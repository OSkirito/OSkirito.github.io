<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1 Introduction 介绍Graphics Areas 图形领域大多数从业人员认同的主要领域： 模型：使用数学描述存储在计算机上的形状或外观属性 渲染：将3D计算机模型创建为着色图像 动画：通过图像序列创造运动效果的技术 用户交互：通过输入设备或应用程序对用户进行图像和其它感官反馈的界面 虚拟现实：让用户沉浸在3D虚拟世界中的技术 可视化：通过可视化显示让用户了解复杂的信息 图像处理：用于">
<meta property="og:type" content="article">
<meta property="og:title" content="Fundamentals Of Computer Graphics 4th">
<meta property="og:url" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/index.html">
<meta property="og:site_name" content="OS&#39;s Blog">
<meta property="og:description" content="1 Introduction 介绍Graphics Areas 图形领域大多数从业人员认同的主要领域： 模型：使用数学描述存储在计算机上的形状或外观属性 渲染：将3D计算机模型创建为着色图像 动画：通过图像序列创造运动效果的技术 用户交互：通过输入设备或应用程序对用户进行图像和其它感官反馈的界面 虚拟现实：让用户沉浸在3D虚拟世界中的技术 可视化：通过可视化显示让用户了解复杂的信息 图像处理：用于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210906101534.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210906102507.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210906110052.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210906105546.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907111227.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907111914.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112035.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112206.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112253.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112640.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112927.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907113058.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907115024.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907115426.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907115119.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907115235.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907124717.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125516.png">
<meta property="og:image" content="c:/Users/86010/AppData/Roaming/Typora/typora-user-images/image-20210907125716158.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125233.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125935.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125944.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125955.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130318.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130337.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130523.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130540.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130550.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907133314.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907133323.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907133334.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907134814.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908111057.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908111224.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908123047.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908152259.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908152314.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908154023.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908152326.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908153107.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908153053.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908153127.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908154640.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908154653.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908154704.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908160645.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908160740.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908161830.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908161841.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908161851.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908161902.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908162655.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908162707.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170008.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170022.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170426.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170435.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170448.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170641.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170650.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170840.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170852.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171218.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171228.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171239.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171848.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171900.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171914.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172322.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172334.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172344.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172828.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172837.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909121458.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909122542.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909122802.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909122828.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909122819.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909124938.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909123607.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909123620.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909124059.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130258.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130309.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130319.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130334.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130343.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909133135.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909133423.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910095400.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910102619.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910104713.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910105656.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910105705.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910105919.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910105951.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910110654.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910110707.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910110951.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910111125.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910111135.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210911103651.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210911103838.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210911105743.png">
<meta property="og:image" content="c:/Users/86010/AppData/Roaming/Typora/typora-user-images/image-20210911110053834.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912091708.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912091734.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912092302.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912095224.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912093756.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912095348.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912100126.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912100649.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912101040.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912101518.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912101636.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102437.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102530.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102540.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102716.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102823.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913103452.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913103652.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913103900.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104319.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104331.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104345.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104710.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104913.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104930.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104941.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913105121.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913105722.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913105732.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913110022.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913110131.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913110149.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913110834.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913111038.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913111812.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913111634.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913112456.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913112507.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913112519.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913122738.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913122200.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913122212.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914132257.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914133203.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914133320.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914133653.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914134040.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914134052.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210915103352.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210915103521.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210915103634.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210915103843.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916104715.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105042.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105236.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105246.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105603.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105616.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105731.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105758.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110021.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110125.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110530.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110356.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110557.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110647.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110659.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916111628.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916111638.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916111855.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916111936.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112037.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112129.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112250.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112335.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112347.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112518.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112743.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112832.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112844.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113455.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113504.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113618.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113632.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113743.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113939.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114058.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114444.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114635.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114646.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114658.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917112255.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124406.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124452.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124534.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124634.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124908.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124926.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124937.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125024.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125102.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125421.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125614.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125623.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125658.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125903.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130133.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130206.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130246.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130448.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130701.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130715.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130724.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130733.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131009.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131119.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131226.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131236.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131246.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131256.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131308.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134407.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134419.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134430.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134441.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134451.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134502.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918103805.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104010.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104019.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104034.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104054.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104043.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104106.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104646.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104656.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104705.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104719.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104733.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104745.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104754.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105214.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105319.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105422.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105432.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105442.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105628.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105640.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105823.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105834.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110125.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110137.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110148.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110530.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110538.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110546.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918113135.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122155.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122221.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122436.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122446.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122956.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123059.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123142.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123534.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123505.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123732.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123745.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123806.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124032.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122824.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124301.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124310.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124408.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124539.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124633.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124643.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124654.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124704.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124852.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124901.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124912.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124921.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124932.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124942.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125458.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125546.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125752.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125802.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125839.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125848.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918130040.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918130051.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919131350.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919131419.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919133120.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919133552.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919135106.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919135502.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919140317.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919140613.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919141502.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919141648.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919141913.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919142144.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919143528.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919145453.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919150249.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919150259.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920110934.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112103.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112214.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112321.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112334.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112345.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112821.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113107.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113121.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113130.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113139.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113151.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920124611.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920130225.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920131502.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920131817.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920131827.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920132445.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920132432.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920132415.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920132612.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920134719.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920134907.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920134940.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920135529.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920135634.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920135730.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920135819.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111149.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111314.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111553.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111606.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111745.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111756.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111834.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111844.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111939.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111952.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112154.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112203.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112404.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112514.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112730.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112958.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113151.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113305.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113315.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113503.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113702.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113711.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113934.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114158.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114324.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114342.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114424.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114505.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104158.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104219.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104230.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104241.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104254.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104637.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104646.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104745.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104803.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923095933.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923104351.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923104413.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923104824.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923104932.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105044.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105635.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105742.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105752.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105912.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923110431.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923110634.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923110737.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923110846.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923111110.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923111407.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923111551.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923111609.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112055.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112330.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112619.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112806.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112928.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113253.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113306.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113317.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113325.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113336.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923114158.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923114209.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923114643.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923115137.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923115159.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923115210.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923115221.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923120147.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923120520.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210924100325.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210924101810.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210924101907.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925130536.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925130810.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132339.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132426.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132434.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132710.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132722.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925133023.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925133147.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925133157.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925133931.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925134527.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925134538.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925134608.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925134746.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925135859.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925140020.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925140422.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925140600.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925140750.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141121.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141159.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141208.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141220.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141657.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141758.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141903.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141949.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141959.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142102.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142353.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142714.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142831.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142843.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143044.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143101.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143517.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143526.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143631.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143817.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143831.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143842.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144018.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144347.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144443.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144454.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144529.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144615.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144735.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144745.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123550.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123749.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123758.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123808.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123930.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123939.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124057.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124107.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124320.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124329.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124339.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124519.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124528.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124616.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124633.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125132.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125623.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125752.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125714.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125821.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130448.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130456.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130711.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130848.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130949.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131008.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131120.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131129.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131314.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131716.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131930.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132154.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132307.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132316.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132447.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132437.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132455.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132718.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132907.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926133423.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926133510.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926133631.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926133835.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926134049.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926134244.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926134521.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926134806.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133340.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133226.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133457.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133645.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133540.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133920.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134153.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134322.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134521.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134510.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134530.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135041.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135133.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135143.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135350.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135453.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135516.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135527.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135535.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135843.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135851.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140327.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140436.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140446.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140830.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140917.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140930.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927141358.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927141628.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142632.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142643.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142730.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142844.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142852.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143030.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143134.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143142.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143232.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143558.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143827.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202344.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202508.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202518.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202608.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202801.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202752.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202831.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202940.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202839.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203119.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203129.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203458.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203509.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203129.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203931.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203941.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203951.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927204323.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927204332.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927204341.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927204353.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105402.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105550.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105521.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105836.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105938.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929110016.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929110842.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111052.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111209.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111305.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111357.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111408.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111758.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111829.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112018.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111957.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112312.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112406.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112455.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112711.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112800.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112912.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929113329.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929113402.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929113440.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114000.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114152.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114221.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114723.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114732.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929115503.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929115808.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929115819.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929120204.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930135235.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930135422.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930135434.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930135614.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930140210.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930140445.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930140701.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141221.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141235.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141249.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141457.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141746.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930142138.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930142458.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930142925.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930142942.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930143035.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930143203.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102252.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102307.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102319.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102351.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102825.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102836.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102854.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102906.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103000.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103217.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103304.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103732.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103756.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103743.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103809.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001104828.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001105003.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001105300.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001105532.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001105637.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110225.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110236.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110409.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110445.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110541.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001115310.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001115423.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001115521.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001115607.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125210.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125607.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125704.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125716.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125810.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125925.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130017.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130048.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130059.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130438.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130455.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130809.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130819.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130914.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131124.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131311.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131157.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131211.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131436.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100427.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100624.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100702.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100718.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100844.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101055.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101139.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101447.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101833.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101954.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102004.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102018.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102218.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102450.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102620.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102734.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102743.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102753.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102804.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102926.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102937.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102946.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102956.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103506.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103515.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103706.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103900.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103956.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104016.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104027.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104126.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104158.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104424.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104636.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104835.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104845.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105430.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105538.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105439.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105759.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105821.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105830.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003101858.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003101817.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102227.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102512.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102527.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102808.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102953.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102944.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103003.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103013.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103022.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103034.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103612.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103649.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103743.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103756.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103806.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103820.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103829.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104215.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104226.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104236.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104244.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104253.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104301.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104605.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104850.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104901.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105125.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105648.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105658.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105709.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105720.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110119.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110129.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110139.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110321.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110333.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110729.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110739.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110749.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004145831.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004145936.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004145945.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150156.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150314.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150413.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150422.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150506.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150515.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150713.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150744.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150831.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150841.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004151020.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004151219.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004151338.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004151348.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006111721.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006111925.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112423.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112300.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112311.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112435.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112705.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112715.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112842.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112853.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112937.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006113355.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006113734.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006113859.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006113949.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006114041.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006114108.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006131323.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006131336.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006131532.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006131757.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006132047.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006132057.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006132236.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006132331.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007110244.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007110330.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111139.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111246.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111253.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111514.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111522.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111603.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112008.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112019.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112029.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112342.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112354.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112544.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112628.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112801.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112814.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112843.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112856.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112905.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112959.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007113111.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007113120.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007113815.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007113940.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114035.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114335.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114348.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114631.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114644.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007115040.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007115050.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007115059.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124218.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124425.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124514.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124651.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124715.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125044.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125207.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125220.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125438.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125447.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008103422.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008103440.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008103949.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008103959.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104114.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104246.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104552.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104855.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104948.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008105800.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008105820.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008105917.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008105926.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110103.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110112.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110122.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110203.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110211.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110252.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110346.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110541.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110613.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110626.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110740.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110752.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110901.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110944.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110955.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008111733.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008111815.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008111827.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008115339.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008115412.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008115430.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008122610.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008122900.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008122955.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123318.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123726.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123812.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123837.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123924.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123914.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123935.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123954.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008124140.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009110545.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009110659.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009110738.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009110751.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111040.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111050.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111131.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111211.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111229.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111645.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111749.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009112822.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009113014.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009113024.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010103600.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010103610.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010103620.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104658.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104713.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104804.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104814.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104824.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105022.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105031.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105133.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105253.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105409.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105458.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105507.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105516.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105948.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105957.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110006.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110230.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110240.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110259.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110310.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110321.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110331.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110341.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110713.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110723.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110732.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110840.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110850.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111129.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111139.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111159.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111612.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111649.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111658.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111829.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111846.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010112303.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011104409.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011104920.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011104931.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011104942.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011105222.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110152.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110255.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110309.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110320.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110449.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110636.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111515.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111715.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111725.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111740.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111750.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111800.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111926.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111935.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111946.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112027.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112134.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112302.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112528.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112650.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112735.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112745.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112759.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011113445.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011113539.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011114018.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011114628.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011114714.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132249.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132341.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132437.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132532.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132544.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133009.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133135.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133023.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133033.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133615.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133721.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133744.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133754.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133843.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133852.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011134057.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011134352.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011134411.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011134727.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012122313.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123048.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123150.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123541.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123552.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123912.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123924.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012124024.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012132922.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012133022.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012133034.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012133656.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012133835.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134027.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134118.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134225.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134320.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134338.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134406.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134416.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134427.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134437.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134754.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013110938.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013111208.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013111310.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013111912.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112154.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112249.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112259.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112308.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112513.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112856.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013113117.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013113328.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013113718.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110125.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110324.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110344.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110556.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110707.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014112547.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014112903.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014113122.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014113141.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014113200.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211015125830.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211015125846.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211015130223.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211015131612.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016122305.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016122608.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016122824.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016123044.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016123056.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016123154.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016123602.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017140002.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017140244.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017143442.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017143522.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017144408.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017144658.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017144907.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145242.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145305.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145416.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145432.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145608.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145728.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145741.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150409.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150430.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150447.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150530.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150603.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150647.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018131914.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018131958.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132110.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132123.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132301.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132330.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132540.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132617.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132630.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018133310.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018133907.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018133934.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134020.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134541.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134612.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134701.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134712.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135010.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135335.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135421.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135824.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135954.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018140006.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019124105.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019124829.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019124917.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019124902.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125104.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125358.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125421.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125455.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125540.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125651.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125913.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019130140.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019130244.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019131250.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019131751.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019132200.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019132703.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133030.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133041.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133206.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133253.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133304.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133325.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133730.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133741.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133929.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133939.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019134040.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019134646.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019134341.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019134852.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135013.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135025.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135038.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135058.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135109.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135128.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135406.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135417.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141322.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141332.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141418.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141438.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141622.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141631.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142032.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142119.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142129.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142210.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142320.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142428.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020113738.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020113901.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020130721.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020130736.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020130947.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020131246.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020131505.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020131718.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020131813.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132121.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132207.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132307.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132407.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132524.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132554.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132640.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133347.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133433.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133523.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133619.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133730.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133829.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133946.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020134037.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020134323.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020135253.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020135317.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020135501.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020135514.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141102.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141202.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141411.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141511.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141627.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021142347.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021143240.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021143329.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144256.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144402.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144516.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144528.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144713.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144806.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144852.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144949.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145046.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145120.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145152.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145630.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145802.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021150033.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021150120.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021150444.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021150916.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021151005.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021151506.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021152758.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153401.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153731.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153834.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153845.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153934.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021212243.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021212425.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021212653.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021212747.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214205.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214347.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214505.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214602.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214643.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214739.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215010.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215020.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215137.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215431.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215609.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215717.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215938.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220027.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220133.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220239.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220250.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220553.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220609.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220707.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220932.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110407.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110426.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110619.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110831.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110848.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111213.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111227.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111243.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111257.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111309.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111747.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111828.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111939.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111951.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023112151.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023112201.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023121555.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023121614.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122004.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122101.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122238.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122323.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122426.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122539.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024155700.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024160854.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161025.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161102.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161138.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161242.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161416.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161502.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161729.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161855.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161906.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024162022.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024162100.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184342.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184430.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184507.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184547.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184739.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024185016.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024185058.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024185211.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025115817.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025115914.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025120206.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124042.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124144.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124337.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124427.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124656.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025125320.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131353.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131425.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131435.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131854.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131904.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025132127.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025132231.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025132448.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026143933.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026144047.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026144410.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026155317.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026155540.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160139.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160214.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160246.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160456.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160511.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160814.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161140.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161229.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161504.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161621.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161931.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026162031.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026162416.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026162605.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163108.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163257.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163550.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163613.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163910.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163928.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026164300.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026164316.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026164834.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026164956.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026165422.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026165510.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026170039.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026170201.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026170604.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171119.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171321.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171447.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171502.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171703.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027113538.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114108.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114122.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114157.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114254.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114343.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114352.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114446.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114456.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114633.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114708.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114815.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114838.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114849.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114900.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115310.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115335.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115345.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115555.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115707.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115724.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115747.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120040.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120213.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120555.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120625.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120700.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120844.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121745.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121823.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121840.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121850.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121943.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027122121.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027122132.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027122214.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027122508.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028173242.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028173259.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028173705.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028173723.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174256.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174305.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174426.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174439.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174449.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174714.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174722.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174732.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174956.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028175006.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028175258.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028175334.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028175549.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180047.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180111.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180159.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180248.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180256.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180305.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180828.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180748.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181031.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181041.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181253.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181436.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181447.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028191754.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028191834.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028191914.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028192238.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028192250.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028192451.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028192517.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029163858.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029165909.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029170006.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029170618.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029183652.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184059.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184120.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184455.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184508.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184955.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029185010.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029185024.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029185037.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029185551.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029190132.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029235929.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029235951.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105033.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105453.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105754.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105807.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105906.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030110331.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030110428.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030110927.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030111550.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030111743.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030111922.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112010.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112112.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112632.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112924.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112955.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030121341.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030123651.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030123706.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124114.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124125.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124136.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124412.png">
<meta property="og:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124540.png">
<meta property="article:published_time" content="2023-05-05T11:38:19.631Z">
<meta property="article:modified_time" content="2023-05-21T09:52:37.475Z">
<meta property="article:author" content="OSkirito">
<meta property="article:tag" content="图形学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210906101534.png">

<link rel="canonical" href="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Fundamentals Of Computer Graphics 4th | OS's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OS's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">41</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Fundamentals Of Computer Graphics 4th
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-05 19:38:19" itemprop="dateCreated datePublished" datetime="2023-05-05T19:38:19+08:00">2023-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-21 17:52:37" itemprop="dateModified" datetime="2023-05-21T17:52:37+08:00">2023-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-Introduction-介绍"><a href="#1-Introduction-介绍" class="headerlink" title="1 Introduction 介绍"></a>1 Introduction 介绍</h1><h2 id="Graphics-Areas-图形领域"><a href="#Graphics-Areas-图形领域" class="headerlink" title="Graphics Areas 图形领域"></a>Graphics Areas 图形领域</h2><p><strong>大多数从业人员认同的主要领域：</strong></p>
<p><strong>模型：使用数学描述存储在计算机上的形状或外观属性</strong></p>
<p><strong>渲染：将3D计算机模型创建为着色图像</strong></p>
<p><strong>动画：通过图像序列创造运动效果的技术</strong></p>
<p><strong>用户交互：通过输入设备或应用程序对用户进行图像和其它感官反馈的界面</strong></p>
<p><strong>虚拟现实：让用户沉浸在3D虚拟世界中的技术</strong></p>
<p><strong>可视化：通过可视化显示让用户了解复杂的信息</strong></p>
<p><strong>图像处理：用于图形和视觉领域的2D图像的操作</strong></p>
<p><strong>3D扫描：使用测距技术来刨建3D模型</strong></p>
<h2 id="Major-Applications-主要应用"><a href="#Major-Applications-主要应用" class="headerlink" title="Major Applications 主要应用"></a>Major Applications 主要应用</h2><p><strong>影视游戏</strong></p>
<p><strong>动画</strong></p>
<p><strong>视觉效果</strong></p>
<p><strong>动画电影</strong></p>
<p><strong>CAD/CAM（计算机辅助设计和计算机辅助制造的缩写）</strong></p>
<p><strong>模拟</strong></p>
<p><strong>医学成像</strong></p>
<p><strong>信息可视化</strong></p>
<h2 id="Graphics-APIs-图形APIs"><a href="#Graphics-APIs-图形APIs" class="headerlink" title="Graphics APIs 图形APIs"></a>Graphics APIs 图形APIs</h2><p><strong><em>application program interface</em> （程序接口API)用于执行集合的标准函数集合，图形API是一组执行基本操作的函数操作。每个图形程序都需要能够使用两个相关的API:用于可视化输出的API和用于从用户获取输入的用户界面API。 目前有两种主要的图形和用户界面API范例：一直是集成方法； 第二个是用Direct3D和OpenGL，在OpenGL中，绘图命令是与c++这样的语言绑定的软件库的一部分，用户界面软件是一个会因系统而异的独立实体。（在后一种方法中，它是有问题的要编写可移植代码，尽管对于简单的程序，可以使用可移植库层来封装特定于系统的用户界面代码。）无论选择什么API，基本的图形调用基本上都是一样的。</strong></p>
<h2 id="Graphics-Pipeline-图形管线"><a href="#Graphics-Pipeline-图形管线" class="headerlink" title="Graphics Pipeline 图形管线"></a>Graphics Pipeline 图形管线</h2><p><strong>这是一个特殊的软件/硬件子系统，它可以有效地绘制透视图中的3D元素。通常，这些系统用于优化处理具有共享顶点的3D三角形。管线的基本操作是将3D顶点位置映射到2D屏幕位置，并给三角形着色，以便它们看起来都很真实，并以适当的前后顺序显示。（但现在几乎总是使用z缓冲区来解决，它使用一个特殊的内存缓冲区以蛮力的方式来解决问题。）</strong></p>
<p><strong>在图形管线中使用的几何操作几乎可以完全在一个由三个传统几何坐标和一个有助于透视的第四次齐次坐标组成的4D坐标空间中完成。这些四维坐标是用4 × 4矩阵和4-向量操作的。因此，图形管道包含了许多有效处理和组合这些矩阵和向量的机器。</strong></p>
<p><strong>图像生成的速度很大程度上取决于绘制的三角形的数量。因为在许多应用中，交互性比视觉质量更重要，所以最小化用于表示模型的三角形数量是值得的。此外，如果从远处观察模型，需要的三角形比从较近的距离观察模型时要少。这表明用不同的细节级别(LOD)来表示模型是有用的。</strong></p>
<h2 id="Numerical-Issues-数学问题"><a href="#Numerical-Issues-数学问题" class="headerlink" title="Numerical Issues 数学问题"></a>Numerical Issues 数学问题</h2><p><strong>IEEE浮点数中三个实数“特殊值”：</strong></p>
<p><strong>无穷(∞)：这是一个比所有其他有效数都大的有效数。</strong></p>
<p><strong>负无穷(−∞)：这是一个比所有其他有效数都小的有效数。</strong></p>
<p><strong>不是数字(NaN)：这是一个无效的数，由结果未定义的操作产生，例如0除以0。</strong></p>
<p><strong>涉及无穷值的规则：</strong></p>
<p>​    <strong>对于任何正实数a，</strong></p>
<p>​    <strong>+a/(+∞) = +0,</strong> </p>
<p>​    <strong>−a/(+∞) = −0,</strong> </p>
<p>​    <strong>+a/(−∞) = −0,</strong> </p>
<p>​    <strong>−a/(−∞) = +0.</strong></p>
<p>​    <strong>对于正a，</strong></p>
<p>​    <strong>∞ + ∞ = +∞,</strong> </p>
<p>​    <strong>∞−∞ = NaN,</strong> </p>
<p>​    <strong>∞×∞ = ∞,</strong> </p>
<p>​    <strong>∞/∞ = NaN,</strong></p>
<p>​    <strong>∞/a = ∞,</strong></p>
<p>​    <strong>∞/0 = ∞,</strong> </p>
<p>​    <strong>0/0 = NaN.</strong></p>
<p><strong>包含无穷值的布尔表达式规则：</strong></p>
<p>​    <strong>1.所有有限有效数都小于+∞。</strong></p>
<p>​    <strong>2.所有有限有效数都大于-∞。</strong></p>
<p>​    <strong>3.−∞小于+∞。</strong></p>
<p><strong>涉及NaN值的规则：</strong></p>
<p>​    <strong>1.任何包含NaN的算术表达式的结果都是NaN。</strong></p>
<p>​    <strong>2.任何涉及NaN的布尔表达式都是假的。</strong></p>
<p><strong>IEEE浮点数对0有两种表示，一种被视为正的，一种被视为负的。对于任何正实数a，用零除的规则是成立的:</strong></p>
<p>​    <strong>+a/ +0 = +∞,</strong> </p>
<p>​    <strong>−a/ +0 = −∞.</strong></p>
<p><strong>使用IEEE规则，能使得程序更小、更健壮、更高效。</strong></p>
<h2 id="Efficiency-效率"><a href="#Efficiency-效率" class="headerlink" title="Efficiency 效率"></a>Efficiency 效率</h2><p><strong>效率是通过仔细的权衡来实现的，而这些权衡对于不同的体系结构是不同的。程序员应该更多地关注内存访问模式而不是操作计数。（发生这种切换是因为内存的速度没有跟上处理器的速度。由于这种趋势仍在继续，有限的、一致的内存访问对优化的重要性只会增加。）</strong></p>
<p><strong>使代码快速的一个合理方法是按照以下顺序进行，只采取那些需要的步骤:</strong></p>
<p>​    <strong>1.以最直接的方式编写代码。根据需要动态计算中间结果，而不是存储它们。</strong></p>
<p>​    <strong>2.在优化模式下进行编译。</strong></p>
<p>​    <strong>3.使用任何现有的分析工具来找到关键的瓶颈。</strong></p>
<p>​    <strong>4.检查数据结构以寻找改进局部性的方法。如果可能，使数据单元大小与目标体系结构上的缓存/页面大小相匹配。</strong></p>
<p>​    <strong>5.如果分析揭示了数值计算中的瓶颈，请检查编译器生成的程序集代码，以确定未达到的效率。重写源代码以解决发现的任何问题。</strong></p>
<p><strong>这些步骤中最重要的是第一步。大多数“优化”使代码难以阅读，而不会加快速度。此外，将优化代码的时间花在纠正bug或添加功能上通常会更好。在所有情况下，都需要进行分析，以确定针对特定机器和编译器的任何优化的优点。</strong></p>
<h2 id="Designing-and-Coding-Graphics-Programs-设计与编码图形程序"><a href="#Designing-and-Coding-Graphics-Programs-设计与编码图形程序" class="headerlink" title="Designing and Coding Graphics Programs 设计与编码图形程序"></a>Designing and Coding Graphics Programs 设计与编码图形程序</h2><h3 id="Class-Design-类设计"><a href="#Class-Design-类设计" class="headerlink" title="Class Design 类设计"></a>Class Design 类设计</h3><p><strong>需要编写的一些基本类:</strong></p>
<p>​    <strong>vector2：存储x和y分量的2D向量类。它应该将这些组件存储在长度为2的数组中，以便能够很好地支持索引操作符。还应包括向量加法、向量减法、点积、叉积、标量乘法和标量除法的运算。</strong></p>
<p>​    <strong>vector3：类似于vector2的3D向量类。</strong></p>
<p>​    <strong>hvector：有四个分量的齐次向量。</strong></p>
<p>​    <strong>rgb：RGB颜色，可存储三个组件。还应包括RGB加、RGB减、RGB乘、标量乘和标量除的操作。</strong></p>
<p>​    <strong>变换：一个用于变换的4 × 4矩阵。应包括一个矩阵乘法和成员函数，以应用于位置、方向和表面法向量。</strong></p>
<p>​    <strong>图像：带有输出操作的RGB像素的2D数组。</strong></p>
<p><strong>（也可以为间隔、标准正交基和坐标系添加类。）</strong></p>
<h3 id="Float-vs-Double-单精度VS-双精度"><a href="#Float-vs-Double-单精度VS-双精度" class="headerlink" title="Float vs. Double 单精度VS.双精度"></a>Float vs. Double 单精度VS.双精度</h3><p><strong>降低内存使用和保持一致的内存访问是效率的关键。这就建议使用单精度数据。然而，避免数值问题建议使用双精度算术。权衡取决于程序，但是最好在类定义中有一个默认值。建议使用单精度进行所有计算，直到发现代码的特定部分需要双精度。建议几何计算使用双精度，颜色计算使用单精度。对于占用大量内存的数据，如三角形网格，建议存储单精度数据，但通过成员函数访问数据时转换为双精度。</strong></p>
<h3 id="Debugging-Graphics-Programs-调试图形程序"><a href="#Debugging-Graphics-Programs-调试图形程序" class="headerlink" title="Debugging Graphics Programs 调试图形程序"></a>Debugging Graphics Programs 调试图形程序</h3><h4 id="The-Scientific-Method-科学方法"><a href="#The-Scientific-Method-科学方法" class="headerlink" title="The Scientific Method 科学方法"></a>The Scientific Method 科学方法</h4><p><strong>创建一个图像，并观察它有什么问题。然后，提出一个关于问题原因的假设，并对其进行检验。</strong></p>
<h4 id="Images-as-Coded-Debugging-Output-图像编码调试输出"><a href="#Images-as-Coded-Debugging-Output-图像编码调试输出" class="headerlink" title="Images as Coded Debugging Output 图像编码调试输出"></a>Images as Coded Debugging Output 图像编码调试输出</h4><p><strong>从在图形程序中直接输出图像本身。例如，如果怀疑表面法线的问题导致阴影的问题，直接复制法向量图像(y x→红色,绿色,z去蓝色),导致实际使用彩色插图的向量计算。或者，如果怀疑某个特定值有时超出了其有效范围，则让程序在发生这种情况时编写亮红色像素。其他常见的技巧包括用明显的颜色绘制表面的背面(当它们不应该是可见的)，根据物体的ID号给图像上色，或者根据计算的工作量给像素上色。</strong></p>
<h4 id="Using-a-Debugger-使用调试器"><a href="#Using-a-Debugger-使用调试器" class="headerlink" title="Using a Debugger 使用调试器"></a>Using a Debugger 使用调试器</h4><p><strong>确保程序是确定性的——在一个线程中运行它，并确保所有的随机数都是从固定的种子中计算出来的。然后，找出哪个像素或三角形显示了bug，并在怀疑错误的代码之前添加一条语句，该语句只会在怀疑的情况下执行。</strong></p>
<p><strong>在程序崩溃的情况下，传统调试器可以用来确定崩溃的位置。然后，应该在程序中开始回溯，使用断言和重新编译，以找到程序出错的地方。这些断言应该留在程序中，以防止将来添加的潜在错误。（这意味着要避免传统的分步处理，因为这不会为您的程序添加有价值的断言。）</strong></p>
<h4 id="Data-Visualization-for-Debugging-调试数据可视化"><a href="#Data-Visualization-for-Debugging-调试数据可视化" class="headerlink" title="Data Visualization for Debugging 调试数据可视化"></a>Data Visualization for Debugging 调试数据可视化</h4><p><strong>为自己绘制良好的图表和插图，以理解数据的含义。花在编写代码来可视化程序内部状态上的时间，在优化程序时也能更好地理解程序的行为。</strong></p>
<h1 id="2-Miscellaneous-Math-基础数学"><a href="#2-Miscellaneous-Math-基础数学" class="headerlink" title="2 Miscellaneous Math 基础数学"></a>2 Miscellaneous Math 基础数学</h1><h3 id="Sets-and-Mappings-集合与映射"><a href="#Sets-and-Mappings-集合与映射" class="headerlink" title="Sets and Mappings 集合与映射"></a>Sets and Mappings 集合与映射</h3><p><strong>映射，也称为函数，是数学和编程的基础。在程序中，我们说” type “;在数学中，我们叫做集合。常用的集合有：</strong><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210906101534.png" class="" title="image-20210906101534"></p>
<p>​    <strong>实数集;</strong></p>
<p>​    <strong>非负实数集(包括0);</strong></p>
<p>​    <strong>真实2D平面中的有序对;</strong></p>
<p>​    <strong>n维笛卡尔空间中的点;</strong></p>
<p>​    <strong>整数集;</strong></p>
<p>​    <strong>三维点(点为3D有序对)在单位球面上的集合。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210906102507.png" class="" title="image-20210906102507">

<p><em>整数f（实数）等同于f:R→Z，R叫做函数的定义域，Z叫做目标。点f（a）称为a的图像，且集合a的图像包括a中所有点的目标的子集。</em></p>
<p><strong>整个定义域的图像称为函数的值域。</strong></p>
<h4 id="逆函数-映射"><a href="#逆函数-映射" class="headerlink" title="逆函数/映射"></a><strong>逆函数/映射</strong></h4><p><strong>有一个函数f：A→B，可能存在一个逆函数f－¹:B→A(详细定义略)，满足所有元素一一对应关系的映射或函数被称为双射，非双射的函数没有逆函数，如下图：</strong></p>
<h4 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h4><p><strong>开闭区间及集合运算（不做赘述）</strong></p>
<h4 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210906110052.png" class="" title="image-20210906110052">

<p><strong>以a为底的对数和以a为底的指数是互逆的。所以有几个性质：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210906105546.png" class="" title="image-20210906105546">



<h2 id="Solving-Quadratic-Equations-求解二次方程"><a href="#Solving-Quadratic-Equations-求解二次方程" class="headerlink" title="Solving Quadratic Equations 求解二次方程"></a>Solving Quadratic Equations 求解二次方程</h2><p><strong>根的判别式△=b²-4ac（剩下的不必多说），求根公式x=（-b±√△）/2a</strong></p>
<h2 id="Trigonometry-三角函数"><a href="#Trigonometry-三角函数" class="headerlink" title="Trigonometry 三角函数"></a>Trigonometry 三角函数</h2><h3 id="Angles-角度"><a href="#Angles-角度" class="headerlink" title="Angles 角度"></a>Angles 角度</h3><p><strong>角度和弧度的转换：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907111227.png" class="" title="image-20210907111227">

<h3 id="Trigonometric-Functions-三角函数"><a href="#Trigonometric-Functions-三角函数" class="headerlink" title="Trigonometric Functions 三角函数"></a>Trigonometric Functions 三角函数</h3><p><strong>sin、cos、tan等三角函数</strong></p>
<h3 id="Useful-Identitie-有用的公式"><a href="#Useful-Identitie-有用的公式" class="headerlink" title="Useful Identitie 有用的公式"></a>Useful Identitie 有用的公式</h3><p><strong>三角恒等变换：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907111914.png" class="" title="image-20210907111914">

<p><strong>毕达哥拉斯等式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112035.png" class="" title="image-20210907112035">

<p><strong>加减恒等式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112206.png" class="" title="image-20210907112206">

<p><strong>半角公式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112253.png" class="" title="image-20210907112253">

<p><strong>积化和差公式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112640.png" class="" title="image-20210907112640">

<p><strong>正弦定理、余弦定理、正切定理：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112927.png" class="" title="image-20210907112927">

<p><strong>面积公式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907113058.png" class="" title="image-20210907113058">

<h2 id="Vectors-向量"><a href="#Vectors-向量" class="headerlink" title="Vectors 向量"></a>Vectors 向量</h2><h3 id="Vector-Operations-向量操作"><a href="#Vector-Operations-向量操作" class="headerlink" title="Vector Operations 向量操作"></a>Vector Operations 向量操作</h3><p><strong>向量的基本加减法则</strong></p>
<h3 id="Cartesian-Coordinates-of-a-Vector-向量的笛卡尔坐标"><a href="#Cartesian-Coordinates-of-a-Vector-向量的笛卡尔坐标" class="headerlink" title="Cartesian Coordinates of a Vector 向量的笛卡尔坐标"></a>Cartesian Coordinates of a Vector 向量的笛卡尔坐标</h3><p><strong>向量的拆分</strong></p>
<p><strong>一个二维向量可以写成任意两个不平行的非零向量的组合。这两个向量的性质称为线性无关。两个线性无关的向量构成一个二维基，因此这些向量被称为基向量。</strong></p>
<h3 id="Dot-Product-点乘-内积"><a href="#Dot-Product-点乘-内积" class="headerlink" title="Dot Product 点乘/内积"></a>Dot Product 点乘/内积</h3><p><strong>向量的点乘（结果是一个数）：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907115024.png" class="" title="image-20210907115024">

<p><strong>一般的计算方法：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907115426.png" class="" title="image-20210907115426">

<p><strong>向量的投影</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907115119.png" class="" title="image-20210907115119">

<p><strong>点乘遵循结合律和分配律:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907115235.png" class="" title="image-20210907115235">

<h3 id="Cross-Product-叉乘-外积"><a href="#Cross-Product-叉乘-外积" class="headerlink" title="Cross Product 叉乘/外积"></a>Cross Product 叉乘/外积</h3><p><strong>向量的叉乘（结果为一个向量）：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907124717.png" class="" title="image-20210907124717">

<p><strong>一般的计算方法：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125516.png" class="" title="image-20210907125516">

<p><strong>其方向由右手定则决定：</strong></p>
<p><img src="C:\Users\86010\AppData\Roaming\Typora\typora-user-images\image-20210907125716158.png" alt="image-20210907125716158"></p>
<p><strong>把你的右手掌放在a和b连接处，四指沿a指向b，拇指所指为a × b的方向。</strong></p>
<p><strong>对于笛卡尔坐标</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125233.png" class="" title="image-20210907125233">

<p><strong>叉乘的性质：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125935.png" class="" title="image-20210907125935">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125944.png" class="" title="image-20210907125944">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125955.png" class="" title="image-20210907125955">

<h3 id="Orthonormal-Bases-and-Coordinate-Frames-标准正交基底和坐标系"><a href="#Orthonormal-Bases-and-Coordinate-Frames-标准正交基底和坐标系" class="headerlink" title="Orthonormal Bases and Coordinate Frames 标准正交基底和坐标系"></a>Orthonormal Bases and Coordinate Frames 标准正交基底和坐标系</h3><p><strong>任何由两个二维向量u和v组成的集合，只要它们是正交的(在直角处)并且每个都是单位长度，就构成一个标准正交基。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130318.png" class="" title="image-20210907130318">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130337.png" class="" title="image-20210907130337">

<p><strong>在三维空间中，三个向量u v和w构成一个标准正交基。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130523.png" class="" title="image-20210907130523">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130540.png" class="" title="image-20210907130540">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130550.png" class="" title="image-20210907130550">

<p><strong>注意笛卡尔标准正交基只是无穷多个可能的标准正交基中的一个。它的特殊之处在于它及其隐式的原点位置用于程序中的低级表示。因此，向量x、y和z永远不会被显式存储，正则原点位置o也不会被存储。全局模型通常存储在这个正则坐标系中，因此它通常被称为全局坐标系。但是，如果我们想要用另一个原点是p和标准正交基向量的坐标系u, v, w，然后我们明确地存储这些向量。这样的系统叫做参照系或坐标系。</strong></p>
<h3 id="Constructing-a-Basis-from-a-Single-Vector-单个向量构造基向量"><a href="#Constructing-a-Basis-from-a-Single-Vector-单个向量构造基向量" class="headerlink" title="Constructing a Basis from a Single Vector 单个向量构造基向量"></a>Constructing a Basis from a Single Vector 单个向量构造基向量</h3><p><strong>给定一个向量a，我们想要一个标准正交的u, v, w，首先使w为a方向上的单位矢量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907133314.png" class="" title="image-20210907133314">

<p><strong>然后选择任意不与w共线的向量t，用叉乘得到垂直于w的单位向量u:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907133323.png" class="" title="image-20210907133323">

<p><strong>最后使用右手定则，得到单位向量v：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907133334.png" class="" title="image-20210907133334">

<h3 id="Constructing-a-Basis-from-Two-Vectors-两个向量构造基向量"><a href="#Constructing-a-Basis-from-Two-Vectors-两个向量构造基向量" class="headerlink" title="Constructing a Basis from Two Vectors 两个向量构造基向量"></a>Constructing a Basis from Two Vectors 两个向量构造基向量</h3><p><strong>如果已知这两个向量是垂直的，那么可以简单地用u = b × a来构造第三个向量。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907134814.png" class="" title="image-20210907134814">

<p><strong>当a和b不是垂直的时候，w将沿着a的方向构造，而v被选为所有垂直于w的向量中离b最近的向量。</strong></p>
<p><strong>让w平行于相机所观察的方向，而v应该指向相机的顶部。为了使相机垂直，我们围绕视图方向建立基础，使用直线方向作为参考向量来建立相机围绕视图方向的方向。将v设置得尽可能接近垂直，这与“保持相机垂直”的直观概念完全吻合。</strong></p>
<h3 id="Squaring-Up-a-Basis-修正基向量"><a href="#Squaring-Up-a-Basis-修正基向量" class="headerlink" title="Squaring Up a Basis 修正基向量"></a>Squaring Up a Basis 修正基向量</h3><p><strong>偶尔你可能会发现在你的计算中由一个标准正态的基引起的问题，但由于计算中的舍入误差，或基被存储在一个低精度的文件中。</strong></p>
<p><strong>可以简单地用现有的w和v向量重新构造基将会产生一个新的标准正交的基并且接近于旧的基。</strong></p>
<p><strong>这种方法对许多应用程序都很好，但它不是可用的最佳方法。它确实能产生精确的正交向量，而且对于几乎正交的起点，结果不会离起点太远。然而，它是不对称的:它“偏爱”w比v和v比u(其初始值被丢弃)。它选择一个接近起始基的基，但不能保证选择最接近的标准正交基。当这还不够好时，可以使用SVD来计算一个标准正交基，该基保证最接近原始基。</strong></p>
<h2 id="Curves-and-Surfaces-曲线和曲面"><a href="#Curves-and-Surfaces-曲线和曲面" class="headerlink" title="Curves and Surfaces 曲线和曲面"></a>Curves and Surfaces 曲线和曲面</h2><h3 id="2D-Implicit-Curves-2D隐式曲线"><a href="#2D-Implicit-Curves-2D隐式曲线" class="headerlink" title="2D Implicit Curves 2D隐式曲线"></a>2D Implicit Curves 2D隐式曲线</h3><p><strong>描述曲线的常用方法是使用隐式方程。二维的隐式方程有这样的形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908111057.png" class="" title="image-20210908111057">

<p><strong>注意，f(x, y) = c是任意常数c的曲线，c = 0只是作为惯例使用。</strong></p>
<p><strong>我们可以用向量来压缩符号。如果已知c = (xc, yc)和p = (x, y)，那么以c为圆心，半径为r的圆由满足条件的位置向量定义</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908111224.png" class="" title="image-20210908111224">

<p><strong>如果在代数上展开，但更容易看出这是一个圆的方程，上面可以理解为“圆上的p点离圆心c点的距离为r”。（这说明方程的矢量形式通常比包含x和y的完全笛卡尔形式更具有几何和直观意义。因此，如果可能，通常建议使用矢量形式。此外，您可以在代码中支持vector类;当使用向量形式时，代码会更清晰。面向矢量的方程在实现中也更不容易出错:一旦在代码中实现并调试矢量类型，涉及x、y和z的剪切和粘贴错误就会消失。习惯这些方程中的向量需要一点时间，但一旦你掌握了窍门，回报就会很大。）</strong></p>
<h3 id="The-2D-Gradient-2D梯度"><a href="#The-2D-Gradient-2D梯度" class="headerlink" title="The 2D Gradient 2D梯度"></a>The 2D Gradient 2D梯度</h3><p><strong>如果我们把函数f(x, y)看作一个高度场，高度为f(x, y)，梯度向量指向上斜率最大的方向，即指向山顶。梯度向量∇f(x, y)：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908123047.png" class="" title="image-20210908123047">

<p><strong>作为梯度的一个例子，考虑隐圆x² + y² − 1 = 0，带有梯度向量(2x, 2y)。注意，梯度向量的长度可能取决于隐式方程中的乘数。例如，单位圆Ax² + Ay² − A = 0对于任意非零A, A = 0。此曲线的梯度为(2Ax, 2Ay)，其与圆的法线(垂直)，但其长度由a决定。对于A &gt; 0，法线将从圆指向外，对于A &lt; 0，法线将指向内。这种由外向向内的转换是正常的，因为正区域在圆内转换。在高度场视图中，h = Ax² + Ay² − A，圆处于零高度。对于A &gt; 0，圆包含一个凹点，对于A &lt; 0，圆包含一个凸点。当A变得更负时，凸起的高度增加，但h = 0的圆没有改变。最大上坡方向不变，但坡度增大。坡度的长度反映了坡度程度的变化。所以直观上，你可以把梯度的方向看成是向上的它的大小是衡量斜率向上的程度的。</strong></p>
<h4 id="Implicit-2D-Lines-隐式直线"><a href="#Implicit-2D-Lines-隐式直线" class="headerlink" title="Implicit 2D Lines 隐式直线"></a>Implicit 2D Lines 隐式直线</h4><p><strong>直线的一般表示（但发现其无法表示常值函数）：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908152259.png" class="" title="image-20210908152259">

<p><strong>通过梯度向量的引入，可表示更一般的：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908152314.png" class="" title="image-20210908152314">

<p><strong>将其转化为单位向量的形式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908154023.png" class="" title="image-20210908154023">

<p><strong>相应的，可以将其转化为斜切式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908152326.png" class="" title="image-20210908152326">

<p><strong>点到直线的距离（为梯度向量k（A,B）的长度）：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908153107.png" class="" title="image-20210908153107">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908153053.png" class="" title="image-20210908153053">

<p><strong>对于(x, y) + k(A, B)点，f(x, y) = Ax + By + C是f(x + kA, y + kB) = Ax + kA² + By + kB² + C = k(A² + B²)，直线Ax + By + C = 0到点(a, b)的带符号距离为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908153127.png" class="" title="image-20210908153127">

<h4 id="Implicit-Quadric-Curve-隐式二次曲线"><a href="#Implicit-Quadric-Curve-隐式二次曲线" class="headerlink" title="Implicit Quadric Curve 隐式二次曲线"></a>Implicit Quadric Curve 隐式二次曲线</h4><p><strong>二次曲线的一般式（包括椭圆和双曲线，以及特殊情况下的抛物线、圆和直线。）：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908154640.png" class="" title="image-20210908154640">

<p><strong>圆心为(xc，yc)和半径r，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908154653.png" class="" title="image-20210908154653">

<p><strong>在(xc，yc)为中心，a和b为长半轴和短半轴的椭圆，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908154704.png" class="" title="image-20210908154704">

<h3 id="3D-Implicit-Surfaces-3D隐式曲面"><a href="#3D-Implicit-Surfaces-3D隐式曲面" class="headerlink" title="3D Implicit Surfaces 3D隐式曲面"></a>3D Implicit Surfaces 3D隐式曲面</h3><p><strong>用向量表示法，我们将p = (x, y, z)的函数写成，f(p)=0。</strong></p>
<h3 id="Surface-Normal-to-an-Implicit-Surface-隐式曲面的曲面法线"><a href="#Surface-Normal-to-an-Implicit-Surface-隐式曲面的曲面法线" class="headerlink" title="Surface Normal to an Implicit Surface 隐式曲面的曲面法线"></a>Surface Normal to an Implicit Surface 隐式曲面的曲面法线</h3><p><strong>表面法线是垂直于表面的矢量(这是光照计算所必需的)。表面上的每一点都可以有一个不同的法向量。同理，梯度为二维的隐式曲线提供了一条法线，隐式曲面上点p处的法线由隐式函数的梯度得出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908160645.png" class="" title="image-20210908160645">

<p><strong>其理由与二维情况相同:梯度指向f增长最快的方向，f垂直于与曲面相切的所有方向，其中f保持不变。梯度向量指向曲面f(p) &gt; 0的一侧，在给定的上下文中，我们可以认为它是“进入”曲面或“离开”曲面。如果f的特殊形式创建面向内的梯度，而需要面向外的梯度，则−f(p) = 0表面与f(p) = 0表面相同，但具有方向相反的梯度，即，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908160740.png" class="" title="image-20210908160740">

<h3 id="Implicit-Planes-隐式平面"><a href="#Implicit-Planes-隐式平面" class="headerlink" title="Implicit Planes 隐式平面"></a>Implicit Planes 隐式平面</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908161830.png" class="" title="image-20210908161830">

<p><strong>点p在包含点a的且法向量为n的平面内，描述平面的隐式方程</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908161841.png" class="" title="image-20210908161841">

<p><strong>通过点(a, b, c)的平面的法向量可以通过求平面上任意两个向量的外积来求，平面的法向量n为，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908161851.png" class="" title="image-20210908161851">

<p><strong>得到隐式平面方程：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908161902.png" class="" title="image-20210908161902">

<h4 id="3D-Quadric-Surfaces-3D二次曲面"><a href="#3D-Quadric-Surfaces-3D二次曲面" class="headerlink" title="3D Quadric Surfaces 3D二次曲面"></a>3D Quadric Surfaces 3D二次曲面</h4><p><strong>球体可写成，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908162655.png" class="" title="image-20210908162655">

<p><strong>椭球体可写成，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908162707.png" class="" title="image-20210908162707">

<h4 id="3D-Curves-from-Implicit-Surfaces-3D隐式表面的曲线"><a href="#3D-Curves-from-Implicit-Surfaces-3D隐式表面的曲线" class="headerlink" title="3D Curves from Implicit Surfaces 3D隐式表面的曲线"></a>3D Curves from Implicit Surfaces 3D隐式表面的曲线</h4><p><strong>由两个联立隐式方程的交点可以构造出一条三维曲线，然而，所有这些曲线都只是退化曲面，在实践中很少有用。</strong></p>
<h3 id="2D-Parametric-Curves-2D参数曲线"><a href="#2D-Parametric-Curves-2D参数曲线" class="headerlink" title="2D Parametric Curves 2D参数曲线"></a>2D Parametric Curves 2D参数曲线</h3><p><strong>参数曲线是由单个参数控制的，该参数可被视为一种沿着曲线连续运动的指标。这样的曲线有其形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170008.png" class="" title="image-20210908170008">

<p><strong>这里(x, y)是曲线上的一点，而t是影响曲线的参数。对于给定的t，会有一个由函数g和h决定的点。对于连续的g和h, t的微小变化会产生x和y的微小变化。因此，当t连续变化时，点在连续曲线上被扫走。这是一个很好的特性，因为我们可以使用参数t来显式地构造曲线上的点。通常我们可以把参数曲线写成矢量形式，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170022.png" class="" title="image-20210908170022">

<p><strong>其中f是一个向量值函数，f : R → R²。我们可以把位置看作是时间的函数。曲线可以是任意的，可以是循环的，可以是交叉的。我们也可以把曲线看成是任意一点的速度。</strong></p>
<h4 id="2D-Parametric-Lines-2D参数直线"><a href="#2D-Parametric-Lines-2D参数直线" class="headerlink" title="2D Parametric Lines 2D参数直线"></a>2D Parametric Lines 2D参数直线</h4><p><strong>通过点p的二维参数线</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170426.png" class="" title="image-20210908170426">

<p><strong>矢量形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170435.png" class="" title="image-20210908170435">

<p><strong>参数线也可以用点o和向量d来描述:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170448.png" class="" title="image-20210908170448">

<p><strong>当向量d有单位长度时，直线参数化弧长。这意味着t是直线上距离的精确度量。任何参数曲线都可以进行弧长参数化，这显然是一种非常方便的形式，但并不是所有的曲线都可以进行解析转换。</strong></p>
<h4 id="2D-Parametric-Circles-2D参数圆"><a href="#2D-Parametric-Circles-2D参数圆" class="headerlink" title="2D Parametric Circles 2D参数圆"></a>2D Parametric Circles 2D参数圆</h4><p><strong>圆心为(xc，yc)，半径r为参数形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170641.png" class="" title="image-20210908170641">

<p><strong>为保证曲线上每一点都有唯一的参数φ，可以限定其定域:φ∈[0,2π)或φ∈(- π，π)或任意长度为2π的半开区间。</strong></p>
<p><strong>也可以通过缩放x和y参数来构造一个轴向椭圆:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170650.png" class="" title="image-20210908170650">

<h3 id="3D-Parametric-Curves-3D参数曲线"><a href="#3D-Parametric-Curves-3D参数曲线" class="headerlink" title="3D Parametric Curves 3D参数曲线"></a>3D Parametric Curves 3D参数曲线</h3><p><strong>3D参数曲线的运行方式与2D参数曲线非常相似:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170840.png" class="" title="image-20210908170840">

<p><strong>我们可以写成向量形式,p: R → R³:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170852.png" class="" title="image-20210908170852">

<h4 id="3D-Parametric-Lines-3D参数直线"><a href="#3D-Parametric-Lines-3D参数直线" class="headerlink" title="3D Parametric Lines 3D参数直线"></a>3D Parametric Lines 3D参数直线</h4><p><strong>三维参数线可以写成二维参数线的直接扩展，例如:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171218.png" class="" title="image-20210908171218">

<p><strong>这很麻烦，不能很好地转换为代码变量，所以我们将它写成向量形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171228.png" class="" title="image-20210908171228">

<p><strong>在这个例子中，o和d是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171239.png" class="" title="image-20210908171239">

<h3 id="3D-Parametric-Surfaces-3D参数曲面"><a href="#3D-Parametric-Surfaces-3D参数曲面" class="headerlink" title="3D Parametric Surfaces 3D参数曲面"></a>3D Parametric Surfaces 3D参数曲面</h3><p><strong>定义三维参数曲面：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171848.png" class="" title="image-20210908171848">

<p><strong>矢量形式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171900.png" class="" title="image-20210908171900">

<p><strong>p的导数，得到曲面上任意一点的两个切向量。曲面的法向量可以通过求这两个向量的叉积得到。叉乘的右手法则提供了一种方法来决定哪边是曲面的正面或外部;我们将使用约定向量</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171914.png" class="" title="image-20210908171914">

<p><strong>指向表面的外面。</strong></p>
<h3 id="Summary-of-Curves-and-Surfaces-曲线曲面汇总"><a href="#Summary-of-Curves-and-Surfaces-曲线曲面汇总" class="headerlink" title="Summary of Curves and Surfaces 曲线曲面汇总"></a>Summary of Curves and Surfaces 曲线曲面汇总</h3><p><strong>二维的隐式曲线或三维的曲面由两或三个变量的标量函数f: R²→R或f: R³→R，曲面由函数为零的所有点组成:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172322.png" class="" title="image-20210908172322">

<p><strong>二维或三维的参数曲线由一个变量的向量值函数定义，p: R→R²或R→R³，当t在整个D上变化时，曲线被扫出:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172334.png" class="" title="image-20210908172334">

<p><strong>三维参数曲面是由两个变量的向量值函数定义的p: R²→R³，该曲面由定义域内所有点(u, v)的像构成:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172344.png" class="" title="image-20210908172344">

<p><strong>对于隐式曲线和曲面，法向量由f(梯度)的导数给出，而切向量(曲线)或向量(曲面)可以通过构造基从法向量推导出来。</strong></p>
<p><strong>对于参数曲线和曲面，p的导数给出了(曲线的)切向量或(曲面的)向量，法向量可以通过构造基从切线推导出来。</strong></p>
<h2 id="Linear-Interpolation-线性插值"><a href="#Linear-Interpolation-线性插值" class="headerlink" title="Linear Interpolation 线性插值"></a>Linear Interpolation 线性插值</h2><p><strong>在x轴上的一组位置:x0, x1，…，xn，对于每个xi 我们有一个相关的高度yi。我们想要创建一个连续函数y = f(x)来插值这些位置，因此f会遍历每一个数据点，也就是f (xi) = yi。对于线性插值，点(xi，yi)由直线段连接。对于这些线段，使用参数线方程是很自然的。参数t就是x之间的分数距离xi 和xi+1：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172828.png" class="" title="image-20210908172828">

<p><strong>因为权重函数是x的线性多项式，这是线性插值。</strong></p>
<p><strong>以上两个例子具有线性插值的共同形式。我们创建一个变量t，当我们从数据项a移动到数据项b时，它从0到1变化。中间值就是函数(1−t)A + tB。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172837.png" class="" title="image-20210908172837">

<h2 id="Triangles-三角形"><a href="#Triangles-三角形" class="headerlink" title="Triangles 三角形"></a>Triangles 三角形</h2><p><strong>在许多图形程序中，二维和三维三角形都是基本的建模元素。通常情况下，诸如颜色之类的信息会被标记到三角形顶点上，并且这些信息会被插值到整个三角形上。使这种插值直接的坐标系统称为重心坐标。</strong></p>
<h3 id="2D-Triangles-2D三角形"><a href="#2D-Triangles-2D三角形" class="headerlink" title="2D Triangles 2D三角形"></a>2D Triangles 2D三角形</h3><p><strong>如果我们有一个由2D点a，b，c定义的2D三角形，可以先求出它的面积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909121458.png" class="" title="image-20210909121458">

<p><strong>如果点a, b, c是逆时针的，这个面积就是正号，否则就是负号。</strong></p>
<p><strong>通常在图形中，我们希望在每个三角形顶点上分配一个属性，比如颜色，并在整个三角形上平滑地插入该属性的值。有多种方法可以做到这一点，但最简单的方法是使用重心坐标。将重心坐标看作非正交坐标系的一种，其中坐标原点为a，从a到b和c的向量为基向量。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909122542.png" class="" title="image-20210909122542">

<p><strong>那么任意点p都可以用表示为，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909122802.png" class="" title="image-20210909122802">

<p><strong>定义一个新的变量α，有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909122828.png" class="" title="image-20210909122828">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909122819.png" class="" title="image-20210909122819">

<p><strong>当且仅当点p在由ABC组成的三角形内,有,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909124938.png" class="" title="image-20210909124938">

<p><strong>如果其中一个坐标是0另外两个在0和1之间，那么它就在一条边上。如果其中两个坐标为0，那么另一个坐标为1，它在一个顶点上。重心坐标的性质是可以一种平滑的方式混合了三个顶点的坐标和混合其他性质，如颜色。</strong></p>
<p><strong>求一个三角形的重心坐标有，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909123607.png" class="" title="image-20210909123607">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909123620.png" class="" title="image-20210909123620">

<p><strong>但是这个方法过于麻烦，更为直观的方法是，计算Aa, Ab和Ac的子三角形的面积，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909124059.png" class="" title="image-20210909124059">

<p><strong>A是三角形的面积，A = Aa + Ab + Ac，这个规则仍然适用于三角形以外的点，只是这些是带符号的面积，只要对三角形和子三角形使用相同的带符号面积计算，就可以正确地计算出三角形A和子三角形Aa, Ab,Ac的面积。</strong></p>
<h3 id="3D-Triangles-3D三角形"><a href="#3D-Triangles-3D三角形" class="headerlink" title="3D Triangles 3D三角形"></a>3D Triangles 3D三角形</h3><p><strong>对于三维三角形，依然有，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130258.png" class="" title="image-20210909130258">

<p><strong>而三角形的法向量为，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130309.png" class="" title="image-20210909130309">

<p><strong>三角形的面积可以通过求叉乘的长度得到：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130319.png" class="" title="image-20210909130319">

<p><strong>三角形的重心坐标为，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130334.png" class="" title="image-20210909130334">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130343.png" class="" title="image-20210909130343">

<h1 id="3-Raster-Images-光栅化图像"><a href="#3-Raster-Images-光栅化图像" class="headerlink" title="3 Raster Images 光栅化图像"></a>3 Raster Images 光栅化图像</h1><p><strong>因为光栅在设备中非常普遍，所以光栅图像是存储和处理图像最常用的方法。光栅图像只是一个2D数组，存储每个像素的像素值——通常是一种颜色，存储为三个数字，分别是红、绿和蓝。存储在内存中的光栅图像可以通过使用存储图像中的每个像素来控制显示的一个像素的颜色来显示。</strong></p>
<p><strong>但我们并不总是希望以这种方式显示图像。我们可能想要改变图像的大小或方向，纠正颜色，甚至显示粘贴在移动三维表面上的图像。即使是在电视，很少有相同的像素数量的图像被显示。这样的破坏了图像像素和显示像素之间的直接联系。最好将光栅图像看作是要显示的图像的与设备无关的描述，而显示设备则是接近理想图像的一种方法。</strong></p>
<p><strong>除了使用像素数组之外，还有其他描述图像的方法。矢量图像是通过存储对形状的描述来描述的——以线或曲线为边界的颜色区域——而不参考任何特定的像素网格。本质上，这相当于存储显示图像的指令，而不是存储显示图像所需的像素。矢量图像的主要优点是它们与分辨率无关，可以在非常高分辨率的设备上很好地显示。相应的缺点是在显示之前必须对其进行光栅化。矢量图像通常用于文本、图表、机械制图和其他应用，在这些应用中，清晰度和精度很重要，不需要摄影图像和复杂的着色。</strong></p>
<h2 id="Raster-Devices-光栅设备"><a href="#Raster-Devices-光栅设备" class="headerlink" title="Raster Devices 光栅设备"></a>Raster Devices 光栅设备</h2><p><strong>一些熟悉的光栅设备可以归类为一个简单的层次结构:</strong></p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p><strong>显示</strong></p>
<p>​    <strong>传输：液晶显示(LCD)</strong></p>
<p>​    <strong>发射：发光二极管(LED)显示</strong></p>
<p><strong>硬拷贝</strong></p>
<p>​    <strong>二进制：喷墨打印机</strong></p>
<p>​    <strong>连续色调：热敏染料转移打印机</strong></p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p><strong>二维阵列传感器：数码相机</strong></p>
<p><strong>一维阵列传感器：平板扫描仪</strong></p>
<h3 id="Displays-显示"><a href="#Displays-显示" class="headerlink" title="Displays 显示"></a>Displays 显示</h3><p><strong>目前的显示器，包括电视和数字电影放映机以及电脑上的显示器和放映机，几乎都是基于固定的像素阵列。它们可以分为发射型显示器和透射型显示器，前者使用像素直接发射可控数量的光，后者像素本身不发射光，而是改变它们允许通过的光的数量。透射式显示器需要光源来照亮它们：在直接显示器中，这是阵列后面的背光;在投影仪中，它是一盏灯，它发出的光通过阵列后投射到屏幕上。发射显示器是它自己的光源。</strong></p>
<p><strong>发光二极管(LED)显示器是发射型显示器的一个例子。每个像素都由一个或多个led组成，这些led是半导体器件(基于无机或有机半导体)，发光强度取决于通过它们的电流。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909133135.png" class="" title="image-20210909133135">

<p><strong>彩色显示器中的像素被分为三个独立控制的亚像素——一个红色，一个绿色，一个蓝色——每个都有自己的LED，使用不同的材料，以便它们发出不同颜色的光。当显示器是从远处观看的，眼睛无法分离单个的亚像素，所感知到的颜色是红、绿、蓝的混合。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909133423.png" class="" title="image-20210909133423">

<p><strong>液晶显示器(LCDs)是透射型显示器的一个例子。如上图，液晶是一种材料，其分子结构使它能够旋转通过它的光的偏振，并且旋转的程度可以通过施加的电压来调节。一个LCD像素的后面有一层偏振光膜，因此它被偏振光照亮——假设它是水平偏振光。</strong></p>
<p><strong>在所述像素前的第二层偏振光膜定向以只传输垂直偏振光。如果将施加的电压设置为中间的液晶层不改变偏振，则所有光都被阻挡，像素处于“关闭”(最小强度)状态。如果电压设置为使液晶旋转90度的偏振，那么所有从像素后面进入的光将从前面逃逸，像素完全“打开”——它有最大的强度。中间电压将部分旋转偏振，使前偏振器部分阻挡光，导致强度介于最小和最大之间。像彩色LED显示器一样，彩色液晶显示器在每个像素内都有红、绿、蓝亚像素，这是三个独立的像素，上面有红、绿、蓝滤光片。</strong></p>
<p><strong>任何具有固定像素网格的显示器，包括这些和其他技术，都具有由网格大小决定的基本固定分辨率。对于显示器和图像，分辨率仅仅意味着像素网格的尺寸:如果桌面显示器的分辨率是1920 × 1200像素，这意味着它有2304000像素排列在1920列和1200行中。</strong></p>
<h3 id="Hardcopy-Devices-硬拷贝设备"><a href="#Hardcopy-Devices-硬拷贝设备" class="headerlink" title="Hardcopy Devices 硬拷贝设备"></a>Hardcopy Devices 硬拷贝设备</h3><p><strong>在纸上永久记录图像的过程与在显示器上短暂显示图像的过程有非常不同的限制。在印刷中，颜料分布在纸上或其他介质上，当光线从纸上反射时，就形成了想要的图像。打印机像显示器一样是光栅设备，但许多打印机只能打印二进制图像——颜料要么在每个网格位置沉积，要么不在每个网格位置，不可能有中间数量。</strong></p>
<p><strong>喷墨打印机是一个通过扫描形成光栅图像的设备。喷墨打印头含有携带颜料的液体墨水，可以在电子控制下以非常小的滴状喷射。头在纸上移动，当它通过应该接收墨水的网格位置时，水滴被发射出来;在空白区域不喷墨。每次扫完后，将纸稍稍向前移动，然后放置下一行网格。彩色打印是通过使用几个打印头，每个喷墨用不同的颜料，这样每个网格位置都可以收到不同颜色的水滴的任何组合。由于所有的水滴都是相同的，喷墨打印机打印出二值图像:在每个网格点上有水滴或没有水滴;没有中间着色。</strong></p>
<p><strong>喷墨打印机没有像素的物理阵列;分辨率是由水滴的大小和每次扫纸后纸张前进的距离决定的。许多喷墨打印机在打印头上有多个喷嘴，可以一次进行多次扫描，但最终决定行间距的是纸张的前进速度，而不是喷嘴的间距。</strong></p>
<p><strong>热敏染料转移打印机是连续色调印刷，这意味着可以在每个像素上沉积不同数量的染料——它不像喷墨打印机那样要么有要么没有。一个含有彩色染料的供体色带被压在纸张(或染料接收器)和一个打印头之间，打印头包含一个线性阵列的加热元件，每个加热元件对应图像中的每一列像素。当纸和纸带经过纸头时，加热元件就会开关，在需要染料的地方加热纸带，使染料从纸带扩散到纸上。这一过程对每种染料重复进行。由于更高的温度导致更多的染料被转移，在每个网格位置沉积的每种染料的数量可以被控制，从而允许产生连续的颜色范围。在打印头的加热元件的数量在整个页面的方向上建立了一个固定的分辨率，但是沿着页面的分辨率是由加热和冷却的速度与纸张的速度相比较决定的。</strong></p>
<p><strong>与显示器不同，打印机的分辨率是用像素密度而不是像素总数来描述的。因此，热敏染料转移打印机的打印头每英寸间距为300的元素在页面上的分辨率为每英寸300像素(ppi)。如果沿着页面的分辨率被选择为相同的，我们可以简单地说打印机的分辨率是300 ppi。在每英寸1200个网点的网格上放置点的喷墨打印机被描述为分辨率为每英寸1200个网点(dpi)。因为喷墨打印机是一种二进制设备，它需要更精细的网格，至少有两个原因。因为边缘是突然的黑/白边界，所以需要非常高的分辨率，以避免出现阶梯或混叠。在打印连续色调图像时，高分辨率要求通过打印被称为半色调的可变密度网点图案来模拟中间色。</strong></p>
<h3 id="Input-Devices-输入设备"><a href="#Input-Devices-输入设备" class="headerlink" title="Input Devices 输入设备"></a>Input Devices 输入设备</h3><p><strong>光栅图像必须来自某个地方，而任何不是由某种算法计算出来的图像必须由某些光栅输入设备测量出来，通常是相机或扫描仪。即使在渲染3D场景的图像时，照片也经常被用作纹理贴图。光栅输入设备必须对每个像素进行光测量，(像输出设备一样)它们通常基于传感器阵列。</strong></p>
<p><strong>数码相机是二维阵列输入设备。相机里的图像传感器是一种半导体装置，由光敏像素组成网格。两种常见的阵列被称为CCDs(电荷耦合器件)和CMOS(互补金属氧化物半导体)图像传感器。相机的镜头将要拍摄的场景的图像投射到传感器上，然后每个像素测量落在其上的光能，最终得到一个进入输出图像的数字。同样的颜色显示使用红色,绿色和蓝色亚像素,大部分颜色相机工作通过使用滤色镜数组或马赛克允许每个像素只看到红色,绿色或蓝色光,离开了图像处理软件来填充缺失的值在一个过程称为demosaicking(色彩重建法)。</strong></p>
<p><strong>其他相机使用三个独立的阵列，或阵列中的三个独立层，测量每个像素上独立的红、绿、蓝值，无需进一步处理就能生成可用的彩色图像。相机的分辨率是由固定数量的像素数组决定,通常是引用使用像素的总数：相机中3000行和2000列的数组产生的图像分辨率3000×2000,拥有600万像素,称为6像素(MP)相机。重要的是要记住，马赛克传感器不能测量完整的彩色图像，所以一个相机测量相同的像素数，但独立的红、绿、蓝测量记录了比马赛克传感器更多的图像信息。</strong></p>
<p><em><em>平板扫描仪也可以测量每个像素网格的红、绿、蓝值，但像热染料转移打印机一样，它使用一维阵列扫描被扫描的页面，每秒进行多次测量。整个页面的分辨率由阵列的大小确定，而沿页面的分辨率则由测量频率与扫描头移动速度的比较决定。彩色扫描仪的分辨率为3 × n</em>x* 数组,其中n*x</em> 是整个页面的像素数，其中三行由红色、绿色和蓝色过滤器覆盖。在测量三种颜色的时间之间有一个适当的延迟，这允许在每个网格点上测量三种独立的颜色。与连续色调打印机一样，扫描仪的分辨率是以每英寸像素(ppi)为单位的。**</p>
<h2 id="Images-Pixels-and-Geometry-图像、像素和几何体"><a href="#Images-Pixels-and-Geometry-图像、像素和几何体" class="headerlink" title="Images, Pixels, and Geometry 图像、像素和几何体"></a>Images, Pixels, and Geometry 图像、像素和几何体</h2><p><strong>当我们测量或复制图像时，它们采用的是光能的二维分布形式:监视器发出的光作为显示表面位置的函数;落在相机图像传感器上的光作为传感器平面上位置的函数;在纸上的反射率，或被反射的光(相对于被吸收的光)的比例，是纸上位置的函数。所以在现实世界中，图像是二维区域上定义的函数——几乎总是矩形。所以我们可以把图像抽象成函数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910095400.png" class="" title="image-20210910095400">

<p><strong>其中R⊂R² 是矩形区域，V是可能像素值的集合。</strong></p>
<p><strong>如果一个图像有nx 列和n<em>y</em> 像素行，左下角像素为(0,0)，右上角像素为(nx-1,ny-1。我们需要2D真实屏幕坐标来指定像素位置。我们将像素的采样点放置在整数坐标上，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910102619.png" class="" title="image-20210910102619">

<h3 id="Pixel-Values-像素值"><a href="#Pixel-Values-像素值" class="headerlink" title="Pixel Values 像素值"></a>Pixel Values 像素值</h3><p><strong>表示图像中某一点的强度(可能分别表示红色、绿色和蓝色)。这表明图像应该是浮点数数组，其中一个(用于灰度或黑白图像)或三个(用于RGB彩色图像)。32位浮点数存储每个像素。</strong></p>
<p><strong>对于直接显示的图像，需要更小的范围。虽然理论上可能的光强度范围是无界的，但任何给定的设备都有一个绝对有限的最大强度，所以在许多情况下，像素有一个有界的范围是完全足够的，通常为简单起见，取为[0,1]。使用浮点数存储的图像允许使用大范围的值，通常称为高动态范围(HDR)图像，以区别于使用整数存储的固定范围或低动态范围(LDR)图像。</strong></p>
<p><strong>一些典型应用中的像素格式:</strong></p>
<p>​    <strong>1位灰度：不需要中间灰度的文本和其他图像(要求高分辨率);</strong></p>
<p>​    <strong>8位固定范围RGB(24位/像素)：网页和电子邮件应用程序、用户照片;</strong></p>
<p>​    <strong>8位或10位固定范围RGB(24-30位/像素)：数字接口到计算机显示器;</strong></p>
<p>​    <strong>12- 14位固定范围RGB(36-42位/像素)原始相机图像;</strong></p>
<p>​    <strong>16位固定范围RGB(48位/像素)：专业摄影和打印;用于固定范围图像处理的中间格式;</strong></p>
<p>​    <strong>16位固定范围灰度(16位/像素)：放射学和医学成像;</strong></p>
<p>​    <strong>16位“半精度”浮点RGB：HDR图像;实时渲染的中间格式;</strong></p>
<p>​    <strong>32位浮点RGB：软件渲染和HDR图像处理通用中间格式。</strong></p>
<p><strong>减少用于存储每个像素的比特数会导致图像中出现两种不同类型的伪影，或人为引入缺陷。当将亮度高于像素最大可表示值时，具有固定范围值的图像将产生剪切。当需要将像素值四舍五入到最接近的可表示值时，编码精度有限的图像会导致量化伪影或条带，从而在强度或颜色上引入可见的跳跃。在动画和视频中，条带可能是特别明显，在静态图像中，条带可能不是令人反感的，但当它们来回移动时，就变得非常明显。</strong></p>
<h3 id="Monitor-Intensities-and-Gamma-显示强度和伽马值"><a href="#Monitor-Intensities-and-Gamma-显示强度和伽马值" class="headerlink" title="Monitor Intensities and Gamma 显示强度和伽马值"></a>Monitor Intensities and Gamma 显示强度和伽马值</h3><p><strong>要想在监视器上生成正确的图像，必须了解两个关键问题。第一，监视器对于输入是非线性的。作为这种非线性的近似表征，监视器通常用γ(“伽马”)值来表征。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910104713.png" class="" title="image-20210910104713">

<p><strong>其中a为0到1之间的输入像素值。注意，a = 0映射到零强度，a = 1映射到最大强度，与γ值无关。用γ描述显示器的非线性只是一个近似值。</strong></p>
<p><strong>我们只需要用肉眼确定一个中间强度值，即可得到伽马值：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910105656.png" class="" title="image-20210910105656">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910105705.png" class="" title="image-20210910105705">

<p><strong>一旦我们知道了γ，我们就可以校正输入，使a = 0.5的值以介于黑色和白色之间的强度显示出来。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910105919.png" class="" title="image-20210910105919">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910105951.png" class="" title="image-20210910105951">

<p><strong>在需要控制精确强度的应用中，我们必须实际测量256种可能的强度，而这些强度在屏幕上的不同点可能是不同的，尤其是CRT。它们也可能随观察角度而变化。幸运的是，很少有应用需要如此精确的校准。</strong></p>
<h2 id="RGB-Color-RGB颜色"><a href="#RGB-Color-RGB颜色" class="headerlink" title="RGB Color RGB颜色"></a>RGB Color RGB颜色</h2><p><strong>大多数计算机图形图像是用红绿蓝(RGB)颜色定义的。RGB颜色是一个简单的空间，允许直接转换为大多数计算机屏幕的控件RGB颜色空间的基本思想是，颜色由三种原光混合显示:一种红、一种绿、一种蓝。灯光以一种附加的方式混合在一起。</strong></p>
<p><strong>在RGB加色混合中（显示器的颜色混合和现实的不同，现实中的为减色混合，比如黄+蓝=绿）：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910110654.png" class="" title="image-20210910110654">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910110707.png" class="" title="image-20210910110707">

<p><strong>“cyan（青色）”是蓝绿色，“magenta（品红）”是紫色。</strong></p>
<p><strong>如果我们允许将主光源从完全关闭(用像素值0表示)调暗到完全打开(用像素值1表示)，我们就可以创建所有可以在RGB监视器上显示的颜色。红色、绿色和蓝色像素值创建一个具有红色、绿色和蓝色轴的三维RGB颜色立方体。坐标轴的允许坐标范围从0到1。颜色立方体如图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910110951.png" class="" title="image-20210910110951">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910111125.png" class="" title="image-20210910111125">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910111135.png" class="" title="image-20210910111135">

<p><strong>实际的RGB等级通常以量化的形式给出，之前讨论的灰度一样。每个组件都用一个整数指定。这些整数最常见的大小是每个字节，所以三个RGB组件都是0到255之间的整数。这三个整数总共占用三个字节，即24位。因此，拥有“24位颜色”的系统对于三种基本颜色中的每一种都有256种可能的级别。伽马校正问题也分别适用于每个RGB分量。</strong></p>
<h2 id="Alpha-Compositing-Alpha合成"><a href="#Alpha-Compositing-Alpha合成" class="headerlink" title="Alpha Compositing Alpha合成"></a>Alpha Compositing Alpha合成</h2><p><strong>通常我们只希望部分覆盖像素的内容。一个常见的例子发生在合成中，我们有一个背景，想要在它上面插入一个前景图像。对于前景中的不透明像素，我们只需替换背景像素。对于完全透明的前景像素，我们不改变背景像素。当前景对象具有部分透明区域(如玻璃)时，就会出现部分透明像素。但是，最常见的前景和背景必须混合的情况是，当前景对象仅部分覆盖像素时，要么是在前景对象的边缘，要么是在遥远的树的叶子之间存在亚像素洞。</strong></p>
<p><strong>将前景对象与背景对象混合所需的最重要的信息是像素覆盖，它告诉前景层覆盖的像素的比例。我们称这个分数为α。如果我们想要合成前景色c<em>f</em> 背景色c<em>b</em>，则前景所覆盖像素的比例为α，则可以使用该公式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210911103651.png" class="" title="image-20210911103651">

<p><strong>对于不透明的前景层，解释为前景对象覆盖像素矩形内的区域α，背景对象覆盖剩余区域，即(1−α)。透明层(把一幅画在玻璃或描图纸,使用透明漆),解释是,前景层块分数(1−α)的光通过背景和贡献一小部分α取代了删除自己的颜色。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210911103838.png" class="" title="image-20210911103838">

<p><strong>一个图像中所有像素的α值可以存储在一个单独的灰度图像中，这被称为alpha遮罩或透明度遮罩。或者信息可以存储为RGB图像中的第四个通道，在这种情况下称为alpha通道，图像可以称为RGBA图像。对于8位图像，每个像素占用32位，这在许多计算机体系结构中是一个方便的大小块。</strong></p>
<h3 id="图像存储"><a href="#图像存储" class="headerlink" title="图像存储"></a>图像存储</h3><p><strong>大多数RGB图像格式使用红、绿、蓝通道各8位。这将为一个百万像素的图像生成大约3兆字节的原始信息。为了减少存储需求，大多数图像格式都允许某种形式的压缩。在高水平上，这种压缩要么是无损的，要么是有损的。在无损压缩中没有信息被丢弃，而在有损系统中有些信息会不可恢复地丢失。流行的图像存储格式包括:</strong></p>
<p>​    <strong>jpeg：这种有损格式基于人眼视觉系统中的阈值对图像块进行压缩。这种格式适用于自然图像。</strong></p>
<p>​    <strong>tiff：这种格式最常用来保存二进制图像或无损压缩的8位或16位RGB，尽管还有许多其他选项。</strong></p>
<p>​    <strong>ppm：对于8位RGB图像，尽管存在许多选项，这种非常简单、无损、未压缩的格式是最常用的。</strong></p>
<p>​    <strong>png：这是一组带有一组好的开源处理工具的无损格式。</strong></p>
<p><strong>由于压缩和变形，可能会涉及到为图像编写输入/输出例程。幸运的是，人们通常可以依靠库例程来读写标准文件格式。对于简单性高于效率的快速应用程序，一个选择是使用原始ppm文件，通常可以简单地通过将存储在内存中的映像的数组转储到一个文件中，并在适当的头文件之前进行编写。</strong></p>
<h1 id="4-Ray-Tracing-光线追踪"><a href="#4-Ray-Tracing-光线追踪" class="headerlink" title="4 Ray Tracing 光线追踪"></a>4 Ray Tracing 光线追踪</h1><p><strong>从根本上说，显示是一个以一组对象作为输入，并产生一个像素数组作为输出的过程。无论如何，渲染涉及到考虑每个对象对每个像素的贡献;它可以有两种一般的组织方式。在对象顺序呈现中，依次考虑每个对象，并为每个对象查找和更新其影响的所有像素。在图像顺序绘制中，依次考虑每个像素，为每个像素找到所有影响它的对象，并计算像素值。你可以从循环嵌套的角度来考虑它们的不同:在图像顺序中，“for each pixel”循环在外部，而在对象顺序中，“for each object”循环在外部。</strong></p>
<p><strong>图像顺序和对象顺序的渲染方法可以计算完全相同的图像，但它们适用于计算不同类型的效果，并且具有非常不同的性能特征。</strong></p>
<p><strong>光线追踪是一种用于3D场景渲染的图像顺序算法，我们首先考虑它，因为它可以让光线追踪器在不开发任何用于对象顺序渲染的数学机制的情况下工作。</strong></p>
<h2 id="The-Basic-Ray-Tracing-Algorithm-基本的光线追踪算法"><a href="#The-Basic-Ray-Tracing-Algorithm-基本的光线追踪算法" class="headerlink" title="The Basic Ray-Tracing Algorithm 基本的光线追踪算法"></a>The Basic Ray-Tracing Algorithm 基本的光线追踪算法</h2><p>光线追踪的工作原理是每次计算一个像素，对于每个像素，基本任务是找到在图像中该像素位置所看到的物体。每个像素“看”一个不同的方向，像素所看到的任何物体都必须与视点射线相交，视点射线是从像素所看到的方向发出的线。我们想要的特定物体是与距离相机最近的观察光线相交的那个，因为它挡住了它后面任何其他物体的视线。一旦找到对象，着色计算使用交点、表面法线和其他信息(取决于所需的渲染类型)来确定像素的颜色。如图所示，射线与两个三角形相交，但只有第一个三角形T2击中被着色。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210911105743.png" class="" title="image-20210911105743">

<p><strong>因此，一个基本的光线追踪有三个部分:</strong></p>
<p>​    <strong>1.射线生成，根据相机几何形状计算每个像素的观察射线的原点和方向;</strong></p>
<p>​    <strong>2.射线相交，找到与观察射线相交的最近的物体;</strong></p>
<p>​    <strong>3.着色，根据光线相交的结果计算像素的颜色。</strong></p>
<p><strong>基本光线追踪程序的结构如下:</strong></p>
<p><img src="C:\Users\86010\AppData\Roaming\Typora\typora-user-images\image-20210911110053834.png" alt="image-20210911110053834"></p>
<h2 id="Perspective-透视"><a href="#Perspective-透视" class="headerlink" title="Perspective 透视"></a>Perspective 透视</h2><p><strong>在电脑出现之前的几百年，艺术家们就研究过用2D图纸或绘画来表示3D物体或场景的问题。计算机图形学中,是线性的角度来看,3D对象的投影到图像平面上,这样在场景成为平面图像。</strong></p>
<p><strong>最简单的投影类型是平行投影，即将3D点沿投影方向移动，直到它们到达图像平面，将它们映射到2D。所产生的视图由投影方向和像面的选择决定。如果平面是垂直的视图方向，投影称为正交投影;否则就叫斜投影。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912091708.png" class="" title="image-20210912091708">

<p>当投影线与像平面平行且垂直时，得到的视图称为正射影。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912091734.png" class="" title="image-20210912091734">

<p>成像面与投影方向成角的平行投影称为斜投影(右)。在透视投影中，投影线全部通过视点，而不是平行(左)。图示的透视图是非斜角的，因为通过图像中心绘制的投影线将垂直于图像平面。</p>
<p><strong>平行投影经常用于机械和建筑图纸，因为它们使平行线保持平行，并保持与图像平面平行的平面物体的大小和形状。</strong></p>
<p><strong>平行投影的优点也是它的局限性。在我们的日常经验中(在照片中更是如此)，物体越远，看起来越小，因此，后退到远处的平行线就不显得平行。这是因为眼睛和相机不会收集单一观看方向的光线;它们收集通过特定视点的光线。正如文艺复兴以来的艺术家们所承认的那样，我们可以使用透视投影来产生自然的视觉效果:我们只是沿着穿过一个点的直线投影，而不是沿着平行线。这样，远离视点的物体在被投射时自然变小。透视图是由视点(而不是投影方向)和图像平面的选择决定的。与平行视图一样，也有斜透视视图和非斜透视视图;根据图像中心的投影方向来区分。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912092302.png" class="" title="image-20210912092302">

<p>在三点透视中，艺术家选择平行线相交的“消失点”。平行的水平线在地平线上相交于一点。每一组平行线都有它自己的消失点。如果我们基于正确的几何原理实现透视，这些规则会自动遵循。</p>
<p><strong>您可能已经了解了三点透视图的艺术约定，这是一个手动构建透视图的系统。关于透视法，一个令人惊讶的事实是，如果我们遵循透视法背后的简单数学规则，那么所有的透视法绘制规则都会自动遵循:物体直接投射到眼睛，然后在眼睛前面的视场平面上绘制。</strong></p>
<h2 id="Computing-Viewing-Rays-计算可视光线"><a href="#Computing-Viewing-Rays-计算可视光线" class="headerlink" title="Computing Viewing Rays 计算可视光线"></a>Computing Viewing Rays 计算可视光线</h2><p><strong>为了生成光线，我们首先需要光线的数学表示。光线其实就是原点和传播方向;一个三维参数线是理想的。从眼e到图像平面上点s的三维参数线为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912095224.png" class="" title="image-20210912095224">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912093756.png" class="" title="image-20210912093756">

<p><strong>这应该解释为，“我们从e沿着向量(s - e)的一个分量距离t前进，找到点p。”已知t，我们可以确定点p，点e是光线的原点，点s - e是光线的方向。</strong></p>
<p>*<em>请注意，p(0) = e, p(1) = s，更一般地说，如果0 &lt; t1 <em>&lt; t</em>2,那么p (t1)比p(t2)更靠近眼睛。同样，如果t &lt; 0，那么p(t)在眼睛后面。当我们搜索光线击中的离眼睛最近的物体时，这些事实会很有用。</em>*</p>
<p><strong>为了计算观察光线，我们需要知道e(给定的)和s。找到s可能看起来很困难，但如果我们在正确的坐标系下看问题，它实际上是简单的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912095348.png" class="" title="image-20210912095348">

<p><strong>我们所有的光线产生是从一个标准正交坐标系开始的，称为相机视图，我们用e表示眼睛的点或者观察点，使用u, v,w三个基向量，u指向向右(从相机的视图),v朝上,和w指向后方,所以{u, v, w}形成了一个右手坐标系。最常见的方式是用相机作为视点e，v、w定义了视图方向和向上方向。</strong></p>
<h3 id="Orthographic-Views-正交视图"><a href="#Orthographic-Views-正交视图" class="headerlink" title="Orthographic Views 正交视图"></a>Orthographic Views 正交视图</h3><p><strong>对于正交视图，所有光线的方向为- w。即使平行视图本身没有视点，我们仍然可以使用相机视图的原点来定义光线开始的位置，这样物体就有可能在相机后面。</strong></p>
<p><strong>观察光线应该从点e和向量u、v定义的平面开始;所需的唯一剩余信息是映像应该在平面上的哪个位置。我们将用四个数字定义图像的维度，用于图像的四个边:l和r是图像左右边缘的位置，从e沿着u方向测量;b和t是图像上边缘和下边缘的位置，从e沿v方向测量。通常l &lt; 0 &lt; r, b &lt; 0 &lt; t。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912100126.png" class="" title="image-20210912100126">

<p>光线生成使用相机视图。左:在正投影视图中，光线从图像平面上的像素位置开始，并且共享同一个方向，与视图方向相同。右:在透视图中，光线从视点开始，每条光线的方向由通过视点e的直线和像素在图像平面上的位置定义。</p>
<p><strong>用n来拟合图像nx ×ny像素分成大小为(r - l) × (t - b)的矩形，像素水平距离为(r - l)/n<em>x</em> 和垂直距离为(t - b)/ny，在边缘周围用半像素空间将图像矩形内的像素网格居中。这意味着在光栅图像中位于(i, j)位置的像素具有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912100649.png" class="" title="image-20210912100649">

<p><strong>其中(u, v)为像素在像面上的位置坐标，相对于原点e和基{u, v}度量。</strong></p>
<p><strong>在正交视图中，我们可以简单地使用像素的图像平面位置作为光线的起始点，并且我们已经知道光线的方向就是视图的方向。构造正交视图光线的步骤如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912101040.png" class="" title="image-20210912101040">

<p><strong>制作斜平行视图非常简单:只需要将图像平面法线w与视图方向d分开指定即可。接下来的过程完全相同，只是将d替换为−w。当然，w仍然被用来构造u和v。</strong></p>
<h3 id="Perspective-Views-透视视图"><a href="#Perspective-Views-透视视图" class="headerlink" title="Perspective Views 透视视图"></a>Perspective Views 透视视图</h3><p><strong>对于透视图，所有光线在视点处都有同一个原点;它是每个像素不同的方向。像平面不再位于e处，而是位于e前的某一距离d处;这个距离就是像面的距离，通常称为焦距，因为选择d和在真实相机中选择焦距起着相同的作用。每条光线的方向由视点和像素在图像平面上的位置定义。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912101518.png" class="" title="image-20210912101518">

<p><strong>构造过程为：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912101636.png" class="" title="image-20210912101636">

<p><strong>与平行投影一样，通过在投影方向上单独指定图像平面法线，将射线方向表达式中的−d w替换为dd，可以实现斜透视视图。</strong></p>
<h2 id="Ray-Object-Intersection-光线与对象相交"><a href="#Ray-Object-Intersection-光线与对象相交" class="headerlink" title="Ray-Object Intersection 光线与对象相交"></a>Ray-Object Intersection 光线与对象相交</h2><h3 id="Ray-Sphere-Intersection-光线与球相交"><a href="#Ray-Sphere-Intersection-光线与球相交" class="headerlink" title="Ray-Sphere Intersection 光线与球相交"></a>Ray-Sphere Intersection 光线与球相交</h3><p><strong>给定一条射线p(t) = e + td和一个隐式曲面f(p) = 0，我们想知道它们的交点。当射线上的点满足隐式方程时就会出现交点，所以我们求的t值就是解方程的值</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102437.png" class="" title="image-20210913102437">

<p><strong>圆心为c = (xc，yc, zc)，半径R可由隐式方程表示</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102530.png" class="" title="image-20210913102530">

<p><strong>我们可以把这个方程写成向量形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102540.png" class="" title="image-20210913102540">

<p><strong>任何满足这个方程的点p都在球面上。如果我们把射线p(t) = e + td的点代入这个方程，我们得到一个关于t的方程，这个方程由球上屈服点的t值满足:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102716.png" class="" title="image-20210913102716">

<p><strong>整理得</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102823.png" class="" title="image-20210913102823">

<p><strong>这里，除了参数t，其他都是已知的，所以这是一个经典的关于t的二次方程，如果判别式为负，则其平方根为虚数，且线与球不相交。如果判别式是正的，就有两个解一个是光线进入球面的解另一个是光线离开球面的解。如果判别式为零，射线就会擦过球体，恰好接触到一点。</strong></p>
<p><strong>在实际实现中，在计算其他项之前，应该首先检查该判别符的值。如果球体只是用作更复杂物体的边界对象，那么我们只需要确定我们是否击中它。</strong></p>
<h3 id="Ray-Triangle-Intersection-光线与三角形相交"><a href="#Ray-Triangle-Intersection-光线与三角形相交" class="headerlink" title="Ray-Triangle Intersection 光线与三角形相交"></a>Ray-Triangle Intersection 光线与三角形相交</h3><p><strong>有许多计算光线与三角形交点的算法。我们将给出包含三角形的参数平面使用重心坐标的形式，因为除了三角形的顶点之外，它不需要长期存储。</strong></p>
<p><strong>为了使光线与参数曲面相交，我们建立一个笛卡尔坐标完全匹配的方程组:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913103452.png" class="" title="image-20210913103452">

<p><strong>这里，我们有三个方程和三个未知数(t, u, v)所以我们可以用数值方法求解这些未知数。如果幸运的话，我们可以用解析法解出来。</strong></p>
<p><strong>当参数曲面为参数平面时，参数方程可以写成向量形式，如果三角形的顶点是a、b、c，那么可表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913103652.png" class="" title="image-20210913103652">

<p><strong>对于某些t， β和γ。交点p将在e+td处，如图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913103900.png" class="" title="image-20210913103900">

<p>光线击中的点p在包含三角形的平面</p>
<p><strong>同样，我们知道，当且仅当β &gt; 0， γ &gt; 0，和β + γ &lt; 1时，交点在三角形内。否则，光线击中了三角形外的平面，所以没有击中三角形。如果没有解，要么三角形退化（面积为0），要么射线平行于包含三角形的平面。</strong></p>
<p><strong>为了求解式中的t， β， γ，我们将其从矢量形式展开为三个坐标下的三个方程:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104319.png" class="" title="image-20210913104319">

<p><strong>这可以写成一个标准线性形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104331.png" class="" title="image-20210913104331">

<p><strong>求解这个3 × 3线性方程组最快的经典方法是克莱默法则。这就得出解</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104345.png" class="" title="image-20210913104345">

<p><strong>而矩阵A为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104710.png" class="" title="image-20210913104710">

<p><strong>而|A|表示A的行列式。3×3行列式有可以利用的公共子项。有哑变量的线性系统形式为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104913.png" class="" title="image-20210913104913">

<p><strong>使用克拉默法则</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104930.png" class="" title="image-20210913104930">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104941.png" class="" title="image-20210913104941">

<p><strong>我们可以通过重复使用“ei-minus-hf”等数字来减少操作次数。</strong></p>
<p><strong>对于需要线性解的射线三角形交，算法可以有提前终止的条件。因此，函数应该如下所示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913105121.png" class="" title="image-20210913105121">

<h3 id="Ray-Polygon-Intersection-光线与多边形相交"><a href="#Ray-Polygon-Intersection-光线与多边形相交" class="headerlink" title="Ray-Polygon Intersection 光线与多边形相交"></a>Ray-Polygon Intersection 光线与多边形相交</h3><p><strong>给定一个具有m个顶点的平面多边形p1 通过p<em>m</em> 有曲面法线n，我们首先用隐式方程计算出射线e + td与包含多边形的平面的交点</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913105722.png" class="" title="image-20210913105722">

<p><strong>我们通过设p = e + td并解出t来得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913105732.png" class="" title="image-20210913105732">

<p><strong>这允许我们计算p。如果p在多边形内部，那么光线就会击中它;否则，它就不存在。</strong></p>
<p><strong>我们可以通过将点和多边形顶点投影到xy平面来得知p是否在多边形内的问题。最简单的方法是从p发出任何2D射线，并计数射线与多边形边界之间的交点数量如果交点数为奇数，则该点位于多边形内;否则就不是。因为光线进入一定会出去，从而创造了一对交点。只有从内部开始的光线才不会产生这样的一对。为了简化计算，2D射线也可以沿x轴传播:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913110022.png" class="" title="image-20210913110022">

<p><strong>计算光线与边的交点很简单，比如</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913110131.png" class="" title="image-20210913110131">

<p><strong>然而，当多边形在xy平面上的投影是一条直线时，问题就出现了。为了解决这个问题，我们可以在xy, yz或zx平面中选择一个最好的。如果我们实现点来允许索引操作，例如，p(0) = xp 然后，这可以实现如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913110149.png" class="" title="image-20210913110149">

<p><strong>现在，所有的计算都可以使用p(index0)而不是xp，等。</strong></p>
<p><strong>另一种处理多边形的方法，也是实践中经常使用的方法，是用几个三角形来替换它们。</strong></p>
<h3 id="Intersecting-a-Group-of-Objects-一组对象相交"><a href="#Intersecting-a-Group-of-Objects-一组对象相交" class="headerlink" title="Intersecting a Group of Objects 一组对象相交"></a>Intersecting a Group of Objects 一组对象相交</h3><p><strong>当然，场景包含不止一个物体，当我们将光线与场景相交时，我们必须沿着光线找到离摄像机最近的交点。实现这一点的一个简单方法是将一组对象本身视为另一种类型的对象。要使射线与组相交，只需将射线与组中的物体相交，并返回t值最小的交点。以下代码对区间t∈[t0, t1]的命中情况进行测试:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913110834.png" class="" title="image-20210913110834">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913111038.png" class="" title="image-20210913111038">

<p>一个简单的场景渲染，只有光线生成和表面交叉，但没有阴影;每个像素都被设置为固定的颜色，这取决于它击中的对象。</p>
<h2 id="Shading-着色"><a href="#Shading-着色" class="headerlink" title="Shading 着色"></a>Shading 着色</h2><p><strong>一旦已知像素的可见表面，像素值就通过评估着色模型来计算。如何做到这一点完全取决于应用方法，从非常简单的启发式到详细的数值计算。</strong></p>
<p><strong>大多数底纹模型，不管怎样，都是为了捕捉光线反射的过程而设计的，即表面被光源照亮，并将部分光线反射到相机上。简单的着色模型是根据点光源的照明来定义的。光反射的重要变量是光的方向l，它是指向光源的单位矢量;视图方向v，是指向眼睛或相机的单位矢量;表面法向量n，是垂直于反射点的单位向量;以及表面的特性——颜色、光泽或其他属性，取决于特定的模型。</strong></p>
<h3 id="Lambertian-Shading-Lambertian着色"><a href="#Lambertian-Shading-Lambertian着色" class="headerlink" title="Lambertian Shading Lambertian着色"></a>Lambertian Shading Lambertian着色</h3><p><strong>最简单的阴影模型是基于Lambert在18世纪所做的观察:光源照射在一个表面上的能量取决于该表面与光线的角度。直接面向光的表面得到最大的照明;与光方向相切的表面(或背向光的表面)没有受到光照;在两者之间，照度与表面法线与光源夹角θ的余弦成正比。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913111812.png" class="" title="image-20210913111812">

<p><strong>这就引出了lambert着色模型:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913111634.png" class="" title="image-20210913111634">

<p><strong>式中，L为像素颜色;Kd为扩散系数，或表面颜色;其中，I为光源强度。因为n和l是单位向量，我们可以用n·l作为cos θ的简写(无论是在纸上还是在代码中)。这个方程(与本节中的其他着色方程一样)分别适用于三种颜色通道，因此像素值的红色分量是红色漫反射分量、红色光源强度和点积的乘积;绿色和蓝色也是如此。</strong></p>
<p><strong>向量l的计算方法是用光源位置减去光线和表面的交点。别忘了v，l，n都是单位向量;在着色计算不归一化这些向量是一个非常常见的错误。</strong></p>
<h3 id="Blinn-Phong-Shading-Blinn-Phong着色"><a href="#Blinn-Phong-Shading-Blinn-Phong着色" class="headerlink" title="Blinn-Phong Shading Blinn-Phong着色"></a>Blinn-Phong Shading Blinn-Phong着色</h3><p><strong>Llambert着色是独立于视图的:表面的颜色不依赖于你观察的方向。许多真实的表面显示出一定程度的光泽，产生高光，或镜面反射，似乎随着视点的变化而移动。Lambert着色不产生任何高光，导致非常哑光，白垩色的外观，和许多着色模型添加一个高光组件到Lambert着色;Lambert部分就是漫反射部分。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913112456.png" class="" title="image-20210913112456">

<p>左：一个简单的场景，由单一光源的漫反射着色渲染。中：一个简单的场景，由三个光源渲染漫反射着色和阴影。一个简单的场景，由三个光源渲染，漫反射着色(蓝色球体)，Blinn- Phong着色(绿色球体)。</p>
<p><strong>Phong (Phong, 1975)提出了一个非常简单和广泛使用的高光模型，后来由Blinn (J. F. Blinn, 1976)更新为今天最常用的形式。这个想法是为了在v和l对称地穿过表面法线时产生最亮的反射，也就是镜面反射发生的时候;当矢量离开镜面结构时，反射平滑地减小。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913112507.png" class="" title="image-20210913112507">

<p><strong>通过比较半矢量h (v和l之间角的平分线)与表面法线，我们可以知道我们与镜面结构的距离有多近。如果半矢量接近表面法线，镜面分量应该是明亮的;如果是遥远的应该是昏暗的。这个结果是通过计算的点积h和n(记住他们是单位向量,所以n·h达到最大1当向量相等),然后把结果功率p &gt; 1,使其减少得更快。功率，或Phong指数，控制表面的表面光泽。半矢量本身很容易计算:因为v和l长度相同，它们的和是一个平分它们之间夹角的矢量，这个夹角只需要标准化就能得到h。</strong></p>
<p><strong>综上所述，Blinn-Phong阴影模型如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913112519.png" class="" title="image-20210913112519">

<p><strong>其中ks是镜面的镜面系数或镜面颜色。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913122738.png" class="" title="image-20210913122738">

<h3 id="Ambient-Shading-Ambient着色"><a href="#Ambient-Shading-Ambient着色" class="headerlink" title="Ambient Shading Ambient着色"></a>Ambient Shading Ambient着色</h3><p><strong>没有任何照明的表面将被渲染成完全黑色，这通常是不可取的。避免黑影的一个粗略但有用的启发式方法是在着色模型中添加一个常量组件，它对像素颜色的贡献只取决于击中的对象，而完全不依赖于表面几何形状。这就是所谓的环境着色——就好像表面被来自各处的“环境”光照亮一样。为了方便调整参数，环境着色通常表示为表面颜色与环境光颜色的乘积，因此环境着色可以单独调整表面，也可以一起调整所有表面。与Blinn-Phong模型的其余部分一起，环境着色完成了一个简单和有用的着色模型的完整版本:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913122200.png" class="" title="image-20210913122200">

<p><strong>ka是表面的环境系数，或“环境色”，a 为环境光强度。</strong> </p>
<h3 id="Multiple-Point-Lights-多点光源"><a href="#Multiple-Point-Lights-多点光源" class="headerlink" title="Multiple Point Lights 多点光源"></a>Multiple Point Lights 多点光源</h3><p><strong>光的一个非常有用的特性是叠加——由多个光源引起的效应仅仅是光源各自效应的总和。由于这个原因，我们简单的着色模型可以很容易地扩展到处理N个光源:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913122212.png" class="" title="image-20210913122212">

<p><strong>Ii,li，hi是i^th光源的强度，方向和半矢量。</strong></p>
<h2 id="A-Ray-Tracing-Program-一个光线追踪程序"><a href="#A-Ray-Tracing-Program-一个光线追踪程序" class="headerlink" title="A Ray-Tracing Program 一个光线追踪程序"></a>A Ray-Tracing Program 一个光线追踪程序</h2><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914132257.png" class="" title="image-20210914132257">

<p><strong>在实际的实现中，曲面相交程序需要以某种方式返回被击中对象的引用，或者至少返回其法向量和着色相关的材质属性。这通常通过传递带有此类信息的记录/结构来实现。在面向对象的实现中，有一个叫做surface的类和派生类triangle, sphere, group等是一个好主意。射线可以相交的任何东西都在这个范围内。光线追踪程序将有一个参考“表面”为整个模型，新类型的对象和效率结构可以更加明显。</strong></p>
<h3 id="Object-Oriented-Design-for-a-Ray-Tracing-Program-面向对象设计的光线追踪程序"><a href="#Object-Oriented-Design-for-a-Ray-Tracing-Program-面向对象设计的光线追踪程序" class="headerlink" title="Object-Oriented Design for a Ray-Tracing Program 面向对象设计的光线追踪程序"></a>Object-Oriented Design for a Ray-Tracing Program 面向对象设计的光线追踪程序</h3><p><strong>如前所述，光线追踪的关键类层次结构是构成模型的几何对象。这些应该是一些几何对象类的子类，并且它们应该支持一个hit函数。为了避免使用“对象”这个词造成混淆，经常使用的类名是surface。有了这样一个类，您可以创建一个具有通用接口的光线跟踪器，该接口对建模原语的假设很少，只使用球体调试它。重要的一点是，任何可以被光线“击中”的东西都应该是这个类层次的一部分，例如，即使是曲面的集合也应该被认为是曲面类的子类。这包括效率结构，如边界体积层次;它们可以被射线击中，所以它们在类里。</strong></p>
<p><strong>例如，“抽象”或“基”类将指定hit函数以及一个稍后将证明有用的边界框函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914133203.png" class="" title="image-20210914133203">

<p><strong>在这里(t0，t1)是射线上返回命中值的间隔，而rec是通过引用传递的记录;它包含数据，例如hit返回true时交集处的t。该类型框是一个3D“边界框”，即两个点定义了一个轴对齐的框，该框包围了曲面。例如，对于一个球体，函数为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914133320.png" class="" title="image-20210914133320">

<p><strong>另一个有用的类是material。这允许你抽象材质的行为，然后添加透明的材质。链接对象和材质的一个简单方法是在surface类中添加一个指向材质的指针，尽管可能需要更多的可编程行为。</strong></p>
<h2 id="Shadows-阴影"><a href="#Shadows-阴影" class="headerlink" title="Shadows 阴影"></a>Shadows 阴影</h2><p><strong>一旦你有了一个基本的光线追踪程序，阴影就可以很容易地添加。光来自于某个方向l。如果我们想象我们自己在一个被阴影覆盖的表面上的点p，如果我们朝l方向“看”，看到一个物体，这个点就处于阴影中。如果没有物体，那么光线就不会被阻挡。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914133653.png" class="" title="image-20210914133653">

<p>p点不在阴影中，而q点在阴影中。</p>
<p><strong>如图所示，光线p + tl没有击中任何物体，因此不在阴影中。点q在阴影中，因为光线q + tl确实击中了一个物体。这两个点的向量l是相同的，因为光线“很远”。这一假设稍后将被放宽。决定在阴影内或阴影外的光线称为阴影光线，以区别于观察光线。</strong></p>
<p><strong>为了得到阴影的算法，我们添加了一个if语句来确定点是否在阴影中。在简单的实现中，阴影射线将检查t∈[0，∞]，但由于数值不精确，这可能导致与p所在的曲面相交。相反，为了避免这个问题，通常的调整是检验t∈[E，∞)，E其中有一个小的正常数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914134040.png" class="" title="image-20210914134040">

<p>通过在从E开始的区间内测试，我们避免了数值不精确导致射线击中表面p。</p>
<p><strong>如果我们使用着色方程为Phong照明实现阴影光线，那么我们有以下结果:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914134052.png" class="" title="image-20210914134052">

<p><strong>注意，无论p是否在阴影中，环境色都是添加的。如果有多个光源，我们可以在评估每个光源的着色模型之前发送阴影射线。上面的代码假设d和l不一定是单位向量。这对于d是至关重要的，特别是，如果我们希望在以后干净利落地添加实例化。</strong></p>
<h2 id="Ideal-Specular-Reflection-理想的镜面反射"><a href="#Ideal-Specular-Reflection-理想的镜面反射" class="headerlink" title="Ideal Specular Reflection 理想的镜面反射"></a>Ideal Specular Reflection 理想的镜面反射</h2><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210915103352.png" class="" title="image-20210915103352">

<p><strong>将理想的镜面反射添加到光线追踪程序中是很简单的。关键观察如图所示，观测者从e方向观察时，可以看到从表面上观察到的r方向的东西。矢量r是使用Phong照明反射方程的一个变体来发现的。整理符号发生了变化，因为在这种情况下，矢量d指向曲面，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210915103521.png" class="" title="image-20210915103521">

<p><strong>在现实世界中，当光线从表面反射时，一些能量会损失，而这种损失会因颜色的不同而不同。例如，与蓝色相比，金色反射黄色的效率更高，所以它会改变所反射物体的颜色。这可以通过在raycolor中添加递归调用来实现:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210915103634.png" class="" title="image-20210915103634">

<p><strong>km (为“镜面反射”)是镜面的RGB颜色。我们需要确保∈[E，∞)的原因与我们测试阴影射线的原因相同;我们不希望反射光线击中产生它的物体。</strong></p>
<p><strong>上面递归调用的问题是它可能永远不会终止。例如，如果光线从房间内部开始，它将永远反弹。这可以通过增加最大递归深度来解决。如果只在km不是零(黑色)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210915103843.png" class="" title="image-20210915103843">

<p>一个简单的场景渲染漫反射和Blinn-Phong阴影，阴影来自三个光源，镜面反射来自地板。</p>
<h2 id="Historical-Notes-发展历程"><a href="#Historical-Notes-发展历程" class="headerlink" title="Historical Notes 发展历程"></a>Historical Notes 发展历程</h2><p><strong>光线追踪在计算机图形学的早期发展(Appel, 1968)，但直到有足够的计算能力(Kay &amp; Greenberg, 1979;Whitted,1980)。</strong></p>
<p><strong>光线跟踪具有比基本对象顺序渲染更低的渐近时间复杂度(Snyder &amp; Barr, 1987;Muuss,1995;S. Parker等人，1999;Wald, Slusallek, Benthin， &amp; Wagner, 2001)。尽管传统上认为作为一种离线的方法，实时光线追踪的实现变得越来越普遍。</strong> </p>
<h1 id="5-Linear-Algebra-线性代数"><a href="#5-Linear-Algebra-线性代数" class="headerlink" title="5 Linear Algebra 线性代数"></a>5 Linear Algebra 线性代数</h1><h2 id="Determinants-行列式"><a href="#Determinants-行列式" class="headerlink" title="Determinants 行列式"></a>Determinants 行列式</h2><p><strong>我们通常认为行列式是在线性方程的解中产生的。然而，为了我们的目标，我们把行列式看作是向量相乘的另一种方法。对于二维向量a和b，行列式|ab|为a和b形成的平行四边形的面积。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916104715.png" class="" title="image-20210916104715">

<p><strong>这是一个有符号的区域，如果a和b是右手坐标系，这个符号是正的，如果它们是左手坐标系，这个符号是负的。这意味着|ab| =−|ba|。在2D中，我们可以将“右手坐标系”解释为逆时针旋转第一个向量，使其与第二个向量形成最小的角度。在三维空间中，行列式必须一次取三个向量。为三个三维向量，a, b，和c，行列式|abc|是平行六面体（三维平行四边形）。为了计算一个二维行列式，我们首先需要确定它的一些性质。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105042.png" class="" title="image-20210916105042">

<p><strong>我们注意到，对平行四边形的一侧进行缩放，其面积也会以同样的比例缩放):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105236.png" class="" title="image-20210916105236">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105246.png" class="" title="image-20210916105246">

<p><strong>另外，我们注意到“剪切”平行四边形不会改变它的面积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105603.png" class="" title="image-20210916105603">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105616.png" class="" title="image-20210916105616">

<p><strong>最后，我们看到行列式有以下性质:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105731.png" class="" title="image-20210916105731">

<p><strong>如图所示，我们可以“滑动”两个平行四边形之间的边，形成一个单独的平行四边形，而不改变原来两个平行四边形中的任何一个的面积。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105758.png" class="" title="image-20210916105758">

<p><strong>现在让我们用a和b的笛卡尔坐标表示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110021.png" class="" title="image-20210916110021">

<p><strong>这种简化使用了|vv| = 0，对于任何向量v，因为平行四边形都将与v共线，因此没有面积。</strong></p>
<p><strong>在三维空间中，三个三维向量a、b、c的行列式记为|abc|。有了向量的笛卡尔表示，平行六面体也有类似的规则平行四边形也有类似的规则，我们可以做一个类似的展开，就像在2D中做的那样:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110125.png" class="" title="image-20210916110125">

<p><strong>随着维数的增加，这种方式的行列式的计算变得越来越复杂。我们将在第5.3节讨论不易出错的计算行列式的方法。</strong></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h3><p><strong>当把一个向量表示成另外两个向量的线性组合时，行列式很自然地出现了。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110530.png" class="" title="image-20210916110530">

<p><strong>例如，如果我们想把一个向量c表示成向量a和b的组合:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110356.png" class="" title="image-20210916110356">

<p><strong>从图可以看出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110557.png" class="" title="image-20210916110557">



<p><strong>因为这些平行四边形只是彼此的剪切版本。得出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110647.png" class="" title="image-20210916110647">

<p><strong>一个类似得出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110659.png" class="" title="image-20210916110659">

<p><strong>这是克莱默规则的二维版本，我们将在第5.3.2节重新讨论。</strong></p>
<h2 id="Matrices-矩阵"><a href="#Matrices-矩阵" class="headerlink" title="Matrices 矩阵"></a>Matrices 矩阵</h2><p><strong>矩阵是遵循一定算术规则的数字元素数组。矩阵在计算机图形学中经常用于各种目的，包括表示空间变换。为了便于讨论，我们假设矩阵的元素都是实数。</strong></p>
<h3 id="Matrix-Arithmetic-矩阵的运算规则"><a href="#Matrix-Arithmetic-矩阵的运算规则" class="headerlink" title="Matrix Arithmetic 矩阵的运算规则"></a>Matrix Arithmetic 矩阵的运算规则</h3><p><strong>一个矩阵乘以一个常数得到一个矩阵，其中每个元素都乘以那个常数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916111628.png" class="" title="image-20210916111628">

<p><strong>矩阵相加等于，一个元素一个元素地相加</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916111638.png" class="" title="image-20210916111638">

<p><strong>对于矩阵乘法，我们将第一个矩阵的行与第二个矩阵的列相乘</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916111855.png" class="" title="image-20210916111855">

<p><strong>所以元素pij 的乘积是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916111936.png" class="" title="image-20210916111936">

<p><strong>只有当左矩阵的列数与右矩阵的行数相同时，才能取两个矩阵的乘积。</strong></p>
<p><strong>矩阵乘法在大多数情况下是不可交换的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112037.png" class="" title="image-20210916112037">

<p><strong>此外，如果AB = AC，也不一定就得出B = C。但是，矩阵乘法是结合性和分配性的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112129.png" class="" title="image-20210916112129">

<h3 id="Operations-on-Matrices-矩阵的性质"><a href="#Operations-on-Matrices-矩阵的性质" class="headerlink" title="Operations on Matrices 矩阵的性质"></a>Operations on Matrices 矩阵的性质</h3><p><strong>单位矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112250.png" class="" title="image-20210916112250">

<p><strong>逆矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112335.png" class="" title="image-20210916112335">

<p><strong>例如</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112347.png" class="" title="image-20210916112347">

<p><strong>有性质：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112518.png" class="" title="image-20210916112518">

<p><strong>转置矩阵，形如</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112743.png" class="" title="image-20210916112743">

<p><strong>有性质：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112832.png" class="" title="image-20210916112832">

<p><strong>行列式与矩阵运算有几个很好的性质:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112844.png" class="" title="image-20210916112844">

<h3 id="Vector-Operations-in-Matrix-Form-矩阵的向量运算"><a href="#Vector-Operations-in-Matrix-Form-矩阵的向量运算" class="headerlink" title="Vector Operations in Matrix Form 矩阵的向量运算"></a>Vector Operations in Matrix Form 矩阵的向量运算</h3><p><strong>在图形学中，我们使用方阵来变换以矩阵表示的向量。例如，如果有一个2D向量a = (xa，ya)并想绕原点旋转90度以形成向量a′=(−ya, xa)，您可以使用2×2矩阵和2×1矩阵的乘积，称为列向量。矩阵中的运算形式是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113455.png" class="" title="image-20210916113455">

<p><strong>我们可以得到同样的结果，使用这个矩阵的转置，并在左边与行向量相乘:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113504.png" class="" title="image-20210916113504">

<p><strong>现在，使用列向量的后乘法是相当标准的，但在许多旧的书籍和系统中，您会遇到行向量和前乘法。唯一的区别是变换矩阵必须用它的转置来替换。</strong></p>
<p><strong>我们也可以用矩阵形式来对向量上的运算进行编码。如果我们把点积的结果看成一个1 × 1矩阵，它可以写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113618.png" class="" title="image-20210916113618">

<p><strong>举个例子，如果我们取两个三维向量</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113632.png" class="" title="image-20210916113632">

<p><strong>一个相关的向量乘积是两个向量的外积，它可以表示为一个矩阵与左边的列向量和右边的行向量的乘积:ab^T．结果是一个矩阵由a元素和b元素的所有对的乘积组成，对于三维向量，我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113743.png" class="" title="image-20210916113743">

<p><strong>用向量运算来考虑矩阵乘法通常是有用的。为了说明使用三维的情况，我们可以把3 × 3矩阵看作是三个三维向量的集合，有两种方式:一种是由三个并排的列向量组成，另一种是由三个堆叠起来的行向量组成。例如，矩阵与向量y = Ax相乘的结果可以解释为一个向量，其元素是x与A的行数的点积，将这些行向量命名为ri,我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113939.png" class="" title="image-20210916113939">

<p><strong>或者，我们可以把这个乘积看成是三列ci和A的，由x的分量加权:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114058.png" class="" title="image-20210916114058">

<p><strong>同理，我们可以将矩阵乘积AB理解为A的所有行与B的所有列的成对点积的数组;作为矩阵A与B的所有列向量的乘积的集合，从左到右排列;A的所有行向量与矩阵B的乘积的集合，从上到下堆叠;或者A的所有列与b的所有行的对偶外积的和。</strong></p>
<p><strong>这些对矩阵乘法的解释通常会导致对运算的有价值的几何解释，否则这些运算可能看起来非常抽象。</strong></p>
<h3 id="Special-Types-of-Matrices-矩阵的特殊类型"><a href="#Special-Types-of-Matrices-矩阵的特殊类型" class="headerlink" title="Special Types of Matrices 矩阵的特殊类型"></a>Special Types of Matrices 矩阵的特殊类型</h3><p><strong>单位矩阵是对角线矩阵的一个例子，其中所有的非零元素都沿着对角线出现。对角线由列索引等于从左上角开始计数的行索引的元素组成。</strong></p>
<p><strong>单位矩阵还有一个性质它和它的转置是一样的。这样的矩阵称为对称矩阵。</strong></p>
<p><strong>单位矩阵也是一个正交矩阵，因为它的每一列都被认为是向量长度为1并且这些列是相互正交的。行也是如此。任何正交矩阵的行列式要么是+1，要么是−1。</strong></p>
<p><strong>正交矩阵的一个非常有用的性质是它们是自己的逆。用一个正交矩阵乘以它的转置得到单位矩阵，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114444.png" class="" title="image-20210916114444">

<p><strong>这很容易看出来，因为R^TR是R列之间的点积，非对角元素是正交向量之间的点积，而对角元素是(单位长度)列与自身的点积。</strong></p>
<h3 id="列子"><a href="#列子" class="headerlink" title="列子"></a>列子</h3><p><strong>有矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114635.png" class="" title="image-20210916114635">

<p><strong>是对角线的，因此是对称的，但不是正交的(列是正交的，但它们不是单位长度)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114646.png" class="" title="image-20210916114646">

<p><strong>是对称的，但不是对角或正交的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114658.png" class="" title="image-20210916114658">

<p><strong>正交，但既不对角线也不对称。</strong></p>
<h2 id="Computing-with-Matrices-and-Determinants-使用矩阵和行列式计算"><a href="#Computing-with-Matrices-and-Determinants-使用矩阵和行列式计算" class="headerlink" title="Computing with Matrices and Determinants 使用矩阵和行列式计算"></a>Computing with Matrices and Determinants 使用矩阵和行列式计算</h2><p><strong>回想一下5.1节，行列式取n个n维向量并将它们组合起来得到由这些向量定义的n维平行六面体的有符号的n维体积。例如，二维的行列式就是面积由这些向量组成的平行四边形。我们可以用矩阵来处理计算行列式的问题。</strong></p>
<p><strong>如果我们有二维向量r和s，我们表示行列式|rs|;这个值是由这些向量组成的平行四边形的带符号的面积。假设我们有两个笛卡尔坐标(a, b)和(A, B)的2D向量。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917112255.png" class="" title="image-20210917112255">

<p><strong>行列式可以写成列向量的形式，或者简写为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124406.png" class="" title="image-20210917124406">

<p><strong>请注意，矩阵的行列式与它的反式行列式是相同的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124452.png" class="" title="image-20210917124452">

<p><strong>这意味着，对于任何一个二维平行四边形，都有一个“兄弟”平行四边形，其面积相同，但形状不同。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124534.png" class="" title="image-20210917124534">

<p><strong>例子</strong></p>
<p><strong>三维行列式的几何意义有助于理解为什么某些公式是有意义的。例如，通过点(xi，yi, zi)为i = 0,1,2</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124634.png" class="" title="image-20210917124634">

<p><strong>每一列是来自点(xi，yi, zi)的向量指向(x, y, z)。只有当(x, y, z)与其他三个点共面时，以这些向量为边的平行六面体的体积为零。几乎所有涉及行列式的方程都有同样简单的基础几何。</strong></p>
<p><strong>正如我们之前看到的，我们可以通过强力展开来计算行列式，其中大多数项都是零，并且有大量的加号和减号的记录。计算行列式的代数运算的标准方法是使用拉普拉斯展开的形式。用这种方法计算行列式的关键部分是求出矩阵各元素的余子式。方阵的每一个元素都有一个余子式，它是矩阵的行列式，它的行和列比矩阵少一，可能乘以- 1。更小的矩阵是通过消去问题元素所在的行和列得到的。例如，对于10×10矩阵，a82 是9×9矩阵的行列式去掉了第8行和第2列。余子式的正号为行和列指标的和是偶数，否则是负的。这可以通过棋盘格来记住:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124908.png" class="" title="image-20210917124908">

<p><strong>对于一个4 × 4矩阵，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124926.png" class="" title="image-20210917124926">

<p><strong>第一行的余子式是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124937.png" class="" title="image-20210917124937">

<p><strong>矩阵的行列式是通过取任意行或列的元素与它们的余子式的乘积和得到的。例如，上面的4 × 4矩阵的行列式取第二列为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125024.png" class="" title="image-20210917125024">

<p><strong>我们可以对任意行或列做类似的展开它们都会得到相同的结果。注意这个扩展的递归性质。</strong></p>
<p><strong>例子</strong></p>
<p><strong>通过展开第一行的余子式求特定3 × 3矩阵的行列式的一个具体例子是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125102.png" class="" title="image-20210917125102">

<p><strong>我们可以推导出平行六面体的体积由列(或行，因为转置的行列式是相同的)定义的向量构成。这等价于说列(或行)不是线性无关的。注意，第一行和第三行的和是第二行，这意味着线性相关。</strong></p>
<h3 id="Computing-Inverses-计算逆"><a href="#Computing-Inverses-计算逆" class="headerlink" title="Computing Inverses 计算逆"></a>Computing Inverses 计算逆</h3><p><strong>行列式给了我们一个计算矩阵逆的工具。对于大型矩阵来说，这是一种非常低效的方法，但在图形学中，我们的矩阵通常都很小。发展这种方法的关键是具有两行相同的矩阵的行列式为零。这应该很清楚，因为n维平行六面体的体积是零如果它的两条边相等。假设我们有一个4 × 4A，我们希望找到它的逆矩阵A ^- 1。它的逆是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125421.png" class="" title="image-20210917125421">

<p><strong>注意，这只是矩阵的转置，其中A的元素被替换为它们各自的余子式乘以前导常数(1或-1)。这个矩阵叫做A的伴随矩阵，伴随矩阵是A的余子矩阵的转置，我们可以看出为什么它是逆矩阵。看看AA^−1我们认为它是恒等式。如果我们用A的第一行乘以伴随矩阵的第一列我们需要得到|A|(记住前面的常数除以|A|)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125614.png" class="" title="image-20210917125614">

<p><strong>这是正确的，因为A的第一行的元素恰好乘以伴随矩阵的第一列的余子式也就是行列式。由于类似的原因，结果矩阵对角线上的其他值是|A|。这些零遵循类似的逻辑:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125623.png" class="" title="image-20210917125623">

<p><strong>注意这个乘积是某个矩阵的行列式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125658.png" class="" title="image-20210917125658">

<p><strong>这个矩阵实际上是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125903.png" class="" title="image-20210917125903">

<p><strong>因为前两行是相同的，这个矩阵是奇异的，因此，它的行列式是零。</strong></p>
<p><strong>上面的论证并不仅仅适用于4 × 4矩阵;使用这个尺寸只是简化了排版。对于任何矩阵，其逆矩阵是伴随矩阵除以被逆矩阵的行列式。伴随矩阵是余子矩阵的转置，也就是元素被其余子矩阵所取代的矩阵。</strong></p>
<p><strong>例子</strong></p>
<p><strong>这个3 × 3矩阵的逆矩阵的行列式是6</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130133.png" class="" title="image-20210917130133">

<p><strong>你可以自己检验一下通过把这些矩阵相乘确保你得到了单位矩阵。</strong></p>
<h3 id="Linear-Systems-线性系统"><a href="#Linear-Systems-线性系统" class="headerlink" title="Linear Systems 线性系统"></a>Linear Systems 线性系统</h3><p><strong>我们经常在图形中遇到“n个方程和n个未知数”的线性系统，通常是n = 2或n = 3。例如,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130206.png" class="" title="image-20210917130206">

<p><strong>这里x、y和z是我们想要解的“未知数”。我们可以把它写成矩阵形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130246.png" class="" title="image-20210917130246">

<p><strong>这种系统的一个常见的简写是Ax = b，其中假设A是一个已知常数的方阵，x是一个未知的列向量(在我们的例子中包含元素x、y和z)， b是一个已知常数的列矩阵。</strong></p>
<p><strong>有很多方法可以解决这种系统,适当的方法取决于属性和维度的矩阵a。因为在图形我们如此频繁与系统大小n≤4,我们将在这里讨论一个方法适合这些系统,称为克莱姆法则,我们之前看到的,从二维几何的观点。在这里，我们用代数方法证明。上面这个方程的解是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130448.png" class="" title="image-20210917130448">

<p><strong>这里的规则是比例的决定因素,分母是|A|和分子是替换产生的矩阵的行列式的一列A与列向量b。列替换对应的位置未知向量x。例如,y是第二个未知,第二列是更换。注意，如果|A| = 0，除法是未定义的，没有解。这只是法则的另一个版本如果A是奇异的(零行列式)那么方程就没有唯一解。</strong></p>
<h2 id="Eigenvalues-and-Matrix-Diagonalization-特征值与矩阵对角化"><a href="#Eigenvalues-and-Matrix-Diagonalization-特征值与矩阵对角化" class="headerlink" title="Eigenvalues and Matrix Diagonalization 特征值与矩阵对角化"></a>Eigenvalues and Matrix Diagonalization 特征值与矩阵对角化</h2><p><strong>方阵具有与之相关的特征值和特征向量。特征向量是非零的向量它们的方向在乘以矩阵时不会改变。例如，对于矩阵a和向量a，我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130701.png" class="" title="image-20210917130701">

<p><strong>这意味着我们已经拉伸或压缩了a，但它的方向没有改变。标度因子λ称为与特征向量a相关联的特征值矩阵的特征值和特征向量在许多实际应用中是有帮助的。我们将描述它们来深入了解几何变换矩阵，并作为下一节中描述的奇异值和向量的一步。</strong></p>
<p><strong>如果我们假设一个矩阵至少有一个特征向量，那么我们可以做一个标准的操作来找到它。首先，我们把等式两边写成方阵与向量a的乘积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130715.png" class="" title="image-20210917130715">

<p><strong>其中I是单位矩阵。这也可以写作</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130724.png" class="" title="image-20210917130724">

<p><strong>因为矩阵乘法满足分配律，我们可以将这些矩阵分组:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130733.png" class="" title="image-20210917130733">

<p><strong>这个方程只有当矩阵(A−λI)是奇异的，因此它的行列式为零时才成立。这个矩阵中的元素是A中的数字，除了对角线上的数字。例如，对于一个2 × 2矩阵，特征值服从</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131009.png" class="" title="image-20210917131009">

<p><strong>因为这是一个二次方程，我们知道λ有两个解。这些解可能是唯一的，也可能不是真的。对n × n矩阵的类似操作将在λ中生成n次多项式。由于通常不可能找到大于4次的多项式方程的精确显式解，我们只能用解析方法计算4 × 4或更小矩阵的特征值。对于较大的矩阵，数值方法是唯一的选择。</strong></p>
<p><strong>特征值和特征向量特别简单的一个重要特例是对称矩阵(其中A = AT)．实对称矩阵的特征值总是实数，如果它们也是不同的，则它们的特征向量是相互正交的。这样的矩阵可以写成对角形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131119.png" class="" title="image-20210917131119">

<p><strong>其中Q是一个正交矩阵D是一个对角矩阵。Q的列是A的特征向量，D的对角元素是A的特征值，把A写成这种形式也叫做特征值分解，因为它把A分解成一个更简单的矩阵的乘积，揭示了它的特征向量和特征值。</strong></p>
<p><strong>例子</strong></p>
<p><strong>一个矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131226.png" class="" title="image-20210917131226">

<p><strong>A的特征值是解</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131236.png" class="" title="image-20210917131236">

<p><strong>我们得到近似值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131246.png" class="" title="image-20210917131246">

<p><strong>现在我们可以找到相关的特征向量。第一个是齐次方程的非平凡解(不是x = y = 0)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131256.png" class="" title="image-20210917131256">

<p><strong>这近似(x, y) =(0.8507, 0.5257)。注意，平行于这个二维向量的解有无穷多个，我们只选了一个单位长度的解。类似地，与λ2相关的特征向量是 (x, y) =(−0.5257,0.8507)。这意味着A的对角线形式是(由于我们的数值近似，在一定精度范围内):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131308.png" class="" title="image-20210917131308">

<h3 id="Singular-Value-Decomposition-奇异值分解"><a href="#Singular-Value-Decomposition-奇异值分解" class="headerlink" title="Singular Value Decomposition 奇异值分解"></a>Singular Value Decomposition 奇异值分解</h3><p><strong>我们在上一节中看到，任何对称矩阵都可以对角化，或者分解成正交矩阵和对角矩阵的乘积。然而，我们在图形学中遇到的大多数矩阵都是不对称的，非对称矩阵的特征值分解并不是那么方便或明显的，而且通常涉及复值特征值和特征向量，即使是实值输入。</strong></p>
<p><strong>对非对称(甚至非方阵)矩阵的对称特征值分解还有另一种推广;它就是奇异值分解(SVD)。对称矩阵的特征值分解与非对称矩阵的奇异值分解的主要区别在于，在奇异值分解中，左右两侧的正交矩阵不需要相同:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134407.png" class="" title="image-20210917134407">

<p><strong>U和V是两个,可能不同,正交矩阵,它的列被称为左和右奇异向量,和S是一个对角矩阵的奇异值的条目被称为A .当一个是对称的,所有非负特征值,计算和特征值分解是相同的。</strong></p>
<p><strong>在奇异值和特征值之间还有另一种关系，可以用来计算SVD(尽管这不是工业强度SVD实现的工作方式)。首先我们定义M = AAT．假设我们可以对M进行SVD:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134419.png" class="" title="image-20210917134419">

<p><strong>这种替代是基于(BC)T = CTBT正交矩阵的转置就是它的逆矩阵，对角矩阵的转置就是矩阵本身。这种新形式的美妙之处在于M是对称的和美式的2UT 是它的特征值分解，S2 包含(所有非负的)特征值。因此，我们发现矩阵的奇异值是矩阵与转置乘积的特征值的平方根，而左奇异向量是该乘积的特征向量。一个类似的论证允许V，右奇异向量的矩阵，从A计算T一个。</strong></p>
<p><strong>例子</strong></p>
<p><strong>现在我们用一个例子来具体说明:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134430.png" class="" title="image-20210917134430">

<p><strong>我们在前一节看过这个矩阵的特征值分解。我们立即观察</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134441.png" class="" title="image-20210917134441">

<p><strong>我们可以用代数方法求解V:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134451.png" class="" title="image-20210917134451">

<p><strong>S的逆矩阵是一个由S的对角元素的倒数组成的对角矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134502.png" class="" title="image-20210917134502">

<p><strong>这种形式使用标准符号σi 对于第i个奇异值。同样，对于对称矩阵，特征值和奇异值是相同的(σi =λi)．我们将在第6.1.6节进一步研究SVD的几何结构。</strong></p>
<h1 id="6-Transformation-Matrices-矩阵变换"><a href="#6-Transformation-Matrices-矩阵变换" class="headerlink" title="6 Transformation Matrices 矩阵变换"></a>6 Transformation Matrices 矩阵变换</h1><h2 id="2D-Linear-Transformations-二维线性变换"><a href="#2D-Linear-Transformations-二维线性变换" class="headerlink" title="2D Linear Transformations 二维线性变换"></a>2D Linear Transformations 二维线性变换</h2><p><strong>我们可以使用2 × 2矩阵来改变或变换一个2D向量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918103805.png" class="" title="image-20210918103805">

<p><strong>这种运算，通过一个简单的矩阵乘法得到另一个2-向量，是一个线性变换。</strong></p>
<p><strong>通过这个简单的公式，我们可以实现各种有用的转换，这取决于我们在矩阵的项中放入了什么，这将在下面几节中讨论。出于我们的目的，考虑沿x轴的移动是水平移动，沿y轴的移动是垂直移动。</strong></p>
<h3 id="Scaling-缩放"><a href="#Scaling-缩放" class="headerlink" title="Scaling 缩放"></a>Scaling 缩放</h3><p><strong>最基本的变换是沿坐标轴的缩放。这个变换可以改变长度和可能的方向:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104010.png" class="" title="image-20210918104010">

<p><strong>注意这个矩阵对具有笛卡尔分量(x, y)的向量的作用:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104019.png" class="" title="image-20210918104019">

<p><strong>所以，只要看一个轴向比例的矩阵，我们就能读出两个比例因子。</strong></p>
<p><strong>例子</strong></p>
<p><strong>将x和y均匀地缩小为原来的两倍的矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104034.png" class="" title="image-20210918104034">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104054.png" class="" title="image-20210918104054">

<p>每个轴按一半均匀缩放:轴对齐的缩放矩阵有每个对角线元素的变化比例，非对角线元素的变化比例为零。</p>
<p><strong>一个在水平方向上减半，在垂直方向上增加三倍的矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104043.png" class="" title="image-20210918104043">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104106.png" class="" title="image-20210918104106">

<p>x和y的非均匀缩放:缩放矩阵是对角的，且不相等元素。</p>
<h3 id="Shearing-剪切"><a href="#Shearing-剪切" class="headerlink" title="Shearing 剪切"></a>Shearing 剪切</h3><p><strong>剪切是把东西往旁边推的东西，就像你用手推一副扑克牌一样。水平和垂直剪切矩阵为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104646.png" class="" title="image-20210918104646">

<p><strong>例子</strong></p>
<p><strong>水平剪切的变换，使垂直线变成45◦向右倾斜的线是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104656.png" class="" title="image-20210918104656">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104705.png" class="" title="image-20210918104705">

<p>x-剪切矩阵按其y坐标的比例向右移动。</p>
<p><strong>垂直方向的一个类似变换是(见图6.4)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104719.png" class="" title="image-20210918104719">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104733.png" class="" title="image-20210918104733">

<p>y-剪切矩阵使点按其横坐标的比例向上移动。</p>
<p><strong>在这两种情况下，被剪切的时钟的方形轮廓变成了一个平行四边形，被剪切的钟的圆形表面变成了椭圆形。</strong></p>
<p><strong>另一种考虑剪切的方法是只考虑垂直(或水平)轴的旋转。具有垂直轴并使其倾斜的剪切变换顺时针方向，φ为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104745.png" class="" title="image-20210918104745">

<p><strong>同理，以角度φ逆时针旋转水平轴的剪切矩阵为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104754.png" class="" title="image-20210918104754">

<h3 id="Rotation-旋转"><a href="#Rotation-旋转" class="headerlink" title="Rotation 旋转"></a>Rotation 旋转</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105214.png" class="" title="image-20210918105214">

<p><strong>假设我们想让向量a逆时针旋转一个角度φ来得到向量b。如果a与x轴的夹角是α，它的长度是r= xa² + ya²，我们就知道了</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105319.png" class="" title="image-20210918105319">

<p><strong>因为b是a的旋转，它的长度也为r。因为它从a旋转一个角度φ， b与x轴形成一个角度(α + φ)。使用三角加法恒等式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105422.png" class="" title="image-20210918105422">

<p><strong>使用xa=rcosα和ya=rsinα替换</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105432.png" class="" title="image-20210918105432">

<p><strong>在矩阵形式中，从a到b的变换是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105442.png" class="" title="image-20210918105442">

<p><strong>例子</strong></p>
<p><strong>一个以π/4弧度(45度)旋转矢量的矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105628.png" class="" title="image-20210918105628">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105640.png" class="" title="image-20210918105640">

<p>逆时针旋转45◦，cos(45◦)= sin(45◦)≈0.707。</p>
<p><strong>一个沿顺时针方向旋转30度的矩阵，在我们的框架中相当于旋转−π/6度(见图6.7):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105823.png" class="" title="image-20210918105823">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105834.png" class="" title="image-20210918105834">

<p>旋转-30度。注意，旋转是顺时针和cos(-30◦)≈0.866和sin(-30◦)= -0.5。</p>
<p><strong>因为旋转矩阵每一行的范数是1 (sin²φ+ cos²φ=1)，且行为正交(cosφ(-sinφ)+sinφcosφ=0)，则旋转矩阵为正交矩阵。通过观察这个矩阵我们可以读出两对标准正交向量这两列向量，是这个变换发送给它的标准基向量(1,0)和(0,1);这些行，就是这些变换传递给标准基向量的向量。</strong></p>
<h3 id="Reflection-反射"><a href="#Reflection-反射" class="headerlink" title="Reflection 反射"></a>Reflection 反射</h3><p><strong>我们可以通过使用一个负比例因子的比例来反映任意一个坐标轴上的向量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110125.png" class="" title="image-20210918110125">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110137.png" class="" title="image-20210918110137">

<p>关于y轴的反射是通过将所有x坐标乘以-1来实现的。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110148.png" class="" title="image-20210918110148">

<p>关于x轴的反射是通过将所有y坐标乘以-1来实现的。</p>
<p><strong>虽然人们可能认为对角线上两个元素都为−1的矩阵也是一个反射，但实际上它只是一个π弧度的旋转（这种旋转也可以称为“穿过原点的反射”。）。</strong></p>
<h3 id="Composition-and-Decomposition-of-Transformations-变换的组合和分解"><a href="#Composition-and-Decomposition-of-Transformations-变换的组合和分解" class="headerlink" title="Composition and Decomposition of Transformations 变换的组合和分解"></a>Composition and Decomposition of Transformations 变换的组合和分解</h3><p><strong>对于图形程序来说，对一个对象应用多个转换是很常见的。例如，我们可能想首先应用一个缩放S，然后再应用一个旋转R。这将在2D向量v1上分两步完成：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110530.png" class="" title="image-20210918110530">

<p><strong>另一种写法是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110538.png" class="" title="image-20210918110538">

<p><strong>因为矩阵乘法满足结合律，我们也可以写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110546.png" class="" title="image-20210918110546">

<p><strong>换句话说，我们可以用一个大小相同的矩阵来表示将一个向量按顺序转换为两个矩阵的效果，我们可以通过将两个矩阵相乘来计算:M = RS。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918113135.png" class="" title="image-20210918113135">

<p>将两个变换矩阵按顺序应用与将它们的乘积应用一次是相同的。这是构成大多数图形硬件和软件的关键概念。</p>
<p><strong>重要的是要记住，这些变换首先是从右侧应用的。矩阵M = RS首先应用S，然后是R。</strong></p>
<p><strong>例子</strong></p>
<p><strong>假设我们想在垂直方向上缩放1 / 2，然后旋转π/4弧度(45度)。得到的矩阵是</strong>image-屏幕截图20210918122140](Fundamentals Of Computer Graphics image-幕截图 02-0-18 122140.png)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </p>
<p><strong>重要的是要始终记住矩阵乘法是不可交换的。所以变换的顺序很重要。在这个例子中，先旋转，然后缩放，会得到一个不同的矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122155.png" class="" title="image-20210918122155">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122221.png" class="" title="image-20210918122221">

<p>应用两个变换的顺序通常很重要。将应用这两个转换的顺序颠倒，将产生不同的结果。</p>
<p><strong>例子</strong></p>
<p><strong>使用我们给出的比例矩阵，非均匀比例只能沿坐标轴进行。如果我们想沿着对角线将时钟拉长50%，那么8:00到1:00移动到西北方向，2:00到7:00移动到东南方向，我们可以使用旋转矩阵结合轴向缩放矩阵来得到我们想要的结果。这个想法是使用旋转使缩放轴与坐标轴对齐，然后沿着这个轴缩放，然后旋转回来。在我们的例子中，缩放轴是正方形的“反斜线”对角线，我们可以使它与x轴平行一个旋转+45◦。把这些操作放在一起，整个转换就是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122436.png" class="" title="image-20210918122436">

<p><strong>用数学符号表示，可以写成RSR^T．这三个矩阵相乘的结果是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122446.png" class="" title="image-20210918122446">

<p><strong>从旋转和缩放转换构建一个转换实际上适用于任何线性转换，这一事实导致了一种思考这些转换的强大方法，下一节将对此进行探讨。</strong></p>
<h3 id="Decomposition-of-Transformations-变换的分解"><a href="#Decomposition-of-Transformations-变换的分解" class="headerlink" title="Decomposition of Transformations 变换的分解"></a>Decomposition of Transformations 变换的分解</h3><p><strong>有时需要“解开”转换的组合，将转换分解成更简单的部分。例如，根据单独的旋转和缩放因子向用户展示一个转换，以便进行操作，这通常是有用的，但一个转换可能在内部简单地表示为矩阵，旋转和缩放已经混合在一起。如果能计算出将矩阵分解成所需的小块，对小块进行调整，然后再将这些小块乘在一起将矩阵重新组装，就可以实现这种操作。</strong></p>
<p><strong>事实证明，这种分解或因式分解是可能的，不管矩阵中的条目是什么——这提供了一种富有成效的方式来思考转换以及它们对由它们转换的几何图形所做的事情。</strong></p>
<h4 id="Symmetric-Eigenvalue-Decomposition-对称特征值分解"><a href="#Symmetric-Eigenvalue-Decomposition-对称特征值分解" class="headerlink" title="Symmetric Eigenvalue Decomposition 对称特征值分解"></a>Symmetric Eigenvalue Decomposition 对称特征值分解</h4><p><strong>让我们从对称矩阵开始。回忆一下5.4节，对称矩阵总是可以使用特征值分解成这种形式的乘积</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122956.png" class="" title="image-20210918122956">

<p><strong>其中R是正交矩阵S是对角矩阵;我们称R的列向量为v1 和v2，我们把S(特征值)的对角线项叫做λ1 和λ2．</strong></p>
<p><strong>在几何方面，我们现在可以识别R是一个旋转，S是一个比例，所以这只是一个多步骤的几何变换:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123059.png" class="" title="image-20210918123059">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123142.png" class="" title="image-20210918123142">

<p>当单位圆被任意对称矩阵变换时会发生什么，又称非轴向、非均匀尺度。这两个垂直的向量v1 和v2，它们是A的特征向量，方向是固定的，但是被缩放了。根据初等变换，这可以被看作是首先旋转特征向量到标准基，做一个轴对齐的比例，然后旋转标准基回到特征向量。</p>
<p><strong>观察这三种变换的效果，我们可以看到它们有沿一对轴的非均匀比例的效果。与轴对齐的比例一样，轴是垂直的，但它们不是坐标轴;相反,他们是a的特征向量。这告诉我们什么是对称矩阵:对称矩阵只是缩放操作——尽管可能是非均匀的和非轴对齐的。</strong></p>
<p><strong>例子</strong></p>
<p><strong>回想一下5.4节中的例子:</strong></p>
<p><strong>上面的矩阵，然后，根据它的特征值分解，在一个方向31.7◦逆时针从3点(x轴)。如图所示，这是在下午2点之前的一次触摸。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123534.png" class="" title="image-20210918123534">

<p>对称矩阵总是沿着某一轴的一个比例尺。在这种情况下，它是沿着φ = 31.7◦方向，这意味着这个矩阵的真实特征向量是在那个方向。</p>
<p><strong>我们也可以反转这个对角化过程;按(λ1,λ2)，第一个缩放方向为从x轴顺时针方向的角度φ，我们得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123505.png" class="" title="image-20210918123505">

<p><strong>我们应该记住，这是一个对称矩阵，因为我们知道它必须是真的，因为我们从一个对称特征值分解构造它。</strong></p>
<h4 id="Singular-Value-Decomposition-奇异值分解-1"><a href="#Singular-Value-Decomposition-奇异值分解-1" class="headerlink" title="Singular Value Decomposition 奇异值分解"></a>Singular Value Decomposition 奇异值分解</h4><p><strong>对于非对称矩阵也可以进行非常类似的分解:它是奇异值分解(SVD)，也将在第5.4.1节中讨论。不同之处在于对角矩阵两边的矩阵不再相同:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123732.png" class="" title="image-20210918123732">

<p><em><em>这两个正交矩阵代替了单个旋转R称为U和V，它们的列称为U</em>i* (左奇异向量)和v*i</em> (右奇异向量)。在这种情况下，S的对角项称为奇异值而不是特征值。几何解释与对称特征值分解非常相似:**</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123745.png" class="" title="image-20210918123745">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123806.png" class="" title="image-20210918123806">

<p>当单位圆被任意矩阵a变换时会发生什么?两个垂直的向量v1和v2，它们是A的右奇异向量，被缩放和改变方向来匹配左奇异向量u1和u2。根据初等变换，这可以看作是首先将右边的奇异向量旋转到标准基上，进行轴对齐的缩放，然后将标准基旋转到左边的奇异向量上。</p>
<p><strong>主要的区别是单个旋转和两个不同的正交矩阵之间的区别。这个差异导致了另一个不那么重要的差异。因为奇异值分解的两边有不同的奇异向量，所以不需要负奇异值:我们总是可以翻转一个奇异值的符号，改变一个相关奇异向量的方向，然后再次得到相同的变换。由于这个原因，SVD总是产生一个所有条目都是正的对角矩阵，但矩阵U和V不能保证是旋转矩阵——它们也可以包括反射。在像图形学这样的几何应用中，这是一个不便之处，但也是一个很小的不便:通过检查行列式，很容易区分旋转和反射，对于旋转，行列式是+1和−1表示反射，如果需要旋转，则其中一个奇异值可以被抵消，从而产生一个旋转-比例-旋转序列，其中反射与比例滚入，而不是与一个旋转滚入。</strong></p>
<p><strong>例子</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124032.png" class="" title="image-20210918124032">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122824.png" class="" title="image-20210918122824">

<p>剪切矩阵的奇异值分解。</p>
<p><strong>SVD存在的直接结果是，我们看到的所有二维变换矩阵都可以由旋转矩阵和缩放矩阵构成。剪切矩阵是一种方便的方法，但表达反式并不需要它们形成。</strong></p>
<p><strong>总之，每个矩阵都可以通过SVD分解为一个旋转乘以一个比例乘以另一个旋转。只有对称矩阵才能通过特征值对角化分解为旋转乘以比例乘以反旋转，且这类矩阵是任意方向上的简单比例。对称矩阵的奇异值分解将通过稍微复杂一点的代数操作产生与特征值分解相同的三重积。</strong></p>
<h4 id="Paeth-Decomposition-of-Rotations-旋转的Paeth分解"><a href="#Paeth-Decomposition-of-Rotations-旋转的Paeth分解" class="headerlink" title="Paeth Decomposition of Rotations 旋转的Paeth分解"></a>Paeth Decomposition of Rotations 旋转的Paeth分解</h4><p><strong>另一种分解使用剪切来表示非零旋转(Paeth, 1990)。下面的标识允许这样做:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124301.png" class="" title="image-20210918124301">

<p><strong>例如，π/4(45度)的旋转是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124310.png" class="" title="image-20210918124310">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124408.png" class="" title="image-20210918124408">

<p>任何二维旋转都可以由三个顺序剪切完成。在这种情况下，旋转45◦分解如公式所示。</p>
<p><strong>这种特殊的变换对于光栅旋转非常有用，因为剪切是一种非常有效的图像光栅操作;它会带来一些粗糙，但会没有留下任何漏洞。关键的观察是，如果我们取一个光栅位置(i, j)，并对其施加一个水平剪切，我们得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124539.png" class="" title="image-20210918124539">

<p><strong>如果我们将sj四舍五入到最接近的整数，这相当于取图像中的每一行，并将其侧向移动一些量——每一行都有不同的量。因为它在一行中是相同的位移，这允许我们在结果图像中没有间隙的旋转。类似的作用也适用于垂直剪切。因此，我们可以很容易地实现一个简单的光栅旋转。</strong></p>
<h2 id="3D-Linear-Transformations-三维线性变换"><a href="#3D-Linear-Transformations-三维线性变换" class="headerlink" title="3D Linear Transformations 三维线性变换"></a>3D Linear Transformations 三维线性变换</h2><p><strong>线性三维变换是二维变换的扩展。例如，沿笛卡尔轴的缩放是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124633.png" class="" title="image-20210918124633">

<p><strong>旋转在3D中要比在2D中复杂得多，因为有更多可能的旋转轴。然而，如果我们只是想绕z轴旋转，这只会改变x和y坐标，我们可以使用2D旋转矩阵，而不需要对z进行操作:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124643.png" class="" title="image-20210918124643">

<p><strong>类似地，我们可以构造绕x轴和y轴旋转的矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124654.png" class="" title="image-20210918124654">

<p><strong>我们将在下一节讨论关于任意轴的旋转。在二维空间中，我们可以沿着特定的轴进行剪切，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124704.png" class="" title="image-20210918124704">

<p><strong>与2D转换一样，任何3D转换矩阵都可以使用SVD分解为旋转、缩放和另一个旋转。任何对称三维矩阵都有一个特征值分解为旋转、缩放和反旋转。最后，将三维旋转分解为三维剪切矩阵的乘积。</strong></p>
<h3 id="Arbitrary-3D-Rotations-任意三维旋转"><a href="#Arbitrary-3D-Rotations-任意三维旋转" class="headerlink" title="Arbitrary 3D Rotations 任意三维旋转"></a>Arbitrary 3D Rotations 任意三维旋转</h3><p><strong>和2D一样，3D旋转是正交矩阵。在几何上，这意味着矩阵的三行是三个相互正交的单位向量的笛卡尔坐标，如2.4.5节所讨论的。列向量是三个，可能不同的，相互正交的单位向量。有无限个这样的旋转矩阵。让我们写下这样一个矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124852.png" class="" title="image-20210918124852">

<p><strong>这里u = xux + yuy + zuz等对于v和w，因为这三个向量是标准正交的，我们知道</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124901.png" class="" title="image-20210918124901">

<p><strong>我们可以通过将旋转矩阵应用于向量u，v和w来推断它的一些行为，例如，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124912.png" class="" title="image-20210918124912">

<p><strong>注意RuvwU的这三行都是点积:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124921.png" class="" title="image-20210918124921">

<p><strong>同样,Ruvwv = y，Ruvww = z，所以Ruvw 将基uvw旋转到相应的笛卡尔轴上。</strong></p>
<p><strong>如果Ruvw 是一个具有标准正交行的旋转矩阵，那么Ruvw^T 也是一个具有标准正交列的旋转矩阵，实际上是Ruvw的逆矩阵 (正交矩阵的逆总是它的转置)。重要的一点是，对于变换矩阵，代数逆也是几何逆。如果Ruvw 取u到x，然后Ruvw^T 将x取到u, v和y也应如此，我们可以确认:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124932.png" class="" title="image-20210918124932">

<p><strong>所以我们总是可以用标准正交基来创建旋转矩阵。</strong></p>
<p><strong>如果我们想旋转一个任意向量a，我们可以形成一个w = a的标准正交基，将这个基旋转到标准基xyz，绕z轴旋转，然后将标准基旋转回uvw基。在矩阵形式下，绕w轴旋转一个角度φ:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124942.png" class="" title="image-20210918124942">

<p><strong>这里我们有一个单位矢量w，在a的方向上(即a除以自身长度)。但是u和v是什么?找到合理的u和v的方法在第2.4.6节中给出。</strong></p>
<p><strong>如果我们有一个旋转矩阵，我们希望以轴角形式旋转，我们可以计算一个真实的特征值(λ = 1)，对应的特征向量是旋转轴。这是一个没有因旋转而改变的轴。</strong></p>
<p><strong>除了旋转矩阵外，还有一些常用的表示旋转的方法，请参阅第16章。</strong></p>
<h3 id="Transforming-Normal-Vectors-转换法向量"><a href="#Transforming-Normal-Vectors-转换法向量" class="headerlink" title="Transforming Normal Vectors 转换法向量"></a>Transforming Normal Vectors 转换法向量</h3><p><strong>虽然我们使用的大多数3D矢量表示位置(从原点偏移的矢量)或方向，比如光线从哪里来，但有些矢量表示表面法线。曲面法向量垂直于曲面的切平面。当下面的表面被变换时，这些法线不会以我们想要的方式进行变换。例如，如果一个曲面上的点被矩阵M变换，那么与曲面相切并乘以M的向量t将与变换后的曲面相切。然而，经过M变换的曲面法向量n可能与变换后的曲面不垂直。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125458.png" class="" title="image-20210918125458">

<p>当一个法向量使用变换对象上的点的相同矩阵进行变换时，得到的向量可能不垂直于这个剪切矩形的表面。然而，切向量确实转换成与变换后的曲面相切的向量。</p>
<p><strong>我们可以推出一个变换矩阵N它把N放到一个垂直于变换后的曲面的向量上。解决这个问题的一种方法是注意曲面法向量和切向量是垂直的，所以它们的点积是零，用矩阵的形式表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125546.png" class="" title="image-20210918125546">

<p><strong>如果我们用t表示需要的变换向量tM = Mt和nN = Nn，我们的目标是找到满足N的nN^TtM = 0．我们可以用代数方法求出N。首先，我们可以在点积中混入一个单位矩阵，然后利用M^−1M = I:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125752.png" class="" title="image-20210918125752">

<p><strong>虽然上面的操作显然没有得到任何结果，但请注意，我们可以添加括号，使上面的表达式更明显地成为一个点积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125802.png" class="" title="image-20210918125802">

<p><strong>这意味着垂直于t的行向量<em>M</em> 是上面表达式的左边部分。这个表达式对切平面上的任何切向量都成立。因为在3D中只有一个方向(和它的相反方向)垂直于所有这些切向量，我们知道上面表达式的左边部分一定是nN的行向量表达式 ,即nN^T，因此我们可以推断出N:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125839.png" class="" title="image-20210918125839">

<p><strong>我们可以用它的转置得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125848.png" class="" title="image-20210918125848">

<p><strong>因此，我们可以看到，正确变换法向量使其保持法向量的矩阵是N = (M ^−1) ^T,即逆矩阵的转置。因为这个矩阵可以改变n的长度，我们可以把它乘以一个任意的标量它仍然会得到nN方向正确。回忆一下在第5.3节中，矩阵的逆是余子矩阵的转置除以行列式。因为我们不关心法向量的长度，我们可以跳过除法，对于3 × 3矩阵，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918130040.png" class="" title="image-20210918130040">

<p><strong>假设第i行第j列中M的元素为N是mij ．所以完整的表达式是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918130051.png" class="" title="image-20210918130051">

<h2 id="Translation-and-Affine-Transformations-平移与仿射变换"><a href="#Translation-and-Affine-Transformations-平移与仿射变换" class="headerlink" title="Translation and Affine Transformations 平移与仿射变换"></a>Translation and Affine Transformations 平移与仿射变换</h2><p><strong>我们一直在研究用矩阵M改变向量的方法，在二维中，这些变换有这样的形式，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919131350.png" class="" title="image-20210919131350">

<p><strong>我们不能使用这种变换来移动对象，只能缩放和旋转它们。特别地，原点(0,0)在线性变换下始终是固定的。要移动或平移一个物体，通过移动其所有点的相同量，我们需要一个形式的变换，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919131419.png" class="" title="image-20210919131419">

<p><strong>用(x, y)乘以2 × 2矩阵是不可能的。将平移添加到线性变换系统中的一种可能性是，简单地将一个单独的平移向量与每个变换矩阵关联起来，让矩阵处理缩放和旋转，让向量处理平移。这是完全可行的，但组成两个转换的规则不像线性转换那样简单和干净。</strong></p>
<p><strong>相反，我们可以使用一个技巧来让一个矩阵乘法同时完成这两种操作。这个想法很简单:用一个3D矢量[x y 1]表示点(x, y)T，并使用3 × 3矩阵的形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919133120.png" class="" title="image-20210919133120">

<p><strong>固定的第三行用于将1复制到变换后的向量中，这样所有向量的最后一个位置都是1，并且前两行计算x′和y′作为x, y，和1的线性组合:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919133552.png" class="" title="image-20210919133552">

<p><strong>这个矩阵实现了一个线性变换，且这是平移。这种变换叫做仿射变换，这种通过增加额外维度来实现仿射变换的方法叫做齐次坐标(Roberts, 1965;Riesenfeld, 1981;Penna &amp; Patterson, 1986)。齐次坐标不仅为转换清理了代码，但是这个方案也使如何组合两个仿射变换变得很明显:简单地将两个矩阵相乘。</strong></p>
<p><strong>这种新形式的一个问题是，当我们需要变换不应该是位置的向量时——它们代表方向，或位置之间的偏移。表示方向或偏移量的向量在平移对象时不应改变。幸运的是，我们可以通过将第三个坐标设置为零来避免:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919135106.png" class="" title="image-20210919135106">

<p><strong>如果在矩阵的左上方2 × 2元素中有一个缩放/旋转变换，它将适用于向量，但平移仍然与0相乘并被忽略。此外，零被复制到变换后的向量中，因此方向向量在变换后仍然是方向向量。</strong></p>
<p><strong>这正是我们想要的向量的行为，所以它们平滑地适合于系统:额外的(第三个)坐标将是1或0，这取决于我们表示的是一个位置（点）还是一个方向。我们需要存储齐次坐标以便区分位置和其他向量。例如,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919135502.png" class="" title="image-20210919135502">

<p><strong>当我们进行透视时，我们将看到允许齐次坐标取除1或0以外的值是很有用的。</strong></p>
<p><strong>齐次坐标几乎普遍用于表示图形系统中的变换。特别是，在图形硬件中实现的渲染器的设计和操作是基于齐次坐标的。我们将在第7章中看到，齐次坐标还可以方便地绘制透视图场景，这也是它们流行的另一个原因。</strong></p>
<p><strong>齐次坐标可以被认为是处理变换表示的一种聪明方法，但也有不同的几何解释。当我们做一个基于z坐标的3D剪切时，我们得到这个变换:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919140317.png" class="" title="image-20210919140317">

<p><strong>注意，这几乎具有我们在x和y中想要的2D转换形式，但有一个z在2D中没有意义。现在，我们将为所有2D位置添加一个坐标z = 1。得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919140613.png" class="" title="image-20210919140613">

<p><strong>通过将a (z = 1)坐标与所有2D点联系起来，我们现在可以将平表示为矩阵形式。例如，首先在2D中平移(xt，yt)，然后旋转角度φ，我们将使用矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919141502.png" class="" title="image-20210919141502">

<p><strong>注意，2D旋转矩阵现在是3 × 3，在“平移槽”中为零。“在这种形式下，沿着z = 1使用剪切来表示平移，我们可以将任意数量的2D剪切、2D旋转和2D平移表示为一个复合的3D矩阵。矩阵的最后一行总是(0,0,1)所以我们不需要存储它。我们只需要记住，当我们把两个矩阵相乘时，它也是存在的。</strong></p>
<p><strong>在3D中，可以使用同样的技术:我们可以添加第四个坐标，一个齐次坐标，然后我们就有了平移:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919141648.png" class="" title="image-20210919141648">

<p><strong>同样，对于方向矢量，第四个坐标是零，因此矢量不受平移的影响。</strong></p>
<p><strong>示例(窗口转换)</strong></p>
<p><strong>通常在图形中，我们需要创建一个变换矩阵，取矩形中的点 [xl, xh] × [yl, yh] 到矩形xl′, xh′] × [yl′, yh′]．这可以用单一的比例和顺序转换来完成。然而，更直观的是从三个操作序列创建转换:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919141913.png" class="" title="image-20210919141913">

<p>要将一个矩形(窗口)移动到另一个，我们首先将左下角移动到原点，然后将其缩放到新的大小，然后将原点移动到目标矩形的左下角。</p>
<p><strong>1.移动点(xl，yl)到原点。</strong></p>
<p><strong>2.将矩形缩放为与目标矩形相同的大小。</strong></p>
<p> <strong>3.将原点移动到点(xl′，yl′)</strong></p>
<p><strong>记住右手边的矩阵是先应用的，我们可以这样写</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919142144.png" class="" title="image-20210919142144">

<p><strong>对于一些读者来说，得到的矩阵具有这样的形式可能并不奇怪，但是用三个矩阵构造的过程的结果毫无疑问是正确的。</strong></p>
<p><strong>一个完全类似的结构可以用来定义一个3D窗口变换，它映射框[xl, xh]×[yl,yh]×[zl, zh]到箱子里</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919143528.png" class="" title="image-20210919143528">

<p><strong>有趣的是，如果我们将一个由缩放、剪切和旋转组成的任意矩阵与一个简单的平移(平移排在第二位)相乘，我们得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919145453.png" class="" title="image-20210919145453">

<p><strong>因此，我们可以把任何矩阵看作一个缩放/旋转部分和一个平移部分，因为这些分量彼此分离。</strong></p>
<p><strong>一类重要的变换是刚体变换。它们只由平移和旋转组成，所以它们没有物体的拉伸或收缩。这种变换对aij有一个纯旋转。</strong></p>
<h2 id="Inverses-of-Transformation-Matrices-变换矩阵的逆"><a href="#Inverses-of-Transformation-Matrices-变换矩阵的逆" class="headerlink" title="Inverses of Transformation Matrices 变换矩阵的逆"></a>Inverses of Transformation Matrices 变换矩阵的逆</h2><p><strong>虽然我们总是可以用代数方法求矩阵的逆变换，但如果我们知道变换的作用，就可以用几何方法。例如，scale(sx, sy, sz)的逆变换是scale(1/sx, 1/sy, 1/sz)。旋转的逆旋转是相同的异号旋转。平移的逆是反方向的平移。如果我们有一系列矩阵M = M1M2 ···Mn，那么M^−1 = Mn^-1 ···M2^-1 M^-1。</strong></p>
<p><strong>另外，某些类型的变换矩阵很容易求逆。我们已经提到过缩放，它是对角矩阵;第二个例子是旋转，它是正交矩阵。回忆(第5.2.4节)正交矩阵的逆就是它的转置。这使求旋转和刚体转换的逆变换变得很容易。此外，知道一个底部行中有[0 0 0 1]的矩阵的逆变换在底部行中也有[0 0 0 1]。</strong></p>
<p><strong>有趣的是，我们也可以用奇异值分解(SVD)来求矩阵的逆。因为我们知道任何矩阵都可以分解成旋转乘以缩放乘以旋转，反演是非常简单的。例如，在3D中</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919150249.png" class="" title="image-20210919150249">

<p><strong>从上面的规则可以很容易地得出结论</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919150259.png" class="" title="image-20210919150259">

<h2 id="Coordinate-Transformations-坐标变换"><a href="#Coordinate-Transformations-坐标变换" class="headerlink" title="Coordinate Transformations 坐标变换"></a>Coordinate Transformations 坐标变换</h2><p><strong>前面所有的讨论都是关于使用变换矩阵来移动点。我们也可以把它们看成是改变点所在的坐标系。例如，在下图中，我们看到了两种可视化运动的方法。在不同的情况下，这两种解释都可能更合适。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920110934.png" class="" title="image-20210920110934">

<p>点(2,1)有一个变换“translate by(-1,0)”作用于它。右上角是我们的目标，如果我们把这种转换看作是一种物理运动，而如果右下角是我们的目标，我们把它看作是坐标的变化(在这种情况下是原点的运动)。人工边界只是一种技巧，轴和点的相对位置在任何情况下都是相同的。</p>
<p><strong>例如，一款驾驶游戏可能包含一个城市模型和一个汽车模型。如果玩家看到的是挡风玻璃外的风景，汽车内的物体就会出现在屏幕上的相同位置，而街道和建筑则会随着玩家的驾驶而向后移动。在每一帧中，我们对这些物体应用一个变换，使它们比前一帧后退得更远。一种简单的理解方法是它将建筑向后移动;另一种思考方式是，建筑保持不变，但我们想要绘制它们的坐标系统——附在汽车上——在移动。在第二种解释中，转变是变化的城市几何体的坐标，表示为汽车坐标系中的坐标。这两种方法将导致完全相同的矩阵应用到汽车外的几何。</strong></p>
<p><strong>如果游戏还支持俯视视图来显示汽车在城市中的位置，那么建筑和街道就需要绘制在固定的位置上，而汽车则需要在帧间移动。同样的两种解释适用:我们可以把变换看作是把汽车从它的标准位置移动到它在世界上的当前位置;或者我们可以把这个变换看作是简单地改变汽车的几何坐标，它原本是用一个附加在汽车上的坐标系来表示的，而现在用一个相对于城市的固定坐标系来表示。坐标变换清楚地表明，在这两种模式(城市到汽车的坐标变化和汽车到城市的坐标变化)中使用的矩阵是彼此相反的。</strong></p>
<p><strong>改变坐标系统的想法很像编程中的类型转换的想法。在将浮点数添加到整数之前，需要根据需要将整数转换为浮点数或将浮点数转换为整数，以便类型匹配。在我们把城市和汽车画在一起之前，我们需要根据我们的需要，把城市转换成汽车坐标，或者把汽车转换成城市坐标，这样坐标才能匹配。</strong></p>
<p><strong>当管理多个坐标系统时，很容易混淆，并最终在错误的坐标中使用对象，导致它们出现在意想不到的地方。但是通过系统地考虑坐标系之间的变换，你可以可靠地得到正确的变换。</strong></p>
<p><strong>几何上，一个坐标系统或坐标系，由一个原点和一个基底组成——一个由三个向量组成的集合。标准正交基是如此的方便，我们通常假设框架是标准正交的，除非另有规定。在原点p和基{u, v, w}的坐标系中，坐标(u, v, w)描述了点</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112103.png" class="" title="image-20210920112103">

<p><strong>当我们在计算机中存储这些向量时，它们需要用某个坐标系来表示。我们必须指定一个规范的坐标系统，通常称为“全局”或“世界”坐标，用来描述所有其他系统。在城市示例中，我们可能会采用街道网格，并使用惯例，即x轴沿着主街指向，y轴向上，z轴沿着中央大道指向。然后，当我们用这些坐标写出车架的原点和基底时，我们的意思就很清楚了。</strong></p>
<p><strong>在2D中，我们的惯例是用点o作为原点，用x和y作为右手标准正交基向量x和y(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112214.png" class="" title="image-20210920112214">

<p>点p可以用任一坐标系表示。</p>
<p><strong>另一个坐标系可能有一个原点e和右手标准正交基向量u和v。注意，典型的标准数据o, x和y从来没有显式地存储。它们是所有其他坐标系的参照系。在那个坐标系中，我们通常把p的位置写成一个有序对，这是一个完整的向量表达式的简写:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112321.png" class="" title="image-20210920112321">

<p><strong>例如，在上图中(xp，yp) =(2.5, 0.9)。注意，这对(xp,yp)隐含地假设原点o。同样，我们可以用另一个方程表示p:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112334.png" class="" title="image-20210920112334">

<p><strong>在上图中，有(up, vp) =(0.5，−0.7)。同样，原点e作为u和v坐标系的隐式部分。</strong></p>
<p><strong>我们可以用矩阵机制来表达同样的关系，像这样:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112345.png" class="" title="image-20210920112345">

<p><strong>注意，这假设我们有点e和向量u和v存储在标准坐标中;(x, y)坐标系是等号中的第一个。基本类型的转换,我们在本章所讨论的,这是一个旋转(包括u和v),后跟一个平移(包括e)。观察旋转和平移的矩阵在一起,你可以看到它很容易写下:我们把u, v,和e为一个矩阵的列,通常在第三行(0 0 1)。为了更清楚，我们可以这样写这个矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112821.png" class="" title="image-20210920112821">

<p><strong>我们称这个矩阵为(u, v)坐标系的坐标系到标准矩阵。它取在(u, v)坐标系中表示的点，并将它们转换为在标准坐标系中表示的相同点。</strong></p>
<p> <strong>在另一个方向</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113107.png" class="" title="image-20210920113107">

<p><strong>这是平移后的旋转;它们是我们用来构建坐标系到标准矩阵的旋转和平移的逆，当它们相乘时，就得到了坐标系到标准矩阵的逆，也就是标准坐标系到标准矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113121.png" class="" title="image-20210920113121">

<p><strong>标准坐标系矩阵取在标准坐标系中表示的点，并将它们转换为在(u,v)坐标系中表示的相同点。我们把这个矩阵写成坐标系到正则矩阵的逆矩阵因为它不能用e u v的正则坐标直接写出来但是记住所有的坐标系都是等价的;只有我们用x和y坐标来存储向量的惯例才造成了这种表面上的不对称。正规到坐标系的矩阵可以简单地用o, x, y的(u, v)坐标表示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113130.png" class="" title="image-20210920113130">

<p><strong>所有这些想法在3D中类似，我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113139.png" class="" title="image-20210920113139">

<p><strong>和</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113151.png" class="" title="image-20210920113151">

<h1 id="7-Viewing-视图"><a href="#7-Viewing-视图" class="headerlink" title="7 Viewing 视图"></a>7 Viewing 视图</h1><p><strong>在前一章中，我们看到了如何使用矩阵变换作为工具来操作二维或三维空间中的几何对象。几何变换的第二个重要用途是在物体的3D位置和它们在3D世界的2D视图中的位置之间移动。这种从3D到2D的映射称为视口转换，它在物体顺序绘制中扮演着重要的角色，在这个过程中我们需要快速找到场景中每个物体的图像空间位置。</strong></p>
<p><strong>当我们在第4章学习光线追踪时，我们讨论了不同类型的透视视图和正投影视图，以及如何根据任意给定视图生成观察光线。本章讲述的是与此相反的过程。这里我们将解释如何使用矩阵变换来表示任何平行视图或透视图。本章中的转换将场景(世界空间)中的3D点投射到图像(图像空间)中的2D点，它们将在给定像素的观察射线上投影任何点到该像素在图像空间中的位置。</strong></p>
<p><strong>如果您最近没有看过它，在阅读本章之前，建议您回顾一下第4章中关于透视和光线生成的讨论。</strong></p>
<p><strong>就其本身而言，从世界向图像投射点的能力只适用于生成线框渲染——在这种渲染中，只绘制物体的边缘，较近的表面不会遮挡较远的表面(图7.1)。就像光线追踪器需要沿着每条观察光线找到最近的曲面交点一样，显示固体外观对象的对象顺序渲染器必须计算出在屏幕上任意给定点绘制的(可能有许多)曲面中，哪一个最接近，并只显示那一个。在本章中，我们假设绘制的模型只包含由它们的两个端点的(x, y, z)坐标指定的3D线段。后面的章节将讨论产生实体表面渲染所需的机制。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920124611.png" class="" title="image-20210920124611">

<p>左:直线投影的线框立方体。中间:透视投影的线框立方体。右图:去除隐藏线的透视投影。</p>
<h2 id="Viewing-Transformations-视图变换"><a href="#Viewing-Transformations-视图变换" class="headerlink" title="Viewing Transformations 视图变换"></a>Viewing Transformations 视图变换</h2><p><strong>视图变换的任务是将三维位置(在标准坐标系中表示为(x, y, z)坐标)映射到图像中的坐标(以像素单位表示)。它是一个复杂的东西，取决于许多不同的东西，包括相机的位置和方向，投影的类型，视野，和图像的分辨率。对于所有复杂的转换，最好将其分解为几个更简单的转换的乘积。大多数图像系统通过使用三个转换序列来做到这一点:</strong></p>
<p>​    <strong>摄像机变换或眼睛变换，这是一个刚体变换，将摄像机置于原点，使其处于一个方便的方向。它只取决于相机的位置和方向或姿势。</strong></p>
<p>​    <strong>投影变换，从相机空间投射点，使所有可见点在x和y的范围内- 1到1。它只取决于所需的投影类型。</strong></p>
<p>​    <strong>视口变换或窗口变换，它将这个单位图像矩形映射到所需的像素坐标矩形。它只取决于输出图像的大小和位置。</strong></p>
<p><strong>为了便于描述过程的各个阶段(下图)，我们为作为这些转换的输入和输出的坐标系统命名。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920130225.png" class="" title="image-20210920130225">

<p>将对象从原始坐标转换到屏幕空间的空间和转换序列。</p>
<p><strong>摄像机变换将标准坐标(或世界空间)中的点转换为摄像机坐标或将它们放置在摄像机空间中。投影变换将点从摄像机空间移动到标准视图体。最后，视口转换将规范视图卷映射到屏幕空间。</strong></p>
<p><strong>每一个变换都是非常简单的。我们将从视口转换开始详细讨论正投影的情况，然后讨论支持透视投影所需的更改。</strong></p>
<h3 id="The-Viewport-Transformation-视口变换"><a href="#The-Viewport-Transformation-视口变换" class="headerlink" title="The Viewport Transformation 视口变换"></a>The Viewport Transformation 视口变换</h3><p><strong>我们从一个问题开始，它的解决方案将被重用为任何查看条件。我们假设我们想要查看的几何图形是在正则视图体中，并且我们希望用正射相机在−z方向上查看它。正则视图体是包含所有笛卡尔坐标在−1和+1之间的三维点的立方体，即(x, y, z)∈[−1,1]³ (下图)。我们将x =−1投影到屏幕的左侧，x = +1投影到屏幕的右侧，y =−1投影到屏幕的底部，y = +1投影到屏幕的顶部。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920131502.png" class="" title="image-20210920131502">

<p>正则视图体是一个以原点为中心，边长为2的立方体。</p>
<p><em><em>回想一下第三章中关于像素坐标的约定:每个像素“拥有”一个以整数坐标为中心的单位正方形;图像边界有二分之一从像素中心的单位超调;和最小的像素中心坐标是(0,0)。如果我们绘制的图像(或屏幕上的窗口)有n</em>x* ×n*y</em> 像素，我们需要映射正方形[−1,1]² 到矩形[−0.5, nx − 0.5] × [−0.5, ny − 0.5]**</p>
<p><strong>现在，我们将假设所有要绘制的线段都完全在正则视图体内。稍后我们将在讨论裁剪时放宽这个假设。</strong></p>
<p><strong>由于视口转换将一个轴对齐的矩形映射到另一个，这是一个窗口转换的情况，如公式所示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920131817.png" class="" title="image-20210920131817">

<p><strong>注意，这个矩阵忽略了中点的z坐标，因为点在投影方向上的距离不会影响该点在图像中的投影位置。但是在我们正式称它为视口矩阵之前，我们添加一行和一列来沿着z坐标移动而不改变它。在本章中我们不需要它，但最终我们将需要z值，因为它们可以用来使较近的表面隐藏较远的表面(参见8.2.3节)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920131827.png" class="" title="image-20210920131827">

<h3 id="The-Orthographic-Projection-Transformation-正射变换"><a href="#The-Orthographic-Projection-Transformation-正射变换" class="headerlink" title="The Orthographic Projection Transformation 正射变换"></a>The Orthographic Projection Transformation 正射变换</h3><p><strong>当然，我们通常希望在空间的某些区域渲染几何体，而不是正则视图体。我们泛化视图的第一步将保持视图方向和方向固定，沿着−z和+y向上看，但将允许任意矩形被查看。我们不会替换视口矩阵，而是将其与右边的另一个矩阵相乘。</strong></p>
<p><strong>在这些约束下，视图体是一个轴对齐的框，我们将其边坐标命名为[l, r] × [b, t] × [f, n]，如图所示。我们称这个方框为直角视图体，边界平面如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920132445.png" class="" title="image-20210920132445">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920132432.png" class="" title="image-20210920132432">

<p><strong>这假设一个观察者沿着负z轴看，他的头指向y方向。这意味着n &gt; f，这可能是不直观的，但如果你假设整个正交视图体积有负的z值，那么z = n“近”平面更接近观察者，当且仅当n &gt; f;这里f比n小，也就是绝对值大于n的负数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920132415.png" class="" title="image-20210920132415">

<p>正射视图体积沿负z轴，因此f比n更负，因此n &gt; f。</p>
<p><strong>这个概念如上图所示。从正射视图体积到规范视图体积的变换是另一个窗口变换，因此我们可以简单地将正射视图体积和规范视图体积的边界代入，得到该变换的矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920132612.png" class="" title="image-20210920132612">

<p><strong>为了在正投影视图体中绘制3D线段，我们将它们投影到屏幕的x和y坐标中，而忽略z坐标。我们结合上方的方程来做这件事。请注意，在一个程序中，我们将两个矩阵相乘，形成一个矩阵，然后对点进行如下操作:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920134719.png" class="" title="image-20210920134719">

<p><strong>z坐标现在是[−1,1]。我们现在没有用它，但是当我们研究z缓冲区算法时，它会很有用。</strong></p>
<p><strong>绘制许多端点为ai 和bi的线段时变得既简单又有效:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920134907.png" class="" title="image-20210920134907">

<h3 id="The-Camera-Transformation-摄像机变换"><a href="#The-Camera-Transformation-摄像机变换" class="headerlink" title="The Camera Transformation 摄像机变换"></a>The Camera Transformation 摄像机变换</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920134940.png" class="" title="image-20210920134940">

<p>我们构建了一个右手基，其中w指向凝视的相反方向，v与g和t在同一平面上。</p>
<p><strong>我们希望能够在3D中改变视点并朝任何方向看。有许多约定来指定查看器的位置和方向。我们将使用以下方法(见下图):</strong></p>
<p>​    <strong>眼睛的位置e，</strong></p>
<p>​    <strong>注视方向g，</strong></p>
<p>​    <strong>视图向量t。</strong></p>
<p><strong>眼睛的位置是眼睛“看向”的位置。“如果你把图形看作摄影过程，它就是镜头的中心。凝视方向是观察者注视方向上的任何向量。视图向量是平面上的任意向量，它将观察者的头部分成左右两半，并且对于站在地面上的人来说指向“天空”。这些向量为我们提供了足够的信息来建立一个以e为原点，以uvw为基底的坐标系，使用第2.4.7节的构造:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920135529.png" class="" title="image-20210920135529">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920135634.png" class="" title="image-20210920135634">

<p>对于任意视图，我们需要更改存储在“适当的”坐标系统中的点。在这种情况下，它有原点e和以uvw表示的偏移坐标。</p>
<p><strong>我们的工作将完成如果所有点我们想改变存储在坐标原点e和基向量u, v,和w。但如上图所示,模型的坐标存储方面的规范(或世界)起源o和x - y和z轴。为了使用我们已经开发的机制，我们只需要转换线段端点的坐标，我们希望从xyz坐标到uvw坐标。这种变换在第6.5节中讨论过，执行这种变换的矩阵是摄像机坐标系的正则-基矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920135730.png" class="" title="image-20210920135730">

<p><strong>或者，我们可以把这个相同的变换看成是首先将e移动到原点，然后对齐u,v,w到x,y,z。</strong></p>
<p><strong>为了使我们之前的仅z轴查看算法适用于任意位置和方向的摄像机，我们只需要添加这个摄像机转换视口和投影变换的乘积，以便它在投影前将进入的点从世界转换为摄像机坐标:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920135819.png" class="" title="image-20210920135819">

<p><strong>同样，一旦矩阵基础结构就位，几乎不需要任何代码。</strong></p>
<h2 id="Projective-Transformations-投影变换"><a href="#Projective-Transformations-投影变换" class="headerlink" title="Projective Transformations 投影变换"></a>Projective Transformations 投影变换</h2><p><strong>我们把透视法留到最后因为它需要一点技巧才能使它适应到向量和矩阵变换的系统。为了了解我们需要做什么，让我们看看透视投影变换需要对摄像机空间中的点做什么。回想一下，视点定位在原点，摄像机沿着z轴观察。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111149.png" class="" title="image-20210921111149">

<p>观众的眼睛在e，凝视方向是g(负z轴)。视平面是到眼睛的距离d。一个点被投影到e，它与视图平面相交的地方就是它被画的地方。</p>
<p><strong>透视的关键属性是，屏幕上物体的大小与1/z成比例，因为在原点向上看负z轴的眼睛。这可以用上图中的几何学方程更精确地表达:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111314.png" class="" title="image-20210921111314">

<p><strong>y是点在y轴上的距离，ys就是点应该画在屏幕上的位置。</strong></p>
<p><strong>我们真的很想使用我们为正投影开发的矩阵机制来绘制透视图像;然后我们可以把另一个矩阵乘到复合矩阵中使用我们已经学过的算法。然而，这种类型的变换，其中一个输入向量的坐标出现在分母上，不能使用仿射变换来实现。</strong></p>
<p><strong>我们可以用齐次坐标机制的一个简单的推广来进行除法我们已经在仿射变换中使用过了。我们同意用齐次矢量[x y z 1]^T来表示点(x, y, z)；额外的坐标w总是等于1，这是通过使用[0 0 0 1]^T来保证的,如仿射变换矩阵的第四行。</strong></p>
<p><strong>与其将1看作是强制矩阵乘法实现平移的额外部分，我们现在将它定义为x、y和z坐标的分母:齐次向量[x y z w]^T 表示点(x/w, y/w, z/w)。当w = 1时，这没有什么区别，但如果我们允许在变换矩阵的底部行中有任何值，则允许实现更广泛的转换，从而使w得到除1以外的值。</strong></p>
<p><strong>具体地说，线性变换允许我们计算表达式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111553.png" class="" title="image-20210921111553">

<p><strong>仿射变换将它扩展到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111606.png" class="" title="image-20210921111606">

<p><strong>将w作为分母进一步扩展了可能性，允许我们计算类似于</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111745.png" class="" title="image-20210921111745">

<p><strong>这可以被称为x, y, z的“线性有理函数”，但有一个额外的约束——变换点的所有坐标的分母都是相同的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111756.png" class="" title="image-20210921111756">

<p><strong>表示为矩阵变换，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111834.png" class="" title="image-20210921111834">

<p><strong>和</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111844.png" class="" title="image-20210921111844">

<p><strong>这样的变换被称为投影变换或单应变换。</strong></p>
<p><strong>例子</strong></p>
<p><strong>矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111939.png" class="" title="image-20210921111939">

<p><strong>表示一个二维投影变换，该变换将单元正方形([0,1]×[0,1])变换为下图所示的四边形。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111952.png" class="" title="image-20210921111952">

<p>投影变换映射一个正方形为一个四边形，保留直线而不是平行线。</p>
<p><strong>例如，正方形(1,0)的右下角用齐次向量[1 0 1]^T表示并变换如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112154.png" class="" title="image-20210921112154">

<p><strong>哪个表示点(1/1/3,0/1/3)或(3,0)注意如果我们使用矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112203.png" class="" title="image-20210921112203">

<p><strong>结果是[3 0 1]^T，也表示(3,0)。实际上，任何标量乘以cM都是等价的:分子和分母都乘以c，这不会改变结果。</strong></p>
<p><strong>另一种方式来表达相同的想法，它避免了特殊处理w坐标。在这个观点中，一个3D投影变换仅仅是一个4D线性变换，额外的规定是一个向量的所有标量倍数指向同一个点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112404.png" class="" title="image-20210921112404">

<p><strong>符号~被理解为“等价于”，意思是两个齐次向量都描述了空间中的同一点。</strong></p>
<p><strong>例子</strong></p>
<p><strong>在一维齐次坐标中，我们用2个向量来表示实线上的点，我们可以用齐次向量[1.5 1]^T来表示点(1.5)，或在齐次空间中x = 1.5h直线上的任何点。(参见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112514.png" class="" title="image-20210921112514">

<p>点x = 1.5可以用直线x = 1.5h上的任意点表示，比如空心圆上的点。然而，在我们将x解释为一个常规的笛卡尔坐标之前，我们首先除以h，得到(x,h) =(1.5,1)，如黑点所示。</p>
<p><strong>在二维齐次坐标中，我们用3个向量来表示平面上的点，我们可以用齐次向量[−2;−1;2]^T表示点(−1, −0.5)，或直线x = α[−1 −0.5 1]^T上的任何其他点．直线上的任意齐次向量都可以映射到直线与平面w = 1得到它的笛卡尔坐标。(参见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112730.png" class="" title="image-20210921112730">

<p>齐次坐标中的一点等价于通过它和原点的直线上的任何点，对这一点进行归一化，等于这条直线与平面w = 1相交。</p>
<p><strong>可以根据需要多次变换齐次向量，而不必担心w坐标的值——事实上，如果w坐标在某个中间相位为零，那是可以的。只有当我们想要普通的笛卡尔坐标的点我们需要规范化的等价点w = 1,相当于所有坐标除以w。一旦我们这样做我们可以读出(x, y, z)前三个组件的坐标齐次向量。</strong></p>
<h2 id="Perspective-Projection-透视投影"><a href="#Perspective-Projection-透视投影" class="headerlink" title="Perspective Projection 透视投影"></a>Perspective Projection 透视投影</h2><p><strong>射影变换的机制使实现透视所需的z除法变得简单。在上一节首图所示的2D示例中，我们可以通过矩阵变换实现透视投影如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112958.png" class="" title="image-20210921112958">

<p><strong>这个变换了二维齐次向量[y;z;1]^T 到一维齐次矢量[dy z]^T，表示一维点(dy/z)(因为它等价于一维齐次矢量[dy/z 1]T)。</strong></p>
<p><strong>对于3D中的“官方”透视投影矩阵，我们将采用我们通常的惯例，即原点的摄像机面向- z方向，因此点(x, y, z)的距离为- z。与正投影一样，我们也采用近平面和远平面的概念，这限制了可见距离的范围。在这种情况下，我们将使用近平面作为投影平面，因此像平面距离为−n。</strong></p>
<p><strong>所需的映射是ys= (n/z)y, x也是如此。这个变换可以通过透视矩阵来实现:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113151.png" class="" title="image-20210921113151">

<p><strong>第一行、第二行和第四行只是实现透视图方程。第三行，就像在正字法和视口矩阵中一样，被设计为带着z坐标，以便我们以后可以使用它来移除隐藏的表面。但是在透视投影中，加上一个非常数分母会让我们无法保持z的值——实际上不可能在得到x和y的同时保持z不变。相反，对于近平面或远平面上的点，我们选择保持z不变。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113305.png" class="" title="image-20210921113305">

<p>透视投影保持z = n平面上的点不变并映射，大z = f矩形在透视体的后面到小z = f矩形在正投影体的后面。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113315.png" class="" title="image-20210921113315">

<p>透视投影将任何通过原点/眼睛的线映射到与之平行的线z轴，并且不移动直线上z = n的点。</p>
<p><strong>有许多矩阵可以作为透视矩阵，它们都是非线性扭曲z坐标的。这个矩阵具有如上两图所示的良好性质;它让(z = n)平面上的点完全独立，也让(z = f)平面上的点在x和y中以适当的数量“挤压”它们。矩阵对点的影响</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113503.png" class="" title="image-20210921113503">

<p><strong>正如你所看到的,x和y是按比例缩小的,更重要的是,除以z。因为n和z(视图内卷)是消极的,没有“翻转”x和y。虽然它不明显,变换还保留之间的相对顺序z值z = n和z = f,允许我们做深度排序后这个矩阵。这在我们以后做隐面消除时很重要。</strong></p>
<p><strong>有时我们想求P的逆，例如，把屏幕坐标加z带回到原来的空间，就像我们想做的那样挑选。逆是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113702.png" class="" title="image-20210921113702">

<p><strong>由于齐次向量乘以标量不会改变它的意义，所以对齐次向量作用的矩阵也是如此。所以我们可以通过乘以nf把逆矩阵写成更漂亮的形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113711.png" class="" title="image-20210921113711">

<p><strong>在正投影矩阵Morth的背景下，透视矩阵简单地将透视视图体积(形状像金字塔的切片或截锥)映射到正射视图体积(轴对齐的框)。透视矩阵的美妙之处在于，一旦我们应用它，我们可以使用一个正交变换来得到规范的视图体积。因此，所有的正字法机制都适用，我们所添加的只是一个矩阵和除以w。而且，我们没有“浪费”4 × 4矩阵的底部行。</strong></p>
<p><strong>连接P和Morth 得到透视投影矩阵，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113934.png" class="" title="image-20210921113934">

<p><strong>然而，有一个问题是:l,r,b,t是如何确定的?它们确定了我们观察的“窗口”。由于透视矩阵不改变(z = n)平面上x和y的值，我们可以指定(l, r, b, t)在该平面上。</strong></p>
<p><strong>为了将透视矩阵集成到我们的正字法基础结构中，我们只需替换Morth与Mper，将透视矩阵P插入相机矩阵Mcam 但在正投影之前。所以透视法的全部矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114158.png" class="" title="image-20210921114158">

<p><strong>得到的算法是:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114324.png" class="" title="image-20210921114324">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114342.png" class="" title="image-20210921114342">

<p><strong>注意，除了附加矩阵之外，唯一的变化是除以齐次坐标w。</strong></p>
<p><strong>乘出来，矩阵Mper 是这样的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114424.png" class="" title="image-20210921114424">

<p><strong>这种或类似的矩阵经常出现在文档中，当人们意识到它们通常是几个简单矩阵的乘积时，它们就不那么神秘了。</strong></p>
<p><strong>例子</strong></p>
<p><strong>许多API，如OpenGL (Shreiner, Neider, Woo， &amp; Davis, 2004)使用这里展示的相同规范视图量。他们还通常让用户指定n和f的绝对值。OpenGL的投影矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114505.png" class="" title="image-20210921114505">

<p><strong>其他API分别将n和f发送给0和1。Blinn (J. Blinn, 1996)建议使规范视图体积[0,1]³更有效率。所有这些决定会稍微改变投影矩阵。</strong></p>
<h2 id="Some-Properties-of-the-Perspective-Transform-透视变换的性质"><a href="#Some-Properties-of-the-Perspective-Transform-透视变换的性质" class="headerlink" title="Some Properties of the Perspective Transform 透视变换的性质"></a>Some Properties of the Perspective Transform 透视变换的性质</h2><p><strong>透视变换的一个重要特性是它将直线转换为直线，将平面转换为平面。此外，它将视图体积中的线段取为线在标准体积中的部分。要了解这一点，考虑线段</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104158.png" class="" title="image-20210922104158">

<p><strong>经4 × 4矩阵M变换后，为齐次坐标可能变化的点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104219.png" class="" title="image-20210922104219">

<p><strong>均匀化的三维线段为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104230.png" class="" title="image-20210922104230">

<p><strong>如果上式可以改写为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104241.png" class="" title="image-20210922104241">

<p><strong>那么所有均匀化的点都在一条3D直线上。对上上式的蛮力操作产生这样的形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104254.png" class="" title="image-20210922104254">

<p><strong>它还证明了线段映射到保留点顺序的线段，即它们不会被重新排序或“撕破”。</strong></p>
<p><strong>将线段转换为线段的一个副产品是它将一个三角形的边和顶点转换为另一个三角形的边和顶点。因此，三角形对三角形，平面对平面。</strong></p>
<h2 id="Field-of-View-视场"><a href="#Field-of-View-视场" class="headerlink" title="Field-of-View 视场"></a>Field-of-View 视场</h2><p><strong>虽然我们可以使用(l, r, b, t)和n值指定任何窗口，但有时我们希望有一个更简单的系统，我们透过窗口的中心。这意味着约束</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104637.png" class="" title="image-20210922104637">

<p><strong>如果我们还添加像素是正方形的约束，即。，则r与t的比值必须等于水平像素数与垂直像素数的比值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104646.png" class="" title="image-20210922104646">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104745.png" class="" title="image-20210922104745">

<p>视场θ是从眼睛测量的屏幕底部到屏幕顶部的角度。</p>
<p><strong>一旦nx 和ny ，则只剩下一个自由度。这通常使用上图所示的θ视场来设置。这有时被称为垂直视场，以区分左右两边的角度或对角线之间的角度。从图中我们可以看出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104803.png" class="" title="image-20210922104803">

<p><strong>如果n和θ是指定的，那么我们可以推导出t，并对更一般的观察系统使用代码。在某些系统中，n的值被硬编码成一个合理的值，因此我们少了一个自由度。</strong></p>
<h1 id="8-The-Graphics-Pipeline-图形管线"><a href="#8-The-Graphics-Pipeline-图形管线" class="headerlink" title="8 The Graphics Pipeline 图形管线"></a>8 The Graphics Pipeline 图形管线</h1><p><strong>前面几章已经建立了数学框架，我们需要看看渲染的第二种主要方法:一个一个地在屏幕上绘制对象，或者对象顺序渲染。不像在光线追踪中，我们依次考虑每个像素并找到影响其颜色的对象，我们现在将依次考虑每个几何对象并找到它可能产生影响的像素。找到图像中所有被几何元素占用的像素的过程称为光栅化，因此目标顺序绘制也可以称为光栅化绘制。所需的操作序列，从对象开始，到更新图像中的像素结束，称为图形管线。（基于光栅化的系统也称为扫描线渲染器。）</strong></p>
<p><strong>对象顺序呈现由于其效率而获得了巨大的成功。对于大型场景，数据访问模式的管理对性能至关重要，与重复搜索场景以获取遮蔽每个像素所需的对象相比，在场景中访问每一位几何图形具有显著的优势。</strong></p>
<p><strong>本章的标题表明，只有一种方法可以进行对象顺序呈现。当然这并不是真的——有两个目标迥异的图形管线的例子，一个是通过OpenGL和Direct3D等API支持交互渲染的硬件管道，另一个是用于电影制作的软件管线，支持RenderMan等API。硬件管线必须运行得足够快，以便对游戏、可视化和用户界面做出实时反应。制作管线必须尽可能呈现最高质量的动画和视觉效果，并将规模扩大到巨大的场景，但这可能需要很多时间有更多的时间。尽管这些不同的目标导致了不同的设计决策，但在大多数(如果不是全部)管线中，有相当一部分是共享的，本章试图关注这些共同的基础，错误的是更紧密地跟随硬件管线。</strong></p>
<p><strong>在对象顺序渲染中需要完成的工作可以组织到光栅化本身的任务中，光栅化之前对几何体所做的操作，以及光栅化之后对像素所做的操作。最常见的几何操作是应用矩阵变换，如前两章所讨论的，将定义几何的点从对象空间映射到屏幕空间，以便光栅化器的输入以像素坐标或屏幕空间表示。最常见的像素操作是隐藏的表面移除，它让离观察器更近的表面出现在离观察器更远的表面前面。在每个阶段还可以包含许多其他操作，从而使用相同的通用流程实现各种不同的渲染效果。</strong></p>
<p><strong>出于本章的目的，我们将根据四个阶段来讨论图形管道(下图)。几何对象从交互式应用程序或场景描述文件输入到管线中，它们总是由顶点集描述。在顶点处理阶段对顶点进行操作，然后使用这些顶点的原语被发送到光栅化阶段。光栅化器将每个原语分解成若干片段，每个片段对应原语覆盖的每个像素。在碎片处理阶段对碎片进行处理，然后在碎片混合阶段对每个像素对应的各个碎片进行组合。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923095933.png" class="" title="image-20210923095933">

<p><strong>我们将从讨论光栅化开始，然后通过一系列的例子说明几何和像素级的目的。</strong></p>
<h2 id="Rasterization-光栅化"><a href="#Rasterization-光栅化" class="headerlink" title="Rasterization 光栅化"></a>Rasterization 光栅化</h2><p><strong>光栅化是对象顺序图形的核心操作，而光栅化是任何图形管线的中心。对于每个传入的原语，光栅化器有两个任务:枚举原语所覆盖的像素，并在原语中插入称为属性的值——这些属性的用途将在后面的示例中明确。光栅化器的输出是一组片段，每个片段对应原语覆盖的每个像素。每个片段“存在”在一个特定的像素上，并携带自己的一组属性值。</strong></p>
<p><strong>在本章中，我们将介绍光栅化，以便使用它来渲染三维场景。同样的光栅化方法用于绘图也可以使用2D的线条和形状——尽管使用3D图形系统“在幕后”绘制所有2D图形已经变得越来越普遍。</strong></p>
<h3 id="Line-Drawing-绘制直线"><a href="#Line-Drawing-绘制直线" class="headerlink" title="Line Drawing 绘制直线"></a>Line Drawing 绘制直线</h3><p><strong>大多数图形包都包含一个线绘制命令，它在屏幕坐标中接受两个端点，并在它们之间绘制一条线。例如，调用端点(1,1)和(3,2)将打开像素(1,1)和(3,2)，并在它们之间填充一个像素。对于一般的屏幕坐标端点(x0,y0)和(x1,y1)，程序应该绘制一些“合理的”像素集合，以近似它们之间的一条线。画这样的直线是基于直线方程的，我们有两种类型的方程可以选择:隐式方程和参数方程。本节介绍使用隐式直线的方法。</strong></p>
<h4 id="Line-Drawing-Using-Implicit-Line-Equations-用隐式直线方程绘制直线"><a href="#Line-Drawing-Using-Implicit-Line-Equations-用隐式直线方程绘制直线" class="headerlink" title="Line Drawing Using Implicit Line Equations 用隐式直线方程绘制直线"></a>Line Drawing Using Implicit Line Equations 用隐式直线方程绘制直线</h4><p><strong>使用隐式方程画线最常见的方法是中点算法(Pitteway (1967);范肯和诺瓦克(1985))。中点算法最终绘制的线与Bresenham算法(Bresenham, 1965)相同，但它在某种程度上更直接。</strong></p>
<p><strong>首先要做的是找到这条直线的隐式方程:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923104351.png" class="" title="image-20210923104351">

<p>*<em>我们假设x0 <em>≤x</em>1．如果它不成立，我们交换点，使它成立。直线的斜率m是</em>*</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923104413.png" class="" title="image-20210923104413">

<p><strong>下面的讨论假设m∈(0,1]。对于m∈(−∞，−1]，m∈(−1,0]，m∈(1，∞)也可以得到类似的讨论。这四种情况涵盖了所有的可能性。</strong></p>
<p><strong>对于m∈(0,1)，“跑”比“升”多，即如果我们有一个y轴向下的API，我们可能会担心这是否会使过程更困难，但事实上，我们可以忽略这个细节。我们可以忽略“上”和“下”的几何概念，因为这两种情况的代数是完全相同的。中点算法的关键假设是我们尽可能画出最细的线没有差距。两个像素之间的对角线连接不被认为是一个间隙。</strong></p>
<p><strong>当线条从左端点向右移动时，只有两种可能:在与左端点相同的高度绘制一个像素，或者在更高的高度绘制一个像素。在端点之间的每一列像素中总是有一个精确的像素。0表示有空隙，2表示这条线太粗了。对于我们所考虑的情况，可能在同一行中有两个像素;这条线是水平的，而不是垂直的，所以有时它会向右，有时向上。这个概念如图所示，其中显示了三条“合理”的线，每条线在水平方向上比在垂直方向上前进得更多。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923104824.png" class="" title="image-20210923104824">

<p>三条“合理的”线，水平方向7个像素，垂直方向3个像素。</p>
<p><strong>m∈(0,1)的中点算法首先建立最左边的像素和最右边像素的列数(x值)，然后水平循环建立每个像素的行(y值)。算法的基本形式为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923104932.png" class="" title="image-20210923104932">

<p><strong>注意x和y是整数。也就是说，“保持从左到右绘制像素，有时在y方向上移动。关键是在if语句中建立有效的决策方法。</strong></p>
<p><strong>做出选择的一种有效方法是查看两个潜在像素中心之间的线的中点。更具体地说,只是画像素(x, y)的中心在实际屏幕坐标(x, y)候选像素是吸引到正确的像素(x + 1, y)和(x + 1, + 1)。这两个候选人的中心像素之间的中点是(x + 1, y + 0.5)。如果直线通过中点以下，我们绘制底部像素，否则我们绘制顶部像素(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105044.png" class="" title="image-20210923105044">

<p>上:线在中点之上，所以上面的像素被画出来。底部:线在中点以下，因此底部像素被绘制。</p>
<p><strong>为了确定直线是通过(x+1, y+0.5)还是通过(x, y+0.5)，我们在直线隐式方程中计算f(x, y+0.5)。回忆一下第2.5.1节，f(x, y) = 0是直线上的点(x, y)，直线一侧的点f(x, y) &gt;0，直线另一侧的点f(x, y) &lt; 0。因为−f(x, y) = 0和f(x, y) = 0都是直线的完美方程，所以f(x, y)为正是否表示(x, y)在直线之上或之下并不是立即明确的。但是，我们可以算出来;直线隐式方程中的关键项是y项(x1−x0) y。请注意,(x1 −x0)肯定是正的，因为x1&gt; x0．这意味着随着y的增加，项(x1−x0)y变大。因此，f(x， +∞)一定是正的，而且一定在直线之上，这意味着直线之上的点都是正的。另一个看它的方法是梯度向量的y分量是正的。所以在直线上，y可以任意增加，f(x, y)一定是正的。这意味着我们可以通过填充if语句使代码更具体:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105635.png" class="" title="image-20210923105635">

<p><strong>上面的代码将很好地工作的直线适当的斜率(即在0和1之间)。读者可以算出另外三种情况，它们只是在小细节上有所不同。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105742.png" class="" title="image-20210923105742">

<p>当使用两个橙色像素之间显示的决策点时，我们只画出蓝色像素，因此我们在左边显示的两个点之一计算f。</p>
<p><strong>如果需要更高的效率，使用增量方法会有所帮助。增量方法试图通过重用前一步的计算来提高循环的效率。在本文提出的中点算法中，主要计算f(x + 1, y + 0.5)的值。注意，在循环内部，在第一次迭代之后，我们已经计算了f(x−1,y + 0.5)或f(x−1,y−0.5)(上图)。还要注意这个关系:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105752.png" class="" title="image-20210923105752">

<p><strong>这允许我们编写代码的增量版本:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105912.png" class="" title="image-20210923105912">

<p><strong>这段代码应该运行得更快,因为它几乎没有额外的设置成本,增量版本(增量算法并不总是如此),但它可能积累更多数字错误,因为f (x, y + 0.5)可能是由许多长时间行补充。然而，考虑到线条很少超过几千像素，这样的错误不太可能是严重的。通过存储(x1−x0) + (y0−y1)和(y0 −y1)作为变量。我们可能希望一个好的编译器能帮我们做到这一点，但是如果代码是关键的，那么检查编译结果是明智的。</strong></p>
<h3 id="Triangle-Rasterization-三角形光栅化"><a href="#Triangle-Rasterization-三角形光栅化" class="headerlink" title="Triangle Rasterization 三角形光栅化"></a>Triangle Rasterization 三角形光栅化</h3><p><strong>我们通常想画一个二维三角形，上面有二维点p0= (x0,y0), p1= (x1,y1), p2= (x2,y2)的屏幕坐标。这类似于线描问题，但它有自己的一些微妙之处。与线描一样，我们可能希望从顶点的值中插入颜色或其他属性。如果我们有重心坐标，这就很简单了(第2.7节)。例如，如果顶点的颜色是c0,c1,c2，质心坐标(α， β， γ)三角形中某一点的颜色为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923110431.png" class="" title="image-20210923110431">

<p><strong>这种类型的颜色插值在图形中被称为高洛插值，以其发明者(高洛，1971)命名。</strong></p>
<p><strong>光栅化三角形的另一个微妙之处是，我们通常光栅化共享顶点和边的三角形。这意味着我们想要栅格化相邻的三角形，这样就没有洞了。我们可以通过使用中点算法来绘制每个三角形的轮廓，然后填充内部像素。这意味着相邻三角形沿着每条边都画出相同的像素。如果相邻三角形有不同的颜色，图像将取决于两个三角形的绘制顺序。最常见的栅格化三角形的方法是避免顺序问题和消除洞是使用约定，当且仅当像素的中心在三角形，即像素中心的重心坐标都在区间(0,1)内。这提出了一个问题，如果中心正好在三角形的边缘，该怎么办。有几种方法可以处理这个问题，本节稍后将对此进行讨论。关键的观察是，重心坐标允许我们决定是否绘制像素，以及如果我们从顶点插值颜色，该像素应该是什么颜色。因此，我们的三角形栅格化问题归结为有效地找到像素中心的重心坐标(Pineda, 1988)。蛮力光栅化算法为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923110634.png" class="" title="image-20210923110634">

<p><strong>算法的其余部分将外循环限制在更小的候选像素集上，使重心计算更加高效。</strong></p>
<p><strong>我们可以添加一个简单的效率，通过找到三个顶点的边界矩形，并只在这个矩形上循环候选像素来绘制。质心坐标可由之前讲过的方法计算。这就产生了算法:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923110737.png" class="" title="image-20210923110737">

<p><strong>这里fij是由隐式直线方程给出的带有适当顶点的直线:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923110846.png" class="" title="image-20210923110846">

<p><strong>注意，我们已经将检验α∈(0,1)与α &gt; 0等进行了交换，因为如果所有的α， β， γ都是正的，那么我们知道它们都小于1，因为α + β + γ = 1。我们也只能计算三个重心变量中的两个然后从这个关系中得到第三个，但是不清楚一旦算法进行增量，这是否节省了计算，这在线图算法中是可能的;α， β和γ的每一个计算都是f(x, y) = Ax + By + C的形式。在内部循环中，只有x改变，它改变1。注意f(x + 1, y) = f(x, y) + A，这是增量算法的基础。在外循环中，f(x, y)的求值变化为f(x, y + 1)，因此可以达到类似的效果。因为α， β和γ在循环中以恒定的增量变化，颜色c也是如此。所以这也可以是增量的。例如，像素(x + 1, y)的红色值与像素(x, y)的红色值相差一个可预先计算的常量。一个带有颜色插值的三角形示例如图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923111110.png" class="" title="image-20210923111110">

<p>一个带重心插值的彩色三角形。注意，颜色组件的变化在每行、每列以及每条边都是线性的。事实上，它在每条直线上都是常数，比如对角线。</p>
<h4 id="Dealing-with-Pixels-on-Triangle-Edges-处理三角形边缘上的像素"><a href="#Dealing-with-Pixels-on-Triangle-Edges-处理三角形边缘上的像素" class="headerlink" title="Dealing with Pixels on Triangle Edges 处理三角形边缘上的像素"></a>Dealing with Pixels on Triangle Edges 处理三角形边缘上的像素</h4><p><strong>我们还没有讨论如何处理中心正好在三角形边缘的像素。如果一个像素恰好在三角形的边缘，那么它也在相邻三角形的边缘(如果有相邻三角形的话)。没有一种明显的方法将像素授予一个三角形或另一个三角形。最糟糕的决定是不画像素，因为两个三角形之间会出现一个洞。更好的方法是让两个三角形都绘制像素，但仍然不是很好。如果三角形是透明的，就会产生双色。我们希望将像素分配给其中一个三角形，我们希望这个过程能够简单些;选择哪个三角形并不重要，只要选择是明确的。</strong></p>
<p><strong>一种方法是注意任何离屏点都是在共享边的一边，这就是我们要画的边。对于两个不重叠的三角形，不在边上的顶点在边的相对边上。恰好有一个顶点与离屏点位于同一边(下图)。这是测试的基础。测试数字p和q是否具有相同的符号可以实现为测试pq &gt; 0，这在大多数环境中非常有效。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923111407.png" class="" title="image-20210923111407">

<p>屏幕外的点将在三角形边还是其他边。只有一个非共享顶点a和b在同一边。</p>
<p><strong>请注意，测试并不完美，因为通过边缘的线也可能通过屏幕外的点，但我们至少大大减少了问题案例的数量。使用哪个屏幕外点是任意的，(x, y) =(−1，−1)是一个很好的选择。我们将需要添加一个检查的情况下，一个点正好在边缘上。我们希望这种检查不触及普通情况下，这是完全内部或外部测试。这表明:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923111551.png" class="" title="image-20210923111551">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923111609.png" class="" title="image-20210923111609">

<p><strong>我们可能认为，只有当我们对两个三角形使用完全相同的直线方程时，上述代码才能消除洞和重复绘制。事实上，只有当两个共享顶点在每个三角形的绘制调用中具有相同的顺序时，直线方程才是相同的。否则方程可能会倒过来。这可能是一个问题，取决于编译器是否更改操作顺序。因此，如果需要健壮的实现，可能需要检查编译器和算术单元的细节。上面伪代码中的前四行必须仔细编码，以处理边缘正好碰到像素中心的情况。</strong></p>
<p><strong>除了适应增量实现之外，还有几个潜在的早期退出点。例如，如果α是负的，就不需要计算β或γ。虽然这可能会很好地提高速度，但分析总是一个好主意;额外的分支可能会减少管线或并发性，并可能降低代码速度。因此，与往常一样，如果代码是关键部分，请测试任何看起来有吸引力的优化。</strong></p>
<p><strong>上述代码的另一个细节是，对于退化三角形，除法可以是被零除法，即如果fγ = 0。应该正确地考虑浮点错误条件，否则就需要进行另一个测试。</strong></p>
<h3 id="Clipping-裁剪"><a href="#Clipping-裁剪" class="headerlink" title="Clipping 裁剪"></a>Clipping 裁剪</h3><p><strong>简单地将原语转换到屏幕空间并对它们进行光栅化并不能完全独立地工作。这是因为在视图体积之外的原语——特别是在眼睛后面的原语可能最终被光栅化，导致不正确的结果。例如，考虑下图中所示的三角形。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112055.png" class="" title="image-20210923112055">

<p>深度z转换成深度z′通过透视变换。注意当z从正到负，z′从负转换为正。因此，眼睛后面的顶点在眼睛前面移动超过z′ = n + f。这将导致错误的结果，这就是为什么三角形首先被裁剪，以确保所有顶点都在眼睛前面。</p>
<p><strong>两个顶点在视图体中，但第三个顶点在眼睛后面。投影变换将这个顶点映射到远平面后面一个毫无意义的位置，如果允许这种情况发生，三角形将不正确地光栅化。由于这个原因，光栅化之前必须进行一个剪切操作，删除部分可能延伸到眼睛后面的原语。</strong></p>
<p><strong>裁剪是图形中的一种常见操作，每当一个几何实体“裁剪”另一个实体时都需要它。例如，如果你在平面x = 0上裁剪一个三角形，如果顶点的x坐标的符号不完全相同，那么平面会将三角形切割成两部分。在大多数剪切应用中，在平面的“错误”边的三角形部分被丢弃。单个平面的操作如图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112330.png" class="" title="image-20210923112330">

<p>一个多边形被剪切到剪切平面上。平面的“内部”部分被保留。</p>
<p><strong>在为光栅化做准备的裁剪中，“错误”的一面是视图体外的一面。将视图体外的所有几何图形裁剪总是安全的——也就是说，将视图体的所有六个面都剪掉——但许多系统只能将视图体的近平面剪掉。</strong></p>
<p><strong>本节讨论裁剪模块的基本实现。那些对实现工业速度的裁剪器感兴趣的人应该看看Blinn在本章末尾的注释中提到的书。</strong></p>
<p><strong>实现裁剪的两种最常见的方法是：</strong></p>
<p>​    <strong>1.在世界坐标系中，用六个平面来连接截断的视锥金字塔，</strong></p>
<p>​    <strong>2.在齐次除法之前的四维变换空间中。</strong></p>
<p><strong>任何一种可能性都可以有效地实现(J. Blinn, 1996)，对每个三角形采用以下方法:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112619.png" class="" title="image-20210923112619">

<h3 id="Clipping-Before-the-Transform-Option-1-变换前的裁剪-选项1"><a href="#Clipping-Before-the-Transform-Option-1-变换前的裁剪-选项1" class="headerlink" title="Clipping Before the Transform (Option 1) 变换前的裁剪(选项1)"></a>Clipping Before the Transform (Option 1) 变换前的裁剪(选项1)</h3><p><strong>选项1有一个简单的实现。唯一的问题是，“这六个平面方程是什么?”“因为这些方程对于单一图像中呈现的所有三角形都是相同的，我们不需要非常高效地计算它们。出于这个原因，我们可以将转换反转并应用转换后的视图体积的8个顶点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112806.png" class="" title="image-20210923112806">

<p><strong>从这里可以推导出平面方程。或者，我们可以使用矢量几何直接从观看参数得到平面。</strong></p>
<h3 id="Clipping-in-Homogeneous-Coordinates-Option-2-齐次坐标裁剪-选项2"><a href="#Clipping-in-Homogeneous-Coordinates-Option-2-齐次坐标裁剪-选项2" class="headerlink" title="Clipping in Homogeneous Coordinates (Option 2) 齐次坐标裁剪(选项2)"></a>Clipping in Homogeneous Coordinates (Option 2) 齐次坐标裁剪(选项2)</h3><p><strong>通常实现的选项是在除法之前在齐次坐标中进行裁剪。这里的视图体是4D的，它被3D体(超平面)所包围。它们是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112928.png" class="" title="image-20210923112928">

<p><strong>这些平面非常简单，所以效率比选择1更好。它们仍然可以通过将视图体积[l, r] × [b, t] × [f, n]转换为[0,1]³来改进。事实证明，三角形的裁剪并不比3D复杂多少。</strong></p>
<h3 id="Clipping-against-a-Plane-平面相交裁剪"><a href="#Clipping-against-a-Plane-平面相交裁剪" class="headerlink" title="Clipping against a Plane 平面相交裁剪"></a>Clipping against a Plane 平面相交裁剪</h3><p><strong>无论我们选择哪一种，我们都必须与一个平面相交。回想一下第2.5.5节，平面通过点q且法线n的隐式方程是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113253.png" class="" title="image-20210923113253">

<p><strong>这经常被写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113306.png" class="" title="image-20210923113306">

<p><strong>有趣的是，这个方程不仅描述了一个三维平面，还描述了一条二维的直线和一个四维平面的体积模拟。所有这些实体在其相应的维度上通常被称为平面。</strong></p>
<p><strong>如果我们有一条线段在点a和点b之间，我们可以使用在第12.4.3节描述的BSP树程序中切割3D三角形的边的技术将它“裁剪”到一个平面上。在这里，通过检查f(a)和f(b)是否有不同的符号来测试点a和b是否在平面f(p) = 0的相对两边。通常，f(p) &lt; 0被定义为“在”平面内，而f(p) &gt; 0被定义为“在”平面外。如果平面确实分割了直线，那么我们可以通过将方程代入参数直线来求交点，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113317.png" class="" title="image-20210923113317">

<p><strong>在平面通过点q且法线n的隐式方程的f(p) = 0平面上：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113325.png" class="" title="image-20210923113325">

<p><strong>解t得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113336.png" class="" title="image-20210923113336">

<p><strong>然后我们可以找到交点并“缩短”这条线。</strong></p>
<p><strong>为了裁剪一个三角形，我们可以按照12.4.3节来制作一个或两个三角形。</strong></p>
<h2 id="Operations-Before-and-After-Rasterization-光栅化的前后操作"><a href="#Operations-Before-and-After-Rasterization-光栅化的前后操作" class="headerlink" title="Operations Before and After Rasterization 光栅化的前后操作"></a>Operations Before and After Rasterization 光栅化的前后操作</h2><p><strong>在可以光栅化一个原语之前，定义它的顶点必须在屏幕坐标中，并且应该在原语中插入的颜色或其他属性必须是已知的。准备这些数据是管线顶点处理阶段的工作。在这个阶段，进入的顶点通过建模、查看和投影转换进行转换，将它们从原始坐标映射到屏幕空间(回想一下，在这里，位置是用像素度量的)。同时，其他信息，如颜色、表面法线或纹理坐标，将根据需要进行转换;我们将在下面的示例中讨论这些附加属性。</strong></p>
<p><strong>光栅化后，进一步处理，为每个碎片计算颜色和深度。这个处理过程可以简单到只需通过一个插值的颜色和使用光栅化器计算的深度;或者包括复杂的着色操作。最后，混合阶段结合由重叠每个像素的(可能是几个)原语生成的片段来计算最终的颜色。最常见的混合方法是用最小的深度(最接近眼睛)选择碎片的颜色。</strong></p>
<p><strong>不同阶段的目的最好通过例子来说明。</strong></p>
<h3 id="Simple-2D-Drawing-简单的2D绘制"><a href="#Simple-2D-Drawing-简单的2D绘制" class="headerlink" title="Simple 2D Drawing 简单的2D绘制"></a>Simple 2D Drawing 简单的2D绘制</h3><p><strong>最简单的管线在顶点或片段阶段什么都不做，在混合阶段，每个片段的颜色只是覆盖前一个片段的值。应用程序直接在像素坐标中提供原语，光栅化完成所有工作。这种基本安排是许多用于绘制用户界面、绘图、图形和其他2D内容的简单、较老的API的精髓。纯色形状可以通过为每个原语的所有顶点指定相同的颜色来绘制，我们的模型管道也支持使用插值平滑地变化颜色。</strong></p>
<h3 id="A-Minimal-3D-Pipeline-最小的化3D管线"><a href="#A-Minimal-3D-Pipeline-最小的化3D管线" class="headerlink" title="A Minimal 3D Pipeline 最小的化3D管线"></a>A Minimal 3D Pipeline 最小的化3D管线</h3><p><strong>绘制3D对象,唯一的变化需要的2D绘图管线是一个矩阵变换:顶点处理阶段计算的顶点位置的产品建模、相机,投影,和视窗矩阵,导致空间三角形,然后在指定的一样,如果他们已经直接在2D。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923114158.png" class="" title="image-20210923114158">

<p>两个遮挡周期，不能画出来前后颠倒的顺序。</p>
<p><strong>最小3D管道的一个问题是，为了获得正确的遮挡关系——让较近的物体在较远的物体前面——原语必须按照前后顺序绘制。这被称为画家去除隐藏表面的算法，类似于先画一幅画的背景，然后在它上面画前景。画家的算法是去除隐藏表面的完美有效方法，但它有几个缺点。它不能处理彼此相交的三角形，因为没有正确的顺序来画它们。类似地，几个三角形，即使它们没有相交，仍然可以被安排在一个闭塞循环中，如上图所示，这是另一种前后顺序不存在的情况。最重要的是，根据深度对原语进行排序很慢，特别是在大场景中，并且干扰了数据的有效流动，这使得对象顺序渲染如此之快。下图显示了不按深度对对象排序时的处理结果。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923114209.png" class="" title="image-20210923114209">

<p>用最小的管道绘制两个相同大小的球体的结果。看起来较小的球体距离较远，但却是最后绘制的，因此它错误地覆盖了较近的球体。</p>
<h3 id="Using-a-z-Buffer-for-Hidden-Surfaces-为隐藏表面使用z-Buffer"><a href="#Using-a-z-Buffer-for-Hidden-Surfaces-为隐藏表面使用z-Buffer" class="headerlink" title="Using a z-Buffer for Hidden Surfaces 为隐藏表面使用z-Buffer"></a>Using a z-Buffer for Hidden Surfaces 为隐藏表面使用z-Buffer</h3><p><strong>实践中，画家算法很少被使用;取而代之的是一种简单而有效的隐藏表面去除算法，即z-缓冲区算法。这个方法非常简单:在每个像素处，我们跟踪到目前为止绘制的最近的表面的距离，然后丢弃比这个距离更远的碎片。最近距离是通过为每个像素分配一个额外的值来存储的，除了红色、绿色和蓝色的值，这被称为深度，或z值。深度缓冲区，或z-缓冲区，是包含深度值的网格的名称。</strong></p>
<p><strong>z-buffer算法是在碎片混合阶段实现的，通过比较每个碎片的深度与z-buffer中存储的当前值。如果片段的深度比较接近，它的颜色和深度值都会覆盖颜色和深度缓冲区中当前的值。如果碎片的深度较远，它将被丢弃。为了确保第一个片段将通过深度测试，z缓冲区被初始化为最大深度(远平面的深度)。无论表面的绘制顺序如何，相同的碎片将赢得深度测试，图像将是相同的。</strong></p>
<p><strong>z-buffer算法要求每个片段携带一个深度。这只需将z坐标插值为顶点属性，就像插值颜色或其他属性一样。</strong></p>
<p><strong>z缓冲区是处理对象顺序渲染中隐藏表面的一种简单而实用的方法，它是目前最主要的方法。它比将表面切割成可以按深度排序的块的几何方法简单得多，因为它避免了解决任何不需要解决的问题。深度顺序只需要在像素的位置上确定，这就是z缓冲区所做的。它得到了硬件图形管线的普遍支持，也是软件管线最常用的方法。下图显示了一个示例结果。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923114643.png" class="" title="image-20210923114643">

<p>结果是用z缓冲区画出两个相同的球体。</p>
<h4 id="Precision-Issues-精度问题"><a href="#Precision-Issues-精度问题" class="headerlink" title="Precision Issues 精度问题"></a>Precision Issues 精度问题</h4><p><strong>实际上，存储在缓冲区中的z值是非负整数。这比真正的浮点数更可取，因为z缓冲区所需的快速内存有点昂贵，值得保持在最小值。</strong></p>
<p><strong>使用整数会导致一些精度问题。如果我们使用一个整数范围有B值{0,1,…,B−1},裁剪面附近我们可以映射0到z = n和B−1到遥远的剪切面z = f。注意,这次讨论,我们假设z, n, f是正的。这将导致与否定情况相同的结果，但论证的细节更容易理解。我们将每个z值发送到a“桶”，深度Δz = (f−n)/B。如果内存不是额外的，我们就不会使用整数z缓冲区，因此使B尽可能小是很有用的。</strong></p>
<p><strong>如果分配b位来存储z值，那么B = 2^b．我们需要足够的位来确保任何三角形在另一个三角形前面的深度映射到不同的深度箱子。</strong></p>
<p><strong>例如，如果您正在渲染一个场景，其中三角形的间距至少为一米，那么Δz &lt; 1应该生成没有伪影的图像。有两种方法可以使Δz变小:将n和f移得更近或增加b。如果b是固定的，就像在API或特定硬件平台上一样，调整n和f是唯一的选择。</strong></p>
<p><strong>当创建透视图像时，z缓冲区的精度必须非常小心地处理。上面的值Δz是在透视划分之后使用的。回忆一下在第7.3节中透视图划分的结果是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923115137.png" class="" title="image-20210923115137">

<p><strong>实际的桶深与zw有关，世界深度，而不是z，后透视分深度。我们可以通过区分两边来近似桶的大小:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923115159.png" class="" title="image-20210923115159">

<p><strong>桶大小的深度各不相同。世界空间的箱子大小是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923115210.png" class="" title="image-20210923115210">

<p><strong>请注意，Δz的数量与前面讨论的相同。最大的箱子′= f,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923115221.png" class="" title="image-20210923115221">

<p><strong>请注意，如果我们不想在眼前丢失对象，选择n = 0是很自然的选择，这将导致一个无限大的箱子——非常糟糕的情况。让Δzw^max尽可能的小，我们需要最小化f和n。因此，仔细选择n和f总是很重要的。</strong></p>
<h3 id="Per-vertex-Shading-逐顶点着色"><a href="#Per-vertex-Shading-逐顶点着色" class="headerlink" title="Per-vertex Shading 逐顶点着色"></a>Per-vertex Shading 逐顶点着色</h3><p><strong>到目前为止，将三角形发送到管线中的应用程序负责设置颜色;光栅化器只是插入颜色，它们直接写入输出图像。对于某些应用程序来说，这已经足够了，但在很多情况下，我们想要用着色影来绘制3D对象，使用与第4章中用于图像顺序渲染的相同的渲染方程。回想一下，这些方程需要光方向、眼睛方向和表面法线来计算表面的颜色。</strong></p>
<p><strong>处理着色计算的一种方法是在顶点阶段执行它们。应用程序提供顶点的法向量，并且光源的位置和颜色是单独提供的(它们不会在整个表面上变化，所以它们不需要为每个顶点指定)。对于每个顶点，观察者的方向和每个光源的方向都是基于摄像机、光源和顶点的位置计算的。计算所需的着色方程来计算颜色，然后将其作为顶点颜色传递给光栅化器。每顶点着色有时被称为Gouraud着色。</strong></p>
<p><strong>需要做的一个决定是在做着色计算的坐标系中。世界空间或眼睛空间都是不错的选择。在世界空间中选择一个标准正交的坐标系是很重要的，因为着色方程依赖于向量之间的角度不被建模转换中经常使用的非均匀缩放操作所保留，或者透视投影，通常用于规范化视图体积的投影。视图空间中的着色有一个优点，我们不需要跟踪摄像机的位置，因为在透视投影中，摄像机总是在视图空间的原点，或者在正射影中，视图的方向总是+z。</strong></p>
<p><strong>逐顶点着色的缺点是，它不能在着色中产生比绘制表面所用的原语更小的细节，因为它只对每个顶点计算一次着色，而从不在顶点之间计算。例如,在一个房间的地板是用两个大三角形和光源照亮房间的中间,着色将评估只在房间的角落,和插入值可能会太黑暗的中心。此外，曲面的着色与高光必须使用原语小到足以解决高光。</strong></p>
<p><strong>下图显示了我们用逐顶点着色绘制的两个球体。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923120147.png" class="" title="image-20210923120147">

<p>两个球体使用每顶点(Gouraud)着色绘制。因为三角形很大，所以可以看到插值伪影。</p>
<h3 id="Per-fragment-Shading-逐片着色"><a href="#Per-fragment-Shading-逐片着色" class="headerlink" title="Per-fragment Shading 逐片着色"></a>Per-fragment Shading 逐片着色</h3><p><strong>逐片段着色有时被称为Phong着色，因为相同的名称附加到Phong光照模型。</strong></p>
<p><strong>为了避免与逐顶点着色相关的插值伪影，我们可以通过在碎片阶段的插值后执行着色计算来避免插值颜色。在每个片段着色，相同的着色方程被评估，但他们被评估为每个片段使用插值向量，而不是每个顶点使用来自应用程序的向量。</strong></p>
<p><strong>在每个碎片着色中，着色所需的几何信息作为属性通过光栅化器传递，因此顶点阶段必须与碎片阶段协调，以适当地准备数据。一种方法是插值眼空间表面法线和眼空间顶点位置，然后就可以像在每个顶点着色中那样使用它们。</strong></p>
<p><strong>下图显示了我们用每个碎片着色绘制的两个球体。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923120520.png" class="" title="image-20210923120520">

<p>使用逐片着色绘制两个球体。因为三角形很大，所以可以看到插值伪影。</p>
<h3 id="Texture-Mapping-纹理映射"><a href="#Texture-Mapping-纹理映射" class="headerlink" title="Texture Mapping 纹理映射"></a>Texture Mapping 纹理映射</h3><p><strong>纹理(在第11章中讨论)是用来为表面的着色添加额外细节的图像，否则会看起来过于均匀和人工。这个想法很简单:每次计算着色时，我们从纹理中读取一个用于着色计算的值，例如漫反射颜色，而不是使用附加到被渲染的几何图形的属性值。这个操作被称为纹理查找:着色代码指定一个纹理坐标、纹理域中的一个点和纹理映射系统在纹理图像中找到那个点的值并返回它。纹理值随后用于着色计算。</strong></p>
<p><strong>定义纹理坐标最常见的方法是简单地将纹理坐标作为另一个顶点属性。每一个原语知道它在纹理中的位置。</strong></p>
<h3 id="Shading-Frequency-着色频率"><a href="#Shading-Frequency-着色频率" class="headerlink" title="Shading Frequency 着色频率"></a>Shading Frequency 着色频率</h3><p><strong>关于在哪里放置着色计算定取决于颜色变化的速度——计算细节的比例。具有大规模特征的着色，如在曲面上的漫射着色，可以相当不频繁地评估，然后进行插值:它可以用较低的着色频率计算。产生小尺度特征的着色，如锐利的高光或详细的纹理，需要在高着色频率下进行评估。对于需要在图像中看起来清晰和清晰的细节，着色频率需要是每个像素至少一个着色样本。</strong></p>
<p><strong>因此，即使定义原语的顶点相距许多像素，也可以在顶点阶段安全地计算大规模效果。需要高着色频率的效果也可以在顶点阶段进行计算，只要顶点在图像中距离很近;或者，当基元大于像素时，可以在片段阶段计算它们。</strong></p>
<p><strong>例如，在电脑游戏中使用的硬件管线，通常使用覆盖多个像素的原语，以确保高效率，通常为每个片段进行大多数着色计算。另一方面，PhotoRealistic RenderMan系统对每个顶点进行所有的着色计算，在第一次细分或切割之后，所有的表面都被细分为小四边形，称为微多边形，大小和像素差不多。由于原语很小，在这个系统中每个顶点的着色达到了一个高的着色频率，这适合于详细的着色。</strong></p>
<h2 id="Simple-Antialiasing-简单抗锯齿"><a href="#Simple-Antialiasing-简单抗锯齿" class="headerlink" title="Simple Antialiasing 简单抗锯齿"></a>Simple Antialiasing 简单抗锯齿</h2><p><strong>就像光线追踪一样，如果我们完全或完全不确定每个像素是否在原语内部，光栅化将产生锯齿状的线条和三角形边缘。事实上,一组简单的三角形光栅化算法产生的碎片在本章所描述的,有时被称为标准或别名光栅化,是一模一样的像素集将被映射到三角形的射线示踪发送一个射线通过每个像素的中心。</strong></p>
<p><strong>同样在光线追踪中，解决方案是允许像素部分被原语覆盖(Crow, 1978)。在实践中，这种形式的模糊有助于视觉质量，特别是在动画中。如图的第一行所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210924100325.png" class="" title="image-20210924100325">

<p>一个抗锯齿和锯齿线查看近距离，所以个别像素是可见的。</p>
<p><strong>在光栅化应用中有许多不同的抗锯齿方法。就像射线追踪器一样，我们可以通过将每个像素值设置为该像素所在正方形区域上图像的平均颜色来生成抗锯齿图像，这种方法称为框过滤。这意味着我们必须将所有可绘制的实体视为具有明确定义的区域。例如，上图中的线可以被认为近似于一个像素宽的矩形。</strong></p>
<p><strong>实现盒滤波抗锯齿最简单的方法是超采样:创建非常高分辨率的图像，然后向下采样。例如,如果我们的目标是一个256×256像素图像的线宽度1.2像素,我们可以光栅化的矩形版本与宽度4.8在1024×1024像素的屏幕,然后平均4×4组像素的颜色为每个256×256像素的图像“萎缩”。这是实际框过滤图像的近似值，但当物体相对于像素之间的距离不是非常小时，效果很好。</strong></p>
<p><strong>然而，超级采样相当昂贵。由于导致走样的非常尖锐的边缘通常是由原语的边缘引起的，而不是原语内着色的突然变化，一个广泛使用的优化是以比着色更高的频率采样可见性。如果在每个像素中存储一些点的覆盖和深度信息，即使只计算一种颜色，也可以获得非常好的抗锯齿效果。在像RenderMan这样使用逐顶点着色的系统中，这是通过高分辨率的光栅化实现的:这样做并不昂贵，因为着色只是简单地插值来为许多片段或可见性样本生成颜色。在按片段着色的系统中，例如硬件管线，多样本抗锯齿是通过为每个片段存储一个单一的颜色加上覆盖掩码和一组深度值来实现的。</strong></p>
<h2 id="Culling-Primitives-for-Efficiency-剔除原语以提高效率"><a href="#Culling-Primitives-for-Efficiency-剔除原语以提高效率" class="headerlink" title="Culling Primitives for Efficiency 剔除原语以提高效率"></a>Culling Primitives for Efficiency 剔除原语以提高效率</h2><p><strong>对象顺序渲染的优势在于，它需要对场景中的所有几何图形进行一次遍历，这在复杂场景中也是一个弱点。例如，在一个完整的城市模型中，在任何给定的时间只有少数建筑可能是可见的。一个正确的图像可以通过绘制场景中的所有原语来获得，但大量的努力将被浪费在处理可见建筑后面或观众后面的几何图形上，因此不会对最终的图像做出贡献。</strong></p>
<p><strong>识别和丢弃不可见的几何图形，以节省处理它的时间，这被称为剔除。三种常用的剔除策略(通常串联使用)是</strong></p>
<p>​    <strong>视图体剔除：移除视图外的几何形状体积;</strong> </p>
<p>​    <strong>遮挡剔除：移除可能在视图体积内的几何体，但被其他靠近相机的几何体遮挡或遮挡;</strong></p>
<p>​    <strong>背向面剔除：移除背向相机的原语。</strong></p>
<p><strong>我们将简要讨论viewvolume culling和backface culling，但是在高性能系统中剔除是一个复杂的话题;参见(Akenine-M¨oller et al.， 2008)获得完整的讨论和关于遮挡剔除的信息。</strong></p>
<h3 id="View-Volume-Culling-视锥体剔除"><a href="#View-Volume-Culling-视锥体剔除" class="headerlink" title="View Volume Culling 视锥体剔除"></a>View Volume Culling 视锥体剔除</h3><p><strong>当整个原语位于视图体之外时，它可以被剔除，因为它在光栅化时不会产生碎片。如果我们可以通过快速测试剔除许多原语，我们可能会大大加快绘图速度。另一方面，单独测试原语来决定到底需要绘制哪些，可能比让光栅化器消除它们的成本更高。</strong></p>
<p><strong>视锥体剔除，也称为视锥剔除，在许多三角形被组合成一个具有相关边界体积的对象时特别有用。如果包围体位于视图体之外，那么组成对象的所有三角形也都在视图体之外。例如，如果我们有1000个三角形被一个圆心为c，半径为r的球体包围，我们可以检查球体是否位于剪切平面之外，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210924101810.png" class="" title="image-20210924101810">

<p><strong>其中a是平面上的一点，p是一个变量。这等价于检查从球的中心c到平面的带符号的距离是否大于+r。即</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210924101907.png" class="" title="image-20210924101907">

<p><strong>请注意，即使在所有三角形都位于平面外的情况下，球体也可能与平面重叠。因此，这是一个保守的测试。测试的保守程度取决于球体与物体的边界。</strong></p>
<p><strong>如果场景是按照第12章中描述的空间数据结构组织的，那么同样的想法也可以分层应用。</strong></p>
<h3 id="Backface-Culling-背面剔除"><a href="#Backface-Culling-背面剔除" class="headerlink" title="Backface Culling 背面剔除"></a>Backface Culling 背面剔除</h3><p><strong>当多边形模型封闭时，即它们限定了一个没有孔洞的封闭空间，然后通常假设它们有向外的法向量，如第10章所讨论的。对于这样的模型，面朝眼睛的多边形肯定会被面朝眼睛的多边形画过。因此，这些多边形甚至可以在管线开始之前被剔除。此条件的测试与第10.3.1节给出的轮廓图测试相同。</strong></p>
<h1 id="9-Signal-Processing-信号处理"><a href="#9-Signal-Processing-信号处理" class="headerlink" title="9 Signal Processing 信号处理"></a>9 Signal Processing 信号处理</h1><p><strong>在图形学中，我们经常处理连续变量的函数:图像是你看到的第一个例子，但随着你继续探索图形，你会遇到更多的例子。从本质上讲，连续函数不能直接在计算机中表示;我们必须用有限的比特来表示它们。表示连续函数最有用的方法之一是使用函数的样本:将函数的值存储在许多不同的点上，并在需要的时候重建它们之间的值。</strong></p>
<p><strong>现在，您已经熟悉了使用二维像素网格表示图像的概念——因此，您已经看到了采样表示。想象一幅由数码相机捕捉的图像:由相机镜头形成的实际场景图像是图像平面上位置的连续函数，相机将该函数转换为一个二维样本网格。从数学上讲，摄像机转换了R²→C(其中C是颜色的集合)到一个二维颜色样本数组，或类型为Z²→C。</strong></p>
<p><strong>另一个例子是2D数字化平板电脑，如平板电脑的屏幕或艺术家使用的单独的手写平板电脑。在这种情况下，原始的功能是手写笔的运动，这是一个时变的2D位置，或R→R²的功能．数字化仪在许多时间点测量手写笔的位置，产生一个二维坐标序列，或Z→R²．动作捕捉系统也会做同样的事情对于附加在参与者身体上的特殊标记:它将随着时间的推移获取标记的3D位置(R→R³)，并使其成为一系列的瞬时位置测量(Z→R³)．</strong></p>
<p><strong>在维度上，医用CT扫描仪，用于非侵入性检查一个人的身体内部，测量密度作为身体内部位置的函数。扫描仪的输出是一个密度值的三维网格:它转换身体的密度(R³→R)转换为实数的三维数组(Z³→R)。</strong></p>
<p><strong>这些例子看起来不同，但实际上它们都可以用完全相同的数学方法来处理。在所有情况下，函数都是在一个或多个维度的晶格点上被采样的，在所有情况下，我们都需要能够从样本数组中重建原始的连续函数。</strong></p>
<p><strong>从2D图像的例子来看，像素似乎足够了，一旦相机离散了图像，我们就再也不需要考虑连续函数了。但如果我们想让图像在屏幕上变大或变小，尤其是通过非整数比例因子?事实证明，最简单的算法执行效果很差，引入了明显的视觉伪影，即走样。解释为什么会发生走样以及理解如何防止走样需要采样理论的数学知识。生成的算法相当简单，但它们背后的推理和使它们表现良好的细节可能是微妙的。</strong></p>
<p><strong>当然，在计算机中表示连续函数并不是图形所独有的;采样和重建的想法也不是。从数字音频到计算物理的应用程序都使用采样表示，图形只是相关算法和数学的一个用户(绝不是第一个)。自20世纪20年代以来，通信领域就已经知道如何进行采样和重建的基本事实，并在20世纪40年代以我们使用的确切形式加以阐述(Shannon &amp; Weaver, 1964)。</strong></p>
<p><strong>本章首先以数字音频的一维具体例子来总结采样和重构。然后，我们继续介绍在一维和二维采样和重建基础上的基本数学和算法。最后，我们深入到频域观点的细节，这提供了许多深入了解这些算法的行为。</strong></p>
<h2 id="Digital-Audio-Sampling-in-1D-数字音频：一维采样"><a href="#Digital-Audio-Sampling-in-1D-数字音频：一维采样" class="headerlink" title="Digital Audio: Sampling in 1D 数字音频：一维采样"></a>Digital Audio: Sampling in 1D 数字音频：一维采样</h2><p><strong>虽然采样表示法已在电信中使用了多年，但随着在前十年中数字录音的使用增加，1982年激光唱片的引入，是采样技术在用户中第一次非常明显的应用。</strong></p>
<p><strong>在音频录制中，麦克风将空气中存在的压力波的声音转换成一个时变电压，该电压相当于测量麦克风所在位置处变化的气压。这种电信号需要以某种方式储存起来，以便在以后播放，然后发送到扬声器，通过与电压同步移动膜片，将电压转换回压力波。</strong></p>
<p><strong>数字方式记录音频信号(下图)使用采样:一种模拟-数字转换器(A/D转换器,或ADC)测量电压许多每秒几千次,生成的整数,可以很容易地存储在任意数量的媒体,说在电脑上一个磁盘在录音室,或者传播到另一个位置,说一个便携式音频播放器的内存。在回放时，数据以适当的速率读出并发送到数字-模拟转换器(D/A转换器，或DAC)。DAC根据它接收到的数字产生电压，并且，如果我们取足够的样本来公平地表示电压的变化，产生的电信号，对于所有实际用途来说，与输入相同。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925130536.png" class="" title="image-20210925130536">

<p>数字音频的采样和重建。</p>
<p><strong>结果表明，每秒所需的样本数量取决于我们试图录制的声音的音调有多高。如果我们试着录制短笛或钹，一个用于复制弦乐低音或踢鼓的采样率会产生奇怪的结果;但这些声音在较高的采样率下可以很好地再现。为了避免这些欠采样伪影，数字音频记录器对ADC的输入进行过滤，以去除可能导致问题的高频。</strong></p>
<p><strong>另一种问题出现在输出端。DAC产生一个电压，当一个新样品进入时，电压会发生变化，但在下一个样品之前保持不变，产生一个阶梯形图形。这些台阶就像噪音，增加了一种高频的、依赖信号的嗡嗡声。为了消除这种重构伪影，数字音频播放器对DAC的输出进行滤波，使波形平滑。</strong></p>
<h3 id="Sampling-Artifacts-and-Aliasing-采样伪影和走样"><a href="#Sampling-Artifacts-and-Aliasing-采样伪影和走样" class="headerlink" title="Sampling Artifacts and Aliasing 采样伪影和走样"></a>Sampling Artifacts and Aliasing 采样伪影和走样</h3><p><strong>数字音频记录链可以作为图形学中发生的采样和重构过程的具体模型。在图形中，图像或其他采样信号也会出现同样的欠采样和重构伪影，解决方法是:采样前滤波，重构时再滤波。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925130810.png" class="" title="image-20210925130810">

<p>以两种不同频率采样的正弦波(蓝色曲线)。上图:在高采样率下，结果样本(黑点)很好地代表了信号。下:较低的采样率产生一个模糊的结果:采样结果与采样频率更低的波(虚线曲线)的结果完全相同。</p>
<p><strong>上图显示了由过低的样本频率产生的工件类型的具体示例。在这里，我们使用两个不同的采样频率对一个简单的正弦波进行采样:顶部为每周期10.8个样本，底部为每周期1.2个样本。更高的利率产生一组样本,显然捕获信号,但产生的样本低采样率和样本的低频正弦波,面对这组样本低频正弦信号似乎更有可能的解释。</strong></p>
<p><strong>一旦采样完成，就不可能知道这两个信号——快的还是慢的正弦波——哪个是原始的，因此也没有一种方法可以在这两种情况下正确地重建信号。由于高频信号“假装”是低频信号，这种现象被称为走样。</strong></p>
<p><strong>当采样和重建的缺陷导致惊人频率的伪影时，就会出现走样。在音频中，走样以听起来奇怪的额外音调的形式出现——一个在10KHz的铃声，在被采样到8KHz后，变成了一个6赫兹的基调。在图像中，走样通常以摩尔纹的形式出现，这是由于样本网格与图像中的规则特征相互作用而产生的。</strong></p>
<p><strong>合成图像中另一个走样的例子是用黑白像素渲染的直线上的楼梯步。这是一个小尺度特征(线条的尖锐边缘)在不同尺度上创建工件的例子(对于浅斜线，楼梯台阶非常长)。</strong></p>
<p><strong>采样和重建的基本问题可以简单地根据特征太小或太大来理解，但一些更定量的问题更难回答:</strong></p>
<p>​    <strong>什么样的采样率高到足以确保良好的结果?</strong> </p>
<p>​    <strong>什么类型的过滤器适合采样和重建?</strong></p>
<p>​    <strong>为了避免走样，需要多大程度的平滑?</strong> </p>
<p><strong>这些问题的确切答案要等到我们在第9.5节中充分发展了这个理论之后</strong></p>
<h2 id="Convolution-卷积"><a href="#Convolution-卷积" class="headerlink" title="Convolution 卷积"></a>Convolution 卷积</h2><p><strong>在讨论采样和重构算法之前，我们先来看看它们所基于的数学概念——卷积。卷积是一个简单的数学概念，它是用于采样、滤波和重构的算法的基础。这也是我们在本章后面分析这些算法的基础。</strong></p>
<p><strong>卷积是对函数的一种操作:它取两个函数并将它们组合起来生成一个新的函数。在本书中，卷积算子用星号表示:将卷积作用于函数f和g的结果是f★g。我们说f和g是卷积的，f★g是f和g的卷积。</strong></p>
<p><strong>卷积可以被应用到连续函数(函数f (x)定义为任何实际参数x)或离散序列(功能只对整数参数定义a[i] )。它也可以应用到函数定义在一维,二维,或高维域(即函数,一个,两个,甚至更多的参数)。我们将从离散的一维情况开始，然后继续讨论连续函数以及二维和三维函数。</strong></p>
<p><strong>为了方便定义，我们通常假设函数的域是无限的，尽管在实践中它们必须在某个地方停止，而且我们必须以一种特殊的方式处理端点。</strong></p>
<h3 id="Moving-Averages-移动平均线"><a href="#Moving-Averages-移动平均线" class="headerlink" title="Moving Averages 移动平均线"></a>Moving Averages 移动平均线</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132339.png" class="" title="image-20210925132339">

<p>使用移动平均线进行平滑。</p>
<p><strong>为了获得卷积的基本图像，考虑使用移动平均值平滑1D函数的例子(上图)。为了得到任意点上的平滑值，我们计算函数在每个方向上延伸距离r范围内的平均值。距离r，称为平滑操作的半径，是一个控制平滑程度的参数。</strong></p>
<p><strong>对于离散或连续函数，我们可以在数学上表述这个概念。如果我们平滑一个连续函数g(x)，平均意味着在一个区间内对g积分然后除以区间的长度:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132426.png" class="" title="image-20210925132426">

<p><strong>另一方面，如果我们平滑一个离散函数a[i]，平均意味着对一系列a求和，然后除以值的数量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132434.png" class="" title="image-20210925132434">

<p><strong>在每种情况下，选择标准化常数，这样如果我们平滑一个常数函数，结果将是相同的函数。</strong></p>
<p><strong>移动平均线的概念是卷积的本质;唯一的区别是在卷积中移动平均是加权平均。</strong></p>
<h3 id="Discrete-Convolution-离散卷积"><a href="#Discrete-Convolution-离散卷积" class="headerlink" title="Discrete Convolution 离散卷积"></a>Discrete Convolution 离散卷积</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132710.png" class="" title="image-20210925132710">

<p>计算序列a与支持五个样本宽的滤波器b的离散卷积中的一个值。b中的每个样本是a中附近样本的平均值，由b的值加权。</p>
<p><strong>我们将从卷积最具体的情况开始:将一个离散序列a[i]与另一个离散序列b[i]进行卷积。结果是一个离散序列(a★b)[i]。这个过程就像用移动平均线平滑a，但是这个我们使用第二个序列b来给每个样本赋予权重(上图)，而不是对距离r内的所有样本进行相同的权重。值b[i−j]给出位置j的样本权重，位置j与指标i有i−j的距离，我们在这里计算卷积。(a b)的定义如下，用公式表示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132722.png" class="" title="image-20210925132722">

<p><strong>通过省略j的界限，我们表明这个和对所有整数都有效(即从−∞到+∞)。上图说明了如何计算一个输出样本，使用</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925133023.png" class="" title="image-20210925133023">

<p><strong>在图形中，这两个函数中的一个通常具有有限支持(如上图中的示例所示)，这意味着它仅在参数值的有限区间内是非零的。如果我们假设b有有限支持，当|k| &gt; r时，存在一个半径r使b[k] = 0，在这种情况下，我们可以写出上面的和为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925133147.png" class="" title="image-20210925133147">

<p><strong>我们可以用代码来表示这个定义</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925133157.png" class="" title="image-20210925133157">

<h4 id="Convolution-Filters-卷积过滤器"><a href="#Convolution-Filters-卷积过滤器" class="headerlink" title="Convolution Filters 卷积过滤器"></a>Convolution Filters 卷积过滤器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925133931.png" class="" title="image-20210925133931">

<p>一个离散盒型过滤器。</p>
<p><strong>卷积很重要，因为我们可以用它来进行滤波。回顾我们的第一个滤波例子，移动平均，我们现在可以将平滑操作重新解释为与特定序列的卷积。当我们在有限的指标范围内计算平均值时，这就相当于对范围内的所有点进行相同的加权，并对其余的点进行零加权。这种过滤器，在非零的区间内有一个常量值，被称为框过滤器(因为如果你画它的图形，它看起来像一个矩形——见上图)。对于半径为r的箱形滤波器，其权重为1/(2r + 1):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925134527.png" class="" title="image-20210925134527">

<p><strong>如果你将这个过滤器代入方程，你会发现它降低到方程中的移动平均线。</strong></p>
<p><strong>在这个例子中，卷积滤波器通常被设计成和为1。这样，它们就不会影响信号的整体水平。</strong></p>
<p><strong>例子</strong></p>
<p><strong>举一个滤波的简单例子，让信号为阶跃函数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925134538.png" class="" title="image-20210925134538">

<p><strong>滤波器是以0为中心的五点盒滤波器，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925134608.png" class="" title="image-20210925134608">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925134746.png" class="" title="image-20210925134746">

<p>盒形函数与阶跃函数的离散卷积。</p>
<p><strong>a和b的卷积结果是什么?在一个特定的索引i上，如上图所示，结果是在i−2到i + 2范围内的阶跃函数的平均值。如果i &lt;−2，我们将所有零取平均，结果为零。如果i≥2，我们取所有1的平均值，结果是1。中间有i + 3个1，结果是这个值(i+3)/5 ．输出是一个从0到1的线性斜坡c超过五个样品:1/5[…， 0, 0, 1, 2, 3, 4, 5, 5，…].</strong></p>
<h4 id="Properties-of-Convolution-卷积的属性"><a href="#Properties-of-Convolution-卷积的属性" class="headerlink" title="Properties of Convolution 卷积的属性"></a>Properties of Convolution 卷积的属性</h4><p><strong>到目前为止我们写它的方式，卷积看起来像是一个非对称运算:a是我们要平滑的序列，b提供权值。但是卷积的一个很好的特性是它实际上没有任何区别:滤波器和信号是可以互换的。要理解这一点，只需重新考虑卷积式中的和，其中指标从滤波器b的原点开始计数，而不是从a的原点出发，即用i−k代替j</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925135859.png" class="" title="image-20210925135859">

<p><strong>这与卷积式完全相同，但a作为滤波器，b作为信号。对于任意序列a和b， (a★b) = (b★a)我们说卷积是一个交换运算。</strong></p>
<p><strong>更一般地说，卷积是一种“类似乘法”的操作。与数字或函数的乘法或加法一样，参数的顺序和括号的位置都不会影响结果。此外，卷积与加法的关系与乘法的关系是一样的。确切地说，卷积是交换的和结合的，它是加法的分配律。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925140020.png" class="" title="image-20210925140020">

<p><strong>这些性质是很自然的如果我们把卷积想成乘法，它们是很容易掌握的因为它们可以帮助我们在实际计算之前通过简化卷积来节省工作。例如，假设我们要取一个序列a用三个滤波器b进行卷积b1，b2, b3也就是说，我们想要((a★b1)★b2)★b3．如果序列很长，而滤波器很短(也就是说，它们的半径很小)，首先将三个滤波器卷积在一起会快得多计算(b1★b2★b3)，最后将结果与信号卷积，计算a★(b1★b2★b3)，我们从结合律得知，它会给出相同的结果。</strong><br><strong>一个非常简单的过滤器对于离散卷积:它是半径为零的离散滤波器，或者序列d[i] =…， 0,0,1,0,0，…（下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925140422.png" class="" title="image-20210925140422">

<p>离散滤波器。</p>
<p><strong>如果我们将d与信号a卷积，则和式中只有一项非零:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925140600.png" class="" title="image-20210925140600">

<p><strong>很明显，a与d的卷积会得到a。序列d称为离散脉冲。它有时在表示滤波器时很有用:例如，用滤波器b平滑信号a，然后从原始信号中减去滤波器b的过程可以表示为与滤波器d−b的单个卷积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925140750.png" class="" title="image-20210925140750">

<h3 id="Convolution-as-a-Sum-of-Shifted-Filters-移位和卷积滤波器"><a href="#Convolution-as-a-Sum-of-Shifted-Filters-移位和卷积滤波器" class="headerlink" title="Convolution as a Sum of Shifted Filters 移位和卷积滤波器"></a>Convolution as a Sum of Shifted Filters 移位和卷积滤波器</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141121.png" class="" title="image-20210925141121">

<p>移动序列b得到b→j。</p>
<p><strong>还有另一种完全相同的方法来解释卷积式。每次看一个a★b的样本就会得到我们已经看到的加权平均解释。但是如果我们省略[i]，我们可以把和看成是把整个序列加在一起。需要一个标记来实现这个工作:如果b是一个序列，那么向右移动j位的相同序列称为b→j(上图):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141159.png" class="" title="image-20210925141159">

<p><strong>然后，我们可以将卷积式写成关于整个序列(a★b)的陈述，而不是逐个元素:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141208.png" class="" title="image-20210925141208">

<p><strong>从这个角度看，卷积是b的移位副本的和，由a的项加权(下图)。因为交换性，我们可以选a或者b作为过滤器;如果我们选择b，那么我们将为输入中的每个样本添加一个过滤器副本。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141220.png" class="" title="image-20210925141220">

<p>离散卷积作为滤波器的移位副本的和。</p>
<h3 id="Convolution-with-Continuous-Functions-连续函数卷积"><a href="#Convolution-with-Continuous-Functions-连续函数卷积" class="headerlink" title="Convolution with Continuous Functions 连续函数卷积"></a>Convolution with Continuous Functions 连续函数卷积</h3><p><strong>虽然离散序列确实是我们在计算机程序中使用的，但这些采样序列应该表示连续函数，通常我们需要对连续函数进行数学推理，以便找出该怎么做。因此，定义连续函数之间以及连续函数和离散函数之间的卷积是有用的。</strong></p>
<p><strong>两个连续函数的卷积是卷积式的明显推广，用一个积分代替和:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141657.png" class="" title="image-20210925141657">

<p><strong>一种解释这个定义的方法是f和g的卷积，在参数x处取值，是两个函数乘积曲线下的面积在我们平移g使g(0)与f(t)对齐之后。就像在离散情况下一样，卷积是一个移动平均值，滤波器提供平均值的权重(见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141758.png" class="" title="image-20210925141758">

<p>连续卷积。</p>
<p><strong>像离散卷积一样，连续函数的卷积是交换的和结合的，它是对加法的分配。同样，对于离散情况，连续卷积可以看作是滤波器副本的和，而不是加权平均的计算。除了，在本例中，有无限多个过滤器g的副本:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141903.png" class="" title="image-20210925141903">

<p><strong>例子</strong></p>
<p><strong>设f为盒型函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141949.png" class="" title="image-20210925141949">

<p><strong>那么f★f是多少？定义如下</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141959.png" class="" title="image-20210925141959">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142102.png" class="" title="image-20210925142102">

<p>将两个盒子函数旋转就产生了一个tent函数。</p>
<p><strong>上图显示了这个积分的两种情况。当x≤−1或x≥1时，两个盒型可能没有重叠;在这种情况下，结果是零。当−1 &lt; x &lt; 1时，重叠取决于两个盒子之间的距离，这是|x|;结果为1−|x|。所以</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142353.png" class="" title="image-20210925142353">

<p><strong>这个函数被称为tent函数，是另一个常见的过滤器(参见9.3.1节)。</strong></p>
<h4 id="The-Dirac-Delta-Function-狄拉克函数"><a href="#The-Dirac-Delta-Function-狄拉克函数" class="headerlink" title="The Dirac Delta Function 狄拉克函数"></a>The Dirac Delta Function 狄拉克函数</h4><p><strong>在离散卷积中，我们看到离散脉冲d作为一个单位函数:d★a = a。在连续的情况下，还有一个单位函数，叫做狄拉克脉冲或狄拉克函数，记作δ(x)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142714.png" class="" title="image-20210925142714">

<p>狄拉克函数 δ(x)。</p>
<p><strong>直观地说，delta函数是一个非常窄、非常高的尖峰，它的宽度很小，但面积仍然等于1(上图)。函数的关键定义性质是，将它乘以一个函数会选择出在0处的值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142831.png" class="" title="image-20210925142831">

<p><strong>函数在0处没有定义明确的值(你可以把它的值看作是+∞)，但是对于所有x≠0，它的值是δ(x) = 0。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142843.png" class="" title="image-20210925142843">

<p>将函数与δ(x)进行卷积将返回相同函数的副本。</p>
<p><strong>从选择单个值的特性可以得出，脉冲函数是连续卷积的恒等式(上图)，因为将δ与任意函数f进行卷积会产生结果</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143044.png" class="" title="image-20210925143044">

<p><strong>所以</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143101.png" class="" title="image-20210925143101">

<h3 id="Discrete-Continuous-Convolution-离散连续卷积"><a href="#Discrete-Continuous-Convolution-离散连续卷积" class="headerlink" title="Discrete-Continuous Convolution 离散连续卷积"></a>Discrete-Continuous Convolution 离散连续卷积</h3><p><strong>有两种方法可以连接离散的和连续的世界。一种是三乘法:将连续函数转换为离散函数，方法是写下函数在所有整型参数处的值，而忽略其余的。给定一个连续函数f(x)，我们可以对其进行采样，将其转换为一个离散序列a[i]:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143517.png" class="" title="image-20210925143517">

<p><strong>反过来，从离散函数，或者说序列，到连续函数，叫做重构。这是用另一种形式的卷积来完成的，离散-连续形式。在这种情况下，我们用连续滤波器f(x)对一个离散序列a[i]进行滤波:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143526.png" class="" title="image-20210925143526">

<p><strong>重构函数a f在x处的值是i在x附近值的样本a[i]的加权和(下图)。权值来自滤波器f在以一个单位为间隔的一组点上计算。例如，如果x = 5.3, f的半径为2，则f的值为1.3、0.3、−0.7和−1.7。注意，对于离散-连续卷积，我们通常先写序列，然后写滤波器，这样和就大于整数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143631.png" class="" title="image-20210925143631">

<p>离散连续卷积。</p>
<p><strong>就像离散卷积一样，如果我们知道滤波器的半径r，我们就可以对求和设定界限，消除所有x和i之间的差值至少为r的点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143817.png" class="" title="image-20210925143817">

<p><strong>注意，如果一个点恰好落在距离x的r处(即如果x−r是一个整数)，它将被排除在求和之外。这与离散情况相反，在离散情况中，我们包含了i - r点。</strong></p>
<p><strong>在代码中表示为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143831.png" class="" title="image-20210925143831">

<p><strong>与其他形式的卷积一样，离散-连续卷积可以看作是对滤波器的移位副本进行求和(下图):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143842.png" class="" title="image-20210925143842">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144018.png" class="" title="image-20210925144018">

<p>重构（离散连续卷积）作为位移滤波器的和。</p>
<p><strong>离散-连续卷积与样条密切相关。对于均匀样条(例如均匀B样条)，样条的参数化曲线恰好是样条的基函数与控制点序列的卷积(参见15.6.2节)。</strong></p>
<h3 id="Convolution-in-More-Than-One-Dimension-多维卷积"><a href="#Convolution-in-More-Than-One-Dimension-多维卷积" class="headerlink" title="Convolution in More Than One Dimension 多维卷积"></a>Convolution in More Than One Dimension 多维卷积</h3><p><strong>到目前为止,我们已经说过的所有关于采样和重建一直是一维:已经有一个变量x或一个单一的顺序索引。许多重要的应用程序图形采样和重建的,特别应用于二维函数,2d图像。幸运的是，将采样算法和理论从一维推广到二维、三维及以上，在概念上非常简单。</strong></p>
<p><strong>从离散卷积的定义开始，我们可以将其推广到二维，将其和变为双和:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144347.png" class="" title="image-20210925144347">

<p><strong>如果b是半径为r的有限支持滤波器(即有(2r + 1)²值)，然后我们可以把这个和写成有界的(下图):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144443.png" class="" title="image-20210925144443">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144454.png" class="" title="image-20210925144454">

<p>用于在点(i, j)与半径为1的滤波器b进行离散卷积的9个输入样本的权值。</p>
<p><strong>并在代码中表达:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144529.png" class="" title="image-20210925144529">

<p><strong>这个定义可以用与在1D情况下相同的方式来解释:每个输出样本是输入区域的加权平均值，使用2D过滤器作为“掩码”来确定每个样本在平均值中的权重。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144615.png" class="" title="image-20210925144615">

<p>输入信号中由(x, y)处的连续卷积产生的一个无限小的区域权重。</p>
<p><strong>继续推广，我们也可以在2D中写出连续-连续(上图)和离散-连续(下图)卷积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144735.png" class="" title="image-20210925144735">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144745.png" class="" title="image-20210925144745">

<p>对于半径为2的重构滤波器，参与在(x, y)点离散-连续卷积的16个输入样本的权值。</p>
<p><strong>在每种情况下，特定点的结果是该点附近输入的加权平均值。对于连续-连续的情况，它是一个以该点为中心的区域的加权积分，而在离散-连续的情况下，它是所有落在该点附近的样本的加权平均值。</strong></p>
<p><strong>一旦我们从1D发展到2D，就应该很清楚如何进一步推广到3D甚至更高维度。</strong></p>
<h2 id="Convolution-Filters-卷积滤波器"><a href="#Convolution-Filters-卷积滤波器" class="headerlink" title="Convolution Filters 卷积滤波器"></a>Convolution Filters 卷积滤波器</h2><p><strong>现在我们已经了解了卷积的原理，让我们来研究一些在图形中常用的特殊滤波器。</strong></p>
<p>**下面的每个过滤器都有一个自然半径，当采样间隔为一个单位时，这是用于采样或重建的默认大小。在本节中，过滤器被定义为这个自然大小:例如，盒子过滤器的自然半径为1/2，而立方过滤器的自然半径是2。我们还安排每个过滤器积分为1:  **</p>
<p><strong></strong></p>
<p><strong>在不改变信号平均值的情况下进行采样和重构所需要的。</strong></p>
<p><strong>正如我们将在9.4.3节中看到的，一些应用程序需要不同大小的过滤器，可以通过缩放基本过滤器获得。对于滤波器f(x)，我们可以定义一个缩放s的版本:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123550.png" class="" title="image-20210926123550">

<p><strong>过滤器水平拉伸s倍，然后垂直压缩s倍 1/s 所以它的面积不变。一个过滤器的自然半径为r，并且在缩放s中使用，它的支持半径为sr。</strong></p>
<h3 id="A-Gallery-of-Convolution-Filters-卷积滤波器库"><a href="#A-Gallery-of-Convolution-Filters-卷积滤波器库" class="headerlink" title="A Gallery of Convolution Filters 卷积滤波器库"></a>A Gallery of Convolution Filters 卷积滤波器库</h3><h4 id="盒型滤波器"><a href="#盒型滤波器" class="headerlink" title="盒型滤波器"></a>盒型滤波器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123749.png" class="" title="image-20210926123749">

<p>离散和连续盒型滤波器。</p>
<p><strong>盒状滤波器是一个积分为1的分段常数函数。作为一个离散滤波器，它可以写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123758.png" class="" title="image-20210926123758">

<p><strong>注意，为了对称，我们包含了两个端点。作为一个连续过滤器，我们写</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123808.png" class="" title="image-20210926123808">

<p><strong>在本例中，我们排除了一个端点，这使得半径为0.5的方框可用作重构过滤器。因为盒状过滤器是不连续的这些边界情况很重要，所以对于这个特殊的过滤器我们需要注意它们。就写成fbox 对于自然半径r = 1/2。</strong></p>
<h4 id="帐篷过滤器"><a href="#帐篷过滤器" class="headerlink" title="帐篷过滤器"></a>帐篷过滤器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123930.png" class="" title="image-20210926123930">

<p>帐篷过滤器和两个缩放版本。</p>
<p><strong>帐篷，或线性滤波器，是一个连续的、分段的线性函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123939.png" class="" title="image-20210926123939">

<p><strong>它的自然半径是1。过滤器,这样,至少C⁰(也就是说,没有突然跳跃值,有盒),我们不再需要单独的离散和连续的定义过滤器:离散滤波器只是连续过滤采样的整数。</strong></p>
<h4 id="高斯滤波器"><a href="#高斯滤波器" class="headerlink" title="高斯滤波器"></a>高斯滤波器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124057.png" class="" title="image-20210926124057">

<p>高斯滤波器</p>
<p><strong>高斯函数，也称为正态分布，在理论上和实践中都是一个重要的滤波器。随着这一章的继续，我们会看到它的更多特殊属性:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124107.png" class="" title="image-20210926124107">

<p><strong>参数σ称为标准差。高斯滤波器是很好的采样滤波器，因为它非常光滑;我们将在本章后面更精确地说明这一点。</strong></p>
<p><strong>高斯滤波器没有任何特定的自然半径;它是σ范围内有用的采样滤波器。高斯也没有一个有限的支持半径，尽管因为指数衰减，它的值迅速变得小到可以忽略。当需要的时候，我们可以通过在半径r之外将函数的尾部设置为零来修剪函数的尾部，从而得到修剪过的高斯函数。这意味着滤波器的宽度和自然半径可以取决于应用程序,和削减高斯缩放的年代是一样的一个们修剪与标准差σ和高斯半径老在实践中处理这个问题的最好方法是让σ和r的属性设置过滤器,过滤时固定指定,然后规模筛选时就像任何其他应用（一般起点是σ = 1和r = 3。）。</strong></p>
<h4 id="B样条三次滤波器"><a href="#B样条三次滤波器" class="headerlink" title="B样条三次滤波器"></a>B样条三次滤波器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124320.png" class="" title="image-20210926124320">

<p>B样条滤波器</p>
<p><strong>许多滤波器被定义为分段多项式，四段(自然半径为2)的立方滤波器常被用作重构滤波器。这样一个过滤器被称为B样条滤波器，因为它的起源是样条曲线的混合函数(见第15章):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124329.png" class="" title="image-20210926124329">

<p><strong>在分段三次函数中，B样条是特殊的，因为它有连续的一阶导数和二阶导数，也就是C²。定义这个过滤器的更简洁的方法是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124339.png" class="" title="image-20210926124339">

<p><strong>证明上面的长形式是等价的是一个很好的卷积练习。</strong></p>
<h4 id="Catmull-Rom-立方滤波器"><a href="#Catmull-Rom-立方滤波器" class="headerlink" title="Catmull-Rom 立方滤波器"></a>Catmull-Rom 立方滤波器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124519.png" class="" title="image-20210926124519">

<p>Catmull-Rom 立方滤波器</p>
<p><strong>另一个以样条命名的分段三次滤波器Catmull-Rom滤波器，在x =−2，−1,1和2处的值为零，这意味着它将作为重构滤波器用于插值样本(章节9.3.2):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124528.png" class="" title="image-20210926124528">

<h4 id="Mitchell-Netravali立方滤波器"><a href="#Mitchell-Netravali立方滤波器" class="headerlink" title="Mitchell-Netravali立方滤波器"></a>Mitchell-Netravali立方滤波器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124616.png" class="" title="image-20210926124616">

<p>Mitchell-Netravali立方滤波器</p>
<p><strong>对于重采样图像的所有重要应用，Mitchell和Netravali (Mitchell &amp; Netravali, 1988)研究了立方滤波器，并推荐在前两个滤波器之间的一个中间位置作为最佳的全面选择。它只是前面两个过滤器的加权组合:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124633.png" class="" title="image-20210926124633">

<h3 id="滤波器的属性"><a href="#滤波器的属性" class="headerlink" title="滤波器的属性"></a>滤波器的属性</h3><p><strong>过滤器有一些传统的术语，我们用它们来描述过滤器，并相互比较。</strong></p>
<p><strong>滤波器的脉冲响应只是函数的另一个名称:它是滤波器对只包含脉冲的信号的响应(回想一下，与脉冲卷积就会返回滤波器)。</strong></p>
<p><strong>连续滤波器是插值，当它被用来从一个离散序列重建一个连续函数时，得到的函数恰好是采样点上的样本值，也就是说，它“连接点”，而不是仅仅产生一个函数靠近点。插值ters就是那些f(0) = 1和f(i) = 0的过滤器f，对于所有非零整数i(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125132.png" class="" title="image-20210926125132">

<p>一个插值滤波器重构采样点恰好是因为它在所有非零整数处的值都是零。</p>
<p><strong>负值的过滤器有铃声或超调:它会产生额外的振荡值左右急剧变化被过滤函数的值。</strong></p>
<p><strong>例如，Catmull-Rom滤波器两个方向上都有负，如果你过滤一个阶跃函数重建一个尖锐的不连续。有了它，它会夸大步骤a位，导致函数值下冲0和上冲1(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125623.png" class="" title="image-20210926125623">

<p>带有负瓣的滤波器在滤波或滤波时总是产生一些超调</p>
<p><strong>连续滤波器是无纹波的，当作为重构滤波器使用时，它将一个常数序列重构为常数函数(下图)。这相当于要求过滤器在任何整数间隔网格上的和为1:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125752.png" class="" title="image-20210926125752">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125714.png" class="" title="image-20210926125714">

<p>半径为1的帐篷滤波器为无波纹重建滤波器;而标准差为1/2的高斯滤波器则不然。</p>
<p><strong>第9.3.1节中的所有滤波器在其自然半径处都是无纹波的，除了高斯分布，但当它们在非整数范围内使用时，它们都不一定是无纹波的。如果需要消除离散-连续卷积中的纹波，很容易做到:将每个计算的样本除以计算它所用的权值之和:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125821.png" class="" title="image-20210926125821">

<p><strong>这个表达式仍然可以解释为a和过滤器ˉf之间的卷积(参见练习6)。</strong></p>
<p><strong>连续滤波器具有一定的连续性，即处处可见的最高阶导数。一个过滤器，像盒过滤器，其值有突然的跳跃，根本不是连续的。一个连续但有尖角(一阶导数不连续)的滤波器，例如帐篷滤波器，连续阶为零，我们说它是C⁰。具有连续导数(无尖角)的滤波器，如前一节中的分段立方滤波器，为C¹;如果它的二阶导数也是连续的，就像b样条滤波器一样，它就是C²．由于重构函数继承了滤波器的连续性，因此重构滤波器的连续性顺序对重构滤波器尤为重要。</strong></p>
<h4 id="Separable-Filters-可分离的过滤器"><a href="#Separable-Filters-可分离的过滤器" class="headerlink" title="Separable Filters 可分离的过滤器"></a>Separable Filters 可分离的过滤器</h4><p><strong>到目前为止，我们只讨论了用于1D卷积的滤波器，但对于图像和其他多维信号，我们也需要滤波器。一般来说，任何2D函数都可以是一个2D过滤器，偶尔这样定义它们是有用的。但是，在大多数情况下，我们可以从我们已经看到的一维滤波器构建合适的二维(或高维)滤波器。</strong></p>
<p><strong>最有用的方法是使用可分离过滤器。可分离滤波器f2(x, y)在特定的x和y处是f1 (1D滤波器)在x和y处求值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130448.png" class="" title="image-20210926130448">

<p><strong>类似地，对于离散滤波器，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130456.png" class="" title="image-20210926130456">

<p><strong>通过f的任何水平或垂直切片f2是f1的缩放副本．f2 是f1积分的平方，特别是如果f1 是标准化的，那么f2也是．</strong></p>
<p><strong>例子(可分离的帐篷过滤器)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130711.png" class="" title="image-20210926130711">

<p>可分离的2D帐篷滤波器。</p>
<p><strong>如果我们为f1选择帐篷函数，得到的分段双线性函数(上图)为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130848.png" class="" title="image-20210926130848">

<p><strong>沿着坐标轴的轮廓是帐篷函数，但是沿着对角线的轮廓是二次曲线(例如，沿着直线x = y的正方向)象限，我们看到二次函数(1 - x)²)．</strong></p>
<p><strong>例子(2D高斯滤波器)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130949.png" class="" title="image-20210926130949">

<p>二维高斯滤波器，既可分离又径向对称。</p>
<p><strong>如果我们选择高斯函数作为f1，得到的2D函数(上图)为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131008.png" class="" title="image-20210926131008">

<p><strong>注意，如果我们将一维高斯函数绕原点旋转，生成一个圆对称的函数，我们得到的函数是相同的(直到一个比例因子)函数。同时具有圆对称和可分离的性质是高斯函数所独有的。沿着坐标轴的轮廓是高斯曲线，沿着任意方向的轮廓也是高斯曲线中心。</strong></p>
<p><strong>与其他二维滤波器相比，可分离滤波器的关键优势在于实现效率。我们代入a2的定义 引入离散卷积的定义:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131120.png" class="" title="image-20210926131120">

<p><strong>请注意,b1[i-i′]不依赖于j′并且可以从内部和中求出:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131129.png" class="" title="image-20210926131129">

<p><strong>让我们将内部和缩写为S[i′]:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131314.png" class="" title="image-20210926131314">

<p><strong>用这种形式的方程，我们可以先计算和存储S[i′]对i′的每个值，然后使用这些存储值计算外部总和。乍一看，这似乎没什么了不起的，因为我们仍然要做与(2r + 1)²成比例的功来计算所有的内部和。然而，如果我们想要计算多个点[i, j]的值，情况就大不相同了。</strong></p>
<p><strong>假设我们需要计算a★2 在[2,2]和[3,2]，和b1 半径是2。检上式，我们可以看到我们将需要S[0]，…，S[4]来计算[2,2]处的结果，我们需要S[1]，…，S[5]来计算[3,2]处的结果。因此，在可分离公式中，我们可以计算所有的6个S值并共享S[1]，…S[4] (下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131716.png" class="" title="image-20210926131716">

<p>使用分离计算两个输出点对包含25个样本的2D数组(上图)进行处理，对列进行一次过滤，然后使用包含5个样本的单独1D数组(下图)。</p>
<p><strong>这种节省对于大型过滤器有很大的意义。一般情况下，用半径为r的滤波器过滤图像需要每像素计算(2r + 1)²个，而用相同大小的可分离滤波器过滤图像需要2(2r + 1)个产品(以牺牲一些中间存储为代价)。从O(r²)到O(r)的渐近复杂度的变化使得使用更大的滤波器成为可能。</strong></p>
<p><strong>该算法是:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131930.png" class="" title="image-20210926131930">

<p><strong>为简单起见，该函数通过在输出图像的所有四边修剪r像素来避免所有边界问题。在实践中，有各种方法来处理边界;9.4.3看到部分。</strong></p>
<h2 id="Signal-Processing-for-Images-图像信号处理"><a href="#Signal-Processing-for-Images-图像信号处理" class="headerlink" title="Signal Processing for Images 图像信号处理"></a>Signal Processing for Images 图像信号处理</h2><p><strong>到目前为止，我们已经讨论了抽象的采样、滤波和重构，主要以一维信号为例。但正如我们在本章开始时所观察到的，信号处理在图形中的最重要和最常见的应用是采样图像。让我们仔细看看这些如何应用于图像。</strong></p>
<h3 id="Image-Filtering-Using-Discrete-Filters-使用离散滤波器进行图像滤波"><a href="#Image-Filtering-Using-Discrete-Filters-使用离散滤波器进行图像滤波" class="headerlink" title="Image Filtering Using Discrete Filters 使用离散滤波器进行图像滤波"></a>Image Filtering Using Discrete Filters 使用离散滤波器进行图像滤波</h3><p><strong>也许卷积最简单的应用是使用离散卷积处理图像。图像处理程序的一些最广泛使用的特性是简单的卷积滤波器。图像模糊可以通过与许多常见的低通滤波器进行卷积来实现，范围从方框到高斯(下图)。高斯滤波器创建一个非常光滑的模糊，通常用于这个目的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132154.png" class="" title="image-20210926132154">

<p>用三个不同的过滤器中的每一个卷积模糊图像。</p>
<p><strong>与模糊相反的是锐化，其中一种方法是使用“非锐化遮罩”程序:从模糊图像中减去一个α分数原创。为了避免改变整体亮度，我们进行了调整</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132307.png" class="" title="image-20210926132307">

<p><strong>fg,σ为宽度σ的高斯滤波器。使用离散脉冲d和卷积的分配律，我们可以将整个过程写成一个单独的过滤器，它取决于模糊的宽度和锐化的程度(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132316.png" class="" title="image-20210926132316">

<p>使用卷积过滤器锐化图像。</p>
<p><strong>结合两个离散过滤器的另一个例子是投影。这是常见的采取模糊，移动的副本的对象的轮廓，以创建一个软下降阴影(下图)。我们可以将移位操作表示为与偏心脉冲的卷积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132447.png" class="" title="image-20210926132447">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132437.png" class="" title="image-20210926132437">

<p>一个软下降阴影</p>
<p><strong>移动，然后模糊，是通过与两个过滤器卷积来实现的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132455.png" class="" title="image-20210926132455">

<p><strong>在这里，我们使用结合性将两个操作组合成一个带有三个参数的过滤器。</strong></p>
<h3 id="Antialiasing-in-Image-Sampling-图像采样中的抗锯齿"><a href="#Antialiasing-in-Image-Sampling-图像采样中的抗锯齿" class="headerlink" title="Antialiasing in Image Sampling 图像采样中的抗锯齿"></a>Antialiasing in Image Sampling 图像采样中的抗锯齿</h3><p><strong>在图像合成中，我们经常有这样的任务:生成图像的采样表示，我们有一个连续的数学公式(或者至少是一个程序，我们可以用来计算任意点的颜色，而不仅仅是在整数像素位置)。射线追踪是一个常见的例子;关于光线追踪和反走样的具体方法在第四章。在信号处理语言中，我们有一个连续的二维信号(图像)，我们需要在一个规则的二维晶格上采样。如果我们继续在没有任何特殊措施的情况下对图像进行采样，结果将显示出各种走样现象(下图)。在图像的尖锐边缘，我们看到阶梯状的物体，称为“锯齿”。“在有重复图案的区域，我们看到被称为摩尔图案的宽条纹。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132718.png" class="" title="image-20210926132718">

<p>图像中的两种伪影:周期性纹理中的莫尔图案(左)和直线上的“锯齿”(右)。</p>
<p><strong>这里的问题是图像包含了太多的小尺度特征;我们需要在采样前通过过滤使其平滑。回顾连续卷积的定义，我们需要在像素位置周围的区域上平均图像，而不仅仅是在单个点上取值。具体的方法将在第4章中讨论。一个简单的滤镜，像一个盒子，将改善锐利边缘的外观，但它仍然产生一些摩尔图案(下图)。高斯滤波器，这是非常平滑的，是更有效的摩尔模式，在整体上更模糊的代价。这两个例子说明了清晰度和走样之间的权衡，这是选择抗锯齿滤波器的基础。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132907.png" class="" title="image-20210926132907">

<p>比较三种不同的采样滤波器用于消除锯齿的一个困难的测试图像，其中包含圆圈，间距越来越近，因为他们变得更大。</p>
<h3 id="Reconstruction-and-Resampling-重构和重采样"><a href="#Reconstruction-and-Resampling-重构和重采样" class="headerlink" title="Reconstruction and Resampling 重构和重采样"></a>Reconstruction and Resampling 重构和重采样</h3><p><strong>最常见的图像操作之一，其中仔细的过滤是至关重要的重采样——改变采样率，或改变图像大小。</strong></p>
<p><strong>假设我们用一个3000 × 2000像素的数码相机拍摄了一张图像，我们想在一个只有1280 × 1024像素的显示器上显示它。为了使它适合，同时保持3:2的宽高比，我们需要重新采样到1278 × 852像素。我们该怎么做呢?</strong></p>
<p><strong>解决这个问题的一种方法是将这个过程想象成减少像素:大小比率介于2和3之间，所以我们必须在保留的像素之间减少1或2个像素。可以用这种方法缩小图像，但结果的质量很低。然而，像素下降非常快，在交互操作期间预览调整大小的图像是一个合理的选择。</strong></p>
<p><strong>考虑调整图像大小的方法是作为一个重采样操作:我们想要一组图像的样本在一个特定的网格上，由新的图像的维数，我们通过对输入样本重建的连续函数进行采样得到它们(下图)。从这个角度看，它只是一系列标准图像处理操作:首先我们从输入样本重构一个连续函数，然后我们对这个函数进行采样就像对其他连续图像进行采样一样。为了避免走样，需要在每个阶段使用适当的过滤器。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926133423.png" class="" title="image-20210926133423">

<p>对图像的重新采样由两个逻辑步骤组成，并在代码中合并为单个操作。首先，我们使用重构滤波器从输入样本定义一个平滑的连续函数。然后，我们在一个新的网格上对该函数进行采样以获得输出样本。</p>
<p><strong>一个小例子如下图:如果原始图像12×9像素和新一是8×6像素,有2/3尽可能多的输出像素作为输入像素在每一个维度,所以他们的间距在图像是3/2的间距原始样本。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926133510.png" class="" title="image-20210926133510">

<p>在对一个12 × 9的图像进行重采样以生成一个8 × 6的图像时，输入和输出网格的样本位置。</p>
<p><strong>为了得到每个输出样本的值，我们需要以某种方式计算样本之间的图像值。像素丢弃算法为我们提供了一种方法:取输入图像中最接近的样本的值，并将其作为输出值。这完全相当于用1像素宽(半径为1 / 2)的盒状滤波器重建图像，然后进行点采样。</strong></p>
<p><strong>当然，如果选择像素下降或其他非常简单的过滤的主要原因是性能，那么就不会将该方法作为一种特殊的方法来实现一般重建和重采样程序的情况。事实上，由于不连续性，很难使盒形过滤器在一般框架下工作。但是，对于高质量的重采样，重构/采样框架提供了宝贵的灵活性。</strong></p>
<p><strong>要计算出算法的细节，最简单的方法是降至1D并讨论重新采样序列。编写实现的最简单方法是使用9.2.5节中定义的重构函数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926133631.png" class="" title="image-20210926133631">

<p><strong>参数x0 根据旧序列的样本给出新序列的第一个样本的位置。也就是说，如果第一个输出样本落在输入序列中样本3和样本4之间，x0是3.5。</strong></p>
<p><strong>该程序通过将输入序列与连续滤波器进行卷积，然后对其进行点采样来重建连续图像。这并不是说这两个操作是顺序发生的——连续函数仅在原理上存在，其值仅在采样点处计算。但在数学上，这个函数计算a★f的一组点样本。</strong></p>
<p><strong>这个点采样似乎是错误的，因为我们刚刚说过信号应该用适当的平滑滤波器进行采样以避免混叠。我们应该将重构函数与采样滤波器g和点采样g★(f★a)卷积，但由于这和(g★f)★a相同，我们可以把采样滤波器和重构滤波器放在一起;我们只需要一个卷积运算(下图)。这种重构和采样滤波器的组合称为重采样滤波器。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926133835.png" class="" title="image-20210926133835">

<p>重采样包括对重建和采样进行滤波。由于顺序应用的两个卷积滤波器可以用一个滤波器代替，所以我们只需要一个重采样滤波器，它起到重构和采样的作用。</p>
<p><strong>当对图像进行重新采样时，我们通常用旧图像的单位指定源矩形，该单位指定我们想要保留在新图像中的部分。例如，使用第3章中的像素样本定位约定，我们用于重新采样整个图像的矩形是(−0.5,nx ^old−0.5)×(−0.5,ny ^old−0.5)。给定源矩形(xl, xh)×(yl,yh)，新图像的样本间距</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926134049.png" class="" title="image-20210926134049">

<p><strong>低采样为(xl +Δx / 2, yl +Δy / 2)。</strong></p>
<p><strong>修改1D伪代码以使用此约定，并扩展调用为了使重构函数进入隐含的双循环，我们得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926134244.png" class="" title="image-20210926134244">

<p><strong>这个例程包含了重新采样图像的所有基础。最后一个问题有待解决的是在图像的边缘做什么，这里的简单版本将访问超出输入序列的边界。我们可能会做以下几件事:</strong></p>
<p>​    <strong>只要在序列的末尾停止循环即可。这相当于填充所有边都是零的图像。</strong></p>
<p>​    <strong>将所有数组访问剪辑到序列的末尾——也就是说，当我们想访问a[−1]时返回a[0]。这相当于通过扩展最后一行或一列来填充图像的边缘。</strong></p>
<p>​    <strong>当我们接近边缘时修改过滤器，使其不会超出序列的边界。</strong></p>
<p><strong>第一种方法导致当我们重新采样整个图像时，边缘变暗，这不是真正令人满意的。第二种选择很容易实现;第三种可能是表现最好的。修改靠近图像边缘的滤波器最简单的方法是对其进行重正化:将滤波器除以位于图像内的滤波器部分的总和。这样，滤波器的加起来总是等于1除以实际的图像样本，所以它保持了图像的强度。为了提高性能，最好将边缘(需要重正化)的滤波半径内的像素带与中心(包含更多像素，不需要重正化)分开处理。</strong></p>
<p><strong>重采样滤波器的选择是很重要的。有两个单独的问题:过滤器的形状和大小(半径)。由于滤波器既可作为重构滤波器又可作为采样滤波器，因此这两种角色的要求都会影响滤波器的选择。对于重建，我们希望滤镜足够平滑，以避免在放大图像时出现混叠现象，并且滤镜应该是无波纹的。采样时，过滤器应足够大，以避免欠采样，并足够光滑，以避免摩尔现象。下图说明了这两种不同的需求。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926134521.png" class="" title="image-20210926134521">

<p>使用不同大小的滤波器对图像进行上采样(放大)或下采样(缩小)的效果。</p>
<p><strong>一般情况下，我们会根据输入和输出的相对分辨率选择一个滤波器形状，并将其缩放。较低的两项决议确定过滤器的大小:当输出比输入粗采样(将采样,或缩小图像),适当的采样所需的平滑大于所需的平滑重建,所以我们根据输出样本大小过滤器间距(半径3在上图)。另一方面,当输出更精细采样(upsampling或放大图片)然后重建所需的平滑主导(重建函数已经足够光滑的样本比它开始以更高的速度),所以过滤器的大小是由输入样本间隔(半径1在上图)。</strong></p>
<p><strong>选择过滤器本身就是在速度和质量之间的权衡。常见的选择是盒式过滤器(速度是最重要的)，帐篷式过滤器(质量中等)，或分段立方过滤器(质量优秀)。在分段三次情况下，可以通过在f之间插值来调整平滑程度fB和fC ；Mitchell-Netravali滤波器是一个不错的选择。</strong></p>
<p><strong>与图像滤波一样，可分离过滤器可以提供显著的速度提升。其基本思想是首先对所有行进行重新采样，生成一个宽度不变但高度不变的图像，然后对该图像的列进行重新采样以生成最终结果(下图)。修改前面给出的伪代码以利用这种优化是相当简单的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926134806.png" class="" title="image-20210926134806">

<p>使用可分离方法对图像进行重采样。</p>
<h2 id="Sampling-Theory-采样理论"><a href="#Sampling-Theory-采样理论" class="headerlink" title="Sampling Theory 采样理论"></a>Sampling Theory 采样理论</h2><p><strong>如果您只对实现感兴趣，可以在这里停止阅读;前面几节中的算法和建议将让您实现执行采样和重构并获得出色结果的程序。然而，采样有一个更深层次的数学理论，其历史可以追溯到采样表示在电信中的第一次使用。采样理论回答了许多严格基于尺度论证的推理难以回答的问题。</strong></p>
<p><strong>但最重要的是，采样理论为采样和重建工作提供了有价值的见解。它为学习它的学生提供了一套额外的智力工具，用于推理如何用最有效的代码实现最佳结果。</strong></p>
<h3 id="The-Fourier-Transform-傅里叶变换"><a href="#The-Fourier-Transform-傅里叶变换" class="headerlink" title="The Fourier Transform 傅里叶变换"></a>The Fourier Transform 傅里叶变换</h3><p><strong>傅里叶变换和卷积是构成采样理论的主要数学概念。你可以在很多关于分析的数学书中读到傅里叶变换，也可以在关于信号处理的书中读到。</strong></p>
<p><strong>傅里叶变换背后的基本思想是通过将所有频率的正弦波(正弦)相加来表示任何函数。通过为不同的频率使用适当的权重，我们可以安排正弦信号相加为我们想要的任何(合理的)函数。</strong></p>
<p><strong>例如，下图中的方波可以用一个序列表示 正弦波:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133340.png" class="" title="image-20210927133340">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133226.png" class="" title="image-20210927133226">

<p>用有限正弦和逼近方波。。</p>
<p><strong>这个傅里叶级数从频率为1.0的正弦波(sin 2πx)开始——与方波相同——剩下的项加上越来越小的修正以减少波纹，在极限情况下，精确地再现方波。注意，和中的所有项的频率都是方波频率的整数倍。这是因为其他频率产生的结果与方波的周期不同。</strong></p>
<p><strong>一个令人惊讶的事实是，一个信号并不一定是周期性的，以这种方式表示为正弦信号的和:一个非周期信号只是需要更多的正弦信号。我们不是对一个离散的正弦序列求和，而是对一个连续的正弦序列积分。例如，一个盒子函数可以写成余弦波族的积分:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133457.png" class="" title="image-20210927133457">

<p><strong>上式中的积分是无穷多个余弦相加，将频率u的余弦加权(sin πu)/πu。当我们包含越来越高的频率时，结果收敛到方框函数(见下图)。当函数f用这种方式表示时，这个权值，这个频率为u的函数，叫做f的傅里叶变换，记作fˆ。函数fˆ告诉我们如何通过对一组正弦函数积分来构造f:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133645.png" class="" title="image-20210927133645">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133540.png" class="" title="image-20210927133540">

<p>用余弦函数的积分逼近一个方框函数，每个余弦函数有四个截止点。</p>
<p><strong>上式被称为傅里叶反变换(IFT)，因为它从f的傅里叶变换开始，以f结束。</strong></p>
<p><strong>注意，在上式中，复指数e^2πiux 代替了之前方程中的cos。此外，fˆ是一个复值函数。为了控制正弦信号的相位和频率，需要使用复数机制;这对于表示任何在零上不对称的函数是必要的。fˆ的大小被称为傅里叶频谱，对于我们的目的来说，这已经足够了——我们不需要担心相位或者直接使用任何复数。</strong></p>
<p><strong>事实证明，从f计算fˆ和计算f非常相似从fˆ:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133920.png" class="" title="image-20210927133920">

<p><strong>上式称为(正向)傅里叶变换(FT)。指数中的符号是傅里叶正变换和反变换之间的唯一区别，这实际上只是一个技术细节。出于我们的目的，我们可以把FT和IFT看作是相同的操作。</strong></p>
<p><strong>有时f - fˆ符号不方便，然后我们用F {f}表示f的傅里叶变换用F^−1{fˆ}表示fˆ的傅里叶反变换一个函数和它的傅里叶变换有许多有用的联系。我们将在本章后面用到(大部分很容易验证):</strong></p>
<h4 id="函数及其傅里叶变换具有相同的平方积分"><a href="#函数及其傅里叶变换具有相同的平方积分" class="headerlink" title="函数及其傅里叶变换具有相同的平方积分:"></a>函数及其傅里叶变换具有相同的平方积分:</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134153.png" class="" title="image-20210927134153">

<p><strong>物理上的解释是两者具有相同的能量(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134322.png" class="" title="image-20210927134322">

<p>傅里叶变换保持了信号的平方积分。</p>
<p><strong>特别地，将一个函数放大a，其傅里叶变换也放大a，即F{af} = aF {f}。</strong></p>
<h4 id="沿x轴拉伸函数时，其傅里叶变换也会沿u轴压缩相同的因子-下图"><a href="#沿x轴拉伸函数时，其傅里叶变换也会沿u轴压缩相同的因子-下图" class="headerlink" title="沿x轴拉伸函数时，其傅里叶变换也会沿u轴压缩相同的因子(下图):"></a>沿x轴拉伸函数时，其傅里叶变换也会沿u轴压缩相同的因子(下图):</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134521.png" class="" title="image-20210927134521">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134510.png" class="" title="image-20210927134510">

<p>在空间域中沿x轴缩放信号会导致在频域沿u轴的反缩放。</p>
<p><strong>(为了保持能量不变，需要b的重正化)</strong></p>
<p><strong>这意味着如果我们感兴趣的是一个家庭的功能不同的宽度和高度(说所有框功能集中在零),然后我们只需要知道一个正则函数的傅里叶变换(说盒子函数与宽度和高度等于1),我们可以很容易地知道的傅里叶变换的缩放和扩张版本的函数。例如，我们可以推广得到宽b高a的方框的傅里叶变换:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134530.png" class="" title="image-20210927134530">

<h4 id="f的平均值等于fˆ-0-："><a href="#f的平均值等于fˆ-0-：" class="headerlink" title="f的平均值等于fˆ(0)："></a>f的平均值等于fˆ(0)：</h4><p><strong>这是有意义的，因为f(0)ˆ应该是信号的零频率分量(如果我们考虑的是电压，则是直流分量)。</strong></p>
<h4 id="如果f是实数-对我们来说总是实数-，则fˆ是偶函数，即f-u-ˆ-f-−u-："><a href="#如果f是实数-对我们来说总是实数-，则fˆ是偶函数，即f-u-ˆ-f-−u-：" class="headerlink" title="如果f是实数(对我们来说总是实数)，则fˆ是偶函数，即f(u)ˆ=f(−u)："></a>如果f是实数(对我们来说总是实数)，则fˆ是偶函数，即f(u)ˆ=f(−u)：</h4><p><strong>同样地，如果f是偶函数，则fˆ为实数(这不是通常在我们的定义域中是这样的，但是记住我们只关心fˆ的大小。</strong></p>
<h3 id="Convolution-and-the-Fourier-Transform-卷积与傅里叶变换"><a href="#Convolution-and-the-Fourier-Transform-卷积与傅里叶变换" class="headerlink" title="Convolution and the Fourier Transform 卷积与傅里叶变换"></a>Convolution and the Fourier Transform 卷积与傅里叶变换</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135041.png" class="" title="image-20210927135041">

<p>一个交换图直观地显示了卷积和乘法之间的关系。如果我们在空间中乘以f和g，然后转换到频率，我们最终会得到和我们把f和g转换到频率然后卷积它们一样的地方。同样地，如果我们在空间中卷积f和g然后转换成频率，我们最终会得到和我们把f和g转换成频率，然后相乘一样的地方。</p>
<p><strong>傅里叶变换最后一个值得特别提及的性质是它与卷积的关系(上图)。简单地说,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135133.png" class="" title="image-20210927135133">

<p><strong>两个函数的卷积的傅里叶变换是傅里叶变换的乘积。根据我们现在熟悉的对称性，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135143.png" class="" title="image-20210927135143">

<p><strong>两个傅里叶变换的卷积就是两个函数乘积的傅里叶变换。从定义中推导出这些事实是相当简单的。</strong></p>
<p><strong>这种关系是傅里叶变换在研究采样和重构效果时有用的主要原因。我们已经看到了采样、滤波和重构是如何用卷积来表示的;现在傅里叶变换给了我们一个新的域——频域——这些运算只是乘积。</strong></p>
<h3 id="A-Gallery-of-Fourier-Transforms-傅里叶变换库"><a href="#A-Gallery-of-Fourier-Transforms-傅里叶变换库" class="headerlink" title="A Gallery of Fourier Transforms 傅里叶变换库"></a>A Gallery of Fourier Transforms 傅里叶变换库</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135350.png" class="" title="image-20210927135350">

<p>盒型、帐篷、B样条和高斯滤波器的傅里叶变换。</p>
<p><strong>现在我们有了傅里叶变换的一些事实，让我们看一些单独函数的例子。特别地，我们将看看9.3.1节中的一些过滤器，它们的傅里叶变换如上图所示。我们已经看到了盒型函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135453.png" class="" title="image-20210927135453">

<p><strong>函数sinx /x很重要，有它自己的名字，sincx。</strong></p>
<p><strong>帐篷函数是盒子与自身的卷积，所以它的傅里叶变换就是盒子函数傅里叶变换的平方</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135516.png" class="" title="image-20210927135516">

<p><strong>我们可以继续这个过程，得到B样条滤波器的傅里叶变换(见练习3):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135527.png" class="" title="image-20210927135527">

<p><strong>高斯函数有一个特别好的傅里叶变换</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135535.png" class="" title="image-20210927135535">

<p><strong>这是另一个高斯。标准差为1.0的高斯变成了标准差为1/2π的高斯。</strong></p>
<h3 id="Dirac-Impulses-in-Sampling-Theory-采样理论中的Dirac脉冲"><a href="#Dirac-Impulses-in-Sampling-Theory-采样理论中的Dirac脉冲" class="headerlink" title="Dirac Impulses in Sampling Theory 采样理论中的Dirac脉冲"></a>Dirac Impulses in Sampling Theory 采样理论中的Dirac脉冲</h3><p><strong>脉冲在抽样理论中有用的原因是我们可以用它们来讨论连续函数和傅里叶变换中的样本。我们表示一个样本，它有一个位置和一个值，用一个平移到那个位置并按那个值缩放的脉冲表示。一个位于a位置的值为b的样本用bδ(x−a)表示。这样我们可以将函数f(x)在a处的采样操作表示为f乘以δ(x−a)，结果是f(A)δ(x−a)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135843.png" class="" title="image-20210927135843">

<p>脉冲列车。一个脉冲序列的傅里叶变换是另一个脉冲序列。在空间上改变脉冲序列的周期会引起频率周期的反向变化。</p>
<p><strong>因此，在一系列等间距点上对函数进行采样可以表示为将函数乘以一系列等间距脉冲的和，称为脉冲序列(上图)。一个周期为T的脉冲序列，也就是说脉冲间隔为T</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135851.png" class="" title="image-20210927135851">

<p><strong>s1的傅里叶变换和s1一样:所有整数频率的脉冲序列。你们可以看到为什么这是正确的通过思考当我们把脉冲序列乘以正弦信号并积分时会发生什么。我们最后把所有整数处的正弦值加起来。对于非整数频率，这个和正好抵消为零，对于整数频率，它发散为+∞。</strong></p>
<p><strong>由于傅里叶变换的膨胀性质，我们可以猜测一个周期为T的脉冲序列的傅里叶变换(就像s1的膨胀)为周期为1/T的脉冲序列。在空间域中采样越精细，脉冲在频域中的距离就越远。</strong></p>
<h3 id="Sampling-and-Aliasing-采样和走样"><a href="#Sampling-and-Aliasing-采样和走样" class="headerlink" title="Sampling and Aliasing 采样和走样"></a>Sampling and Aliasing 采样和走样</h3><p><strong>现在我们已经建立了数学机制，我们需要从频域的观点来理解采样和重构过程。引入傅里叶变换的关键优点是，它使卷积滤波对信号的影响更加清晰，并且更精确地解释了采样和重构时为什么需要滤波。</strong></p>
<p><strong>我们从原始的连续信号开始这个过程。一般来说，它的傅里叶变换可以包含任何频率的分量，尽管对于大多数类型的信号(尤其是图像)，我们预计其内容会随着频率的增加而减少。图像也倾向于在零频率有一个很大的分量——记住零频率分量，或DC，是整个图像的积分，因为图像都是正的值，这往往是一个很大的数字。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140327.png" class="" title="image-20210927140327">

<p>采样率对采样信号频谱的影响。较高的采样率会将光谱的副本分开，从而减少走样造成的问题。</p>
<p><strong>让我们看看如果不做任何特殊的滤波采样和重构，傅里叶变换会发生什么(上图)。当我们对信号进行采样时，我们将运算模型化为与脉冲序列的乘法运算;采样信号为fsT．由于乘法卷积的性质，采样后的FT</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140436.png" class="" title="image-20210927140436">

<p> <strong>回想一下，δ是卷积的恒等式。这意味着</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140446.png" class="" title="image-20210927140446">

<p><strong>脉冲序列的卷积,使得一系列的等距的副本的光谱f。一个好的直观的解释这个看似奇怪的结果是,所有这些副本只是表达一个事实(正如我们在9.1.1看到)频率不同的整数倍数采样频率是无法区分一旦采样它们将产生完全相同的设置的样本。原始谱称为基谱，复制谱称为杂谱。</strong></p>
<p><strong>如果这些信号频谱的副本重叠，问题就开始了，如果信号包含任何超过样本频率一半的重要内容，就会发生重叠。当这种情况发生时，频谱相加，不同频率的信息不可逆地混合在一起。这是可能发生走样的第一个地方，如果它发生在这里，那是因为欠采样——对信号使用过低的采样频率。</strong></p>
<p><strong>假设我们用最近邻技术重建信号。这相当于与宽度为1的方框进行卷积。(用于实现这一目的的离散-连续卷积与与表示样本的脉冲序列的连续卷积相同。)卷积乘法性质是指重构信号的频谱将是采样信号的频谱与盒子的频谱的乘积。得到的重建傅里叶变换包含了基谱(尽管在较高的频率上有些衰减)，加上所有走样谱的衰减副本。因为方框有一个相当宽的傅里叶变换，这些衰减的伪谱是重要的，它们是第二种走样形式，由于不充分的重建滤波器。这些别名组件在图像中表现为具有最近邻重建特征的正方形图案。</strong></p>
<h4 id="Preventing-Aliasing-in-Sampling-防止采样中的走样"><a href="#Preventing-Aliasing-in-Sampling-防止采样中的走样" class="headerlink" title="Preventing Aliasing in Sampling 防止采样中的走样"></a>Preventing Aliasing in Sampling 防止采样中的走样</h4><p><strong>为了实现高质量的采样和重构，我们需要选择合适的采样和重构滤波器。从频域的角度来看，采样时低通滤波的目的是限制信号的频率范围，使走样谱不与基谱重叠。下图显示了采样率对采样信号傅里叶变换的影响。较高的采样率使伪谱分离得更远，最终留下的重叠部分都无关紧要。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140830.png" class="" title="image-20210927140830">

<p>采样率对采样信号频谱的影响。较高的采样率会将光谱的副本分开，从而减少重叠造成的问题。</p>
<p><strong>关键的标准是频谱的宽度必须小于拷贝之间的距离，也就是说，信号中的最高频率必须小于样本频率的一半。这被称为奈奎斯特准则，最高允许频率被称为奈奎斯特频率或奈奎斯特极限。奈奎斯特-香农采样定理表明，一个频率不超过奈奎斯特极限的信号(或者，换句话说，一个带宽限制在奈奎斯特频率的信号)，原则上可以从样本中精确地重建。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140917.png" class="" title="image-20210927140917">

<p>应用低通(平滑)滤波器缩小信号的频谱。</p>
<p><strong>对于一个特定的信号有足够高的采样率，我们不需要使用采样滤波器。但是，如果我们遇到的是一个频率范围很广的信号(比如一幅边缘清晰的图像)，我们必须在采样之前使用一个采样滤波器来限制信号的频带。上图显示了三种低通(平滑)滤波器在频域的效果，下图显示了采样时使用这些相同滤波器的效果。即使频谱在没有滤波的情况下重叠，用低通滤波器对信号进行卷积也可以将频谱缩小到足以消除重叠，并产生滤波后信号的良好采样表示。当然，我们失去了高频信号，但总比让它们被信号干扰变成藏物强。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140930.png" class="" title="image-20210927140930">

<p>上图中的低通滤波器如何在采样期间防止走样。低通滤波使频谱变窄，使复制的重叠更少，杂化频谱的高频对基谱的干扰更小。</p>
<h4 id="Preventing-Aliasing-in-Reconstruction-防止重建中的混叠"><a href="#Preventing-Aliasing-in-Reconstruction-防止重建中的混叠" class="headerlink" title="Preventing Aliasing in Reconstruction 防止重建中的混叠"></a>Preventing Aliasing in Reconstruction 防止重建中的混叠</h4><p><strong>从频域的角度来看，重构滤波器的工作是在保留基谱的同时去除杂谱。在之前的图中，我们可以看到，最粗糙的重构滤波器，即方框，确实会衰减走样光谱。最重要的是，它完全阻断了所有杂化光谱的直流脉冲。这是所有合理重构滤波器的一个特点:它们在采样频率的所有倍数的频率空间中都有零。这等价于空间域中的无波纹性质。</strong></p>
<p><strong>因此，一个好的重构滤波器需要是一个好的低通滤波器，同时还需要完全阻断采样频率的所有倍数。</strong></p>
<p><strong>采用与盒形滤波器不同的重构滤波器的目的是为了更彻底地消除杂频，减少高频伪影泄漏到重构信号中，同时尽可能地减少对基谱的干扰。下图显示了在重建过程中使用不同滤波器的效果。正如我们所看到的，盒子过滤器是相当“漏”的，即使取样率足够高，也会导致大量的人为因素。帐篷滤波器由于线性插值，对高频的衰减更大，产生更温和的伪影，而B样条滤波器非常平滑，有效地控制了杂散谱。它也平滑了一些基谱，这是平滑和混叠之间的权衡，我们之前看到过。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927141358.png" class="" title="image-20210927141358">

<p>不同重构滤波器在频域的影响。好的重建滤波器能有效地衰减杂频，同时保留基谱。</p>
<h4 id="Preventing-Aliasing-in-Resampling-防止重采样中的走样"><a href="#Preventing-Aliasing-in-Resampling-防止重采样中的走样" class="headerlink" title="Preventing Aliasing in Resampling 防止重采样中的走样"></a>Preventing Aliasing in Resampling 防止重采样中的走样</h4><p><strong>当重构和采样操作在重采样中结合时，同样的原理也适用，只是一个过滤器同时做重构和采样工作。下图说明了重采样滤波器必须去除走样光谱，使频谱足够窄，以新的采样率进行采样。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927141628.png" class="" title="image-20210927141628">

<p>在频域观察重采样。重采样滤波器既重建信号(去除杂频)，又限制它的带宽(减少它的宽度)以新的速率采样。</p>
<h3 id="Ideal-Filters-vs-Useful-Filters-理想过滤器VS有用过滤器"><a href="#Ideal-Filters-vs-Useful-Filters-理想过滤器VS有用过滤器" class="headerlink" title="Ideal Filters vs. Useful Filters 理想过滤器VS有用过滤器"></a>Ideal Filters vs. Useful Filters 理想过滤器VS有用过滤器</h3><p><strong>根据频域分析得出的逻辑结论，在频域中恰好是一个盒子的滤波器对于采样和重构都是理想的。这样的滤波器可以在两个阶段防止走样，而不会减少低于奈奎斯特频率的频率。</strong></p>
<p><strong>回想一下傅里叶反变换和正变换本质上是相同的，所以傅里叶变换为方框的空间域滤波器是函数sin πx/πx = sinc πx。</strong></p>
<p><strong>然而，由于sinc滤波器不切实际，而且尽管它根据频域准则是最优的，但在许多应用中它并不能产生最佳结果，因此在实际应用中，无论是采样还是重构，一般都不使用sinc滤波器。</strong></p>
<p><strong>对于采样，sinc滤波器的无限延伸，以及它相对较慢的下降速度随距离中心的距离，是一个不利因素。此外，对于某些类型的采样，负叶是有问题的。高斯滤波器是一个很好的采样滤波器，即使在输入信号中高频模式必须去除的困难情况下，因为它的傅里叶变换下降指数基本上，不要让化名泄露出去。对于不太困难的情况，一个帐篷过滤器通常就足够了。</strong></p>
<p><strong>对于重构，sinc函数的大小再次产生问题，但更重要的是，许多波纹在重构信号中产生“振铃”伪影。</strong></p>
<h1 id="10-Surface-Shading-表面着色"><a href="#10-Surface-Shading-表面着色" class="headerlink" title="10 Surface Shading 表面着色"></a>10 Surface Shading 表面着色</h1><h2 id="Diffuse-Shading-漫反射着色"><a href="#Diffuse-Shading-漫反射着色" class="headerlink" title="Diffuse Shading 漫反射着色"></a>Diffuse Shading 漫反射着色</h2><p><strong>世界上许多物体的表面外观被宽泛地描述为“哑光”，这表明该物体根本没有光泽。例如，纸张、未加工的木材和干燥、未抛光的石头。在很大程度上，这样的物体不会随着视点的变化而发生颜色变化。例如，如果你盯着一张纸上的一个特定点并移动，同时保持你的目光盯着这个点，这个点上的颜色将保持相对恒定。这样的哑光对象可以被认为具有朗伯对象的行为。本节讨论如何实现这些对象的着色。关键是，本章所有公式都应在世界坐标中求值，而不是在透视变换后的扭曲坐标中求值。否则，法线之间的角度会改变，着色将是不准确的。</strong></p>
<h3 id="Lambertian-Shading-Model-朗伯着色模型"><a href="#Lambertian-Shading-Model-朗伯着色模型" class="headerlink" title="Lambertian Shading Model 朗伯着色模型"></a>Lambertian Shading Model 朗伯着色模型</h3><p><strong>朗伯物体遵循朗伯余弦定律，即表面的颜色c与表面法线与光源方向夹角的余弦成正比(Gouraud, 1971):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142632.png" class="" title="image-20210927142632">

<p><strong>或者向量形式，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142643.png" class="" title="image-20210927142643">

<p><strong>其中n和l如下图所示。因此，表面上的颜色将根据表面法线和光线方向之间的夹角的余弦变化。注意，通常假设向量l不依赖于对象的位置。这个假设相当于假设光相对于物体的大小是“遥远的”。这种“远距离”的光通常被称为定向光，因为它的位置仅由一个方向来确定。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142730.png" class="" title="image-20210927142730">

<p>朗伯定律的几何。n和l都是单位向量。</p>
<p><strong>通过改变光源的强度或表面的反射率，表面可以变得更亮或更暗。漫反射系数c<em>r</em> 为被表面反射的光的比例。这个分数对于不同的颜色成分是不同的。例如，如果一个表面反射的红色入射光比蓝色入射光的比例更高，那么它就是红色的。如果我们假设表面颜色与从表面反射的光成正比，那么漫反射系数cr——RGB颜色也必须包括在内:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142844.png" class="" title="image-20210927142844">

<p><strong>上式右手边为RGB颜色，所有RGB分量都在[0,1]范围内。我们想要添加光强度的效果，同时保持RGB分量在[0,1]范围内。这建议添加RGB强度项cl它本身在范围[0,1]中有分量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142852.png" class="" title="image-20210927142852">

<p><strong>这是一种非常方便的形式，但它可以产生c的RGB分量在范围[0,1]之外，因为点积可以是负的。如下图所示，当表面指向光源时，点积为负。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143030.png" class="" title="image-20210927143030">

<p>当一个表面指向远离光，它应该收不到光。这种情况可以通过检验l与n的点积是否为负来验证。</p>
<p><strong>可以在上式中加入“max”函数来检验这种情况:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143134.png" class="" title="image-20210927143134">

<p><strong>另一种处理“负面”光线的方法是使用绝对值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143142.png" class="" title="image-20210927143142">

<p><strong>虽然上式在物理上似乎不可信，但它实际上对应于上上式，即两个方向相反的光。由于这个原因，它通常被称为双面照明(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143232.png" class="" title="image-20210927143232">

<p>双面照明公式，相当于假设两个相反的光源相同的颜色。</p>
<h3 id="Ambient-Shading-环境着色"><a href="#Ambient-Shading-环境着色" class="headerlink" title="Ambient Shading 环境着色"></a>Ambient Shading 环境着色</h3><p><strong>漫反射着色的一个问题是，任何法线面远离光线的点都是黑色的。在现实生活中，光是被反射的，有些光是从各个方向入射的。此外，经常有天窗提供“环境”照明。解决这个问题的一种方法是使用多个光源。一个常见的技巧是总是在眼睛处放一个昏暗的光源，这样所有可见的点都会收到一些光。另一种方法是使用的双面照明。一种更常见的方法是添加环境光(Gouraud, 1971)。这只是添加到公式中的一个常量颜色项:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143558.png" class="" title="image-20210927143558">

<p><strong>直观地说，你可以想到环境色ca 作为场景中所有表面的平均颜色。如果您想确保计算的RGB颜色保持在[0,1]³范围内,那么ca + cl ≤(1,1,1)。否则，你的代码应该“夹紧”RGB值高于1的值为1。</strong></p>
<h3 id="Vertex-Based-Diffuse-Shading-基于顶点的漫反射着色"><a href="#Vertex-Based-Diffuse-Shading-基于顶点的漫反射着色" class="headerlink" title="Vertex-Based Diffuse Shading 基于顶点的漫反射着色"></a>Vertex-Based Diffuse Shading 基于顶点的漫反射着色</h3><p><strong>如果我们将漫反射着色方程应用于由三角形组成的物体，它通常会有一个面外观。三角形通常是光滑表面的近似值。为了避免面形的外观，我们可以将曲面法向量放置在三角形的顶点上(Phong, 1975)，并使用顶点上的法向量在每个顶点上应用公式(见下图)。这将给每个三角形顶点一个颜色，并且这个颜色可以使用8.1.2节中描述的重心插值。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143827.png" class="" title="image-20210927143827">

<p>一个圆(左)近似于一个八边形(右)。顶点法线记录原始曲线的表面法线。</p>
<p><strong>在三角形顶点上着色的一个问题是我们需要从某处得到法线。许多模型将与正常供应。如果你绘制自己的平滑模型，你可以在创建三角形时创建法线。如果你有一个多边形模型，顶点上没有法线，你想要平滑地着色它，你可以通过各种启发式方法计算法线。最简单的方法是对共享每个顶点的三角形的法线取平均值，并在顶点处使用这个平均值。这个平均法线不会自动是单位长度，所以你应该在使用它做阴影之前将它转换成单位向量。</strong></p>
<h2 id="Phong-Shading-Phong-着色"><a href="#Phong-Shading-Phong-着色" class="headerlink" title="Phong Shading Phong 着色"></a>Phong Shading Phong 着色</h2><p><strong>有些表面本质上就像哑光表面，但它们有亮点。这种表面的例子包括抛光的瓷砖地板、有光泽的油漆和白板。高光随着视点的移动在表面上移动。这意味着我们必须在方程中加入一个朝向眼睛的单位向量e。如果你仔细观察高光部分，你会发现它们其实是光的反射;有时这些反射是模糊的。这些高光的颜色是光的颜色，表面的颜色似乎没有什么影响。这是因为反射发生在物体表面，而穿透物体表面并捕捉到物体颜色的光是漫反射的。</strong></p>
<h3 id="Phong-Lighting-Model-Phong照明模型"><a href="#Phong-Lighting-Model-Phong照明模型" class="headerlink" title="Phong Lighting Model Phong照明模型"></a>Phong Lighting Model Phong照明模型</h3><p><strong>我们想在正确的地方添加一个与光源相同颜色的模糊“光点”。点的中心应该画在e到眼睛的方向与反射的自然方向r的“线”上，如下图所示。这里“对齐”在数学上等同于“σ为零”。“我们希望高光有一些非零区域，这样眼睛就能在σ很小的地方看到一些高光。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202344.png" class="" title="image-20210927202344">

<p>Phong照明模型的几何图形。如果σ很小，眼睛应该看到一个亮点。</p>
<p><strong>给定r，我们想要一个启发式函数，当e = r时是亮的，当e远离r时逐渐下降夹角:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202508.png" class="" title="image-20210927202508">

<p><strong>使用这个方程有两个问题。第一个是点积可以是负的。这可以通过一个“if”语句来计算解决，该语句在点积为负时将颜色设置为零。更严重的问题是，这个等式产生的亮点比现实生活中看到的要广泛得多。最大值是在正确的地方，它是正确的颜色，但它就是太大了。我们可以在不减少其最大颜色的情况下缩小它:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202518.png" class="" title="image-20210927202518">

<p><strong>这里p被称为Phong指数;它是一个正实数(Phong, 1975)。改变Phong指数在高亮显示上的效果可以在下图中看到。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202608.png" class="" title="image-20210927202608">

<p>Phong指数对突出特征的影响。这将使用上式来突出显示。还有一个漫反射组件，给对象一个闪亮的非金属外观。图片由Nate Robins提供。</p>
<p><strong>为了实现上式，我们首先需要计算单位向量r。给定单位向量l和n, r是关于n的向量l，如下图所示这个向量可以被计算为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202801.png" class="" title="image-20210927202801">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202752.png" class="" title="image-20210927202752">

<p>计算向量r的几何图形。</p>
<p><strong>用点积来计算cos θ。</strong></p>
<p><strong>另一种基于上上式的启发式模型消除了检查作为指数基数的数字是否为负值的需要(Warn, 1983)。我们不计算r，而是计算l和e中间的单位向量h(下图):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202831.png" class="" title="image-20210927202831">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202940.png" class="" title="image-20210927202940">

<p>单位向量h在l和e之间。</p>
<p><strong>高亮出现在h接近n时，即。，当cos ω = h·n接近1时。这就提出了一个规则:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202839.png" class="" title="image-20210927202839">

<p><strong>这里的指数p将具有类似于Phong照明模型方程中的指数的控制行为，但h和n之间的角度是e和r之间的角度的一半大小，所以细节将略有不同。使用n和h之间的余弦的优点是，对于平面上的眼睛和光线，余弦总是正的。缺点是需要平方根和除法来计算h。</strong></p>
<p><strong>在实践中，我们希望大多数材料除了高光外还有漫反射的外观。我们可以结合得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203119.png" class="" title="image-20210927203119">

<p><strong>如果我们想让用户调暗高光，我们可以添加一个控制项cp：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203129.png" class="" title="image-20210927203129">

<p><strong>cp是RGB颜色，它允许我们改变高光颜色。这对cp = cr，因为金属上的高光会呈现出金属的颜色。此外，使cp小于1的中性值，使颜色保持在1以下。例如，设置cp = 1−M，其中M是cr的最大分量将保持颜色低于1为一个光源和没有环境条件。</strong></p>
<h3 id="Surface-Normal-Vector-Interpolation-曲面法向量插值"><a href="#Surface-Normal-Vector-Interpolation-曲面法向量插值" class="headerlink" title="Surface Normal Vector Interpolation 曲面法向量插值"></a>Surface Normal Vector Interpolation 曲面法向量插值</h3><p><strong>与具有相同几何形状的Lambertian曲面相比，带有高光的光滑表面易于快速改变颜色。因此，在法向量上的着色可以产生干扰的伪影。</strong></p>
<p><strong>这些问题可以通过在多边形上插值法向量，然后在每个像素上应用Phong着色来减少。这可以让你得到好的图像，而不使三角形的大小极小。回想第3章，当栅格化三角形时，我们计算重心坐标(α， β， γ)来插值顶点颜色c0,c1,c2：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203458.png" class="" title="image-20210927203458">

<p><strong>我们可以用同一个方程来插值曲面法线n0,n1和n2：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203509.png" class="" title="image-20210927203509">

<p><strong>对于每个像素处计算的n，可以计算公式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203129.png" class="" title="image-20210927203129">

<p><strong>注意，由上上式得到的n通常不是单位法线。如果在使用着色计算之前将其转换为单位向量，将获得更好的视觉效果。这种类型的法向插值通常被称为Phong法向插值(Phong, 1975)。</strong></p>
<h2 id="Artistic-Shading-艺术着色"><a href="#Artistic-Shading-艺术着色" class="headerlink" title="Artistic Shading 艺术着色"></a>Artistic Shading 艺术着色</h2><p><strong>Lambertian和Phong着色方法是基于启发式设计来模仿真实世界中物体的外观。艺术着色是为了模仿人类艺术家的绘画而设计的(Yessios, 1979;杜利和科恩，1990年;齐藤&amp;高桥，1990;l·威廉姆斯,1991)。这种底纹在许多应用中似乎有优势。例如，汽车制造商雇佣艺术家为车主手册绘制图表。这比使用更“现实”的照片要昂贵得多，所以当需要某些类型的交流时，艺术家的技术可能有一些内在的优势。在本节中，我们将展示如何制作巧妙的着色线图纸，让人想起人类绘制的图像。创建这样的图像通常被称为非真实感渲染，但我们将避免使用这个术语，因为许多非真实感技术用于提高效率，与任何艺术实践无关。</strong></p>
<h3 id="Line-Drawing-绘制线"><a href="#Line-Drawing-绘制线" class="headerlink" title="Line Drawing 绘制线"></a>Line Drawing 绘制线</h3><p><strong>我们在人类绘画中看到的最明显的东西是我们在现实生活中看不到的剪影。当我们有一组共享边的三角形时，当共享边的两个三角形中的一个面向观看者，而另一个面向远离观看者时，我们应该画一条边作为剪影。这个条件可以用两个法线n0 和n1来测试</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203931.png" class="" title="image-20210927203931">

<p><strong>这是一个从边缘到眼睛的向量。这可以是边上的任意一点也可以是三角形中的任意一个。另外,如果fi(p) = 0为两个三角形的隐式平面方程，检验可写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203941.png" class="" title="image-20210927203941">

<p><strong>我们还想绘制多边形模型的可见边缘。为了做到这一点，我们可以使用第12章中的任何一种隐面方法来绘制背景色，然后用黑色绘制每个三角形的轮廓。事实上，这也将捕捉到轮廓。不幸的是，如果多边形代表一个光滑的表面，我们真的不想画大部分的边。然而，我们可能想要画出所有的折痕，那里确实有一个角落的几何。我们可以使用启发式阈值来测试折痕:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203951.png" class="" title="image-20210927203951">

<p><strong>这与轮廓测试相结合将给出漂亮的线条图。</strong></p>
<h3 id="Cool-to-Warm-Shading-冷暖着色"><a href="#Cool-to-Warm-Shading-冷暖着色" class="headerlink" title="Cool-to-Warm Shading 冷暖着色"></a>Cool-to-Warm Shading 冷暖着色</h3><p><strong>当艺术家在画线条时，他们经常使用低强度的着色给表面一些曲线的印象，并给物体着色(Gooch, Gooch, Shirley， &amp; Cohen, 1998)。朝一个方向的表面用冷色着色，如蓝色，朝相反方向的表面用暖色着色，如橙色。通常这些颜色不是很饱和，也不是很暗。这样，黑色的轮廓就能很好地展现出来。总的来说，这给了一个卡通般的效果。这可以通过设置一个“温暖”光的方向l和使用余弦调制颜色，其中温暖常数kw 定义在[0,1]上:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927204323.png" class="" title="image-20210927204323">

<p><strong>颜色c是冷色cc 和暖色cw的线性混合：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927204332.png" class="" title="image-20210927204332">

<p><strong>cw 和cb 将产生看起来合理的结果。猜测的一个好起点是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927204341.png" class="" title="image-20210927204341">

<p><strong>下图显示了传统的Phong照明和这种艺术着色类型的比较。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927204353.png" class="" title="image-20210927204353">

<p>左:Phong照明图像。中:如果没有轮廓，从冷到暖的阴影是没有用的。右:冷到暖的阴影加上轮廓。图片由Amy Gooch提供。</p>
<h1 id="11-Texture-Mapping-纹理映射"><a href="#11-Texture-Mapping-纹理映射" class="headerlink" title="11 Texture Mapping 纹理映射"></a>11 Texture Mapping 纹理映射</h1><p><strong>当试图复制真实世界的外观时，人们很快就会意识到几乎没有任何表面是无特征的。木头随谷物生长;皮肤长出皱纹;布显示其编织结构;油漆显示出刷子或滚筒的痕迹。即使是光滑的塑料也有凹凸的部分，而光滑的金属则显示出加工过程的痕迹。曾经毫无特色的材料很快就会被标记、凹痕、污渍、划痕、指纹和污垢所覆盖。</strong></p>
<p><strong>在计算机图形学中，我们把所有这些现象都归到“空间变化的表面属性”的标题下——这些表面属性在不同的地方变化，但并不真正以有意义的方式改变表面的形状。允许这些影响,各种建模和渲染系统提供一些纹理映射方法:使用一个图像,称为纹理贴图,纹理图像,或只是一个纹理,存储细节,你想去在一个表面上,然后“映射”数学图像到表面上。</strong></p>
<p><strong>事实证明，一旦将图像映射到表面的机制存在，就会有许多不太明显的方法可以使用，而不仅仅是引入表面细节的基本目的。纹理可以用来制造阴影和反射，提供照明，甚至定义表面形状。在复杂的交互程序中，纹理被用来存储各种各样的数据，这些数据甚至与图片没有任何关系!</strong></p>
<p><strong>本章讨论了使用纹理来表示表面细节、阴影和反射。虽然基本思想很简单，但有几个实际问题使纹理的使用复杂化。首先，纹理很容易变形，设计将纹理映射到表面的功能是具有挑战性的。此外，纹理映射是一个重采样过程，就像缩放图像一样，正如我们在第9章中看到的，重采样很容易引入混叠现象。纹理映射和动画的结合使用很容易产生真正引人注目的混叠，纹理映射系统的许多复杂性都是由用于驯服这些伪影的抗锯齿措施造成的。</strong></p>
<h2 id="Looking-Up-Texture-Values-查找纹理值"><a href="#Looking-Up-Texture-Values-查找纹理值" class="headerlink" title="Looking Up Texture Values 查找纹理值"></a>Looking Up Texture Values 查找纹理值</h2><p><strong>首先，让我们考虑一个简单的纹理映射应用。我们有一个木地板的场景，我们希望地板的漫反射颜色由一个显示木地板纹理的图像来控制。无论我们使用光线追踪或光栅化,计算颜色的着色代码光线表面交点或片段生成的光栅化程序需要知道的颜色纹理着色点,为了使用它作为漫射颜色传感器的着色模型从第十章。</strong></p>
<p><strong>为了获得这种颜色，着色器执行纹理查找:它在纹理图像的坐标系统中找出对应于着色点的位置，并读取图像中该点的颜色，从而生成纹理样本。这种颜色随后被用于着色，由于纹理查找发生在每个看到地板的像素的纹理的不同位置，不同颜色的图案就会在图像中显示出来。代码可能是这样的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105402.png" class="" title="image-20210929105402">

<p><strong>在这段代码中，着色器询问表面在纹理中寻找的位置，而我们想要使用纹理着色的每个表面都需要能够回答这个问题。这就引出了纹理映射的第一个关键元素:我们需要一个从表面映射到纹理的函数，我们可以轻松地计算每个像素。这是纹理坐标函数(下图)，我们说它为表面上的每个点分配纹理坐标。数学上，它是从表面S到纹理域T的映射:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105550.png" class="" title="image-20210929105550">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105521.png" class="" title="image-20210929105521">

<p>就像观看投影π地图每一个点在物体表面,S,图像中的一个点,纹理坐标函数φ地图对象的表面上每一个点一个点的纹理映射,T .适当地定义这个函数φ是纹理映射的所有应用程序的基础。</p>
<p><strong>集合T，通常称为“纹理空间”，通常只是一个包含图像的矩形;常用单位平方(u, v)∈[0,1]² (在本书中，我们将使用名称u和v作为两个纹理坐标)。在很多方面，它类似于第七章讨论的视觉投影，本章称之为π，它将场景表面上的点映射到图像上的点;两者都是3d到2D的映射，并且都是渲染所需要的——一个是知道从哪里得到纹理值，一个是知道在图像中放置着色结果。但也有一些重要的区别:π几乎总是一个透视或正投影，而φ可以有多种形式;一个图像只有一个可视投影，而场景中的每个物体都可能有一个完全独立的纹理坐标函数。</strong></p>
<p><strong>当我们的目标是将纹理放到表面上时，φ是一个从表面到纹理的映射，这似乎令人惊讶，但这是我们需要的功能。</strong></p>
<p><strong>对于木地板的情况，如果地板恰好处于恒定的z轴并与x轴和y轴对齐，我们可以使用映射</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105836.png" class="" title="image-20210929105836">

<p><strong>对于一些适当选择的比例因子a和b，将纹理坐标(s, t)分配给点(x, y, z)floor，然后使用纹理像素或texel的值，最接近(u, v)的是(x, y)处的纹理值。我们用这种方法渲染下图中的图像。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105938.png" class="" title="image-20210929105938">

<p>木地板，使用纹理坐标函数直接使用点的x和y坐标进行纹理。</p>
<p><strong>这是非常有限的，尽管:如果房间建模在x和y轴的一个角度，或者如果我们想要木材纹理在椅子的弯曲靠背上呢?我们需要一些更好的方法来计算表面上的点的纹理坐标。</strong></p>
<p><strong>从最简单的纹理映射形式中产生的另一个问题是，从一个非常接近的角度绘制一个高对比度的纹理到一个低分辨率的图像。下图显示了一个更大的平面纹理，使用了相同的方法，但使用了高对比度的网格模式和朝向地平线的视图。你可以看到，当没有使用适当的过滤器时，它包含走样的伪影(前景中的台阶，远处的波浪形和闪光图案)，类似于图像重采样(第9章)中出现的伪影。虽然这需要一个极端的情况，使这些文物如此明显地在一个微小的静止图像印在一本书，在动画中，这些模式移动，非常分散，即使他们是非常微妙的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929110016.png" class="" title="image-20210929110016">

<p>一个大的水平面，纹理与上图相同，并显示严重的走样现象。</p>
<p><strong>现在我们已经看到了基本纹理映射中的两个主要问题:</strong></p>
<p>​    <strong>定义纹理坐标函数</strong></p>
<p>​    <strong>查找纹理值而不引入太多的走样。</strong></p>
<p><strong>这两个问题是所有类型的纹理映射应用的基础，将在第11.2节和11.3节中讨论。一旦你理解了它们和它们的一些解决方案，那么你就理解了纹理映射。剩下的只是如何将基本的纹理机制应用于各种不同的目的，这将在第11.4节中讨论。</strong></p>
<h2 id="Texture-Coordinate-Functions-纹理坐标函数"><a href="#Texture-Coordinate-Functions-纹理坐标函数" class="headerlink" title="Texture Coordinate Functions 纹理坐标函数"></a>Texture Coordinate Functions 纹理坐标函数</h2><p><strong>设计好纹理坐标函数φ是获得良好纹理映射效果的关键。你可以将其视为决定如何变形一个平面的矩形图像，使其符合你想要绘制的3D表面。或者，你将表面轻轻地压平，不让它起皱、撕裂或折叠，使它平躺在图像上。有时这很简单:也许3D表面已经是一个扁平的矩形!在其他情况下则非常棘手:3D形状可能非常复杂，比如角色身体的表面。</strong></p>
<p><strong>定义纹理坐标函数的问题在计算机图形学中并不新鲜。制图师在设计时也面临着同样的问题覆盖地球表面大片区域的地图:从曲面到平面的地图不可避免地会导致区域、角度和/或距离的扭曲，这很容易使地图变得非常容易误导人。几个世纪以来，人们提出了许多地图投影，它们都是为了平衡纹理映射所面临的相同的竞争问题——在覆盖大面积连续区域的同时尽量减少各种失真。</strong></p>
<p><strong>在某些应用程序中(我们将在本章后面看到)，使用特定映射有明确的理由。但在大多数情况下，设计纹理坐标地图是一项微妙的任务，需要平衡相互冲突的关注点，熟练的建模人员为此付出了相当大的努力。</strong></p>
<p><strong>你可以用任何你能想到的方式来定义φ。但有几个相互竞争的目标需要考虑:</strong></p>
<p>​    <strong>双射性。在大多数情况下，你会希望φ是双射的(参见2.1.1节)，这样表面上的每个点都会映射到纹理空间中的不同点。如果几个点映射到同一个纹理空间点，纹理中一个点的值会影响到表面上的几个点。在你想要纹理在表面上重复的情况下(想想墙纸或地毯的重复图案)，故意引入从表面点到纹理点的多对一映射是有意义的，但你不希望这意外发生。</strong></p>
<p>​    <strong>尺寸失真。纹理的比例在整个表面上应该是近似恒定的。也就是说，表面上任何距离相同的近距离点应该映射到纹理中距离相同的点。对于函数φ来说，φ导数的大小不应变化太大。</strong></p>
<p>​    <strong>形状畸变。纹理不应该被扭曲。也就是说，绘制在表面上的一个小圆应该映射到纹理空间中的一个合理的圆形形状，而不是一个被压扁或拉长的形状。就φ而言，φ的导数在不同的方向上不应相差太大规划设计。</strong> </p>
<p>​    <strong>连续性。不应该有太多的接缝:表面上相邻的点应该映射到纹理上相邻的点。也就是说，φ应该是连续的，或有尽可能少的不连续。在大多数情况下，一些不连续是不可避免的，我们想把它们放在不显眼的地方。</strong><br><strong>由参数方程定义的表面(章节2.5.8)带有纹理坐标函数的内置选择:简单地反转函数这定义了表面，并使用表面的两个参数作为纹理坐标。这些纹理坐标可能有也可能没有理想的属性，这取决于表面，但它们确实提供了映射。</strong></p>
<p><strong>但是对于隐式定义的表面，或者仅仅由三角形网格定义的表面，我们需要一些其他的方法来定义纹理坐标，而不依赖于现有的参数化。广义地说，定义纹理坐标的两种方法是从表面点的空间坐标几何上计算纹理坐标，或者，对于网格表面，在顶点上存储纹理坐标的值并在整个表面上插入它们。让我们逐个看看这些选项。</strong></p>
<h3 id="Geometrically-Determined-Coordinates-几何确定坐标"><a href="#Geometrically-Determined-Coordinates-几何确定坐标" class="headerlink" title="Geometrically Determined Coordinates 几何确定坐标"></a>Geometrically Determined Coordinates 几何确定坐标</h3><p><strong>几何决定的纹理坐标用于简单的形状或特殊的情况，作为一个快速的解决方案，或作为设计手工调整纹理坐标地图的起点。</strong></p>
<p><strong>我们将通过将下图中的测试图像映射到表面来说明各种纹理坐标函数。图像中的数字可以让您从渲染图像中读出近似的(u, v)坐标，网格可以让您看到映射的失真程度。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929110842.png" class="" title="image-20210929110842">

<h4 id="Planar-Projection-平行投影"><a href="#Planar-Projection-平行投影" class="headerlink" title="Planar Projection 平行投影"></a>Planar Projection 平行投影</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111052.png" class="" title="image-20210929111052">

<p>平行投影，如果投影方向大致沿着整体法线选择，那么物体或物体的部分几乎是平的。</p>
<p><strong>从3D到2D最简单的映射可能是平行投影——与用于正射影的映射相同(上图)。我们已经为查看(第7.1节)开发的机制可以直接用于定义纹理坐标:正如正投影查看归结为乘以一个矩阵并丢弃z组件，通过平面投影生成纹理坐标可以通过简单的矩阵乘法来完成:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111209.png" class="" title="image-20210929111209">

<p><strong>纹理矩阵Mt 表示一个仿射变换，星号表示我们不关心最后在第三个坐标中是什么。</strong></p>
<p><strong>这对于平面表面来说非常有效，没有太多的表面法线变化，并且可以通过取平均法线找到一个好的投影方向。对于任何闭合形状，平面投影都可以不是单射的:正面和背面的点将映射到纹理空间中的同一个点(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111305.png" class="" title="image-20210929111305">

<p>在一个封闭的物体上使用平行投影总是会导致一个非单射，一对多的映射，以及在投影方向与物体相切的点附近的极端失真。</p>
<p><strong>通过简单地将透视投影替换为正投影，我们得到了投影纹理坐标(下图):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111357.png" class="" title="image-20210929111357">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111408.png" class="" title="image-20210929111408">

<p>投影纹理变换，使用向某一点投射的类似视图的转换。</p>
<p><strong>现在是4×4矩阵P<em>t</em> 表示一个投影(不一定是仿射)变换——也就是说，最后一行可能不是[0,0,0,1]。</strong></p>
<p><strong>投影纹理坐标在阴影映射技术中非常重要，将在11.4.4节中讨论。</strong></p>
<h4 id="Spherical-Coordinates-球坐标"><a href="#Spherical-Coordinates-球坐标" class="headerlink" title="Spherical Coordinates 球坐标"></a>Spherical Coordinates 球坐标</h4><p><strong>对于球体，纬度/经度参数化是熟悉的，并且被广泛使用。它在两极附近有很多失真，这可能会导致困难，但它确实覆盖了整个球体，只有沿一条纬度线的不连续。</strong></p>
<p><strong>表面球形的形状上大致可以使用一个纹理坐标参数化功能,地图上的一个点表面使用径向投影球面上的点:把一条线从球体的中心通过表面的点,并找到与球面相交。这个交点的球坐标是你开始在表面上的点的纹理坐标。</strong></p>
<p><strong>另一种说法是，用球坐标(ρ， θ， φ)表示曲面点，然后去掉ρ坐标，将θ和φ分别映射到范围[0,1]。这个公式依赖于球坐标的约定;使用第2.5.8节的约定，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111758.png" class="" title="image-20210929111758">

<p><strong>一个球坐标地图将是双射的，除了极点，如果整个表面是可见的，从中心点。它在两极附近继承了与球体上的经纬度图相同的失真。下图显示了一个球体坐标提供了合适的纹理坐标函数的对象。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111829.png" class="" title="image-20210929111829">

<p>对于这个模糊的球形物体，将每个点投影到以物体中心为中心的球体上提供了一个单射映射，这里用于放置与球体图像相同的映射纹理。注意，当表面离中心较远时，区域会被放大(表面点在纹理空间中聚集在一起)，而当表面离中心较近时，区域会收缩。</p>
<h4 id="Cylindrical-Coordinates-圆柱坐标"><a href="#Cylindrical-Coordinates-圆柱坐标" class="headerlink" title="Cylindrical Coordinates 圆柱坐标"></a>Cylindrical Coordinates 圆柱坐标</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112018.png" class="" title="image-20210929112018">

<p>一个远离球形的花瓶，球面投影产生很多失真(左)和圆柱形投影产生一个非常好的结果在外部表面。</p>
<p><strong>对于柱状而非球面的物体，从轴向外投影到圆柱体可能比从点投影到球面更好(上图)。类似于球面投影，这相当于转换为柱坐标并丢弃半径:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111957.png" class="" title="image-20210929111957">

<h4 id="Cubemaps-立方体映射"><a href="#Cubemaps-立方体映射" class="headerlink" title="Cubemaps 立方体映射"></a>Cubemaps 立方体映射</h4><p><strong>使用球坐标参数化球形或球形形状会导致形状和极点附近区域的高度失真，这通常会导致可见的伪影，揭示有两个特殊的点纹理出了问题。一种流行的替代方案要均匀得多，但代价是有更多的不连续。这个想法是投射到一个立方体上，而不是一个球体上，然后使用六个独立的正方形纹理为立方体的六个面。6个正方形纹理的集合称为立方体贴图。这在立方体的所有边缘上都引入了不连续，但它保持了形状和面积的低失真。</strong></p>
<p><strong>计算立方地图纹理坐标也比计算球坐标便宜，因为投影到一个平面上只需要一个分割——本质上与透视投影用于观看相同。例如，对于一个投射到立方体的+z面上的点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112312.png" class="" title="image-20210929112312">

<p><strong>三次映射的一个令人困惑的方面是建立如何在六个面上定义u和v方向的约定。任何约定都可以，但是选择的约定会影响纹理的内容，所以标准化是很重要的。因为立方体映射通常用于从立方体内部观察的纹理(参见11.4.5节中的环境映射)，通常的惯例是u轴和v轴朝向，因此从内部观察u轴是顺时针方向的。OpenGL使用的约定是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112406.png" class="" title="image-20210929112406">

<p><strong>下标表示每个投影对应立方体的哪个面。例如，φ - x用于在x = +1处投影到立方体表面的点。你可以通过观察绝对值最大的坐标来判断一个点投射到哪个面:例如，如果|x| &gt; |y|和|x| &gt; |z|，这个点投射到+x面或−x面，这取决于x的符号。</strong></p>
<p><strong>用于立方体贴图的纹理有6个方形块。(参见下图)。通常它们被打包在一个图像中存储，就像立方体被打开一样。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112455.png" class="" title="image-20210929112455">

<p>被投影成立方体地图的表面。表面上的点从中心向外投射，每个点映射到六个面上的一个点上。</p>
<h3 id="Interpolated-Texture-Coordinates-插值纹理坐标"><a href="#Interpolated-Texture-Coordinates-插值纹理坐标" class="headerlink" title="Interpolated Texture Coordinates 插值纹理坐标"></a>Interpolated Texture Coordinates 插值纹理坐标</h3><p><strong>为了对三角形网格表面上的纹理坐标函数进行更细粒度的控制，您可以在每个顶点显式地存储纹理坐标，并在三角形上使用重心插值(章节8.1.2)。它的工作方式与任何其他平滑变化的数量，你可能会定义一个网格:颜色，法线，甚至3D位置本身。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112711.png" class="" title="image-20210929112711">

<p>使用线性插值纹理坐标的单个三角形。左:纹理空间中绘制的三角形;右:在3D场景中渲染的三角形。</p>
<p><strong>让我们看一个单三角形的例子。上图显示了一个三角形纹理映射到现在熟悉的测试模式的一部分。通过查看呈现在三角形上的模式，您可以推断出三个顶点的纹理坐标是(0.2,0.2)、(0.8,0.2)和(0.2,0.8)，因为这些是纹理中出现在三角形三个角上的点。就像前一节中几何决定的映射一样，我们通过给出从表面到纹理域的映射来控制纹理在表面上的位置，在本例中，我们通过指定每个顶点在纹理空间中的位置。一旦你定位了顶点，其余的就由三角形的线性(重心)插值处理了。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112800.png" class="" title="image-20210929112800">

<p>一个二十面体，它的三角形布局在纹理空间中，提供零失真，但有许多接缝。</p>
<p><strong>在上图中，我们展示了一种在整个网格上可视化纹理坐标的常见方法:简单地在纹理空间中绘制顶点位于的三角形他们的纹理坐标。这个可视化显示了哪个三角形正在使用纹理的哪个部分，它是一个方便的工具，用于评估纹理坐标和调试各种纹理映射代码。</strong></p>
<p><strong>由顶点纹理坐标定义的纹理坐标映射的质量取决于分配给顶点的坐标——也就是说，网格在纹理空间中是如何布局的。无论分配什么坐标，只要网格中的三角形共享顶点(章节12.1)，纹理坐标映射总是连续的，因为相邻三角形在共享边的点上的纹理坐标是一致的。但是上面描述的其他可取的品质并不是自动的。注入性意味着三角形在纹理空间中不重叠——如果它们重叠，就意味着纹理中的某个点会出现在表面的多个地方。</strong></p>
<p><strong>当纹理空间中的三角形面积与其三维空间中的三角形面积成比例时，尺寸失真较小。例如，如果使用连续的纹理坐标函数映射角色的脸，那么角色的鼻子就会被压缩到一个相对较小的纹理空间中，如下图所示。虽然鼻子上的三角形比脸颊上的三角形小，但在纹理空间上，大小比例更极端。结果是鼻子上的纹理被放大了，因为一小块纹理必须覆盖大面积的表面。类似地，比较前额和太阳穴，三角形在3D中大小相似，但太阳穴周围的三角形在纹理空间上更大，导致纹理在那里看起来更小。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112912.png" class="" title="image-20210929112912">

<p>一种人脸模型，分配纹理坐标，以达到合理的低形状失真，但仍然显示适度的区域失真。</p>
<p><strong>同样地，当三角形的形状在三维和纹理空间中相似时，形状失真程度也较低。面具有相当低的形状失真。</strong></p>
<h3 id="Tiling-Wrapping-Modes-and-Texture-Transformations-平铺、包裹模式和纹理转换"><a href="#Tiling-Wrapping-Modes-and-Texture-Transformations-平铺、包裹模式和纹理转换" class="headerlink" title="Tiling, Wrapping Modes, and Texture Transformations 平铺、包裹模式和纹理转换"></a>Tiling, Wrapping Modes, and Texture Transformations 平铺、包裹模式和纹理转换</h3><p><strong>允许纹理坐标超出纹理图像的边界通常是有用的。有时这是一个细节:纹理坐标计算中的舍入误差可能会导致恰好落在纹理边界上的顶点稍微偏外，在这种情况下，纹理映射机制应该不会失败。但它也可以是一个建模工具。</strong></p>
<p><strong>如果纹理只覆盖部分表面，但纹理坐标已经设置好，将整个表面映射到单位正方形，一个选项是准备一个纹理图像，大部分是空白的内容在一个小区域。但这可能需要一个非常高分辨率的纹理图像来获得相关区域的足够细节。另一种选择是缩放所有的纹理坐标它们覆盖了一个更大的范围——[- 4.5,5.5]×[- 4.5, 5.5]，例如，将一个正方形单元置于表面中心的十分之一大小。</strong></p>
<p><strong>对于这样的情况，纹理图像所覆盖的单位平方区域之外的纹理查找应该返回一个恒定的背景颜色。一种方法是设置一个背景颜色，以便在单位方块之外的纹理查找时返回。如果已经有一个恒定的背景颜色纹理图像(例如,一个标志在白色背景),另一种方法来扩展这个背景平面安排查找外单位平方返回纹理图像的颜色最接近边缘,通过夹紧u和v坐标的范围从第一个像素的像素的图像。</strong></p>
<p><strong>有时我们想要一个重复的图案，比如棋盘、瓷砖地板或砖墙。如果模式在矩形网格上重复，那么创建包含许多相同数据副本的图像将是一种浪费。相反，我们可以使用环绕索引处理纹理图像之外的纹理查找—当查找点离开纹理图像的右边缘时，它环绕到纹理图像的左边缘。这可以非常简单地使用像素坐标上的整数余数操作来处理。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929113329.png" class="" title="image-20210929113329">

<p><strong>这两种处理越界查找的方式之间的选择是通过从包含平铺、夹紧以及这两种方式的组合或变体的列表中选择包装模式来指定的。在环绕模式下，我们可以自由地将纹理视为返回无限2D平面上任意点颜色的函数(下图)。当我们使用图像指定纹理时，这些模式描述了如何使用有限的图像数据来定义这个函数。在11.5节中，我们将看到程序纹理可以自然地扩展到无限平面，因为它们不受有限图像数据的限制。由于两者在逻辑上都是无限的，这两种类型的纹理是可以互换的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929113402.png" class="" title="image-20210929113402">

<p>通过包裹texel坐标将木地板纹理平铺在纹理空间上。</p>
<p><strong>当调整纹理的比例和位置时，它很方便地避免实际改变生成纹理坐标的函数，或存储在网格顶点的纹理坐标值，而不是应用一个矩阵变换生成纹理坐标，然后使用它们来采样纹理:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929113440.png" class="" title="image-20210929113440">

<p><strong>φmodel 模型是否有纹理坐标函数，MT 是一个3 × 3矩阵，表示2D纹理坐标使用齐次坐标的仿射或投影变换。这种转换有时仅限于缩放和/或平移，大多数使用纹理映射的渲染器都支持这种转换。</strong></p>
<h3 id="Perspective-Correct-Interpolation-透视正确插值"><a href="#Perspective-Correct-Interpolation-透视正确插值" class="headerlink" title="Perspective Correct Interpolation 透视正确插值"></a>Perspective Correct Interpolation 透视正确插值</h3><p><strong>通过在三角形上插值纹理坐标来获得正确的视角有一些微妙之处，但我们可以在栅格化阶段解决这个问题。事情不是那么简单的原因是在屏幕空间中插值纹理坐标会导致不正确的图像，如下图中的网格纹理所示。因为随着与观众距离的增加，视角中的物体会变得更小，所以在3D中间隔均匀的线条在2D图像空间中应该会被压缩。为了实现这一点，需要更仔细地插值纹理坐标。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114000.png" class="" title="image-20210929114000">

<p>左:正确的观点。右:插值到屏幕空间。</p>
<p><strong>我们可以通过插值(u, v)坐标来实现三角形上的纹理映射，修改8.1.2节的光栅化方法，但结果是这样的，在上图右侧显示的问题中。如果使用如下光栅化代码所示的屏幕空间重心坐标，三角形也会出现类似的问题:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114152.png" class="" title="image-20210929114152">

<p><strong>这段代码将生成图像，但有一个问题。为了解开这个基本问题，让我们考虑从世界空间q到齐次点r再到齐次点s的级数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114221.png" class="" title="image-20210929114221">

<p><strong>纹理坐标插值问题最简单的形式是当我们有纹理坐标(u, v)与两个点q和Q相关联时，我们需要在图像中沿着s和S之间的直线生成纹理坐标。如果世界坐标点q′在q和Q投影到屏幕空间点s′在s和S之间的直线上，那么这两个点应该有相同的纹理坐标。</strong></p>
<p><strong>上面的算法所体现的na¨ıve屏幕空间方法表示，在点s′= s+α(S - s)我们应该使用纹理坐标us +α(uS −us)和vs +α(vS −vs)．这是不对的，因为世界空间点q′它转化成s′而不是q + α(Q−q)。</strong></p>
<p><strong>然而，从第7.4节我们知道q和q之间线段上的点确实在s和s之间线段上的某个地方结束;事实上，在那部分我们已经展示过了</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114723.png" class="" title="image-20210929114723">

<p><strong>插值参数t和α是不一样的，但我们可以从另一个计算:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114732.png" class="" title="image-20210929114732">

<p><strong>这些方程为屏幕空间插值思想提供了一个可能的解决方案。获取屏幕空间点的纹理坐标s′= s + α(S−s)，计算us′ = us +t(α)(uS −us) and vs′ = vs +t(α)(vS −vs).点q′它映射到s′，所以这是可行的。然而，评估每个片段的t(α)是缓慢的，有一个更简单的方法。</strong></p>
<p><strong>关键的观察是，因为我们知道，透视变换保留了直线和平面，所以在三角形上线性插值我们想要的任何属性是安全的，但前提是它们与点一起经过透视变换。为了得到几何直观，减小维数，得到齐次点(xr,yr,wr)和一个单独的属性u被插入。属性u应该是xr和yr的线性函数，如果我们把u画成高度场除以(xr,yr)结果是一个平面。现在，如果我们把u看做第三个空间坐标，叫它ur 强调它和其他的是一样的)并发送整个3D齐次点(xr,yr,ur,wr)，结果(xs,ys,us)仍然生成平面上的点。在平面内会有一些扭曲，但平面保持平坦。这意味着us 是(xs,ys)的线性函数，也就是说，我们可以通过基坐标(xs，ys)计算us ．</strong></p>
<p><strong>回到完整的问题，我们需要插值纹理坐标(u, v)，它是世界空间坐标(x)的线性函数(xq,yq, zq)．在将点转换到屏幕空间并添加纹理坐标之后，我们便拥有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929115503.png" class="" title="image-20210929115503">

<p><strong>上一段的实际含义是，我们可以继续并根据(x)的值插值所有这些量(xs,ys)—包括值zs，用于z缓冲区。na¨ıve方法的问题很简单，我们正在插值不一致选择的组件——只要所涉及的数量是在透视分割之前或全部之后，一切都会很好。</strong></p>
<p><strong>剩下的一个问题是(u/wr, v / wr)对于查找纹理数据不是直接有用的;我们需要(u, v)。这就解释了插入上式的额外参数的用途，它的值总是1:一旦我们有了u/wr, v/wr, 1/ wr*，我们可以很容易地通过除法得到(u, v)。</strong></p>
<p><strong>为了验证这是正确的，让我们检查一下插值1/w<em>r</em> 在屏幕空间确实产生了内插wr的倒数在世界空间。要验证这一点，请确认:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929115808.png" class="" title="image-20210929115808">

<p><strong>记住，α(t)和t由上上式联系起来。</strong></p>
<p><strong>这个能力内插1/wr 在转换的空间中，线性且没有错误的允许我们正确地纹理三角形。我们可以使用这些事实来修改三个点ti = (xi,yi, zi,wi)的扫描转换代码，它已经通过观看矩阵，但没有被均质化，完整的纹理坐标ti = (ui, vi)：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929115819.png" class="" title="image-20210929115819">

<p><strong>当然，为了提高速度，伪代码中出现的许多表达式都是在循环外部预先计算的。对于实体纹理，只要包含原始世界空间坐标xq,yq, zq就足够简单了在属性列表中，与u和v相同处理，得到正确的插值世界空间坐标，可以传递给实体纹理函数。</strong></p>
<h3 id="Continuity-and-Seams-连续性和接缝"><a href="#Continuity-and-Seams-连续性和接缝" class="headerlink" title="Continuity and Seams 连续性和接缝"></a>Continuity and Seams 连续性和接缝</h3><p><strong>虽然低失真和连续性是纹理坐标函数的优良特性，但不连续往往是不可避免的。对于任何封闭的三维曲面，没有连续的双射函数将整个曲面映射成纹理图像，这是拓扑的基本结果。有些东西必须要放弃，通过引入接缝(纹理坐标突然改变的表面曲线)，我们可以在其他地方得到低失真。上面讨论的许多几何决定的映射已经包含接缝:在球面和圆柱坐标中，接缝是由atan2计算的角度围绕从π到−π，在立方体贴图中，接缝沿着立方体边缘，在这里映射在六个正方形纹理之间切换。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929120204.png" class="" title="image-20210929120204">

<p>多边形球体:在左侧，有所有共享的顶点，纹理坐标函数是连续的，但在穿过180度子午线的三角形上必然会有问题，因为纹理坐标是从接近180度的经度插值到接近−180度的经度。在右侧，一些顶点被复制，具有相同的3D位置，但纹理坐标在经度上有360度的差异，因此纹理坐标是在子午线上插值的，而不是在整个地图上。</p>
<p><strong>使用插值纹理坐标，接缝需要特别考虑，因为它们不会自然发生。我们前面观察到插值纹理坐标在共享顶点网格上是自动连续的——共享纹理坐标保证了这一点。但这意味着，如果一个三角形跨越一条缝，在一边有一些顶点，在另一边有一些顶点，插补机器将乐于提供一个连续的映射，但它可能会被高度扭曲或折叠，因此它不是内射的。上图在球坐标映射的球体上说明了这个问题。例如，在地球底部附近有一个三角形，它的一个顶点位于新西兰南岛的顶端，另一个顶点位于太平洋北岛东北约400公里处。一个明智的飞行员在这些点之间飞行将飞越新西兰，但路径开始在经度167◦s E(+167)和结束在179◦s W(即经度−179)，所以线性插值选择的路线，在途中跨越南美。这将导致整个地图的反向拷贝被压缩成横过180度子午线的三角形带。解决方案是用等效经度181◦s E标记第二个顶点，但这只是将问题推到下一个三角形。</strong></p>
<p><strong>创建一个干净过渡的唯一方法是避免在接缝处共享纹理坐标:穿越新西兰的三角形需要插入经度+181，而太平洋的下一个三角形需要继续从经度−179开始。为了做到这一点，我们复制顶点在接缝:对于每个顶点，我们添加一个具有相同经度的第二个顶点，不同的360◦，和三角形在接缝的相对边使用不同的顶点。这个解决方案如上图的右半部分所示，其中纹理空间最左边和最右边的顶点是重复的，具有相同的3D位置。</strong></p>
<h2 id="Antialiasing-Texture-Lookups-抗锯齿纹理查找"><a href="#Antialiasing-Texture-Lookups-抗锯齿纹理查找" class="headerlink" title="Antialiasing Texture Lookups 抗锯齿纹理查找"></a>Antialiasing Texture Lookups 抗锯齿纹理查找</h2><p><strong>纹理映射的第二个基本问题是抗锯齿。渲染纹理映射图像是一个采样过程:将纹理映射到表面，然后将表面投影到图像中，生成一个跨图像平面的2D函数，我们以像素对其进行采样。正如我们在第9章中所看到的，当图像包含细节或尖锐的边缘时，使用点样本将产生走样伪影——由于纹理的全部要点就是引入细节，它们成为走样问题的主要来源。</strong></p>
<p><strong>就像线或三角形的抗锯齿光栅化、抗锯齿射线追踪(第13.4节)或向下采样图像(第9.4节)一样，解决方案是使每个像素不是点样本，而是图像的面积平均值，面积大小与像素相似。使用相同的超级采样方法用于平滑光栅化和光线跟踪,有足够的样本,可以获得优秀的结果没有改变纹理映射机械:许多样本像素的区域内将土地在纹理映射不同的地方,和着色的平均值结果计算一个准确的方法是使用不同的纹理查找的平均颜色近似的图像像素。然而，使用详细的纹理需要很多样本才能得到好的结果，这是缓慢的。在表面纹理存在的情况下，有效地计算这一面积平均值是纹理抗锯齿的第一个关键问题。</strong></p>
<p><strong>纹理图像通常由光栅图像定义，因此也需要考虑重构问题，就像上采样图像一样(章节9.4)。纹理的解决方案是一样的:使用一个重建过滤器来插值像素。</strong></p>
<p><strong>我们将在以下各节中详细讨论这些主题。</strong></p>
<h3 id="The-Footprint-of-a-Pixel-像素占用空间"><a href="#The-Footprint-of-a-Pixel-像素占用空间" class="headerlink" title="The Footprint of a Pixel 像素占用空间"></a>The Footprint of a Pixel 像素占用空间</h3><p><strong>使抗锯齿纹理比其他类型的抗锯齿更复杂的是，渲染图像和纹理之间的关系是不断变化的。每个像素值都应该作为图像中属于该像素的区域的平均颜色进行计算，在通常情况下，该像素正在查看单个表面，这相当于对表面上的一个区域进行平均。如果表面颜色来自纹理，那么这就相当于对纹理的相应部分进行平均，即像素的纹理空间足迹。下图展示了正方形区域(在低分辨率图像中可能是像素区域)的足迹如何映射到地板纹理空间中大小和形状非常不同的区域。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930135235.png" class="" title="image-20210930135235">

<p>图像中相同大小的正方形区域纹理空间中的足迹大小和形状在整个图像中都不同。</p>
<p><strong>回想一下使用纹理进行渲染所涉及的三个空间:将3D点映射到图像的投影π和将3D点映射到纹理空间的纹理坐标函数φ。为了处理像素足迹，我们需要理解这两种映射的组成:首先跟踪π以从图像到表面，然后跟踪φ前进。ψ = φ◦π^−1构成决定了像素足迹:一个像素的足迹是该像素在ψ映射下的图像的正方形区域的图像。</strong></p>
<p><strong>纹理反走样的核心问题是计算纹理在像素占用面积上的平均值。要准确地做到这一点通常可能是一项相当复杂的工作:对于具有复杂表面形状的遥远物体，足迹可能是一个复杂的形状，覆盖了纹理空间中的大片区域，或者可能是几个不相连的区域。但在典型情况下，一个像素落在表面的光滑区域，该区域被映射到纹理中的单个区域。</strong></p>
<p><strong>由于ψ同时包含从图像到表面的映射和从表面到纹理的映射，所以占地面积的大小和形状取决于观看情况和纹理坐标函数。当表面距离相机越近，像素足迹越小;当同一表面移动得更远时，足迹就会变大。当以斜角观看表面时，表面上的像素足迹被拉长，这通常意味着它在纹理空间中也会被拉长。即使是在一个固定的视图中，纹理坐标功能也可以导致足迹的变化:如果它扭曲了区域，足迹的大小将会变化，如果它扭曲了形状，它们可以被拉长，甚至在正面的表面视图中。</strong></p>
<p><strong>然而，为了找到一个有效的算法计算抗锯齿查找，将需要一些大量的近似。当函数是平滑的，线性近似通常是有用的。在纹理反走样的情况下，这意味着将ψ从图像空间到纹理空间的映射近似为从2D到2D的线性映射:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930135422.png" class="" title="image-20210930135422">

<p><strong>其中2 × 2矩阵J是ψ导函数的近似。它有四个分量，如果我们将图像空间位置表示为x = (x, y)，纹理空间位置表示为u = (u, v)，那么</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930135434.png" class="" title="image-20210930135434">

<p><strong>当我们改变x和y时，四个导数描述了纹理点(u, v)在图像中的一点(x, y)上的变化。</strong></p>
<p><strong>这种近似的几何解释是，图像中以x为中心的单位大小的正方形像素区域将近似映射到纹理空间中以ψ(x)为中心的平行四边形，其边缘平行于向量</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930135614.png" class="" title="image-20210930135614">

<p><strong>导数矩阵J是有用的，因为它讲述了整个图像(近似的)纹理空间足迹的变化故事。较大的导数表示较大的纹理空间足迹，以及导数向量ux 和uy 之间的关系表示的形状。当他们是正交的，长度相同，足迹是正方形的，当它们变得歪斜和/或在长度上非常不同，足迹变得拉长。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930140210.png" class="" title="image-20210930140210">

<p>近似纹理空间占用的像素可以通过映射的导数(x, y) (u, v)。偏导数对x和y是平行于x和y等值线的图像(法蓝)和跨越一个近似平行四边形(橙色阴影)的弯曲形状的足迹(黑色)中概述。</p>
<p><strong>现在我们已经得到了通常被认为是“正确答案”的问题的形式:在特定图像空间位置的过滤纹理样本应该是纹理贴图在该点纹理坐标导数定义的平行四边形足迹上的平均值。这已经包含了一些假设——即，从图像到纹理的映射是平滑的——但对于优秀的图像质量来说，它是足够精确的。然而，这个平行四边形的面积平均值已经太昂贵，无法精确计算，所以使用了各种各样的近似。纹理反锯齿的方法在速度/质量上的权衡是不同的，它们在近似这个查找时做出了不同的选择。我们将在下面几节中讨论这些问题。</strong></p>
<h3 id="Reconstruction-重建"><a href="#Reconstruction-重建" class="headerlink" title="Reconstruction 重建"></a>Reconstruction 重建</h3><p><strong>当足迹小于一个texel时，我们将纹理映射到图像中。这种情况类似于对图像进行上采样，主要考虑的是在像素之间进行插值，以产生一个像素网格不明显的平滑图像。就像在图像上采样，平滑过程是由一个重建滤波器定义的，用于计算纹理空间中任意位置的纹理样本。(参见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930140445.png" class="" title="image-20210930140445">

<p>纹理过滤的主要问题随足迹大小而变化。对于小的足迹(左)，需要插值像素之间，以避免块状的伪影;对于大的足迹，挑战是有效地找到许多像素的平均值。</p>
<p><strong>这些考虑事项与图像重采样基本相同，但有一个重要的区别。在图像重采样中，任务是在规则网格上计算输出样本，而这种规则性使可分离重构滤波器的重要优化成为可能。在纹理过滤中，查找的模式不规律，需要单独计算样本。这意味着大的，高质量的重建过滤器是非常昂贵的使用，由于这个原因，最高质量的过滤器通常用于纹理是双线性插值。</strong></p>
<p><strong>双线性插值纹理样本的计算相当于用双线性插值计算上采样图像中的一个像素。首先，我们用(实值)texel坐标表示纹理空间样本点，然后读取四个相邻texel的值并将其平均。纹理通常在单位平方上参数化，texels的定位方式与任何图像中的像素相同，间隔距离为1/nu 在u方向和1/nv在v方向，用texel(0,0)从边缘定位半个texel用于对称。(详见第9章。)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930140701.png" class="" title="image-20210930140701">

<p><strong>在许多系统中，这个操作成为一个重要的性能瓶颈，主要是因为从纹理数据中获取四个texel值所涉及的内存延迟。纹理的采样点模式是不规则的，因为从图像到纹理空间的映射是任意的，但通常是连贯的，因为附近的图像点倾向于映射到可能读取相同像素的附近纹理点。因此，高性能系统有专门用于纹理采样的特殊硬件，用于处理插值和管理最近使用的纹理数据的缓存，以最小化从存储纹理数据的内存中获取缓慢数据的数量。</strong></p>
<p><strong>读完第9章后，你可能会抱怨线性插值对于某些苛刻的应用来说可能不是一个足够平滑的重建。然而，通过使用更好的过滤器将纹理重新采样到更高的分辨率，这样纹理就足够光滑，双线性插值也能很好地工作。</strong></p>
<h3 id="Mipmapping-映射"><a href="#Mipmapping-映射" class="headerlink" title="Mipmapping 映射"></a>Mipmapping 映射</h3><p><strong>做一个好的内插工作只满足于纹理被放大的情况:与texels的间距相比，像素占用很小。当一个像素覆盖许多像素时，良好的抗走样需要计算许多像素的平均值来平滑信号，以便安全采样。</strong></p>
<p><strong>一个非常精确的计算足迹上的平均纹理值的方法是找到足迹内的所有像素，并将它们相加。然而，当内存占用很大时，这可能会非常昂贵——仅一次查找就需要读取数千texel。一个更好的方法是预计算和存储不同大小和位置的不同区域纹理的平均值。</strong></p>
<p><strong>这个想法的一个非常流行的版本被称为“MIP映射”或仅仅是MIP映射。一个mipmap是一个纹理序列，所有纹理都包含相同的图像，但分辨率越来越低。原始的全分辨率纹理图像被称为mipmap的基础级别，或级别0，而级别1是通过获取该图像并在每个维度上对其进行因子2的向下采样而生成的，结果是图像有四分之一的像素。这个图像中的像素，粗略地说，是0级图像中2 × 2像素大小的正方形区域的平均值。</strong></p>
<p><em><em>这个过程可以继续定义任意多的mipmap级别:通过将k - 1级别的图像向下采样2，来计算k级别的图像。k级的像素对应一个面积为2的正方形</em>k* 2*k</em> 原始纹理中的Texels。例如，从1024 × 1024的纹理图像开始，我们可以生成一个包含11个级别的mipmap:级别0是1024 × 1024;第1级是512 × 512，如此类推，直到第10级，它只有一个像素。这种以一系列越来越低的采样率表示相同内容的图像结构被称为图像金字塔，它是基于将所有较小的图像堆叠在原始图像之上的视觉隐喻。**</p>
<h3 id="Basic-Texture-Filtering-with-Mipmaps-Mipmaps纹理过滤"><a href="#Basic-Texture-Filtering-with-Mipmaps-Mipmaps纹理过滤" class="headerlink" title="Basic Texture Filtering with Mipmaps Mipmaps纹理过滤"></a>Basic Texture Filtering with Mipmaps Mipmaps纹理过滤</h3><p><strong>有了mipmap或图像金字塔在手，纹理过滤可以比单独访问多个像素更有效地完成。当我们需要一个大面积的平均纹理值时，我们只需使用mipmap的更高级别的值，这些值已经是大面积图像的平均值了。最简单和最快的方法是从mipmap中查找单个值，选择关卡，使该关卡的像素所覆盖的大小与像素足迹的总体大小大致相同。当然，像素占用可能会在形状上与texel所代表的(总是正方形)区域有很大的不同，我们可以预期这会产生一些伪影。</strong></p>
<p><strong>暂且不考虑当像素足迹有一个细长形状时该怎么办的问题，假设足迹是宽度D的正方形，以全分辨率纹理中的像素度量。什么级别的mipmap适合采样?因为k级的像素覆盖宽度为2k的正方形，所以选择k似乎是合适的</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141221.png" class="" title="image-20210930141221">

<p><strong>让k = log₂D.当然，这在大多数情况下会给出k的非整数值，而且我们只存储了整数级别的mipmap图像。两种可能的解决方案是只查找最接近k的整数的值(有效，但在层之间的突变处会产生接缝)或查找最接近k的两个整数的值，然后线性插值这些值(工作量翻倍，但更平滑)。</strong></p>
<p><strong>在我们真正写下采样mipmap的算法之前，我们必须决定当脚印不是正方形时，我们将如何选择“宽度”D。一些可能的方法是使用面积的平方根，或者找到足迹的最长轴并将其称为宽度。一个很容易计算的实用折中方法是使用最长边的长度:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141235.png" class="" title="image-20210930141235">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141249.png" class="" title="image-20210930141249">

<p><strong>基本的mipmapping在消除走样方面做得很好，但因为它无法处理拉长的或各向异性的像素足迹，所以当以掠角观看表面时，它的表现就不太好。这是最常见的在大平面上，代表一个表面的观众是站在。地面上远处的点以非常陡峭的角度观看，导致非常各向异性的脚印，mipmapping近似于更大的正方形区域。由此产生的图像在水平方向上会出现模糊。</strong></p>
<h3 id="Anisotropic-Filtering-各向异性过滤"><a href="#Anisotropic-Filtering-各向异性过滤" class="headerlink" title="Anisotropic Filtering 各向异性过滤"></a>Anisotropic Filtering 各向异性过滤</h3><p><strong>一个mipmap可以与多个查找一起使用，以更好地近似一个延长的内存占用。其思想是根据内存占用的最短轴而不是最大轴来选择mipmap级别，然后将沿着长轴间隔的几个查找相加平均。(参见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141457.png" class="" title="image-20210930141457">

<p>抗锯齿的结果具有挑战性的测试场景(参考图像显示详细的结构，在左边)使用三种不同的策略:简单地采用最近邻插值单点样本;使用mipmap金字塔平均纹理中的每个像素的正方形区域;使用来自mipmap的几个样本来平均纹理中的各向异性区域。</p>
<h2 id="Applications-of-Texture-Mapping-纹理映射的应用"><a href="#Applications-of-Texture-Mapping-纹理映射的应用" class="headerlink" title="Applications of Texture Mapping 纹理映射的应用"></a>Applications of Texture Mapping 纹理映射的应用</h2><p><strong>一旦理解了为曲面定义纹理坐标的概念和查找纹理值的机制，这种机制就有很多用途。在本节中，我们将介绍纹理映射中的一些最重要的技术，但纹理是一种非常通用的工具，其应用仅限于程序员的想象。</strong></p>
<h3 id="Controlling-Shading-Parameters-控制着色参数"><a href="#Controlling-Shading-Parameters-控制着色参数" class="headerlink" title="Controlling Shading Parameters 控制着色参数"></a>Controlling Shading Parameters 控制着色参数</h3><p><strong>纹理映射最基本的用途是通过在着色计算中使用漫反射颜色来引入颜色的变化——无论是在光线追踪器中还是在碎片着色器中——依赖于从纹理中查找的值。一个纹理漫反射组件可以用来粘贴贴花，油漆装饰，或在表面上打印文本，它也可以模拟材料颜色的变化，例如木材或石头。</strong></p>
<p><strong>没有什么能限制我们改变，只有漫反射的颜色。任何其他参数，如镜面反射或镜面粗糙度，也可以被纹理化。例如，一个用透明胶带粘上的纸箱，可能到处都有相同的漫反射颜色，但更有光泽，镜面反射率更高在胶带所在的地方，粗糙度比其他地方要低。在许多情况下不同参数相关的地图:例如,一个光滑的白色陶瓷杯标志印在它可能是粗糙和暗印(下图),和一本书的标题印在金属油墨可能会改变在漫射颜色,镜面的颜色,和粗糙度。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141746.png" class="" title="image-20210930141746">

<p>一个镜面粗糙度的陶瓷杯子，由漫反射颜色纹理的反向拷贝控制。</p>
<h3 id="Normal-Maps-and-Bump-Maps-法线贴图和凹凸贴图"><a href="#Normal-Maps-and-Bump-Maps-法线贴图和凹凸贴图" class="headerlink" title="Normal Maps and Bump Maps 法线贴图和凹凸贴图"></a>Normal Maps and Bump Maps 法线贴图和凹凸贴图</h3><p><strong>另一个对着色很重要的量是表面法线。通过插值法线(第8.2节)，我们知道着色法线不必与底面的几何法线相同。法线贴图利用了这一点，使着色法线依赖于从纹理贴图读取的值。最简单的方法就是在纹理中存储法线，在每个被解释的像素中存储三个数字，而不是作为颜色的三个组成部分，而是作为法向量的3D坐标。</strong></p>
<p><strong>但是，在使用法线映射之前，我们需要知道从映射中读取的法线在哪个坐标系中表示。法线直接存储在对象空间,在同一坐标系中用于代表表面几何本身是简单的:正常读取地图可用于完全由表面本身一样正常的报道:在大多数情况下,它将需要转换成世界空间照明计算,就像一个法线,几何。</strong></p>
<p><strong>然而，存储在对象空间中的法线贴图本质上与表面几何绑定在一起，即使法线贴图没有效果，要用几何法线再现结果，法线贴图的内容也必须跟踪表面的方向。此外，如果表面要变形，因此几何法线改变，对象空间法线贴图不能再使用，因为它将继续提供相同的着色法线。</strong></p>
<p><strong>解决方法是为附在曲面上的法线定义一个坐标系统。这种坐标系可以根据曲面的切空间来定义(见2.5节):选择一对切向量，用它们来定义一组标准正交基(见2.4.5节)。纹理坐标函数本身提供了一个有用的方法来选择一双切线向量:使用u和v的等值线切线方向这些切线不是一般正交的,但我们可以用程序2.4.7“广场”的标准正交基,或者它可以定义使用曲面法线和一个切向量。</strong></p>
<p><strong>当法线在这种基础上表示时，它们的变化要小得多;因为它们大多指向平滑表面的法线方向，所以它们将靠近法线贴图中的向量(0,0,1)^T。</strong></p>
<p><strong>法线贴图从何而来?它们通常是从一个更详细的模型中计算出来的，平滑表面只是一个近似;其他时候，它们可以直接从实际表面测量。它们也可以作为建模过程的一部分进行编写;在这种情况下，通常使用凹凸贴图来间接指定法线。这个想法是凹凸贴图是一个高度场:一个给出光滑表面上的细节表面的局部高度的函数。当数值高的地方(当地图看起来很亮的地方，如果你以图像的形式显示它)，表面就会突出到光滑表面的外面;在数值较低的地方(地图看起来很暗的地方)，表面在它下面后退。例如，凹凸贴图中狭窄的黑线是划痕，或者小白点是凹凸。</strong></p>
<p><strong>从凹凸贴图推导法线贴图很简单:法线贴图(在切线框架中表示)是凹凸贴图的导数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930142138.png" class="" title="image-20210930142138">

<p>一个木质地板渲染使用纹理贴图来控制阴影。(a)只有漫反射颜色是由纹理贴图调制的。(b)镜面粗糙度也由第二个纹理贴图调制。(c)表面法线被凹凸贴图修改。</p>
<p><strong>上图显示了纹理贴图被用来创建木纹颜色和模拟增加的表面粗糙度，由于表面浸透到木材更多的多孔部分，以及凹凸贴图创建一个不完美的表面和木板之间的间隙，以制作一个真实的木地板。</strong></p>
<h3 id="Displacement-Maps-置换贴图"><a href="#Displacement-Maps-置换贴图" class="headerlink" title="Displacement Maps 置换贴图"></a>Displacement Maps 置换贴图</h3><p><strong>法线贴图的一个问题是，它们实际上根本不会改变表面;它们只是一个着色技巧。当法线贴图暗示的几何图形在3D中产生明显的效果时，这就变得很明显了。在静态图像中，首先要注意的问题通常是物体的轮廓保持平滑，尽管在内部出现了凸起。在动画中，由于缺乏视差，这些凸起实际上只是“绘制”在表面上。</strong></p>
<p><strong>纹理可以用于不仅仅是着色，尽管:他们可以用来改变几何。置换贴图是这个想法最简单的版本之一。这个概念和凹凸贴图是一样的:一个标量(单通道)贴图，给出了高于“平均地形”的高度。但效果是不同的。置换贴图实际上改变了表面，沿着光滑表面的法线移动每个点到一个新的位置。法线在每种情况下大致相同，但表面是不同的。</strong></p>
<p><strong>最常用的实现置换贴图的方法是用大量的小三角形对光滑的表面进行镶嵌，然后使用置换贴图对生成网格的顶点进行置换。在图形管线中，这可以在顶点阶段使用纹理查找来完成，这对于地形特别方便。</strong></p>
<h3 id="Shadow-Maps-阴影贴图"><a href="#Shadow-Maps-阴影贴图" class="headerlink" title="Shadow Maps 阴影贴图"></a>Shadow Maps 阴影贴图</h3><p><strong>阴影是场景中物体关系的重要线索，正如我们所看到的，它们很容易包含在光线追踪的图像中。然而，在光栅化渲染中如何获得阴影并不明显，因为表面每次都是单独考虑的。阴影贴图是一种利用纹理映射机制从点光源获得阴影的技术。</strong></p>
<p><strong>阴影贴图的概念是表示由点光源照亮的空间体积。想想像聚光灯或视频投影仪这样的光源，它们从一个点向一个有限范围的方向发射光线。被照亮的体积——如果你把手放在那里，你就能看到光线的点集——是线段的联合，沿着离开那个点的每一条光线，将光源连接到最近的表面点。</strong></p>
<p><strong>有趣的是，这个体积与位于光源同一点的透视相机可见的体积相同:当且仅当从光源位置可见时，一个点被光源照亮。在这两个在这种情况下，我们需要评估场景中的点的可见度:对于可见度，我们需要知道一个片段是否对摄像机可见，是否要在图像中绘制它;对于阴影，我们需要知道一个碎片是否对光源可见，以知道它是否被光源照亮。(参见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930142458.png" class="" title="image-20210930142458">

<p>顶部:由点光源照亮的空间区域。下:那个区域用10像素宽的阴影图来近似。</p>
<p><strong>在这两种情况下，解决方案是一样的:一个深度地图，告诉距离最近的表面沿着一束射线。在可见情况下，这是z缓冲区(章节8.2.3)，对于阴影情况，它被称为阴影映射。在这两种情况下，可见性是通过比较一个新碎片的深度和存储在地图中的深度来评估的，如果表面的深度大于最近的可见表面的深度，那么它将从投影点隐藏(着色或阴影)。不同之处在于，z缓冲区用于跟踪到目前为止看到的最近的表面，并在渲染过程中更新，而阴影贴图告诉整个场景中到最近表面的距离。</strong></p>
<p><strong>阴影贴图是在单独的渲染通道中提前计算的:像往常一样简单地栅格化整个场景，并保留得到的深度贴图(不需要计算像素值)。手里拿着阴影映射,您执行一个普通的渲染,而当你需要知道源片段是可见的,您的项目的位置阴影地图(使用相同的透视投影用于渲染阴影映射首先)和比较查找值dmap 实际距离d到源。如果距离相同，碎片的点就会被照亮;如果d &gt; dmap，这意味着有一个不同的表面更接近光源，所以它是阴影。</strong></p>
<p><strong>“如果距离是相同的”这句话应该在你的脑海中引起一些危险信号:因为所有涉及的数量都是有限精度的近似，我们不能期望它们完全相同。对于可见点，d≈dmap 但有时d会大一点，有时小一点。因此，需要一个公差:如果d - dmap &lt; E，则认为一个点是亮的。这种容忍被称为“阴影偏差”。</strong></p>
<p><strong>当在阴影贴图中查找时，在地图中记录的深度值之间插入并不是很有意义。这可能会在平滑区域产生更精确的深度(需要更少的阴影偏差)，但会在阴影边界附近造成更大的问题，在那里深度值会突然改变。因此，阴影贴图中的纹理查找是使用最近邻重建来完成的。为了减少走样，可以使用多个样本，平均1或0的阴影结果(而不是深度);这被称为百分比更接近过滤。</strong></p>
<h3 id="Environment-Maps-环境贴图"><a href="#Environment-Maps-环境贴图" class="headerlink" title="Environment Maps 环境贴图"></a>Environment Maps 环境贴图</h3><p><strong>正如纹理可以方便地将细节引入到表面的着色中，而不必为模型添加更多的细节，纹理也可以用于将细节引入到照明中，而无需建模复杂的光源几何。当光线来自与视野中物体大小相比较的远处时，场景中点对点的照明变化很小。假设光照只依赖于你观察的方向，并且场景中所有点的光照都是相同的，然后使用环境地图来表示光照对方向的依赖是很方便的。</strong></p>
<p><strong>环境地图的理念是，在3D方向上定义的函数是单位球体上的函数，所以它可以使用纹理贴图来表示，就像我们在球形物体上表示颜色变化一样。我们没有使用曲面点的三维坐标来计算纹理坐标，而是使用完全相同的公式来计算单位向量的三维坐标，单位向量表示我们想要知道的光照方向。</strong></p>
<p><strong>环境地图最简单的应用是在光线追踪器中给不击中任何物体的光线着色:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930142925.png" class="" title="image-20210930142925">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930142942.png" class="" title="image-20210930142942">

<p><strong>随着光线追踪器的改变，反射其他场景物体的发光物体现在也会反射背景环境。</strong></p>
<p><strong>在光栅化上下文中也可以通过在着色计算中添加镜面反射来达到类似的效果，其计算方法与在光线追踪器中相同，但只需直接在环境地图中查找，而不考虑场景中的其他物体:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930143035.png" class="" title="image-20210930143035">

<p><strong>这种技术被称为反射映射。</strong></p>
<p><strong>环境贴图的一个更高级的应用是从环境地图中计算所有的照明，而不仅仅是镜面反射。这是环境照明，可以用Monte Carlo积分在光线追踪器中计算，也可以用点源集合来近似环境并计算许多阴影图来进行光栅化。</strong></p>
<p><strong>环境映射可以存储在任何坐标中，这些坐标可以用于映射球体。球面(经纬度)坐标是一种流行的选择，尽管在极点压缩纹理会浪费纹理分辨率，并且会在极点创建伪影。Cubemaps是一种更有效的选择，广泛用于交互式应用程序(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930143203.png" class="" title="image-20210930143203">

<p>圣彼得大教堂的立方体地图，六个面存储在图像上的展开的“水平十字”安排。(材质:埃米尔佩尔森)</p>
<h2 id="Procedural-3D-Textures-程序3D纹理"><a href="#Procedural-3D-Textures-程序3D纹理" class="headerlink" title="Procedural 3D Textures 程序3D纹理"></a>Procedural 3D Textures 程序3D纹理</h2><p><strong>在前面的章节中，我们使用了cr 即物体上一点的漫反射。对于一个没有纯色的对象，我们可以用函数cr(p)来替换它将3D点映射为RGB颜色(Peachey, 1985;佩林,1985)。这个函数可能只是返回包含p的对象的反射。但是对于带有纹理的对象，我们应该期望cr(p)随着p在表面上的移动而变化。</strong></p>
<p><strong>定义从3D表面映射到2D纹理域的纹理映射函数的另一种选择是创建一个3D纹理，定义的RGB值为在三维空间中的每个点。我们只对曲面上的点p调用它，但通常为所有3D点定义它比为任意曲面上可能奇怪的2D点子集更容易。3D纹理映射的好处是映射函数的定义很容易，因为曲面已经嵌入到3D空间中，从3D到纹理空间的映射没有失真。这种策略显然适用于由固体介质“雕刻”而成的表面，例如大理石雕塑。</strong></p>
<p><strong>3D纹理的缺点是将它们存储为3D光栅图像或体积会消耗大量内存。由于这个原因，三维纹理坐标最常用于程序纹理，其中纹理值是使用数学程序计算的，而不是通过从纹理图像中查找它们。在本节中，我们将介绍一些用于定义程序纹理的基本工具。这些也可以用于定义2D程序纹理，尽管在2D中更常见的是使用光栅纹理图像。</strong></p>
<h3 id="3D-Stripe-Textures-3D条纹纹理"><a href="#3D-Stripe-Textures-3D条纹纹理" class="headerlink" title="3D Stripe Textures 3D条纹纹理"></a>3D Stripe Textures 3D条纹纹理</h3><p><strong>制作条纹纹理的方法多得惊人。假设有两种颜色c0 和c1 我们想用它来制作条纹颜色。我们需要一些振荡函数在两种颜色之间切换。一个简单的是sin:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102252.png" class="" title="image-20211001102252">

<p><strong>我们还可以使条纹的宽度w可控:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102307.png" class="" title="image-20211001102307">

<p><strong>如果我们想在条纹颜色之间进行平滑插值，我们可以使用参数t来线性改变颜色:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102319.png" class="" title="image-20211001102319">

<p><strong>下图显示了这三种可能性。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102351.png" class="" title="image-20211001102351">

<p>不同的条纹纹理是在保持z不变的情况下绘制xy点的规则数组的结果。</p>
<h3 id="Solid-Noise-固体噪波"><a href="#Solid-Noise-固体噪波" class="headerlink" title="Solid Noise 固体噪波"></a>Solid Noise 固体噪波</h3><p><strong>虽然常规纹理如条纹通常是有用的，但我们希望能够制作“斑纹”纹理，如我们在鸟蛋上看到的。这通常是通过使用一种“固体噪波”来实现的，通常以它的发明者柏林噪音的名字命名，柏林噪音因其对电影工业的影响而获得了学院奖(1985)。</strong></p>
<p><strong>通过为每个点调用一个随机数来得到一个嘈杂的外观是不合适的，因为它就像电视静态中的“白噪音”。我们希望在不丢失随机质量的前提下使它更平滑。一种可能是模糊白噪声，但没有实际的实施。另一种可能是在每个点上都有一个随机数的大晶格，然后将这些随机点插值到晶格节点之间的新点上;这只是一个3D纹理数组，就像上一节描述的那样，数组中有随机数。这种技术使晶格过于明显。Perlin使用了各种技巧来改进这个基本的点阵技术，所以点阵不是那么明显。这就产生了一组巴洛克式的步骤，但本质上只是从线性插值一个随机值的3D数组的三个变化。第一个改变是使用埃尔米特插值来避免马赫带，就像可以用常规纹理做的那样。第二个变化是使用随机向量而不是数值，用点积来推导一个随机数;通过移动网格顶点的局部极小值和极大值，使得底层网格结构在视觉上不那么明显。第三个变化是使用一维数组和散列来创建一个随机向量的虚拟3D数组。这增加了计算以降低内存使用。以下是他的基本方法:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102825.png" class="" title="image-20211001102825">

<p><strong>其中(x, y, z)是x的笛卡尔坐标</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102836.png" class="" title="image-20211001102836">

<p><strong>ω(t)为三次权重函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102854.png" class="" title="image-20211001102854">

<p><strong>最后一个是Γijk 是晶格点(x, y, z) = (i, j, k)的随机单位向量。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102906.png" class="" title="image-20211001102906">

<p><strong>其中G是一个由n个随机单位向量组成的预计算数组，φ(i) = P[i mod n]其中P是一个长度为n的数组，包含从0到n−1的整数排列。在实践中，Perlin报告说n = 256的效果很好。随机选择一个单位向量(vx, vy, vz)第一组</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103000.png" class="" title="image-20211001103000">

<p><strong>ξ,ξ′,ξ″为标准随机数(在区间[0,1]内均匀)。然后,如果(vx² + vy² + vz²) &lt; 1，使向量为单位向量。否则，继续随机设置它，直到它的长度小于1，然后使它成为一个单位向量。这是一个拒绝方法的例子，将在第14章中进一步讨论。从本质上说，“小于”测试在单位球中得到一个随机点，而原点到该点的矢量是均匀随机的。对于立方体中的随机点，这是不成立的，所以我们在测试中“去掉”了棱角。</strong></p>
<p><strong>因为固体噪声可以是正的，也可以是负的，所以在转换为颜色之前必须先进行转换。下图显示了10 × 10平方上的噪声绝对值，以及拉伸后的版本。这些版本是通过缩放噪声函数的输入点来拉伸的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103217.png" class="" title="image-20211001103217">

<p>固体噪声的绝对值，以及缩放后的x和y值的噪声。</p>
<p><strong>暗曲线是原始噪声函数由正变为负的地方。由于噪声从−1到1不等，使用(噪声+1)/2的颜色可以实现更平滑的图像。然而，由于噪声值接近1或−1是罕见的，这将是一个相当平滑的图像。更大的缩放可以增加对比度(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103304.png" class="" title="image-20211001103304">

<p>上：使用 0.5(noise+1) 强度，下：使用 0.8(noise+1) 强度。</p>
<h3 id="Turbulence-湍流"><a href="#Turbulence-湍流" class="headerlink" title="Turbulence 湍流"></a>Turbulence 湍流</h3><p><strong>许多自然纹理在同一纹理中包含不同的特征尺寸。Perlin使用伪分形“湍流”函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103732.png" class="" title="image-20211001103732">

<p><strong>如下图所示，这有效地重复添加了噪声函数的放大副本。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103756.png" class="" title="image-20211001103756">

<p>湍流函数具有(从左上到右下)1到8项求和。</p>
<p><strong>湍流可以用来扭曲条纹函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103743.png" class="" title="image-20211001103743">

<p><strong>k的不同值1 和k2 用于生成下图。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103809.png" class="" title="image-20211001103809">

<p>不同k的湍流条纹结构1 <em>k</em>2．第一行只有湍流级数的第一项。</p>
<h1 id="12-Data-Structures-for-Graphics-图形的数据结构"><a href="#12-Data-Structures-for-Graphics-图形的数据结构" class="headerlink" title="12 Data Structures for Graphics 图形的数据结构"></a>12 Data Structures for Graphics 图形的数据结构</h1><p><strong>某些数据结构似乎在图形应用程序中反复出现，可能是因为它们解决了表面、空间和场景结构等基本的底层概念。本章讨论了一些最常见和最有用的基本和不相关的数据结构类别:网格结构、空间数据结构、场景图和平铺多维数组。</strong></p>
<p><strong>对于网格，我们讨论了用于存储静态网格和将网格传输到图形api的基本存储方案。我们还讨论了翼边数据结构(Baumgart, 1974)和相关的半边结构，这对管理镶嵌变化的模型很有用，如细分或模型简化。虽然这些方法推广到任意多边形网格，但我们在这里只关注简单的三角形网格。</strong></p>
<p><strong>然后给出了场景图数据结构。这种数据结构的各种形式在图形应用程序中无处不在，因为它们在管理对象和转换方面非常有用。所有新的图形api都是为了支持场景图形而设计的。</strong></p>
<p><strong>对于空间数据结构，我们讨论了在三维空间边界体层次结构、层次空间细分和统一空间细分中组织模型的三种方法，以及使用层次空间细分(BSP树)来去除隐藏表面。同样的方法也用于其他目的，包括几何剔除和碰撞检测。</strong></p>
<p><strong>最后，提出了平铺多维数组。这种结构最初是为了在需要从磁盘交换图形数据的应用程序中提高分页性能而开发的，但现在对于机器上的内存局部来说，不管数组是否适合主内存，这种结构都是至关重要的。</strong></p>
<h2 id="Triangle-Meshes-三角形网格"><a href="#Triangle-Meshes-三角形网格" class="headerlink" title="Triangle Meshes 三角形网格"></a>Triangle Meshes 三角形网格</h2><p><strong>大多数真实世界的模型都是由具有共享顶点的三角形组成的综合体。这些通常被称为三角形网格、三角形网格或三角形不规则网络(TINs)，有效地处理它们对许多图形程序的性能至关重要。重要的效率取决于应用程序。网格存储在磁盘和内存中，我们希望最小化所消耗的存储量。当网格跨网络传输或从CPU传输到图形系统时，它们会消耗带宽，这通常比存储更宝贵。在对网格执行操作的应用程序中，除了简单地存储和绘制它们之外(如细分、网格编辑、网格压缩或其他操作)，高效地访问邻接信息是至关重要的。</strong></p>
<p><strong>三角形网格通常用来表示曲面，所以网格不仅仅是不相关的三角形的集合，而是通过共享顶点和边相互连接的三角形网络，形成一个连续的曲面。这是一个关于网格的关键洞见:一个网格可以比一个相同数量的不相关三角形的集合更有效地处理。</strong></p>
<p><strong>三角形网格所需的最小信息是一组三角形(顶点的三组)及其顶点在三维空间中的位置。但是，许多(如果不是大多数的话)程序需要在顶点、边或面存储额外数据的能力，以支持纹理映射、着色、动画和其他操作。顶点数据是最常见的:每个顶点都可以有材质参数、纹理坐标、辐照度——任何值在表面上发生变化的参数。然后，这些参数在每个三角形上进行线性插值，从而在整个网格表面上定义一个连续的函数。然而，能够存储每个边或每个面的数据有时也很重要。</strong></p>
<h3 id="Mesh-Topology-网格拓扑"><a href="#Mesh-Topology-网格拓扑" class="headerlink" title="Mesh Topology 网格拓扑"></a>Mesh Topology 网格拓扑</h3><p><strong>网格类曲面的概念可以形式化为网格拓扑的约束——不考虑顶点位置的三角形连接方式。许多算法只能在具有可预测连接性的网格上工作，或者更容易实现。网格拓扑最简单和最严格的要求是表面是一个流形。流形网格是“水密”的——它没有缝隙，将表面内部的空间与外部的空间分隔开来。它看起来也像网格上的每个表面。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001104828.png" class="" title="image-20211001104828">

<p>非流形(左)和流形(右)在克格勃边缘。</p>
<p><strong>术语流形来自于拓扑学的数学领域:粗略地说，一个流形(特别是一个二维流形，或2-流形)是任何一点周围的一个小邻域都可以被平滑成一个平面的表面。这个想法是最清楚地解释为反例:如果一个边缘在一个网有三个三角形连接,点的小区边缘不同于附近的一个点在三角形的内部,因为它有一个额外的“鳍”伸出它(上图)。如果这条边正好有两个三角形连接在上面，那么这条边上的点就像内部的点一样，只是中间有一个折痕。类似地，如果共享一个顶点的三角形处于下图中左侧三角形的构型中，其邻域就像在中心粘在一起的两块表面，如果不将其加倍，就无法将其变平。在右边有简单邻域的顶点就可以了。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001105003.png" class="" title="image-20211001105003">

<p>非流形(左)和流形(右)在克格勃顶点。</p>
<p><strong>许多算法假设网格是流形的，如果输入的是一个畸形的网格，验证这个属性以防止崩溃或无限循环总是一个好主意。这个验证归结为检查所有的边是流形，检查所有的顶点是流形，通过验证以下条件:</strong></p>
<p>​    <strong>每条边正好由两个三角形共享。</strong></p>
<p>​    <strong>每个顶点周围都有一个完整的三角形环。</strong></p>
<p><strong>上上图说明了一条边如何因为有太多三角形而在第一次测试中失败，上图说明了一个顶点如何因为有两个独立的三角形环连接到它而在第二次测试中失败。</strong></p>
<p><strong>流形网格很方便，但有时需要允许网格有边或边界。这样的网格不是流形——边界上的一个点有一个在一边被切断的邻域。它们不一定是无懈可击的。然而，我们可以将流形网格的要求放宽到具有边界的流形，而不会对大多数网格处理算法造成问题。放宽的条件是:</strong></p>
<p>​    <strong>每条边都被一个或两个三角形使用。</strong></p>
<p>​    <strong>每个顶点连接到一个边连通的三角形集合。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001105300.png" class="" title="image-20211001105300">

<p>具有边缘条件的边界。</p>
<p><strong>上图说明了这些条件:从左到右，有一条边有一个三角形，一个顶点的相邻三角形在一个边连接的集合中，一个顶点有两个不相连的三角形集合连接在它上。</strong></p>
<p><strong>最后，在许多应用中，区分一个表面的“正面”或“外部”和“背面”或“内部”是很重要的——这被称为表面的方向。对于单个三角形，我们根据列出顶点的顺序来定义方向:前面是三角形的三个顶点逆时针排列的边。连通网格为一直面向如果它的三角形都同意哪边是正面——当且仅当每一对相邻的三角形都有一致的方向时，这个成立。</strong></p>
<p><strong>在一对一致方向的三角形中，两个共享顶点在两个三角形的顶点列表中以相反的顺序出现(下图)。重要的是方向的一致性——有些系统使用顺时针而不是逆时针来定义正面。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001105532.png" class="" title="image-20211001105532">

<p>三角形(B,A,C)和(D,C,A)是一致的，而(B,A,C)和(A,C,D)是不一致的。</p>
<p><strong>任何具有非流形边缘的网格都不能保持一致的方向。但网格也有可能是一个有效的带有边界的流形(甚至是流形)，但却没有一致的方法来确定三角形的方向——它们不是可定向的表面。如下图所示的M¨obius带就是一个例子。然而，这在实践中很少成为一个问题。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001105637.png" class="" title="image-20211001105637">

<p>一个三角形的M¨obius带，它不是可定向的。</p>
<h3 id="Indexed-Mesh-Storage-索引网格存储"><a href="#Indexed-Mesh-Storage-索引网格存储" class="headerlink" title="Indexed Mesh Storage 索引网格存储"></a>Indexed Mesh Storage 索引网格存储</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110225.png" class="" title="image-20211001110225">

<p>一个有四个顶点的三三角形网格，用分开的三角形(左)和共享的顶点(右)表示。</p>
<p><strong>一个简单的三角形网格如上图所示。你可以将这三个三角形存储为独立的实体，每一个都是这样的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110236.png" class="" title="image-20211001110236">

<p><strong>这将导致顶点b被存储3次，其他顶点各2次，共9个存储点(3个三角形中的每个三角形对应3个顶点)。或者你可以安排共享公共顶点，结果只存储四个在共享顶点网格中。逻辑上，这个数据结构有指向包含顶点数据的顶点的三角形:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110409.png" class="" title="image-20211001110409">

<p><strong>注意，v数组中的条目是指向Vertex对象的引用或指针;顶点不包含在三角形中。</strong></p>
<p><strong>在实现中，顶点和三角形通常存储在数组中，通过存储数组索引来处理三角形到顶点的引用:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110445.png" class="" title="image-20211001110445">

<p><strong>第i个三角形的第k个顶点的索引在tInd[i] [k]中找到，该顶点的位置存储在vertex数组的相应行中;参见下图中的示例。这种存储共享顶点网格的方法是索引三角形网格。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110541.png" class="" title="image-20211001110541">

<p>一种更大的三角形网格，其部分表示为索引三角形网格。</p>
<p><strong>分开的三角形或共享的顶点都可以很好地工作。共享顶点有空间优势吗?如果我们的网格有nv 顶点和nt 三角形,如果我们假设浮点数、指针和整型数的数据都需要相同的存储空间(一个可疑的假设)，那么对空间的要求如下:</strong></p>
<p>​    <strong>三角形：每个三角形有三个向量，对于9nt 单位的存储;</strong></p>
<p>​    <strong>索引网格：每个顶点有一个向量，每个三角形有三个int值，对应3nv + 3nt 单位的存储。</strong></p>
<p><strong>相对存储要求取决于nt 到nv的比值．</strong></p>
<p><strong>根据经验法则，一个大型网格的每个顶点都与大约6个三角形相连(尽管在极端情况下可以有任意数量的三角形)。由于每个三角形连接三个顶点，这意味着在一个大网格中，三角形的数量通常是顶点的两倍:nt≈2nv．通过这个替换，我们可以得出存储需求是18nv为三角形结构和9nv为索引网格。使用共享顶点可以将存储需求减少大约1/2;这似乎适用于大多数实现。</strong></p>
<h3 id="Triangle-Strips-and-Fans-三角形带和扇"><a href="#Triangle-Strips-and-Fans-三角形带和扇" class="headerlink" title="Triangle Strips and Fans 三角形带和扇"></a>Triangle Strips and Fans 三角形带和扇</h3><p><strong>索引网格是三角形网格最常见的内存表示形式，因为它们在简单性、便捷性和紧凑性之间取得了良好的平衡。它们也通常用于在网络上以及应用程序和图形管道之间传输网格。在需要更紧凑的应用程序中，三角形顶点索引(仅在顶点处占索引网格空间的三分之二)可以使用三角形带和三角形扇形更有效地表示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001115310.png" class="" title="image-20211001115310">

<p><strong>三角形扇形如上图所示。在索引网格中，三角形数组将包含[(0,1,2)，(0,2,3)，(0,3,4)，(0,4,5)]。我们存储了12个顶点索引，尽管只有6个不同的顶点。在三角形扇形中，所有三角形共享一个共同的顶点，其他顶点生成一组三角形，就像可折叠扇形的叶片一样。图中的扇形可以用序列[0,1,2,3,4,5]来指定:第一个顶点建立中心，然后每一对相邻顶点(1-2,2-3等)组成一个三角形。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001115423.png" class="" title="image-20211001115423">

<p><strong>三角形带是一个类似的概念，但它适用于更大范围的网格。在这里，顶点在一个如上图所示的线性条的顶部和底部交替添加。图中的三角形带可以用序列[0 1 2 3 4 5 6 7]指定，三个相邻顶点(0- 1-2、1-2-3等)的子序列创建一个三角形。为了保持一致的方向，每个其他三角形都需要颠倒它的顺序。在这个例子中，结果是三角形(0,1,2)，(2,1,3)，(2,3,4)，(4,3,5)等等。对于每个进入的新顶点，最老的顶点被遗忘，剩下的两个顶点的顺序被交换。参见下图以获得更大的示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001115521.png" class="" title="image-20211001115521">

<p>两个三角形带在一个更大的网格中。请注意，这两个条带都不能扩展为包含用星号标记的三角形。</p>
<p><strong>在条形网格和扇形网格中，n + 2个顶点就足以描述n个三角形，这大大节省了标准索引网格所需的3n个顶点。如果程序是顶点限界的，长三角形带将节省大约三倍的时间。</strong></p>
<p><strong>似乎只有当三角形条很长时三角形条才有用，但即使是相对较短的三角形条也能获得大部分好处。节省的存储空间(仅针对顶点索引)如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001115607.png" class="" title="image-20211001115607">

<p><strong>因此，事实上，随着条带变长，回报会迅速递减。因此，即使对于一个非结构化的网格，也值得使用一些贪婪算法将它们聚集成短条带。</strong></p>
<h3 id="Data-Structures-for-Mesh-Connectivity-用于网格连通性的数据结构"><a href="#Data-Structures-for-Mesh-Connectivity-用于网格连通性的数据结构" class="headerlink" title="Data Structures for Mesh Connectivity 用于网格连通性的数据结构"></a>Data Structures for Mesh Connectivity 用于网格连通性的数据结构</h3><p><strong>索引网格、条形网格和扇形网格都是很好的、紧凑的静态网格表示。然而，它们不容易允许网格被修改。为了有效地编辑网格，需要更复杂的数据结构来有效地回答以下查询:</strong></p>
<p>​    <strong>给定一个三角形，三个相邻的三角形是什么?</strong></p>
<p>​    <strong>给定一条边，哪两个三角形共用一条边?</strong></p>
<p>​    <strong>给定一个顶点，哪些面共享它?</strong></p>
<p>​    <strong>给定一个顶点，哪些边共享它?</strong></p>
<p><strong>对于三角形网格、多边形网格和带孔的多边形网格，有许多数据结构。在许多应用中，网格非常大，因此有效的表示是至关重要的。</strong></p>
<p><strong>最直接(虽然臃肿)的实现是拥有三种类型:顶点、边和三角形，并直接存储所有关系:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125210.png" class="" title="image-20211001125210">

<p><strong>这让我们可以直接查找上述连接问题的答案，但由于这些信息都是相互关联的，因此存储的信息比实际需要的要多。此外，在顶点中存储连接性会产生变长数据结构(因为顶点可以有任意数量的邻居)，这通常是较低效的实现。与其承诺显式地存储所有这些关系，不如定义一个类接口来回答这些问题，这样可以隐藏更有效的数据结构。事实证明，我们只能存储部分连接，并在需要时有效地恢复其他信息。</strong></p>
<p><strong>Edge和Triangle类中的固定大小数组表明，在那里存储连接信息会更有效。事实上，对于多边形网格，多边形的边数和顶点数都是任意的，只有边具有固定大小的连通性信息，这导致许多传统的网格数据结构都是基于边的。但对于只使用三角形的网格，将连接性存储在(数量较少的)面上是很有吸引力的。</strong></p>
<p><strong>一个好的网格数据结构应该是合理紧凑的，并允许对所有邻接查询的有效回答。高效意味着固定的时间:寻找邻居的时间不应依赖于网格的大小。我们将研究网格的三种数据结构，一种基于三角形，两种基于边。</strong></p>
<h4 id="The-Triangle-Neighbor-Structure-三角形邻边结构"><a href="#The-Triangle-Neighbor-Structure-三角形邻边结构" class="headerlink" title="The Triangle-Neighbor Structure 三角形邻边结构"></a>The Triangle-Neighbor Structure 三角形邻边结构</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125607.png" class="" title="image-20211001125607">

<p>三角形中三角形和顶点之间的引用邻边结构。</p>
<p><strong>我们可以创建一个基于三角形的紧凑网格数据结构，方法是使用从三角形到三个相邻三角形的指针，以及从每个顶点到一个相邻三角形的指针(不管是哪个三角形)来增加基本共享顶点网格;见上图:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125704.png" class="" title="image-20211001125704">

<p><strong>在数组Triangle.nbr，第k个入口指向相邻的三角形它共享顶点k和k + 1。我们称这种结构为三角形邻接结构。从标准的索引网格数组开始，它可以通过两个额外的数组来实现:一个存储每个三角形的三个邻居，另一个存储每个顶点的单个邻接三角形(参见下图中的例子):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125716.png" class="" title="image-20211001125716">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125810.png" class="" title="image-20211001125810">

<p>编码在数组中的三角形邻接结构，以及在遍历顶点2的相邻三角形时所遵循的顺序。</p>
<p><strong>显然，三角形的相邻三角形和顶点可以直接在数据结构中找到，但通过仔细使用这个三角形邻接信息，也可以在常数时间内回答关于顶点的连接性查询。这个想法就是从一个三角形移动到另一个三角形，只访问与相关顶点相邻的三角形。如果三角形t的第k个顶点是顶点v，那么三角形t.nbr [k]是沿顺时针方向围绕v的下一个三角形。这种观察结果导致了以下算法遍历所有与给定顶点相邻的三角形:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125925.png" class="" title="image-20211001125925">

<p><strong>该操作以恒定的时间找到每个后续三角形——尽管需要搜索每个三角形的顶点列表中的中心顶点位置，但顶点列表的大小是恒定的，因此搜索所需的时间是恒定的。然而，这种搜索是笨拙的，需要额外的分支。</strong></p>
<p><strong>一个小的改进可以避免这些搜索。问题是，一旦我们沿着指针从一个三角形到另一个三角形，我们就不知道我们是从哪个方向来的:我们必须搜索三角形的顶点，以找到与前一个三角形相连的顶点。为了解决这个问题，我们不存储相邻三角形的指针，而是通过使用指针存储索引来存储指向这些三角形特定边的指针:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130017.png" class="" title="image-20211001130017">

<p><strong>实际上，Edge是通过从三角形索引t中借用两位存储空间来存储边索引i，因此总存储需求保持不变。</strong></p>
<p><strong>在这种结构中，三角形的邻居数组告诉我们哪些相邻三角形的边与三角形的三条边共享。有了这个额外的信息，我们总是知道在哪里找到原始三角形，这导致了数据结构的不变量:对于任意三角形t的任何第j条边，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130048.png" class="" title="image-20211001130048">

<p><strong>知道我们从哪条边进来，我们就能立即知道要从哪条边出去，以便继续绕着一个顶点走，从而产生一种流线型算法:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130059.png" class="" title="image-20211001130059">

<p><strong>三角形邻接结构非常紧凑。对于只有顶点位置的网格，我们每个顶点存储4个数字(三个坐标和一条边)，每个面存储6个数字(三个顶点索引和三条边)，总共4nv + 6nt ≈16nv 每个顶点的存储单位为9nv 用于基本索引网格。</strong></p>
<p><strong>这里展示的三角形邻居结构仅适用于流形网格，因为它依赖于返回到起始三角形来终止顶点的邻居的遍历，而这不会发生在没有完整三角形循环的边界顶点上。然而，将其推广到有边界的流形并不困难，只需为边界三角形的邻居引入一个合适的哨兵值(如−1)，并注意边界顶点指向最逆时针的邻近三角形，而不是任意三角形。</strong></p>
<h4 id="The-Winged-Edge-Structure-翼边结构"><a href="#The-Winged-Edge-Structure-翼边结构" class="headerlink" title="The Winged-Edge Structure 翼边结构"></a>The Winged-Edge Structure 翼边结构</h4><p><strong>一种广泛使用的将连接性信息存储在边缘而不是表面的网格数据结构是翼边数据结构。这个数据结构使边成为数据结构的一级成员，如下两图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130438.png" class="" title="image-20211001130438">

<p>一个翼边网格结构的例子，存储在阵列中。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130455.png" class="" title="image-20211001130455">

<p>翼边数据结构的四面体和相关元素。两张表并不是独一无二的;每个顶点和面存储与其相关联的任何一条边。</p>
<p><strong>在翼边网格中,每个边缘存储指针的两个顶点(头部和尾部顶点),两面是(左和右面)的一部分,最重要的是,下一个和以前的边缘的逆时针方向遍历左和右面(下图)。每个顶点和面还存储一个指向连接它的任意边的指针:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130809.png" class="" title="image-20211001130809">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130819.png" class="" title="image-20211001130819">

<p>从边缘到翼边结构中的相邻边、面和顶点。</p>
<p><strong>翼边数据结构支持恒时访问面或顶点的边，从这些边可以找到相邻的顶点或面:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130914.png" class="" title="image-20211001130914">

<p><strong>这些相同的算法和数据结构同样适用于不局限于三角形的多边形网格;这是基于边缘的结构的一个重要优点。</strong></p>
<p><strong>与任何数据结构一样，翼边数据结构会做出各种时间/空间权衡。例如，我们可以消除前面的引用。这使得顺时针绕面或逆时针绕顶点遍历变得更加困难，但当我们需要知道之前的边时，我们总是可以沿着圆中的后续边，直到我们回到原来的边。这节省了空间，但使一些操作变慢了。</strong></p>
<h4 id="The-Half-Edge-Structure-半边结构"><a href="#The-Half-Edge-Structure-半边结构" class="headerlink" title="The Half-Edge Structure 半边结构"></a>The Half-Edge Structure 半边结构</h4><p><strong>翼边结构相当优雅，但它还有一个尴尬之处——在移动到下一个边缘之前，需要不断检查边缘的方向。这种检查直接类似于我们在三角形邻居结构的基本版本中看到的搜索:我们要找出我们是从头部还是从尾部进入当前边缘的。解决方案也几乎没有区别:我们不是为每条边存储数据，而是为每条半边存储数据。共享一条边的两个三角形各有一条半边，这两条半边的方向相反，每条边都与它自己的三角形一致。</strong></p>
<p><strong>通常存储在边中的数据在两个半边之间分割。每条半边都指向边一侧的面和头部的顶点，每条半边都包含面向其面的边指针。它还指向边缘另一边的邻居，从那里可以找到另一半信息。与翼边一样，半边可以包含指向其正面周围的前半边和下半边的指针，也可以只指向下半边。我们将展示使用单个指针的示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131124.png" class="" title="image-20211001131124">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131311.png" class="" title="image-20211001131311">

<p>从半边到的引用它的邻近网格组件。</p>
<p><strong>遍历一个半边结构就像遍历一个翼边结构一样，除了我们不再需要检查方向，我们跟随对指针访问相反面的边。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131157.png" class="" title="image-20211001131157">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131211.png" class="" title="image-20211001131211">

<p><strong>这里的顶点遍历是顺时针的，这是必要的，因为结构中省略了prev指针。</strong></p>
<p><strong>因为半边通常是成对分配的(至少在没有边界的网格中是这样)，许多实现都可以不使用成对指针。例如，在基于数组索引的实现中(如下图所示)，数组可以被安排为偶数的边i总是与边i + 1配对，奇数的边j总是与边j−1配对。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131436.png" class="" title="image-20211001131436">

<p>存储在数组中的半边网格结构的一个例子。</p>
<p><strong>除了本章所展示的简单遍历算法，这三种网格拓扑结构都可以支持各种“网格手术”操作，如分裂或折叠顶点、交换边、添加或删除三角形等。</strong></p>
<h2 id="Scene-Graphs-场景图形"><a href="#Scene-Graphs-场景图形" class="headerlink" title="Scene Graphs 场景图形"></a>Scene Graphs 场景图形</h2><p><strong>三角形网格管理构成场景中的对象的三角形集合，但图形应用程序中的另一个普遍问题是将对象安排在所需的位置。正如我们在第6章所看到的，这是通过转换完成的，但是复杂的场景可以包含大量的转换，并且组织好它们会使场景更容易操作。大多数场景都有一个层次结构，并且使用场景图可以根据这个层次结构来管理转换。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100427.png" class="" title="image-20211002100427">

<p>一个铰链的钟摆。左边是“局部”坐标中的两部分。底部件的铰链在b点，底部件的附件在其局部原点。装配对象的自由度为上铰链的角度(θ，φ)和位置p。</p>
<p><strong>为了激发场景图数据结构，我们将使用如上图所示的铰链摆。考虑一下我们怎样画钟摆的上面部分:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100624.png" class="" title="image-20211002100624">

<p><strong>底部更复杂，但我们可以利用这个事实，在局部坐标系中，它位于上摆的底部b点。首先，我们旋转下摆，使其相对于初始位置的角度为φ。然后，我们移动它，使它的顶部铰链在b点，现在它在上摆的局部坐标中的适当位置，然后它可以沿着那个坐标系移动。下摆的复合变换为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100702.png" class="" title="image-20211002100702">

<p><strong>因此，我们看到，下摆不仅生活在它自己的局部坐标系中，而且这个坐标系本身也随着上摆的坐标系运动。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100718.png" class="" title="image-20211002100718">

<p>上图铰链摆的场景图。</p>
<p><strong>我们可以在数据结构中对摆进行编码，使这些坐标系统问题的管理更容易，如上图所示。适用于一个对象的合适矩阵就是链中所有矩阵的乘积指向数据结构根的对象。例如，考虑一个轮渡模型，该轮渡有一辆可以在轮渡甲板上自由移动的汽车，每个车轮都相对于汽车移动，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100844.png" class="" title="image-20211002100844">

<p>渡轮，渡轮上的汽车，还有汽车(仅显示两辆)存储在一个场景图中。</p>
<p><strong>和钟摆一样，每个物体都应该通过从根到物体的路径上的矩阵乘积进行变换:</strong></p>
<p>​    <strong>•利用M0进行变换；</strong></p>
<p>​    <strong>•车身变换使用M0M1；</strong></p>
<p>​    <strong>•左轮变换使用M0M1M2；</strong></p>
<p>​    <strong>•左轮变换使用M0M1M3．</strong></p>
<p><strong>一个有效的实现可以使用矩阵堆栈(许多API支持的数据结构)来实现。使用从矩阵乘积右侧添加和删除矩阵的推和弹出操作来操作矩阵堆栈。例如,调用:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101055.png" class="" title="image-20211002101055">

<p><strong>生成活动矩阵M = M0M1M2．随后调用pop()将去掉最后添加的矩阵，以便活动矩阵变为M = M0M1．将矩阵堆栈与场景图的递归遍历相结合，我们得到:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101139.png" class="" title="image-20211002101139">

<p><strong>场景图有许多变体，但都遵循上面的基本思想。</strong></p>
<h2 id="Spatial-Data-Structures-空间数据结构"><a href="#Spatial-Data-Structures-空间数据结构" class="headerlink" title="Spatial Data Structures 空间数据结构"></a>Spatial Data Structures 空间数据结构</h2><p><strong>在许多(如果不是全部)图形应用程序中，快速定位空间特定区域中的几何对象的能力是重要的。光线追踪器需要找到与光线相交的物体;在环境中导航的交互式应用程序需要找到从任何给定视角可见的对象;游戏和物理模拟需要检测物体碰撞的时间和地点。所有这些需求都可以得到支持通过各种空间数据结构来组织空间中的对象，以便有效地查找它们。</strong></p>
<p><strong>在本节中，我们将讨论三种空间数据结构的一般类型。将对象分组成层次结构的结构称为对象划分方案:对象被划分为不相连的组，但这些组最终可能在空间上重叠。将空间划分为不相交区域的结构称为空间划分方案:空间被划分为独立的分区，但一个对象可能必须与多个分区相交。空间划分方案可以是规则的，将空间划分成形状一致的小块;也可以是不规则的，将空间自适应地划分成不规则的小块，小块的地方有更多更小的物体。</strong></p>
<p><strong>在讨论这些结构时，我们将使用光线追踪作为主要动机，尽管它们也可以用于视图剔除或碰撞检测。在第4章中，所有对象在检查交叉路口时被循环。对于N个对象，这是一个O(N)线性搜索，因此在大型场景中很慢。与大多数搜索问题一样，只要我们能够创建有序的数据结构作为预处理，就可以使用“分治”技术在亚线性时间内计算出射线与目标的交集。有很多方法可以做到这一点。</strong></p>
<p><strong>本节将详细讨论其中的三种技术:包围体积层次(Rubin &amp; Whitted, 1980;Whitted,1980;Goldsmith &amp; Salmon, 1987)，统一空间划分(Cleary, wyill, Birtwistle， &amp; Vatti, 1983; Fujimoto, Tanaka, &amp; Iwata, 1986; Amanatides &amp; Woo, 1987)和二进制空间分区(Glassner, 1984; Jansen, 1986; Havran, 2000)。下图显示了前两种策略的示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101447.png" class="" title="image-20211002101447">

<p>左:空间的统一划分。右:自适应边界框层次结构。</p>
<h3 id="Bounding-Boxes-边界框"><a href="#Bounding-Boxes-边界框" class="headerlink" title="Bounding Boxes 边界框"></a>Bounding Boxes 边界框</h3><p><strong>在大多数交加速方案中，一个关键的操作是计算带有边界框的射线的交(下图)。这与传统的交叉测试不同，因为我们不需要知道光线击中盒子的位置;我们只需要知道它是否击中了盒子。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101833.png" class="" title="image-20211002101833">

<p>如果它击中了边界框，射线只检测交点。</p>
<p><strong>为了构建射线盒相交的算法，我们首先考虑一个方向向量具有正x和y分量的2D射线。我们可以把它推广到任意的3D射线。2D边界框由两条水平线和两条垂直线定义:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101954.png" class="" title="image-20211002101954">

<p><strong>这些直线所限定的点可以用区间表示法来描述:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102004.png" class="" title="image-20211002102004">

<p><strong>如下图所示，交集测试可以用这些间隔来划分。首先，我们计算射线在x = xmin处的射线参数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102018.png" class="" title="image-20211002102018">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102218.png" class="" title="image-20211002102218">

<p>射线在x∈[x]区间内[xmin*, x*max]对于其参数空间t∈[t]中的某个区间[txmin,txmax］．对于y区间也存在类似的区间。如果射线同时在x和y区间，那么它与方框相交，即两个一维区间的交集不是空的。</p>
<p><strong>然后对t进行类似的计算txmax,tymin, tymax．当且仅当区间[txmin,txmax]和[tymin,tymax)重叠,即它们的交集是非空的。在伪代码中，这个算法是:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102450.png" class="" title="image-20211002102450">

<p><strong>if语句可能看起来不明显。要理解它的逻辑，请注意，如果第一个区间完全在第二个区间的右边或左边，那么就没有重叠。</strong></p>
<p><strong>我们首先要处理的是xd或yd是负的。如果xd 是负的，那么射线在到达xmin点之前就会击中xmax ．因此，计算txmin 和txmax 扩展:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102620.png" class="" title="image-20211002102620">

<p><strong>对于y情况，必须进行类似的代码扩展。一个主要的问题是，水平和垂直射线的yd和xd值分别为零。这将导致除以0，这可能是一个问题。然而，在直接解决这个问题之前，我们检查IEEE浮点计算是否为我们优雅地处理了这些情况。回想一下第1.5节中的除零规则:任何正实数a，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102734.png" class="" title="image-20211002102734">

<p><strong>考虑垂直射线的情况，xd = 0 且 yd&gt; 0。然后我们可以计算</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102743.png" class="" title="image-20211002102743">

<p><strong>有三种可能性:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102753.png" class="" title="image-20211002102753">

<p><strong>对于我们的第一个案例</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102804.png" class="" title="image-20211002102804">

<p><strong>这就得到了区间(txmin,txmin) =(∞，∞)。这个区间不会与任何区间重叠，因此不会出现预期的命中。对于第二个例子，我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102926.png" class="" title="image-20211002102926">

<p><strong>这就得到了区间(txmin,txmin) =(−∞，∞)，它将与所有的区间重叠，因此将产生预期的命中。第三种情况导致的区间(−∞，−∞)不产生预期的命中。因为这些案例可以按照预期工作，所以我们不需要对它们进行特别检查。通常情况下，IEEE浮点是我们的约定。然而，这种方法仍然存在一个问题。</strong></p>
<p><strong>考虑以下代码段:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102937.png" class="" title="image-20211002102937">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102946.png" class="" title="image-20211002102946">

<p><strong>当xd =−0。这可以通过检验xd的倒数来克服(A. Williams, Barrus, Morley， &amp; Shirley, 2005):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102956.png" class="" title="image-20211002102956">

<h3 id="Hierarchical-Bounding-Boxes-层次包围框"><a href="#Hierarchical-Bounding-Boxes-层次包围框" class="headerlink" title="Hierarchical Bounding Boxes 层次包围框"></a>Hierarchical Bounding Boxes 层次包围框</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103506.png" class="" title="image-20211002103506">

<p>2D射线e + t d与2D射线进行测试边界框。</p>
<p><strong>层次包围盒的基本思想可以通过在所有对象周围放置一个轴向3D包围盒的常见策略来理解，如上图所示。击中边界框的射线实际上比强力搜索的计算成本更高，因为测试与框的交集不是免费的。不过，错过的射线盒比暴力搜索便宜。这种包围盒可以通过将对象集划分为一个盒，并在每个分区周围放置一个盒来分层，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103515.png" class="" title="image-20211002103515">

<p>包围框可以被嵌套在模型的子集周围创建框。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103706.png" class="" title="image-20211002103706">

<p>灰色方框是一个指向三个灰色的球体的树节点，而厚厚的黑盒子指向三个黑色的球体。注意，不是所有被方框包围的球体都被相应的树节点指向。</p>
<p><strong>上图中所示的层次结构的数据结构可能是一个树根上有一个大边框的树，两个较小的边框作为左右子树。这些三角形依次指向三个三角形。射线与这个硬编码树的交点是:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103900.png" class="" title="image-20211002103900">

<p><strong>与此算法相关的一些观察是，在两个子树之间没有几何顺序，没有理由射线可能不会击中两个子树。事实上，这两棵子树没有理由不重叠。</strong></p>
<p><strong>这种数据层次结构的一个关键点是，一个框保证绑定层次结构中它下面的所有对象，但它们不保证包含空间上与它重叠的所有对象，如上图所示。这使得这种几何搜索比严格有序的一维数据的传统二分搜索稍微复杂一些。读者可能会注意到有几种可能的优化。我们推迟优化，直到我们有一个完整的层次算法。</strong></p>
<p><strong>如果我们将树限制为二进制，并要求树中的每个节点都有一个边界框，那么这个遍历代码自然会扩展。此外，假设所有节点要么是树中的叶子，包含一个原语，要么是它们包含一棵或两棵子树。</strong></p>
<p><strong>bvh-node类应该是surface类型的，所以它应该实现surface::hit。它包含的数据应该是简单的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103956.png" class="" title="image-20211002103956">

<p><strong>遍历代码然后可以以面向对象的风格递归地调用</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104016.png" class="" title="image-20211002104016">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104027.png" class="" title="image-20211002104027">

<p><strong>注意，因为左节点和右节点都指向曲面而不是bvh-node，所以我们可以让虚函数来区分内部节点和叶节点;将调用适当的hit函数。注意，如果正确构建了树，我们可以消除left为NULL的检查。如果我们想要消除对右是否为NULL的检查，可以用多余的左指针替换NULL右指针。这最终将检查两次左侧，但将消除整个树中的检查。这是否值得，将取决于树木构造的细节。</strong></p>
<p><strong>有许多方法可以为包围卷层次结构构建树。这样做很方便，可以使树为二叉树，大致平衡，并且兄弟子树的方框不会有太多重叠。实现这一点的一个启发式方法是，在将曲面划分为两个子列表之前，先沿着一个轴对它们进行排序。如果坐标轴定义为一个x = 0, y = 1, z = 2的整数，我们有:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104126.png" class="" title="image-20211002104126">

<p><strong>通过每次仔细选择AXIS，可以提高树的质量。一种方法是选择坐标轴，使两棵子树的包围盒的体积之和最小化。与通过轴旋转相比，这种变化对同位素分布的小物体构成的场景没有什么不同，但它可能对表现不佳的场景有显著帮助场景。这段代码也可以通过只进行分区而不是进行完整排序来提高效率。</strong></p>
<p><strong>另一种可能更好的构建树的方法是让子树包含大约相同数量的空间，而不是相同数量的对象。为此，我们根据空间对列表进行分区:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104158.png" class="" title="image-20211002104158">

<p><strong>尽管这会导致不平衡的树，但它允许很容易地遍历空白空间，而且构建成本更低，因为分区比排序成本更低。</strong></p>
<h3 id="Uniform-Spatial-Subdivision-统一空间划分"><a href="#Uniform-Spatial-Subdivision-统一空间划分" class="headerlink" title="Uniform Spatial Subdivision 统一空间划分"></a>Uniform Spatial Subdivision 统一空间划分</h3><p><strong>另一个减少交集测试的策略是划分空间。这从根本上不同于分层边界体积划分对象:</strong></p>
<p>​    <strong>•在层次包围体中，每个对象都属于两个兄弟节点中的一个，而空间中的一个点可能在两个兄弟节点中。</strong></p>
<p>​    <strong>•在空间细分中，空间中的每个点都只属于一个节点，而对象可能属于多个节点。</strong></p>
<p><strong>在均匀的空间细分中，场景被分割成轴向框。这些盒子的大小都是一样的，尽管它们不一定是立方体。射线穿过这些盒子，如下图所示。当命中一个对象时，遍历结束。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104424.png" class="" title="image-20211002104424">

<p>在均匀空间细分中，光线通过单元格向前追踪，直到其中一个单元格中的物体被击中。在本例中，只检查着色单元格中的对象。</p>
<p><strong>网格本身应该是surface的一个子类，并且应该实现为一个指向surface的指针的3D数组。对于空单元格，这些指针是NULL。对于只有一个对象的单元格，指针指向该对象。对于具有多个对象的单元格，指针可以指向列表、另一个网格或另一个数据结构，如边界卷层次结构。</strong></p>
<p><strong>这个遍历是以增量方式完成的。这种规律性来自于光线击中每一组平行平面的方式，如下图所示。要了解这个遍历是如何工作的，首先考虑二维情况，其中射线方向有正的x和y分量，并且从网格外开始。假设网格以点(xmin，ymin)和(xmax，ymax)．网格有nx×ny。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104636.png" class="" title="image-20211002104636">

<p>虽然单元格撞击的模式似乎是不规则的(左)，但撞击是平行的平面非常均匀。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104835.png" class="" title="image-20211002104835">

<p>来决定我们是正确前进还是向上，我们跟踪与单元格的下一个垂直和水平边界的交点。</p>
<p><strong>我们的第一项任务是求射线e + td击中的第一个单元格的索引(i, j)。然后，我们需要以适当的顺序遍历单元格。该算法的关键部分是找到初始单元格(i, j)，并决定是增加i还是j(上图)。注意，当我们检查与单元格中的对象的交集时，我们将t的范围限制在单元格内(下图)。大多数实现都是将指针指向表面的3D数组。为了改进遍历的局部性，可以像12.5节中讨论的那样平铺数组。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104845.png" class="" title="image-20211002104845">

<p>只有在单元格内的点击应该被重新移植。否则，上述情况将导致我们报告击中对象b而不是对象a。</p>
<h3 id="Axis-Aligned-Binary-Space-Partitioning-轴对齐二进制空间分区"><a href="#Axis-Aligned-Binary-Space-Partitioning-轴对齐二进制空间分区" class="headerlink" title="Axis-Aligned Binary Space Partitioning 轴对齐二进制空间分区"></a>Axis-Aligned Binary Space Partitioning 轴对齐二进制空间分区</h3><p><strong>我们还可以在分层数据结构中对空间进行分区，例如二叉空间分区树(BSP树)。这类似于12.4节中用于可见性排序的BSP树，但最常见的是使用轴对齐的，而不是多边形对齐的，用于射线相交的切割平面。</strong></p>
<p><strong>这个结构中的一个节点包含一个切割平面和一个左右子树。每一个子树包含切割平面一侧的所有对象。通过平面的对象存储在两个子树中。假设切割平面在x = D处平行于yz平面，则节点类为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105430.png" class="" title="image-20211002105430">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105538.png" class="" title="image-20211002105538">

<p>这四种情况下射线是如何重新排列到BSP切割平面x = D的。</p>
<p><strong>我们稍后将其推广到y和z切割平面。然后可以以面向对象的方式递归地调用交集代码。代码考虑上图中所示的四种情况。对于我们的目的，这些射线的原点是参数t0处的一个点：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105439.png" class="" title="image-20211002105439">

<p><strong>这四种情况是:</strong></p>
<p>​    <strong>1.射线只与左子树相互作用，我们不需要测试它是否与切割平面相交。它发生在xp &lt; D和xb &lt; 0。</strong></p>
<p>​    <strong>2.射线针对左子树进行测试，如果没有命中，则针对右子树进行测试。我们需要找到x = D处的射线参数，这样我们就可以确保只测试子树内的交点。这种情况发生在xp &lt; D和xb &gt; 0。</strong></p>
<p>​    <strong>3.这种情况类似于情况1，并且发生在xp &gt; D和xb &gt; 0。</strong></p>
<p>​    <strong>4.这种情况类似于第二种情况，发生在xp &gt; D和xb &lt; 0。</strong></p>
<p><strong>处理这些情况的遍历代码依次为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105759.png" class="" title="image-20211002105759">

<p><strong>这是非常干净的代码。然而，为了让它开始，我们需要点击一些包含边界框的根对象，这样我们就可以初始化遍历t0 和t1．我们必须解决的一个问题是，切割平面可能沿着任何轴。我们可以向bsp-node类添加一个整数索引轴。如果允许对点使用索引操作符，将导致对上面的代码进行一些简单的修改，例如:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105821.png" class="" title="image-20211002105821">

<p><strong>将成为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105830.png" class="" title="image-20211002105830">

<p><strong>这将导致一些额外的数组索引，但不会生成更多的分支。</strong></p>
<p><strong>虽然处理单个bsp-node比处理bvh-node要快，但单个曲面可能存在于不止一个子树中，这意味着有更多的节点，并且可能会有更高的内存使用。构建树的“好”程度决定了哪种更快。构建树类似于构建BVH树。我们可以选择轴在一个循环中分裂，我们可以每次分裂成两半，或者我们可以尝试更复杂的分裂方式。</strong></p>
<h2 id="BSP-Trees-for-Visibility-可视性二叉树"><a href="#BSP-Trees-for-Visibility-可视性二叉树" class="headerlink" title="BSP Trees for Visibility 可视性二叉树"></a>BSP Trees for Visibility 可视性二叉树</h2><p><strong>另一个可以使用空间数据结构的几何问题是在一个视角变化的场景中确定对象的可见性顺序。</strong></p>
<p><strong>如果我们要从不同的角度制作由平面多边形组成的固定场景的许多图像——就像游戏等应用的情况一样——我们可以使用与前一节讨论的射线相交方法密切相关的二元空间划分方案。不同之处在于，对于可见性排序，我们使用非轴对齐的分裂平面，这样平面就可以与多边形重合。这就产生了一种被称为BSP树的算法，它可以从前面到后面对曲面进行排序。BSP树的关键在于它使用预处理来创建对任何视点都有用的数据结构。因此，当视点发生变化时，将使用相同的数据结构而不进行更改。</strong></p>
<h3 id="Overview-of-BSP-Tree-Algorithm-BSP树算法概述"><a href="#Overview-of-BSP-Tree-Algorithm-BSP树算法概述" class="headerlink" title="Overview of BSP Tree Algorithm BSP树算法概述"></a>Overview of BSP Tree Algorithm BSP树算法概述</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003101858.png" class="" title="image-20211003101858">

<p>画家的算法从一张空白图像开始，然后从前后依次绘制一个物体，绘制已经存在的物体。这将自动消除隐藏的表面。</p>
<p><strong>BSP树算法是画家算法的一个例子。画家的算法从后到前绘制每个对象，每个新的多边形可能会覆盖之前的多边形，如上图所示。它可以实现如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003101817.png" class="" title="image-20211003101817">

<p><strong>第一步(排序)的问题是，多个对象的相对顺序并不总是定义得很好，即使每一对对象的顺序是这样的。这个问题如图12.34所示，三个三角形组成一个循环。</strong></p>
<p><strong>BSP树算法适用于任何由多边形组成的场景，其中没有多边形穿过由其他多边形定义的平面。然后通过预处理步骤放宽这个限制。在接下来的讨论中，我们假设三角形是唯一的原始图形，但我们可以将其扩展到任意多边形。</strong></p>
<p><strong>BSP树的基本思想可以用两个三角形T1 和T2来说明．我们首先回顾(见2.5.3节)包含T1的平面的隐式平面方程f1(p) = 0。隐平面的关键性质我们想要利用的是对于所有点p+ 在平面的一边，f1(p+) &gt; 0;对于平面另一端的所有点p-，f1(p-)&lt; 0。利用这个性质，我们可以求出平面T2在哪一边。同样，这假设了T2的所有三个顶点 都在平面的同一侧。讨论,假设T2 在f1(p) &lt; 0面。然后我们可以画出T1 和T2 对于任意点e，按照正确的顺序:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102227.png" class="" title="image-20211003102227">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102512.png" class="" title="image-20211003102512">

<p>如果周期性的前后颠倒，就会发生循环顺序不可能针对一个特定的眼睛位置。</p>
<p><strong>这样做的原因是如果T2 和e在包含T1的平面的同一侧T2 是没有办法的完全或部分被T1 可以看到从e出发，所以画T1 是安全的第一。如果e和T2 在包含T1的平面的相对两边,那么T2 不能完全或部分阻塞T1，相反的绘制顺序是安全的(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102527.png" class="" title="image-20211003102527">

<p>当e和T<em>2</em> 在包含T的平面的相对两边1，那就安全了首先画T2 然后T1。如果e和T<em>2</em> 在平面的同一侧，那么先T1 然后T<em>2</em>．这是BSP树算法的核心思想。</p>
<p><strong>这种观察可以推广到许多物体，只要它们没有张成由T1定义的平面．如果我们使用带有T1 的二叉树数据结构作为根，树的负分支包含所有顶点为fi(p) &lt; 0的三角形，并且树的正分支包含所有顶点为fi(p) &gt; 0的三角形。我们可以按以下顺序画:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102808.png" class="" title="image-20211003102808">

<p><strong>这段代码的优点是它适用于任何视点e，所以树可以被预先计算。注意，如果每个子树本身是一棵树，其中根三角形将其他三角形相对于包含它的平面分成两组，代码将按原样工作。通过终止更高一级的递归调用，可以稍微提高效率，但代码仍然很简单。一个树如下图所示。如2.5.5节所述，平面上包含三个非共线点a、b、c的点p的隐式方程为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102953.png" class="" title="image-20211003102953">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102944.png" class="" title="image-20211003102944">

<p>三个三角形和一个有效的BSP树。“肯定”和“否定”分别根据左右子树位置进行编码。</p>
<p><strong>这种形式的隐式方程的(A, B, C, D)存储起来更快</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103003.png" class="" title="image-20211003103003">

<p><strong>方程上式和上上式是等价的，当你回想一下隐式方程的梯度是三角形的法线时，这一点就很清楚了。方程上式的梯度是n = (A, B, C)这就是法向量</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103013.png" class="" title="image-20211003103013">

<p><strong>我们可以通过代入平面上的任意点来求D，例如a:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103022.png" class="" title="image-20211003103022">

<p><strong>这表明了以下形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103034.png" class="" title="image-20211003103034">

<p><strong>如果你记得n是用叉乘来计算的，它和最初的式子是一样的。使用哪种形式的平面方程以及只存储顶点(n和顶点)还是只存储n, D和顶点，这可能是一个品味问题——一个经典的时间存储折衷方案，最好通过剖面来解决。对于调试，使用最初的式子可能是最好的。</strong></p>
<p><strong>一般来说，阻碍上述代码工作的唯一问题是，不能保证一个三角形可以在平面的一边或另一边被唯一分类。它可以在平面的一边有两个顶点，在另一边有第三个顶点。或者它可以在平面上有顶点。这是通过使用平面将三角形分割成更小的三角形来实现的。</strong></p>
<h3 id="Building-the-Tree-构建树"><a href="#Building-the-Tree-构建树" class="headerlink" title="Building the Tree 构建树"></a>Building the Tree 构建树</h3><p><strong>如果数据集中没有三角形交叉，那么所有三角形都在其他三角形的一边，那么可以使用上面的代码遍历的BSP树可以使用以下算法构建:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103612.png" class="" title="image-20211003103612">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103649.png" class="" title="image-20211003103649">

<p>当一个三角形跨越一个平面时，就会有一边是一个顶点，另一边是两个顶点。</p>
<p><strong>我们需要修复的唯一一件事是三角形穿过分割平面的情况，如上图所示。为了简单起见，假设三角形在平面的一边有顶点a和顶点b，顶点c在另一边。在这种情况下，我们可以找到交点A和B，并将三角形切成三个新的带顶点的三角形</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103743.png" class="" title="image-20211003103743">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103756.png" class="" title="image-20211003103756">

<p>当一个三角形被切割时，我们把它分成三个三角形，没有一个跨越切割平面。</p>
<p><strong>如上图所示。这个顶点的顺序是很重要的，这样法线的方向就会和原来的三角形保持一致。如果我们假设f(c) &lt; 0，下面的代码可以将这三个三角形加到树中，假设正子树和负子树都不是空的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103806.png" class="" title="image-20211003103806">

<p><strong>当一个顶点非常接近分裂平面时，会出现一个会困扰简单实现的精度问题。例如,如果我们有两个顶点的一侧分裂面,另一顶点只是一个非常小的距离在另一边,我们将创建一个新的三角形几乎和旧的一样,是一片的一个三角形,三角形的大小几乎为零。最好将其作为一种特殊情况来检测，而不是分成三个新的三角形。人们可能认为这种情况很少见，但因为许多模型都有共享顶点的镶嵌平面和三角形，所以它经常发生，因此必须小心处理。以下是一些简单的操作:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103820.png" class="" title="image-20211003103820">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103829.png" class="" title="image-20211003103829">

<p><strong>它取平面内f值为正或负的任意顶点。常数是由用户选择的一个小的正实值。上面的技术是一个罕见的例子，在这种情况下，测试浮点数相等是有用的，并且有效，因为零值是设置的，而不是计算的。用计算过的浮点值进行相等比较几乎是不可取的，但我们没有这样做。</strong></p>
<h3 id="Cutting-Triangles-裁剪三角形"><a href="#Cutting-Triangles-裁剪三角形" class="headerlink" title="Cutting Triangles 裁剪三角形"></a>Cutting Triangles 裁剪三角形</h3><p><strong>最后一种情况“将三角形切成三个三角形，并在每边相加”的细节很简单，但也很乏味。我们应该利用BSP树的构建作为一个前处理，最高的效率不是关键。相反，我们应该尝试拥有一个简洁的代码。一个很好的技巧是，通过确保c在平面的一边，而其他两个顶点在另一边，将多种情况合并到一种情况中。这很容易通过互换来实现。在最后的else语句中填充细节(为了简单起见，假设子树是非空的)会得到:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104215.png" class="" title="image-20211003104215">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104226.png" class="" title="image-20211003104226">

<p><strong>这段代码利用了这样一个事实:如果a和b有相同的符号，那么它们的乘积就是正的——因此，第一个if语句。如果交换顶点，我们必须做两次交换以保持顶点的逆时针顺序。注意，可能恰好有一个顶点位于平面上，在这种情况下，上面的代码可以工作，但生成的三角形中的一个面积为零。我们可以通过忽略这种可能性来解决这个问题，但这并不危险，因为栅格化代码必须处理屏幕空间中的零面积三角形。侧面的三角形)。您还可以添加一个不向树中添加零面积三角形的检查。最后，您可以在一个特殊的情况下，当fa, fb和fc中恰好有一个是零时，将三角形切成两个三角形。</strong></p>
<p><strong>为了计算A和B，需要一条线段和隐式平面交。例如，连接a和c的参数线为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104236.png" class="" title="image-20211003104236">

<p><strong>将p(t)代入平面方程，求出与平面n·p + D = 0的交点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104244.png" class="" title="image-20211003104244">

<p><strong>求出t:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104253.png" class="" title="image-20211003104253">

<p><strong>称这个解为t<em>A</em>，我们可以写出A的表达式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104301.png" class="" title="image-20211003104301">

<p><strong>一个类似的计算将得到B。</strong></p>
<h3 id="Optimizing-the-Tree-优化树"><a href="#Optimizing-the-Tree-优化树" class="headerlink" title="Optimizing the Tree 优化树"></a>Optimizing the Tree 优化树</h3><p><strong>与树遍历相比，树创建的效率不那么重要，因为它是一个预处理过程。遍历BSP树所花费的时间与树中节点的数量成正比。(这棵树是否平衡并不重要。)每个三角形都有一个节点，包括由于分裂而创建的三角形。这个数字取决于三角形加到树中的顺序。例如，在下图中，如果T1 是根，树中就会有两个节点，但如果T2 是根结点，就会有更多节点，因为T1 将分裂。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104605.png" class="" title="image-20211003104605">

<p>使用T1 因为BSP树的根会重构结果是一个有两个节点的树。使用T2 因为树根需要修剪，这样树就会变大。</p>
<p><strong>很难找到要加到树中的“最佳”三角形顺序。对于N个三角形，有N个!可能的顺序。所以尝试所有的顺序通常是不可行的。或者，可以从随机的排列集合中尝试一些预定数量的排序，并且最好的一个可以保留到最后的树中。</strong></p>
<p><strong>上面描述的分割算法将一个三角形分割成三个三角形。将一个三角形分割成一个三角形和一个凸四边形可能更有效。如果所有的输入模型都只有三角形，那么这样做可能不值得，但是很容易支持适应任意多边形的实现。</strong></p>
<h2 id="Tiling-Multidimensional-Arrays-平铺多维数组"><a href="#Tiling-Multidimensional-Arrays-平铺多维数组" class="headerlink" title="Tiling Multidimensional Arrays 平铺多维数组"></a>Tiling Multidimensional Arrays 平铺多维数组</h2><p><strong>有效利用内存层次结构是现代体系结构算法设计的关键。通过平铺(有时也称为砖砌)来确保多维数组具有“良好”的数据安排。传统的2D数组存储为带有索引机制的1D数组;例如，Nx ×Ny 数组存储在长度为NxNy 的一维数组中和2D索引(x, y)(从(0,0)到(Nx −1,Ny −1))对应1D索引(从0到NxNy −1)使用公式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104850.png" class="" title="image-20211003104850">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104901.png" class="" title="image-20211003104901">

<p>未填充2D数组的内存布局Nx = 4 且 Ny = 3。</p>
<p><strong>上图显示了内存布局的示例。这种布局的一个问题是，尽管在同一行中的两个相邻数组元素在内存中是相邻的，但在同一列中的两个相邻元素将被Nx分开元素在内存中。这可能会导致Nx的内存局部性较差．这个问题的标准解决方案是使用贴图来制造内存行和列的局部性更相等。下图显示了一个使用2 × 2贴图的例子。下一节将讨论索引这样一个数组的细节。在此之后将介绍一个更复杂的例子，即在3D阵列上使用两个级别的平铺。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105125.png" class="" title="image-20211003105125">

<p>二维平铺数组的内存布局Nx = 4和Ny = 3和2 × 2平铺。注意，数组顶部的填充是需要的，因为Ny 不是贴图大小2的倍数。</p>
<p><strong>一个关键的问题是瓷砖的大小。实际上，它们应该与机器上的内存单元大小类似。例如，如果我们在一台具有128字节高速缓存线的机器上使用16位(2字节)数据值，那么8 × 8块瓷砖恰好适合高速缓存线。但是，如果使用32位浮点数，即能够将32个元素放入一条缓存线中，那么5 × 5的tiles就有点小了，6 × 6的tiles就有点大了。由于还存在较大的内存单元(如页面)，具有类似逻辑的分层平铺可能很有用。</strong></p>
<h3 id="One-Level-Tiling-for-2D-Arrays-二维数组的一级平铺"><a href="#One-Level-Tiling-for-2D-Arrays-二维数组的一级平铺" class="headerlink" title="One-Level Tiling for 2D Arrays 二维数组的一级平铺"></a>One-Level Tiling for 2D Arrays 二维数组的一级平铺</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105648.png" class="" title="image-20211003105648">

<p>由Bx ×By 每个大小为n × n的格子。</p>
<p><strong>如果我们假设一个Nx ×Ny 数组分解为正方形n×n贴图(上图)，则所需贴图的数量为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105658.png" class="" title="image-20211003105658">

<p><strong>这里，我们假设n除以Nx 和Ny 完全正确。如果不是这样，则应该填充数组。例如，如果Nx = 15, n = 4，然后Nx 应该改为16。为了计算出这样一个数组的索引公式，我们首先找到瓷砖索引(bx,by)，给出贴图的行/列(贴图本身构成一个2D数组):</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105709.png" class="" title="image-20211003105709">

<p><strong>其中÷是整数除法，例如:12 ÷ 5 = 2。如果我们按照图上上上所示的行排列贴图，那么贴图的第一个元素的索引(bx,by)是</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105720.png" class="" title="image-20211003105720">

<p><strong>该贴图中的内存被安排成传统的2D数组，如图上上所示。部分偏移量(x′， y′)瓷砖的内部</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110119.png" class="" title="image-20211003110119">

<p><strong>其中mod是余数运算符，例如，12 mod 5 = 2。因此，平铺内部的偏移量是</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110129.png" class="" title="image-20211003110129">

<p><strong>因此，在N中找到1D索引元素(x, y)的完整公式Nx ×Ny数组的平铺n × n块为</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110139.png" class="" title="image-20211003110139">

<p><strong>这个表达式包含许多整数乘法、除法和模运算，这些运算在某些处理器上开销很大。当n是2的幂时，这些操作可以转换为位移位和按位逻辑操作。然而，如上所述，理想的大小并不总是2的幂。一些乘法运算可以转换为移位/加法运算，但除法和模数运算更成问题。索引可以增量地计算，但这需要跟踪计数器，需要进行大量比较和较差的分支预测性能。</strong><br><strong>然而，有一个简单的解决方案;注意，索引表达式可以写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110321.png" class="" title="image-20211003110321">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110333.png" class="" title="image-20211003110333">

<p><strong>我们汇总Fx 和Fy，并使用x和y查找数据数组中的索引。这些表将分别由Nx 和Ny 组成元素。即使对于非常大的数据集，表的总大小也将适合处理器的主数据缓存。</strong></p>
<h3 id="Example-Two-Level-Tiling-for-3D-Arrays-示例-用于3D数组的二级平铺"><a href="#Example-Two-Level-Tiling-for-3D-Arrays-示例-用于3D数组的二级平铺" class="headerlink" title="Example: Two-Level Tiling for 3D Arrays 示例:用于3D数组的二级平铺"></a>Example: Two-Level Tiling for 3D Arrays 示例:用于3D数组的二级平铺</h3><p><strong>有效的TLB（ lookaside buffer，是虚拟内存系统的一部分。）利用率也成为影响算法性能的关键因素。同样的技术可以用来提高TLB命中率，在3D阵列中创建m × m × m的n × n × n单元块。例如，一个40 × 20 × 19的体积可以分解成4 × 2 × 2的大砖块，由2 × 2 × 2的砖块和5 × 5 × 5的单元组成。这对应于m = 2和n = 5。因为19不能被mn = 10分解，所以需要一层填充。经验上有用的大小是m = 5对于16位数据集和m = 6对于浮点数据集。</strong></p>
<p><strong>可以使用表达式计算任意(x, y, z)三倍的数据数组的结果索引</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110729.png" class="" title="image-20211003110729">

<p><strong>其中Nx,Ny 和Nz 分别为数据集的大小。</strong></p>
<p><strong>注意，在更简单的二维单级情况下，这个表达式可以写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110739.png" class="" title="image-20211003110739">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110749.png" class="" title="image-20211003110749">

<h1 id="13-More-Ray-Tracing-更多的光线追踪"><a href="#13-More-Ray-Tracing-更多的光线追踪" class="headerlink" title="13 More Ray Tracing 更多的光线追踪"></a>13 More Ray Tracing 更多的光线追踪</h1><p><strong>射线追踪器是构建各种高级渲染效果的一个很好的基板。许多效果需要大量的工作来适应对象顺序栅格化框架，包括基础的阴影和反射已经在第4章中介绍，在射线追踪器中是简单和优雅的。在本章中，我们将讨论一些更炫酷的技术，这些技术可以用于光线追踪更广泛的场景，并包括更广泛的效果。一些扩展允许更通用的几何:实例化和构造实体几何(CSG)是使模型更复杂的两种方法，并将复杂性添加到程序中。其他扩展增加了我们可以处理的材料范围:通过透明材料的折射，如玻璃和水，和各种表面上的光泽反射是许多场景中的现实主义必不可少的。</strong></p>
<p><strong>本章还讨论了分布的一般框架射线跟踪(做饭,波特,和木匠,1984),一个强大的扩展基本的多维随机射线的射线跟踪的想法通过每个像素在图像产生平滑的图像边缘和简单和优雅(如果缓慢)产生广泛的影响从软阴影相机景深效果。</strong></p>
<p><strong>优雅的光线跟踪的代价是计算时间:大多数这些扩展将跟踪任何非平凡场景的大量光线。正因为如此，使用第12章中描述的方法来加速光线追踪是至关重要的。</strong></p>
<h2 id="Transparency-and-Refraction-透明度和折射"><a href="#Transparency-and-Refraction-透明度和折射" class="headerlink" title="Transparency and Refraction 透明度和折射"></a>Transparency and Refraction 透明度和折射</h2><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004145831.png" class="" title="image-20211004145831">

<p>斯涅尔定律描述了角度φ如何依赖于角度θ以及物体和周围介质的折射率。</p>
<p><strong>在第四章中，我们讨论了使用递归光线追踪来计算镜面反射。另一种类型的镜面物体是介质——一种能够折射光线的透明材料。钻石、玻璃、水和空气都是电介质。电介质也能滤光;有些玻璃滤掉的红光和蓝光多于绿光，所以玻璃呈现出绿色。当光线从折射率为n的介质进入折射率为nt的介质时,当一些光被透射时，它就会弯曲。这是nt &gt; n的表达式见上图。斯涅尔定律告诉我们</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004145936.png" class="" title="image-20211004145936">

<p><strong>计算两个向量夹角的正弦值通常不像计算余弦值那么方便，余弦值是单位向量的简单点积，就像这里。用三角恒等式sin²θ + cosθ²θ = 1时，可导出余弦的折射关系:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004145945.png" class="" title="image-20211004145945">

<p><strong>注意，如果n和nt ，则θ和φ也相同，如上图右侧所示。</strong></p>
<p><strong>为了将sin φ和cos φ转换成三维矢量，我们可以在曲面法线平面n和光线方向d上建立一个二维标准正交基。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150156.png" class="" title="image-20211004150156">

<p>向量n和b形成一个二维标准正交基平行于传输向量t。</p>
<p><strong>从上图可以看出，n和b构成了折射面的标准正交基。根据定义，我们可以描述变换的方向ray, t，根据这个基础:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150314.png" class="" title="image-20211004150314">

<p><strong>因为我们可以用相同的基底来描述d，而且d是已知的，所以我们可以解出b:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150413.png" class="" title="image-20211004150413">

<p><strong>这意味着我们可以用已知的变量解出t:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150422.png" class="" title="image-20211004150422">

<p><strong>注意，不管n和n是哪个，这个方程都成立<em>t</em> 比较大。一个直接的问题是，“如果平方根下的数字是负数，你该怎么办?”“在这种情况下，没有折射光线，所有的能量都被反射了。这被称为全反射，它是玻璃物体丰富外观的主要原因。</strong></p>
<p><strong>根据菲涅耳方程，介质的反射率随入射角的变化而变化。实现近似菲涅耳方程的一个好方法是使用Schlick近似(Schlick, 1994a)，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150506.png" class="" title="image-20211004150506">

<p><strong>在R0 为法向量入射时的反射率:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150515.png" class="" title="image-20211004150515">

<p><strong>注意，上面的cos θ项总是针对空气中的夹角(相对于法线的内角和外角较大)。</strong></p>
<p><strong>对于均匀的杂质，如在典型的有色玻璃中发现的，根据比尔定律，携带光线的强度会衰减。当射线穿过介质时，根据dI =−CI dx，它的强度会降低，其中dx是距离。因此，dI/dx =−CI。我们可以解这个方程，得到指数I = kexp(−Cx)。衰减程度用RGB衰减常数a来描述，a是一单位距离后的衰减量。引入边界条件，我们知道I(0) = I0， I(1) =aI0)。前者意味着I(x) = I0 exp(−Cx)。后者意味着I0a = I0 exp(−C), 所以 −C = ln(a)。因此，最后的公式是</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150713.png" class="" title="image-20211004150713">

<p><strong>式中，I(s)为距离界面s处的光束强度。在实践中，我们通过眼睛进行逆向工程，因为这样的数据很少容易找到。比尔定律的效果可以在下图中看到，玻璃呈现出绿色。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150744.png" class="" title="image-20211004150744">

<p>玻璃的颜色受内部全反射和比尔定律的影响。透射和反射的光量由菲涅耳方程决定。如第23章所述，使用粒子追踪来计算地平面上的复杂照明。</p>
<p><strong>为了在代码中添加透明材质，我们需要一种方法来确定光线什么时候进入一个对象。最简单的方法是假设所有物体都嵌入在空气中，其折射率非常接近1.0，并且表面法线指向“外”(朝向空气)。在这些假设下，射线和电介质的代码段是:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150831.png" class="" title="image-20211004150831">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150841.png" class="" title="image-20211004150841">

<p><strong>上面的代码假设自然对数已经被折叠成常数(ar,ag,ab)．如果有完全的内部反射，则折射函数返回false，否则它将填充参数列表的最后一个参数。</strong></p>
<h2 id="Instancing-实例"><a href="#Instancing-实例" class="headerlink" title="Instancing 实例"></a>Instancing 实例</h2><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004151020.png" class="" title="image-20211004151020">

<p>一个由三个元素组成的圆的实例变换是一个椭圆。</p>
<p><strong>光线追踪的一个优雅的特性是它允许非常自然的实例化。实例化的基本思想是在显示对象之前通过变换矩阵扭曲对象上的所有点。例如,如果我们把单位圆由一个比例因子(2,1)在x和y,分别由45◦,然后旋转方向增加一个单位,结果是一个椭圆的离心率2和长轴沿(x =−y)方向集中在(0,1)(上图)。使这个实体成为“实例”的关键是我们存储了圆和复合变换矩阵。因此，椭圆的显式构造将留在呈现时作为后续操作。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004151219.png" class="" title="image-20211004151219">

<p>这两个空间中的射线相交问题只是彼此的简单变换。物体被指定为一个球体加上矩阵M。光线在变换的(世界)空间中由位置a和方向b指定。</p>
<p><strong>在光线追踪中实例化的优点是我们可以选择要做交集的空间。如果基对象是由一组点组成的，其中一个点是p，那么被变换的对象是由矩阵M变换的一组点组成的，其中示例点被变换为Mp。如果我们有一条射线a + tb，我们想与变换后的物体相交，我们可以用一条反变换的射线与未变换的物体相交(上图)。在未转换的空间中进行计算有两个潜在的优势(即上图右侧):</strong></p>
<p>​    <strong>1.未变换的物体可能有一个更简单的相交例程，例如，一个球体和一个椭球体。</strong></p>
<p>​    <strong>2.许多被转换的对象可以共享同一个未被转换的对象，从而减少存储，例如，汽车的交通堵塞，在这种情况下，单个汽车只是几个基本(未转换的)模型的转换。</strong></p>
<p><strong>如第6.2.2节所述，曲面法向量变换不同。记住这一点并使用上图中所示的概念，我们可以确定射线和矩阵m转换的对象的交集。如果我们创建类型为surface的实例类，我们需要创建一个hit函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004151338.png" class="" title="image-20211004151338">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004151348.png" class="" title="image-20211004151348">

<p><strong>这个函数的一个优点是不需要更改参数rec.t，因为它在两个空间中都是相同的。还要注意，我们不需要计算或存储矩阵M。</strong></p>
<p><strong>这就引出了一个非常重要的问题:射线方向b不能被限制为单位长度的矢量，或者上面的基础结构都不起作用。因此，不将光线方向限制为单位向量是有用的。</strong></p>
<h2 id="Constructive-Solid-Geometry-构建立体几何"><a href="#Constructive-Solid-Geometry-构建立体几何" class="headerlink" title="Constructive Solid Geometry 构建立体几何"></a>Constructive Solid Geometry 构建立体几何</h2><p><strong>射线追踪的一个好处是，任何与3D线相交的几何原语都可以被无缝地添加到射线追踪器中。事实证明，在光线追踪中添加构造立体几何(CSG)也是很简单的(罗斯,1982)。CSG的基本思想是使用集合运算来组合实体形状。这些基本操作如下图所示。这些操作可以看作是设置操作。例如，我们可以考虑C是圆中所有点的集合，S是正方形中所有点的集合。交集操作C∩S是所有同时属于C和S的点的集合。其他操作是类似的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006111721.png" class="" title="image-20211006111721">

<p>基本的CSG操作在2D圆和正方形。</p>
<p><strong>尽管可以直接在模型上执行CSG，但如果只需要一个映像，则不需要显式地更改模型。相反，我们在光线与模型交互时直接执行设置操作。为了使其更自然，我们用一个模型来找到光线的所有交点，而不仅仅是最近的。例如，一条射线a + tb可能在t = 1和t = 2时击中一个球体。在CSG的背景下，我们把它看成是t∈[1,2]在球面内的射线。我们可以为所有曲面计算这些“内部间隔”，并在这些间隔上进行集合操作(回忆第2.1.2节)。如下图所示，命中间隔被处理以表明在差分对象中有两个间隔。t&gt;0的第一个点是射线的交点。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006111925.png" class="" title="image-20211006111925">

<p>间隔被处理以表示射线击中合成物体。</p>
<p><strong>在实践中，CSG交集程序必须维护一个区间列表。当第一个生命值被确定时，材质属性和表面法线与生命值相关联。此外，您必须注意精度问题，因为没有任何东西可以阻止用户使用两个相邻的对象和一个交叉的对象。这可以通过消除厚度低于一定公差的任何间隔来实现。</strong></p>
<h2 id="Distribution-Ray-Tracing-分布光线追踪"><a href="#Distribution-Ray-Tracing-分布光线追踪" class="headerlink" title="Distribution Ray Tracing 分布光线追踪"></a>Distribution Ray Tracing 分布光线追踪</h2><p><strong>对于某些应用来说，光线追踪图像太“干净”了。这种影响可以通过分布射线追踪来缓解(Cook等人，1984)。传统的光线追踪图像看起来很干净，因为一切都很清晰;阴影是完美的锐利，反射没有模糊，一切都在完美的焦点。有时我们希望阴影是柔和的(就像他们在现实生活中一样)，反射是模糊的，就像拉丝金属，图像有不同的焦距，就像在一张大光圈的照片。虽然从基本原理完成这些事情有些复杂(如第23章所述)，但我们可以通过对基本光线追踪算法进行一些相当简单的更改来获得大部分视觉效果。此外，该框架为我们提供了一种相对简单的方法来消除图像的锯齿(回忆第8.3节)。</strong></p>
<h3 id="Antialiasing-抗锯齿"><a href="#Antialiasing-抗锯齿" class="headerlink" title="Antialiasing 抗锯齿"></a>Antialiasing 抗锯齿</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112423.png" class="" title="image-20211006112423">

<p>一个简单的场景，每像素一个样本(左下半部分)和每像素九个样本(右上半部分)。</p>
<p><strong>回想一下，消除图像锯齿的一种简单方法是计算像素区域的平均颜色，而不是中心点的颜色。在光线追踪中，我们的计算原语是计算屏幕上某一点的颜色。如果我们对像素上的这些点进行平均，我们就接近了真实的平均值。如果像素边界的屏幕坐标是[i, i + 1] × [j, j + 1]，那么我们可以替换循环:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112300.png" class="" title="image-20211006112300">

<p><strong>使用在每个像素内的常规n × n样本网格上进行采样的代码:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112311.png" class="" title="image-20211006112311">

<p><strong>这通常被称为常规采样。当n = 4时，一个像素内的16个样本位置如下图所示。注意，这将产生与渲染传统光线跟踪图像相同的答案，每个像素在n处有一个样本nxn×nyn然后平均n × n像素块得到nx ×ny 的图像。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112435.png" class="" title="image-20211006112435">

<p>一个像素有16个常规样本。</p>
<p><strong>在一个像素内以规则模式采集样本的一个潜在问题是，可能会出现规则的伪影，如莫尔图案。如下图所示，通过在每个像素内随机采样，这些伪影可以变成噪声。这通常被称为随机采样，只涉及对代码的一个小更改:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112705.png" class="" title="image-20211006112705">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112715.png" class="" title="image-20211006112715">

<p>一个像素有16个随机样本。</p>
<p><strong>这里ξ是一个在[0,1)范围内返回一个均匀随机数的调用。不幸的是，除非采取许多样本，否则噪声是相当令人讨厌的。一种方法是采用一种混合策略，随机扰动规则网格:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112842.png" class="" title="image-20211006112842">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112853.png" class="" title="image-20211006112853">

<p><strong>这种方法通常称为抖动或分层采样(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112937.png" class="" title="image-20211006112937">

<p>16个样本采样显示带有或不带有高亮箱的单个像素的调和(抖动)样本。每个箱子里都有一个随机样本。</p>
<h3 id="Soft-Shadows-软阴影"><a href="#Soft-Shadows-软阴影" class="headerlink" title="Soft Shadows 软阴影"></a>Soft Shadows 软阴影</h3><p><strong>阴影在标准光线追踪中难以处理的原因是光线是无限小的点或方向，因此要么可见，要么不可见。在现实生活中，光有非零区域，因此可以部分可见。这个想法如下图中的2D所示。光完全看不见的区域叫做本影。部分可见的区域称为半影。没有一个常用的术语来描述不在阴影中的区域，但有时它被称为反本影。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006113355.png" class="" title="image-20211006113355">

<p>从没有阴影的地方到有阴影的地方，柔和的阴影有渐变的过渡。过渡区为图中用p表示的“半影”。</p>
<p><strong>实现软阴影的关键是考虑到光线是一个区域而不是一个点。一个简单的方法是用一组分布的N个点光源来近似光源，每个点光源的强度是基础光源的1 / N。这个概念如下图的左边所示，其中使用了9个灯。你可以在标准的光线追踪器中这样做，这是在现成的渲染器中获得柔和阴影的常见技巧。这种技术有两个潜在的问题。首先，通常需要几十个点光源来达到视觉上平滑的效果，这大大减慢了程序的速度。第二个问题是阴影在半影内部有明显的过渡。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006113734.png" class="" title="image-20211006113734">

<p>左:一个区域灯可以用一些点灯来近似;9个点中的4个对p是可见的，所以它在半影中。右图:在光线上随机选择一个点作为阴影射线，它有一定的机会击中光线。</p>
<p><strong>分布射线追踪在阴影代码中引入了一个小的变化。代替离散数量的点源来表示区域光，我们将其表示为无限数量，并为每条观察射线随机选择一个。这相当于在灯上为任何表面点选择一个随机点，如上图的右侧所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006113859.png" class="" title="image-20211006113859">

<p>平行四边形光的几何形状由一个角点和两个边向量指定。</p>
<p><strong>如果光源是一个由角点c和两个边向量a和b指定的平行四边形(上图)，那么随机选择一个点r很简单:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006113949.png" class="" title="image-20211006113949">

<p><strong>其中ξ1 和ξ2 为范围[0,1)的均匀随机数。</strong></p>
<p><strong>然后我们发送一条阴影射线到这一点，如上上图中右侧所示。注意，这条射线的方向不是单位长度，这可能需要根据假设对基本射线追踪器进行一些修改。</strong></p>
<p><strong>我们真的很想在灯光上抖动点。然而，不加思考就实现它是很危险的。我们不希望总是有位于像素左上角的光线会向光线的左上角生成阴影光线。相反，我们想要打乱样本，这样像素样本和光样本各自都是抖动的，但是像素样本和光样本之间没有相关性。一个很好的方法是生成两组不同的n²抖动样本，并将样本传递到光源例程中:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006114041.png" class="" title="image-20211006114041">

<p><strong>这个shuffle例程消除了数组r和s之间的任何相干性。阴影例程只使用存储在s[p]中的2D随机点，而不调用随机数生成器。对于索引为0到N−1的数组，shuffle例程为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006114108.png" class="" title="image-20211006114108">

<h3 id="Depth-of-Field-景深"><a href="#Depth-of-Field-景深" class="headerlink" title="Depth of Field 景深"></a>Depth of Field 景深</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006131323.png" class="" title="image-20211006131323">

<p>透镜平均在一个圆锥体上击中被采样像素位置的方向。</p>
<p><strong>在大多数照片中看到的软聚焦效果可以通过在一个非零尺寸的“镜头”而不是在一个点上收集光线来模拟。这叫做景深。透镜从一个方向的圆锥体上收集光线，圆锥体的顶点在聚焦的距离处(上图)。我们可以将我们正在采样的“窗口”放置在聚焦的平面上(而不是我们之前所做的z = n平面)，并将透镜放置在眼睛上。到所有东西都在焦点上的平面的距离我们称之为焦点平面，到它的距离是由用户设置的，就像真实相机到焦点平面的距离是由用户或测距仪设置的一样。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006131336.png" class="" title="image-20211006131336">

<p>为了创造景深效果，眼睛都是从一个正方形区域中随机选取的。</p>
<p><strong>为了忠实于真正的相机，我们应该把镜头做成磁盘。然而，我们将得到非常类似的效果与一个正方形镜头(上图)。所以我们选择了镜头的边长，并在上面随机取样。视场光线的来源将是这些被扰动的位置，而不是眼睛的位置。同样，使用变换程序来防止与像素样本位置的相关性。下图显示了一个使用每像素25个样本和一个大磁盘镜头的示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006131532.png" class="" title="image-20211006131532">

<p>一个景深的例子。酒杯阴影中的焦散计算使用粒子追踪，如第23章所述。</p>
<h3 id="Glossy-Reflection-镜面反射"><a href="#Glossy-Reflection-镜面反射" class="headerlink" title="Glossy Reflection 镜面反射"></a>Glossy Reflection 镜面反射</h3><p><strong>有些表面，如拉丝金属，介于理想的镜面和漫反射表面之间。在反射中可以看到一些可辨认的图像，但它是模糊的。我们可以通过随机扰动理想镜面反射光线来模拟这个过程，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006131757.png" class="" title="image-20211006131757">

<p>反射光线被扰动到一个随机向量r′。</p>
<p><strong>只有两个细节需要解决:如何选择向量r′以及当产生的摄动光线在光线所在表面以下时该怎么做反映。后一个细节通常通过当光线低于表面时返回零颜色来解决。</strong></p>
<p><strong>选择r′，我们再次随机采样。这个正方形垂直于r，其宽度为a，用于控制模糊的程度。我们可以使用2.4.6节中的技术，通过创建w = r的标准正交基来设置正方形的方向。然后，我们在2D正方形中创建一个边长为以原点为中心的随机点。如果我们有二维样本点(ξ， ξ′)∈[0,1]²，则所要求的平方上的类比点为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006132047.png" class="" title="image-20211006132047">

<p><strong>因为我们要扰动的平方平行于u和v向量，射线r′只是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006132057.png" class="" title="image-20211006132057">

<p><strong>请注意,r′不一定是一个单位矢量，如果你的代码要求射线方向，应该标准化。</strong></p>
<h3 id="Motion-Blur-运动模糊"><a href="#Motion-Blur-运动模糊" class="headerlink" title="Motion Blur 运动模糊"></a>Motion Blur 运动模糊</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006132236.png" class="" title="image-20211006132236">

<p>右下角的球在运动，结果是模糊的外观。图片由Chad Barb提供。</p>
<p><strong>我们可以向对象添加一个模糊的外观，如上图所示。这被称为运动模糊，是图像在非零上形成的结果跨越的时间。在真正的相机中，光圈是在物体移动的一段时间内打开的。我们可以通过设置一个从T0到T1的时间变量来模拟开孔．对于每一条观察射线，我们选择一个随机的时间，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006132331.png" class="" title="image-20211006132331">

<p><strong>我们可能还需要创建一些随着时间移动的物体。例如，我们有一个运动的球体，在时间间隔里它的中心从c0到c1运动。已知T，我们可以计算出实际的圆心并与球面做射线交点。因为每一条光线都是在不同的时间发送的，所以每一条光线都会在不同的位置遇到球体，最终的外观会变得模糊。注意，移动球体的边界框应该限定其整个路径，这样就可以在整个时间间隔内建立效率结构(Glassner, 1988)。</strong></p>
<h1 id="14-Sampling-采样"><a href="#14-Sampling-采样" class="headerlink" title="14 Sampling 采样"></a>14 Sampling 采样</h1><h2 id="Integration-混合"><a href="#Integration-混合" class="headerlink" title="Integration 混合"></a>Integration 混合</h2><p><strong>尽管“积分”和“度量”这两个词看起来很吓人，但它们与数学中一些最直观的概念有关，不应该害怕。对于我们非常不严格的目的，测度就是一个将子集映射到R+ 的函数以与我们对长度、面积和体积的直观概念相一致的方式。例如，在二维实平面R²上，我们有面积A它给平面上的一组点赋值。注意，A只是一个函数，它取了平面的一部分并返回面积。这意味着A的定义域是R²的所有可能子集，表示为幂集P(R²)．因此，我们可以用箭头表示A:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007110244.png" class="" title="image-20211007110244">

<p><strong>应用面积测度的一个例子表明，边长为1的正方形的面积为1:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007110330.png" class="" title="image-20211007110330">

<p><strong>其中(a, b)是正方形的左下角。注意，像(3,7)这样的单点是R²的有效子集面积为零:A((3,7)) = 0。x轴上S = (x, y)使得(x, y)∈R²的点S的集合也是这样y = 0，也就是A (S) = 0。这样的集称为零测度集。</strong></p>
<p><strong>要把一个函数看作测度，它必须服从某些类面积的性质。例如，我们有一个μ: P(S)→R+的函数．要使μ是一个测度，必须满足以下条件:</strong></p>
<p>​    <strong>1.空集的度数为0:μ(∅)= 0，</strong></p>
<p>​    <strong>2.两个截然不同的集合的度量是它们各自度量的总和。这个规则与可能的交集是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111139.png" class="" title="image-20211007111139">

<p><strong>其中∪是集合并算子，∩是集相交算子。</strong></p>
<p><strong>当我们实际计算度量时，我们通常使用积分。我们可以把积分看成一种符号</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111246.png" class="" title="image-20211007111246">

<p><strong>你可以把右边非正式地理解为“取区域S中的所有点x，和它们相关的微分区域。”积分通常有其他写法，包括</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111253.png" class="" title="image-20211007111253">

<p><strong>以上公式都表示“区域S的面积”。“我们将继续使用第一个，因为它过于冗长，避免了模糊性。为了用解析的方法来计算这样的积分，我们通常需要建立一些坐标系，并使用我们的微积分技巧来解这些方程。但如果这些技巧已经消失，也不用担心，因为我们通常需要数值逼近积分，而这只需要一些简单的技巧，稍后将在本章中介绍。</strong></p>
<p><strong>给定集合S上的一个测度，我们总是可以通过用非负函数w: S→R+加权来创建一个新的测度．这个最好用积分表示符号。例如，我们可以从[0,1]²上的简单面积测量开始：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111514.png" class="" title="image-20211007111514">

<p><strong>我们可以通过插入一个半径平方的加权函数来使用“径向加权”度量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111522.png" class="" title="image-20211007111522">

<p><strong>为了解析地计算它，我们可以使用dA≡dx dy的笛卡尔坐标系展开:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111603.png" class="" title="image-20211007111603">

<p><strong>这里的关键是，如果考虑||x||² 项和dA项结合在一起，形成了一个新的测量值，我们可以称之为ν。这将允许我们写出ν(S)而不是整个积分。如果你觉得这只是一堆符号和簿记，那么你是对的。但它确实允许我们写出方程，可以是紧凑的，也可以是展开的，这取决于我们的喜好。</strong></p>
<h3 id="Measures-and-Averages-度量和平均值"><a href="#Measures-and-Averages-度量和平均值" class="headerlink" title="Measures and Averages 度量和平均值"></a>Measures and Averages 度量和平均值</h3><p><strong>当取函数的平均值时，测量才真正开始奏效。您只能对特定的度量值取平均值，并且希望为应用程序或领域选择一个“自然”的度量值。一旦选择了一个度量，函数f在一个区域S上相对于度量μ的平均值是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112008.png" class="" title="image-20211007112008">

<p><strong>例如，函数f(x, y) = x²  [0,2]²相对于面积度量的平均值是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112019.png" class="" title="image-20211007112019">

<p><strong>这种机制有助于解决看似困难的问题，其中选择度量是棘手的部分。这类问题经常出现在积分几何中，积分几何是研究几何实体(如线和面)的一个领域。例如,有人可能想知道[0,1]²的直线的平均长度。也就是说，根据定义，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112029.png" class="" title="image-20211007112029">

<p><strong>一旦我们知道了，剩下的就是为应用程序选择合适的μ。这将在下一节中对行进行处理。</strong></p>
<h3 id="Example-Measures-on-the-Lines-in-the-2D-Plane-例-在二维平面的直线上度量"><a href="#Example-Measures-on-the-Lines-in-the-2D-Plane-例-在二维平面的直线上度量" class="headerlink" title="Example: Measures on the Lines in the 2D Plane 例:在二维平面的直线上度量"></a>Example: Measures on the Lines in the 2D Plane 例:在二维平面的直线上度量</h3><p><strong>什么量度μ是“自然的”?</strong></p>
<p><strong>如果将直线参数化为y = mx + b，则可以将给定的直线视为“斜截”空间中的点(m, b)。一个容易使用的度量是dm db，但这不是一个“好的”度量，因为并不是所有大小相等的行“包”都具有相同的度量。更准确地说，度量对于坐标系统的变化将不是不变的。例如，如果你取所有通过正方形[0,1]²的直线，通过它的直线的长度与通过一个旋转45度的单位正方形的长度是不同的。我们真正想要的是一种“公平”的度量，它不会随着一组直线的旋转或平移而改变。下两图说明了这个想法。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112342.png" class="" title="image-20211007112342">

<p>这两束线应该用同样的测量方法。它们与y轴有不同的交叉长度，因此使用db将是一个差的选择衡量。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112354.png" class="" title="image-20211007112354">

<p>这两束线应该用同样的测量方法。由于它们有不同的斜率变化值，使用dm将是一个差值测量的糟糕选择。</p>
<p><strong>为了在直线上建立一个自然的度量，我们首先应该把它们看作是二元空间中的点。这是一个简单的概念:直线y = mx + b可以指定为斜截空间中的点(m, b)。这个概念如下图所示。在(φ， b)空间中进行度量更为直接。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112544.png" class="" title="image-20211007112544">

<p>在(x, y)空间中的直线y = m x + b上的点集合也可以用(m, b)空间中的一个点来表示，所以上面的线和下面的点代表同一个几何实体:一条2D线。</p>
<p><strong>其中b为y轴截距，φ为直线与x轴的夹角，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112628.png" class="" title="image-20211007112628">

<p>在角截距空间中，我们通过用角度φ∈[- π/2， π/2]代替斜率来表示直线。</p>
<p><strong>这里，微分测量dφ db几乎可以工作，但由于上上上上图所示的影响，它将不公平。为了解释恒定宽度的线束所造成的更大的跨度b，我们必须加上一个余弦因子:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112801.png" class="" title="image-20211007112801">

<p><strong>可以证明，这个度量，直到一个常数，是唯一相对于旋转和平移不变的度量。</strong></p>
<p><strong>这个测量可以转换成适合于线的其他参数化的测量。例如，(m, b)空间的合适度量是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112814.png" class="" title="image-20211007112814">

<p><strong>对于(u, v)空间中参数化的直线空间，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112843.png" class="" title="image-20211007112843">

<p><strong>适当的措施是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112856.png" class="" title="image-20211007112856">

<p><strong>对于用(a, b)， x轴截距和y轴截距参数化的直线，度量为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112905.png" class="" title="image-20211007112905">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112959.png" class="" title="image-20211007112959">

<p>直线的法向坐标用到原点的法线距离和指定直线的角度。</p>
<p><strong>注意，这些空格都是同样有效的指定行的方法，并且哪一个是最好的取决于环境。然而，人们可能想知道是否存在这样一个坐标系，在这个坐标系中，一组直线的度量仅仅是对偶空间中的一个区域。事实上，确实有这样一个坐标系，它非常简单;它是法坐标，通过从原点到直线的法线距离和直线的法线相对于x轴的角度来指定一条直线(上图)。这类直线的隐式方程是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007113111.png" class="" title="image-20211007113111">

<p><strong>事实上，这个空间的尺度是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007113120.png" class="" title="image-20211007113120">

<p><strong>在后面的章节中，我们将使用这些方法来选择均匀随机的线。</strong></p>
<h3 id="Example-Measure-of-Lines-in-3D-例-在3D中度量直线"><a href="#Example-Measure-of-Lines-in-3D-例-在3D中度量直线" class="headerlink" title="Example: Measure of Lines in 3D 例:在3D中度量直线"></a>Example: Measure of Lines in 3D 例:在3D中度量直线</h3><p><strong>在3D中，参数化直线的方法有很多种。也许，最简单的方法是使用它们与特定平面的交点以及它们的方向。例如，我们可以画出xy平面的交点及其方向的球坐标。因此，每条线都被指定为a (x, y， θ， φ)四重体。这表明3D中的线是4D实体，即它们可以被描述为4D空间中的点。</strong></p>
<p><strong>一条线的微分量不应随(x, y)而变化，但相等截面的线束应具有相等的量。因此，一个公平的差别衡量是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007113815.png" class="" title="image-20211007113815">

<p><strong>另一种参数化直线的方法是画出两个平行平面的交点。例如,如果直线相交平面z = 0 (x = u,y = v)和平面z = 1 (x = s,y = t),然后由四线可以被描述(u, v,s,t)注意到,像前面的参数化,这个是线平行于xy平面的退化。微分测量对于这个参数化来说更加复杂，尽管它可以近似为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007113940.png" class="" title="image-20211007113940">

<p><strong>对于几乎平行于z轴的线束。这是在基于图像的渲染中经常隐含使用的度量方法。</strong></p>
<p><strong>对于与球面相交的直线集，我们可以使用直线与球面相交的两点的参数化。如果它们在球坐标下，那么这个点可以用四元(θ1,φ1,θ2,φ2)，测量值只是与每个点相关联的微分面积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114035.png" class="" title="image-20211007114035">

<p><strong>这意味着在球体上选择两个均匀的随机端点会形成一条密度均匀的直线。Mateu Sbert在他的论文(Sbert, 1997)中使用了这一观察结果来计算形状因子。</strong></p>
<p><strong>注意，有时我们想参数化有向线，有时我们想让端点的顺序无关紧要。这是一个记账细节，对于渲染应用程序来说尤其重要，因为在渲染应用程序中，沿着一条线流动的光的数量在两条线的两个方向上是不同的。</strong></p>
<h2 id="Continuous-Probability-连续概率"><a href="#Continuous-Probability-连续概率" class="headerlink" title="Continuous Probability 连续概率"></a><strong>Continuous Probability 连续概率</strong></h2><p><strong>许多图形算法利用概率构造随机样本来解决积分和平均问题。这是应用连续概率的领域，它与测度理论有基本的联系。</strong></p>
<h3 id="One-Dimensional-Continuous-Probability-Density-Functions-一维连续概率密度函数"><a href="#One-Dimensional-Continuous-Probability-Density-Functions-一维连续概率密度函数" class="headerlink" title="One-Dimensional Continuous Probability Density Functions 一维连续概率密度函数"></a>One-Dimensional Continuous Probability Density Functions 一维连续概率密度函数</h3><p><strong>非严格地说，连续随机变量x是一个标量或矢量，它“随机”从实线R =(−∞，+∞)取某个值。x的行为完全由它所取值的分布来描述。这种值的分布可以用与x相关的概率密度函数(pdf)， p(关系表示为x ~ p)。x在某一区间[a, b]中假定某一特定值的概率由以下积分给出:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114335.png" class="" title="image-20211007114335">

<p><strong>非严格地说，概率密度函数p描述了一个随机变量取某一值的相对可能性;如果p (x1)= 6.0且p(x2) = 3.0，那么密度p的随机变量在x1 附近的值的可能性是它在x2附近的两倍．密度p有两个特点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114348.png" class="" title="image-20211007114348">

<p><strong>作为一个例子，标准随机变量ξ值在0(包括)和1(不包括)之间具有一致概率(这里一致简单地意味着ξ的每个值都是相等的可能性)。这意味着概率密度函数q对于ξ为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114631.png" class="" title="image-20211007114631">

<p><strong>ξ被定义的空间仅仅是区间[0,1)。ξ在[a, b]∈[0,1)区间内取一个值的概率是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114644.png" class="" title="image-20211007114644">

<h3 id="One-Dimensional-Expected-Value-一维期望值"><a href="#One-Dimensional-Expected-Value-一维期望值" class="headerlink" title="One-Dimensional Expected Value 一维期望值"></a>One-Dimensional Expected Value 一维期望值</h3><p><strong>一个一维随机变量的实函数f，对于底层pdf，p的平均值称为其期望值E(f(x))(有时写成Ef(x)):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007115040.png" class="" title="image-20211007115040">

<p><strong>一维随机变量的期望值可以通过设置f(x) = x来计算。期望值有一个令人惊讶而又有用的性质:</strong></p>
<p><strong>两个随机变量和的期望值为两个随机变量的期望值之和:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007115050.png" class="" title="image-20211007115050">

<p><strong>对于随机变量x和y，由于随机变量的函数本身就是随机变量，这种期望的线性也适用于它们:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007115059.png" class="" title="image-20211007115059">

<p><strong>一个显而易见的问题是，如果被求和的随机变量是相关的(不相关的变量称为独立的)，那么这个属性是否成立。事实上，无论变量是否独立，这种线性性质都是成立的!这个求和性质对于大多数蒙特卡罗应用程序是至关重要的。</strong></p>
<h3 id="Multidimensional-Random-Variables-多维随机变量"><a href="#Multidimensional-Random-Variables-多维随机变量" class="headerlink" title="Multidimensional Random Variables 多维随机变量"></a>Multidimensional Random Variables 多维随机变量</h3><p><strong>关于随机变量及其期望值的讨论自然延伸到多维空间。大多数图形问题都是在高维空间中进行的。例如，许多照明问题是在半球的表面上出现的。幸运的是，如果我们在随机变量占据的空间上定义一个μ测度，一切都与一维情况非常相似。假设空间S有μ;例如，S是球面，而μ是测量面积的。我们可以定义一个pdf p: S →R，如果x是一个具有x ~ p的随机变量，那么x将在某个区域Si ⊂S中取一个值的概率是由积分给出的</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124218.png" class="" title="image-20211007124218">

<p><strong>这里概率(事件)是事件发生的概率，所以积分是x在区域Si中取值的概率．</strong></p>
<p><strong>在图形中，S通常是一个面积(dμ = dA = dxdy)或一组方向(单位球上的点:dμ = dω = sin θ dθ dφ)。例如，一个二维随机变量α是在半径为R的圆盘上均匀分布的随机变量。这里均匀是指相对于面积均匀分布，例如，一个坏的飞镖玩家的命中率会分布在飞镖板上。因为它是均匀的，我们知道p(α)是某个常数。这个圆盘的面积是πr² 总概率是1，我们可以推导出来</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124425.png" class="" title="image-20211007124425">

<p><strong>这意味着α在某个子集S1 中的概率</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124514.png" class="" title="image-20211007124514">

<p><strong>这是非常抽象的。为了使用这个信息，我们需要一个可以计算的积分形式。假设Si 是圆盘离圆心比周长更近的部分。如果我们转换为极坐标，则α表示为(r， φ)对，S1 是r &lt; R /2的区域。注意，仅仅因为α是均匀的，并不意味着φ或r一定是均匀的(事实上，φ是均匀的，而r不均匀)。微分面积dA等于r dr dφ。因此,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124651.png" class="" title="image-20211007124651">

<p><strong>实函数期望值公式适用于多维情况:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124715.png" class="" title="image-20211007124715">

<p><strong>其中x∈S, f: S→R, p: S →R。例如，在一个单位区域S = [0, 1] × [0, 1]且 p(x, y)=4xy,x坐标的期望值(x, y) ∼ p为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125044.png" class="" title="image-20211007125044">

<p><strong>注意这里f(x, y) = x。</strong></p>
<h3 id="Variance-方差"><a href="#Variance-方差" class="headerlink" title="Variance 方差"></a>Variance 方差</h3><p><strong>根据定义，一维随机变量的方差V (x)是x与E(x)之差的平方的期望值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125207.png" class="" title="image-20211007125207">

<p><strong>一些代数操作给出了不明显的表达式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125220.png" class="" title="image-20211007125220">

<p><strong>表达式E([x−E(x)]²)对于直观地考虑方差更有用，而代数等价表达式E(x²)−[E (x)] ²通常便于计算。随机变量和的方差是变量独立时的方差之和。这种方差的和性质是它经常被用于概率模型分析的原因之一。方差的平方根称为标准差，σ，它给出了一些与期望值的期望绝对偏差的指示。</strong></p>
<h3 id="Estimated-Means-估计方法"><a href="#Estimated-Means-估计方法" class="headerlink" title="Estimated Means 估计方法"></a>Estimated Means 估计方法</h3><p><strong>许多问题都涉及到独立随机变量x的和<em>i</em>这种变量称为独立同分布(iid)随机变量。当和除以变量数，我们得到E(x)的估计值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125438.png" class="" title="image-20211007125438">

<p><strong>随着N的增加，这个估计的方差减小。我们希望N足够大，以便我们有信心估计“足够接近”。“然而，在蒙特卡洛没有什么是确定无疑的;我们只是获得了统计上的信心，我们的估计是好的。当然，我们必须让N =∞。这种信心由大数定律表示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125447.png" class="" title="image-20211007125447">

<h2 id="Monte-Carlo-Integration-蒙特卡洛积分"><a href="#Monte-Carlo-Integration-蒙特卡洛积分" class="headerlink" title="Monte Carlo Integration 蒙特卡洛积分"></a>Monte Carlo Integration 蒙特卡洛积分</h2><p><strong>本节概述了定积分的基本蒙特卡罗解法。这些技术可直接应用于某些积分问题。本节的所有基本材料也涵盖在几个经典的蒙特卡洛文本。(请参阅本章末尾的注释部分。)</strong></p>
<p><strong>如前所述，给定一个函数f: S →R和一个随机变量x ~ p，我们可以通过求和来近似f(x)的期望值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008103422.png" class="" title="image-20211008103422">

<p><strong>因为期望值可以用积分表示，所以积分也可以用求和来近似。上式的形式有点尴尬;我们通常喜欢近似单个函数g的积分而不是乘积fp的积分。我们可以通过将g = fp代入被积函数来实现:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008103440.png" class="" title="image-20211008103440">

<p><strong>为了使这个公式有效，当g不为零时，p必须为正。</strong></p>
<p><strong>为了得到一个好的估计，我们需要尽可能多的样本，我们希望g/p有一个低的方差(g和p应该有一个相似的形状)。智能地选择p被称为重要抽样，因为如果p很大，而g也很大，那么在重要区域就会有更多的样本。上上式也显示了蒙特卡罗积分的基本问题:收益递减。因为估计的方差与1/N成正比，所以标准差与1/√N成正比。因为估计中的误差与标准差的行为类似，我们需要将N的四倍来将误差减半。</strong></p>
<p><strong>另一种减少方差的方法是划分S，积分的域，分为几个较小的域Si，并将积分作为积分之和进行计算越过Si。这被称为分层采样，即抖动在像素采样中使用的技术(第4章)。通常情况下，每个Si只采集一个样本与密度(pi)，在这种情况下，估计的方差为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008103949.png" class="" title="image-20211008103949">

<p><strong>可以看出，如果各层具有相同的测度，分层采样的方差永远不会高于非分层抽样:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008103959.png" class="" title="image-20211008103959">

<p><strong>图形中最常见的分层采样例子是像素采样的抖动，如第13.4节所述。</strong></p>
<p><strong>作为积分I的蒙特卡罗解的一个例子，集合g(x)等于x在区间(0,4)上的积分:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104114.png" class="" title="image-20211008104114">

<p><strong>函数p的形状对N个样本估计方差的影响见下表。注意，当p的形状与g的形状相似时，方差减小。如果p = g/I，方差降为零，但是我通常不为人所知，否则我们就不必求助于蒙特卡洛。下表所示的一个重要原则是，分层抽样通常远优于重要采样(Mitchell, 1996)。虽然对I进行分层的方差与样本数的立方成反比，但对分层下的方差行为并没有普遍的结果。分层对某些功能是没有好处的。一个例子是白噪声函数，其中所有区域的方差都是常数。另一方面，大多数函数将受益于分层采样，因为每个子单元的方差通常会小于整个域的方差。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104246.png" class="" title="image-20211008104246">

<p>∫₀⁴xdx的蒙特卡罗估计的方差。</p>
<h3 id="Quasi–Monte-Carlo-Integration-准蒙特卡罗积分"><a href="#Quasi–Monte-Carlo-Integration-准蒙特卡罗积分" class="headerlink" title="Quasi–Monte Carlo Integration 准蒙特卡罗积分"></a>Quasi–Monte Carlo Integration 准蒙特卡罗积分</h3><p><strong>常用的求积方法是用拟随机点代替蒙特卡罗积分中的随机点。这些点是确定性的，但在某种意义上是一致的。例如，在单位平方[0,1]²上，一组N个拟随机点在正方形内区域a上具有如下性质:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104552.png" class="" title="image-20211008104552">

<p><strong>例如，晶格中的一组规则样本就具有这种性质。</strong></p>
<p><strong>在许多集成应用中，准随机点可以提高性能。有时必须小心确保它们不引入走样。特别好的是，在任何应用程序中，当调用[0,1]^d中的随机或分层点时，可以在不做其他改变的情况下替换d维准随机点。</strong></p>
<p><strong>激发拟蒙特卡罗积分的关键直觉是，当估计被积函数的平均值时，任何一组样本点都可以，只要它们是“公平的”。</strong></p>
<h2 id="Choosing-Random-Points-选择随机点"><a href="#Choosing-Random-Points-选择随机点" class="headerlink" title="Choosing Random Points 选择随机点"></a>Choosing Random Points 选择随机点</h2><p><strong>我们经常想在单位平方上生成一组随机或伪随机点，用于诸如分布射线追踪的应用。有几种方法可以做到这一点，例如jittering(参见第13.4节)。这些方法在单位平方上给出了一组N个合理等分布的点[0,1]² : (u1, v1)通过(uN，vN)。</strong><br><strong>有时，我们的采样空间可能不是方形的(例如，圆形透镜)，也可能不是均匀的(例如，以像素为中心的滤波函数)。如果我们能写出一个数学变换将我们的等分布点(ui, vi)作为输入和输出的一组点在我们的期望采样空间与我们的期望密度。例如，采样一个相机镜头，变换将采取(ui, vi)和输出(ri,φi)，使新的点在透镜的圆盘上近似等分布。虽然我们可能会尝试使用转换</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104855.png" class="" title="image-20211008104855">

<p><strong>它有一个严重的问题。虽然这些点覆盖了镜头，但它们并不均匀(下图)。在这种情况下，我们需要的是一个将等面积区域转换为等面积区域的变换——一个将平方上的均匀采样分布转换为新区域上的均匀分布的变换。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104948.png" class="" title="image-20211008104948">

<p>采用水平和的转换垂直尺寸一致为(r， φ)不保留相对面积;并不是所有的结果区域都是相同的。</p>
<p><strong>有几种方法可以在非矩形域上生成这样的非均匀点或均匀点，下面几节将介绍三种最常用的方法:函数求逆、拒绝和Metropolis。</strong></p>
<h3 id="Function-Inversion-函数求逆"><a href="#Function-Inversion-函数求逆" class="headerlink" title="Function Inversion 函数求逆"></a>Function Inversion 函数求逆</h3><p><strong>如果密度f(x)是一维的并且定义在x∈[xmin, xmax]区间内，则可以生成随机数αi 从一组均匀随机数ξi中得到密度f,ξi ∈[0,1]。为此，我们需要累积概率分布函数P(x):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008105800.png" class="" title="image-20211008105800">

<p><strong>得到αi，我们只是变换ξi值：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008105820.png" class="" title="image-20211008105820">

<p><strong>其中P−1是P的逆。如果P不是解析可逆的，那么数值方法就足够了，因为对所有有效的概率分布函数都存在逆。</strong><br><strong>注意，由于符号的关系，解析反变换函数比它应该的更容易混淆。例如，如果我们有这个函数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008105917.png" class="" title="image-20211008105917">

<p><strong>对于x &gt; 0，则逆函数表示为y作为x的函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008105926.png" class="" title="image-20211008105926">

<p><strong>当函数是解析可逆的时候，它几乎总是那么简单。然而，使用标准表示法时，情况有点不透明:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110103.png" class="" title="image-20211008110103">

<p><strong>这里x只是一个哑变量。你可能会发现使用不太标准的符号更容易:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110112.png" class="" title="image-20211008110112">

<p><strong>记住，它们是相互反函数。例如，随机选择点xi 的密度</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110122.png" class="" title="image-20211008110122">

<p><strong>在[- 1,1]上我们可以看到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110203.png" class="" title="image-20211008110203">

<p><strong>和</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110211.png" class="" title="image-20211008110211">

<p><strong>所以我们可以“扭曲”一组标准随机数(ξ1，···，ξN )到正确分布的数</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110252.png" class="" title="image-20211008110252">

<p><strong>当然，同样的翘曲函数可以用来将“均匀”抖动的样本转换成理想密度的均匀分布的样本。</strong> </p>
<p><strong>如果随机变量α = (αx,αy)的二维密度(x, y)定义在[xmin, xmax]×[ymin,ymax]，则需要二维分布函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110346.png" class="" title="image-20211008110346">

<p><strong>我们首先选择一个xi 使用边际分布F(x, ymax)，然后选择yi 根据F (xi,y)/F (xi, ymax)．如果f(x, y)是可分离的(可表示为g(x)h(y))，那么一维技术可以在每个维度上使用。</strong><br><strong>回到我们前面的例子，假设我们从半径为R的圆盘均匀采样，因此p(r， φ) = 1/(πR)²)．二维分布函数为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110541.png" class="" title="image-20211008110541">

<p><strong>这意味着正则对(ξ1,ξ2)可以转化为圆盘上的均匀随机点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110613.png" class="" title="image-20211008110613">

<p><strong>这个映射如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110626.png" class="" title="image-20211008110626">

<p>一种使用相同面积的区域的映射磁盘中面积相等的单位平方</p>
<p><strong>为了在一些真实的渲染应用中选择反射光线的方向，我们根据密度在单位半球上选择点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110740.png" class="" title="image-20211008110740">

<p><strong>其中n为类phon指数，θ为与表面法线的夹角，θ∈[0，π/2] (位于上半球)，φ为方位角(φ∈[0,2 π])。累积分布函数为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110752.png" class="" title="image-20211008110752">

<p><strong>sinθ′项的出现是因为在球面上dω = cos θdθdφ。当边际密度被发现时，p(如预期)是可分离的，并且我们发现a (ξ1,ξ2)对正则随机数可以被转换为一个方向</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110901.png" class="" title="image-20211008110901">

<p><strong>同样，这个方法的好处是单位平方上的一组抖动点可以很容易地转化为半球上的一组抖动点，它们的分布是理想的。注意，如果n被设为1，我们有一个弥散分布，这是经常需要的。</strong></p>
<p><strong>通常我们必须将球面上的点映射到一个相对于uvw基的适当方向上。要做到这一点，我们可以先把角度转换成单位向量a:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110944.png" class="" title="image-20211008110944">

<p><strong>为了提高效率，我们可以避免使用反三角函数的三角函数(如cos (arccosθ))。例如，当n = 1(扩散分布)时，向量a简化为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110955.png" class="" title="image-20211008110955">

<h3 id="Rejection-拒绝"><a href="#Rejection-拒绝" class="headerlink" title="Rejection 拒绝"></a>Rejection 拒绝</h3><p><strong>拒绝方法根据一些简单的分布选择点，并拒绝一些在更复杂的分布中的点。有几种使用拒绝的场景，我们通过示例展示其中一些场景。</strong><br><strong>假设我们想要在单位圆内均匀随机的点。我们可以首先选择均匀随机点(x, y)∈[−1,1]² 拒绝圈外的点。如果函数r()返回一个规范随机数，则该过程</strong></p>
<p><strong>是:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008111733.png" class="" title="image-20211008111733">

<p><strong>如果我们想要一个随机数x ~ p，并且我们知道p: [a, b] →R，并且对于所有的x, p(x) &lt; m，那么我们可以在矩形[a, b] × [0, m]中生成随机的点，并在其中y &lt; p(x):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008111815.png" class="" title="image-20211008111815">

<p><strong>同样的想法也可以应用于在球面上随机取点。要随机选取方向均匀分布的单位矢量，首先在单位球中随机选取一个点，然后取相同方向的单位矢量，将该点视为方向矢量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008111827.png" class="" title="image-20211008111827">

<p><strong>拒选方法通常易于编码，但它很少与分层兼容。由于这个原因，它趋向于收敛得更慢，因此应该主要用于调试，或在特别困难的情况下。</strong></p>
<h3 id="Metropolis"><a href="#Metropolis" class="headerlink" title="Metropolis"></a>Metropolis</h3><p><strong>Metropolis方法使用随机变异产生一组所需密度的样本。这个概念在章节注释中引用的Metropolis Light Transport算法中被广泛使用。假设有一个随机的点x0 在定义域S进一步，假设对于任意点x，我们有一种方法生成随机的y ~ px。我们用边缘符号px(y)≡p(x→y)表示密度函数。现在，假设我们设x1 是S中以密度p(x0 →x1)选定的随机点．我们生成x2 与密度p (x1 →x0)等等。在极限情况下，我们生成无限个样本，可以证明样本有一个由p决定的潜在密度不管初始点x0是多少。</strong></p>
<p><strong>现在,假设我们想选择p这样底层的密度的样品我们收敛函数f (x)成正比,与域f是一个非负函数s .此外,假设我们可以评估f,但我们有很少或没有额外的知识其属性(函数是常见的图形)。同样，假设我们有能力从xi到xi+1 进行“转换”它的密度函数是t(xi →xi+1)．为了增加灵活性，进一步假设我们加上xi 转换到自身，即xi+1 = xi。我们称之为产生了一个潜在的候选者y ~ t(xi →y)和“接受”这个候选人(即xi+1 = y，其概率为a(xi →y)和拒绝它(例如:xi+1 = xi)的概率为1 - a(xi →y)x0, x1, x2，…将是一个随机集合，但在样本之间会有一些相关性。它们仍然适用于蒙特卡罗积分或密度估计，但分析这些估计的方差更具挑战性。</strong></p>
<p><strong>现在，假设我们有一个转移函数t(x→y)和一个函数f(x)我们想要模拟它的分布，我们可以用a(y→x)使点以f的形状分布吗?或者更准确地说,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008115339.png" class="" title="image-20211008115339">

<p><strong>这可以通过确保xi 在某种强烈意义上是静止的。如果你想象一个巨大的样本点x集合，你希望两点之间的“流动”在每个方向上都是相同的。如果我们假设x和y附近点的密度分别与f(x)和f(y)成正比，那么这两个方向的流动应该是相同的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008115412.png" class="" title="image-20211008115412">

<p><strong>k是一个正的常数。设置这两个流常量将对a进行约束:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008115430.png" class="" title="image-20211008115430">

<p><strong>因此，如果a(y→x)或a(x→y)已知，那么另一个已知。使它们更大可以提高被接受的机会，所以通常的技术是将较大的两个设为1。</strong></p>
<p><strong>使用Metropolis样本生成技术的一个困难是，很难估计需要多少个点才能使点集“良好”。“如果丢弃前n个点，事情就会加速，尽管明智地选择n并非易事。</strong></p>
<h3 id="Example-Choosing-Random-Lines-in-the-Square-例-在正方形中选择随机线"><a href="#Example-Choosing-Random-Lines-in-the-Square-例-在正方形中选择随机线" class="headerlink" title="Example: Choosing Random Lines in the Square 例:在正方形中选择随机线"></a>Example: Choosing Random Lines in the Square 例:在正方形中选择随机线</h3><p><strong>作为设计采样策略的整个过程的一个例子，考虑寻找与单位平方相交的随机线的问题[0,1]2。我们希望这个过程是公平的;也就是说，我们希望直线在正方形内均匀分布。直观上，我们可以看到这个问题有些微妙之处;在一个斜角上比在水平或垂直方向上有“更多”线。这是因为正方形的横截面不均匀。</strong></p>
<p><strong>我们的第一个目标是找到一个函数反转方法(如果存在的话)，然后在拒绝方法或Metropolis方法失败时返回。这是因为我们希望在行空间中有分层的样本。我们首先尝试使用法坐标，因为在正方形中选择随机直线的问题就是在(r， θ)空间中与正方形中直线对应的任意部分中找到均匀随机点的问题。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008122610.png" class="" title="image-20211008122610">

<p>最大的距离r对应于一条直线与θ∈[−π/ 2,0]的平方相接。因为这个平方的边长是1,r = cos θ。 </p>
<p><strong>考虑−π/2 &lt; θ &lt; 0的区域。r的什么值对应于与正方形相交的直线?对于这些角，r &lt; cos θ是所有与上图所示的正方形相接的直线。在其他四个象限中，类似的推理可以找到(r， θ)空间中必须采样的区域，如下图所示。区域rmax(θ)的边界方程是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008122900.png" class="" title="image-20211008122900">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008122955.png" class="" title="image-20211008122955">

<p>到达单位正方形的线的最大半径[0,1]² 作为θ的函数。</p>
<p><strong>因为rmax(θ)下的区域是一个简单函数，其下界为r = 0，我们可以根据密度函数首先选择θ对其进行采样:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123318.png" class="" title="image-20211008123318">

<p><strong>分母是4。现在，我们可以计算累积概率分布函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123726.png" class="" title="image-20211008123726">

<p><strong>我们可以通过控制ξ1 = P(θ)来求倒数化成θ = g(ξ1)．这个收益率</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123812.png" class="" title="image-20211008123812">

<p><strong>一旦有了θ， r就很简单:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123837.png" class="" title="image-20211008123837">

<p><strong>如前所述，这一行有许多参数化，每个参数都有一个相关的“公平”度量。我们也可以在这些空间中生成随机的直线。例如，在斜截空间中，到达正方形的区域如下图所示。通过与法向空间相似的推理，斜率的密度函数为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123924.png" class="" title="image-20211008123924">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123914.png" class="" title="image-20211008123914">

<p>(m,b)空间的区域，其中包含与单位平方[0,1]²相交的直线。</p>
<p><strong>关于微分测度</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123935.png" class="" title="image-20211008123935">

<p><strong>这就产生了累积分布函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123954.png" class="" title="image-20211008123954">

<p><strong>这些可以通过解两个二次方程得到。给定使用ξ1生成的m，我们还有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008124140.png" class="" title="image-20211008124140">

<p><strong>这并不是比使用法坐标更好的方法;这只是另一种选择。</strong></p>
<h1 id="15-Curves-曲线"><a href="#15-Curves-曲线" class="headerlink" title="15 Curves 曲线"></a><strong>15 Curves 曲线</strong></h1><h2 id="Curves-曲线"><a href="#Curves-曲线" class="headerlink" title="Curves 曲线"></a>Curves 曲线</h2><p><strong>直观地说，你可以把曲线想象成可以用钢笔画出来的东西。曲线是笔在一段时间内所画出的点的集合。虽然我们通常会想到一支笔在纸上写字(例如，在2D空间中的一条曲线)，但笔可以在3D空间中移动以生成一条空间曲线，或者你也可以想象笔在其他空间中移动。</strong></p>
<p><strong>从数学上看，曲线的定义至少有两种方式:</strong> </p>
<p>​    <strong>1.n维空间中某些区间的连续象;</strong> </p>
<p>​    <strong>2.从一维空间到n维空间的连续映射。</strong> </p>
<p><strong>这两种定义都始于间隔范围(笔在曲线上画出的时间)的概念。然而，有一个显著的区别:在第一个定义中，曲线是笔的痕迹点(图像)的集合，而在第二个定义中，曲线是时间和该集合点之间的映射。在本章中，我们使用第一个定义。</strong></p>
<p><strong>曲线是无限大的点的集合。曲线上的点都有这样的性质:任何一点都有两个邻居，除了少数几个有一个邻居的点(这些是端点)。有些曲线没有端点，要么是因为它们是无限的(像一条线)，要么是因为它们是闭合的(绕圈并连接到自己)。</strong></p>
<p><strong>因为曲线的“笔”很薄(无穷小)，很难创建填充区域。虽然空间填充曲线是可能的(通过让它们无限次地自我折叠)，我们在这里不考虑这种数学上的奇怪。一般来说，我们认为曲线是事物的轮廓，而不是“内部”。</strong></p>
<p><strong>我们需要解决的问题是如何指定曲线——给曲线一个名称或表示，以便我们能在计算机上表示它。对于某些曲线，命名问题很简单，因为它们有已知的形状:线段、圆、椭圆弧等。没有“命名”形状的一般曲线有时被称为自由形曲线。因为自由形式的曲线可以呈现任何形状，所以很难指定它们。</strong></p>
<p><strong>有三种主要的方法在数学上指定曲线:</strong></p>
<p>​    <strong>1.隐式曲线表示通过给出一个程序来定义曲线上的点集，这个程序可以测试曲线上是否有点。通常，隐式曲线表示是由这种形式的隐式函数定义的</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009110545.png" class="" title="image-20211009110545">

<p><strong>所以曲线就是这个方程成立的点的集合。请注意，隐式函数f是一个标量函数(它返回一个实数)。</strong></p>
<p>​    <strong>2.参数曲线表示提供了从自由参数到曲线上点集的映射。也就是说，这个自由参数提供了曲线上点的索引。曲线的参数形式是一个将位置赋给自由参数值的函数。直观地说，如果你认为曲线是你可以用笔在纸上画出来的东西，自由参数就是时间，从我们开始画曲线的时间到我们完成曲线的时间。这条曲线的参数函数告诉我们笔在任何时刻的位置:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009110659.png" class="" title="image-20211009110659">

<p><strong>注意，参数函数是一个向量值函数。这个例子是一个2D曲线，所以函数的输出是一个2向量;在三维中它是一个三维向量。</strong></p>
<p>​    <strong>3.生成式或程序性曲线表示提供了可以生成曲线上不属于前两类点的过程。生成曲线描述的例子包括细分方案和分形。</strong></p>
<p><strong>记住，曲线是点的集合。这些表示给了我们指定这些集合的方法。任何曲线都有许多可能的表示形式。对于这个因为，数学家通常会小心地区分曲线和它的表示。在计算机图形学中，我们常常是马虎的，因为我们通常只参考表示，而不是实际的曲线本身。所以当有人说“隐函数”的时候，他们指的要么是由隐函数表示的曲线要么是由隐函数表示的曲线。这种区别通常并不重要，除非我们需要考虑同一曲线的不同表示。我们将在本章中考虑不同的曲线表示，因此我们会更加小心。当我们使用“多项式曲线”这样的术语时，我们指的是可以用多项式表示的曲线。</strong></p>
<p><strong>根据本章开头给出的定义，曲线必须有参数表示。然而，许多曲线有其他表现形式。例如，一个圆心在原点，半径为1的二维圆可以隐式写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009110738.png" class="" title="image-20211009110738">

<p><strong>或以参数形式表示</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009110751.png" class="" title="image-20211009110751">

<p><strong>对于给定的曲线，参数形式不一定是最方便的表示形式。事实上，曲线有可能具有简单的隐式或生成表示，但很难找到参数表示。</strong></p>
<p><strong>不同的曲线表示方式各有优缺点。例如，参数曲线更容易绘制，因为我们可以对自由参数进行采样。一般来说，参数化形式是计算机图形学中最常用的形式，因为它们更容易处理。我们的重点将是曲线的参数表示。</strong></p>
<h3 id="Parameterizations-and-Reparameterizations-参数化和重新参数化"><a href="#Parameterizations-and-Reparameterizations-参数化和重新参数化" class="headerlink" title="Parameterizations and Reparameterizations 参数化和重新参数化"></a>Parameterizations and Reparameterizations 参数化和重新参数化</h3><p><strong>参数曲线是指在特定区间内由特定参数函数给出的曲线。更准确地说，参数曲线有一个给定的函数，它是参数区间的映射。让参数在从0到1的单位区间内运行通常是方便的。当自由参数在单位区间内变化时，通常用u表示。</strong></p>
<p><strong>如果我们查看参数曲线是一条直线用钢笔,我们可以考虑u = 0的时候首先放下笔在纸上和单位时间所花费的时间画出曲线(u = 1是曲线的结束)。</strong></p>
<p><strong>曲线可以通过一个将时间(在这些单位坐标中)映射到位置的函数来指定。基本上，曲线的规格是一个函数，它可以回答这样的问题，“笔在时间u时在哪里?”</strong></p>
<p><strong>如果我们已知一个函数f(t)它指定了区间[a, b]上的一条曲线，我们可以很容易地定义一个新函数f2(u)在单位区间内指定同一曲线。我们可以先定义</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111040.png" class="" title="image-20211009111040">

<p><strong>然后</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111050.png" class="" title="image-20211009111050">

<p><strong>两个函数，f和f2 两者代表同一曲线;然而，它们提供了不同的曲线参数化。为现有曲线创建新参数化的过程称为重参数化，从旧参数到新参数(本例中为g)的映射称为重参数化函数。</strong></p>
<p><strong>如果我们用某种参数化定义了一条曲线，那么就会存在无穷多的其他曲线(因为我们总是可以重新参数化)。能够有一个曲线的多个参数化是有用的，因为它允许我们创建方便的参数化。然而，它也可能是有问题的，因为它使得比较两个函数以确定它们是否代表同一条曲线变得困难。</strong></p>
<p><strong>这个问题的本质更为普遍:自由参数(或时间元素)的存在为我们的曲线表示增加了一个无形的、潜在的未知元素。当我们看到画完的曲线时，我们不一定知道时间。钢笔可能在整个时间间隔内以恒定的速度移动，或者它可能开始时很慢，然后加速。例如，虽然u = 0.5是通过参数空间的一半，但如果笔的运动开始缓慢，并在末端加速，那么它可能不是沿着曲线的一半。下面是一条非常简单的曲线:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111131.png" class="" title="image-20211009111131">

<p><strong>这三个函数在单位区间上代表同一条曲线;然而，当u不为0或1时，f(u)指的是不同的点，这取决于曲线的表示。</strong></p>
<p><strong>如果我们得到一条曲线的参数化，我们可以直接使用它作为曲线的说明，或者我们可以发展一个更方便的参数化。通常，自然参数化是以一种方便的方式创建的(或自然)来指定曲线，所以我们不需要知道沿着曲线的速度是如何变化的。</strong></p>
<p><strong>如果我们知道笔以恒定速度运动，那么自由参数的值就有更多的意义。穿过参数空间的一半就是曲线的一半。这个参数可以被认为是沿着曲线测量长度，而不是测量时间。这种参数化称为弧长参数化，因为它们通过函数定义曲线，函数从沿着曲线的距离(称为弧长)映射到位置。我们经常用变量s来表示弧长参数。</strong></p>
<p><strong>从技术上讲，如果参数化的正切(即参数化对参数的导数)的大小是常数，则参数化就是弧长参数化。用方程式表示，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111211.png" class="" title="image-20211009111211">

<p><strong>计算一条曲线的长度是很棘手的。一般来说，它是由导数的大小的积分定义的(直观地说，导数的大小是笔在曲线上移动的速度)。因此，给定参数v的值，可以计算s(沿曲线从f(0)点到f(v)点的弧长距离)为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111229.png" class="" title="image-20211009111229">

<p><strong>其中f(t)是一个用自然参数化定义曲线的函数。</strong></p>
<p><strong>使用弧长参数化要求能够解出给定s的t的上式。对于我们研究的许多类型的曲线，它不能以一种封闭的(简单的)方式来完成，而必须用数值方法来完成。</strong></p>
<p><strong>通常，我们用变量u表示单位区间内的自由参数，s表示弧长自由参数，t表示非这两个参数之一的参数。</strong></p>
<h3 id="Piecewise-Parametric-Representations-分段参数表示"><a href="#Piecewise-Parametric-Representations-分段参数表示" class="headerlink" title="Piecewise Parametric Representations 分段参数表示"></a>Piecewise Parametric Representations 分段参数表示</h3><p><strong>对于一些曲线，定义一个参数函数来表示它们的形状是很容易的。例如，线、圆和椭圆都有简单的函数，用参数定义它们所包含的点。对于许多曲线来说，找到一个指定其形状的函数是很困难的。我们创建复杂曲线的主要策略是分而治之:我们将曲线分解成许多更简单的小块，每个小块都有一个简单的描述。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111645.png" class="" title="image-20211009111645">

<p>(a)可以很容易表示为两条直线的曲线;(b)可以很容易表示为直线和圆弧的曲线;(c)一条曲线近似于(b)五条线段的曲线。</p>
<p><strong>例如，考虑上图中的曲线。前两条曲线很容易用两部分来表示。以上图(b)中的曲线为例，我们需要两种不同的部分:线段和圆。</strong></p>
<p><strong>为了创建复合曲线的参数表示(如上图(b)中的曲线)，我们需要参数函数在表示各部分的函数之间进行切换。如果我们在0≤u≤1范围内定义参数函数，则上图(a)或(b)中的曲线可以定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111749.png" class="" title="image-20211009111749">

<p><strong>f1 是第一部分f的参数化吗2 是第二部分的参数化，这两个函数都是在单位区间内定义的。</strong></p>
<p><strong>我们需要小心定义函数f1 和f2 以确保曲线的各个部分吻合。如果f1(1)≠ f2(0)，那么我们的曲线片段将不会连接，不会形成一个单一的连续曲线。</strong></p>
<p><strong>为了表示上图(b)中的曲线，我们需要使用两种不同类型的片段:线段和圆弧。为了简单起见，我们可能更喜欢使用单一类型的块。如果我们试图用一种类型的块(线段)来表示上图(b)中的曲线，我们不能准确地重新创建曲线(除非我们使用无限数量的块)。虽然由线段组成的新曲线(如上图(c))可能与上图(b)中的形状不完全相同，但它可能足够接近我们使用。在这种情况下，我们可能更喜欢使用更简单的线段，而不是使用更准确地表示形状的曲线。</strong></p>
<p><strong>同时，注意当我们使用越来越多的块时，我们可以得到一个更好的近似。在极限情况下(使用无限个碎片)，我们可以准确地表示原始形状。</strong></p>
<p><strong>使用分段表示的一个好处是，它允许我们在两者之间进行权衡</strong></p>
<p>​    <strong>1.我们所表示的曲线与我们想要表示的真实形状的近似程度;</strong></p>
<p>​    <strong>2.我们使用的部件有多复杂;</strong></p>
<p>​    <strong>3.我们用了多少块。</strong></p>
<p><strong>因此，如果我们试图表示一个复杂的形状，我们可能会决定一个粗略的近似是可以接受的，并使用少量的简单块。为了提高近似值，我们可以选择使用更多的块和使用更复杂的块。</strong></p>
<p><strong>在计算机图形实践中，我们倾向于使用相对简单的曲线段(线段、弧段或多项式段)。</strong></p>
<h3 id="Splines-样条线"><a href="#Splines-样条线" class="headerlink" title="Splines 样条线"></a>Splines 样条线</h3><p><strong>在计算机出现之前，当绘图员想要画出光滑的曲线时，他们使用的工具是一块坚硬的金属，他们可以将其弯曲成想要的形状来描画。因为金属会弯曲，而不是折叠，它会有一个光滑的形状。这种硬度意味着金属会尽可能地弯曲以达到预期的形状。这种坚硬的金属叫做花键。</strong></p>
<p><strong>数学家们发现，他们可以用分段多项式函数来表示草图样条所产生的曲线。最初，他们用样条来表示平滑的分段多项式函数。最近，样条被用来描述任何分段多项式函数。我们更喜欢后一种定义。</strong></p>
<p><strong>对我们来说，样条是一个分段多项式函数。这样的函数对于表示曲线非常有用。</strong></p>
<h2 id="Curve-Properties-曲线的性质"><a href="#Curve-Properties-曲线的性质" class="headerlink" title="Curve Properties 曲线的性质"></a><strong>Curve Properties 曲线的性质</strong></h2><p><strong>为了描述曲线，我们需要给出关于它的性质的一些事实。对于“命名”曲线，其属性通常根据曲线的类型而定。例如，为了描述一个圆，我们可以提供它的半径和圆心的位置。对于一个椭圆，我们也可以提供它的长轴的方向和轴的长度的比率。然而，对于自由形式的曲线，我们需要一组更一般的属性来描述单个曲线。</strong></p>
<p><strong>曲线的一些性质仅归因于曲线上的一个位置，而其他性质则需要整个曲线的知识。为了直观地了解两者的区别，假设曲线是一条火车轨道。如果你在一个雾天站在轨道上，你可以分辨出轨道是直的还是弯的，以及你是否在终点。这些是局部性质。你不知道这条轨迹是不是一条闭合曲线，或者它是否与自身相交，或者它有多长。我们称这种类型的属性为全局属性。</strong></p>
<p><strong>研究几何物体(曲线和曲面)的局部性质被称为微分几何。从技术上讲，作为一个微分属性，有一些数学上的限制(粗略地说，在火车轨道的类比中，你不可能有GPS或指南针)。我们不用担心这个区别，而是使用局部性质而不是微分性质。</strong></p>
<p><strong>局部性质是描述曲线的重要工具，因为它们不需要关于整个曲线的知识。局部性质包括</strong></p>
<p>​    <strong>•连续性,</strong> </p>
<p>​    <strong>•在曲线上的特定位置，</strong> </p>
<p>​    <strong>•曲线上特定位置的方向，</strong> </p>
<p>​    <strong>•曲率(和其他导数)。</strong></p>
<p><strong>通常，我们想要指定一条曲线包含一个特定的点。如果一条曲线的一个点是曲线的一部分，那么这个点就是曲线的插值点。如果参数u的某个值f(t) = v，函数f将插值一个值v。我们称插值的位置，即t的值，即位置。</strong></p>
<h3 id="Continuity-连续性"><a href="#Continuity-连续性" class="headerlink" title="Continuity 连续性"></a>Continuity 连续性</h3><p><strong>当两个参数集合在一起时，理解曲线的局部性质是非常重要的。如果曲线是使用上方程来定义的，那么我们就需要小心如何定义各个部分。如果f1(1)≠ f2(0)，那么曲线将被“打破”——我们将不能在一个连续的笔触画曲线。我们把曲线拼接在一起的条件称为连续性条件，因为如果符合连续性条件，曲线就可以画成连续的曲线。因为我们在本章开始时对“曲线”的定义要求曲线是连续的，所以从技术上讲，“破曲线”不是曲线。</strong></p>
<p><strong>除了位置之外，我们还可以检查各个片段的衍生是否匹配正确。如果f₁′(1)≠ f₂′(0)，则组合曲线在切换点处的一阶导数发生突变;一阶导数不是连续的。一般来说，我们说曲线是C^n 连续的，如果它的所有导数在n之前都匹配。我们把位置本身表示为零阶导数，这样C⁰ 连续性条件是指曲线的位置是连续的，C¹ 连续性意味着位置和一阶导数是连续的。曲线的定义要求曲线是C⁰．</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009112822.png" class="" title="image-20211009112822">

<p>两个曲线段之间各种类型的连续性的说明。</p>
<p><strong>上图给出了一些连续性条件的说明。一阶导数的不连续(曲线为C⁰ 但不是C¹)通常是显而易见的，因为它显示了一个尖锐的角落。二阶导数的不连续有时在视觉上是显而易见的。高阶导数的不连续可能会产生影响，这取决于应用。例如，如果曲线代表一个运动，二阶导数的突变是显而易见的，因此三阶导数的连续性通常是有用的。如果曲线上有流体流过(例如，如果它是飞机机翼或船壳的形状)，四阶或五阶导数的不连续可能会导致湍流。</strong></p>
<p><strong>我们刚才介绍的连续性类型(C^n)通常被称为参数连续性，因为它依赖于两个曲线块的参数化。如果每一块的“速度”不同，那么它们就不是连续的。对于我们关心曲线的形状而不是它的参数化的情况，我们定义了几何连续性，当曲线被等效地参数化时(例如，使用弧长参数化)，要求曲线各部分的导数匹配。直观上，这意味着对应的导数必须有相同的方向，即使它们有不同的大小。</strong></p>
<p><strong>所以，如果C¹连续性条件是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009113014.png" class="" title="image-20211009113014">

<p><strong>G¹ 连续性条件为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009113024.png" class="" title="image-20211009113024">

<p><strong>对于标量k的某个值。一般来说，几何连续性比参数连续性的限制小。一个C^n 曲线也是G^n 除了当参数导数消失时。</strong></p>
<h2 id="Polynomial-Pieces-分布多项式"><a href="#Polynomial-Pieces-分布多项式" class="headerlink" title="Polynomial Pieces 分布多项式"></a><strong>Polynomial Pieces 分</strong>布多项式</h2><p><strong>计算机图形学中最广泛使用的曲线表示方法是将多项式定义的基本元素拼接在一起，这些基本元素被称为多项式块。例如，线元素是由一个线性多项式给出的。在第15.3.1节中，我们给出了一个正式的定义，并解释了如何将多项式块组合在一起。</strong></p>
<h3 id="Polynomial-Notation-多项式符号"><a href="#Polynomial-Notation-多项式符号" class="headerlink" title="Polynomial Notation 多项式符号"></a>Polynomial Notation 多项式符号</h3><p><strong>多项式是这种形式的函数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010103600.png" class="" title="image-20211010103600">

<p><strong>ai 称为系数，n称为多项式的次数，如果an ≠ 0。上式也写成</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010103610.png" class="" title="image-20211010103610">

<p><strong>我们称它为多项式的标准形式。我们可以将规范形式推广到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010103620.png" class="" title="image-20211010103620">

<p><strong>bi(t)是多项式。我们可以为不同的应用选择这些多项式的方便形式，我们称它们为基函数或混合函数(见第15.3.5节)。在上上式中，t^i 是上上式中的bi(t)。如果基函数的集合被正确的选择，任何n + 1次的多项式都可以用一个适当的c来表示。</strong></p>
<p><strong>标准形式并不总是有方便的系数。为了实际的目的，在这一章中，我们将找到一组基函数，这些基函数的系数是控制由多项式函数表示的曲线的方便方法。</strong></p>
<p><strong>要指定二维中嵌入的曲线，可以指定t中的两个多项式一个是x随t变化的一个是y随t变化的;或者指定一个多项式，其中每个ai 是一个二维点。在n维空间中，任何曲线都存在类似的情况。</strong></p>
<h3 id="A-Line-Segment-A线段"><a href="#A-Line-Segment-A线段" class="headerlink" title="A Line Segment  A线段"></a>A Line Segment  A线段</h3><p><strong>为了介绍分段多项式曲线表示的概念，我们将讨论线段。在实践中，线段是如此简单，以至于数学推导看起来有些过分。然而，通过理解这个简单的例子，当我们继续学习更复杂的多项式时，事情会变得更简单。</strong></p>
<p><strong>考虑一个线段的连接点p0 p1．我们可以把这个线段在单位域中的参数函数写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104658.png" class="" title="image-20211010104658">

<p><strong>通过把它写成向量的形式，我们隐藏了点的维数以及我们分别处理每个维数的事实。例如，如果我们制作的是2D游戏，我们可以创建单独的方程式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104713.png" class="" title="image-20211010104713">

<p><strong>我们指定的直线是由两个端点决定的，但从现在开始，我们将坚持使用向量表示法，因为它更清晰。我们称控制参数的向量p为控制点，p的每个元素为控制点。</strong></p>
<p><strong>虽然用线段端点的位置来描述线段是很明显的，通常也是很方便的，但是还有其他的方法来描述线段。例如,</strong></p>
<p>​    <strong>1.线段的中心位置、方向、长度;</strong></p>
<p>​    <strong>2.一个端点的位置和第二点相对于第一点的位置;</strong></p>
<p>​    <strong>3.线段的中间和一个端点的位置。</strong></p>
<p><strong>显然，给定线段的一种描述，我们可以转换到另一种描述。</strong></p>
<p><strong>另一种描述线段的方法是使用多项式的标准形式(见第15.3.1节)，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104804.png" class="" title="image-20211010104804">

<p><strong>任何线段都可以通过指定a0 和a1 或者端点(p0 和p1)来表示．指定端点通常更方便，因为我们可以从端点计算其他参数。</strong></p>
<p><strong>为了将规范形式写成向量表达式，我们定义一个向量u，它是u的幂次向量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104814.png" class="" title="image-20211010104814">

<p><strong>多项式可表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104824.png" class="" title="image-20211010104824">

<p><strong>这种矢量表示法将使不同形式的曲线之间的转换更容易。</strong></p>
<p><strong>上面的方程用多项式的简单形式的多项式系数集描述曲线段。我们称这种表示为标准形式。我们将用a表示规范形式的参数。</strong></p>
<p><strong>虽然它在数学上很简单，但标准形式并不总是指定曲线的最方便的方法。例如，我们可能更喜欢通过线段端点的位置来指定线段。如果我们想定义p0 是段的开始(当u = 0时段是)和p1 为线段的末端(线段在u = 1处)，我们可以这样写</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105022.png" class="" title="image-20211010105022">

<p><strong>我们可以解出这些方程的a0 和a1：</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105031.png" class="" title="image-20211010105031">

<h4 id="Matrix-Form-for-Polynomials-多项式的矩阵形式"><a href="#Matrix-Form-for-Polynomials-多项式的矩阵形式" class="headerlink" title="Matrix Form for Polynomials 多项式的矩阵形式"></a>Matrix Form for Polynomials 多项式的矩阵形式</h4><p><strong>虽然第一个例子很容易解，但对于更复杂的例子，将上上式写成更容易的形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105133.png" class="" title="image-20211010105133">

<p><strong>或者，我们可以写</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105253.png" class="" title="image-20211010105253">

<p><strong>我们称之为C，约束矩阵。 如果点的向量让你感到困扰，你可以独立考虑每一个维度(所以p是[x0 x1]或[y0 y1]， a则相应处理)。</strong></p>
<p><strong>我们可以通过求C的逆矩阵来解上式。这个用B表示的逆矩阵叫做基矩阵。基矩阵是非常方便的，因为它告诉我们如何在方便的参数p和标准形式a之间转换, 因此，给了我们一个简单的方法来计算曲线</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105409.png" class="" title="image-20211010105409">

<p><strong>我们可以找到任意形式的曲线的基矩阵，只要参数的定义中没有非线性。非线性定义参数的例子包括线段的长度和角度。</strong></p>
<p><strong>现在，假设我们要参数化线段，使p0 中间点(u = 0.5)和p1 是结束点(u = 1)。为了推导这个参数化的基矩阵，我们设置</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105458.png" class="" title="image-20211010105458">

<p><strong>所以</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105507.png" class="" title="image-20211010105507">

<p><strong>因此</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105516.png" class="" title="image-20211010105516">

<h3 id="Beyond-Line-Segments-超出线段"><a href="#Beyond-Line-Segments-超出线段" class="headerlink" title="Beyond Line Segments 超出线段"></a>Beyond Line Segments 超出线段</h3><p><strong>线段是如此简单，以至于找到一个基矩阵是很简单的。然而，对于高阶曲线来说，这是一个很好的练习。首先，让我们考虑二次曲线。标准形式的优点是，它适用于这些更复杂的曲线，只是让n是一个更大的数字。</strong></p>
<p><strong>二次多项式有三个系数a0,a1和a2．这些系数不便于描述曲线的形状。然而，我们可以使用相同的基矩阵方法来设计更方便的参数。如果我们知道u的值，多项式方程在参数中成为一个线性方程，上一节的线性代数仍然有效。</strong></p>
<p><strong>假设我们想通过起始(u = 0)、中间(u = 0.5)和结束(u = 1)的位置来描述我们的曲线。在多项式中输入相应的值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105948.png" class="" title="image-20211010105948">

<p><strong>约束矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105957.png" class="" title="image-20211010105957">

<p><strong>基矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110006.png" class="" title="image-20211010110006">

<p><strong>还有一种附加类型的约束(或参数)有时很方便指定:曲线(相对于其自由参数)在特定值处的导数。直观上，导数告诉我们曲线是如何变化的，一阶导数告诉我们曲线的方向，二阶导数告诉我们曲线的方向变化有多快，等等。我们将在后面看到为什么导数是有用的例子。</strong></p>
<p><strong>二次,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110230.png" class="" title="image-20211010110230">

<p><strong>导数很简单:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110240.png" class="" title="image-20211010110240">

<p><strong>和</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110259.png" class="" title="image-20211010110259">

<p><strong>或者,更普遍的是,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110310.png" class="" title="image-20211010110310">

<p><strong>例如，考虑一个情况，我们想要指定一个二次曲线段的位置，第一和第二导数在其中间(u = 0.5)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110321.png" class="" title="image-20211010110321">

<p><strong>约束矩阵为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110331.png" class="" title="image-20211010110331">

<p><strong>基矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110341.png" class="" title="image-20211010110341">

<h3 id="Basis-Matrices-for-Cubics-三次多项式的基矩阵"><a href="#Basis-Matrices-for-Cubics-三次多项式的基矩阵" class="headerlink" title="Basis Matrices for Cubics 三次多项式的基矩阵"></a>Basis Matrices for Cubics 三次多项式的基矩阵</h3><p><strong>三次多项式在图形中很流行(见第15.5节)。各种形式的三次方程的推导就像我们在这一节中看到的推导一样。我们将通过另一个例子来练习。</strong></p>
<p><strong>三次多项式的一种非常有用的形式是Hermite形式，我们在开始和结束处指定位置和一阶导数，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110713.png" class="" title="image-20211010110713">

<p><strong>因此，约束矩阵为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110723.png" class="" title="image-20211010110723">

<p><strong>基矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110732.png" class="" title="image-20211010110732">

<p><strong>我们将在第15.5.2节讨论Hermite三次样条。</strong></p>
<h3 id="Blending-Functions-混合函数"><a href="#Blending-Functions-混合函数" class="headerlink" title="Blending Functions 混合函数"></a>Blending Functions 混合函数</h3><p><strong>如果我们知道基矩阵B，我们可以用它乘以参数向量u，得到一个函数向量</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110840.png" class="" title="image-20211010110840">

<p><strong>注意，我们用b(u)表示这个向量，以强调其值取决于自由参数u的事实。我们称b(u)中的元素为混合函数，因为它们指定了如何将控制点向量的值混合在一起:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110850.png" class="" title="image-20211010110850">

<p><strong>值得注意的是，对于选择的u值，上方程是一个线性方程，指定控制点的线性混合(或加权平均)。无论哪个次多项式”隐藏”在bi 函数中都是成立的。</strong></p>
<p><strong>混合函数为描述曲线提供了一个很好的抽象。任何类型的曲线都可以表示为其控制点的线性组合，其中这些权值被计算为自由参数的一些任意函数。</strong></p>
<h3 id="Interpolating-Polynomials-插值多项式"><a href="#Interpolating-Polynomials-插值多项式" class="headerlink" title="Interpolating Polynomials 插值多项式"></a>Interpolating Polynomials 插值多项式</h3><p><strong>一般来说，n次多项式可以插值n + 1个值的集合。如果已知向量p = (p0，…pn)和一个向量t = (t0，…tn)增加参数值，ti ≠ tj ，我们可以使用这些方法确定一个n + 1 × n + 1基矩阵它给出一个函数f(t)使f(ti) = pi．对于任意给定的向量t，我们需要建立并求解一个n = 1 × n + 1的线性方程组。这为我们提供了一组执行插值的n + 1基函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111129.png" class="" title="image-20211010111129">

<p><strong>这些插值基函数可以用其他方法导出。定义它们的一个特别优雅的方法是拉格朗日形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111139.png" class="" title="image-20211010111139">

<p><strong>有比拉格朗日形式更有效的计算方法来表示插值基函数(详见De Boor(1978))。</strong></p>
<p><strong>插值多项式提供了一种机制，用于定义插值一组点的曲线。下图显示了一些示例。虽然可以创建一个多项式来插值任意数量的点，但我们很少在计算机图形中使用高阶多项式来表示曲线。相反，插值样条(分段多项式函数)是首选。第15.5.3节讨论了一些原因。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111159.png" class="" title="image-20211010111159">

<p>通过多个点插值多项式。注意点之间额外的摆动和过冲。在(c)中，当加入第6点时，由于插值多项式的非局部性质，完全改变了曲线的形状。</p>
<h2 id="Putting-Pieces-Together-拼凑"><a href="#Putting-Pieces-Together-拼凑" class="headerlink" title="Putting Pieces Together 拼凑"></a>Putting Pieces Together 拼凑</h2><p><strong>现在我们已经看到了如何制作单独的多项式曲线，我们可以考虑如何将这些曲线组合在一起。</strong></p>
<h3 id="Knots-结"><a href="#Knots-结" class="headerlink" title="Knots 结"></a>Knots 结</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111612.png" class="" title="image-20211010111612">

<p>(a)两条线段连接三个点;(b)每个点的混合函数在右边作图。</p>
<p><strong>分段参数函数的基本思想是每一段仅在某个参数范围内使用。例如，如果我们想定义一个函数，它有两个连接三个点的分段线段(如上图(a)所示)，我们可以定义</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111649.png" class="" title="image-20211010111649">

<p><strong>f1 和f2 是两个线段各自的函数。注意，我们已经为每一部分重新调整了参数，以方便将它们的方程写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111658.png" class="" title="image-20211010111658">

<p><strong>对于分段函数中的每个多项式，都有一个起始和结束的位置(或参数值)。一个函数开始或结束的地方叫做结点。对于上上公式中的例子，结点的值是0、0.5和1。</strong></p>
<p><strong>我们也可以把分段多项式函数写成基函数的和，每个基函数以一个系数作比例。例如，可以将上上式中的两条线段改写为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111829.png" class="" title="image-20211010111829">

<p><strong>其中函数b1(u)定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111846.png" class="" title="image-20211010111846">

<p><strong>和b2 和b3 类似的定义。这些函数绘制在上图(b)中。</strong></p>
<p><strong>多项式函数的结是所有用来创建它的部件的结的组合。结向量是一个以升序存储所有结值的向量。</strong></p>
<p><strong>请注意，在本节中，我们使用了两种不同的机制来组合多项式块:为不同范围的参数使用独立的多项式块，以及将分段多项式函数混合在一起。</strong></p>
<h3 id="Using-Independent-Pieces-使用独立块"><a href="#Using-Independent-Pieces-使用独立块" class="headerlink" title="Using Independent Pieces 使用独立块"></a>Using Independent Pieces 使用独立块</h3><p><strong>在第15.3节中，我们定义了单位参数范围内的多项式。如果我们想组装这些部件，我们需要从整体功能的参数转换为部件的参数值。最简单的方法是定义参数范围[0,n]内的整体曲线，其中n是段的数量。根据参数的值，我们可以将其移动到所需的范围。</strong></p>
<h3 id="Putting-Segments-Together-拼装片段"><a href="#Putting-Segments-Together-拼装片段" class="headerlink" title="Putting Segments Together 拼装片段"></a>Putting Segments Together 拼装片段</h3><p><strong>如果我们想从两个线段制作一条曲线，我们需要确保第一个线段的末端与下一个线段的起点在同一位置。有三种方法连接这两个部分(按简单程度排序):</strong></p>
<p>​    <strong>1.将线段表示为它的两个端点，然后对两个端点使用相同的点。我们称之为共享点方案。</strong> </p>
<p>​    <strong>2.当第一个段的参数发生变化时，将第一个段末尾的值复制到第二个段的开头。我们称之为依赖模式。</strong></p>
<p>​    <strong>3.为连接写一个显式方程，当其他参数改变时，通过数值方法强制执行。</strong></p>
<p><strong>虽然更简单的方案更可取，因为它们需要更少的工作，但它们也对线段的参数化方式施加了更多的限制。例如，如果我们想使用线段的中心作为参数(以便用户可以直接指定它)，我们将使用每个线段的开始和线段的中心作为它们的参数。这将迫使我们使用依赖方案。</strong></p>
<p><strong>请注意，如果我们使用共享点或依赖方案，控制点的总数小于n∗m，其中n是段的数量，m为每段控制点的个数;独立块的许多控制点将作为其他块的函数计算。请注意,如果我们使用共同点方案行(每段两端点使用它作为参数和共享内部点与邻域),或者如果我们使用依赖方案(如示例的第一个端点、中点),我们最终得到的n + 1 控制的n段曲线。</strong></p>
<p><strong>依赖计划有一个更严重的问题。曲线上一个地方的变化可以传播到整个曲线。这被称为缺乏局部性。局部性意味着如果你移动曲线上的一个点，它只会影响一个局部性区域。局部区域可能很大，但它是有限的。如果曲线的控制没有局部性，改变一个控制点可能会影响无限远的点。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010112303.png" class="" title="image-20211010112303">

<p>具有局部控制和非局部控制的线段链。</p>
<p><strong>为了看到局部性和缺乏局部性，在行动中，考虑两链线段，如上图所示。一条链通过其端点参数化其片段，并使用点共享来保持连续性。另一种是通过端点和中点参数化片段，并使用依赖项传播将片段保持在一起。这两条线段链可以代表相同的曲线:它们都是n个连通线段的集合。但是，由于位置问题，端点共享表单可能对用户更方便。考虑改变每条链中第一个控制点的位置。对于端点共享版本，只有第一个片段会改变，而在中点版本中，所有片段都会受到影响，如上图所示。事实上，对于端点共享版本中移动的任何点，最多会有两个线段发生变化。在中点版本中，控制点移动后的所有段都将改变，即使链是无限长的。</strong></p>
<p><strong>在本例中，依赖项传播方案是没有本地控制的方案。这并不总是正确的。有不是本地的直接共享方案和本地的传播方案。</strong></p>
<p><strong>我们强调地方是一个便于控制的问题。虽然每次都改变整个曲线是不方便的，但是可以对曲线做同样的改变。它只需要同步移动几个点。</strong></p>
<h2 id="Cubics-三次曲线"><a href="#Cubics-三次曲线" class="headerlink" title="Cubics 三次曲线"></a>Cubics 三次曲线</h2><p><strong>在图形中，当我们用分段多项式来表示曲线时，我们通常用线段或三次多项式来表示这些部分。三次曲面在计算机图形学中流行的原因有很多:</strong></p>
<p>​    <strong>•分段三次多项式允许C² 连续性，通常是足以完成大多数视觉任务。二次方程提供的C¹平滑度往往不足。高阶多项式提供的更大的平滑性很少重要。</strong></p>
<p>​    <strong>•三次曲线提供了一组点的最小曲率插值。也就是说，如果你有一组n + 3个点，并定义通过它们的“最平滑”的曲线(即在其长度上曲率最小的曲线)，这条曲线可以表示为n段的分段三次曲线。</strong></p>
<p>​    <strong>•三次多项式有很好的对称性，位置和导数可以指定在开始和结束。</strong> </p>
<p>​    <strong>•三次多项式在计算中的数值问题和平滑性之间有一个很好的权衡。</strong> </p>
<p><strong>注意，我们不必使用三次方程;它们只是在平滑度和复杂性之间的一个很好的权衡。不同的应用程序可能有不同的权衡。我们关注的是曲线，因为它们是最常用的。</strong></p>
<p><strong>三次多项式的标准形式是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011104409.png" class="" title="image-20211011104409">

<p><strong>正如我们在第15.3节中讨论的，这些标准形式系数不是描述三次线段的方便方法。</strong></p>
<p><strong>我们寻求三次多项式的形式，其系数是一种方便的方式来控制由三次表示的结果曲线。便利的主要方式之一将是提供确保各部分的连接和各部分之间的连续性的方法。</strong></p>
<p><strong>每个三次多项式块需要四个系数或控制点。这意味着对于一个有n个分段的多项式，如果分段之间没有共享或没有使用依赖，我们可能需要多达4n个控制点。更常见的情况是，每个片段的某些部分要么是共享的，要么依赖于相邻的片段，因此控制点的总数要低得多。另外，请注意控制点可能是曲线的一个位置或一个导数。</strong></p>
<p><strong>不幸的是，对于分段曲线并没有单一的“最佳”表示。不可能有一个分段多项式曲线表示具有下列所有理想性质:</strong></p>
<p>​    <strong>1.曲线的每一部分都是曲线的;</strong></p>
<p>​    <strong>2.曲线插值控制点;</strong></p>
<p>​    <strong>3.曲线具有局部控制;</strong></p>
<p>​    <strong>4.曲线上有C² 连续性。</strong></p>
<p><strong>我们可以有这些性质中的任意三个，但不是全部四个;有三种形式的任意组合。在这本书中，我们将讨论三次B样条，不插值它们的控制点(但有局部控制，是C²);插值它们的控制的基数样条和Catmull-Rom样条点和提供本地控制，但不是C²;和插值的自然三次方程是C²，但没有局部控制。</strong></p>
<p><strong>三次曲线的连续性是指线段之间(结点处)的连续性。三次元本身的导数有无限的连续性(我们一直在讨论的连续性)。注意，如果你有许多控制点(或结点)，曲线可能会摇摆，这可能看起来并不“平滑”。</strong></p>
<h3 id="Natural-Cubics-自然三次曲线"><a href="#Natural-Cubics-自然三次曲线" class="headerlink" title="Natural Cubics 自然三次曲线"></a>Natural Cubics 自然三次曲线</h3><p><strong>使用分段三次曲线，可以创建C²曲线。为了做到这一点，我们需要在每一段的开始指定位置和一阶导数和二阶导数(以便我们可以确保它与前一段的末尾相同)。注意，每个曲线段从链中先前曲线的四个参数中接收三个。这些C² 三次曲线的连续链有时被称为自然三次样条。</strong></p>
<p><strong>对于自然三次曲线的一部分，我们需要通过端点的位置和起始点的一阶导数和二阶导数来参数化三次曲线。因此控制点是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011104920.png" class="" title="image-20211011104920">

<p><strong>因此约束矩阵为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011104931.png" class="" title="image-20211011104931">

<p><strong>基矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011104942.png" class="" title="image-20211011104942">

<p><strong>给定一组n个控制点，自然三次样条有n - 1个三次分段。第一段使用控制点来定义它的起始位置、结束位置以及起始处的一阶导数和二阶导数。一个依赖计划复制第一段末端的位置和第一、二阶导数，以便在第二段中使用。</strong></p>
<p><strong>自然三次样条的一个缺点是它们不是局部的。任何部分的改变都可能需要整个曲线的改变(至少是改变后的部分)。更糟糕的是，自然的三次样条往往是病态的:曲线开始的一个小变化可能导致后来的大变化。另一个问题是，我们只能控制曲线开始时的导数。曲线开始后的部分决定了它们从起始点开始的导数。</strong></p>
<h3 id="Hermite-Cubics-Hermite三次曲线"><a href="#Hermite-Cubics-Hermite三次曲线" class="headerlink" title="Hermite Cubics Hermite三次曲线"></a>Hermite Cubics Hermite三次曲线</h3><p><strong>第15.3.4节介绍了Hermite三次多项式。三次埃尔米特样条的一段允许指定其两个端点的位置和一阶导数。一段链可以连接成一个C¹ 样条的位置和导数使用相同的值为一段的结束和下一段的开始。</strong></p>
<p><strong>给定一组n个控制点，其中每一个控制点都是导数值，三次Hermite样条包含(n - 2)/2曲线段。样条插值点，如下图所示，但只能保证C¹连续性。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011105222.png" class="" title="image-20211011105222">

<p>由三段组成的埃尔米特三次样条。</p>
<p><strong>埃尔米特曲线很方便，因为它们提供了对形状的局部控制，并提供了C¹ 连续性。但是，由于用户必须同时指定位置和求导，因此必须为导数提供一个特殊的界面。一种可能是为用户提供一些点，这些点表示导数向量如果被“放置”在位置点上将会在哪里结束。</strong></p>
<h3 id="Cardinal-基数三次曲线"><a href="#Cardinal-基数三次曲线" class="headerlink" title="Cardinal 基数三次曲线"></a>Cardinal 基数三次曲线</h3><p><strong>基数三次样条是C¹ 的一种类型插值由三次多项式段组成的样条。给定一组n个控制点，用基数三次样条N - 2三次多项式段，以插值除第一个和最后一个点的所有点。</strong></p>
<p><strong>基数样条有一个称为张力的参数，它控制曲线在插值点之间的“紧”程度。张力是一个在[0,1)范围内的数字，它控制曲线如何向下一个控制点弯曲。对于t = 0的重要特殊情况，样条被称为Catmull-Rom样条。</strong></p>
<p><strong>基数样条的每一段使用四个控制点。对于线段i，使用的点是i, i + 1, i + 2和i + 3，因为线段与它们的邻居共享三个点。每个部分从第二个控制点开始，到第三个控制点结束。曲线开始处的导数由第一控制点与第三控制点之间的向量决定，曲线结束处的导数由第二控制点与第四个控制点之间的向量决定，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110152.png" class="" title="image-20211011110152">

<p>内基数三次样条的一段将其第二和第三个控制点(p2 和p3)，并利用它的其他点来确定起点和终点的导数。</p>
<p><strong>张力参数调整导数缩放的大小。具体来说，导数是(1 - t)/2。因此立方上的约束是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110255.png" class="" title="image-20211011110255">

<p><strong>求解控制点的这些方程(定义s = (1 - t)/2)得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110309.png" class="" title="image-20211011110309">

<p><strong>这就得到基数矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110320.png" class="" title="image-20211011110320">

<p><strong>由于线段i的第三个点是线段i+1的第二个点，基数样条曲线的相邻线段连接起来。类似地，同样的点被用来指定每一段的一阶导数，提供C¹连续性。</strong></p>
<p><strong>基数样条是有用的，因为它们提供了一种简单的方法来插值一组具有C¹连续性和局部控制的点。它们只是C¹，所以有时会出现“扭结”。张力参数可以控制插值点之间的变化，如下图所示通过一组点的基数样条集合显示。这些曲线使用相同的控制点，但它们使用不同的张力参数值。注意，第一个和最后一个控制点没有插入。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110449.png" class="" title="image-20211011110449">

<p>基数样条通过张力参数t的变化值的七个控制点。</p>
<p><strong>给定一组n个点进行插值，您可能会想，为什么我们可能更喜欢使用基数三次样条(即n - 2个曲线的集合)，而不是第15.3.6节中描述的单个n阶多项式。插值多项式的一些缺点是:</strong></p>
<p>​    <strong>•插值多项式趋于过冲点，如下图所示。随着分数的增加，这种超值会变得更糟。基数样条曲线趋向于在点之间表现良好。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110636.png" class="" title="image-20211011110636">

<p>样条插值9个控制点(用小叉标记)。粗橙色的线表示一个插值多项式。这条细线表示 Catmull-Rom样条。后者是由七个曲线片段，每个显示在交替的蓝色色调。</p>
<p>​    <strong>•对插值多项式的控制不是局部的。改变样条开始的一个点会影响整个样条。基数样条是局部的:样条上的任何位置最多受四个相邻点的影响。</strong></p>
<p>​    <strong>•对插值多项式的评估不是局部的。求多项式上的一个点需要访问它的所有点。在分段曲线上计算一个点需要固定的少量计算，不管总点数有多大。</strong></p>
<p><strong>在使用插值样条时，随着点的数量增加，还有许多其他的数值和技术问题。更多信息请参阅De Boor(2001)。</strong></p>
<p><strong>基数样条有一个缺点，它不能插值第一个或最后一个点，这可以很容易地通过在序列的任何一端添加一个额外的点来固定。基数样条也不是连续的——只在结点处提供C¹连续性。</strong></p>
<h2 id="Approximating-Curves-近似曲线"><a href="#Approximating-Curves-近似曲线" class="headerlink" title="Approximating Curves 近似曲线"></a>Approximating Curves 近似曲线</h2><p><strong>控制曲线最简单的方法似乎是指定一组点来进行插值。然而，在实践中，插值方案往往有不理想的特性，因为它们的连续性较差，并且无法控制点之间发生的情况。通常首选只近似于点的曲线方案。在近似方案中，控制点影响曲线的形状，但不精确地指定它。虽然我们放弃了直接指定要通过的曲线点的能力，但我们获得了更好的曲线行为和局部控制。如果我们需要插值一组点，可以计算控制点的位置，使曲线通过这些插值点。</strong></p>
<p><strong>计算机图形学中两种最重要的近似曲线是B´ezier曲线和B样条曲线。</strong></p>
<h3 id="B´ezier-Curves-贝塞尔曲线"><a href="#B´ezier-Curves-贝塞尔曲线" class="headerlink" title="B´ezier Curves 贝塞尔曲线"></a>B´ezier Curves 贝塞尔曲线</h3><p><strong>B´ezier曲线是计算机图形学中自由曲线最常见的表现形式之一。这些曲线以Pierre B´ezier的名字命名，他是这些曲线发展的重要贡献者之一。B´ezier曲线有一个有趣的历史，它们是由几个独立的小组同时开发的。</strong></p>
<p><strong>B´ezier曲线是近似其控制点的多项式曲线。这些曲线可以是任意次的多项式。d度曲线由d + 1个控制点控制。曲线插入它的第一个和最后一个控制点，并且形状直接受到其他点的影响。</strong></p>
<p><strong>通常，复杂的形状是由一些低度B´ezier曲线连接而成的，在计算机图形学中，三次(d = 3) B´ezier曲线通常用于这一目的。许多流行的插图程序，如Adobe Illustrator和字体表示方案，如Postscript中使用的，使用二次B´ezier曲线。B´ezier曲线在计算机图形学中非常受欢迎，因为它们易于控制，有许多有用的属性，并且有非常有效的算法来处理它们。</strong></p>
<p><strong>B´ezier曲线是这样构造的:</strong></p>
<p>​    <strong>•曲线插值第一个和最后一个控制点，u分别为0和1。</strong> </p>
<p>​    <strong>•曲线开始(结束)处的一阶导数由第一个和第二个控制点(倒数第二个和倒数第二个控制点)之间的向量决定。导数是由这些点之间的向量根据曲线的度数缩放得到的。</strong></p>
<p>​    <strong>•曲线起点(终点)的高阶导数取决于曲线起点(终点)的点。n^th 导数取决于前(后)n + 1个点。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111515.png" class="" title="image-20211011111515">

<p>三次B´ezier曲线由四个点控制。它插值第一和最后，开始和最终的导数是前两个(或后两个)点之间向量的三倍。</p>
<p><strong>例如，考虑上图中3度(立方)的B´ezier曲线。曲线有四个(d + 1)控制点。它从第一个控制点(p0)，并以最后(p1)．开始时的一阶导数与第一和第二控制点(p1 −p0)．具体来说，f′(0) = 3(p1 −p0)．类似地，曲线末端的一阶导数是由f ′(1) = 3(p3 −p2)．曲线开始处的二阶导数可以由控制点p0，p1 和p2确定．</strong></p>
<p><strong>利用上一段关于B´ezier三次方程的事实，我们可以使用第15.5节的方法为它们创建一个参数函数。定义由开始和结束的插值和导数给出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111715.png" class="" title="image-20211011111715">

<p><strong>这可以用基矩阵来求解</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111725.png" class="" title="image-20211011111725">

<p><strong>然后写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111740.png" class="" title="image-20211011111740">

<p><strong>或</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111750.png" class="" title="image-20211011111750">

<p><strong>bi,3 是3级B´ezier混合函数:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111800.png" class="" title="image-20211011111800">

<p><strong>幸运的是，B´ezier曲线的混合函数有一种特殊的形式，适用于所有程度。这些函数被称为伯恩斯坦基多项式，并具有一般形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111926.png" class="" title="image-20211011111926">

<p><strong>其中n为B´ezier曲线的阶数，k为0和n(含)之间的混合函数数。C(n, k)为二项式系数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111935.png" class="" title="image-20211011111935">

<p><strong>已知控制点pk的位置，求n阶(n + 1个控制点)B´ezier曲线的函数为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111946.png" class="" title="image-20211011111946">

<p><strong>一些B´ezier片段如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112027.png" class="" title="image-20211011112027">

<p>2-6度的各种B´ezier片段。控制点用十字形显示，控制多边形(连接控制点的线段)也显示出来。</p>
<p><strong>B´ezier片段有几个有用的属性:</strong></p>
<p>​    <strong>•曲线以控制点的凸包为界。</strong> </p>
<p>​    <strong>•直线与曲线相交的次数不超过与控制点相连的线段集相交的次数。这叫做变分递减性质。该属性如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112134.png" class="" title="image-20211011112134">

<p>B´ezier曲线的变化递减特性意味着曲线不会比它的控制多边形更越过一条线。因此，如果控制多边形没有“摆动”，曲线上也不会有它们。B样条(第15.6.2节)也具有这个属性。</p>
<p>​    <strong>•曲线是对称的:反向控制点的顺序产生相同的曲线，具有反向的参数化。</strong></p>
<p>​    <strong>•曲线是仿射不变的。这意味着平移、缩放、旋转或倾斜控制点与在曲线上执行这些操作是相同的。</strong></p>
<p>​    <strong>•有很好的简单的算法来评估和细分B´ezier曲线到块本身是B´ezier曲线。因为细分 可以使用后面描述的算法有效地完成，分治方法可以用于创建重要任务的有效算法，如绘制B´ezier曲线，用线段逼近它们，并确定两条曲线之间的交集。</strong></p>
<p><strong>当B´ezier段连接在一起形成一个样条时，段之间的连通性通过共享端点创建。然而，导数的连续性必须通过定位其他控制点来实现。这为B´ezier样条的用户提供了平滑的控制。对于G¹连续性，第一条曲线的倒数第二点和第二条曲线的第二点必须与等值的端点共线。对于C′ 连续，点之间的距离也必须相等。如下图所示。适当地定位更多的点可以创造更高的连续性。</strong></p>
 <img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112302.png" class="" title="image-20211011112302">

<p>两个B´ezier片段连接形成C¹样条曲线，因为第一个线段的最后两点之间的向量等于第二个线段的前两点之间的向量。</p>
<h4 id="Geometric-Intuition-for-Bezier-Curves-B´ezier曲线的几何外观"><a href="#Geometric-Intuition-for-Bezier-Curves-B´ezier曲线的几何外观" class="headerlink" title="Geometric Intuition for Bezier Curves B´ezier曲线的几何外观"></a>Geometric Intuition for Bezier Curves B´ezier曲线的几何外观</h4><p><strong>B´ezier曲线可以从几何原理中得到，也可以从上面描述的代数方法中得到。我们概述了几何原理，因为它们提供了关于B´ezier曲线如何工作的直觉。</strong></p>
<p><strong>假设我们有一组控制点，我们想从这些控制点创建一条平滑的曲线。简单地用直线连接点(形成控制多边形)将导致一些非光滑的东西。它会有尖角。我们可以想象通过切掉尖锐的角来“平滑”这个多边形，生成一个更平滑的新多边形，但在数学意义上仍然不是“平滑”的(因为曲线仍然是一个多边形，因此只有C¹)。我们可以重复这个过程，每次生成一个更平滑的多边形，如下图所示。在极限情况下，也就是如果我们无限次重复这个过程，我们会得到一条C¹平滑的曲线。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112528.png" class="" title="image-20211011112528">

<p>二次B´ezier的细分过程。每条线段被分成两半，这些中点是相连的(蓝色的点和线)。内部控制点移动到新线段的中点(橙色点)。</p>
<p><strong>我们对切角所做的就是定义一个细分方案。也就是说，我们通过将简单的曲线分解成更小的部分(例如，细分它)来定义曲线。由此得到的曲线是极限曲线，它是通过无限次应用该过程而得到的。如果细分方案定义正确，结果将是一个平滑的曲线，它将有一个参数形式。</strong></p>
<p><strong>让我们考虑将切角应用于单个角落。给定三分(p0,p1,p2)，我们重复“切掉边角”，如下图所示。在每一步中，我们将每个线段分成两半，连接中点，然后将角点移动到新线段的中点。注意，在这个过程中，引入新的点，移动一次，然后在任何剩余的迭代中保持在这个位置。端点永远不会移动。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112650.png" class="" title="image-20211011112650">

<p>通过反复切割多边形的棱角，我们可以得到一条光滑的曲线。</p>
<p><strong>如果我们计算p2 的“新”位置作为中点的中点，我们得到表达式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112735.png" class="" title="image-20211011112735">

<p><strong>这种结构实际上适用于每段距离的其他比例。如果我们让u是每一段的起点和终点之间的距离也就是我们放置中点的地方，我们可以把这个表达式改写为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112745.png" class="" title="image-20211011112745">

<p><strong>重组项给出了二次B´ezier函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112759.png" class="" title="image-20211011112759">

<h4 id="The-de-Casteljau-Algorithm-de-Casteljau算法"><a href="#The-de-Casteljau-Algorithm-de-Casteljau算法" class="headerlink" title="The de Casteljau Algorithm de Casteljau算法"></a>The de Casteljau Algorithm de Casteljau算法</h4><p><strong>B´ezier曲线的一个很好的特征是，有一个非常简单和通用的方法来计算和细分它们。这种方法被称为de Casteljau算法，使用一系列线性插值来计算沿着任意顺序的B´ezier曲线。它是前一节中描述的细分方案的推广。</strong></p>
<p><strong>de Casteljau算法首先用直线连接每一个相邻的点集，然后找到这些直线上的u插值点，给出n - 1个点集。这些点被直线连接，这些直线被插值(同样由u)，给出一组n - 2个点。这个过程不断重复，直到有一个点。下图显示了这个过程的说明。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011113445.png" class="" title="image-20211011113445">

<p>一个关于三次B´ezier的de Casteljau算法的说明。左边的图像显示了u = 0.5的构造。右边的图像显示了0.25、0.5和0.75的构造。</p>
<p><strong>计算B´ezier线段上的点的过程也提供了在该点上分割线段的方法。在de Casteljau算法中计算的中间点形成了新的更小的线段的新的控制点，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011113539.png" class="" title="image-20211011113539">

<p>采用de Casteljau算法对三次B´ezier分段进行细分。初始点(黑方块A, B, C和D)被线性插值以产生蓝色圆圈(AB, BC, CD)，线性插值以产生橙色圆圈(AC, BD)，线性插值以给出立方体AD上的点。这个过程还将控制点A,B,C,D的B´ezier段细分为两个控制点A, AB, AC, AD和AD, BD, CD, D的B´ezier段。</p>
<p><strong>B´ezier曲线分割算法的存在使分治算法成为可能。例如，当绘制B´ezier曲线时，它很容易检查曲线是否接近直线，因为它有其凸包为界。如果曲线的控制点都接近共线，则可以将曲线画成直线。否则，曲线可以被分割成更小的块，并且这个过程可以重复。类似的算法可以用来确定两条曲线的交点。由于这类算法的存在，其他曲线表示通常被转换成B´ezier形式进行处理。</strong></p>
<h3 id="B-Splines-B样条"><a href="#B-Splines-B样条" class="headerlink" title="B-Splines B样条"></a>B-Splines B样条</h3><p><strong>B样条提供了一种方法，可以用一个由d次多项式组成的曲线来近似一组n个点，从而使C^(d−1)具有连续性。与前一节的B´ezier样条不同，B样条允许生成任意连续性程度的曲线(几乎达到点的数量)。因此，B样条是指定计算机图形中非常光滑的曲线(高连续性)的首选方法。如果我们想要C² 或更高的曲线，B样条可能是正确的方法。</strong></p>
<p><strong>我们可以用B样条基函数的线性组合来表示曲线。由于这些基函数本身就是样条，所以我们简称它们为基样条或B样条。每个B样条或基函数由一组d阶的d + 1多项式组成。B样条的方法提供了定义这些函数的一般程序。</strong></p>
<p><strong>B样条是指其中一个基函数，而不是由一组b样条线性组合而成的函数。然而，这一术语在计算机图形学中的使用并不一致。通常，“B样条曲线”是指由B样条的线性组合表示的曲线。</strong></p>
<p><strong>将一个多项式表示为其他多项式的线性组合的想法已在15.3.1节和15.3.5节中讨论。将样条表示为其他样条的线性组合，见章节15.4.1。事实上，给出的例子是B样条的一个简单例子。</strong></p>
<p><strong>将一个函数表示为其他函数的线性组合的一般符号是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011114018.png" class="" title="image-20211011114018">

<p><strong>pi 是系数，bi 是基函数。如果系数是点(例如，2或3个向量)，我们将它们称为控制点。使这种方法工作的关键是定义bi 适当。B样条提供了一种非常通用的方法。</strong></p>
<p><strong>可以为若干系数n和参数值k定义一组B样条。k的值比用于制作B样条的多项式的次数多 (k = d + 1)。</strong></p>
<p><strong>B样条很重要，因为它们提供了一种非常通用的方法来创建具有许多有用属性的函数(对于表示曲线很有用)。参数值为k的B样条曲线有n个点:</strong></p>
<p>​    <strong>•是C^(k−2) 连续的;</strong> </p>
<p>​    <strong>•由k - 1次多项式构成;</strong> </p>
<p>​    <strong>•具有局部控制-曲线上的任何位置仅依赖于k个控制点;</strong> </p>
<p>​    <strong>•被点的凸包所包围;</strong> </p>
<p>​    <strong>•显示出图15.12所示的变化递减特性。</strong></p>
<p><strong>使用B样条创建的曲线不一定插值其控制点。</strong></p>
<p><strong>我们将通过先看一个具体的、简单的例子来介绍b样条的概念。然后我们将推广这些方法并说明它们为什么有趣。因为计算B样条的方法是非常普遍的，所以我们推迟引入它，直到我们展示了这些泛化是什么。</strong></p>
<h4 id="Uniform-Linear-B-Splines-统一的线性B样条"><a href="#Uniform-Linear-B-Splines-统一的线性B样条" class="headerlink" title="Uniform Linear B-Splines 统一的线性B样条"></a>Uniform Linear B-Splines 统一的线性B样条</h4><p><strong>考虑以下形式的一组基函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011114628.png" class="" title="image-20211011114628">

<p><strong>每个函数看起来都像一个小三角“帽子”在i和i+2之间，其峰值在i+ 1。每一个都是分段多项式，在i i + 1和i + 2处打结。其中两个如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011114714.png" class="" title="image-20211011114714">

<p>d = 1或k = 2的B样条。</p>
<p><strong>每个函数都是bi,2 为一阶(线性)B样条。因为我们将在后面考虑其他参数值的B样条，所以我们用下标2表示它们。</strong></p>
<p><strong>注意，我们选择将B样条的下缘(它的第一个结)放在i处。因此，第一个B样条(i = 1)的第一个结是在1处。对b样条或系数向量元素的迭代从1到n(见上上公式)。当B样条被实现时，以及在其他许多关于B样条的讨论中，它们通常从0到n−1进行编号。</strong></p>
<p><strong>我们可以使用上上式从n个控制点的集合中创建一个函数，这些函数用于bi 创建一个受系数影响的“整体函数”。如果我们使用这些(k = 2) B样条来定义整个函数，我们将定义一个线性插值系数pi 在t = k和t = n + 1之间的分段多项式函数。注意，当(k = 2) B样条插值它们的所有系数时，更高阶的B样条在某些特定条件下这样做，我们将在第15.6.3节中讨论。</strong></p>
<p><strong>B样条的一些性质可以在这个简单的例子中看到。我们将用参数k和系数或控制点的数目n写成一般形式:</strong></p>
<p><strong>•每个B样条有k + 1个结点。</strong> </p>
<p><strong>•每个B样条在第一个结之前和最后一个结之后都是零。</strong> </p>
<p><strong>•整体样条具有局部控制，因为每个系数只乘以一个B样条，并且这个B样条仅在k + 1节之间是非零的。</strong></p>
<p><strong>•整个样条有n + k个结点。</strong> </p>
<p><strong>•每个B样条为C^(k−2) 连续的，因此整个样条为C^(k−2) 连续的。</strong> </p>
<p><strong>•对于节点k和n+1之间的所有参数值，B样条和为1的集合。这个范围是有k条B样条是非零的。求和为1是很重要的，因为这意味着B样条是平移不变的:平移控制点将平移整个曲线。</strong></p>
<p><strong>•在每个结点之间，B样条是一个d = k−1次的单一多项式。因此，整体曲线(将这些加在一起)也可以表示为任意相邻结点之间的单次d多项式。</strong></p>
<p><strong>在这个例子中，我们选择了均匀间隔的结点。稍后我们将讨论非均匀间距的B样条。当结间距是均匀的，每个B样条都是相同的，除了移位。具有均匀结点间距的B样条有时称为均匀B样条或周期B样条。</strong></p>
<h4 id="Uniform-Quadratic-B-Splines-二次均匀B样条"><a href="#Uniform-Quadratic-B-Splines-二次均匀B样条" class="headerlink" title="Uniform Quadratic B-Splines 二次均匀B样条"></a>Uniform Quadratic B-Splines 二次均匀B样条</h4><p><strong>前一节中列出的B样条的性质是特意为任意n和k编写的。构造B样条的一般过程将在稍后提供，但首先，让我们考虑k = 3的另一种特殊情况。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132249.png" class="" title="image-20211011132249">

<p>均匀结点间距的B样条b2,3。</p>
<p><strong>B样条2,3 如上图所示。它是由二次块(2度)组成的，有三个。这是C¹ 连续的，并且只在它跨越的四个节内是非零的。请注意，二次B样条由三块组成，一块在结1和2之间，一块在结2和3之间，一块在结3和4之间。在第15.6.3节中，我们将看到构建这些函数的一般过程。现在，我们简单地检查以下函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132341.png" class="" title="image-20211011132341">

<p><strong>为了使表达式更简单，我们把函数的每一部分都写成在0到1的范围内。</strong></p>
<p><strong>如果我们计算由B样条之和组成的整体函数，在任何时候只有k(本例中为3)是非零的。一个在上方程的第一部分，一个在第二部分，一个在第三部分。因此，我们可以把整个函数的任何一部分看作是存在的由一个依赖于k个系数的d = k−1次多项式组成。对于k = 3的情况，我们可以这样写</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132437.png" class="" title="image-20211011132437">

<p><strong>其中u = t−i。它定义了当i≤t &lt; i+1时整个函数的一部分。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132532.png" class="" title="image-20211011132532">

<p>7条B样条的集合，k = 3，结点间距均匀[1,2,3,4,5,6,7,8,10]</p>
<p><strong>如果我们有一组n个点，我们可以用B样条来创建一条曲线。如果我们有7个点，我们需要一组7条B样条。上图显示了k = 3时的一组7条B样条。注意到有n + k(10)个结点，B样条的和在k到n + 1的范围内是1(结点3到8)。下图显示了使用这些B样条和一组点指定的曲线。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132544.png" class="" title="image-20211011132544">

<p>由7条二次(k=3) B样条组成的曲线，使用7个控制点。</p>
<h4 id="Uniform-Cubic-B-Splines-均匀三次B样条"><a href="#Uniform-Cubic-B-Splines-均匀三次B样条" class="headerlink" title="Uniform Cubic B-Splines 均匀三次B样条"></a>Uniform Cubic B-Splines 均匀三次B样条</h4><p><strong>由于三次多项式在计算机图形学中非常流行，因此k = 4的B样条的特殊情况是非常重要的，因此我们在讨论一般情况之前考虑它。三次B样条由四个三次多项式块定义。决定这些部分的一般过程稍后描述，但结果是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133009.png" class="" title="image-20211011133009">

<p><strong>度3 B样条曲线在下图中为i = 1绘制。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133135.png" class="" title="image-20211011133135">

<p>具有均匀结的三次(k = 4) B样条。</p>
<p><strong>我们可以将节点i + 3和i + 4之间的整体曲线的函数写成参数u在0到1之间的函数以及影响它的四个控制点的函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133023.png" class="" title="image-20211011133023">

<p><strong>这可以用前面几节的矩阵表示法重写，给出三次B样条的基矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133033.png" class="" title="image-20211011133033">

<p><strong>与第15.5节中从约束中导出的矩阵不同，这个矩阵是由下一节中定义的一般B样条程序确定的多项式创建的。</strong></p>
<h3 id="Nonuniform-B-Splines-非均匀B样条"><a href="#Nonuniform-B-Splines-非均匀B样条" class="headerlink" title="Nonuniform B-Splines 非均匀B样条"></a>Nonuniform B-Splines 非均匀B样条</h3><p><strong>B样条的一个很好的特征是它们可以被定义为任何k&gt; 1。因此，如果我们需要一条更平滑的曲线，我们只需增加k的值，如图15.23所示。</strong></p>
<p><strong>到目前为止，我们已经说过B样条可推广到任何k&gt; 1和任何n≥d。在我们展示如何实际计算这些B样条之前，还要介绍最后一个推广。B样条定义为任何非递减结向量。</strong></p>
<p><strong>对于给定的n和k, B样条集合(以及由它们的线性组合创建的函数)有n + k个结点。我们可以把这些结点的值写成向量，我们用t表示。对于均匀B样条，结点向量是[1,2,3，…，n + k]。然而，对于长度为n + k的任何结点向量，只要其值是非递减的(例如，ti+1 ≥ti)．</strong></p>
<p><strong>有两个主要原因非均匀结间距是有用的:它让我们控制参数范围每个系数影响的整体功能,它允许我们重复节(例如,创建节之间没有间隔的)以创建函数不同的属性在这些点。后者将在本节稍后讨论。</strong></p>
<p><strong>为B样条指定结点值的能力类似于为插值样条曲线指定插值点的能力。它允许我们将曲线特征与参数值联系起来。通过指定非均匀结向量，我们指定B样条曲线的每个系数影响的参数范围。记住B样条i只在结点i和结点i + k之间是非零的，因此，与它相关的系数只影响这些参数值之间的曲线。</strong></p>
<p><strong>对结值的控制特别有用的一个地方是在序列开始处插入或删除结。为了说明这一点，考虑a如第15.6.2节所述，使用线性B样条(k = 2)定义的曲线。对于n = 4，均匀结向量是[1,2,3,4,5,6]。这条曲线由四个点控制，参数范围为t = 2到t = 5。曲线(t = 5)的“末端”插入最后一个控制点。如果我们在点集的中间插入一个新的点，我们将需要一个更长的结向量。B样条的局域性可以防止这种插入影响曲线端点的值。较长的曲线仍然会在其末端插入最后一个控制点。但是，如果我们选择保持均匀的结点间距，则新的结点向量为[1,2,3,4,5,6,7]。曲线的末端将在t = 6处，最后一个控制点所插入的参数值将与插入前的参数值不同。对于非均匀的结间距，我们可以使用结向量[1,2,3,3.5,4,5,6]，这样曲线的端点不受变化的影响。具有非均匀结点间距的能力使得B样条的局部性既具有代数性质，又具有几何性质。</strong></p>
<p><strong>现在我们介绍定义B样条的一般方法。给定系数n、B样条参数k和结点向量t(长度为n + k)的值，下列递归方程定义B样条:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133615.png" class="" title="image-20211011133615">

<p><strong>这个方程叫做Cox-de Boor递归式。它可以用来计算特定B样条的特定值。然而，它更常用于代数推导方程，如方程上上和上上上两式。</strong></p>
<p><strong>例如，考虑如何导出上上上式。使用一个均匀结向量[1,2,3，…]，ti = i，则上式中的k = 3得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133721.png" class="" title="image-20211011133721">

<p><strong>继续递归式，我们必须对递归表达式求值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133744.png" class="" title="image-20211011133744">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133754.png" class="" title="image-20211011133754">

<p><strong>将这些结果代入上式得到:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133843.png" class="" title="image-20211011133843">

<p>*<em>要知道这个表达式等价于15.17式，我们注意到每个(k = 1) B样条就像一个开关，只在特定的参数范围内打开。例如,乙</em>i,<em>1 在I和I + 1之间只有非零。所以，如果i≤t &lt; i + 1，表达式中只有(k = 1) b样条中的第一个是非零的，所以</em>*</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133852.png" class="" title="image-20211011133852">

<p><strong>类似的操作给出了15.17式的其他部分。</strong></p>
<h4 id="Repeated-Knots-and-B-Spline-Interpolation-重复结点和B样条插值"><a href="#Repeated-Knots-and-B-Spline-Interpolation-重复结点和B样条插值" class="headerlink" title="Repeated Knots and B-Spline Interpolation 重复结点和B样条插值"></a>Repeated Knots and B-Spline Interpolation 重复结点和B样条插值</h4><p><strong>虽然B样条有许多很好的特性，但使用它们定义的函数通常不会插值系数。如果我们要用它们来定义一条曲线来插值一个特定的点，这可能会很不方便。我们简要介绍了如何使用B样条插值特定的点。更完整的讨论可以在章节注释中列出的书中找到。</strong></p>
<p><strong>使B样条插值其系数的一种方法是重复打结。如果一个特定b样条的所有内部结点都有相同的值，那么整个函数将插值这个B样条的系数。如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011134057.png" class="" title="image-20211011134057">

<p>由7个控制点的二次b样条(k = 3)参数化的曲线。在左边，使用均匀结向量[1,2,3,4,5,6,7,8,9,10]。右侧为非均匀结间距[1,2,3,4,4,6,7,8,8,10]重复第4和第8个结点意味着第3和第7个B样条的所有内部结点都是相等的，所以曲线插值与这些点相关的控制点。</p>
<p><strong>重复结点的插值代价很高:它消除了B样条的光滑性以及由此产生的整体函数和表示曲线。然而，在样条的开始和结束，连续性不是一个问题，结重复是有用的创建端点插值B样条。虽然第一个(或最后一个)结点的值对插补并不重要，为了简单起见，我们让第一个(或最后一个)k个结点具有相同的值来实现插补。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011134352.png" class="" title="image-20211011134352">

<p>端点插值二次(k = 3) b样条，对于n = 8。结向量是[0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 6]。前两个B样条和后两个B样条是非周期性的，而中间四个B样条(如虚线所示)是周期性的，与图15.20中的B样条相同。</p>
<p><strong>端点插值二次B样条如上图所示。前两个B样条和后两个B样条不同于均匀B样条。他们的表达,通过使用Cox-de Boor递归式可以推导出:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011134411.png" class="" title="image-20211011134411">

<h3 id="NURBS"><a href="#NURBS" class="headerlink" title="NURBS"></a>NURBS</h3><p><strong>尽管B样条提供了所有的一般性，但仍有一些函数不能用它们精确地表示。特别是b样条不能代表圆锥截面。为了表示这样的曲线，使用了两个多项式的比率。非均匀B样条被用来表示分子和分母。最普遍的形式是非均匀有理B样条，简称为NURBS。</strong></p>
<p><strong>NURBS与标量权值hi 相关联使用相同的B样条:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011134727.png" class="" title="image-20211011134727">

<p><strong>bi,k,t 为参数k和结向量t的B样条。</strong><br><strong>在几何建模中，NURBS被广泛地用于表示曲线和曲面，因为除了B样条的有用特性外，它们还提供了惊人的通用性。</strong></p>
<h2 id="Summary-总结"><a href="#Summary-总结" class="headerlink" title="Summary 总结"></a>Summary 总结</h2><p><strong>在本章中，我们讨论了自由形式曲线的一些表示。对于计算机图形学来说，最重要的是:</strong></p>
<p>​    <strong>•基数样条使用一组立方块来插值控制点。它们通常比插值多项式更可取，因为它们是局部的，更容易计算。</strong></p>
<p>​    <strong>•B´ezier曲线近似它们的控制点，并有许多有用的属性和相关算法。由于这个原因，它们在图形应用程序中很受欢迎。</strong></p>
<p>​    <strong>•B样条曲线将曲线表示为b样条函数的线性组合。它们是一般的，有许多有用的性质，如凸包和变分递减。当需要光滑曲线时，通常使用B样条。</strong></p>
<h1 id="16-Computer-Animation-计算机动画"><a href="#16-Computer-Animation-计算机动画" class="headerlink" title="16 Computer Animation 计算机动画"></a>16 Computer Animation 计算机动画</h1><p><strong>动画来源于拉丁语anima，意为赋予生命、兴趣、精神、运动或活动的行为、过程或结果。运动是生命的定义属性，动画的真正艺术主要是关于如何通过运动来讲述故事、表现情感，甚至表达人类性格的微妙细节。计算机是实现这些目标的辅助工具——一个熟练的动画师可以使用它来帮助更快地得到他想要的结果，而不必专注于他不感兴趣的技术细节。没有电脑的动画，也就是现在经常被称为“传统”的动画，有着悠久而丰富的历史，不断被数以百计的活跃在这门艺术中的人所写。正如在任何既定领域一样，已经明确了一些经过时间考验的规则，这些规则为如何做某些事情和应避免哪些事情提供了一般的高层指导。传统动画的这些原则同样适用于计算机动画，我们将在本章讨论其中的一些。</strong></p>
<p><strong>然而，计算机不仅仅是一个工具。除了让动画师的主要任务变得不那么乏味外，计算机还添加了一些以前无法获得或很难获得的真正独特的能力。现代建模工具允许相对容易创建详细的三维模型,渲染算法可以产生一系列令人印象深刻的表象,从完全逼真到高度程式化,强大的数值模拟算法可以帮助为特别难以产生预期的基于物理运动动画对象和动作捕捉系统的能力记录和使用真实的动作。这些发展导致了计算机动画技术在电影和广告、汽车设计和建筑、医学和科学研究等许多领域的爆炸式应用。全新的领域和应用也出现了，包括全电脑动画电影，虚拟/增强现实系统，当然还有电脑游戏。</strong></p>
<p><strong>本书的其他章节更直接地涵盖了上面提到的许多发展(例如，几何建模和渲染)。在这里，我们只提供一个概述的技术和算法直接用于创建和操纵运动。特别地，我们将粗略区分并简要描述四种主要的计算机动画方法:</strong></p>
<p>​    <strong>•关键帧为动画师提供了最直接的控制，他们在某些时刻提供了必要的数据，而计算机填补了其余的时间。</strong></p>
<p>​    <strong>•程序动画涉及专门设计的，通常是经验的，数学函数和程序，其输出类似于某些特定的运动。</strong></p>
<p>​    <strong>•基于物理的技术求解运动微分方程。</strong> </p>
<p>​    <strong>•动作捕捉使用特殊的设备或技术来记录真实世界的动作，然后将这个动作转换到计算机模型中。</strong> </p>
<p><strong>我们在这里完全不涉及这个领域的艺术方面。一般来说，我们不可能在这里做更多，而仅仅是对用计算机创造运动这一迷人主题的皮毛。我们希望真正对这一主题感兴趣的读者能够在本章内容之外继续他们的旅程。</strong></p>
<h2 id="Principles-of-Animation-动画原理"><a href="#Principles-of-Animation-动画原理" class="headerlink" title="Principles of Animation 动画原理"></a>Principles of Animation 动画原理</h2><p><strong>John Lasseter在他1987年的SIGGRAPH论文(Lasseter, 1987)中提出了早在20世纪30年代由迪士尼工作室的传统动画师开发的关键原则，引起了当时刚刚起步的电脑动画社区的注意。12个原则被提及:挤压和伸展，节奏，预期，跟随和重叠动作，慢进和慢出，舞台，弧线，次级动作，直线前进和姿势对姿势的动作，夸张，扎实的绘画技巧，和吸引力。近20年过去了，这些经过时间考验的规则依然重要，它们可以将自然而有趣的动画与机械而乏味的动画区别开来。另外，对于计算机动画来说，平衡控制和灵活性的赋予是非常重要的动画师充分利用计算机的能力。虽然这些原则是众所周知的，但许多因素影响着在实践中对这些规则的重视程度。虽然制作故事片的角色动画师可能会花很多时间遵循这些建议(游戏邦注:例如调整自己的时间)，但许多游戏设计师倾向于将时间花在其他地方。</strong></p>
<h3 id="Timing-节奏"><a href="#Timing-节奏" class="headerlink" title="Timing 节奏"></a>Timing 节奏</h3><p><strong>节奏，或者说动作的速度，是任何动画的核心。事情发生的速度会影响行动的意义、情绪状态，甚至是相关物体的感知重量。同样的动作，角色的头从左向右转，取决于其速度，可以意味着任何反应，从被重物击中到缓慢地在书架上寻找一本书或伸展颈部肌肉。为手头的具体行动设定适当的时间是非常重要的。动作要占用足够的时间来引起注意，同时要避免动作过于缓慢和潜在的无聊。对于涉及录制声音的计算机动画项目，声音提供了一个自然的时间锚。事实上，在大多数制作中，演员的声音首先被记录下来，然后完整的动画被同步到这个记录中。由于大而重的物体往往比小而轻的物体移动得慢(更准确地说，加速度更小)，计时可以用来提供有关物体重量的重要信息。</strong></p>
<h3 id="Action-Layout-行动布局"><a href="#Action-Layout-行动布局" class="headerlink" title="Action Layout 行动布局"></a>Action Layout 行动布局</h3><p><strong>在动画的任何时刻，观众都应该清楚地知道所呈现的是什么想法(情感、情绪、表情)。好的阶段，或高层次的行动计划，应该引导观众的眼睛到当前重要的行动集中的地方，有效地告诉他“看看这个，现在，看看这个”，而不使用任何语言。对人类感知的一些熟悉可以帮助我们完成这项艰巨的任务。由于人类的视觉系统主要对相对变化而不是刺激的绝对值做出反应，所以在静止的环境中突然运动或在繁忙的场景中某些部分缺乏运动，自然会引起人们的注意。呈现相同的动作，所以物体的轮廓变化通常比正面的安排更引人注目(见下图(左下角))。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012122313.png" class="" title="image-20211012122313">

<p>行动的布局。左:恰当地安排动作对于引起人们对当前重要动作的注意至关重要。举起手的动作在顶部会很明显，但在底部则很难注意到。相反，在第一种情况下，鼻子长度的变化可能是完全看不见的。注意，这可能是故意隐藏的，例如，稍后突然显示出来。如果两个议案都要处理，那么这两种安排都不是特别好。中:预期的多少可以说明接下来的动作。接下来的动作(扔球)很短，但很清楚将要发生什么。角色越紧张，接下来的动作就会越快。右图:后续阶段对次要附属物(头发)尤其重要，它的运动跟随主导部分(头部)。头部的运动非常简单，但会导致头发本身的不平凡的跟随行为。在这种情况下，如果没有后续阶段和重叠动作，就不可能创建一个自然的动画。Peter Shirley和Christina Villarruel提供的数字。</p>
<p><strong>在较低的层次上，每个动作可以分为三个部分:预期(动作的准备)、动作本身和后续(动作的终止)。在许多情况下，动作本身是最短的部分，从某种意义上说，最有趣的。例如，踢足球可能需要踢球者进行大量的准备工作，对即将离开的球进行长时间的“视觉追踪”，并有足够的机会显示当时的压力、踢球者的情绪状态，甚至是对行动预期结果的反应。动作本身(腿踢球的动作)是相当简单的，在这种情况下只需要几分之一秒。</strong></p>
<p><strong>预期的目的是让观众对将要发生的事情有所准备。如果动作本身非常快，这一点就变得尤为重要重要的，或极其困难的。为这些操作创建更广泛的预期可以突出这些属性，并且在快速事件的情况下，可以确保操作不会被遗漏(参见上图(底部中间))。</strong></p>
<p><strong>在现实生活中，主要动作通常会导致一个或多个其他重叠动作。物体的不同附属物或松散部分通常拖在主要引导部分的后面，并在如上图(右下)所示的主要动作的后续部分继续移动一段时间。此外，下一个动作通常在前一个动作完全结束之前就开始了。一个球员可能会在他还在追踪他刚刚踢出的球的时候开始奔跑。忽略这种自然流动通常会被认为是动作之间有停顿，并可能导致类似机器人的机械运动。虽然重叠是保持动作自然的必要条件，但动画师通常会添加次要动作，使动作更有趣，并实现动画的现实复杂性。重要的是不要让次要动作支配主要动作。</strong></p>
<h3 id="Animation-Techniques-动画技术"><a href="#Animation-Techniques-动画技术" class="headerlink" title="Animation Techniques 动画技术"></a>Animation Techniques 动画技术</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123048.png" class="" title="image-20211012123048">

<p>应用壁球的经典例子和拉伸原理。注意，弹跳球的体积应该在整个动画中保持大致相同。</p>
<p><strong>一些特定的技术可以用来使动作看起来更自然。最重要的可能是挤压和拉伸，这意味着在移动的物体移动时，以特定的方式改变其形状。人们通常会沿着运动方向拉伸一个物体，并在施加一个力时将其压扁，如上图所示，这是一个弹跳球的经典动画。重要的是要保持总体积，因为这发生，以避免幻觉的增长或缩小的对象。运动的速度(或力)越大，施加的拉伸(或挤压)就越多。使用这种变形有几个原因。对于非常快的运动，一个物体可以在两个连续的帧之间快速移动，以至于在当前帧和前一帧之间没有重叠，这可能导致频闪(走样的一种变体)。物体在运动方向上被拉长可以确保更好的重叠，并帮助眼睛对抗这种不愉快的效果。拉伸/挤压也可以用来显示物体的灵活性，对柔韧的材料应用更多的变形。如果物体看起来是刚性的，那么当它移动时，它的形状就会故意保持不变。</strong></p>
<p><strong>自然运动很少发生在直线上，所以在动画中应该避免使用弧线。同样，在现实世界中，没有任何运动可以瞬间改变速度——这需要对物体施加无限大的力。在动画中也要避免这种情况。特别是，运动应该逐渐开始和结束(缓慢的进和出)。而手绘动画有时是通过直接的动作完成的动画师从第一帧开始，连续绘制一帧接着一帧，直到最后一帧，姿势对姿势的动作，也被称为关键帧，更适合于计算机动画。在这种技术中，动画是通过一系列相对稀疏的关键帧来精心规划的，只有在设置了关键帧之后，动画的其余部分(中间帧)才会被填充(下图)。这允许更精确的计时，并允许计算机使用下一节介绍的算法来处理过程中最乏味的部分——创建中间帧。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123150.png" class="" title="image-20211012123150">

<p>关键帧(顶部)鼓励详细行动计划，而直接的行动(下)导致一个更自发的结果。</p>
<p><strong>以上提到的几乎所有技术都可以通过适当的夸张来实现更大的艺术效果，或强调动作或角色的某些特定属性。最终目标是实现观众想要看到的东西，吸引人的东西。角色或动作的极端复杂性或过于对称往往不太吸引人。为了创造好的效果，传统的动画师需要扎实的绘画技能。类似地，一个计算机动画师当然应该理解计算机图形学，并且对他使用的工具有扎实的知识。</strong></p>
<h3 id="Animator-Control-vs-Automatic-Methods-动画控制vs-自动方法"><a href="#Animator-Control-vs-Automatic-Methods-动画控制vs-自动方法" class="headerlink" title="Animator Control vs. Automatic Methods 动画控制vs.自动方法"></a>Animator Control vs. Automatic Methods 动画控制vs.自动方法</h3><p><strong>在传统动画中，动画师完全控制制作过程的各个方面，没有什么能阻止最终产品按照计划中的每个细节制作。为这种灵活性付出的代价是，每一个框架都是手工创建的，这导致了一个极其耗时和劳动的企业。在计算机动画中,有一个明确的权衡,一方面,给一个动画师更直接的控制结果,但要求他提供更多的工作,另一方面,依靠更自动化的技术可能需要设置几个输入参数,但提供很少或没有控制结果的一些属性。一个好的算法应该提供足够的灵活性，同时只要求动画师提供直观、容易提供的信息，以及动画师自己认为是实现预期效果所必需的信息。虽然在实践中不太可能完全符合这一要求，因为它可能需要接近读心术的机器，但我们鼓励读者从提供这种平衡的角度来评估任何计算机动画技术。</strong></p>
<h2 id="Keyframing-关键帧"><a href="#Keyframing-关键帧" class="headerlink" title="Keyframing 关键帧"></a>Keyframing 关键帧</h2><p><strong>术语“关键帧”在应用于3D计算机动画时可能会产生误导，因为没有实际完成的帧(例如。例如，图像)。在任何给定时刻,一个3d场景动画是由一组数字:指定的位置的中心对象,他们的RGB颜色,扩展应用到每个对象的数量在每个轴,建模复杂对象的不同部分之间的转换,相机位置和姿态,光源强度等。为了使场景动画化，这些值的一些子集必须随着时间而改变。当然，我们可以在每一帧中直接设置这些值，但这并不是特别有效。除此之外，一些重要的时刻(关键帧tk)可以沿着动画的时间轴选择每个参数和该参数的值(关键值fk)只设置这些选定的帧。我们称之为一个组合(tkfk)的关键帧和关键值只是一个关键。对于不同的参数，关键帧不一定是相同的，但至少同时设置其中一些关键帧是合乎逻辑的。例如，为特定对象的x、y和z坐标选择的关键帧可能被设置在形成单个位置矢量键(tk,pk)的完全相同的帧。然而，这些关键帧可能与为对象的方向或颜色选择的帧完全不同。关键帧之间的距离越近，动画师对结果的控制就越强;然而，必须评估更多设置关键的工作的成本。因此，动画中相对简单的部分的键之间通常有较大的间距，将它们集中在复杂动作发生的间隔中，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123541.png" class="" title="image-20211012123541">

<p>不同模式的设置键(上面的黑色圆圈)可以同时用于相同的场景。假设在这部分之前和之后都有更多的帧。</p>
<p><strong>一旦动画师设置了关键帧(tk,fk)，系统必须计算所有其他帧的f值。虽然我们最终只对一组离散的值感兴趣，但将其视为经典插值问题是很方便的，它通过提供的一组数据点来拟合连续动画曲线f(t)(下图)。关于曲线拟合算法的广泛讨论可以在第一章中找到15分钟，这里就不重复了。因为动画器最初只提供键而不提供导数(切线)，所以直接从键计算所有必要信息的方法对于动画来说更可取。参数沿曲线变化的速度由曲线对时间的导数(df/dt)给出。因此，为了避免速度的突然跳跃，C¹ 连续性通常是必要的。动画曲线通常不需要更高程度的连续性，因为二阶导数(对应于加速度或施加的力)在现实世界中可能会经历非常突然的变化(球撞到坚实的墙壁)，而更高的导数并不直接对应于物理运动的任何参数。这些考虑使Catmull-Rom样条曲线成为初始动画曲线创建的最佳选择之一。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123552.png" class="" title="image-20211012123552">

<p>曲线f(t)是通过动画师提供的关键帧匹配的，即使只有在帧位置的值是感兴趣的。该函数的导数给出了参数变化的速度，并首先由拟合程序自动确定。</p>
<p><strong>大多数动画系统都允许动画师对初始曲线进行交互式精细编辑，包括插入更多键、调整现有键或修改自动计算的切线。另一种有助于调整曲线形状的有用技术叫做TCB控制(TCB代表张力、连续性和偏差)。这个想法是引入三个新的参数，可以用来修改曲线的形状附近的关键，通过协调调整进入和出切线在这一点。对于时间均匀间隔的键，它们之间的距离为Δt，输入Ti^in 的标准Catmull-Rom表达式和外向的Ti^out 在内部键(tk,fk)可以重写为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123912.png" class="" title="image-20211012123912">

<p><strong>TCB样条的修正切线为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123924.png" class="" title="image-20211012123924">

<p><strong>张力参数t通过缩放进线和出线的切线来控制键附近曲线的锐度。较大的切线(较低的张力)导致键附近较平坦的曲线形状。偏置b允许动画师有选择地增加键的相邻键的权重，将曲线拉得更接近连接键与其左邻(b接近1，“超过”动作)或右邻(b接近−1，“低于”动作)的直线。连续值c的非零值使得进出的切线不同，允许动画师在曲线的键值处创建扭结。TCB参数的实际有用值通常限于区间[−1;1]，默认t = c = b = 0对应于原始的Catmull-Rom样条。下图显示了可能的曲线形状调整的例子。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012124024.png" class="" title="image-20211012124024">

<p>使用TCB控件编辑默认插值样条(中间列)。注意，所有的关键帧都保持在相同的位置。</p>
<h3 id="Motion-Controls-运动控制"><a href="#Motion-Controls-运动控制" class="headerlink" title="Motion Controls 运动控制"></a>Motion Controls 运动控制</h3><p><strong>到目前为止，我们已经描述了如何通过键定位和微调键的切线值来控制动画曲线的形状。然而，当一个人想要同时控制物体的移动方向时，这通常是不够的。它的路径，以及它沿着这条路径移动的速度。给定空间中的一组位置作为关键帧，自动曲线拟合技术可以通过它们来拟合曲线，但由此产生的运动只能通过迫使对象在相应的关键帧tk处到达指定的关键位置pk来约束，没有直接说明按键之间的移动速度。这可能会产生问题。例如，如果一个物体沿着x轴以每秒11米的速度移动1秒，然后以每秒1米的速度移动9秒，它将在10秒后到达x = 20的位置，从而满足动画师的关键帧(0,0)和(10,20)。这种不稳定的运动不太可能是真正想要的，速度为2米/秒的匀速运动可能更接近动画师设置这些键时想要的效果。虽然通常不显示这种极端行为，由标准拟合程序得出的多项式曲线确实显示出按键之间的非匀速运动，如下图所示。虽然这可以容许(在一定范围内)对一些参数的人类视觉系统不是很好确定速度不均匀性的变化(如颜色甚至旋转速度),我们必须做得更好位置p对象的速度直接对应于日常经验。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012132922.png" class="" title="image-20211012132922">

<p>所有三个运动都沿着相同的二维方向路径并满足黑色三角形尖端的键集。白色三角形的尖端以Δt = 1的间隔显示对象的位置。按键之间的匀速运动可能更接近动画师的要求，但自动装配程序可能导致其他两个动作中的任何一个。</p>
<p><strong>我们将首先区分拟合过程中使用的曲线参数化和动画中使用的曲线参数化。当一条曲线通过位置键拟合时，我们将结果写成某个参数u的函数p(u)。这将描述曲线在空间中的几何形状。弧长s是曲线的物理长度。动画师控制沿着现有曲线运动的一个自然方法是指定一个额外的函数s(t)，它对应于物体在任何给定时间沿着曲线应该走多远。为了得到空间中的实际位置，我们还需要一个辅助函数u(s)，它计算给定弧长s下的参数值u。然后将这些函数组合起来，给出给定时间t下计算物体位置的完整过程(见下图):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012133022.png" class="" title="image-20211012133022">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012133034.png" class="" title="image-20211012133034">

<p>为了获得给定时间t的空间位置，首先利用用户指定的运动控制来获得沿着曲线s(t)的距离，然后计算相应的曲线参数值u (s (t))。先前拟合的曲线P(u)现在可用来求位置P(u(s(t)))。</p>
<p><strong>可以使用几个标准函数作为距离-时间函数s(t)。其中最简单的是与恒定速度对应的线性函数:s(t) = vt, v = const。另一个常见的例子是恒定加速度a(和初始速度v0)的运动由抛物线s(t) = v0t +at²/ 2。由于速度在这里是逐渐变化的，这个函数可以帮助模拟理想的放松进入和放松退出行为。更一般地，s(t)的斜率给出了与沿曲线向后运动相对应的负斜率的运动速度。要达到最大的灵活性，就要有能力交互式编辑通常是由动画系统提供给动画师的。距离-时间函数并不是控制运动的唯一方法。在某些情况下，用户指定一个速度-时间函数v(t)或加速度-时间函数a(t)可能更方便。由于这些对应的是s(t)的一阶和二阶导数，为了使用这些类型的控制，系统首先通过对用户输入进行积分来恢复距离-时间函数(在a(t)的情况下是两次)。</strong></p>
<p><strong>曲线参数u与弧长s的关系由系统自动建立。在实践中，系统首先确定弧长与参数u(即反函数s(u))。利用这个函数，对于任意给定的S，都有可能解出方程s (u)−S = 0，而未知量u是u(S)。对于大多数曲线，函数s(u)不能用封闭解析形式表示，需要进行数值积分(见第14章)。标准的数值寻根程序(例如牛顿-拉夫森方法)可以直接用来求解方程s(u) - S = 0。</strong></p>
<p><strong>另一种方法是将曲线本身近似为点pi 之间的一组线段在一组间距足够密集的参数值ui处计算．然后创建一个近似弧长的表格</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012133656.png" class="" title="image-20211012133656">

<p><strong>由于s(u)是u的一个非递减函数，我们可以通过简单的搜索表找到包含值S的区间(见下图)。然后对区间的u值进行线性插值，最终找到u(S)。如果需要更高的精度，可以采用以这个值为起点的牛顿-拉夫森算法的几个步骤。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012133835.png" class="" title="image-20211012133835">

<p>要创建s(u)的表格版本，这条曲线可以用若干条线段来近似表示，这些线段的连接点位于曲线上的参数增量相等。在表格中查找给定S的u-interval。例如，在上面的曲线中，S = 6.5位置对应的u值位于u = 0.6和u = 0.8之间。</p>
<h3 id="Interpolating-Rotation-插值旋转"><a href="#Interpolating-Rotation-插值旋转" class="headerlink" title="Interpolating Rotation 插值旋转"></a>Interpolating Rotation 插值旋转</h3><p><strong>上面介绍的技术可以用来插入用于描述场景的大多数参数的键集。三维旋转是一种重要的运动，其插值方法和表示方法较为专门。这样做的原因是，将标准技术应用于3D旋转经常会导致严重的实际问题。旋转(物体方向的改变)是除平移外唯一能保持物体形状不变的运动。因此，它在动画刚性物体中起着特殊的作用。</strong></p>
<p><strong>有几种方法可以指定对象的方向。首先，可以使用第六章中描述的变换矩阵。不幸的是,天真的(逐元素)旋转矩阵的插值不会产生正确的结果。例如，在2D时钟和逆时针90度旋转之间的“中间”矩阵就是零矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134027.png" class="" title="image-20211012134027">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134118.png" class="" title="image-20211012134118">

<p>三个欧拉角可以通过围绕嵌入到对象中的坐标轴(Y轴总是指向锥尖)的三次旋转序列来指定对象的任意方向。注意，每个旋转都是在一个新的坐标系中给出的。固定角度表示非常类似，但它使用的坐标轴在空间中是固定的，不随对象旋转。</p>
<p><strong>当然，正确的结果是，单位矩阵对应于无旋转。第二，可以指定任意方向，作为一个围绕特定顺序选择的坐标轴进行三次旋转的序列。这些轴可以固定在空间中(固定角度表示)或嵌入到物体中，因此在每次旋转后都会发生变化(如上图所示的欧拉角表示)。这三个旋转角度可以通过标准关键帧直接动画，但一个微妙的问题称为万向节锁出现。如果在旋转过程中，三个旋转轴中的一个意外地与另一个对齐，从而减少了一个可用的自由度，如下图所示。这种效果比人们想象的要普遍得多，向右(或左)一个90度的转弯就可能把一个物体放进万向节锁中。最后，可以通过在空间中选择合适的轴和围绕该轴的旋转角度来指定任何方向。虽然在这种表现中动画是相对简单的，结合两个旋转，即找到与由轴和角表示的两个旋转序列相对应的轴和角是很重要的。一种特殊的数学装置，四元数已经被开发出来，使这种表示既适用于将几个旋转组合成一个旋转，也适用于动画。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134225.png" class="" title="image-20211012134225">

<p>在这个例子中，万向节锁发生在绕Z轴作90度旋转。现在，X轴和Y轴的旋转都是围绕同一轴进行的，导致失去一个自由度。</p>
<p><strong>给定一个三维矢量v = (x, y, z)和一个标量s，四元数q将这两个组合成一个四分量对象:q = [s x y z] = [s;v)。几个然后为四元数定义新的操作。四元数加法简单地分别和标量和向量部分:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134320.png" class="" title="image-20211012134320">

<p><strong>乘以标量a得到一个新的四元数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134338.png" class="" title="image-20211012134338">

<p><strong>更复杂的四元数乘法定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134406.png" class="" title="image-20211012134406">

<p><strong>其中×为向量叉积。很容易看出，与矩阵相似，四元数乘法是结合律，但不是交换律。我们最感兴趣的是归一化四元数——四元数范数|q| = √（s² + v²） 等于1。最后一个定义是逆函数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134416.png" class="" title="image-20211012134416">

<p><strong>以角度φ表示绕经过原点的轴旋转，原点的方向由归一化四元数n给出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134427.png" class="" title="image-20211012134427">

<p><strong>就形成了。要旋转点p，就把它变成四元数qp = [0;p]并计算四元数积</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134437.png" class="" title="image-20211012134437">

<p><strong>它的标量部分为0旋转后的点作为它的向量部分。复合旋转简单地由表示每个单独旋转步骤的四元数乘积给出。使用四元数动画，可以将它们视为四维空间中的点，并在这个空间中直接设置键。为了保持四元数归一化，我们应该严格地将插值过程限制在这个四维空间中的一个单位球体(一个三维物体)。然而，球面线性插值(通常称为slerp)已经导致了相当令人不快的数学运算。简单的四维线性插值，然后在单位球面上进行投影，如下图所示，这在实践中要简单得多，通常也足够了。通过重复使用de Casteljau算法的线性插值过程，可以得到更平滑的结果。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134754.png" class="" title="image-20211012134754">

<p>插值四元数应该在嵌入在四维空间中的三维单位球体的表面。然而，沿着4D直线(开圆)进行更简单的插值，然后再将结果投影到球体上(黑圆)通常就足够了。</p>
<h2 id="Deformations-变形"><a href="#Deformations-变形" class="headerlink" title="Deformations 变形"></a>Deformations 变形</h2><p><strong>虽然物体变形技术可能更适合作为建模工具，但传统上它们是与动画方法一起讨论的。可能改变对象形状的操作最简单的例子是不均匀缩放。更普遍地说，一些函数可以应用于指定对象的所有点的局部坐标(例如三角形网格的顶点或样条曲面的控制多边形)，重新定位这些点并创建一个新的形状:p′= f(p， γ)，其中γ为变形函数所使用的参数向量。选择不同的f(并通过一个接一个的应用组合它们)可以帮助创建非常有趣的变形。如下图所示的有用的简单函数示例包括弯曲、扭曲和锥度。在这种情况下，通过关键帧变形函数的参数，动画形状变化是非常容易的。这种技术的缺点包括难以为一些非标准变形选择数学函数，以及产生的变形是全局的，因为在某种意义上，整个对象而不仅仅是它的一部分被重塑。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013110938.png" class="" title="image-20211013110938">

<p>整体变形的流行例子。弯曲和扭曲角度，以及锥度，都可以动画实现动态形状变化。</p>
<p><strong>为了在局部变形对象的同时提供对结果的更直接的控制，可以选择单个顶点，将其移动到一个新的位置，并根据种子顶点在一些邻域内调整顶点。受变形影响的区域和物体不同部分的具体位移量是由衰减函数控制的，衰减函数随着距离(通常是在物体表面计算的)到种子顶点的距离减小。种子顶点运动可以通过关键帧产生动画形状变化。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013111208.png" class="" title="image-20211013111208">

<p>对FFD点阵进行调整，会导致失稳物体的形成。</p>
<p><strong>更一般的变形技术称为自由形式变形(FFD) (Sederberg &amp; Parry, 1986)。首先建立一个局部(在大多数情况下是直线的)坐标网格来封装要变形的对象部分，并计算所有相关点的坐标(s, t, u)相对于这个网格。然后，用户自由地将晶格点Pijk的网格重塑为一个新的扭曲晶格P′ijk (上图)。在B´ezier插值(见第15章)的三变量模拟中，使用在原始未变形网格中计算的坐标重建对象，并使用扭曲的晶格点P′Ijk在这个表达式中作为控制点的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013111310.png" class="" title="image-20211013111310">

<p><strong>式中，L, M, N为每维格点的最大指标。实际上，晶格充当了物体变形的低分辨率版本，允许任意复杂物体的平滑形状变化通过相对较少的直观调整。FFD晶格本身可以被系统视为规则对象，并可以进行转换、动画，甚至在必要时进一步变形，从而导致晶格所附着的对象发生相应的变化。例如，移动变形工具，由原始点阵和变形点阵组成，它们代表了一个跨越物体的凸起，结果是一个凸起在物体上移动。</strong></p>
<h2 id="Character-Animation-角色动画"><a href="#Character-Animation-角色动画" class="headerlink" title="Character Animation 角色动画"></a>Character Animation 角色动画</h2><p><strong>铰接图形的动画通常通过关键帧和专门的变形技术的组合来执行。动画角色模型通常包含至少两个主要层，如下图所示。观众最终将在最终产品中看到的是代表角色外壳或皮肤的高度详细的表面的运动。它下面的骨架是一个关节的层次结构(树)，它提供了图形的运动学模型，专门用于动画。在某些情况下，在骨骼和皮肤之间插入与肌肉大致对应的额外中间层。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013111912.png" class="" title="image-20211013111912">

<p>(左)关节的层次结构，一个骨架，作为角色的运动抽象;(中)重新定位骨骼使附加在它上的单独皮肤物体变形;(右)树数据结构被用来表示骨架。为了紧凑，隐藏了几个节点的内部结构(它们与对应的同级节点相同)。</p>
<p><strong>骨骼的每一个关节都是它下面的层次结构的父级。根代表整个角色，直接位于世界坐标系中。如果一个将关节与其层次结构中的父关节相关联的局部变换矩阵是可用的，那么就可以得到一个将任何关节的局部空间与世界系统相关联的变换。通过简单地沿着从根到关节的路径连接转换)。评估整个骨架(即在此基础上，对整个关节树)进行深度优先遍历。转换堆栈是帮助完成这一任务的自然数据结构。向下遍历树时，将当前的复合矩阵推入堆栈，并通过将当前矩阵与存储在节点上的矩阵相乘创建一个新的矩阵。当回溯到父分支时，这个额外的转换应该在访问另一个分支之前撤销;这很容易做到，只需弹出堆栈。尽管这种评估层次结构的通用而简单的技术在整个计算机图形中都被使用，但在动画(和机器人技术)中，它被赋予了一个特殊的名称——正向运动学(FK)。虽然可以使用所有转换的一般表示，但通常使用特定的参数集(如链接长度或关节角度)来指定骨架。为了进行正运动学动画，所有关节的旋转参数都是直接操作的。该技术还允许动画师改变关节之间的距离(链接长度)，但你应该知道，这与肢体伸展相对应，通常看起来相当不自然。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112154.png" class="" title="image-20211013112154">

<p>正运动学(上图)要求动画师将所有关节放入正确的位置。在逆运动学(下)中，一些内部关节的参数是基于期望的末端执行器运动计算的。</p>
<p><strong>正运动学需要用户为运动中涉及的所有关节设置参数(上图(上))。然而，这些关节大多属于层级的内部节点，它们的运动通常不是动画师想要担心的事情。在大多数情况下，动画师只是想让它们“自己”自然地移动，而人们更感兴趣的是指定关节链端点的行为，这通常与执行特定动作的东西相对应，如踝关节或指尖。动画师宁愿让所有内部关节的参数由系统自动从末端执行器的运动来确定。逆运动学(IK)允许我们这样做(见上图(下))。</strong></p>
<p><strong>设x为末端执行器的位置，α为指定从根到最终关节的链条上所有内部关节所需的参数向量。有时最终关节的方向也是由动画师直接设置的，在这种情况下，我们假设相应的变量包含在向量x中。然而，为了简单起见，我们将写出向量的所有具体表达式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112249.png" class="" title="image-20211013112249">

<p><strong>由于x中的每个变量都是α的函数，所以它可以写成向量方程x = F(α)。如果我们将内部关节参数改变少量δα，末端执行器位置的变化δx可以近似表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112259.png" class="" title="image-20211013112259">

<p><strong>其中∂F/∂α是偏导数矩阵称为雅可比矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112308.png" class="" title="image-20211013112308">

<p><strong>在每一个时刻，我们都知道末端执行器的期望位置(由动画师设置)，当然，也知道执行器的当前位置。两者相减，我们将得到期望的调整值δx。雅可比矩阵的元素与当特定的内部参数改变而其他参数保持不变时末端执行器坐标的变化有关(见下图)。这些元素可以使用几何关系计算任何给定的骨架配置。在(16.1)方程组中，唯一剩下的未知数是内部参数α的变化。一旦我们解决了它们，我们更新α = α+δα，这为FK程序重新定位骨骼提供了所有必要的信息。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112513.png" class="" title="image-20211013112513">

<p>部分的导数∂x/∂αknee以Δx/Δαknee的极限给出。效应器位置是在除膝盖外，所有关节都是固定。</p>
<p><strong>不幸的是，系统通常不能解析地解决，而且，在大多数情况下，它是不受约束的，即。，未知关节内部参数α的个数超过向量x中变量的个数。这意味着骨架的不同运动可以导致末端的相同运动效应。下图显示了一些示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112856.png" class="" title="image-20211013112856">

<p>多个配置的内部关节可以导致同样的效应器，另一个帮助动画抓取位置。(上)脱节的“翻转”解决方案;(下)溶液的连续统一体。</p>
<p><strong>对于这样的系统，有许多方法可以获得特定的解决方案，包括那些考虑到现实生活中某些关节所需要的自然约束(例如，只向一个方向弯曲膝盖)。我们还应该记住，计算出来的雅可比矩阵只对一个特定的配置有效，它必须随着骨架的移动而更新。完整的IK框架如下图所示。当然，IK的根关节不必是整个层次结构的根，多个IK求解器可以应用到骨架的独立部分。例如，可以使用分开右脚和左脚的求解器和用右手，每个都有自己的根。。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013113117.png" class="" title="image-20211013113117">

<p>逆运动学算法图。</p>
<p> <strong>结合FK和IK方法通常用于制作骨骼动画。许多常见的运动(步行或跑步循环，抓握，伸手等)显示出众所周知的相互关节运动模式，使快速成为可能创建自然看起来的运动，甚至使用这样的“剪辑”库。然后动画师根据角色的物理参数调整这个通用的结果，并赋予它更多的个性。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013113328.png" class="" title="image-20211013113328">

<p>上:硬皮蒙皮顶点到一个特定的关节。属于肘关节的部分用黑色表示;软蒙皮可以混合几个关节的影响。显示肘关节的重量(重量越轻=重量越大)。注意关节附近皮肤内侧光滑的皮肤变形。</p>
<p><strong>当骨骼改变它的位置时，它作为一种特殊类型的变形器应用于角色的皮肤。通过为每个蒙皮顶点分配一个(刚性蒙皮)或多个(光滑蒙皮)关节作为驱动，运动被转移到这个表面(见上图)。在第一种情况下，蒙皮顶点被简单地冻结在相应关节的局部空间中，该关节可以是空间中最近的一个，也可以是用户直接选择的一个。顶点然后重复这个关节经历的任何运动，它在世界坐标中的位置由标准FK程序确定。尽管它很简单，但刚性蒙皮使其难以在关节附近区域获得足够光滑的蒙皮变形，也难以获得更微妙的效果，如呼吸或肌肉动作。另外一种叫做屈肌的特殊变形器也可以用于这个目的。在平滑蒙皮中，多个关节可以根据动画师分配的一些权重影响蒙皮顶点，从而对结果进行更详细的控制。位移矢量di，由影响给定皮肤顶点的不同关节提出(每个关节再次用标准FK计算)，根据它们的权重wi平均，以计算顶点d = ∑widi的最终位移。归一化权值∑wi = 1)是最常见的，但不是基本必需的。设置平滑蒙皮权重来达到预期的效果并不容易，需要动画师的重要技能。</strong></p>
<h3 id="Facial-Animation-面部表情动画"><a href="#Facial-Animation-面部表情动画" class="headerlink" title="Facial Animation 面部表情动画"></a>Facial Animation 面部表情动画</h3><p><strong>骨骼非常适合创建角色身体的大多数动作，但它们不太适合制作逼真的面部动画。原因是，人类面部的皮肤是由直接附着在其上的肌肉移动的，而身体其他部位的肌肉主要目的是移动骨骼，任何皮肤变形都是次要结果。这种面部解剖结构安排的结果是一套非常丰富的动态面部表情，人类使用它作为主要的交流工具之一。我们都受过很好的训练，能够识别这种面部变化，很容易注意到任何不自然的外观。这不仅对动画师提出了特殊的要求，而且还需要高分辨率的面部几何模型，如果想要逼真，还需要精确的皮肤反射属性和纹理。</strong></p>
<p><strong>虽然可以逐点设置人脸的关键姿态，并在它们之间插入，或使用基于物理的技术直接模拟底层肌肉结构的行为(参见第16.5节)，但更专业的方法是高级别的方法也存在。特定的静态形状的脸可以以一个相对较小的设置所谓的构象参数(总规模,距离从眼睛到前额,鼻子的长度,宽度的下巴,等等)用于变形一般的脸模型到一个个人特性。另外一组表达参数可以用来描述动画中脸部的动态形状。例如，头部的刚性旋转，眼睛的睁开程度，某些特征点从静止位置的移动，等等。这些选择是为了大多数有趣的表情可以通过一些参数调整的组合获得，因此，允许一个脸通过标准关键帧动画。为了实现更高层次的控制，可以使用表达参数创建一组与常见情绪(中性、悲伤、快乐、愤怒、惊讶等)对应的表情，然后将这些关键姿势混合，得到一张“轻微悲伤”或“愤怒惊讶”的脸。类似的技术也可以用于表演对口型动画，但这种情况下的关键姿势对应不同的音素。面部动作编码系统(FACS) (Eckman &amp; Friesen, 1978)没有使用静态表情序列来描述动态表情，而是直接将动态面部表情分解为称为动作单位(AUs)的基本动作的总和。这套动作基于广泛的心理学研究，包括抬内眉、皱鼻子、拉伸嘴唇等动作。结合 AUs可用于合成必要的表达。</strong></p>
<h3 id="Motion-Capture-动作捕捉"><a href="#Motion-Capture-动作捕捉" class="headerlink" title="Motion Capture 动作捕捉"></a>Motion Capture 动作捕捉</h3><p><strong>即使在上述技术的帮助下，从零开始创建逼真的角色动画仍然是一项艰巨的任务。因此，人们很自然地将大量注意力集中在记录演员在现实世界中的动作，然后将其应用于电脑生成的角色的技术上。运动捕捉(MC)技术主要有两类:电磁和光学。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013113718.png" class="" title="image-20211013113718">

<p>光学运动捕捉:标记附着在表演者的身体上，骨骼运动被提取出来。图片由运动分析公司提供。</p>
<p><strong>在电磁运动捕捉中，电磁传感器直接测量其三维位置(可能还有方向)，通常实时提供捕获结果。这种技术的缺点包括昂贵的设备成本，可能来自附近金属物体的干扰，以及传感器和电池的明显尺寸，这可能会成为执行高振幅运动的障碍。在光学MC中，小的彩色标记被用来代替主动传感器，使其成为一个侵入性小得多的过程。上图显示了这样一个系统的操作。在最基本的安排中，运动被两个校准的摄像机记录下来，并使用简单的三角测量来提取标记者的三维位置。更先进的计算机视觉算法用于精确跟踪从视频中提取多个标记的计算代价很高，因此，在大多数情况下，这种处理是离线完成的。光学跟踪的鲁棒性通常不如电磁跟踪。某些帧中给定标记的遮挡、标记的可能错误识别和图像中的噪声只是必须解决的几个常见问题。引入更多的摄像机从不同的方向观察运动，提高了精确度和鲁棒性，但这种方法更昂贵，而且需要更长的时间来处理这些数据。随着可用计算能力的提高和更好的计算机视觉算法的发展，光学MC变得越来越有吸引力。由于标记的低影响特性，光学方法适用于精细的面部动作捕捉，也可以用于人类以外的对象，例如，动物，甚至是风中的树枝。</strong></p>
<p><strong>通过将几个传感器或标记连接到表演者的身体上，可以记录一些点集合的一组时间依赖的3D位置。这些跟踪位置通常选择在关节附近，但当然，它们仍然位于皮肤表面，而不是在实际的骨骼接触点。因此，需要一些额外的护理和一些额外的处理来将记录的位置转换为物理骨骼关节的位置。例如，在肘关节或踝关节的相对两侧放置两个标记点，使系统通过平均两个标记点的位置来获得更好的关节位置。如果没有额外的注意，由于关节位置偏移以及固有噪声和测量精度不足，会出现非常明显的伪影。例如，由于运动过程中的身体不准确，角色的四肢可能会在行走或抓握时失去与它们应该接触的物体的接触，骨骼可能会出现脚滑(滑冰)等问题。大多数这些问题都可以通过使用逆运动学技术来纠正，这种技术可以明确地迫使肢体的末端做出所需的行为。</strong></p>
<p><strong>恢复的关节位置现在可以直接应用到电脑生成的角色的骨架上。本程序假定角色的物理尺寸与表演者的物理尺寸相同。将记录的动作重新定位到不同的角色，更普遍地说，编辑MC数据，需要非常小心，以满足必要的约束条件(如保持脚在地面上或不允许肘部向后弯曲)，并保持修改后动作的整体自然外观。一般来说，期望的更改越多，保持结果质量的可能性就越小。解决这个问题的一种有趣的方法是记录大量的动作，并从这个库中将短片段拼接在一起，以获得所需的动作。虽然这个课题目前是一个非常活跃的研究领域，但动作捕捉技术的主要缺点之一仍然是不能根据动画师的需要来调整记录的动作。</strong></p>
<h2 id="Physics-Based-Animation-基于物理的动画"><a href="#Physics-Based-Animation-基于物理的动画" class="headerlink" title="Physics-Based Animation 基于物理的动画"></a>Physics-Based Animation 基于物理的动画</h2><p><strong>我们周围的世界是由物理定律支配的，其中许多可以被形式化为偏微分方程组，或者在一些更简单的情况下，常微分方程组。计算机最初的应用之一就是(现在仍然是)解这样的方程。因此，尝试使用过去几十年发展起来的数字技术来获得计算机动画的真实动作是很自然的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110125.png" class="" title="image-20211014110125">

<p>现实的布料模拟是经常使用基于物理的方法执行。在这个例子中，力来自碰撞和重力。</p>
<p><strong>由于其相对的复杂性和巨大的成本，基于物理的动画最常用于其他技术不可用或不能产生足够逼真的结果的情况下。主要的例子包括流体动画(其中包括许多由相同方程描述的气态现象——烟、云、火等)、布料模拟(示例如上图所示)、刚体运动和弹性物体的精确变形。在每一种情况下，控制方程和常用数值方法的细节是不同的，但许多基本思想和困难仍然适用于各个应用程序。数值求解ODEs 和 PDEs的方法很多，但详细讨论它们远远超出了本书的范围。为了让读者对基于物理的技术和涉及的一些问题有所了解，我们在这里只简要地提到有限差分方法——概念上最简单和最流行的算法系列之一，它已被应用于动画中遇到的大多数(如果不是全部)微分方程。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110324.png" class="" title="image-20211014110324">

<p>对于∂f/∂x和∂f/∂t的导数方程，有两种可能的差分格式。(左)显式方案仅通过已知值表示未知值(开圆)，当前(橙色圆圈)和可能过去(蓝色圆圈)时间;(右)隐式格式将已知值和未知值混合在单个方程中，因此必须将所有这些方程作为一个系统来求解。对于这两种方案，需要关于右边界值的信息来关闭过程。</p>
<p><strong>该方法的核心思想是将微分方程替换为离散模拟方程—差分方程。为了做到这一点，连续感兴趣的区域由有限的点集表示，在这些点上将计算出解。在最简单的情况下，这些定义在一个统一的矩形网格上，如上图所示。原始ODE或PDE中的每一个导数都被其在网格点处的函数值的逼近所取代。一种方法是用网格上相邻点的函数值减去给定点上的函数值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110344.png" class="" title="image-20211014110344">

<p><strong>当然，这些表达并不是唯一的方式。例如，可以使用f(t−Δt)而不是上面的f(t)，然后除以2Δt。对于包含时间导数的方程，现在可以通过求解未知f(t + Δt)的差分方程组(每个空间位置一个)，将未知函数的值以Δt-size步骤序列在时间上向前传播。一些最初的条件,即在t = 0时的未知函数值，是启动过程所必需的。根据特定的问题，可能还需要其他信息，例如域边界上的值。</strong></p>
<p><strong>f(t+Δt)的计算对于所谓的显式格式来说是很容易的，只要在当前时间取所有其他值，并且相应的差分方程f(t+Δt)中唯一的未知数通过这些已知值来表示。隐式方案混合了当前和未来的价值，例如,使用</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110556.png" class="" title="image-20211014110556">

<p><strong>作为近似 ∂f/∂x ．在这种情况下，每一步都要解一个代数方程组。</strong></p>
<p><strong>差分格式的选择会极大地影响算法的各个方面。其中最明显的是准确性。在Δt→0或Δx→0的极限下，上上式中这种类型的表达式是精确的，但对于有限步长，有些格式允许比其他格式更好地逼近导数。差分格式的稳定性与实际中经常出现的数值误差随时间增长的速度有关。对于稳定方案，这种增长是有界的，而对于不稳定方案，这种增长是指数级的，并且可以迅速压倒人们所寻求的解决方案(见下图)。重要的是要认识到，虽然解决方案中的一些不准确是可以容忍的(事实上，动画很少需要物理和工程中要求的精度)，但不稳定的结果是完全不需要的没有意义，应该避免使用不稳定的方案。一般来说，显式格式是不稳定的，或者在较大的步长下会变得不稳定，而隐式格式是无条件稳定的。隐式格式允许更大的步长(因此，更少的步长)，这就是为什么尽管每一步都需要解一个代数方程组，隐式格式还是很受欢迎的原因。显式格式在满足其稳定性条件的情况下，由于其简单而具有吸引力。为一个特定的问题开发一个好的差分格式和相应的算法是不容易的，对于大多数标准情况，最好使用现有的方法。有大量的文献讨论这些技术的细节。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110707.png" class="" title="image-20211014110707">

<p>一个不稳定的解决方案可能会跟随最初是行动一，但随着时间的推移，它会任意偏离行动一。对于特定的应用程序，稳定的解决方案的准确性可能仍然不够。</p>
<p><strong>我们应该记住，在许多情况下，仅仅计算方程中所有必要的项本身就是一项困难和耗时的任务。例如，在刚体或布的模拟中，作用在系统上的大多数力是由于物体之间的碰撞。因此，在动画的每一步中，我们都必须解决一个纯粹的几何问题，但非常重要的碰撞检测问题。在这种情况下，需要对这种力量进行较少评估的方案可能会节省大量计算。</strong></p>
<p><strong>虽然求解适当的时变方程的结果给出了非常真实的运动，但这种方法有其局限性。首先，物理动画的效果很难控制。这些方程的基本数学性质表明，一旦设定了初始条件，解就是唯一的。这没有给动画师留下太多的输入空间，如果结果由于某种原因不令人满意，那么就只有几个选择了。它们大多局限于调整初始条件，改变系统的物理属性，甚至通过引入人工术语来修改方程本身，以“推动”动画师想要的方向的解决方案。做出这样的改变需要高超的技能，同时也需要理解基本的物理原理，最好还有数值方法。如果没有这些知识，基于物理的动画所提供的现实主义可能会被破坏，或者可能出现严重的数值问题。</strong></p>
<h2 id="Procedural-Techniques-程序技术"><a href="#Procedural-Techniques-程序技术" class="headerlink" title="Procedural Techniques 程序技术"></a>Procedural Techniques 程序技术</h2><p><strong>想象一下，我们可以编写(并在计算机上执行)一个数学函数，在动画师的指导下精确输出所需的运动。当所涉及的“函数”是求解特定微分方程的过程，而“指导”是初始条件和边界条件、额外方程项等的集合时，上述基于物理的技术可以作为这种方法的一个特例来处理。</strong></p>
<p><strong>然而，如果我们只关心最终结果，我们不必遵循基于物理的方法。例如,一个简单的表面恒定振幅波湖可以直接由应用函数f (x, t) = cos(ωt−kx +φ)在恒定的频率ω,波矢k和阶段φ得到2d点x在时间t的位移。这样的波浪随机集合阶段和适当选择振幅,频率和波向量会导致一个非常现实的动画的表面水没有明确解决任何流体动力学方程。事实证明，其他相当简单的数学函数也可以创建非常有趣的模式或对象。在11.5节中描述了几个这样的函数，大多数是基于晶格噪声的。在这些功能中添加时间依赖性使我们能够比基于物理的技术更容易和更便宜地动画某些复杂的现象，同时保持非常高的视觉质量的结果。如果noise(x)是基本的模式生成函数，我们可以通过在晶格中移动参数位置来创建一个随时间变化的变量。最简单的例子是匀速运动:timenoise(x, t) =noise(x + vt)，但更复杂的通过晶格的运动当然也是可能的，事实上也更常见。下图显示了这样一条路径，即螺旋。另一种方法是使用动画参数来生成噪声函数。这尤其适用于当外观随时间发生显著变化时，例如云变得更加动荡。通过这种方式，我们可以使用生成静态云的功能来动画云的动态形成过程。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014112547.png" class="" title="image-20211014112547">

<p>一个路径通过立方体定义程序noise被遍历以动画结果模式。</p>
<p><strong>对于某些程序技术来说，时间依赖是一个更重要的组成部分。最简单的元胞自动机在二维矩形网格上运行，在每个位置(元胞)存储二进制值。要创建时变模式，需要重复应用一些用户提供的修改这些值的规则。规则通常涉及当前值和单元格相邻值的一些条件集。例如，由英国数学家John Conway于1970年发明的2D生命游戏细胞自动机的规则如下:</strong></p>
<p>​    <strong>1.一个死细胞(即在给定位置的二进制值为0)，恰好有三个活动邻居成为一个活动单元(即其值设置为1)。</strong></p>
<p>​    <strong>2.一个有两三个活细胞邻居的活细胞可以存活。</strong></p>
<p>​    <strong>3.在其他情况下，细胞死亡或保持死亡。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014112903.png" class="" title="image-20211014112903">

<p>生命游戏自动机进化的几个(非连续的)阶段。活细胞用黑色表示。应用非常简单的规则可以得到稳定的物体、振荡器、运动模式和许多其他有趣的结构。图由艾伦·亨塞尔使用程序创建。</p>
<p><strong>一旦规则应用于所有网格位置，就会创建一个新的模式，并开始一个新的进化周期。活细胞分布在不同时间的三个样本快照如上图所示。更复杂的自动机同时可以在几个可能是浮点值的三维网格上操作，并可用于模拟云和其他气体现象或生物系统的动力学，这是该仪器最初为之发明的(注意术语)。仅仅几个精心选择的规则就可以产生令人惊讶的模式复杂性，但是如何编写这样的规则来创建所需的行为通常并不明显。这是程序性技术的一个常见问题:关于如何创建新的程序或甚至调整现有程序的参数的指导，如果有的话，也是有限的。因此，我们通常需要通过大量调整和反复试验(游戏邦注:即“通过经验”)来学习程序方法。</strong></p>
<p><strong>另一种最初用于描述生物物体的有趣方法是L-systems(以其最初发明者阿斯特丽德·林登迈尔的名字命名)。这种方法基于用于重写符号字符串的语法或递归规则集。有两种类型的符号:终端符号代表我们想用语法表示的元素。根据语法的含义，语法可以描述树木和灌木丛、建筑和整个城市的结构，或者编程和自然语言。在动画,L-systems是最受欢迎的代表植物几何建模和相应的终端指令系统:把一片叶子(或分支机构)在当前我们将使用@符号,画一个圆,推动当前位置,一些数量的单位(符号f),扭转当前方向60度世界z轴(符号+),pop(符号[)或推(符号])当前位置/取向,等等。辅助非终结符号(用大写字母表示)只有语义而不是任何直接意义。它们打算最终通过终端被重写。我们从特殊的非终结符开始符号S开始，并并行地对当前字符串应用语法规则，即替换当前存在的所有非终端机以获得新字符串，直到我们最终得到一个只包含终端的字符串，因此不可能有更多的替换。然后使用这串建模指令输出实际的几何图形。例如，一组规则(产品)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014113122.png" class="" title="image-20211014113122">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014113141.png" class="" title="image-20211014113141">

<p>连续的推导步骤使用符号表示L-system。大写字母表示非终结符，并说明相应的非终结符将被展开的位置。它们不是实际产出的一部分。</p>
<p><strong>可能导致如上图所示的重写步骤序列:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014113200.png" class="" title="image-20211014113200">

<p><strong>如上所示，对于相同的非终结符，通常有许多不同的结果，允许使用相同的语法生成许多不同的对象。应用哪条规则的选择可以取决于哪些符号位于被替换的符号的旁边(上下文敏感性)，或者可以根据为每个规则分配的一些概率随机执行(随机l系统)。更复杂的规则可以建模与环境的交互，比如修剪到特定形状，参数可以与符号关联，以控制发出的几何命令。</strong></p>
<p><strong>L-systems已经捕获了工厂拓扑随时间的变化:在重写过程中获得的每个中间串都可以被解释为工厂的“年轻”版本(见上图)。对于更显著的变化，不同的产量可以在不同的时间生效，允许植物的结构随着它的生长而发生显著的变化。例如，一棵幼树会产生很多新的分枝，而一棵老树只会适度地分枝。</strong></p>
<p><strong>非常逼真的植物模型已经用l系统创建。然而，与大多数过程技术一样，需要一些经验才能有意义地应用现有的 L-systems，而编写新的语法来获得一些预期的效果当然不容易。</strong></p>
<h2 id="Groups-of-Objects-对象组"><a href="#Groups-of-Objects-对象组" class="headerlink" title="Groups of Objects 对象组"></a>Groups of Objects 对象组</h2><p><strong>当然，要制作多个对象的动画，我们可以简单地将本章所描述的标准技术应用到每个对象上。这种方法适用于中等数量的独立物体，它们的理想运动是已知的的进步。然而，在许多情况下，在动态环境中采取某种协调行动是必要的。如果只涉及少数对象，动画师可以使用基于人工智能(AI)的系统，根据一些高级目标自动确定每个对象的即时任务，计划必要的动作，并执行计划。许多现代游戏使用这种自主对象来创造聪明的怪物或玩家的合作者。</strong></p>
<p><strong>有趣的是，随着群体中物体的数量从几个增长到几十个、数百个甚至数千个，群体中的个体必须只有非常有限的“智能”，才能让整个群体表现出协调一致的目标驱动运动。事实证明，群体聚集是一种突现行为，可能是群体成员与几个最亲密的邻居有限互动的结果(Reynolds, 1987)。任何观察过一群鸟或一群鱼引人入胜的同步运动的人都应该对群集现象很熟悉。这项技术也可以用来控制一群动物在地形上移动，甚至是一群人。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211015125830.png" class="" title="image-20211015125830">

<p>(左)单个群成员(boid)可以经历几个不同重要性的冲动(由线厚表示)，这些冲动必须被协商成一个单一的速度矢量。boid只知道它有限的邻域(圆)。(右)Boid控制通常被实现为三个独立的模块。</p>
<p><strong>在任何给定的时刻，群体成员的运动，通常称为boid，应用于群时，是平衡几个经常相互矛盾的趋势的结果，每个趋势表明其自己的速度矢量(见上图16.28)。首先，有外力作用于体，如重力或风。由这些力产生的新速度可以直接通过牛顿定律计算</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211015125846.png" class="" title="image-20211015125846">

<p><strong>第二，一个boid应该对全球环境和其他群体成员的行为做出反应。避免碰撞是这种相互作用的主要结果之一。群集的关键是，每个群体成员只有有限的视野，因此只知道在其当前位置附近发生的事情。为了避免环境中的物体，最简单的策略是在每个物体周围建立一个有限范围的斥力场。这将产生第二个所需的速度矢量vnew^col - avoid，也由牛顿定律给出。与其他组成员的交互可以通过同时应用不同的转向行为来建模，从而产生几个额外的期望速度向量vnew^steer。 最常见的情况是远离邻近的动物以避免拥挤，转向同伴以确保群体凝聚力，以及调整鱼群的速度以与邻近动物的平均方向一致。最后，一些额外的期望速度矢量vnew^goal通常用于实现所需的全局目标。它们可以是沿着空间中某个路径的向量，跟随某个特定指定的鸟群领袖，或者仅仅代表鸟群成员的迁徙冲动。</strong></p>
<p><strong>一旦所有的vnew被确定，最终想要的向量将基于它们之间的优先级进行协商。避免碰撞和速度匹配通常具有更高的优先级。与其简单地平均期望的速度向量(这可能导致冲动的取消和不自然的“无处移动”行为)，不如使用加速分配策略。某些固定的总加速度是为一个boid提供的，它的一部分是按优先顺序给予每个敦促的。如果总的可用加速度耗尽，一些较低优先级的冲动将对运动产生较小的影响或被完全忽略。我们希望，一旦当前最重要的任务(在大多数情况下避免碰撞)完成，其他任务就可以在不久的将来处理。尊重真实对象的某些物理限制也很重要，例如，将过高的加速度或速度夹持到某些现实值。根据鸟群成员的内部复杂性，动画的最后阶段可能是将商定的速度矢量转换成一组特定的参数(鸟的翅膀位置，平面模型在空间中的方向，腿骨架骨骼配置)，用于控制boid的运动。上图(右)显示了系统实现群集的示意图。</strong></p>
<p><strong>一个更简单，但仍然非常有用的群体控制版本是由粒子系统实现的(Reeves, 1983)。一个系统中的粒子数量通常比一个群中的boids数量大得多，可以是数万或数十万，甚至更多。此外，在动画过程中，粒子的确切数量会随着新粒子的诞生和一些旧粒子的破坏而波动。粒子通常是完全独立于相互之间，忽略自己的邻居，只通过经历外力和与物体的碰撞与环境互动，而不是像鸟群那样通过避免碰撞。在动画过程中的每一步，系统首先用一些初始参数创建新的粒子，终止旧的粒子，然后根据牛顿定律计算必要的力，更新剩余粒子的速度和位置。</strong></p>
<p><strong>粒子系统的所有参数(粒子数量、粒子寿命、初始速度和粒子位置等)通常都在动画师的直接控制之下。粒子系统的主要应用包括建模烟花、爆炸、喷雾液体、烟雾和火灾，或其他模糊物体和没有尖锐边界的现象。为了获得真实的外观，在所有参数中引入一些随机性是很重要的，例如，在每个步骤中产生(和破坏)随机数量的粒子，它们的速度根据某些分布生成。除了设置适当的初始参数，控制粒子系统的运动通常是通过在空间中创建一个特定的力模式来实现的，例如，在粒子到达某个特定位置时将其吹向一个新的方向或添加一个吸引中心。我们应该记住，尽管粒子系统具有所有的优势，主要是实现的简单性和易于控制，但它们通常不能提供基于真实物理的相同现象模拟的真实感特征。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211015130223.png" class="" title="image-20211015130223">

<p>被定向源发射后，粒子与物体碰撞，一旦清除障碍物，就会被当地的风场吹落。</p>
<h1 id="17-Using-Graphics-Hardware-使用图形硬件"><a href="#17-Using-Graphics-Hardware-使用图形硬件" class="headerlink" title="17 Using Graphics Hardware 使用图形硬件"></a>17 Using Graphics Hardware 使用图形硬件</h1><h2 id="Hardware-Overview-硬件概述"><a href="#Hardware-Overview-硬件概述" class="headerlink" title="Hardware Overview 硬件概述"></a>Hardware Overview 硬件概述</h2><p><strong>在本书的大部分内容中，重点是计算机图形的基本原理，而不是与实现算法的API或硬件相关的任何细节。本章采取了稍微不同的路线，将使用图形硬件的细节与与硬件编程相关的一些实际问题混合在一起。这一章被设计为图形硬件的介绍性指南，可以用作一组调查图形硬件的每周实验室的基础。</strong></p>
<h2 id="What-Is-Graphics-Hardware-什么是图形硬件"><a href="#What-Is-Graphics-Hardware-什么是图形硬件" class="headerlink" title="What Is Graphics Hardware 什么是图形硬件"></a>What Is Graphics Hardware 什么是图形硬件</h2><p><strong>图形硬件描述了使用专门的基于光栅化(在某些情况下，基于射线跟踪器)的硬件架构在计算机屏幕上以像素形式快速渲染3D对象所需的硬件组件。使用术语图形硬件是为了引出执行一系列图形计算所需的物理组件的含义。换句话说，硬件就是目前显卡上的芯片组、晶体管、总线、处理器和计算核心的集合。正如您将在本章学到并最终体验到的，当前的图形硬件非常擅长处理3D对象的描述，并将这些表示转换为填充显示器的彩色像素。</strong></p>
<p><strong>在过去的十年里，图形硬件的确发生了非常迅速的变化。较新的图形硬件提供了更多的并行处理功能，以及对特殊呈现的更好支持。这种快速发展的原因之一是电子游戏行业及其经济发展势头。本质上，这意味着每一个新的图形卡提供更好的性能和处理能力。因此，电子游戏的视觉效果更加逼真。图形硬件上的处理器，通常称为GPUs或图形处理单元，是高度并行的，可以提供数千个并发线程执行。硬件是为吞吐量设计的，允许在更短的时间内处理更多的像素和顶点。所有这些并行性对图形算法来说都很好，但其他工作也得益于并行硬件。除了电子游戏，GPU还被用于加速物理计算，开发实时光线追踪代码，解决流体模拟的Navier-Stokes相关方程，以及开发理解气候的更快代码(Purcell, Buck, Mark， &amp; Hanrahan, 2002;S. G. Parker等人，2010;哈里斯,2004)。一些APIs和SDKs已经开发出来，可以提供更直接的通用计算，比如OpenCL和NVIDIA的CUDA。硬件加速光线追踪APIs也可以用来加速射线与物体的相交(S. G. Parker et al.， 2010)。类似地，用于为视频游戏的图形组件编程的标准APIs，如OpenGL和DirectX，也允许机制来利用图形硬件的并行能力。随着新硬件的开发以支持更复杂的计算，许多APIs都会发生变化。</strong></p>
<p><strong>图形硬件是可编程的。作为开发人员，您可以控制与处理几何图形、顶点和最终成为像素的片段相关的许多计算。最近的硬件变化以及APIs的持续更新，如OpenGL或DirectX，支持一个完全可编程的管线。这些变化为开发人员提供了利用GPU上可用的计算的创造性许可。在此之前，固定函数栅格化管道强制计算特定风格的顶点转换、光照和片段处理。管线的固定功能确保了基本的着色、照明和纹理可以非常快地发生。无论是可编程接口，还是固定函数计算，栅格化管线的基本计算是相似的，如下图所示。在栅格化管线中，顶点经过视图和投影变换矩阵的变换，由局部空间转换为全局空间，最终转换为屏幕坐标。与几何体顶点相关联的屏幕坐标集被栅格化为碎片。管线的最后阶段将片段处理成像素并可以应用每片段纹理查找，照明，和任何必要的混合。一般来说，流水线可以并行执行，GPU内核可以同时处理顶点和碎片。关于栅格化管道的更多细节可以在第8章中找到。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211015131612.png" class="" title="image-20211015131612">

<p>基本图形硬件流水线由几个阶段组成，这些阶段将3D数据转换为2D屏幕对象，以便通过像素处理阶段进行栅格化和着色。</p>
<h2 id="Heterogeneous-Multiprocessing-异构多处理"><a href="#Heterogeneous-Multiprocessing-异构多处理" class="headerlink" title="Heterogeneous Multiprocessing 异构多处理"></a>Heterogeneous Multiprocessing 异构多处理</h2><p><strong>在使用图形硬件时，将CPU和GPU区分为单独的计算实体是很方便的。在这个上下文中，术语host指的是CPU，包括它可用的线程和内存。术语device是指GPU或图形处理单元，以及与之相关的线程和内存。这是有意义的，因为大多数图形硬件都是由通过PCI总线连接到计算机的外部硬件组成的。硬件也可以作为一个单独的芯片组焊接到机器上。从这个意义上说，图形硬件代表了一种特殊的协处理器，因为CPU(和它的核心)都可以被编程，GPU和它的核心也可以。所有使用图形硬件的程序必须首先建立CPU和GPU内存之间的映射。这是一个相当低级的细节，是必需的，以便驻留在操作系统中的图形硬件驱动程序可以在硬件、操作系统和窗口系统软件之间进行接口。回想一下，因为主机(CPU)和设备(GPU)是独立的，必须在两个系统之间进行数据通信。更正式地说，操作系统、硬件驱动程序、硬件和窗口系统之间的映射称为图形上下文。上下文通常是通过对窗口系统的API调用建立的。关于建立上下文的细节超出了本章的范围，但是许多窗口系统开发库都有方法查询图形硬件的各种功能，并基于这些需求建立图形上下文。因为设置上下文依赖于窗口系统，这也意味着这样的代码不太可能是跨平台的代码。然而，在实践中，或者至少在开始时，不太可能需要这种低级上下文设置代码，因为存在许多高级API来帮助人们开发可移植的交互式应用程序。</strong></p>
<p><strong>许多用于开发交互式应用程序的框架都支持查询输入设备(如键盘或鼠标)。一些框架提供对网络、音频系统和其他高级系统资源的访问。在这方面，许多API是开发图形甚至游戏应用程序的首选方法。</strong></p>
<p><strong>跨平台硬件加速通常是通过OpenGL API实现的。OpenGL是一个开放的工业标准图形API，支持多种图形硬件的硬件加速。OpenGL是图形硬件编程中最常见的API之一，还有DirectX等API。虽然OpenGL可以在许多操作系统和硬件架构上使用，但DirectX只适用于基于微软的系统。在本章中，我们将使用OpenGL来介绍硬件编程的概念和示例。</strong></p>
<h3 id="Programming-with-OpenGL-使用OpenGL编程"><a href="#Programming-with-OpenGL-使用OpenGL编程" class="headerlink" title="Programming with OpenGL 使用OpenGL编程"></a>Programming with OpenGL 使用OpenGL编程</h3><p><strong>当你用OpenGL API编程时，你至少在为两个处理器编写代码:CPU(s)和GPU(s)。OpenGL是在一个C风格的API中实现的，所有的函数都带有“gl”前缀，以表示它们包含在OpenGL中。OpenGL函数调用改变图形硬件的状态，可以用来声明和定义几何体，加载顶点和碎片着色器，并确定数据通过硬件时如何进行计算。</strong></p>
<p><strong>本章介绍的OpenGL的变体是OpenGL 3.3 Core Profile版本。虽然不是OpenGL的最新版本，但OpenGL的3.3版本符合OpenGL编程的未来方向。这些版本专注于提高效率，同时也将管线的编程完全交给了开发人员。许多功能在OpenGL的早期版本中出现的调用在这些更新的API中并不存在。例如，立即模式呈现已弃用。即时模式渲染用于在每帧需要时将数据从CPU内存发送到显卡内存，通常效率非常低，特别是对于较大的模型和复杂的场景。当前的API侧重于在需要数据之前将数据存储在显卡上，并在呈现时实例化它。另一个例子是，OpenGL的矩阵栈也被弃用了，开发者只能使用第三方的矩阵库(如GLM)或他们自己的类来创建必要的矩阵来查看、投影和转换，如第7章所述。因此，OpenGL的着色器语言(GLSL)也承担了更大的角色，在着色器中执行必要的矩阵转换以及照明和着色。因为执行逐顶点转换和光照的固定函数管道不再存在，程序员必须自己开发所有的着色器。本章提供的着色示例将使用GLSL 3.3 Core Profile版本的着色器规范。本章的未来读者会想要探索当前的OpenGL和OpenGL着色语言规范，以获得这些API和语言支持的更多细节。</strong></p>
<h2 id="Graphics-Hardware-Programming-Buffers-State-and-Shaders-图形硬件编程：缓冲区、状态和着色器"><a href="#Graphics-Hardware-Programming-Buffers-State-and-Shaders-图形硬件编程：缓冲区、状态和着色器" class="headerlink" title="Graphics Hardware Programming: Buffers, State, and Shaders 图形硬件编程：缓冲区、状态和着色器"></a>Graphics Hardware Programming: Buffers, State, and Shaders 图形硬件编程：缓冲区、状态和着色器</h2><p><strong>三个概念将有助于理解当代图形硬件编程。第一个是数据缓冲区的概念，它非常简单，是设备上的内存的线性分配，可以存储GPU操作的各种数据。第二个想法是，显卡维持计算状态，决定与场景数据和着色器相关的计算如何在图形硬件上发生。此外，状态可以从主机传递到设备，甚至在着色器之间的设备内部。着色器代表了GPU上与逐顶点或逐片段处理相关的计算发生的机制。本章将专注于顶点和碎片着色器，但专门的几何和计算着色器也存在于当前版本的OpenGL中。着色器在现代图形硬件的功能中扮演着非常重要的角色。</strong></p>
<h3 id="Buffers-缓冲区"><a href="#Buffers-缓冲区" class="headerlink" title="Buffers 缓冲区"></a>Buffers 缓冲区</h3><p><strong>缓冲区是图形硬件上存储数据的主要结构。它们代表了图形硬件的内部存储器与一切相关几何、纹理和图像平面数据。对于第8章中描述的光栅化管线，与硬件加速光栅化相关的计算读写GPU上的各种缓冲区。从编程的角度来看，应用程序必须初始化GPU上应用程序所需要的缓冲区。这相当于主机对设备的复制操作。在执行的各个阶段结束时，也可以执行从设备到主机的拷贝，将数据从GPU拉到CPU内存。此外，OpenGL的API中确实存在允许设备内存映射到主机内存的机制，以便应用程序可以直接写入显卡上的缓冲区。</strong></p>
<h3 id="Display-Buffer-显示缓冲区"><a href="#Display-Buffer-显示缓冲区" class="headerlink" title="Display Buffer 显示缓冲区"></a>Display Buffer 显示缓冲区</h3><p><strong>在图形管线中，最终的一组像素颜色可以链接到显示器，也可以将它们作为PNG图像写入磁盘。与这些像素相关联的数据通常是颜色值的2D数组。数据本质上是2D的，但它在GPU上被有效地表示为一维线性阵列的内存。这个数组实现了显示缓冲区，它最终被映射到窗口。渲染图像涉及到通过图形API将更改通信到图形硬件上的显示缓冲区。在栅格化管线的最后，分片处理和混合阶段将数据写入输出显示缓冲存储器。同时，开窗系统读取显示缓冲区的内容以在监视器的窗口上产生光栅图像。</strong></p>
<h3 id="Cycle-of-Refresh-刷新周期"><a href="#Cycle-of-Refresh-刷新周期" class="headerlink" title="Cycle of Refresh 刷新周期"></a>Cycle of Refresh 刷新周期</h3><p><strong>大多数应用程序更喜欢双缓冲显示状态。这意味着有两个与图形窗口相关联的缓冲区:前缓冲区和后缓冲区。双缓冲系统的目的是，应用程序可以将更改通信到后缓冲区(从而写入该缓冲区)，而前缓冲区内存用于驱动窗口上的像素颜色。</strong></p>
<p><strong>在呈现循环的末尾，缓冲区通过指针交换进行交换。前缓冲区指针指向后缓冲区，然后后缓冲区指针被分配给前一个前缓冲区。通过这种方式，窗口系统将用最新的缓冲区刷新窗口的内容。如果缓冲区指针交换与整个显示的窗口系统刷新同步，呈现将无缝显示。否则，用户可能会观察到实际显示器上的几何图形被撕裂，因为场景的几何图形和碎片被处理(从而写入显示缓冲区)的速度比屏幕刷新的速度快。</strong></p>
<p><strong>当显示器被认为是内存缓冲区时，显示器上最简单的操作之一本质上是内存设置(或复制)操作，该操作将内存置零，或将内存清除到默认状态。对于图形程序，这可能意味着将窗口的背景清除为特定的颜色。要在OpenGL应用程序中清除背景颜色(变为黑色)，可以使用以下代码:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016122305.png" class="" title="image-20211016122305">

<p><strong>glClearColor函数的前三个参数表示在范围[0,1]内指定的红色、绿色和蓝色颜色组件。第四个参数表示不透明度，或alpha值，范围从0.0完全透明到1.0完全不透明。alpha值用于在管道的最后阶段通过各种片段混合操作确定透明度。</strong></p>
<p><strong>此操作仅清除颜色缓冲。除了颜色缓冲区,由GL COLOR BUFFER BIT允许在这种情况下清除到黑色,图形硬件还使用一个深度缓冲来表示碎片的距离相对于相机(你可能记得z-buffer算法在第8章)的讨论。清除深度缓冲z-buffer算法是必要的,以确保操作正确,并允许隐面消除发生。清除深度缓冲区可以通过或’ ‘两个位字段值一起，如下所示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016122608.png" class="" title="image-20211016122608">

<p><strong>在一个基本的交互式图形应用程序中，这个清除步骤通常是在处理任何几何图形或片段之前执行的第一个操作。</strong></p>
<h2 id="State-Machine-状态机"><a href="#State-Machine-状态机" class="headerlink" title="State Machine 状态机"></a>State Machine 状态机</h2><p><strong>通过对显示器颜色和深度缓冲区的缓冲区清除操作的说明，还介绍了图形硬件状态的思想。glClearColor函数设置在调用glClear时写入颜色缓冲区中所有像素的默认颜色值。清除调用初始化显示缓冲区的颜色组件，也可以重置深度缓冲区的值。如果清除颜色在应用程序中没有改变，那么清除颜色只需要设置一次，这通常是在OpenGL程序的初始化中完成的。每次调用glClear时，它都会使用先前设置的清除颜色状态。</strong></p>
<p><strong>还要注意，z-buffer算法状态可以根据需要启用或禁用。z-缓冲区算法在OpenGL中也被称为深度测试。通过启用它，在将任何片段颜色写入颜色缓冲区之前，片段的深度值将与当前存储在深度缓冲区中的深度值进行比较。有时，深度测试是不必要的，可能会降低应用程序的运行速度。禁用深度测试将阻止z-buffer计算并改变可执行文件的行为。使用OpenGL启用z-buffer测试如下所示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016122824.png" class="" title="image-20211016122824">

<p><strong>glEnable调用打开深度测试，而glDepthFunc调用设置如何执行深度比较的机制。在这种情况下，depth函数被设置为GL_LESS的默认值，以表明存在其他状态变量，并且可以修改。与glEnable调用相反的是glDisable调用。</strong></p>
<p><strong>OpenGL中的状态概念模仿了面向对象类中静态变量的使用。根据需要，程序员可以启用、禁用和/或设置驻留在显卡上的OpenGL变量的状态。这些状态会影响硬件上的后续计算。一般来说，高效的OpenGL程序试图最小化状态变化，启用需要的状态，同时禁用渲染不需要的状态。</strong></p>
<h2 id="Basic-OpenGL-Application-Layout-基本OpenGL应用程序布局"><a href="#Basic-OpenGL-Application-Layout-基本OpenGL应用程序布局" class="headerlink" title="Basic OpenGL Application Layout 基本OpenGL应用程序布局"></a>Basic OpenGL Application Layout 基本OpenGL应用程序布局</h2><p><strong>一个简单而基本的OpenGL应用程序的核心是一个显示循环，该循环被调用的速度要么尽可能快，要么与监视器或显示设备的刷新率相一致。下面的示例循环使用GLFW库，它支持OpenGL跨多个平台编码。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016123044.png" class="" title="image-20211016123044">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016123056.png" class="" title="image-20211016123056">

<p><strong>循环被严格限制为仅在窗口打开时操作。这个例子循环重置颜色缓冲值，也重置基于先前设置(或默认)值的图形硬件内存中的z-缓冲深度值。输入设备，如键盘、鼠标、网络或其他一些交互机制在循环结束时被处理，以改变与程序相关联的数据结构的状态。对glfwSwapBuffers的调用将图形上下文与显示刷新同步，在前缓冲区和后缓冲区之间执行指针交换，以便更新后的图形状态显示在用户屏幕上。交换缓冲区的调用发生在发出所有图形调用之后。</strong><br><strong>虽然在概念上是分开的，但深度缓冲区和颜色缓冲区通常统称为framebuffer。通过清除framebuffer的内容，应用程序可以继续执行额外的OpenGL调用，通过图形管道推送几何图形和片段。framebuffer与已经打开以包含图形上下文的窗口的大小直接相关。OpenGL需要窗口或视口的尺寸来构造Mvp 矩阵(来自第7章)的硬件。这是通过下面的代码完成的，再次使用GLFW工具包演示，它提供了查询请求窗口(或framebuffer)维度的函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016123154.png" class="" title="image-20211016123154">

<p><strong>在这个例子中，glViewport使用nx和ny为窗口的宽度和高度设置窗口维度的OpenGL状态，并指定视图从原点开始。</strong></p>
<p><strong>从技术上讲，OpenGL在栅格化几何图形和处理片段的操作中写入framebuffer内存。这些写入发生在像素显示在用户监视器上之前。</strong></p>
<h2 id="Geometry-几何学"><a href="#Geometry-几何学" class="headerlink" title="Geometry 几何学"></a>Geometry 几何学</h2><p><strong>与显示缓冲区的概念类似，几何图形也使用数组来存储顶点数据和其他顶点属性，如顶点颜色、法线或着色所需的纹理坐标。缓冲区的概念将被用于在图形硬件上分配存储空间，用于从主机向设备传输数据。</strong></p>
<h3 id="Describing-Geometry-for-the-Hardware-硬件上描述几何形状"><a href="#Describing-Geometry-for-the-Hardware-硬件上描述几何形状" class="headerlink" title="Describing Geometry for the Hardware 硬件上描述几何形状"></a>Describing Geometry for the Hardware 硬件上描述几何形状</h3><p><strong>图形硬件编程的挑战之一是管理3D数据及其在图形硬件内存中的传输。大多数图形硬件使用特定的几何原语集。不同的基元类型利用基元复杂性来提高图形硬件的处理速度。简单的原语有时可以处理得非常快。需要注意的是，原始类型需要是通用的，以便为从非常简单到非常复杂的广泛几何建模。在典型的图形硬件上，基本类型仅限于以下一种或多种:</strong></p>
<p>​    <strong>•点：用于表示点或粒子系统的单个顶点;</strong></p>
<p>​    <strong>•线：顶点对用于表示线，轮廓，或边缘突出;</strong></p>
<p>​    <strong>•三角形：三角形，三角形带，索引三角形，索引三角形带，四边形，或近似几何表面的三角形网格。</strong></p>
<p><strong>这三种基本类型构成了大多数可定义几何体的基本构建块。下图显示了一个用OpenGL渲染的三角形网格的例子。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016123602.png" class="" title="image-20211016123602">

<p>几何图形的组织方式将影响应用程序的性能。小棉白杨峡谷地形数据集的线框图显示了数以万计的三角形组织成一个三角形网格，以实时速率运行。图像使用Ben Discoe提供的VTerrain项目地形系统进行渲染。</p>
<h2 id="A-First-Look-at-Shaders-初探着色器"><a href="#A-First-Look-at-Shaders-初探着色器" class="headerlink" title="A First Look at Shaders 初探着色器"></a>A First Look at Shaders 初探着色器</h2><p><strong>现代版本的OpenGL要求使用着色器来处理顶点和碎片。因此，如果没有至少一个顶点着色器来处理传入的原始顶点和另一个着色器来处理栅格化碎片，就不能渲染原语。高级着色器类型存在于OpenGL和OpenGL着色语言中:几何着色器和计算着色器。几何着色器被设计来处理原语，潜在地创建额外的原语，并且可以支持几何实例化操作。计算着色器是为在GPU上执行一般计算而设计的，并且可以链接到特定应用程序所需的着色器集合中。关于几何和计算着色器的更多信息，读者可以参考OpenGL规范文档和其他资源。</strong></p>
<h3 id="Vertex-Shader-Example-顶点着色器示例"><a href="#Vertex-Shader-Example-顶点着色器示例" class="headerlink" title="Vertex Shader Example 顶点着色器示例"></a>Vertex Shader Example 顶点着色器示例</h3><p><strong>顶点着色器提供了对如何转换顶点的控制，并且经常帮助准备碎片着色器中使用的数据。除了标准的转换和潜在的逐顶点光照操作，顶点着色器可以用于在GPU上执行一般的计算。例如，如果顶点代表粒子，并且粒子运动可以在顶点着色器计算中(简单地)建模，那么CPU基本上可以从执行这些计算中移除。对已经存储在图形硬件内存中的顶点执行计算的能力是一个潜在的性能增益。虽然这种方法在某些情况下是有用的，高级一般计算可能更适当地编码计算着色器。</strong></p>
<p><strong>在第7章，视口矩阵Mvp 介绍了。它将规范视图体积坐标转换为屏幕坐标。在规范视图体积内，坐标存在于[−1,1]范围内。任何超出这个范围的都将被截断。如果我们做一个初始假设，几何存在于这个范围内，z值被忽略，我们可以创建一个非常简单的顶点着色器。这个顶点着色器将顶点位置传递到栅格化阶段，在那里最终的视口转换将发生。注意，由于这种简化，没有投影、查看或模型转换将应用于传入顶点。除了非常简单的场景，这对于创建任何东西来说都是很麻烦的，但这将有助于引入着色器的概念，并允许你在屏幕上渲染一个初始三角形。通过顶点着色器如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017140002.png" class="" title="image-20211017140002">

<p><strong>这个顶点着色器只做一件事。它将进入的顶点位置作为OpenGL用于光栅化片段的gl_position传递出去。注意gl_Position是一个内置的保留变量，它表示顶点着色器所需的关键输出之一。还要注意第一行中的版本字符串。在本例中，该字符串指示GLSL编译器使用GLSL Core配置文件的3.3版本来编译着色语言。</strong></p>
<p><strong>顶点和片段着色器是SIMD操作，分别对管道中正在处理的所有顶点或片段进行操作。额外的数据可以通过使用输入、输出或统一变量从主机传递到在设备上执行的着色器。传递到着色器中的数据以关键字in作为前缀。该数据的位置，因为它与特定的顶点属性或片段输出索引也直接在着色器中指定。因此,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017140244.png" class="" title="image-20211017140244">

<p><strong>指定in_Position是类型为vec3的输入变量。该数据的来源是与几何图形关联的属性索引0。这个变量的名字是由程序员决定的，当在设备上设置顶点数据时，进入的几何体和着色器之间的连接发生。GLSL包含各种各样对图形程序有用的类型，包括vec2、vec3、vec4、mat2、mat3和mat4等等。标准类型如int或float也存在。在着色器编程中，矢量，如vec4包含4个分量，分别对应于齐次坐标的x、y、z和w分量，或者r、g、b和RGBA元组的一个分量。类型的标签可以根据需要进行交换(甚至重复)，这称为swizzling(例如，在Position.zyxa中)。此外，组件标签是重载的，可以适当地使用它来提供上下文。</strong></p>
<p><strong>所有的着色器必须有一个主函数来执行所有输入的主要计算。在这个例子中，main函数简单地将vec3类型的输入顶点位置(In_position)复制到内置的vec4类型的顶点着色输出变量中。注意，许多内置类型都有对转换有用的构造函数，比如这里展示的将进入顶点位置的vec3类型转换为gl_position的vec4类型的构造函数类型。在OpenGL中使用齐次坐标，因此1.0被指定为第四个坐标，以表示向量是一个位置。</strong></p>
<h3 id="Fragment-Shader-Example-碎片着色器示例"><a href="#Fragment-Shader-Example-碎片着色器示例" class="headerlink" title="Fragment Shader Example 碎片着色器示例"></a>Fragment Shader Example 碎片着色器示例</h3><p><strong>如果最简单的顶点着色器只是通过剪辑坐标，最简单的碎片着色器设置碎片的颜色为常量值。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017143442.png" class="" title="image-20211017143442">

<p><strong>在这个例子中，所有的片段将被设置为浅绿色。一个关键的区别是out关键字的使用。一般来说，在着色程序中的关键字In和out表示数据流入和流出着色器。当顶点着色器接收到传入的顶点并将它们输出到一个内置变量时，分段着色器声明它的输出值，并将输出值写入颜色缓冲区:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017143522.png" class="" title="image-20211017143522">

<p><strong>输出变量out_FragmentColor也是用户定义的。输出的位置是颜色缓冲区索引0。片段着色器可以输出到多个缓冲区，但这是留给读者的一个高级主题，如果研究OpenGL的framebuffer对象，将需要它。布局和位置关键字的使用使得应用程序的顶点着色器中的几何数据和片段着色器中的输出颜色缓冲之间有一个明确的连接。</strong></p>
<h3 id="Loading-Compiling-and-Using-Shaders-加载、编译和使用着色器"><a href="#Loading-Compiling-and-Using-Shaders-加载、编译和使用着色器" class="headerlink" title="Loading, Compiling, and Using Shaders 加载、编译和使用着色器"></a>Loading, Compiling, and Using Shaders 加载、编译和使用着色器</h3><p><strong>着色程序以字符串的形式转移到图形硬件上。然后必须对它们进行编译和链接。此外，着色器被耦合到着色程序中，以便顶点和片段处理以一致的方式发生。开发人员可以激活一个已经成功编译并链接到着色程序的着色器，同时也可以在不需要的时候禁用着色器。而具体的创作过程，加载，编译和链接着色程序在本章中没有提供，下面的OpenGL函数将有助于创建着色器:</strong> </p>
<p>​    <strong>•glCreateShader在硬件上创建一个shader句柄。</strong> </p>
<p>​    <strong>•glShaderSource将字符串加载到图形硬件内存中。</strong> </p>
<p>​    <strong>•glCompileShader在硬件中执行着色器的实际编译。</strong> </p>
<p><strong>上面的功能需要为每个着色器调用。因此，对于简单的直通着色器，每个函数都将被顶点着色器代码和片段着色器代码所调用。在编译阶段结束时，可以使用额外的OpenGL命令查询编译状态和任何错误。</strong></p>
<p><strong>在两个着色器代码加载和编译后，它们可以链接到着色器程序。着色程序是用来影响几何图形的渲染。</strong></p>
<p>​    <strong>•glCreateProgram创建一个程序对象，该对象将包含先前编译的着色器。</strong> </p>
<p>​    <strong>•glAttachShader将一个shader附加到shader程序对象。在这个简单的例子中，编译后的顶点着色器和编译后的碎片着色器对象都会调用这个函数。</strong></p>
<p>​    <strong>•在所有着色器被附加到程序对象之后，glLinkProgram在内部链接着色器。</strong></p>
<p>​    <strong>•glUseProgram绑定用于图形硬件的着色程序。由于需要着色器，程序句柄使用这个函数绑定。当不需要着色器时，它们可以通过使用着色程序句柄0作为这个函数的参数来解除绑定。</strong></p>
<h2 id="Vertex-Buffer-Objects-顶点缓冲区对象"><a href="#Vertex-Buffer-Objects-顶点缓冲区对象" class="headerlink" title="Vertex Buffer Objects 顶点缓冲区对象"></a>Vertex Buffer Objects 顶点缓冲区对象</h2><p><strong>顶点使用缓冲区存储在图形硬件上，称为顶点缓冲区对象。除了顶点，任何额外的顶点属性，如颜色、法向量或纹理坐标，也将使用顶点缓冲对象指定。</strong></p>
<p><strong>首先，让我们关注几何原语本身。首先在应用程序的主机内存中分配与原语关联的顶点。最常用的方法是在主机上定义一个数组来包含原语所需的顶点。例如，一个完全包含在标准体积中的三角形，可以在主机上静态定义，如下所示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017144408.png" class="" title="image-20211017144408">

<p><strong>如果这个三角形使用简单的透传着色器，那么所有的顶点都将被渲染。尽管三角形被放置在z = 0平面上，但是这个例子中的z坐标并不重要，因为它们实际上是在最终转换为屏幕坐标时被丢弃的。另一件需要注意的事情是在这些示例中使用了类型GLfloat。就像GLSL语言有专门的类型一样，OpenGL也有相关类型，这些类型通常可以与标准类型很好地混合在一起(比如float)。为了精确起见，OpenGL类型将在必要时使用。</strong></p>
<p><strong>在处理顶点之前，首先在设备上创建一个顶点缓冲区来存储顶点。然后，主机上的顶点被传输到设备。在此之后，可以根据需要引用顶点缓冲区来绘制存储在缓冲区中的顶点数组。此外，在初始顶点数据传输之后，不需要在主机上向设备总线复制额外的数据，特别是在渲染循环更新过程中几何形状保持静态的情况下。如果是动态分配的，也可以删除任何主机内存。</strong></p>
<p><strong>顶点缓冲对象，通常称为VBOs，代表了现代OpenGL在图形存储器中存储顶点和顶点属性的主要机制。为了提高效率，VBO的初始设置和顶点相关数据的传输通常发生在进入显示循环之前。例如，要为这个三角形创建一个VBO，可以使用以下代码:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017144658.png" class="" title="image-20211017144658">

<p><strong>创建和分配顶点缓冲区对象需要三个OpenGL调用。首先，glGenBuffers创建一个句柄，一旦VBO存储在设备上，就可以使用该句柄来引用它。可以在一个glGenBuffers调用中创建多个VBOs句柄(存储在数组中)，如图所示，但这里没有使用。请注意，当生成缓冲区对象时，设备上的实际空间分配尚未执行。</strong></p>
<p><strong>在OpenGL中，对象(比如顶点缓冲区对象)是计算和处理的主要目标。对象必须绑定到一个已知的OpenGL状态使用时松开，不使用时松开。OpenGL使用对象的例子包括顶点缓冲对象、framebuffer对象、纹理对象和着色程序等等。在当前的例子中，OpenGL的GL_ARRAY_BUFFER状态绑定到之前生成的三角形VBO句柄。这使得三角形VBO成为活动顶点缓冲区对象。任何跟随glBindBuffer(GL_ARRAY_BUFFER, triangleVBO[0])命令的影响顶点缓冲区的操作都将通过读数据或写数据来使用VBO中的三角形数据。</strong></p>
<p><strong>顶点数据从主机(顶点数组)复制到设备(当前绑定的GL_ARRAY_BUFFER)使用</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017144907.png" class="" title="image-20211017144907">

<p><strong>调用。参数表示目标的类型、要复制的缓冲区的字节大小、指向主机缓冲区的指针以及指示如何使用缓冲区的枚举类型。在当前的示例中，目标是GL_ARRAY_BUFFER，数据的大小是9∗sizeof(GLfloat)，最后一个参数是GL_STATIC_DRAW，指示OpenGL顶点在渲染过程中不会改变。最后，当VBO不再需要作为读写的活动目标时，它将通过glBindBuffer(GL_ARRAY_BUFFER, 0)调用解除绑定。通常，绑定任何OpenGL的对象或缓冲区来处理0，解除绑定，或禁用该缓冲区，以免影响后续功能。</strong></p>
<h2 id="Vertex-Array-Objects-顶点数组对象"><a href="#Vertex-Array-Objects-顶点数组对象" class="headerlink" title="Vertex Array Objects 顶点数组对象"></a>Vertex Array Objects 顶点数组对象</h2><p><strong>顶点缓冲区对象是顶点(和顶点属性)的存储容器，顶点数组对象代表OpenGL的机制，将顶点缓冲区捆绑在一起，形成一致的顶点状态，可以与图形硬件中的着色器通信和链接。回想一下，过去的固定函数管道不再存在，因此，每个顶点的状态，如法线或甚至顶点颜色，必须存储在硬件缓冲区中，然后使用输入变量(如in)在着色器中引用。</strong></p>
<p><strong>与顶点缓冲区对象一样，必须在绑定顶点数组对象时创建和分配顶点数组对象(或VAOs)，并设置任何必要的状态。例如，下面的代码展示了如何创建一个VAO来包含之前定义的三角形VBO:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145242.png" class="" title="image-20211017145242">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145305.png" class="" title="image-20211017145305">

<p><strong>当定义一个顶点数组对象时，特定的顶点缓冲对象可以绑定到着色器代码中的特定顶点属性(或输入)。使用</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145416.png" class="" title="image-20211017145416">

<p><strong>在直通顶点着色器中。这个语法表示着色器变量将从绑定顶点数组对象的属性索引0接收数据。在主机代码中，使用</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145432.png" class="" title="image-20211017145432">

<p><strong>调用。第一个调用启用顶点属性索引(在本例中为0)。接下来的两个调用将之前定义的保存顶点的顶点缓冲区对象连接到顶点属性本身。因为glVertexAttribPointer利用了当前绑定的VBO，所以在分配顶点属性指针之前发出glBindBuffer是很重要的。这些函数调用创建一个映射，将顶点缓冲区中的顶点绑定到顶点着色器中的in Position变量。glVertexAttribPointer调用看起来很复杂，但它基本上设置了属性索引0来保存未标准化(第四个参数)的GLfloats(第2和第3个参数)的三个组件(例如x, y, z)。第五个参数指示OpenGL用三个浮点值分隔每个顶点集的起点。换句话说，这些顶点一个接一个地紧密地封装在内存中。最后一个参数是一个指向数据的指针，但是因为在此调用之前已经绑定了一个顶点缓冲区，所以数据将与顶点缓冲区相关联。</strong></p>
<p><strong>前面初始化和构造顶点数组对象、顶点缓冲对象和着色器的步骤都应该在进入显示循环之前执行。所有来自顶点缓冲区的内存将被转移到GPU，顶点阵列对象将在数据和着色器输入变量索引之间建立连接。在显示循环中，以下调用将触发顶点数组对象的处理:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145608.png" class="" title="image-20211017145608">

<p><strong>再次注意，bind调用使顶点数组对象处于活动状态。对glDrawArrays的调用为这个几何图形启动了管线，描述了这个几何图形应该被解释为一系列从偏移量0开始的三角形原语，并且只呈现三个索引。在本例中，数组中只有三个元素，而原语是一个三角形，因此将呈现一个三角形。</strong></p>
<p><strong>结合所有这些步骤，为三角形组装的代码将类似如下，假设着色器和顶点数据加载包含在外部函数中:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145728.png" class="" title="image-20211017145728">

<p><strong>下图显示了使用着色器和顶点状态渲染规范视图体积三角形的结果。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145741.png" class="" title="image-20211017145741">

<p>标准三角形使用简单的顶点和碎片着色器渲染。</p>
<h2 id="Transformation-Matrices-变换矩阵"><a href="#Transformation-Matrices-变换矩阵" class="headerlink" title="Transformation Matrices 变换矩阵"></a>Transformation Matrices 变换矩阵</h2><p><strong>当前版本的OpenGL已经删除了曾经用于从硬件中引用投影和模型视图矩阵的矩阵堆栈。因为这些矩阵堆栈不再存在，程序员必须编写矩阵代码，可以转移到将发生转换的顶点着色器。起初，这似乎具有挑战性。但是，已经开发了几个库和工具包来帮助OpenGL代码的跨平台开发。其中一个库，GLM，或OpenGL Mathematics，已经被开发用于密切跟踪OpenGL和GLSL规范，以便GLM和硬件之间的互操作能够无缝地工作。</strong></p>
<h3 id="GLM"><a href="#GLM" class="headerlink" title="GLM"></a>GLM</h3><p><strong>GLM提供了几种对计算机图形学有用的基本数学类型。出于我们的目的，我们将专注于少数类型和少数功能，使矩阵变换在着色器中容易使用。以下几种类型将被使用:</strong></p>
<p>​    <strong>•glm::vec3：一个由3个浮点数组成的紧凑数组，可以在着色器中使用相同的组件访问;</strong> </p>
<p>​    <strong>•glm::vec4：一个由4个浮点数组成的紧凑数组，可以在着色器中使用相同的组件访问;</strong> </p>
<p>​    <strong>•glm:: mat4：一个4 × 4矩阵存储，表示为16个浮点数。矩阵是以column-major格式存储的。</strong> </p>
<p><strong>类似地，GLM提供用于创建投影矩阵Morth 和Mp的函数，以及生成视图矩阵Mcam的函数：</strong> </p>
<p>​    <strong>•glm::ortho：创建一个4 × 4正投影矩阵。</strong></p>
<p>​    <strong>•glm::perspective：创建4 × 4透视矩阵。</strong> </p>
<p>​    <strong>•glm::lookAt：创建4 × 4的齐次变换，转换和朝向镜头。</strong></p>
<h3 id="Using-an-Orthographic-Projection-使用正投影法"><a href="#Using-an-Orthographic-Projection-使用正投影法" class="headerlink" title="Using an Orthographic Projection 使用正投影法"></a>Using an Orthographic Projection 使用正投影法</h3><p><strong>前面示例的一个简单扩展是将三角形顶点放置到一个更灵活的坐标系统中，并使用正交投影渲染场景。前一个例子中的顶点可以变成:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150409.png" class="" title="image-20211017150409">

<p><strong>使用GLM，可以很容易地在主机上创建正投影。例如,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150430.png" class="" title="image-20211017150430">

<p><strong>然后可以将投影矩阵应用于每个顶点，将其转换为剪辑坐标。顶点着色器将被修改来执行这个操作:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150447.png" class="" title="image-20211017150447">

<p><strong>这个计算将发生在一个修改过的顶点着色器中，它使用统一变量从主机向设备传递数据。统一变量表示在着色程序执行过程中保持不变的静态数据。所有元素的数据都是相同的，并且保持静态。然而，统一的变量可以被应用程序在执行着色器之间修改。这是宿主应用程序中的数据可以与着色器计算交流变化的主要机制。统一数据通常表示与应用程序相关联的图形状态。例如，投影、视图或模型矩阵可以通过统一变量设置和访问。关于场景中的光源的信息也可以通过均匀变量来获得。</strong></p>
<p><strong>修改顶点着色器需要添加一个统一的变量来保持投影矩阵。我们可以使用GLSL的mat4类型来存储这些数据。然后可以自然地使用投影矩阵将进入的顶点转换为规范坐标系:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150530.png" class="" title="image-20211017150530">

<p><strong>应用程序代码只需要将统一变量从主机内存(GLM mat4)转移到设备的着色程序(GLSL mat4)。这很简单，但需要在着色程序被链接之后，应用程序的主机端获得一个统一变量的句柄。例如，为了获得projMatrix变量的句柄，在着色程序链接完成后，将发出下面的调用:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150603.png" class="" title="image-20211017150603">

<p><strong>第一个参数是shader程序对象句柄，第二个参数是shader中变量名的字符串。然后，这个id可以与各种OpenGL glUniform函数调用一起使用，以将主机上的内存转移到设备上。然而，着色程序必须在设置与统一变量相关的值之前被绑定。另外，由于GLM用于在主机上存储投影矩阵，因此将使用GLM助手函数来获取指向底层矩阵的指针，并允许继续复制。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150647.png" class="" title="image-20211017150647">

<p><strong>注意glUniform采用的形式。函数名以帮助定义如何使用它的字符结尾。在这种情况下，一个4 × 4的浮点矩阵被转移到均匀变量。v表示数组包含数据，而不是按值传递。第三个参数让OpenGL知道矩阵是否应该被转置(一个可能很方便的特性)，最后一个参数是一个指向矩阵所在内存的指针。</strong></p>
<p><strong>通过本章的这一节，你应该对着色器和顶点数据在OpenGL渲染对象中所扮演的角色有一个感觉。特别是着色器，在现代OpenGL中扮演着非常重要的角色。其余部分将进一步探讨着色器在渲染场景中的作用，尝试建立在着色器在本书中呈现的其他渲染风格中的作用。</strong></p>
<h2 id="Shading-with-Per-Vertex-Attributes-逐顶点属性着色"><a href="#Shading-with-Per-Vertex-Attributes-逐顶点属性着色" class="headerlink" title="Shading with Per-Vertex Attributes 逐顶点属性着色"></a>Shading with Per-Vertex Attributes 逐顶点属性着色</h2><p><strong>前面的示例指定了一个没有附加数据的三角形。顶点属性，如法向量、纹理坐标，甚至颜色，都可以在顶点缓冲区中与顶点数据交叉。内存布局很简单。下面，每个顶点的颜色设置在数组中的每个顶点之后。三个组件用于表示红色、绿色和蓝色通道。分配顶点缓冲区是相同的，只是数组的大小现在是18 GLfloats而不是9。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018131914.png" class="" title="image-20211018131914">

<p><strong>顶点数组对象的规范是不同的。因为颜色数据在顶点之间交错，顶点属性指针必须适当地跨数据。也必须启用第二个顶点属性索引。在前面例子的基础上，我们构造新的VAO如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018131958.png" class="" title="image-20211018131958">

<p><strong>由于顶点和颜色数据都包含在VBO中，所以在设置属性之前使用和绑定单个VBO。第一个顶点属性在索引0处启用，这将代表着色器中的顶点。注意，步幅(第5个参数)是不同的，因为顶点被6个浮点数分开(例如，顶点的x, y, z后跟颜色的r, g, b)。第二个顶点属性索引是启用的，它将表示着色器中位置1的顶点颜色属性。它有相同的步幅，但是最后一个参数现在表示第一个颜色值开始的指针偏移量。虽然在上面的示例中使用了12，但这与声明3 * sizeof(GLfloat)是相同的。换句话说，我们需要跳过代表顶点x、y、z值的三个浮点数来定位数组中的第一个color属性。</strong></p>
<p><strong>这个例子的着色器只做了轻微的修改。顶点着色器(如下所示)的主要区别是:(1)第二个属性，颜色，位于位置1;(2)vColor是在顶点着色器的主体中设置的输出变量。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132110.png" class="" title="image-20211018132110">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132123.png" class="" title="image-20211018132123">

<p><strong>回想一下，关键字in和out指的是着色器之间的数据流。如果变量名称匹配，从顶点着色器流出的数据将成为连接片段着色器中的输入数据。此外，传递给碎片着色器的输出变量是使用重心插值的碎片。可以使用额外的关键字对插值进行一些修改，但这些细节将留给读者。在这个例子中，指定了三个顶点，每个顶点都有一个特定的颜色值。在碎片着色器中，颜色将被插值到三角形的表面。</strong></p>
<p><strong>碎片着色器的改变是简单的。vColor变量被设置并传递出顶点着色器，现在变成了一个in变量。当片段被处理时，vColor vec3将根据片段在三角形中的位置包含正确的插值值。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132301.png" class="" title="image-20211018132301">

<p><strong>使用三角形数据运行这个着色器的结果如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132330.png" class="" title="image-20211018132330">

<p>在顶点着色器中设置每个顶点的颜色，并将数据传递给碎片着色器，结果是颜色的重心插值。</p>
<h3 id="Structs-of-Vertex-Data-顶点数据结构"><a href="#Structs-of-Vertex-Data-顶点数据结构" class="headerlink" title="Structs of Vertex Data 顶点数据结构"></a>Structs of Vertex Data 顶点数据结构</h3><p><strong>前面的示例演示了数组中数据的交错。顶点缓冲可以以多种方式使用，包括针对不同模型属性的单独顶点缓冲。交错数据具有优势，因为与某个顶点相关联的属性在内存中靠近该顶点，因此可以利用它在着色器中操作时的内存局部性。虽然这些交错数组的使用很简单，但以这种方式管理大型模型可能会变得很麻烦，特别是当数据结构被用于构建健壮的(和可持续的)图形软件基础结构时(见第12章)。将顶点数据存储为包含顶点和任何相关属性的结构的向量是相当简单的。当这样做时，结构只需要映射到顶点缓冲区。例如，下面的结构包含顶点位置和顶点颜色，使用GLM的vec3类型:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132540.png" class="" title="image-20211018132540">

<p><strong>STL向量将保存与模型中所有三角形相关的所有顶点。我们将继续使用与前面示例相同的三角形布局，即基本三角形带。列表中每三个顶点代表一个三角形。OpenGL还可以使用其他数据组织，第12章提供了更有效地组织数据的其他选项。</strong></p>
<p><strong>一旦数据加载到向量中，在将数据加载到顶点缓冲区对象之前使用了相同的调用:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132617.png" class="" title="image-20211018132617">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132630.png" class="" title="image-20211018132630">

<p><strong>STL向量连续存储数据。上面使用的vertexData结构体由平面内存布局表示(它不包含指向其他数据元素的指针)，并且是连续的。然而，STL向量是一个抽象，引用底层内存的指针必须使用data()成员进行查询。该指针提供给对glBufferData的调用。顶点数组对象中的属性分配是相同的，因为顶点属性的位置保持不变。</strong></p>
<h2 id="Shading-in-the-Fragment-Processor-碎片处理器着色"><a href="#Shading-in-the-Fragment-Processor-碎片处理器着色" class="headerlink" title="Shading in the Fragment Processor 碎片处理器着色"></a>Shading in the Fragment Processor 碎片处理器着色</h2><p><strong>图形管线章节(第8章)和表面着色章节(第10章)很好地描述和说明了逐顶点和逐片段着色的效果，因为它们通常与栅格化和着色相关。在现代图形硬件中，在片段处理器中应用着色算法可以产生更好的视觉效果，更准确地逼近光照。在逐顶点基础上计算的着色通常会受到与底层几何镶嵌相关的视觉伪影的影响。特别是，基于每个顶点的着色经常不能在三角形的表面上近似适当的强度，因为光照只在每个顶点上计算。例如，当与光源的距离较小时，与被遮挡的脸的大小相比，脸上的照明就会不正确。下图说明了这种情况。三角形的中心将不会被照亮，尽管非常接近光源，因为顶点上的照明，远离光源，是用来插值整个面部的着色。当然，增加几何的镶嵌可以改善视觉效果。然而，这种解决方案在实时图形中的应用有限，因为为更精确的光照而添加的几何图形会导致渲染速度变慢。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018133310.png" class="" title="image-20211018133310">

<p>与光源的距离很小与三角形的大小有关。</p>
<p><strong>碎片着色器在顶点被转换和裁剪后从栅格化中出现的碎片上操作。一般来说，片段着色器必须输出一个写入framebuffer的值。通常，这是像素的颜色。如果启用了深度测试，则将使用片段的深度值来控制是否将颜色及其深度写入framebuffer内存。碎片着色器用于计算的数据来自不同的来源:</strong></p>
<p>​    <strong>•内置OpenGL变量：这些变量是由系统提供的。片段着色器变量的例子包括gl_FragCoord或gl_FrontFacing。这些变量可能会根据OpenGL和GLSL的修订而改变，所以建议您检查您所瞄准的OpenGL和GLSL版本的规范。</strong></p>
<p>​    <strong>•统一变量：统一变量从主机转移到设备，并可以根据用户输入或应用程序中的模拟状态的变化而根据需要进行更改。这些变量由程序员声明和定义，在顶点和片段着色器中使用。在之前的顶点着色例子中的投影矩阵是通过统一变量传达给着色器的。如果需要，相同的统一变量名称可以在顶点和碎片着色器中使用。</strong></p>
<p>​    <strong>•输入变量：输入变量是在片段着色器中用带前缀的关键字in指定的。回想一下，数据可以流入和流出着色器。顶点着色器可以使用out关键字将数据输出到下一个着色器阶段(例如，在前面的例子中，out vec3 vColor)。当下一阶段使用in关键字，后面跟着相同的类型和名称限定符时，输出被链接到输入(例如，在vec3 vColor中，在前面例子中对应的片段着色器)。</strong></p>
<p><strong>任何通过输入-输出链接机制传递到片段着色器的数据都将使用重心插值在每个片段的基础上变化。插值运算是由图形硬件在着色器之外计算的。在这个基础结构中，碎片着色器可以用来执行每个碎片着色算法，评估整个三角形表面的特定方程。顶点着色器提供了对计算的支持，转换顶点和分段的中间值将被插入片段代码。</strong></p>
<p><strong>下面的着色程序代码实现了每个片段，Blinn-Phong着色。它汇集了本章到目前为止所呈现的大部分内容，并将其绑定到第4章的着色器描述中。交错顶点缓冲区用于包含顶点位置和法向量。这些值在顶点着色器中显示为索引0和索引1的顶点数组属性。在片段着色器代码中发生的着色计算是在摄像机坐标(有时称为眼空间)中执行的。</strong></p>
<h3 id="Blinn-Phong-Shader-Program-Vertex-Shader-Blinn-Phong着色程序-顶点着色器"><a href="#Blinn-Phong-Shader-Program-Vertex-Shader-Blinn-Phong着色程序-顶点着色器" class="headerlink" title="Blinn-Phong Shader Program: Vertex Shader Blinn-Phong着色程序:顶点着色器"></a>Blinn-Phong Shader Program: Vertex Shader Blinn-Phong着色程序:顶点着色器</h3><p><strong>我们的程序的顶点着色阶段是使用Mmodel 和Mcam 矩阵来将进入的顶点转换为摄像机坐标。它也使用(M ^−1) ^T，以适当地变换入法向量属性。顶点着色器输出三个变量到片段阶段:</strong> </p>
<p><strong>•法线：将顶点的法向量转换为摄像机坐标系统。</strong> </p>
<p><strong>•h： Blinn-Phong着色所需的半矢量。</strong> </p>
<p><strong>•l：光线方向转换为摄像机坐标系统。</strong> </p>
<p><strong>在应用重心插值后，这些变量中的每一个都可以用于碎片计算。</strong></p>
<p><strong>这个着色器程序使用单点光源。光的位置和强度使用统一的变量传达给顶点和碎片着色器。light数据是使用GLSL的结构限定符声明的，它允许变量以有意义的方式分组在一起。虽然这里没有介绍，但GLSL支持数组和for循环控制结构，因此可以很容易地向本示例添加额外的光源。</strong></p>
<p><strong>所有矩阵也使用统一变量提供给顶点着色器。现在，我们将想象模型(或局部变换)矩阵将被设置为单位矩阵。在下一节中，将提供更多细节，以扩展如何使用GLM在主机上指定模型矩阵。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018133907.png" class="" title="image-20211018133907">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018133934.png" class="" title="image-20211018133934">

<p><strong>顶点着色器的主要功能首先使用vec4类型将位置和光线位置转换为摄像机坐标，以对应GLSL的mat4的4 × 4矩阵。然后我们转换法向量并将其存储在out vec4法向量变量中。然后计算视图(或眼睛)向量和光方向向量，这导致计算Blinn-Phong着色所需的半向量。最后的计算完成了计算</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134020.png" class="" title="image-20211018134020">

<p><strong>通过应用投影矩阵。然后它将顶点的标准坐标设置为内置的GLSL顶点着色器输出变量gl_Position。在此之后，顶点在剪辑坐标中，并准备光栅化。</strong></p>
<h3 id="Blinn-Phong-Shader-Program-Fragment-Shader-Blinn-Phong-着色程序-碎片着色器"><a href="#Blinn-Phong-Shader-Program-Fragment-Shader-Blinn-Phong-着色程序-碎片着色器" class="headerlink" title="Blinn-Phong Shader Program: Fragment Shader Blinn-Phong 着色程序:碎片着色器"></a>Blinn-Phong Shader Program: Fragment Shader Blinn-Phong 着色程序:碎片着色器</h3><p><strong>碎片着色器计算Blinn-Phong着色模型。它接收顶点法向量、半矢量和光方向的重心插值值。注意，当这些变量从顶点处理阶段进入时，使用in关键字指定它们。光线数据也与碎片着色器共享，使用相同的统一规范在顶点着色器中使用。矩阵不是必需的，所以没有声明统一的矩阵变量。几何模型的材料属性通过统一变量来指定ka,kd,ks,Ia和p，数据允许碎片着色器计算公式4.3:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134541.png" class="" title="image-20211018134541">

<p><strong>在每一个片段。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134612.png" class="" title="image-20211018134612">

<p><strong>碎片着色器将计算出的强度写入碎片颜色输出缓冲区。下图展示了几个例子，展示了在几何模型上不同程度的镶嵌中每个碎片着色的效果。这个片段着色器引入了结构的使用来保持一致的变量。需要注意的是，它们是用户定义的结构，在本例中，LightData类型仅保存光的位置和强度。在宿主代码中，结构中的统一变量在请求统一变量句柄时使用完全限定变量名引用，如:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134701.png" class="" title="image-20211018134701">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134712.png" class="" title="image-20211018134712">

<p>每个碎片着色应用于增加细分球体的镶嵌。镜面高光在较低镶嵌时很明显。</p>
<h3 id="A-Normal-Shader-法线着色器"><a href="#A-Normal-Shader-法线着色器" class="headerlink" title="A Normal Shader 法线着色器"></a>A Normal Shader 法线着色器</h3><p><strong>一旦你有一个工作着色程序，如Blinn-Phong，它很容易扩展你的想法和开发新的着色器。它也可能有助于开发一套非常具体的着色器调试。一个这样的着色程序是普通的着色程序。法线着色通常有助于理解进入的几何结构是否组织正确或计算是否正确。在这个例子中，顶点着色器保持不变。只有碎片着色器改变:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135010.png" class="" title="image-20211018135010">

<p><strong>无论你开始构建哪个着色器，一定要注释!GLSL规范允许在着色器代码中包含注释，所以请留下一些细节，以便以后指导您。</strong></p>
<h2 id="Meshes-and-Instancing-网格和实例化"><a href="#Meshes-and-Instancing-网格和实例化" class="headerlink" title="Meshes and Instancing 网格和实例化"></a>Meshes and Instancing 网格和实例化</h2><p><strong>一旦基本的着色器开始工作，开始创建更复杂的场景是很有趣的。有些3D模型文件很容易加载，而有些则需要付出更多的努力。OBJ格式是一种简单的3D对象文件表示。OBJ是一种广泛使用的格式，有一些代码可以加载这些类型的文件。前面介绍的结构体数组机制可以很好地在主机上包含OBJ数据。然后可以很容易地将其转移到VBO和顶点数组对象中。</strong></p>
<p><strong>许多3D模型都是在它们自己的局部坐标系统中定义的，需要进行各种转换以使它们与OpenGL坐标系统保持一致。例如，当Stanford Dragon的OBJ文件被加载到OpenGL坐标系统时，它会显示在原点的一侧。使用GLM，我们可以创建模型转换来放置场景中的对象。对于龙模型，这意味着绕X旋转- 90度，然后转换成Y向上，有效的模型转换成为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135335.png" class="" title="image-20211018135335">

<p><strong>龙垂直放置在地平面上方，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135421.png" class="" title="image-20211018135421">

<p>从左到右描述图像。龙的默认本地方向，侧卧。绕X旋转-90度后，龙是直立的，但仍然以起源为中心。最后，在Y应用1.0的平移后，龙已经完成实例化准备了。</p>
<p><strong>为此，我们利用GLM中的几个函数来生成局部模型转换:</strong></p>
<p>​    <strong>•glm::translate创建一个平移矩阵。</strong> </p>
<p>​    <strong>•glm::rotate创建一个旋转矩阵，以特定的角度或弧度指定。</strong> </p>
<p>​    <strong>•glm::scale创建一个缩放矩阵。</strong></p>
<p><strong>我们可以应用这些函数来创建模型转换，并使用统一变量将模型矩阵传递给着色器。Blinn-Phong顶点着色器包含了将局部变换应用到传入顶点的指令。下面的代码展示了如何呈现龙模型:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135824.png" class="" title="image-20211018135824">

<h3 id="Instancing-Models-实例化模型"><a href="#Instancing-Models-实例化模型" class="headerlink" title="Instancing Models 实例化模型"></a>Instancing Models 实例化模型</h3><p><strong>使用OpenGL实例化的实现与使用射线跟踪器实例化的实现是不同的。利用光线追踪器，利用模型变换矩阵将光线反变换到物体的局部空间。在OpenGL中，实例化是通过加载对象的单个副本作为顶点数组对象(与相关的顶点缓冲对象)来执行的，然后根据需要重用几何图形。像射线跟踪器一样，只有一个对象被加载到内存中，但是很多对象都可以被渲染。</strong></p>
<p><strong>现代OpenGL很好地支持这种类型的实例化，因为顶点着色器可以(而且必须)计算必要的转换来将顶点转换为剪辑坐标。通过编写嵌入这些转换的通用着色器，如Blinn-Phong顶点着色器，模型可以用相同的底层局部几何重新着色。不同的材料类型和转换可以从更高级别的类结构中查询，以填充从主机到设备每帧传递的统一变量。动画和交互控制也很容易创建，因为模型转换可以在显示循环迭代中随时间变化。下两图使用了一条龙的内存占用，但在屏幕上呈现了三种不同的龙模型。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135954.png" class="" title="image-20211018135954">

<p>在三只龙上运行Blinn-Phong着色程序的结果使用统一变量指定材质属性和变换。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018140006.png" class="" title="image-20211018140006">

<p>在Blinn- Phong着色程序中设置统一变量ks =(0,0,0)产生Lambertian着色。</p>
<h2 id="Texture-Objects-纹理对象"><a href="#Texture-Objects-纹理对象" class="headerlink" title="Texture Objects 纹理对象"></a>Texture Objects 纹理对象</h2><p><strong>纹理是使用OpenGL着色器操作视觉效果的有效方法。它们与许多基于硬件的图形算法一起广泛使用，OpenGL通过纹理对象原生地支持它们。和之前的OpenGL概念一样，纹理对象必须通过将主机上的数据复制到GPU内存中并设置OpenGL状态来分配和初始化。纹理坐标通常集成到顶点缓冲对象中，并作为顶点属性传递给着色程序。片段着色器通常使用从顶点着色器传递的插值纹理坐标来执行纹理查找功能。</strong></p>
<p><strong>如果你已经有了工作着色器和顶点数组对象，纹理是相当简单的添加到你的代码中。用于在硬件上创建对象的标准OpenGL技术与纹理一起使用。然而，纹理数据的来源必须首先确定。数据可以从文件加载(例如，PNG, JPG, EXR，或HDR图像文件格式)或在主机上程序生成(甚至在GPU上)。数据加载到主机内存后，数据被复制到GPU内存中，并且可以选择设置与纹理相关的OpenGL状态。OpenGL纹理数据被加载为内存的线性缓冲区，其中包含用于纹理的数据。硬件上的纹理查询可以是1D、2D或3D查询。无论纹理维度查询是什么，数据都被加载到内存以同样的方式，使用主机上线性分配的内存。在下面的示例中，从图像文件加载数据(或程序生成数据)的过程留给读者，但是提供了与加载图像时可能出现的变量名相匹配的变量名(例如，imgData, imgWidth, imgHeight)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019124105.png" class="" title="image-20211019124105">

<p><strong>这里展示的例子强调了如何使用shader程序设置和使用基本的2D OpenGL纹理。创建OpenGL对象的过程现在应该很熟悉了。必须在设备上生成一个句柄(或ID)来引用纹理对象(例如，在本例中，texID)。然后id被绑定以允许任何后续的纹理状态操作影响纹理的状态。OpenGL存在一组相当广泛的纹理状态和参数，影响纹理坐标解释和纹理查找过滤。图形硬件中存在各种纹理目标。在这种情况下，纹理目标被指定为GL_texture_2D，并将作为纹理相关函数的第一个参数出现。对于OpenGL来说，这个特定的纹理目标意味着纹理坐标将以设备标准化的方式指定(例如:，取值范围[0,1])。此外，必须分配纹理数据，使宽度和高度尺寸为2的幂(例如，512 × 512, 1024 × 512等)。通过调用glTexParameter为当前绑定的纹理设置纹理参数。这个函数的签名根据被设置的数据类型有多种形式。在这种情况下，纹理坐标将被硬件固定到显式范围[0,1]。OpenGL纹理对象的缩小和放大过滤器被设置为在执行纹理查找时自动使用线性过滤(而不是最近邻- GL_nearest)。第11章提供了纹理的大量细节，包括纹理查找时可能发生的过滤的细节。图形硬件可以通过设置相关的纹理状态来自动执行这些操作。</strong></p>
<p><strong>最后，调用glTexImage2D执行纹理的主机设备复制。这个函数有几个参数，但总体操作是在显卡上分配三个浮点数(第7和第8个参数:GL_RGB和GL_FLOAT)的空间(例如imageWidth X imgHeight)，并将线性纹理数据复制到硬件(例如imgData指针)。剩下的参数处理设置mipmap的细节级别(第2个参数)，指定内部格式(例如，第3个参数的GL_RGB)和纹理是否有边界(第6个参数)。当学习OpenGL纹理时，保持这些为这里列出的默认纹理是安全的。然而，建议读者了解更多关于mipmaps和纹理的潜在内部格式，因为需要更高级的图形处理。</strong></p>
<p><strong>纹理对象分配和初始化在上面的代码中进行。必须对顶点缓冲和顶点数组对象进行额外的修改，以链接到正确的纹理坐标与几何描述。在前面的例子中，纹理坐标的存储是对顶点数据结构的直接修改:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019124829.png" class="" title="image-20211019124829">

<p><strong>因此，顶点缓冲对象的大小将增加，而纹理坐标的交错将需要改变顶点数组对象的顶点属性规范中的步数。下图说明了顶点缓冲区内数据的基本交错。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019124917.png" class="" title="image-20211019124917">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019124902.png" class="" title="image-20211019124902">

<p>将纹理坐标添加到顶点缓冲区后的数据布局。每个块代表一个4字节的GLfloat。位置编码为白色块，法线编码为紫色，纹理坐标编码为橙色。</p>
<p><strong>使用上面的代码片段，纹理坐标被放置在顶点属性位置2。注意纹理坐标大小的变化(例如，glVertexAttribPointer的第二个参数是2，用于纹理坐标与结构中的vec2类型一致)。此时，纹理对象的所有初始化都将完成。</strong></p>
<p><strong>纹理对象必须在使用着色器渲染顶点数组对象之前启用(或绑定)。通常，图形硬件在执行着色程序时允许使用多个纹理对象。这样，着色程序可以应用复杂的纹理和视觉效果。因此，为使用着色器绑定一个纹理，它必须关联到一个潜在的纹理单位。纹理单位表示着色器可以使用多个纹理的机制。在下面的示例中，只使用了一个纹理，因此纹理单元0将被激活并绑定到我们的纹理。</strong></p>
<p><strong>激活纹理单位的函数是glActiveTexture。它唯一的参数是要激活的纹理单元。它被设置为GL_TEXTURE0下面，但它可以是GL_TEXTURE1或GL_TEXTURE2，例如，如果在着色器中需要多个纹理。一旦一个纹理单元被激活，就可以使用glBindTexture调用将纹理对象绑定到它。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125104.png" class="" title="image-20211019125104">

<p><strong>上面的大部分代码应该是对您目前所开发的代码的逻辑扩展。注意在呈现顶点数组对象之前调用glUniform。在现代图形硬件编程中，着色器执行纹理查找和混合的工作，因此，必须有关于在着色器中使用的纹理的纹理单元的数据。活动纹理单元使用统一变量提供给着色器。在本例中，0被设置为表示纹理查找将来自纹理单元0。这将在下一节中展开。</strong></p>
<h3 id="Texture-Lookup-in-Shaders-着色器中的纹理查找"><a href="#Texture-Lookup-in-Shaders-着色器中的纹理查找" class="headerlink" title="Texture Lookup in Shaders 着色器中的纹理查找"></a>Texture Lookup in Shaders 着色器中的纹理查找</h3><p><strong>着色程序执行查找和任何可能需要的混合。大部分的计算通常进入碎片着色器，但顶点着色器经常通过传递纹理坐标到碎片着色器阶段碎片计算。通过这种方式，纹理坐标将被插值，并提供纹理数据的每个片段查找。</strong></p>
<p><strong>在shader程序中使用纹理数据需要进行简单的更改。使用之前提供的Blinn-Phong顶点着色器，只需要三个更改:</strong></p>
<p><strong>1.纹理坐标是存储在顶点数组对象中的每个顶点的属性。它们与顶点属性索引2(或位置2)相关联。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125358.png" class="" title="image-20211019125358">

<p><strong>2.碎片着色器将执行纹理查找，将需要插值纹理坐标。这个变量将作为输出变量被添加到片段着色器。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125421.png" class="" title="image-20211019125421">

<p><strong>3.将传入的顶点属性复制到main函数的输出变量中。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125455.png" class="" title="image-20211019125455">

<p><strong>碎片着色器也需要简单的改变。首先，从顶点着色器传入的插值纹理坐标必须声明。还记得统一变量应该存储纹理绑定到的纹理单元吗?这必须作为一个采样器类型传达给着色器。采样器是一种着色语言类型，允许从单个纹理对象中查找数据。在这个例子中，只需要一个采样器，但是在使用多个纹理查找的着色器中，将使用多个采样器变量。根据纹理对象的类型，也有多种采样器类型。在这里展示的例子中，GL_TEXTURE_2D类型用于创建纹理状态。碎片着色器中的相关采样器类型为sampler2D。下面两个变量声明必须添加到片段着色器中:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125540.png" class="" title="image-20211019125540">

<p><strong>最后的修改进入了片段着色器代码的主要功能。纹理使用GLSL纹理查找函数进行采样，(在本例中)，替换几何的漫反射系数。纹理的第一个参数接受采样器类型，该类型保存纹理绑定到的纹理单元。第二个参数是纹理坐标。函数返回vec4类型。在下面的代码片段中，在最终的计算中没有使用alpha值，因此生成的纹理查找值只选择RGB组件。从纹理查找中得到的漫反射系数被设置为vec3类型，用于照明方程。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125651.png" class="" title="image-20211019125651">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125913.png" class="" title="image-20211019125913">

<p>最左边的图像显示纹理，1024 × 1024像素的图像。中间的图像显示了使用[0,1]范围内的纹理坐标应用纹理的场景，因此只有一个图像被平铺到地平面上。最右边的图像修改纹理参数，使GL_REPEAT用于GL_TEXTURE_WRAP_S和GL_TEXTURE_WRAP_T，纹理坐标范围为[0,5]。结果是一个平铺纹理在两个纹理维度重复5次。</p>
<p><strong>上图显示了使用这些着色器修改的结果。图中最右边的图像通过使用OpenGL状态启用纹理平铺扩展了示例代码。注意，这些改变只在主机代码中完成，着色器不改变。为了启用这种平铺，它允许纹理坐标超出设备规范化范围，GL_TEXTURE_WRAP_S和GL_TEXTURE_WRAP_T的纹理参数从GL_CLAMP更改为GL_REPEAT。此外，设置纹理坐标的宿主代码现在的范围是[0,5]。</strong></p>
<p><strong>作为一个附注，另一个可能对各种应用有用的纹理目标是GL纹理矩形。纹理矩形是唯一的纹理对象，它不受图像宽度和高度要求的二次幂的约束，并使用非标准化的纹理坐标。此外,他们做不允许重复瓷砖。如果使用纹理矩形，着色器必须使用特殊的采样类型:sampler2DRect来引用它们。</strong></p>
<h2 id="Object-Oriented-Design-for-Graphics-Hardware-Programming-图形硬件编程的面向对象设计"><a href="#Object-Oriented-Design-for-Graphics-Hardware-Programming-图形硬件编程的面向对象设计" class="headerlink" title="Object-Oriented Design for Graphics Hardware Programming 图形硬件编程的面向对象设计"></a>Object-Oriented Design for Graphics Hardware Programming 图形硬件编程的面向对象设计</h2><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019130140.png" class="" title="image-20211019130140">

<p>在左边，一个单一的镶嵌球体被实例化了六次，使用不同的模型转换来创建这个场景，使用每个碎片着色程序。右边的图像是使用基本的Whitted射线追踪器渲染的。注意阴影对场景感知的影响。每片段着色允许高光在两种渲染风格中是相似的。</p>
<p><strong>随着你对OpenGL熟悉程度的增加，将本章描述的大部分内容封装到类结构中变得更加明智，这些类结构可以包含特定于模型的数据，并在场景中提供各种对象的渲染。例如，在上图中，一个球体被实例化六次，以创建三个椭球体和三个球体。每个模型使用相同的基础几何结构，但有不同的材料属性和模型转换。如果您已经按照本书的要求实现了射线跟踪器(详见第4章)，那么您的实现很可能是基于可靠的面向对象设计的。这种设计可以使使用OpenGL开发图形硬件程序变得更容易。一个典型的射线跟踪软件架构将包括几个直接映射到图形硬件和软件光栅化应用程序的类。光线追踪器中代表表面、材质、灯光、着色器和相机的抽象基类可以用于初始化图形硬件状态、更新该状态，并在必要时将类数据渲染到framebuffer中。这些虚函数的接口可能需要适应您的特定实现，但扩展表面类设计的第一步可能类似于以下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019130244.png" class="" title="image-20211019130244">

<p><strong>将投影和视图矩阵传递给呈现函数提供了如何管理这些矩阵的间接方法。这些矩阵将来自摄像机类，可以通过解释键盘、鼠标或操纵杆输入操作。初始化函数(至少对于曲面导数)将包含顶点缓冲区对象、顶点数组对象分配和初始化代码。除了为任何顶点数组对象初始化绘制数组外，渲染函数还需要激活着色程序，并将必要的矩阵传递到着色器中，如前面的龙模型示例所示。当您将图像顺序和对象顺序(硬件和软件)算法集成到相同的底层数据框架中时，会出现一些软件设计挑战，主要与数据访问和组织有关。然而，这是一个非常有用的练习，可以让你熟练掌握图形编程的软件工程，并最终获得杂交渲染算法的扎实经验。</strong></p>
<h2 id="Continued-Learning-继续学习"><a href="#Continued-Learning-继续学习" class="headerlink" title="Continued Learning 继续学习"></a>Continued Learning 继续学习</h2><p><strong>本章的目的是对受OpenGL API影响的图形硬件编程提供一个介绍性的一瞥。你继续学习的方向有很多。许多主题，如framebuffer对象、渲染到纹理、环境映射、几何着色器、计算着色器和高级照明着色器都没有涉及。这些领域代表了学习图像硬件的下一个阶段，但即使在所涵盖的领域中，也有许多方向可以让你更好地理解图像硬件。图形硬件编程将继续发展和变化。感兴趣的读者应该期待这些变化，并查看OpenGL和OpenGL着色语言的规范文档，了解更多关于OpenGL能够做什么以及硬件如何与这些计算相关的细节。</strong></p>
<h1 id="18-Light-光照"><a href="#18-Light-光照" class="headerlink" title="18 Light 光照"></a>18 Light 光照</h1><p><strong>在本章中，我们讨论测量光的实际问题，通常称为辐射测量法。放射测量学中出现的术语可能一开始看起来很奇怪，术语和符号可能很难保持一致。然而，由于辐射测量学是计算机图形学的基础，所以在深入研究辐射测量学之前是值得的。本章还涵盖了光度学，它采用辐射量并将其缩放以估计有多少“有用的”光存在。例如，同样强度的绿光可能比蓝光亮两倍，因为眼睛对绿光更敏感。光度学试图量化这种差别。</strong></p>
<h2 id="Radiometry-辐射度量学"><a href="#Radiometry-辐射度量学" class="headerlink" title="Radiometry 辐射度量学"></a>Radiometry 辐射度量学</h2><p><strong>虽然我们可以在许多系统中定义辐射单位，但我们使用SI(国际单位制)单位。我们熟悉的国际单位制单位包括公制单位米(m)和克(g)。光基本上是能量的一种传播形式，所以定义国际单位制能量单位焦耳(J)是很有用的。</strong></p>
<h3 id="Photons-光子"><a href="#Photons-光子" class="headerlink" title="Photons 光子"></a>Photons 光子</h3><p><strong>为了帮助我们的直觉，我们将用大量光子的收集来描述辐射测量，这一节将确定光子在这里的含义上下文。就本章的目的而言，光子是光的量子，它具有位置、传播方向和波长λ。有些奇怪的是，波长的国际单位制单位是纳米(nm)。这主要是由于历史原因，1 nm = 10^−9 m。有时还使用另一个单位埃(angstrom)，一纳米等于十埃。光子的速度c只取决于它所通过的介质的折射率n。有时频率f = c/λ也用于光。这很方便，因为与λ和c不同，当光子折射到具有新的折射率的介质中时，f不会改变。另一个不变测度是光子携带的能量q的量，它由以下关系式给出:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019131250.png" class="" title="image-20211019131250">

<p><strong>其中h = 6.63 × 10^−34 Js为普朗克常数。尽管这些量可以用任何单位制来测量，但只要可能，我们将使用国际单位制。</strong></p>
<h3 id="Spectral-Energy-光谱能量"><a href="#Spectral-Energy-光谱能量" class="headerlink" title="Spectral Energy 光谱能量"></a>Spectral Energy 光谱能量</h3><p><strong>如果我们有大量的光子，它们的总能量Q，可以通过对每一个光子的能量qi求和来计算 。一个合理的问题是“能量是如何在波长上分布的?”回答这个问题的一个简单方法是将光子分成多个盒子，本质上是对它们进行柱状图分析。然后我们有一个与区间相关的能量。例如，我们可以计算λ = 500 nm和λ = 600 nm之间的所有能量，结果是10.2 J，这可能表示为q[500, 600] = 10.2。如果我们把波长区间分成两个50 nm的区间，我们可能会发现q[500, 550] = 5.2和q[550, 600] = 5.0。这告诉我们，在间隔[500,600]的一半的短波长中有一点多的能量。如果我们将容器分成25 nm，我们可能会发现q[500, 525] = 2.5，以此类推。这个系统的优点是它很简单。它的缺点是区间大小的选择决定了数字。</strong></p>
<p><strong>一个更常用的系统是用间隔的大小除以能量。所以q[500, 600] = 10.2，我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019131751.png" class="" title="image-20211019131751">

<p><strong>这种方法很好，因为间隔的大小对数字的总体大小的影响要小得多。一个迫在眉睫的想法是将间隔大小Δλ降为零。这可能会很尴尬，因为对于一个足够小的Δλ， Qλ 是零还是很大取决于是否有单个光子间隔中的光子。有两种思想流派来解决这个困境。第一种是假设Δλ很小，但还没有小到光的量子性质开始发挥作用。第二种是假设光是一个连续体而不是单个光子，因此一个真正的导数dQ/dλ是合适的。这两种思考方式都是恰当的，并导致相同的计算机制。在实践中，大多数测量光的人似乎更喜欢小的，但有限的间隔，因为这是他们在实验室里可以测量的。大多数做理论或计算的人喜欢无穷小的间隔，因为这让微积分的机器变得可用。</strong></p>
<p><strong>数量Qλ 被称为光谱能量，它是一个密集的量，相对于一个广泛的量，如能量、长度或质量。密集量可以被认为是密度函数，它告诉一个扩展量在无限小点的密度。例如，特定波长的能量Q可能为零，但光谱能量(能量密度)Qλ 是一个有意义的量。一个可能更熟悉的例子是，一个国家的人口可能是2500万，但在某个点上，这个国家的人口是无意义的。然而，以每平方米人口为单位的人口密度是有意义的，只要它是在足够大的区域上测量的。就像光子一样，如果我们假设我们可以把人口看作一个连续体，即使面积很小，人口密度也不会变成颗粒状，那么人口密度就会发挥最好的作用。</strong></p>
<p><strong>我们将遵循图形的惯例，光谱能量几乎总是被使用，而能量很少被使用。如果使用“proper”表示法，这将导致λ下标的扩散。相反，我们将去掉下标，使用Q表示光谱能量。当图形以外的人阅读图形论文时，这可能会导致一些混淆，所以请注意这个标准问题。想象一个带有测量光能的传感器的测量设备Δq，可能会帮助你对光谱能量的直觉。如果你在传感器前放置一个彩色滤光片，只允许在区间[λ - Δλ/2， λ + Δλ/2]内的光，那么λ处的光谱能量为Q = Δq/Δλ。</strong></p>
<h3 id="Power-功率"><a href="#Power-功率" class="headerlink" title="Power 功率"></a>Power 功率</h3><p><strong>估计光源的能量产生率是有用的。这个速率叫做功率，它的单位是瓦特，W，这是焦耳每秒的另一个名字。在稳定状态下，这是最容易理解的，但由于功率是一个密集量(随时间变化的密度)，即使当能量生产随时间变化时，它也可以被很好地定义。功率单位可能更熟悉，例如100瓦的灯泡。这种灯泡每秒大约消耗100j的能量。产生的光的功率实际上会小于100瓦，因为热量损失，等等，但我们仍然可以用这个例子来帮助理解更多关于光子的知识。例如，我们可以感受到100瓦的光每秒产生多少光子。假设产生的平均光子的能量为λ = 500 nm。这样一个光子的频率是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019132200.png" class="" title="image-20211019132200">

<p><strong>这个光子的能量是hf≈4 × 10^−19 j，这意味着一个惊人的10^20 即使灯泡的效率不是很高，每秒也会产生光子。这就解释了为什么用快速快门和直接模拟光子来模拟相机是产生图像的低效选择。</strong></p>
<p><strong>与能量一样，我们对以W(nm)^-1测量的光谱功率非常感兴趣。同样，虽然光谱功率的正式标准符号是Φλ，我们将使用Φ不带下标，以方便和与大多数图形文献一致。需要注意的是，光源的光谱功率通常比功率小。例如，如果一束光的功率为100 W，在波长为400 nm到800 nm之间均匀分布，那么光谱功率将为100 W/400 nm = 0.25 W(nm)^-1。这是值得注意的，如果为了调试目的而手动设置光源的光谱功率。</strong></p>
<p><strong>请记住最后一节中光谱能量的测量装置可以通过在以时间t为中心的时间间隔Δt打开的快门进行读数来修改。然后光谱功率将是Φ = Δq/(ΔtΔλ)。</strong></p>
<h3 id="Irradiance-辐照度"><a href="#Irradiance-辐照度" class="headerlink" title="Irradiance 辐照度"></a>Irradiance 辐照度</h3><p><strong>如果你问”有多少光到达这个点? “答案当然是“没有”，同样，我们必须使用密度函数。如果点在一个表面上，很自然地用面积来定义密度函数。我们从上一节修改了设备，使其有一个有限的ΔA面积传感器，小于被测量的光场。光谱辐照度H就是单位面积功率ΔΦ/ΔA。完全展开</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019132703.png" class="" title="image-20211019132703">

<p><strong>因此，辐照度的全单位为Jm^− 2s ^−1(nm) ^−1。注意，辐射的SI单位包括面积的反米平方和波长的反纳米。这种表面上的不一致(同时使用纳米和米)是因为面积和可见光波长的自然单位。</strong></p>
<p><strong>当光离开一个表面时，例如当它被反射时，与辐照度相同的量称为辐射出度E。对于入射光和激发光有不同的词是有用的，因为同一点有可能有不同的辐照度和辐射出度。</strong></p>
<h3 id="Radiance-辐亮度"><a href="#Radiance-辐亮度" class="headerlink" title="Radiance 辐亮度"></a>Radiance 辐亮度</h3><p><strong>虽然辐照度告诉我们有多少光到达一个点，但它几乎不能告诉我们光来自的方向。为了测量类似于我们用眼睛看到的东西，我们需要能够将“有多少光”与特定的方向联系起来。我们可以设想一个简单的装置来测量这样一个量(下图)。我们使用一个小的辐照度计，并添加一个锥形“挡板”，以限制光线击中计数器的角度范围与实心角度Δσ。探测器的响应如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133030.png" class="" title="image-20211019133030">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133041.png" class="" title="image-20211019133041">

<p>通过添加一个只显示一个小立体角Δσ到辐照度探测器，我们测量辐射度。</p>
<p><strong>这是在太空中旅行的光的光谱亮度。同样，我们将在讨论中去掉“光谱”，并假设它是隐式的。</strong></p>
<p><strong>辐射是我们通常在图形程序中计算的东西。辐亮度的一个奇妙特性是它在空间中不会沿直线变化。要知道为什么是这样，检查两个都在观察一个表面的亮度探测器如下图所示。假设探测器所观察的线足够接近，使得表面在两个被测量区域发出/反射的光“相同”。因为被采样表面的面积与距离的平方成正比，并且因为到达探测器的光与距离的平方成反比，两个探测器应该有相同的读数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133206.png" class="" title="image-20211019133206">

<p>辐射探测器接收到的信号与被测表面的距离无关。这个图假设探测器指向表面上以同样方式发光的区域。</p>
<p><strong>测量照射到表面的辐射是有用的。我们可以考虑将探测器上的锥形挡板放置在表面的某一点上，从锥内方向测量表面上的辐照度H(下图)。注意，表面“探测器”没有对准锥体。为此，我们需要在辐亮度的定义中加入余弦校正项:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133253.png" class="" title="image-20211019133253">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133304.png" class="" title="image-20211019133304">

<p>表面的辐照度被掩盖圆锥体比探测器测得的圆锥体要小，用余弦系数表示。</p>
<p><strong>就像辐照度和辐射出度一样，区分入射到表面某一点的辐射度和从该点发出的辐射度是很有用的。这些概念有时在图形文献中使用的术语是表面亮度Ls 为(留下)表面的辐亮度，场辐亮度Lf 为入射到表面的辐射度。两者都需要余弦项，因为它们都对应于上图中的配置:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133325.png" class="" title="image-20211019133325">

<h4 id="Radiance-and-Other-Radiometric-Quantities-辐亮度和其他辐射量"><a href="#Radiance-and-Other-Radiometric-Quantities-辐亮度和其他辐射量" class="headerlink" title="Radiance and Other Radiometric Quantities 辐亮度和其他辐射量"></a>Radiance and Other Radiometric Quantities 辐亮度和其他辐射量</h4><p><strong>如果我们有一个表面，它的场辐射是Lf ，然后我们可以从它推导出所有其他的辐射量。这是辐亮度被认为是“基本”辐射量的原因之一。例如，辐照度可以表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133730.png" class="" title="image-20211019133730">

<p><strong>这个公式有一些在图形中很常见的表示法约定，使得这些公式对不熟悉的读者不透明(下图)。首先，k是一个入射方向，可以认为是一个单位矢量，一个方向，或一个(θ， φ)对相对于表面法线球坐标。这个方向有一个与之相关的微分立体角dσ。每个方向的场辐射都可能不同，所以我们把它写成函数L(k)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133741.png" class="" title="image-20211019133741">

<p>方向k有一个微分立体角dσ与它相关。</p>
<p><strong>例如，我们可以计算具有恒定场辐亮度Lf 的表面的辐照度H在所有的方向。为了积分，我们使用一个经典的球坐标系，回想一下，微分立体角是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133929.png" class="" title="image-20211019133929">

<p><strong>所以辐照度是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133939.png" class="" title="image-20211019133939">

<p><strong>这个关系向我们展示了一个潜在的令人惊讶的常数π的首次出现。π的这些因素在射线测量中经常出现，并且是我们选择测量立体角的伪因素。单位球的面积是π的倍数，而不是1的倍数。</strong></p>
<p><strong>同样地，我们可以通过对辐照度积分来求出撞击表面的功率穿过表面面积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019134040.png" class="" title="image-20211019134040">

<p><strong>其中x是曲面上的一个点，dA是这个点的微分面积。请注意，我们没有专门的术语或符号来表示输入功率和输出功率。这种区别似乎并没有引起足够的重视。</strong></p>
<h3 id="BRDF-双向反射"><a href="#BRDF-双向反射" class="headerlink" title="BRDF 双向反射"></a>BRDF 双向反射</h3><p><strong>因为我们对表面的外观感兴趣，我们想要描述一个表面是如何反射光线的。在直观的层面上，对于任何来自ki方向的入射光，在向外方向ko附近，有一些分数以一个小的立体角分散．我们有很多方法可以将这个概念形式化，毫不奇怪，标准的方法是受建立一个简单测量装置的启发。如下图所示，其中一个小光源位于ki 方向从表面上的一点看，在ko方向放置检测器．对于每个方向对(ki,ko)，我们用探测器进行读数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019134646.png" class="" title="image-20211019134646">

<p>一种简单的方向反射率测量装置。光的位置和检测器移动到每个可能的方向对。注意两个ki 和ko 指向远离表面以允许互惠。</p>
<p><strong>现在我们只需要决定如何测量光源的强度并使反射函数独立于这个强度。例如，如果我们用一个更亮的光替换光，我们就不会想要把表面看作是反射光的不同。我们可以在这一点放一个辐射度计照明来测量光。然而，为了得到一个不依赖于探测器Δσ的准确读数，我们需要光对着一个大于Δσ的实心角度。不幸的是，我们在ko 方向上的粗纱亮度检测器所测量的也将计算来自新探测器锥外点的光。所以这看起来不像是一个实际的解决方案。</strong></p>
<p><strong>或者，我们也可以在被测表面的某一点上放置一个辐照度计。这将采取一个读数，不强烈依赖于微妙的光源几何。这表明反射率可以用比率表示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019134341.png" class="" title="image-20211019134341">

<p><strong>这个分数ρ会随着入射和激发方向ki 和ko而变化， H为光位ki的辐照度,Ls 是在ko方向上测量表面辐射．如果我们对所有方向对进行这样的测量，我们最终得到一个四维函数ρ(ki,ko）．这个函数称为双向反射分布函数(BRDF)。我们只需要知道BRDF就可以描述一个表面如何反射光的方向特性。</strong></p>
<h4 id="Directional-Hemispherical-Reflectance-定向半球形反射"><a href="#Directional-Hemispherical-Reflectance-定向半球形反射" class="headerlink" title="Directional Hemispherical Reflectance 定向半球形反射"></a>Directional Hemispherical Reflectance 定向半球形反射</h4><p><strong>对于BRDF，我们很容易问:“入射光的反射光的比例是多少?”然而，答案并非如此简单;反射光的比例取决于入射光的方向分布。由于这个原因，我们通常只设置一个固定入射方向ki反射的分数．这个分数称为定向半球反射率。这个分数,R (ki)定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019134852.png" class="" title="image-20211019134852">

<p><strong>注意，为了能量守恒，这个量在0和1之间。如果我们允许事件力量Φi 点击一个小区域ΔA，那么辐照度是Φi/ΔA。同样，入射功率的比值就是辐射出度与辐照度的比值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135013.png" class="" title="image-20211019135013">

<p><strong>根据BRDF的定义，由该功率产生的特定方向上的辐亮度为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135025.png" class="" title="image-20211019135025">

<p><strong>从辐射的定义，我们也有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135038.png" class="" title="image-20211019135038">

<p><strong>E是ko方向上小块的辐射出度．利用这两种定义，我们得到了辐亮度</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135058.png" class="" title="image-20211019135058">

<p><strong>重新排列项，我们得到</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135109.png" class="" title="image-20211019135109">

<p><strong>这只是对E/H的很小的贡献反映在特定的ko附近．求总的R(ki)，对所有向外的ko求和．积分形式是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135128.png" class="" title="image-20211019135128">

<h4 id="Ideal-Diffuse-BRDF-理想的双向反射"><a href="#Ideal-Diffuse-BRDF-理想的双向反射" class="headerlink" title="Ideal Diffuse BRDF 理想的双向反射"></a>Ideal Diffuse BRDF 理想的双向反射</h4><p><strong>理想的漫反射面称为朗伯曲面。由于热力学原因，这样的表面在自然界是不可能存在的，但从数学上讲，它们确实能保存能量。朗伯BRDF有ρ对于所有角度都是常数。这意味着表面在所有视角下都有相同的辐亮度，辐亮度与辐照度成正比。</strong></p>
<p><strong>如果我们计算R(ki)对于ρ = C的朗伯曲面，我们得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135406.png" class="" title="image-20211019135406">

<p><strong>因此，对于完全反射的朗伯曲面(R = 1)，我们有ρ = 1/π,R(ki) = r，我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135417.png" class="" title="image-20211019135417">

<p><strong>这是另一个使用立体角确定归一化常数，从而引入π因子的例子。</strong></p>
<h2 id="Transport-Equation-传播方程"><a href="#Transport-Equation-传播方程" class="headerlink" title="Transport Equation  传播方程"></a>Transport Equation  传播方程</h2><p><strong>根据BRDF的定义，我们可以用从各个不同方向入射的辐亮度来描述一个表面的辐亮度。因为在计算机图形学中，我们可以使用理想化的数学，这在实验室中可能是不切实际的，我们也可以只用亮度来写BRDF。如果我们取一小部分实心角度Δσi 与在ko 方向上“测量”反射辐亮度Li，由于这一小块光，我们可以计算BRDF(下图)。小片光的辐照度为H = Li cosθiΔσi．因此BRDF是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141322.png" class="" title="image-20211019141322">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141332.png" class="" title="image-20211019141332">

<p>定向形式的传播方程的几何形式。</p>
<p><strong>这种形式在某些情况下是有用的。重新排列这些项，我们可以写出来自ki方向的光的部分亮度：</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141418.png" class="" title="image-20211019141418">

<p><strong>如果有光从多个方向射来Li(ki)，我们可以把它们加起来。在积分形式中，用表面和场辐射的符号表示，这是</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141438.png" class="" title="image-20211019141438">

<p><strong>这通常被称为计算机图形学中的渲染方程(Immel, Cohen， &amp; Greenberg, 1986)。</strong></p>
<p><strong>有时只用表面辐射来写输运方程是有用的(Kajiya, 1986)。注意，在封闭环境中，场辐亮度Lf (ki)来自具有表面辐射度Ls(−ki) =Lf (ki)的表面(下图)。x′所对的实心角在图中是由</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141622.png" class="" title="image-20211019141622">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141631.png" class="" title="image-20211019141631">

<p>射入一点的光来自另一个点。</p>
<p><strong>其中ΔA′是与x′有关的面积。在以下替代Δσi，ΔA′表示以下传播方程：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142032.png" class="" title="image-20211019142032">

<p><strong>注意到我们使用的是非标准化向量x−x′来表示x′方向到x，还要注意这里写的是Ls 作为位置和方向的函数。</strong></p>
<p><strong>这个新的传输方程的唯一问题是，积分的领域是棘手的。如果我们引入一个可见性函数，我们可以权衡域的复杂性和被积函数的复杂性:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142119.png" class="" title="image-20211019142119">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142129.png" class="" title="image-20211019142129">

<h2 id="Photometry-光度测定"><a href="#Photometry-光度测定" class="headerlink" title="Photometry 光度测定"></a>Photometry 光度测定</h2><p><strong>对于每一个光谱辐射量，都有一个相关的光度量，测量这个量有多少对人类观察者是“有用的”。给定光谱辐射量fr(λ)，对应的光度量fp 是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142210.png" class="" title="image-20211019142210">

<p><strong>其中y¯是人类视觉系统的发光效率函数。这个函数在上面的积分极限之外是0，所以极限可以是0,∞和fp 不会改变。发光效率函数为在第19章有更详细的讨论，但我们在这里讨论它的一般性质。首要的常数是使定义与历史上的绝对光度量相一致。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142320.png" class="" title="image-20211019142320">

<p>光效率函数随时间变化而变化波长(nm)。</p>
<p><strong>光效率函数对所有波长的灵敏度并不相同(上图)。对于波长低于380 nm(紫外线范围)的光，人类是看不见的，因此y¯的值为零。从380 nm逐渐增加到λ = 555 nm，达到峰值。这是纯绿色的光。然后逐渐减小，直到800nm处到达红外区域边界。</strong></p>
<p><strong>在图形中最常用的光度量是光度，相当于亮度的光度:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142428.png" class="" title="image-20211019142428">

<p><strong>表示亮度的符号Y来自比色法。大多数其他字段使用符号L;我们不会遵循这个惯例，因为用L来表示亮度和光谱辐亮度太混乱了。亮度给出了一个关于“明亮”的东西是如何独立于观察者的适应的总体概念。需要注意的是，正午阳光下的黑纸主观上比月光下亮度较低的白纸暗;过多地解读亮度是危险的，但它是一个非常有用的量，可以为相对可感知的光输出提供定量的感觉。lm单位是流明。请注意，大多数灯泡是根据它们消耗的功率(瓦特)和它们产生的有用光(流明)来评级的。更高效的灯泡在y¯大的地方产生更多的光，因此每瓦产生更多的流明。一个“完美”的光可以将所有的能量转换成555纳米的光，产生683 lumens每瓦。亮度单位为(lm/W)(W/(m²sr)) = lm/(m²sr)。每一个立体角的流明被定义为一个candela(cd)，所以亮度通常用cd/m²来描述。</strong></p>
<h1 id="19-Color-颜色"><a href="#19-Color-颜色" class="headerlink" title="19 Color 颜色"></a>19 Color 颜色</h1><p><strong>光子是光信息的载体。它们通过具有波的特性的媒体传播。在表面边界，它们与物质相互作用，表现得更像粒子。它们还可以被视网膜吸收，在那里，它们携带的信息被转换成电信号，随后由大脑处理。只有在那里，才会产生一种色彩的感觉。</strong></p>
<p><strong>因此，色彩研究涉及到几个不同的领域:光在空间中的传播的物理学，与物质相互作用的化学，以及与色彩感知和认知相关的神经科学和心理学(Reinhard et al.， 2008)。</strong></p>
<p><strong>在计算机图形学中，我们通常对光如何在空间中传播采用一种简化的观点。光子沿直线运动，直到碰到表面边界，然后根据某种反射函数反射。单个光子将携带一定的能量，用它的波长表示。因此，一个光子将只有一个波长。给出了它的波长λ和它所携带的能量(ΔE)之间的关系</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020113738.png" class="" title="image-20211020113738">

<p><strong>ΔE的单位是电子伏(eV)。</strong></p>
<p><strong>在计算机图形学中，模拟单个光子的效率不是很高;相反，同时模拟它们的大量集合。如果我们拿大量的光子，每一个都可能携带不同数量的能量，然后它们一起代表一个光谱。光谱可以看作是光子数与波长的关系图。因为同一波长的两个光子携带的能量是同一波长的单个光子的两倍，这张图也可以看作是能量与波长的关系图。下图显示了一个频谱示例。人类能感应到的波长范围大约在380 - 800纳米之间。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020113901.png" class="" title="image-20211020113901">

<p>光谱描述了在每个波长λ可获得的能量，这里用相对辐射功率来测量。这个特定的光谱代表平均日光。</p>
<p><strong>因此，在模拟光线时，就有可能追踪每一种光线都带有光谱。完成这个的渲染器通常被称为光谱渲染器。从前面的章节中，我们应该清楚的是，我们通常不会花费建造光谱渲染器的费用。相反，我们用通常使用红色、绿色和蓝色成分的表示来代替光谱。这可能与人类的视觉有关，我们将在本章后面讨论。</strong></p>
<p><strong>通过追踪光线来模拟光需要考虑光的物理特性，但是需要注意的是，光的一些特性，例如，偏振、衍射和干涉，并不是以这种方式建模的。</strong></p>
<p><strong>在表面边界，我们通常用一个反射函数来模拟光的情况。这些函数可以通过角反射仪直接测量，从而产生大量的表格数据，这些数据可以更紧凑地用各种不同的函数表示。尽管如此，这些反射函数在本质上是经验的，即当一个光子被电子吸收并重新释放时所发生的化学反应就会被吸走。因此，反射函数在计算机图形学建模中是有用的，但不是解释为什么某些波长的光会被吸收而其他波长的光会被反射。因此，我们不能用反射函数来解释为什么香蕉反射的光的光谱组成在我们看来是黄色的。为此，我们必须研究分子轨道理论，这是一个超出本书范围的话题。</strong></p>
<p><strong>最后，当光线到达视网膜时，它被转换成电信号并传播到大脑。大脑的很大一部分用于处理视觉信号，其中一部分产生了对颜色的感觉。因此，即使我们知道香蕉反射的光谱，我们仍然不知道为什么人们会把“黄色”这个词和它联系在一起。此外，正如我们将在本章剩余部分发现的那样，我们对颜色的感知远比乍一看要复杂得多。它随光照而变化，在观察者之间变化，在观察者内部随时间而变化。</strong></p>
<p><strong>换句话说，香蕉发出的光谱是在环境的背景下感知的。要预测观察者如何感知“香蕉光谱”，就需要了解包含香蕉和观察者所处环境的环境知识。在许多情况下，这两种环境是相同的。然而，当我们在监视器上显示香蕉的照片时，这两个环境将是不同的。由于人类的视觉感知依赖于观察者所处的环境，它对照片中的香蕉的感知可能与直接看着香蕉的观察者的感知不同。这对我们如何处理颜色有重大影响，并说明了与颜色相关的复杂性。</strong></p>
<p><strong>强调人类的视觉扮演的重要角色,我们只需要看颜色的定义:“色彩是视觉感知的角度,一个观察者可以区分两个structure-free字段之间的差异的看法相同的大小和形状,如可能是由于有关辐射能的光谱成分的差异观察”(Wyszecki &amp;斯泰尔斯,2000)。本质上，没有人类观察者就没有颜色。</strong></p>
<p><strong>幸运的是，我们对颜色的了解大多是可以量化的，这样我们就可以进行计算来修正人类视觉的特性，从而显示出图像，让观察者看到这些图像的设计者想要的样子。本章包含了这样做所需要的理论和数学。</strong></p>
<h2 id="Colorimetry-比色法"><a href="#Colorimetry-比色法" class="headerlink" title="Colorimetry 比色法"></a>Colorimetry 比色法</h2><p><strong>比色学是一门颜色测量和描述的科学。因为颜色最终是人类的反应，所以颜色测量应该从人类开始观察。人类视网膜中的光探测器由视杆细胞和视锥细胞组成。杆状体高度敏感，在弱光条件下发挥作用。在正常光照条件下，视锥细胞起作用，调节人类的视觉。有三种视锥细胞，它们共同负责色觉。</strong></p>
<p><strong>虽然当某些视觉刺激出现时，直接记录视锥细胞的电输出是可能的，但这样的过程可能是有创的，同时忽略了观察者之间有时存在的本质差异。此外，在这种直接记录技术出现之前，颜色的许多测量方法就已经发展起来了。</strong></p>
<p><strong>另一种方法是通过测量人类对颜色斑块的反应来测量颜色。这导致了颜色匹配实验，稍后将在本节中介绍。进行这些实验已经产生了几个标准化的观察者，这可以被认为是实际人类观察者的统计近似值。然而，首先，我们需要描述一些基于颜色匹配可能性的假设，这些假设是由格拉斯曼定律总结的。</strong></p>
<h3 id="Grassmann’s-Laws-格拉斯曼定律"><a href="#Grassmann’s-Laws-格拉斯曼定律" class="headerlink" title="Grassmann’s Laws 格拉斯曼定律"></a>Grassmann’s Laws 格拉斯曼定律</h3><p><strong>鉴于人类有三种不同的视锥类型，颜色匹配的实验法则可以总结为三色概括(Wyszecki &amp; Stiles, 2000)，即任何颜色刺激都可以通过三种适当调制的颜色源的加性混合完全匹配。这种颜色特征在实践中经常被使用，例如电视和显示器通过给每个像素添加红、绿、蓝的混合光来复制许多不同的颜色。这也是渲染器可以只用三个值来描述每种颜色的原因。</strong></p>
<p><strong>三原色泛化使我们能够在任何给定的刺激和三种其他刺激的相加混合之间进行颜色匹配。Hermann Grassmann是第一个描述颜色匹配遵循的代数规则的人。它们被称为加色配色格拉斯曼定律(Grassmann, 1853)，其内容如下:</strong></p>
<p><strong>•对称。如果颜色刺激A匹配颜色刺激B，那么B匹配A。</strong> </p>
<p><strong>•传递法。如果A匹配B, B匹配C，那么A匹配C。</strong></p>
<p><strong>•比例法。如果A匹配B，那么αA匹配αB，其中α是一个正的比例因子。</strong></p>
<p><strong>•可加性。如果A匹配B，C匹配D，A + C匹配B + D，那么，A + D匹配B + C。</strong> </p>
<p><strong>加性法则是配色和比色法的基础。</strong></p>
<h3 id="Cone-Responses-锥反应"><a href="#Cone-Responses-锥反应" class="headerlink" title="Cone Responses 锥反应"></a>Cone Responses 锥反应</h3><p><strong>每种锥型对波长范围都很敏感，涵盖了整个可见范围的大部分。然而，对波长的灵敏度不是均匀分布的，而是包含一个灵敏度最大的峰值波长。每个锥型的峰值波长的位置是不同的。这三种锥型分别为S、M和L锥，字母分别代表短、中、长，表明在可见光谱中峰值灵敏度的位置。</strong></p>
<p><strong>一个给定的圆锥的响应是它输出的电信号的大小，作为入射到圆锥上的波长的频谱的函数。每个锥型的锥响应函数是波长λ的函数，然后由L(λ)， M(λ)和S(λ)给出。它们绘制在下图中。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020130721.png" class="" title="image-20211020130721">

<p>L, M和S锥的锥响应函数。</p>
<p><strong>对给定光谱组成Φ(λ)的刺激的实际响应然后给出每个锥型的</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020130736.png" class="" title="image-20211020130736">

<p><strong>这三种综合反应被称为三刺激值。</strong></p>
<h3 id="Color-Matching-Experiments-配色实验"><a href="#Color-Matching-Experiments-配色实验" class="headerlink" title="Color Matching Experiments 配色实验"></a>Color Matching Experiments 配色实验</h3><p><strong>鉴于三刺激值是通过在可见范围内集成两个函数的乘积而产生的，很明显，人类的视觉系统并不是一个简单的波长探测器。相反，我们的光感受器起着近似线性积分器的作用。因此，有可能找到两种不同的光谱成分，比如Φ₁(λ)和Φ₂(λ)，经过整合后产生相同的响应(L, M, S)。这种现象被称为同分异构体，其例子如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020130947.png" class="" title="image-20211020130947">

<p>两个刺激Φ₁(λ)和Φ₂(λ)积分后得到相同的三刺激值。</p>
<p><strong>异色是人类视觉的关键特征，它允许构建彩色复制设备，包括这本书中的彩色图形和任何在打印机、电视和显示器上复制的东西。</strong></p>
<p><strong>配色实验也依赖于异谱原理。假设我们有三种不同颜色的光源，每个光源都有一个刻度盘来改变其亮度。我们称这三种光源为原色。我们现在应该能够调整每一种光源的强度，这样当它们相加时，得到的光谱就会整合成一个三刺激值，与第四个未知光源的感知颜色相匹配。当我们进行这样的实验时，我们基本上已经将我们的原色与一种未知的颜色进行了匹配。我们三个刻度盘的位置就代表了第四个光源的颜色。</strong></p>
<p><strong>在这样的实验中，我们使用格拉斯曼定律将我们的原色的三个光谱相加。我们还使用了异谱法，因为我们的三个初级的组合光谱几乎肯定是不同的第四个光源。然而，从这两个光谱计算的三刺激值将是相同的，产生了一种颜色匹配。</strong></p>
<p><strong>请注意，我们实际上并不需要知道锥响应函数来进行这样的实验。只要我们在相同的条件下使用相同的观察者，我们就能够匹配颜色，并记录每种颜色的刻度盘的位置。但是，每次测量颜色的时候都要做这样的实验是很不方便的。因此，我们确实想知道光谱锥响应函数，并对一组不同的观测者进行平均，以消除观测者间的变异性。</strong></p>
<h3 id="Standard-Observers-标准观察者"><a href="#Standard-Observers-标准观察者" class="headerlink" title="Standard Observers 标准观察者"></a>Standard Observers 标准观察者</h3><p><strong>如果我们对大范围的颜色进行颜色匹配实验，由一组不同的观察者进行，就有可能生成一个平均的颜色匹配数据集。如果我们专门使用单色光源来匹配我们的原色，我们可以对所有可见波长重复这个实验。得到的三刺激值称为光谱三刺激值，可以根据波长λ绘制，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020131246.png" class="" title="image-20211020131246">

<p>频谱三刺激值在许多观察者中取平均值。波长为435.8、546.1和700 nm的单色光源的原色。</p>
<p><strong>通过使用一组明确的主光源，光谱三刺激值导致三个颜色匹配函数。国际电子委员会(CIE)定义了三种这样的原色光源，分别为435.8、546.1和700 nm。用这三张单色所有其他可见波长的自动光源都可以通过添加不同数量的光来匹配。每个所需的数量匹配给定波长λ编码在颜色匹配函数，由r¯(λ)， g¯(λ)，和¯b(λ)给出，并绘制在上图。与这些颜色匹配函数相关的三刺激值被称为R、G和B。</strong></p>
<p><strong>假设我们正在添加光，而光不可能是负的，您可能已经注意到上图中的一个异常:为了创建一些波长的匹配，有必要减去光。虽然没有所谓的负光，但我们可以再次使用格拉斯曼定律，我们可以在匹配的颜色中添加相同数量的光，而不是从混合的原色中减去光。</strong></p>
<p><strong>CIE r¯(λ)， g¯(λ)，和¯b(λ)颜色匹配函数允许我们确定一个光谱分布Φ₁ 匹配第二个光谱分布Φ₂ 简单比较通过整合这些颜色匹配函数得到的三刺激值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020131505.png" class="" title="image-20211020131505">

<p><strong>当然，只有当三个三刺激值都匹配时，颜色匹配才有保证。</strong></p>
<p><strong>这些颜色匹配函数的重要性在于，我们现在能够通过三刺激值来简洁地交流和描述颜色。对于给定的光谱函数，CIE颜色匹配函数提供了一种精确的方法来计算三刺激值。只要每个人都使用相同的颜色匹配函数，就应该总是能够生成匹配。</strong></p>
<p><strong>如果不能使用相同的颜色匹配函数，则可以将一组三刺激值转换为一组适合于相应原色集的不同三刺激值。CIE定义了一种这样的转变，原因有两个。首先，在20世纪30年代，数值积分很难执行，对于既可以是正数也可以是负数的函数来说更是如此。第二，CIE已经建立了光致发光响应函数CIE V (λ)。我们希望有三个积分函数，其中V (λ)为1并且在可见范围内三个都是正的。</strong></p>
<p><strong>为了创建一组正的颜色匹配函数，有必要定义虚三原色。换句话说，为了在可见光谱中再现任何颜色，我们需要的光源不能被物理实现。颜色匹配函数被CIE确定为x¯(λ)， y¯(λ)，和z¯(λ)，如下图所示。注意，y¯(λ)等于光的亮度响应函数V (λ)，并且每个函数确实都是正的。他们被称为CIE 1931年标准观察员。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020131718.png" class="" title="image-20211020131718">

<p>CIE x¯(λ)， y¯(λ)， z¯(λ)颜色匹配函数。</p>
<p><strong>相应的三刺激值被称为X, Y，和Z，以避免与R, G，和B三刺激值混淆，这些值通常与可实现的原色相关联。从(R, G, B)三刺激值到(X, Y, Z)三刺激值的转换由一个简单的3×3变换定义:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020131813.png" class="" title="image-20211020131813">

<p><strong>为了计算三刺激值，我们通常直接将标准观察者的颜色匹配函数与感兴趣的光谱Φ(λ)积分，而不是先通过CIE r¯(λ)， g¯(λ)，和¯b(λ)颜色匹配函数，然后再进行上述变换。它允许我们计算一致的颜色尺寸，并确定两种颜色何时匹配。</strong></p>
<h3 id="Chromaticity-Coordinates-色度坐标"><a href="#Chromaticity-Coordinates-色度坐标" class="headerlink" title="Chromaticity Coordinates 色度坐标"></a>Chromaticity Coordinates 色度坐标</h3><p><strong>每一种颜色都可以用一组三刺激值(X, Y, Z)来表示。我们可以用X, Y, Z轴定义一个正交坐标系，并在生成的三维空间中绘制每一种颜色。这就是所谓的颜色空间。颜色所处的空间范围就称为色域。</strong></p>
<p><strong>在3D颜色空间中可视化颜色是相当困难的。而且，任何颜色的Y值对应于它的亮度，这是由于y¯(λ) = V (λ)这一事实。因此，我们可以将三刺激值投影到一个近似彩色信息的二维空间，即与亮度无关的信息。这种投影称为色度图，通过归一化同时去除亮度信息得到:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132121.png" class="" title="image-20211020132121">

<p><strong>给定x + y + z = 1, z值是多余的，允许我们在色度图中绘制x和y的色度。虽然x和y本身不足以完全描述一种颜色，但我们可以使用这两个色度坐标和三个三刺激值中的一个，传统上是Y，来恢复其他两个三刺激值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132207.png" class="" title="image-20211020132207">

<p><strong>通过在色度图中绘制所有的单色(光谱)颜色，我们得到了一个马蹄形曲线。这条曲线上的点称为谱轨迹。所有其他颜色将生成位于曲线内的点。1931标准观测仪的谱轨迹如下图所示。紫色的线和马蹄形两端之间不代表一种单色，而是长短波长刺激的组合。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132307.png" class="" title="image-20211020132307">

<p>CIE 1931标准观测仪的光谱轨迹。</p>
<p><strong>一个(非单色)原色可以在所有可见波长上集成，得到(X, Y, Z)三刺激值，随后得到(x,y)色度坐标，即色度图上的一个点。对两个或更多原色重复这个过程，就会在色度图上产生一组可以用直线连接的点。以这种方式跨越的体积代表了可以通过添加这些原色的混合复制的颜色范围。三主系统的例子如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132407.png" class="" title="image-20211020132407">

<p>色度边界的CIE RGB三原色在435.8,546.1和700 nm(固体)和典型的HDTV(虚线)。</p>
<p><strong>色度图提供了对加色混合物的洞察。然而，它们应该小心使用。首先，马蹄铁内部不应该着色，因为任何颜色复制系统都有自己的原色，只能复制色度图的某些部分。第二，由于CIE的颜色匹配函数不能代表人类的视锥敏感度，色度图上任何两点之间的距离并不能很好地指示这些颜色将被感知到的不同程度。</strong></p>
<p><strong>一个更均匀的色度图至少部分地解决了第二个问题。CIE u′v′色度图提供了一个感知上更均匀的间隔，因此通常优于(x, y)色度图。它由(X, Y, Z)三刺激值通过应用不同的归一化，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132524.png" class="" title="image-20211020132524">

<p><strong>也可以直接从(x, y)色度坐标计算:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132554.png" class="" title="image-20211020132554">

<p><strong>CIE u′v′色度图如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132640.png" class="" title="image-20211020132640">

<h2 id="Color-Spaces-颜色空间"><a href="#Color-Spaces-颜色空间" class="headerlink" title="Color Spaces 颜色空间"></a>Color Spaces 颜色空间</h2><p><strong>如上所述，每种颜色都可以用三个数字来表示，例如用(X, Y, Z)三刺激值来定义。然而，它的原色是假想的，这意味着不可能制造出一个设备，它有三个光源(都是正极)，可以重现可见光谱中的所有颜色。</strong></p>
<p><strong>出于同样的原因，在图像上进行图像编码和计算可能并不实用。例如，有大量可能的XY Z值并不对应于任何物理颜色。这将导致存储可用位的低效使用，并对位深度提出更高的要求，以在图像处理后保持视觉完整性。虽然有可能构建一个具有接近CIE XY Z颜色匹配功能的原色的捕获设备，但硬件和图像处理的成本使它成为一个没有吸引力的选择。不可能建立一个对应CIE XY Z的显示。出于这些原因，有必要设计其他颜色空间:物理可实现性、有效编码、感知一致性和直观的颜色规范。</strong></p>
<p><strong>CIE XY Z颜色空间仍然被积极使用，主要用于其他颜色空间之间的转换。它可以被看作是一个与设备无关的颜色空间。</strong></p>
<p><strong>其他颜色空间可以根据它们与CIE XY Z的关系来定义，这通常是由一个特定的变换来指定的。例如，线性和加性三色显示设备可以通过一个简单的3 × 3矩阵转换成CIE XY Z。还可以指定一些非线性附加变换，例如，当数据以有限位深存储时，将感知误差降到最低，或直接在输入信号和发射光量之间存在非线性关系的设备上显示。</strong></p>
<h3 id="Constructing-a-Matrix-Transform-构造矩阵变换"><a href="#Constructing-a-Matrix-Transform-构造矩阵变换" class="headerlink" title="Constructing a Matrix Transform 构造矩阵变换"></a>Constructing a Matrix Transform 构造矩阵变换</h3><p><strong>显示设备有三个初选,说红色,绿色和蓝色,我们可以测量发射光的光谱成分通过发送颜色向量(1,0,0)(0,1,0)和(0 0 1)。这些向量代表三种情况即初选充满之一,和其他两个。从测量光谱输出,我们可以计算出相应的色度坐标(xR, yR), (xG, yG), 和 (xB, yB)。</strong></p>
<p><strong>显示器的白点定义为当颜色向量(1,1,1)被发送到显示器时所发出的光谱。其对应的色度坐标为(xW,yW )．三原色和白点描述了显示器的特征，每一个都需要在显示器的颜色空间和CIE XY Z之间构建一个变换矩阵。</strong></p>
<p><strong>这四个色度坐标可以扩展为从z = 1−x−y重建z坐标的色度三联体，得到三联体(xR,yR, zR), (xG,yG,zG), (xB,yB,zB ), (xW,yW,zW )．如果已知白点的最大亮度，就可以计算出其对应的三刺激值(XW,YW , ZW )，然后解出亮度的下列方程组</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133347.png" class="" title="image-20211020133347">

<p><strong>RGB和XYZ之间的转换是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133433.png" class="" title="image-20211020133433">

<p><strong>任何给定颜色的亮度可以通过计算矩阵的中间行来计算:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133523.png" class="" title="image-20211020133523">

<p><strong>要在给定设备的XYZ和RGB之间转换，上面的矩阵可以简单地倒转。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133619.png" class="" title="image-20211020133619">

<p>ITU-R BT.709规定的原色和白点的(x, y)色度坐标。sRGB标准也使用这些原色和白点。</p>
<p><strong>如果图像是在原色和白点未知的RGB颜色空间中表示的，那么接下来最好假设图像是在标准RGB颜色空间中编码的。一个合理的选择是假设图像是根据ITU-R BT.709指定的，这是用于HDTV编码和广播的规范。其原色和白点在上表中指定。请注意，使用相同的原色和白点来定义众所周知的sRGB颜色空间。这个RGB颜色空间和CIE XYZ之间的变换为，反之亦然</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133730.png" class="" title="image-20211020133730">

<p><strong>通过替换设备的最大RGB值，我们可以计算出白点。对于ITU-R BT.709，最大值为(RW,GW,BW =(100, 100, 100)，导致白点为(XW,YW,ZW ) =(95.05, 100.00, 108.90)。</strong></p>
<p><strong>除了线性变换外，sRGB颜色空间还具有随后的非线性变换。给出了非线性编码</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133829.png" class="" title="image-20211020133829">

<p><strong>这种非线性编码有助于减少数字应用中由于量化误差而产生的感知误差。</strong></p>
<h3 id="Device-Dependent-RGB-Spaces-设备依赖的RGB空间"><a href="#Device-Dependent-RGB-Spaces-设备依赖的RGB空间" class="headerlink" title="Device-Dependent RGB Spaces 设备依赖的RGB空间"></a>Device-Dependent RGB Spaces 设备依赖的RGB空间</h3><p><strong>由于每个设备通常都有自己的原色和白点集合，所以我们称相关的RGB颜色空间为设备相关的。需要注意的是，即使所有这些设备都在RGB空间中运行，它们的原色和白点也可能非常不同。因此，如果我们在某些RGB空间中指定了一幅图像，它对我们来说可能会非常不同，这取决于我们显示它的设备。</strong></p>
<p><strong>这显然是一种不受欢迎的情况，因为缺乏色彩管理。然而，如果图像是在已知的RGB颜色空间中指定的，那么它可以首先被转换为XYZ，这是独立于设备的，然后它可以被转换为设备的RGB空间，它将在该设备上显示。</strong></p>
<p><strong>还有其他几个明确定义的RGB颜色空间。它们都由一个线性矩阵变换和一个非线性变换组成，类似于前面提到的sRGB颜色空间。非线性变换可参数化如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133946.png" class="" title="image-20211020133946">

<p><strong>参数s, f, t和γ，连同原色和白点，指定了在各个行业中使用的一类RGB颜色空间。下表中列出了几种常见的转换。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020134037.png" class="" title="image-20211020134037">

<p>标准RGB颜色空间的转换(在(Pascale, 2003)之后)。</p>
<h3 id="LMS-Cone-Space-LMS锥体空间"><a href="#LMS-Cone-Space-LMS锥体空间" class="headerlink" title="LMS Cone Space LMS锥体空间"></a>LMS Cone Space LMS锥体空间</h3><p><strong>上述锥信号可以用CIE XYZ颜色空间表示。给出了计算从XYZ到的LMS信号的矩阵变换</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020134323.png" class="" title="image-20211020134323">

<p><strong>这种变换被称为Hunt-Pointer-Estevez变换(Hunt, 2004)，用于彩色自适应变换以及颜色外观建模。</strong></p>
<h3 id="CIE-1976-L-a-b"><a href="#CIE-1976-L-a-b" class="headerlink" title="CIE 1976 L* a* b*"></a>CIE 1976 L* a* b*</h3><p><strong>颜色对抗空间的特征是一个表示消色差通道(亮度)的通道，以及两个编码颜色对抗的通道。这些通常是红绿色和黄蓝色通道。这些颜色对抗，因此，内尔编码沿着一个轴的两个色度，可以有正负值。例如，红绿通道将正值编码为红色，负值编码为绿色。值0编码了一个特殊情况:中和色（neutral），既不是红色也不是绿色。黄蓝通道的工作原理大致相同。</strong></p>
<p><strong>由于在两个色轴上至少编码了两种颜色，因此不可能编码红色和绿色的混合物。同时编码黄色和蓝色也是不可能的。虽然这似乎是一个缺点，但众所周知，人类视觉系统在视觉通路的早期就计算出了类似的属性。因此，人类无法同时感知红色和绿色，黄色和蓝色。我们没有看到任何类似红绿或黄蓝的东西。然而，我们能够感知黄-红(橙)或绿-蓝等颜色的混合，因为这些是通过彩色通道编码的。</strong></p>
<p><em><em>对计算机图形来说，最相关的反色系统是CIE 1976 L</em> a</em> b<em>颜色模型。它是一个感知上或多或少统一的颜色空间，在计算色差时非常有用。它也被称为CIELAB。</em>*</p>
<p><strong>CIELAB的输入是刺激(X, Y, Z)三刺激值，以及由已知光源照亮的漫反射白色表面的三刺激值(Xn,Yn, Zn)．因此，CIELAB不仅仅是一个普通的颜色空间，因为它考虑了已知光照下的一小块颜色。因此，它可以被看作是一个基本的颜色外观空间。</strong></p>
<p><em><em>CIELAB中定义的三个通道分别是L</em> 、a</em> 和 b<em>。L <em>为通道编码颜色的亮度，即具有三刺激值(X, Y, Z)的贴片的感知反射系数。a * 和 b</em>为颜色对抗通道。XYZ与CIELAB之间的变换为</em>*</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020135253.png" class="" title="image-20211020135253">

<p><strong>函数f定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020135317.png" class="" title="image-20211020135317">

<p>*<em>从这个公式可以看出，色度通道确实取决于亮度Y。尽管这在感知上是准确的，但这意味着我们不能在色度图中绘制一个a * 和 b</em>的值。亮度L <em>标准化在0到100之间是黑白的。尽管a * 和 b</em>通道没有明确限制，但它们通常在[−128,128]范围内。**</p>
<p><strong>由于CIELAB近似感知线性，因此可以将两种颜色转换为CIELAB，然后通过计算它们之间的欧氏距离来估计感知到的颜色差异。这就得到了以下色差公式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020135501.png" class="" title="image-20211020135501">

<p><strong>字母E代表感觉上的不同(德语，Empfindung)(贾德，1932)。</strong></p>
<p><strong>最后，给出了CIELAB与XYZ之间的逆变换</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020135514.png" class="" title="image-20211020135514">

<h2 id="Chromatic-Adaptation-色彩适应"><a href="#Chromatic-Adaptation-色彩适应" class="headerlink" title="Chromatic Adaptation 色彩适应"></a>Chromatic Adaptation 色彩适应</h2><p><strong>刚才描述的CIELAB颜色空间以刺激的三刺激值和白色漫反射片反射的光的三刺激值作为输入。因此，它形成了一个系统的开端，在其中查看环境被考虑在内。</strong></p>
<p><strong>我们观察物体和图像的环境对我们如何感知这些物体有很大的影响。我们在日常生活中遇到的观看环境的范围是非常大的，从阳光到星光，从烛光到荧光灯。照明条件不仅构成了一个非常大的范围内的光的数量，而且还在发射光的颜色上有很大的变化。</strong></p>
<p><strong>人类的视觉系统通过一个叫做适应的过程来适应环境中的这些变化。可以区分三种不同类型的适应，即光适应、暗适应和色适应。光适应是指当我们从一个非常黑暗的环境移动到一个非常明亮的环境时所发生的变化。当这种情况发生时，起初我们会被光线弄得眼花缭乱，但很快我们就适应了新的环境，并开始区分我们环境中的物体。暗适应指的是相反的情况，即我们从光明的环境进入黑暗的环境。一开始，我们看到的很少，但在给定的时间后，细节将开始出现。适应黑暗所需的时间通常比适应光明所需的时间要长得多。</strong></p>
<p><strong>色彩适应是指我们对光照颜色变化的适应能力。从本质上讲，彩色适应是大多数现代相机上的白平衡操作的生物等效。人类视觉系统有效地使观看条件正常化，以呈现相当一致的视觉体验。因此，我们表现出一定的颜色稳定性:物体的反射率相对稳定，尽管在照明变化。</strong></p>
<p><strong>虽然我们能够在很大程度上忽略观看环境的变化，但我们不能完全这样做。例如，颜色在晴天比在阴天显得更加丰富多彩。虽然表面发生了变化，但我们并不认为物体反射本身实际上改变了它们的物理性质。因此，我们了解到照明条件影响了整体颜色的外观。</strong></p>
<p><strong>尽管如此，色彩恒常性确实适用于彩色内容。色彩适应性允许白色物体在大量光照条件下呈现白色，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141102.png" class="" title="image-20211020141102">

<p>在CIE u′v′色度图。一张白纸在这些光源的照射下会保持白色的外观。</p>
<p><strong>颜色适应的计算模型倾向于关注锥细胞的增益控制机制。最简单的模型之一是假设每个锥体都能独立地适应它所吸收的能量。这意味着不同类型的锥适应不同的光谱吸收的光。这种适应性可以被建模为锥体信号的自适应和独立缩放:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141202.png" class="" title="image-20211020141202">

<p><strong>其中(La, Ma, Sa)为彩色自适应圆锥信号，α、β和γ是由观察环境决定的独立增益控制。这种独立的适应也被称为von-Kries适应。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141411.png" class="" title="image-20211020141411">

<p>冯·克里斯式独立光感受器增益控制的一个例子。显示了CIE光源A的相对锥响应(实线)和相对适应锥响应(虚线)。单独的色块表示CIE光源A呈现在sRGB颜色空间中。</p>
<p><strong>自适应光照可以测量出场景中的白色表面。在理想情况下，这是朗伯曲面。在数字图像中，自适应光照也可以近似为场景的最大三刺激值。用这种方法测量或计算的光是自适应白，由(Lw,Mw,Sw)．Von Kries的适应就是简单的基于互惠的缩放适应性的白色，在锥体响应空间中进行:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141511.png" class="" title="image-20211020141511">

<p><strong>在许多情况下，我们感兴趣的是在一个光照下应该产生什么刺激来匹配不同光照下的给定颜色。例如，如果我们有一个被日光照亮的色块，我们可能会问自己应该生成什么样的三刺激值来创建一个由白炽灯照亮的匹配色块。</strong></p>
<p><strong>因此，我们感兴趣的是计算相应的颜色，这可以通过层叠两色自适应计算来实现。从本质上讲，前面提到的von Kries变换划分出了适应光源——在我们的例子中，日光照明。如果我们随后在白炽光源上乘上，我们就算出了相应的颜色。如果两种光源为(Lw,1,Mw,1,Sw,1)和(Lw,2,Mw,2,Sw,2)，对应的颜色(Lc,Mc,Sc)是由</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141627.png" class="" title="image-20211020141627">

<p><strong>还有一些更复杂，因此更精确的颜色适应变换(Reinhard et al.， 2008)。然而，简单的von Kries模型在建模彩色适应方面仍然非常有效，因此可以用于实现数字图像中的白色平衡。</strong></p>
<p><strong>在渲染的背景下，色彩适应的重要性在于，我们已经向考虑观察者的观看环境迈出了一步，而不必通过调整场景和重新渲染我们的图像来纠正它。相反，我们可以建模和渲染我们的场景，然后，作为一个图像后处理，纠正视觉环境的照明。然而，为了确保白平衡不会引入伪影，确保将图像呈现为浮点格式是很重要的。如果渲染到传统的8位图像格式，彩色自适应变换可能放大量化误差。</strong></p>
<h2 id="Color-Appearance-颜色外观"><a href="#Color-Appearance-颜色外观" class="headerlink" title="Color Appearance 颜色外观"></a>Color Appearance 颜色外观</h2><p><strong>虽然比色法允许我们以一种独立于设备的方式准确地指定和传达颜色，而色彩适应允许我们在照明变化中预测颜色匹配，但这些工具仍然不足以描述颜色实际看起来是什么样的。</strong></p>
<p><strong>为了预测对一个物体的实际感知，我们需要了解更多关于环境的信息，并将这些信息纳入考虑。人类的视觉系统在不断地适应环境，这意味着对颜色的感知会受到这种变化的强烈影响。颜色外观模型考虑刺激本身的测量，以及观看环境。这意味着产生的颜色描述是独立于观看条件的。</strong></p>
<p><strong>颜色外观建模的重要性可以在下面的例子中看到。假设一个图像显示在LCD屏幕上。当打印相同的图像，并在不同的背景下观看它时，通常图像看起来会明显不同。颜色外观模型可以用来预测生成准确的跨媒体颜色再现所需的变化(Fairchild, 2005)。</strong></p>
<p><strong>虽然色彩外观建模为色彩再现提供了重要的工具，但实际的实现往往相对复杂和繁琐。可以预见，这种情况可能会随着时间的推移而改变。然而，在那之前，我们把他们的描述留给更专业的教科书(Fairchild, 2005)。</strong></p>
<h1 id="20-Visual-Perception-视觉感知"><a href="#20-Visual-Perception-视觉感知" class="headerlink" title="20 Visual Perception 视觉感知"></a>20 Visual Perception 视觉感知</h1><p><strong>计算机图形学的最终目的是生成供人们观看的图像。因此，计算机图形系统的成功取决于它如何将相关信息传递给人类观察者。物理世界的内在复杂性和显示设备的局限性使它不可能向观众呈现与观察自然环境时相同的光模式。当计算机图形系统的目标是物理真实感时，我们所能期望的最好结果就是系统在感知上是有效的:显示的图像应该“看起来”如预期的那样。对于技术演示等应用程序，通常希望以视觉方式突出相关信息，而感知效果则成为明确的需求。</strong></p>
<p><strong>艺术家和插图画家已经根据经验开发了广泛的工具和技术来有效地传达视觉信息。提高计算机图形学感知有效性的方法之一是在我们的自动化系统中利用这些方法。第二种方法直接建立在人类视觉系统的知识基础上，将感知有效性作为计算机图形系统设计的优化标准。这两种方法并非完全不同。事实上，在列奥纳多·达·芬奇的笔记本中发现了视觉感知的第一个系统检验。</strong></p>
<p><strong>本章的其余部分提供了一个关于人类视觉感知的部分概述。重点是与计算机图形学最相关的人类视觉方面。人类的视觉系统在运作和结构上都是极其复杂的。像这样的一章最多只能提供一个关键点的总结，重要的是要避免从这里介绍的内容过度概括。Wandell(1995)和Palmer(1999)对视觉知觉进行了更深入的研究;Gregory(1997)和Yantis(2000)提供了更多有用的信息。一个好的计算机视觉参考，如Forsyth和Ponce(2002)也很有帮助。值得注意的是，尽管有超过150年的深入研究，我们对视力的许多方面的知识仍然非常有限和不完善。</strong></p>
<h2 id="Vision-Science-视觉科学"><a href="#Vision-Science-视觉科学" class="headerlink" title="Vision Science 视觉科学"></a>Vision Science 视觉科学</h2><p><strong>人们普遍认为视觉是人类最强大的感官。视觉比听觉、触觉、嗅觉或味觉更能提供关于世界的有用信息。这是光物理学的直接结果(下图)。照明是普遍的，特别是在白天，但在夜晚由于月光，星光和人工来源。表面反射了大量的入射照明，并且以特定材料特有的方式反射，这取决于表面的形状。光(大部分)在空气中以直线传播，这一事实使得视觉能够从遥远的地方获取信息。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021142347.png" class="" title="image-20211021142347">

<p>光的本质使视觉具有强大的意义。</p>
<p><strong>视觉研究有着悠久而丰富的历史。我们对眼睛的了解大多可以追溯到17世纪哲学家和物理学家的工作。从19世纪中期开始，知觉心理学家对视觉现象学进行了大量的研究，并提出了视觉如何工作的模型。20世纪中期是现代神经科学的开端，它既研究单个神经元的精细尺度的工作，也研究大脑和神经系统的大规模结构组织。神经科学研究的很大一部分集中在视觉上。最近，计算机科学通过提供精确描述视觉计算的假设模型的工具和允许计算机视觉程序的经验检验，对理解视觉感知做出了贡献。术语视觉科学是指视觉知觉的多学科研究，包括知觉心理学、神经科学和计算分析。</strong></p>
<p><strong>视觉科学认为视觉的目的是通过到达观察者的光的成像模式来产生关于世界上物体、位置和事件的信息。心理学家用远端刺激来指代观察下的物理世界，用近端刺激来指代视网膜图像。我们,在这个术语中，视觉的功能是产生对近端刺激的远端刺激的各个方面的描述。当产生的描述准确地反映了现实世界时，视觉感知就被称为是真实的。在实践中，孤立地考虑这些对象、位置和事件的描述是没有意义的。相反，视觉在它所服务的运动和认知功能的背景下可以更好地理解。</strong></p>
<h2 id="Visual-Sensitivity-视觉灵敏度"><a href="#Visual-Sensitivity-视觉灵敏度" class="headerlink" title="Visual Sensitivity 视觉灵敏度"></a>Visual Sensitivity 视觉灵敏度</h2><p><strong>视觉系统根据入射光照的特性创建视觉环境的描述。因此，了解人类视觉系统能够实际检测到的入射光照的特性是非常重要的。关于人类视觉系统的一个关键观察是，它主要对光的模式敏感，而不是对光能的绝对量级敏感。眼睛不能作为光度计来使用。相反，它检测视网膜上成像的光的空间、时间和光谱模式，关于这些光模式的信息构成了所有视觉感知的基础。</strong></p>
<p><strong>视觉系统对空间和时间上的光照变化的敏感性具有明显的生态效用。准确感知环境变化对我们的生存至关重要。一个测量光能变化而不是能量本身大小的系统在工程上也是有意义的，因为它使在光强大范围内更容易检测光的模式。视觉以这种方式运作对计算机图形学来说是件好事。显示设备在物理上是有限的，因为它们投射光线的功率和动态范围是典型的自然场景。如果图形显示需要产生与相应的物理世界相同的光模式，那么它们就不会有效。幸运的是，所需要的只是显示器能够产生与现实世界相似的空间和时间变化模式。</strong></p>
<h3 id="Brightness-and-Contrast-亮度和对比度"><a href="#Brightness-and-Contrast-亮度和对比度" class="headerlink" title="Brightness and Contrast 亮度和对比度"></a>Brightness and Contrast 亮度和对比度</h3><p><strong>在明亮的光线下，人类的视觉系统能够区分由高对比度平行光条和细至50-60周期/度的暗条组成的光栅。(在这种情况下，一个“循环”由一对相邻的亮条和暗条组成。)作为比较，目前最好的液晶电脑显示器，在正常的观看距离，可以显示图案的精细约20周期/度。人类视觉系统在强光下检测到的边缘处的最小对比度差约为边缘处平均亮度的1%。在大多数8位显示器中，由于从灰度级到实际显示亮度的映射特性，单个灰度级的差异通常在至少部分强度范围内是显而易见的。</strong></p>
<p><strong>描述视觉系统检测精细尺度模式(视敏度)和检测亮度变化的能力要比照相机和类似的图像采集设备复杂得多。如下图所示，人类视觉的对比度和敏锐度之间存在交互作用。在图中，图案的比例从左到右减小，而对比度从上到下增大。如果你以正常的观察距离观察图形，就会清楚地看到图案可见的最低对比度是图案空间频率的函数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021143240.png" class="" title="image-20211021143240">

<p>条纹之间的对比度从上到下以恒定的方式增加，而能见度阈值则随频率而变化。</p>
<p><strong>从世界上某一表面点到达人眼的光的强度L，照亮该表面点的光的强度I，和被观察点表面的反射率R之间存在线性关系:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021143329.png" class="" title="image-20211021143329">

<p><strong>其中α依赖于表面几何形状、入射照明模式和观察方向之间的关系。虽然眼睛只能直接测量L，但人类的视觉在估计R方面要比L好得多。要看到这个，可以在明亮的直射光下查看下图。用你的手在其中一个图案上画上阴影，让另一个直接发光。虽然两个图案反射的光会有显著的不同，但两个中心正方形的表观亮度看起来几乎是一样的。“亮度”一词通常用来描述表面的表观亮度，有别于其实际亮度。在许多情况下，亮度对光照的大变化是不变的，这种现象被称为亮度恒定。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144256.png" class="" title="image-20211021144256">

<p>亮度恒常性。用你的手在其中一个图案上投上阴影，注意到两个中心正方形的明显亮度几乎是相同的。</p>
<p><strong>人类视觉系统实现亮度恒定的机制还没有被很好地理解。如上上图所示，视觉系统对缓慢变化的光模式相对不敏感，这可能会抵消缓慢变化光照的影响。视亮度受周围区域亮度的影响(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144402.png" class="" title="image-20211021144402">

<p>(a)同时对比:中心条的表观亮度受周围区域亮度的影响;(b)相同的条，没有变量包围。</p>
<p><strong>这可以帮助不同区域照明时的亮度恒定。而这种同时产生的对比效果通常被描述为感知到的轻一个区域基于周围区域的亮度对比，它实际上要复杂得多(下两图)。关于亮度感知的更多信息，请参见(Gilchrist et al.， 1999)和(Adelson, 1999)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144516.png" class="" title="image-20211021144516">

<p>蒙克-怀特错觉显示了同时对比的复杂性。在上上图中，当周围区域变暗时，中心区域看起来更亮。在(a)中，左边的灰色条纹看起来比右边的灰色条纹浅，尽管它们几乎被白色区域包围;(b)显示没有黑线的灰色条纹。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144528.png" class="" title="image-20211021144528">

<p>对亮度的感知受到对三维结构的感知。标记(a)的两个表面具有相同的亮度，标记(b)的两个表面也是如此(Adelson(1999))。</p>
<p><strong>虽然视觉系统在很大程度上忽略了缓慢变化的强度模式，但它对由亮度不连续线组成的边缘非常敏感。成像光强中的边缘通常对应于表面边界或环境中的其他重要特征(下图)。视觉系统还可以检测运动的局部差异、立体视差、纹理等图像属性。然而，视觉系统几乎没有能力检测颜色的空间不连续，如果没有伴随这些其他特性的差异。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144713.png" class="" title="image-20211021144713">

<p>(a)原始灰度图像，(b)图像边缘，即在某一方向上空间变异性较大的线。</p>
<p><strong>对边缘的感知似乎与对形式的感知相互作用。虽然边缘为视觉系统提供了识别形状所需的信息，但如果最终的边缘创建了更完整的形式，那么缓慢变化的亮度可能会出现锐利的边缘(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144806.png" class="" title="image-20211021144806">

<p>视觉系统有时会看到“边缘”，即使在亮度上没有明显的不连续，就像这张图片中中心图案的右侧。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144852.png" class="" title="image-20211021144852">

<p>有时，视觉系统会“看到”主观轮廓，而没有任何相关的亮度变化。</p>
<p><strong>上图显示了一个主观轮廓，这是这种效果的一种极端形式，即使在实际图像中没有这样的轮廓，也可以看到一个封闭的轮廓。最后，视觉系统对边缘的敏感性似乎也是参与亮度感知的机制的一部分。注意，在上图中主观轮廓所包围的区域看起来比页面周围的区域要亮一些。下图显示了边缘和亮度之间的不同交互作用。在这种情况下，一个特定的亮度轮廓在边缘有一个戏剧性的影响表面的表观亮度的任何一边的边缘。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144949.png" class="" title="image-20211021144949">

<p>感知的亮度更多地依赖于边缘的局部对比度，而不是表面的亮度。试着用铅笔覆盖图形中间的垂直边缘。这个图像是Craik-O ‘Brien-Cornsweet错觉的一个例子。</p>
<p><strong>如上所述，如果两个相邻区域之间的亮度差异至少是平均亮度的1%，人们就可以检测到亮度差异。这是韦伯定律的一个例子，该定律指出，在刺激的显著差异(jnd)和刺激的大小之间存在一个恒定的比例:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145046.png" class="" title="image-20211021145046">

<p><strong>I是刺激的大小，ΔI是明显差异的大小，k₁ 是刺激所特有的常数。韦伯定律于1846年提出，至今仍是许多知觉效应的有用表征。1860年提出的Fechner定律，将韦伯定律推广到一种允许描述任何感官体验强度的方式，而不仅仅是jnd:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145120.png" class="" title="image-20211021145120">

<p><strong>其中S是感官体验的感知强度，I是相应刺激的物理大小，k₂ 是特定于刺激的缩放常数。目前的做法是使用幂函数(史蒂文斯定律)来模拟刺激的感知强度和实际强度之间的联系:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145152.png" class="" title="image-20211021145152">

<p><em><em>S和I和之前一样，k₃ 是另一个缩放常数，b是特定于刺激的指数。对于涉及视觉的大量知觉量，b &lt; 1。在其他地方描述的CIE L</em> a</em> b<em>颜色空间，使用改进的史蒂文斯定律表示来表征亮度值之间的感知差异。注意,在前两个特征的知觉强度的刺激和史蒂文斯定律当b &lt; 1,刺激的变化当它有一个小的平均大小创建更大的感知效果比相同的物理刺激的变化幅度更大。</em>*</p>
<p><strong>上面描述的“法则”并不是对感知如何运作的物理约束。相反，它们是关于感知系统如何对特定的物理刺激作出反应的概括。在知觉心理学领域，定量研究物理刺激与其知觉效应之间的关系被称为心理物理学。虽然心理物理定律是由经验推导出来的观察结果，而不是机械的解释，但如此多的知觉效应被简单的权力函数很好地模拟，这一事实是惊人的，可能提供了有关机制的见解。</strong></p>
<h3 id="Color-颜色"><a href="#Color-颜色" class="headerlink" title="Color 颜色"></a>Color 颜色</h3><p><strong>1666年，艾萨克·牛顿(Isaac Newton)用棱镜表明，显然白色的阳光可以分解成光谱的颜色，这些颜色可以重新组合，产生白色的光。我们现在知道光能是由一组光子组成的，每个光子都有特定的波长。光的光谱分布是光在每个波长的平均能量的量度。对于自然照明，表面反射的光的光谱分布显著地取决于表面材料。因此，这种光谱分布的特征可以为环境中表面的性质提供视觉信息。</strong></p>
<p><strong>大多数人在看世界的时候都有一种普遍的颜色感。颜色感知取决于光的频率分布，人类的可见光谱波长从370 nm到730 nm不等(见下图)。视觉系统从光谱分布中获得色彩感的方式在1801年首次被系统地研究，并在此后的150年里一直备受争议。问题是，视觉系统对光谱分布模式的反应与亮度分布模式非常不同。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145630.png" class="" title="image-20211021145630">

<p>可见光谱。波长的单位是纳米。</p>
<p><strong>即使考虑到亮度恒常性等现象，明显不同的空间分布几乎总是看起来明显不同。更重要的是，鉴于视觉系统的目的是在给出近端刺激的情况下产生对远端刺激的描述，感知到的亮度模式至少大致对应于环境中表面的亮度模式。</strong></p>
<p><strong>而对颜色的感知却并非如此。许多不同的光的光谱分布可以产生任何特定颜色的感觉。相应地，一个表面是一种特定颜色的感觉提供的关于从该表面来的光的光谱分布的直接信息很少。例如，光谱分布由波长为700 nm和540 nm的光组合而成，并适当地选择相对强度，看起来与波长为580 nm的光没有区别。(感知上难以区分的不同光谱组成的颜色被称为超光谱。)如果我们看到“黄色”，我们就无法知道它是由这些分布中的一种或另一种产生的，还是由无穷多的其他光谱分布产生的。因此，在视觉语境中，颜色一词指的是一种纯粹的感知性质，而不是物理性质。</strong></p>
<p><strong>在人类视网膜上有两类感光细胞。视锥细胞参与颜色感知，而视杆细胞对可见范围内的光能敏感，不提供颜色信息。有三种视锥细胞，每一种都有不同的光谱灵敏度(下图)。S锥对可见光谱中蓝色范围内的短波长有反应。M锥对可见光谱的中间(绿色)区域的波长有反应。L锥对覆盖可见光谱的绿色和红色部分的较长的波长有反应。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145802.png" class="" title="image-20211021145802">

<p>人眼视网膜中短、中、长视锥细胞的光谱敏感度</p>
<p><strong>虽然我们通常用红色、绿色和蓝色来描述三种视锥细胞，但这既不是正确的术语，也不能准确反映上图所示的视锥细胞的敏感性。L锥和M锥是广泛调谐的，这意味着它们对广泛的频率范围作出反应。三种锥型的灵敏度曲线也有很大的重叠。综上所述，这两个性质意味着不可能重建一个近似给出了三种锥型响应的原始谱分布。这与视网膜(和数码相机)的空间采样形成了对比，后者的感受器在空间灵敏度上进行了细微调整，以便能够在局部对比度下检测出细节。</strong></p>
<p><strong>人类视网膜中只有三种颜色敏感的光感受器，这一事实大大简化了在计算机显示器和其他图形显示器上显示颜色的任务。计算机显示器显示的颜色是三种固定颜色分布的加权组合。在大多数情况下，这三种颜色是明显的红色、明显的绿色和明显的蓝色。因此，在计算机图形中，颜色通常由红-绿-蓝(RGB)三色表示，代表显示特定颜色所需的红、绿、蓝三原色的强度。三种基本颜色足以显示大多数可感知颜色，因为适当选择的三种颜色的适当加权组合可以产生这些可感知颜色的度量。</strong></p>
<p><strong>RGB颜色表示至少存在两个重大问题。首先，不同的显示器的红、绿、蓝三原色有不同的光谱分布。因此，感知上正确的颜色再现需要为每个显示器重新映射RGB值。当然，这只有在原始RGB值满足某些定义良好的标准时才有可能，但通常情况并非如此。(关于这个问题的更多信息，请参阅第19章。)第二个问题是RGB值不能以一种符合主观感知的方式来定义特定的颜色。当我们看到“黄色”时，我们不会觉得它是由红光和绿光等分组成的。相反，它看起来像是一种单一的颜色，带有亮度和颜色“数量”等附加属性。将颜色表示为S锥、M锥和L锥的输出也没有帮助，因为我们没有更多的现象学意义上的颜色的特征为这些属性，而不是我们的特征为RGB显示属性。</strong></p>
<p><strong>有两种不同的方法可以更准确地反映人类的感知来描述颜色。各种CIE颜色空间的目标是“感知统一”，以便两种颜色的代表值的差异大小与感知到的颜色差异成正比(Wyszecki &amp; Stiles, 2000)。这是一个很难实现的目标，在过去的几年里CIE模式已经有了几次修改。此外，虽然CIE颜色空间的一个维度对应于感知的亮度，但其他两个指定色度的维度没有直观的意义。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021150033.png" class="" title="image-20211021150033">

<p>HSV颜色空间。色调在圆周围变化，饱和度随半径变化，值随高度变化。</p>
<p><strong>第二种以更自然的方式描述颜色的方法始于观察到有三个不同的和独立的属性支配色彩的主观感觉。亮度，即表面的表观亮度，已经讨论过了。饱和度是指颜色的纯度或鲜明度。颜色可以从完全不饱和的灰色到部分饱和的粉彩，再到完全饱和的“纯”色。第三个属性，色相，最接近“颜色”这个词的非正式含义，其特征与可见光谱中的颜色相似，从深紫色到深红色。上图显示了色调-饱和度-亮度(HSV)色彩空间图。由于亮度和亮度之间的关系既复杂又不被很好地理解，HSV颜色空间几乎总是使用亮度而不是试图估计亮度。然而，与光谱中的波长不同，色相通常以一种反映可见光谱的极端在外观上实际上是相似的方式来表示(下图)。一个特定颜色值的RGB和HSV表示之间存在简单的转换。因此，虽然HSV颜色空间是由感知考虑驱动的，但它包含的信息并不比RGB表示多。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021150120.png" class="" title="image-20211021150120">

<p>绿色和紫色，哪个颜色更接近红色?</p>
<p><strong>描述颜色的色调-饱和度-亮度方法是基于单点上的光谱分布，因此仅近似于光在空间上分布的光谱分布的感知响应。像亮度/亮度一样，颜色感知也受到类似的恒定和同时的对比度影响，这两者在RGB表示中都没有捕捉到，因此在HSV表示中也没有捕捉到。例如，在白炽灯下的室内和在阳光直射下的室外，看一张白纸。在这两种情况下，纸张看起来都是“白色”的，尽管白炽灯有明显的黄色色调，因此纸张反射的光线也会有黄色色调，而阳光的光谱颜色则要均匀得多。</strong></p>
<p><strong>CIE颜色空间或HSV编码都没有捕捉到的另一个色彩感知方面是，当我们观察连续的可见光光谱或自然出现的彩虹时，我们会看到少量独特的颜色。对大多数人来说，可见光谱似乎可以分为四到六种不同的颜色:红、黄、绿、蓝，也许再加上浅蓝色和紫色。如果考虑到非光谱颜色，英语中常用的基本颜色术语只有11个:红、绿、蓝、黄、黑、白、灰、橙、紫、棕、粉。将本质上连续的光谱分布空间划分为与定义明确的语言术语相关的相对较小的知觉类别集，似乎是知觉的基本属性，而不仅仅是文化产物(Berlin &amp; Kay, 1969)。然而，这一过程的确切性质尚不清楚。</strong></p>
<h3 id="Dynamic-Range-动态范围"><a href="#Dynamic-Range-动态范围" class="headerlink" title="Dynamic Range 动态范围"></a>Dynamic Range 动态范围</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021150444.png" class="" title="image-20211021150444">

<p>白色表面在不同照明类型下的近似亮度水平，单位为每平方米坎德拉(cd/m2)。(万德尔,1995)。</p>
<p><strong>自然光照强度的变化超过6个数量级(上图)。人类的视觉系统能够在整个亮度范围内运作。然而，在任何时间点上，视觉系统只能在更小的范围内检测到光强度的变化。由于视觉系统所暴露的平均亮度随时间而变化，因此可分辨亮度的范围也会相应发生变化。如果我们从一个明亮的室外区域快速移动到一个非常黑暗的房间，这种效果是最明显的。起初，我们能看到的很少。然而，过了一段时间，房间里的细节开始变得明显。这种对黑暗的适应涉及到眼睛的许多生理变化。显著的暗适应需要几分钟，完全的暗适应需要40分钟左右。如果我们回到明亮的光线中，不仅视野困难，实际上还会很痛苦。在它再次能够看清楚之前，光适应是必需的。光适应发生的速度比暗适应快得多，通常需要不到一分钟。</strong></p>
<p><strong>人类视网膜上的两类光感受器对不同的亮度范围都很敏感。从明亮的阳光到昏暗的室内光线，视锥细胞在大多数我们认为正常的光照条件下提供视觉信息。这种棒只在非常低的光线下有效。光视涉及到只有视锥细胞有效的强光。暗视涉及到只有杆状体有效的暗光。视锥细胞和视杆细胞在一定的强度范围内对光线变化都很敏感，这被称为中温条件(见第21章)。</strong></p>
<h3 id="Field-of-View-and-Acuity-视野和敏锐度"><a href="#Field-of-View-and-Acuity-视野和敏锐度" class="headerlink" title="Field-of-View and Acuity 视野和敏锐度"></a>Field-of-View and Acuity 视野和敏锐度</h3><p><strong>每个眼睛在人类的视觉系统有一个视野大约160◦水平135◦垂直。在双目观察中，两只眼睛的视野只有部分重叠。这导致一个更宽的整体视野(大约200◦水平◦135◦垂直)，与重叠的区域大约是120◦水平◦135◦垂直。</strong></p>
<p><strong>在正常视力或矫正视力的情况下，我们通常有一种主观体验，无论我们看什么，都能看到相对细微的细节。然而，这只是一种错觉。每只眼睛的视野中只有一小部分对细节是敏感的。要看到这一点，将一张覆盖着正常大小文本的纸放在手臂的长度处，如下图所示。盖住一只眼睛手不握纸。盯着你的拇指不动眼睛的时候，注意你拇指上方的文字是可读的，而两边的文字则不然。高灵敏度的视力局限于一个略大于你的拇指在手臂长度的视角。我们通常不会注意到这一点，因为眼睛通常会频繁地移动，使得视野的不同区域都能以高分辨率被观察到。随着时间的推移，视觉系统将这些信息整合在一起，以高分辨率产生整个视野的主观体验。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021150916.png" class="" title="image-20211021150916">

<p>如果你把一页文字拿在一臂远的地方，盯着你的拇指看，那么只有拇指附近的文字是可读的。由Peter Shirley拍摄。</p>
<p><strong>如果在整个视网膜上对图像强度进行密集采样，人类视觉皮层就没有足够的带宽来处理由此产生的信息。视网膜中密度可变的光感受器的堆积和快速眼球运动以指向感兴趣区域的机制的结合，提供了一种同时优化视力和视野的方法。其他动物进化出了不同的平衡视力和视野的方式，而不依赖于快速的眼球运动。有些人只有高的视力，但局限于狭窄的视野。有些人视野开阔，但看到细节的能力有限。</strong></p>
<p><strong>将周围环境中感兴趣的区域集中在中央凹上的眼部运动称为扫视。扫视发生得非常快。从触发刺激到完成眼球运动的时间为150-200毫秒。大部分时间花在视觉系统规划扫视。实际的移动平均需要20毫秒左右。眼睛在扫视过程中移动非常快，最大旋转速度经常超过500◦/秒。在扫视之间，眼睛指向一个感兴趣的区域(固定)，需要300毫秒左右的时间来获取详细的视觉信息。在广阔的视野中，多重固定结合在一起形成一个整体的主观细节感的机制还没有被很好地理解。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021151005.png" class="" title="image-20211021151005">

<p>人视网膜中视杆细胞和视锥细胞的密度(以Osterberg(1935)命名)。</p>
<p><strong>上图显示了人眼视网膜中视锥细胞和视杆细胞的不同堆积密度。在正常光照下负责视觉的视锥细胞最紧密地聚集在视网膜中央凹处(上图)。当眼睛固定在环境中的一个特定点时，这个点的图像就落在中央凹上。中央凹处的锥细胞堆积密度越高，成像光的采样频率就越高(见第9章)，因此采样模式的细节就越详细。中央凹视觉包含约1.7◦，这是相同的视角，你的拇指在手臂的长度。</strong></p>
<p><strong>虽然上图的一个版本出现在大多数关于人类视觉感知的介绍性文本中，但它只提供了视觉敏度的神经生理学限制的部分解释。在信息被传送之前，单个视杆细胞和视锥细胞的输出通过神经连接以不同的方式汇聚在眼睛里沿着视神经到达视觉皮层。这种汇聚过滤由入射照明模式提供的信号，其方式对可检测的光模式有重要影响。特别是，离中央凹越远，平均亮度的区域就越大。因此，远离中央凹的空间视力急剧下降。大多数显示杆状和锥状堆积密度的图像表明了视网膜盲点的位置，在这里，将光学信息从眼睛传送到大脑的神经束通过视网膜，对光线没有敏感性。总的来说，盲点对真实世界感知的唯一实际影响是它在入门感知文本中的错觉，因为正常的眼球运动弥补了暂时的信息损失。</strong></p>
<p><strong>如上图所示，在中央凹中心处，棒的堆积密度降至零。远离中央凹时，杆状细胞密度先增大后减小。这样做的一个结果是，当光照很低时，没有中央凹视觉。在没有月亮的夜晚，远离城市灯光，观察夜空，就可以证明中央凹中没有杆状细胞。有些星星非常暗淡，如果你看星星旁边的一点，就能看到它们，但如果你直接看它们，它们就会消失。这是因为当你直接观察这些特征时，这些特征的图像只落在视网膜的锥细胞上，而锥细胞对光线不够敏感，无法探测到这些特征。稍微往旁边看会使图像落在更敏感的视锥细胞上。暗视的视力也受到限制，部分原因是视网膜上的杆状细胞密度较低，部分原因是为了增加传回大脑的视觉信息的光敏度，视网膜上杆状细胞的信号池更大。</strong></p>
<h3 id="Motion-运动"><a href="#Motion-运动" class="headerlink" title="Motion 运动"></a>Motion 运动</h3><p><strong>当阅读有关视觉感知的内容和看着印刷纸张上的静态图形时，我们很容易忘记，运动在我们的视觉体验中是无处不在的。由于眼睛和身体的运动以及世界上物体的运动，落在视网膜上的光的模式不断变化。这部分介绍了我们检测视觉运动的能力。第20.3.4节描述了如何使用视觉运动来确定环境的几何信息。第20.4.3节讨论了如何使用运动来引导我们在环境中的运动。</strong></p>
<p><strong>对落在视网膜上的特定光模式运动的检测是速度、方向、模式大小和对比度的复杂功能。这个问题更加复杂，因为同时的对比效应在运动知觉中发生的方式与在亮度知觉中观察到的方式相似。在一个极端的情况下，单一的小模式移动对一个对比，均匀的背景，可感知的运动需要一个运动速率对应的0.2◦-0.3◦/秒的视角。同样的图案对纹理图案的运动以十分之一的速度可以检测到。</strong></p>
<p><strong>由于对视网膜运动的敏感性，再加上眼跳运动的频率和速度，令人惊讶的是，当我们看到这个世界时，它通常看起来是稳定和静止的。视觉系统通过三种方式实现这一点。在扫视过程中，对比敏感度降低，减少了由眼睛位置的快速变化所产生的视觉效果。在扫视之间，各种精密复杂的机制调整眼睛的位置，以补偿头部和身体的运动，以及世界上感兴趣的物体的运动。最后，视觉系统利用眼睛位置的信息，从多个固定位置将高分辨率图像的小块拼接成一个单一的、稳定的整体。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021151506.png" class="" title="image-20211021151506">

<p>孔径问题:(a)如果一条直线或边缘以一种隐藏端点的方式移动，视觉信息不足以确定这条线的实际运动。(b)如果直线上有任何角或其他明显的标记，则直线的二维运动是明确的。</p>
<p><strong>如果看不到端点或角，直线和边缘的运动是模糊的，这种现象称为孔径问题(上图)。光圈问题的出现是因为平行于线或边的运动分量不会产生任何视觉变化。现实世界的几何学是足够复杂的，这很少在实践中造成困难，除了有意的幻觉，如理发杆。然而，在一些计算机图形渲染中发现的简化几何和纹理，有可能在感知运动中引入不精确性。</strong></p>
<p><strong>实时计算机图形、电影和视频如果没有一个重要的感知现象是不可能的:不连续运动，即一系列静态图像在时间上的离散间隔是可见的，然后在空间上按离散间隔移动，几乎与连续运动没有区别。这种效果被称为表观运动，强调连续运动的出现是一种错觉。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021152758.png" class="" title="image-20211021152758">

<p>(a)连续运动。(b)具有相同平均速度的不连续运动。在某些情况下，对这两种运动模式的感知可能是相似的。</p>
<p><strong>上图说明了连续运动与视运动的区别，这是现实世界中的典型运动，而视运动是几乎所有动态图像显示设备所产生的。在上图 (b)中绘制的运动包含了一个与上图 (a)所示类似的平均运动，由一个高时空频率调制，该频率解释了一个静止模式和一个不连续移动到一个新位置之间的交替。由于视觉系统对运动的高频部分不敏感，所以出现了连续运动的表观感知。</strong></p>
<p><strong>当单个图像出现的频率超过10hz时，只要连续图像之间的位置变化不是太大，就会产生明显的运动感。然而，对于大多数图像显示设备来说，这个速度不足以产生令人满意的连续运动感。几乎所有这类设备都会在切换到下一幅图像时引入亮度变化。在光线充足的条件下，人类的视觉系统对这种高达80赫兹的变化率的亮度变化非常敏感。在低光下，可检测性高达40赫兹。当交替亮度足够高时，发生闪烁融合，变化不再可见。</strong></p>
<p><strong>因此，为了产生令人信服的视觉动感，图像显示必须满足两个单独的约束条件:</strong> </p>
<p>​    <strong>•图像必须以≥10 Hz的速率更新;</strong> </p>
<p>​    <strong>•在更新图像的过程中引入的任何闪烁必须以≥60-80 Hz的频率发生。</strong> </p>
<p><strong>一种解决方案是要求图像更新率大于或等于60-80 Hz。然而，在许多情况下，这根本是不可能的。对于计算机图形显示，帧计算时间通常大大超过12-15毫秒。旧监视器技术的传输带宽和限制限制了普通广播电视每秒25-30幅图像。(一些高清电视格式的运行速度是60图像/秒。)电影以每秒24帧的速度更新图像，这是由于曝光时间的要求和物理移动胶片的机械困难。</strong></p>
<p><strong>不同的显示技术以不同的方式解决这个问题。计算机显示器的刷新频率为~ 70 ~ 80赫兹，与图像内容的变化频率无关。术语帧速率对于这种显示来说是不明确的，因为需要两个值来描述这种显示:刷新率，表示图像重新显示的速率和帧更新率，表示生成新图像用于显示的速率。标准的非高清电视广播电视使用60hz的刷新率(NTSC，在北美和其他一些地区使用)或50hz的刷新率(PAL，在世界其他大部分地区使用)。帧更新速率为刷新率的一半。不是将每个新图像显示两次，而是通过将交替的水平图像线划分为偶数和奇数字段，并交替显示这些偶数和奇怪的领域。在电影中避免闪烁的方法是，使用机械快门在进入下一帧之前每帧闪烁三次，产生72赫兹的刷新率，同时保持24赫兹的帧更新率。</strong></p>
<p><strong>使用视运动来模拟连续运动偶尔会产生不良的伪影。其中最著名的是马车车轮错觉，在这个错觉中，旋转车轮的辐条似乎在与预期的方向相反的方向旋转，给出了车轮的平移运动。车轮错觉是时间混叠的一个例子。辐条，或旋转圆盘上的其他空间周期模式，产生一个时间周期信号，用于观察与车轮或圆盘的中心固定的位置。固定的帧更新率有在时间上采样这个时间周期信号的效果。如果采样模式的时间频率太高，欠采样结果在图像显示时出现混叠，较低的时间频率。在某些情况下，这种时间频率的失真会导致空间失真，在这种情况下，车轮似乎在向后移动。由于时间采样率较低，马车轮错觉在电影中比在视频中更容易发生。</strong></p>
<p><strong>当从一种介质转换到另一种介质时，也会出现问题。当24赫兹的电影被转换成视频时，这一点尤为重要。不仅非隔行格式需要转换为隔行格式，而且也没有直接的方法将每秒24帧转换为每秒50或60个字段。一些高端显示设备能够部分补偿电影转换成视频时产生的影响。</strong></p>
<h2 id="Spatial-Vision-空间视觉"><a href="#Spatial-Vision-空间视觉" class="headerlink" title="Spatial Vision 空间视觉"></a>Spatial Vision 空间视觉</h2><p><strong>视觉系统执行的关键操作之一是对可见环境的几何属性的估计，因为这些是确定关于对象、位置和事件的信息的核心。视觉有时被描述为逆光学，以强调视觉系统的一个功能是倒转图像形成过程，以确定在视网膜上产生特定图案的几何形状、材料和世界上的照明。视觉系统的核心问题是，可见环境的特性与视网膜上成像的光的模式混杂在一起。亮度是光照和反射率的函数，由于光传输的复杂性，它可以依赖于大区域空间的环境属性。图像位置的投影环境位置最多可以用于将该位置的位置限制为半线。因此，几乎不可能唯一地确定产生特定成像模式光的世界的性质。</strong></p>
<p><strong>确定表面布局-环境中可见表面的位置和方向被认为是人类视觉的关键步骤。大多数讨论的视觉系统提取信息布局模式的光接收表面将问题划分为一组视觉线索,与每个线索描述一个特定的视觉模式,可以用来推断表面布局的属性以及所需的推理规则。由于表面布局很少能准确和明确地确定仅从视觉，推断表面布局的过程通常需要额外的，非视觉信息。这可能来自对现实世界可能发生的事情的其他感觉或假设。</strong></p>
<p><strong>视觉线索通常被分为四类。眼动线索包括关于眼睛位置和焦点的信息。视差线索包括用两只眼睛观察同一表面点所获得的信息，而不仅仅是眼睛的位置所获得的信息。运动线索提供了关于世界的信息，这些信息来自观察者的运动或物体的运动。图像线索来自于将三维表面形状投射到落在视网膜上的2D光模式的过程。本节讨论与曲面上单个点的几何信息提取相关的视觉线索。更多的位置和形状信息的提取将在第20.4节中介绍。</strong></p>
<h3 id="Frames-of-Reference-and-Measurement-Scales-参考框架和测量量表"><a href="#Frames-of-Reference-and-Measurement-Scales-参考框架和测量量表" class="headerlink" title="Frames of Reference and Measurement Scales 参考框架和测量量表"></a>Frames of Reference and Measurement Scales 参考框架和测量量表</h3><p><strong>对可见表面上的点的位置和方向的描述必须在特定的参考框架的上下文中完成，该框架指定了用于表示几何信息的坐标系统的原点、方向和比例。人类视觉系统使用多种参考框架，部分原因是不同的视觉线索提供了不同种类的信息，部分原因是信息被放置的目的不同(Klatzky, 1998)。以自我为中心的表示是根据查看者的身体来定义的。它们可以细分为固定在眼睛、头部或身体上的坐标系统。他心表象，也叫外心表象，是根据观察者外部的事物来定义的。异向参考系可以是环境中物体的局部配置，也可以是根据不同的位置、重力或地理属性进行全局定义。</strong></p>
<p><strong>从观察者到环境中特定可见位置的距离，以自我为中心的表现方式表达，在感知文献中通常被称为深度。表面取向可以用自中心坐标表示，也可以用非自中心坐标表示。取向的自我中心表示,偏一词用来指视线之间的角点和表面正常的点,而倾斜指的方向表面正常的投影到一个平面垂直于视线。</strong></p>
<p><strong>距离和方位可以用各种测量尺度表示。绝对描述是使用不属于感知信息本身的标准来指定的。这些标准可以是文化上定义的标准(如米)，也可以是相对于观众身体的标准(如眼睛的高度、肩膀的宽度)。相对描述将一个感知到的几何属性与另一个关联起来(例如，点a的距离是点b的两倍)。顺序描述是相对度量的一种特殊情况，在这种情况下，所代表的只是符号，而不是大小。下表提供了最常考虑的视觉线索的列表，以及它们可能提供的信息种类的特征。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153401.png" class="" title="image-20211021153401">

<p>绝对深度(a)、相对深度(r)和顺序深度(o)的常见视觉信息。</p>
<h3 id="Ocularmotor-Cues-眼动信息"><a href="#Ocularmotor-Cues-眼动信息" class="headerlink" title="Ocularmotor Cues 眼动信息"></a>Ocularmotor Cues 眼动信息</h3><p><strong>有关深度的眼动信息直接来自于对眼睛的肌肉控制。有两种不同类型的眼运动信息。注视是眼睛在一定距离上光学聚焦的过程。收敛(通常称为收敛)是指在三维空间中两只眼睛指向同一点的过程。适应和融合都有可能提供关于深度的绝对信息。</strong></p>
<p><strong>从生理学上讲，人眼的聚焦是通过扭曲眼睛前部晶状体的形状来实现的。视觉系统可以从这种扭曲的程度推断深度。适应是一个相对较弱的距离线索，超过约2米无效。大多数人在超过45岁后，在一定距离范围内都有越来越多的聚焦困难。对他们来说，迁就变得更不有效。</strong></p>
<p><strong>那些不熟悉视觉感知细节的人有时会将调节的深度估计与由于眼睛有限景深而产生的模糊所产生的深度信息混淆。调节深度线索提供了与聚焦的那部分视野的距离信息。它不依赖于视野的其他部分失焦的程度，除了视觉系统使用模糊来调整焦点。景深似乎确实提供了一定程度的顺序深度信息(下图)，尽管这一效应只得到有限的研究。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153731.png" class="" title="image-20211021153731">

<p>中心正方形是出现在圆形图案的前面，还是通过圆形图案的一个方孔出现?这两幅图像的唯一区别是线条和圆形图案之间的边缘清晰度(Marshall, Burbeck, Arely, roland, and Martin(1999)，经许可使用)。</p>
<p><strong>如果两只眼睛注视空间中的同一点，可以使用三角函数来确定从观察者到被观察位置的距离(下图)。在最简单的情况下，注视点就在观众的正前方，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153834.png" class="" title="image-20211021153834">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153845.png" class="" title="image-20211021153845">

<p>两眼的辐辏提供了关于两眼注视点的距离的信息。</p>
<p><strong>其中，z为到世界上某一点的距离，ipd为瞳间距离，表示两眼之间的距离，θ为收敛角，表示两眼相对于正前方的方向。对于小θ，也就是人眼的几何构型，当θ以弧度表示时，tan θ≈θ。因此，角的差值表示深度的差值，关系如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153934.png" class="" title="image-20211021153934">

<p><strong>随着θ→0匀速前进，Δz逐渐变大。这意味着随着整体深度的增加，立体视觉对深度变化的敏感度降低。收敛实际上只提供了距离几米的绝对深度的信息。除此之外，距离的变化会导致收敛角的变化，但这些变化太小，无法发挥作用。</strong></p>
<p><strong>在人类视觉系统中，调节和收敛是相互作用的:调节用来帮助确定合适的收敛角，收敛角用来帮助设置焦距。正常情况下，当存在不确定性时，这有助于视觉系统设置调节或收敛。然而，立体计算机显示打破了现实世界中焦点和收敛之间的关系，导致了许多知觉困难(Wann, Rushton， &amp; Mon-Williams, 1995)。</strong></p>
<h3 id="Binocular-Disparity-双眼差异"><a href="#Binocular-Disparity-双眼差异" class="headerlink" title="Binocular Disparity 双眼差异"></a>Binocular Disparity 双眼差异</h3><p><strong>眼睛的收敛角，当固定在空间中的一个公共点上时，只是视觉系统能够从双目立体判断深度的方法之一。第二种机制涉及到视网膜图像的比较两只眼睛，不需要知道眼睛指向哪里。一个简单的例子演示了这种效果。手臂向前伸直，拇指向上。盯着你的拇指，然后闭上一只眼睛。现在，同时睁开闭着的眼睛和闭着睁开的眼睛。你的拇指看起来或多或少是静止的，而你拇指后面更远的表面看起来会从一边到另一边移动(下图)。场景中左眼和右眼之间的点在视网膜上位置的变化叫做视差。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021212243.png" class="" title="image-20211021212243">

<p>双眼差异。从左眼和右眼的视图显示了不同于注视点深度的表面点的偏移。图片由Peter Shirley提供。</p>
<p><strong>双目视差提示要求视觉系统能够将一只眼睛中世界上的点的图像与另一只眼睛中这些点的图像位置进行匹配，这个过程称为对应问题。这是一个相对复杂的过程，人们只了解部分内容。一旦建立了对应关系，世界上特定的点投射到左右视网膜上的相对位置就表明这些点是比注视点更近还是更远。交叉视差发生在相应的点相对于中央凹向外移位，表明表面点比固定点更近。当相应的点相对于中央凹向内移位时，出现不交叉视差，表明表面点比固定点更远(下图)。双目视差是一个相对深度线索，但通过收敛进行缩放，可以提供绝对深度的信息。上上式既适用于双眼视差，也适用于双眼收敛。与收敛时，双眼视差对深度变化的灵敏度随深度的增加而降低。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021212425.png" class="" title="image-20211021212425">

<p>在视线附近，距离注视点较近的表面点与距离较远的表面点在相反方向上产生差异注视点。</p>
<h3 id="Motion-Cues-运动信息"><a href="#Motion-Cues-运动信息" class="headerlink" title="Motion Cues 运动信息"></a>Motion Cues 运动信息</h3><p><strong>眼睛和可见表面之间的相对运动将在视网膜上这些表面的图像上产生变化。眼睛和表面点之间的三维相对运动产生表面点在视网膜上投影的二维运动。这种视网膜运动被称为视流。光流是几种深度线索的基础。此外，光流还可用于确定一个人在世界中如何移动以及是否即将发生碰撞的信息(章节20.4.3)。</strong></p>
<p><strong>如果一个人移动到一边，同时继续注视某些表面点，那么光流提供了类似于立体视差的深度信息。这被称为运动视差。对于其他投影到注视点附近视网膜位置的表面点，零光流表示与注视点等效的深度;流向相反方向时，头部平移表示近点，相当于交叉视差;与头部平移方向相同的流动表示更远的点，相当于没有交叉的视差(下图)。运动视差是相对深度的有力线索。原则上，如果视觉系统能够获得头部运动速度的信息，运动视差可以提供绝对深度信息。在实践中，运动视差充其量只是绝对深度的微弱线索。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021212653.png" class="" title="image-20211021212653">

<p>(a)注视延伸的地平面时向右移动所产生的运动视差。(b)同样的运动，眼球追踪注视点。</p>
<p><strong>除了由于运动视差而产生的以自我为中心的深度信息，视觉运动还可以提供相对于观察者移动的物体的三维形状信息。在知觉文献中，这被称为动力深度效应。在计算机视觉中，它被称为来自-的结构运动。动力学深度效应假定物体运动的一个分量是深度旋转，这意味着有一个围绕垂直于视线的轴旋转的分量。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021212747.png" class="" title="image-20211021212747">

<p>光流信号表面边界的不连续。在许多情况下，深度变化的符号(即顺序深度)。</p>
<p><strong>光流还可以提供关于表面边界形状和位置的信息，如上图所示。光流中的空间不连续几乎总是与深度不连续相对应或由独立的运动物体引起。光流的大小的简单比较不足以确定深度变化的标志，除非在特殊情况下，观察者移动通过一个静态的世界。然而，即使存在独立移动的物体，跨表面边界深度变化的标志通常可以通过其他方法确定。运动经常改变在表面边界可见的较远表面的部分。表面纹理的出现(增加)或消失(删除)是因为较近的、闭塞的表面逐渐显露或覆盖较远的、闭塞的表面的部分。比较表面纹理到边界任意一侧的运动也可以用来推断顺序深度，即使在没有增加或删除纹理的情况下。光流中的不连续和表面纹理的增加/删除被称为动态遮挡信息，是关于环境空间结构的另一个强大的视觉信息来源。</strong></p>
<p><strong>观察者相对于世界上各点的移动速度不能仅从视觉运动来确定(见第20.4.3节)。尽管有这样的限制，我们还是可以利用视觉信息来确定到达一个可见点所需要的时间，即使在速度无法确定的情况下。当速度恒定时，接触时间(通常被称为碰撞时间)是由观察者所移动的物体的视网膜大小除以图像大小增加的速率得出的。在生物视觉文献中，这是通常称为τ函数(Lee &amp; Reddish, 1981)。如果距离信息在世界上的结构上的碰撞时间估计是可用的，那么这可以用来确定速度。</strong></p>
<h3 id="Pictorial-Cues-图像信息"><a href="#Pictorial-Cues-图像信息" class="headerlink" title="Pictorial Cues 图像信息"></a>Pictorial Cues 图像信息</h3><p><strong>即使在没有双目立体视觉或运动的情况下，一幅图像也可以包含关于它产生的世界的空间结构的许多信息。作为证据，请注意，即使我们闭上一只眼睛，保持头部静止，环境中没有任何东西移动，世界仍然是三维的。(如第20.5节所述，对于照片和其他显示的图像，情况会更加复杂。)这种图像深度线索有三类。其中最著名的是线性透视法。即使在没有透视的情况下，也有一些咬合信息提供了关于顺序深度的信息。最后，包括阴影、阴影和相互反射的照明线索，以及空中透视也提供了关于空间布局的视觉信息。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214205.png" class="" title="image-20211021214205">

<p>经典的线性透视效果包括按距离缩放的物体大小、平行线的收敛、地平面延伸到可见的视界，以及地平面相对于视界的位置。图片由Sam Pullara提供。</p>
<p><strong>线性透视一词通常是指属性涉及对象的图像大小的图像缩放距离,平行线的收敛,地平面扩展到可见的地平线,和距离之间的关系对象在地面上飞机,这些对象的图像位置相对于地平线(上图)。更正式地说，线性透视线索是那些利用透视投影的视觉线索，世界上的点被投影到的图像位置是按比例缩放的 1/z ，其中z为从投影点到环境中某一点的距离。这种关系的直接后果是,点预计将越来越远的点接近图像的中心(平行线的收敛),世界上的图像点之间的间距减少更遥远世界点(对象大小缩放图像的距离)。世界上无限平面的象止于有限的视界，这一事实可以通过考察透视投影方程z→∞来解释。</strong></p>
<p><strong>除了第20.4.2节中描述的与尺寸相关的影响外，大多数涉及线性透视的图像深度线索依赖于与地平面接触的感兴趣的物体。实际上，这些线索估计的不是到物体的距离，而是到地平面上接触点的距离。假设观察者和目标都在一个水平地面上，那么在视图中较低的地平面位置将接近。下图定量地说明了这种影响。对于地面上的视点h以及视界和地面上一个感兴趣点之间的倾斜角θ，所讨论的点与观测者所站点的距离为d = h cot θ。赤纬角提供了任意固定视点的相对深度信息，并可以提供绝对深度，当缩放眼高(h)是可能的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214347.png" class="" title="image-20211021214347">

<p>到地平面上位置的绝对距离可以根据从地平线到眼高的赤纬角来确定。</p>
<p><strong>虽然人类的视觉系统几乎可以肯定地利用赤纬角作为深度线索，但用来获取所需信息的确切机制尚不清楚。角度θ可以相对于重力或可见视界得到。有证据表明，这两种方法都用于人类视觉。眼高可以根据姿势来判断，可以通过看脚下的地面来判断，也可以通过经验来判断，假设是恒定的。虽然许多研究人员已经调查了这个问题，但这些值是否以及如何确定尚不确定。</strong></p>
<p><strong>阴影提供了关于三维空间布局的各种类型的信息。附加的阴影表明一个物体与另一个表面相接触，通常包括地平面。分离的阴影表明物体接近某个表面，但不与该表面接触。阴影可以作为间接的深度线索，使物体出现在地平面上阴影位置的深度(Yonas, Goldsmith， &amp; Hallstrom, 1978)。当利用这个信息时，视觉系统似乎假设光是从上面直接来的(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214505.png" class="" title="image-20211021214505">

<p>通过将物体的深度与地平面上的位置联系起来，阴影可以间接地作为深度线索(Kersten, Mamassian, and Knill(1997))。</p>
<p><strong>视觉提供了关于表面方向和距离的信息。用倾斜(定义为表面法线在图像中的投影方向)和倾斜(定义为表面法线与视线之间的角度)来表示直观确定的表面方向是很方便的。</strong></p>
<p><strong>可见的表面地平线可以用来找到相对于观察者的(有效的无限)表面的方向。确定倾斜是很简单的，因为表面的倾斜是可见地平线的方向。斜度也可以恢复，因为从视点到地平线的视线定义了一个平行于表面的平面。在许多情况下，要么地表视界是不可见的，要么地表足够小，其远边缘不符合实际的视界。在这种情况下，可见纹理仍然可以用来估计方向。</strong></p>
<p><strong>在感知的语境中，纹理是指视觉模式，由在表面上复制的子模式组成。子模式及其分布可以是固定的和有规则的，就像棋盘，或者在更统计学意义上是一致的，就像在草地的视图中。当一个纹理表面从一个斜角来看，纹理的投影视图相对于表面上的实际标记是扭曲的。两种截然不同的扭曲会发生(Knill, 1998)，都受到倾斜量的影响。纹理元素的位置和大小取决于上面描述的线性透视效果。这将产生一个纹理梯度(Gibson, 1950)，因为元素大小和间距都随着距离而减小(下图(a))。两者都是个体的形象纹理元素和元素分布在斜视图下被缩短(下图(b))。这就产生了倾斜方向上的压缩。例如，一个斜视圆显示为一个椭圆，其小轴与长轴的比值等于斜度的余弦。请注意，透视本身并不是线性透视的结果，尽管在实践中线性透视和透视都提供了关于倾斜的信息</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214602.png" class="" title="image-20211021214602">

<p>纹理线索的倾斜。(a)近地表显示压缩和结构梯度;(b)远表面仅显示压缩;(c)近地表表面的变异性，具有规则的几何变异性。</p>
<p><strong>对于纹理梯度作为表面倾斜的线索，纹理元素的平均大小和间距必须在纹理表面上保持恒定。如果图像中大小和间距的空间变异性并不完全是由于投影过程，那么试图反转投影效果将产生关于表面方向的错误推断。同样地，如果纹理元素的形状不是各向同性的，则透视缩短提示失效，因为不对称纹理元素图像形状将出现在与斜视无关的情况下。为了使空间视觉线索有效，这些假设通常是必需的。这些假设在一定程度上是合理的，因为它们反映了世界普遍存在的特性。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214643.png" class="" title="image-20211021214643">

<p>从着色中恢复形状。(a)和(b)中的图像似乎有不同的3D形状，因为它们表面的亮度变化率不同。</p>
<p><strong>底纹也提供了关于表面形状的信息(上图)。表面上被观察点的亮度取决于表面反射率和表面相对于定向光源和观察点的方向。当一个物体的相对位置、观察方向和照明方向保持固定时，亮度在一个常量上变化反射面是物体表面方向变化的指示。从着色中恢复形状是指从观测到的亮度变化中恢复表面形状的过程。仅仅通过着色来恢复表面的实际方向几乎是不可能的，尽管着色经常可以与其他线索结合起来提供表面形状的有效指示。对于具有精细几何变化的表面，着色可以提供引人注目的三维外观，即使是在二维表面上渲染的图像(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214739.png" class="" title="image-20211021214739">

<p>着色可以产生强烈的三维形状感。在这幅图中，如果你用一只眼睛从几米远的地方观看图像，效果会更强烈。如果你把一张硬纸板放在人物的前面，在上面切出一个比图片稍小的洞(见第20.5节)，它就会变得更牢固。图片由Albert Yonas提供。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215010.png" class="" title="image-20211021215010">

<p>(a)连接提供了咬合和角的凹凸性的信息。(b)平面表面物体的常见结类型。</p>
<p><strong>有许多图像线索产生了关于深度的顺序信息，而没有直接指示实际距离。在线形图中，不同类型的连接提供了对3D几何图形的约束，从而可以生成绘图(上图)。许多这样的效果也会出现在更自然的图像中。在感知上最有效的连接线索是T连接，这是一个强有力的指标，表明与T柄相对的表面封闭了至少一个远处的表面。t型连接通常产生一种模态补全的感觉，在这种感觉中，一个表面被看到在一个更近的、封闭的表面后面继续(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215020.png" class="" title="image-20211021215020">

<p>T型连接导致左侧圆盘在矩形后面继续，而右侧圆盘在矩形前面继续，可见矩形在圆盘后面继续。</p>
<p><strong>大气效应引起的视觉变化可以提供深度信息，特别是在长距离的户外。列奥纳多·达·芬奇是第一个描述空中透视(也称为大气透视)，在这种透视中，散射降低了场景中远处部分的对比度，使它们看起来比近的部分更蓝(达·芬奇，1970)(见下图)。空中透视主要是一个相对深度线索，尽管有人推测它也可能影响绝对距离的感知。虽然很多人认为由于大气的影响，更远的物体看起来更模糊，但大气散射实际上很少造成模糊。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215137.png" class="" title="image-20211021215137">

<p>在空中透视中，大气效果降低了对比度，颜色向蓝色方向移动，提供了长距离的深度信息。</p>
<h2 id="Objects-Locations-and-Events-对象、位置和事件"><a href="#Objects-Locations-and-Events-对象、位置和事件" class="headerlink" title="Objects, Locations, and Events 对象、位置和事件"></a>Objects, Locations, and Events 对象、位置和事件</h2><p><strong>虽然目前的视觉科学家普遍认为，视觉的目的是提取有关物体、地点和事件的信息，但对于提取什么信息、如何提取信息或如何使用信息执行任务的关键特征，却几乎没有共识。关于物体识别的本质以及物体识别与知觉的其他方面之间潜在的相互作用存在着重大的争议。我们对位置的了解大多涉及到低层次的空间视觉，而不是与复杂物体之间的空间关系或所需的视觉过程相关的问题在复杂的环境中导航。当人们在这个世界上移动时，我们对他们如何感知自己的速度和方向有相当的了解，但对实际事件感知的了解有限。视觉注意涉及到对物体、位置和事件的感知。虽然有很多关于视觉注意对于相对简单和控制良好的刺激的现象学数据，但我们对视觉注意如何服务于高层次的知觉目标所知甚少。</strong></p>
<h3 id="Object-Recognition-对象识别"><a href="#Object-Recognition-对象识别" class="headerlink" title="Object Recognition 对象识别"></a>Object Recognition 对象识别</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215431.png" class="" title="image-20211021215431">

<p>物体识别的复杂性。(a)我们能识别出类似车辆的物体，即使我们可能从未见过车辆的这种特殊视图。(b)快速查看图像难以识别。如果书是倒过来的，就更容易认出来了。</p>
<p><strong>物体识别包括将图像分割成与不同物理实体相对应的组成部分，并确定这些实体的身份。上图说明了与此过程相关的一些复杂性。我们不难认出左边的图像是某种交通工具，尽管我们之前从未见过这种交通工具的特殊视图，我们中的大多数人也没有把交通工具和这个背景联系起来。在页面翻转之前，右边的图像不太容易识别，这表明人类物体识别的方向偏好。</strong></p>
<p><strong>物体识别被认为包括两个截然不同的步骤。第一步将视野组织成与物体和表面相对应的组。这些分组过程是非常强大的(见下图)，尽管很少或没有意识到生成的低层次图像特征分组效应。分组是基于图像中原始结构的接近性、亮度、颜色、形状和方向的相似性、共同运动和各种更复杂的关系的复杂交互作用。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215609.png" class="" title="image-20211021215609">

<p>图像根据一套复杂的相似性和组织标准被知觉地组织成组。(a)亮度相似导致四个水平分组。(b)邻近造成三种垂直分组。</p>
<p><strong>物体识别的第二步是将分组解释为已识别的物体。一项计算分析表明，识别一个物体有许多截然不同的方法。知觉数据还不清楚究竟哪一个是人类视觉中真正使用的。物体识别要求视觉系统对每一类物体都有可用的描述足以使每个阶级区别于所有其他阶级。物体识别理论的不同之处在于描述每一类的信息的性质，以及用于将这些描述与现实世界的观点相匹配的机制。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215717.png" class="" title="image-20211021215717">

<p>模板匹配。右侧图像中的亮点表示与左侧图像中的模板的最佳匹配位置。图片由国家档案和记录管理局提供。</p>
<p><strong>可能有三种一般类型的描述。模板用每个类中对象的原型视图来表示对象类。上图显示了一个简单的示例。结构描述根据对象视图中很容易检测到的每个类的独特特征，以及关于特征之间的几何关系的信息来表示对象类。结构描述可以用2D或3D表示。对于对象类型的2D模型，必须对对象的每个明显不同的潜在视图有单独的描述。对于3D模型，两种不同形式的匹配策略是可能的。第一种方法是，在分类之前，利用任何可用的空间线索确定被观察对象的三维结构，然后将这个视图的3D描述与已知对象的3D原型相匹配。另一种可能是某些机制允许确定视图中尚未标识的对象的方向。该方向信息用于旋转和投射潜在的3D描述，以允许描述和被观察对象的2D匹配。最后，描述对象类属性的最后一个选项涉及到不变特征，它根据更通用的几何属性来描述对象类，特别是那些可能对对象的不同视图不敏感的属性。</strong></p>
<h3 id="Size-and-Distance-尺寸和距离"><a href="#Size-and-Distance-尺寸和距离" class="headerlink" title="Size and Distance 尺寸和距离"></a>Size and Distance 尺寸和距离</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215938.png" class="" title="image-20211021215938">

<p>左:视角和熟悉的尺寸线索是一致的。右图:视角和熟悉的尺寸线索是不一致的。图片由Peter Shirley, Scott Kuhl和J. Dylan Lacewell提供。</p>
<p><strong>在缺乏关于深度的更明确信息的情况下，投射到视网膜较大区域的物体被认为比投射到视网膜较小区域的物体更近，这种效应称为相对大小。一个更有力的线索涉及熟悉的大小，它可以提供绝对距离的信息到已知尺寸的可识别物体。熟悉尺寸作为深度线索的强度可以在上图中看到，在上图中，它与地面平面、基于透视的深度线索相冲突。熟悉尺寸是尺寸-距离关系的一部分，它与物体的物理尺寸、投影到视网膜上的相同物体的光学尺寸以及物体到眼睛的距离有关(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220027.png" class="" title="image-20211021220027">

<p>尺寸-距离关系允许已知尺寸的物体之间的距离，根据物体所处的视角确定。同样，一个已知距离的物体的大小可以根据物体所处的视角来确定。</p>
<p><strong>当物体位于平坦地面上时，就可以获得额外的深度信息来源，特别是当地平线是可见的或可以从其他视角信息获得时。地面上接触点的倾斜角是一个相对深度提示，并提供了绝对的自我中心距离，当按眼睛高度缩放时，如上所示图20.27。视界比，即一个物体的总可视高度与出现在视界以下的那部分物体的可视范围相比较，可以用来确定物体的实际大小，即使距离物体的距离未知(下图)。地平线比之下的事实是，对于一个平坦的地面，地平线的视线与物体相交的位置正好是地面上一个眼睛的高度。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220133.png" class="" title="image-20211021220133">

<p>(a)地平比可以通过比较一个物体在地平以下的可见部分与该物体的垂直总可见范围来确定深度。(b)真实世界的例子。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220239.png" class="" title="image-20211021220239">

<p>(a)大小恒常性使得放置在离眼睛不同距离的手在现实世界中看起来几乎是一样的大小，尽管视网膜的大小相当不同。(b)当一只手被另一只手部分遮挡时，特别是当一只眼睛闭上时，这种效果较弱。图片由Peter Shirley和Pat Moulis提供。</p>
<p><strong>人类的视觉系统足以确定大多数被观察物体的绝对大小;我们对大小的感知受实际物理的支配CAL的大小，我们几乎没有意识到物体对应的视网膜大小。这类似于前面讨论过的亮度恒常性，因为我们的感知是由推断出的世界属性所主导的，而不是由视网膜上的光感受器实际感知到的低层次特征。Gregory(1997)描述了一个大小恒定的简单例子。将你的两只手放在你面前，一只手保持一臂的距离，另一只手保持一半的距离(上图(a))。你的两只手看起来几乎一样大，尽管视网膜的大小相差两倍。如果较近的手部分包括较远的手，尤其是当你闭上一只眼睛时(上图(b))，这种效果就弱得多。视觉系统也表现出形状的恒常性，其对几何结构的感知接近实际物体的几何形状，而不是考虑到由于透视造成的视网膜图像畸变(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220250.png" class="" title="image-20211021220250">

<p>形状不变——桌子看起来是矩形的，尽管它在图像中的形状是一个不规则的四边多边形。</p>
<h3 id="Events-事件"><a href="#Events-事件" class="headerlink" title="Events 事件"></a>Events 事件</h3><p><strong>事件感知的大多数方面超出了本章的范围，因为它们涉及复杂的非视觉认知过程。三种类型的事件感知主要是视觉的，然而，也与计算机图形清晰相关。视觉能够提供关于一个人如何在世界上运动的信息，世界上独立运动物体的存在，以及由于观察者的运动或由于物体向观察者移动而可能发生的碰撞。</strong></p>
<p><strong>视觉可以用来确定旋转和相对于环境的平移方向。最简单的例子是向垂直于视线的平面移动。假设有足够的表面纹理使光流恢复，流场将形成如下图(a)所示的对称图案。在视场中的位置，流场的扩展焦点将有相应的平移方向的视线。虽然光流可以用来直观地确定运动方向，但它并不包含足够的信息来确定速度。要理解这一点，请考虑这样一种情况:世界变得两倍大，观察者移动速度两倍快。由于距离增加一倍而导致的流量值的减小正好被速度增加一倍而导致的流量值的增加所补偿，从而形成了一个相同的流场。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220553.png" class="" title="image-20211021220553">

<p>(a)向平坦的纹理表面移动会产生一个膨胀的流场，膨胀的焦点表示与运动方向相对应的视线。(b)观察与视线垂直的平面时，绕垂直轴旋转产生的流场。(c)平行于平面纹理表面的平动所产生的流场。</p>
<p><strong>上图(b)显示了观察者(或者更准确地说，观察者的眼睛)围绕垂直轴旋转所产生的光流场。与平移运动不同的是，光流提供了足够的信息来确定旋转轴和(角速度)旋转轴。的在利用这是实际问题,纯旋转运动产生的流绕轴垂直于视线非常类似于流产生的纯翻译的方向垂直于视线和转动轴,很难在视觉上区分两种不同类型的运动(上图 (c))。下图显示了在更真实的环境中运动所产生的光流模式。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220609.png" class="" title="image-20211021220609">

<p>光流通过一个静态环境产生，提供了相对于环境的运动和到环境中点的距离的信息。在这种情况下，视野的方向从视界被压低，但正如膨胀的焦点所表明的，运动是平行于地平面的。</p>
<p><strong>如果观察者是完全静止的，那么对移动物体的视觉检测就很容易，因为这些物体将与视场中唯一的非零光流相关联。当观察者移动时，情况要复杂得多，因为视野将被非零流支配，大部分或全部这是由于观察者和静态环境之间的相对运动(Thompson &amp; Pong, 1990)。在这种情况下，视觉系统必须对光流场的模式敏感，这种模式与观察者相对于静态环境的运动相关联的流场不一致(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220707.png" class="" title="image-20211021220707">

<p>移动物体的视觉检测一个移动的观察点需要识别光流中的模式，这些模式不能与通过静态环境的运动相关联。</p>
<p><strong>第20.3.4节描述了如何使用视觉来确定与环境中的某一点接触的时间，即使在运动速度未知的情况下。假设观察者沿直线匀速运动，并且世界上没有独立运动的物体，那么在τ关系指示的时间内，在与膨胀焦点相对应的视线方向上的任何表面都会产生接触。一个独立运动的物体使确定是否会发生碰撞的问题变得复杂。水手们使用一种方法来检测潜在的碰撞，这种方法也可以应用于人类的视觉系统:对于非加速直线运动，碰撞将发生在视觉上膨胀的物体上，但在以自我为中心的参照系中，视觉上保持静止。</strong></p>
<p><strong>这里有一种更复杂的事件感知形式值得讨论，因为它在交互式计算机图形学中非常重要。人们对与人体动作相对应的动作特别敏感。当唯一可见的特征是步行者关节上的灯光时，运动就可以被识别出来(Johansson, 1973)。这种移动的灯光显示通常甚至足以识别诸如步行者的性别和负重等属性。在计算机图形渲染中，观众会注意到动画角色哪怕是很小的错误，特别是当他们试图模仿人类动作时。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220932.png" class="" title="image-20211021220932">

<p>在(a)和(b)中，视觉注意力很快被吸引到不同形状或颜色的项目上。在(c)中，为了找到形状和颜色都不同的一项，顺序搜索似乎是必要的。</p>
<p><strong>“视觉注意力”一词涵盖了一系列现象，从我们的眼睛指向的地方，到涉及我们在复杂场景中注意到什么以及我们如何解释我们注意到的东西的认知效果(Pashler, 1998)。上图提供了一个注意过程如何影响视觉的例子，即使是非常简单的图像。在左边两个面板，其中一个图案的形状或颜色不同于其他立即“弹出”，很容易被注意到。在右边的面板中，一个在形状和颜色上都不同的图案是很难找到的。这样做的原因是，视觉系统可以对不同属性的项目进行并行搜索，但在寻找两个不同特征同时出现的项目时，需要更多的认知和顺序搜索。基于图形的人机界面应该(但往往不是!)在设计时理解如何利用人的视觉注意过程，以便快速有效地传达重要信息。</strong></p>
<h2 id="Picture-Perception-图像感知"><a href="#Picture-Perception-图像感知" class="headerlink" title="Picture Perception 图像感知"></a>Picture Perception 图像感知</h2><p><strong>到目前为止，本章已经讨论了当世界被人眼直接成像时发生的视觉知觉。当然，当我们看到计算机图形的结果时，我们看到的是经过渲染的图像，而不是真实的世界。这有重要的知觉暗示。原则上，至少在没有物体或观察者运动的情况下，单目观看时，应该可以生成与现实世界难以区分的计算机图形。想象一下透过玻璃窗看外面的世界。现在，考虑给窗户上的每个点上色，使其与最初看到的世界的颜色完全匹配。通过这种操作，到达眼睛的光线是不变的，这意味着无论是观看彩绘玻璃还是通过窗户观看真实世界，感知应该是相同的。计算机图形学的目标可以被认为是产生彩色的窗口，而实际上没有等效的现实世界的视图。</strong></p>
<p><strong>计算机图形学和其他视觉艺术的问题是，我们实际上不能通过给平面上色来匹配真实世界的观点。现实世界中的亮度和动态范围是不可能使用任何当前的显示技术来重现的。渲染图像的分辨率通常也低于人类视觉所能感知的最精细的细节。明度和颜色恒常性在照片不太明显比在现实世界中,可能是因为视觉系统试图弥补可变性的亮度和颜色根据环境照度照明在观看环境中,而不是与渲染后的图像相关的照明。这就是为什么在照片中颜色的真实外观取决于胶片的颜色平衡，以适应拍摄时光源的性质视频中的真实色彩需要白平衡步骤。虽然我们对分辨率、亮度和动态范围的限制如何影响简单模式的可检测性已经了解很多，但对于这些显示特性如何影响空间视觉或物体识别却几乎一无所知。</strong></p>
<p><strong>我们对这个问题的其他方面有了更好的理解，心理学家称之为图像空间的知觉(S. Rogers, 1995)。观看图像和观看真实世界之间的一个区别是，适应能力、双目立体视觉、运动视差，或许还有其他深度线索，可能表明所观察的表面与它所代表的世界距离有很大的不同。在这种情况下看到的深度往往介于图像中的图像线索所表示的深度和到图像本身的距离之间。当看一张照片或电脑显示器时，这通常会导致比预期的规模更小的感觉。另一方面，在大屏幕电影院看电影比在电视上看同样的电影产生更引人注目的空间感，即使距离电视的距离是这样的，视角是相同的，因为电影屏幕更远。</strong></p>
<p><strong>使用透视投影渲染的计算机图形具有一个视点(指定为模型空间中的位置和方向)和一个视图截锥(指定水平和垂直视场以及视图变换的其他几个方面)。如果没有从正确的位置查看渲染的图像，那么图像边缘的视角将与创建图像时使用的截锥不匹配。图像中的所有视角也将被扭曲，导致基于线性透视的所有图像深度和方向线索的扭曲。在实际操作中，当观察者被放置在离照片或显示表面太近或太远的地方时，这种效果经常发生。如果观察者离得太近，深度的透视线索将被压缩，而表面倾斜的线索将表明表面比实际情况更接近于垂直于视线。如果观看者离照片或屏幕太远，情况就会相反。如果视线不穿过观察区域的中心，情况就会更加复杂，因为在各种各样的观察情况下通常都会出现这种情况。</strong></p>
<p><strong>人类的视觉系统能够部分补偿由于在错误的位置观看图像而产生的透视失真，这就是为什么我们能够坐在电影院的不同座位上，体验到类似的描绘空间的感觉。当控制观察位置特别重要时，可以使用观察管。这些是适当大小的管，安装在一个相对于显示器的固定位置，并通过观看者看到显示器。观察管将观察点限制在(希望)矩形的位置。观看管也非常有效地减少了图像中的图像线索和实际显示表面之间的深度信息冲突。他们消除了立体声和运动视差，如果存在，将对应于显示表面，而不是渲染的视图。如果它们的直径足够小，它们还会隐藏画框或显示设备的边缘，从而减少显示表面位置的其他线索。奇异的视觉沉浸式显示设备，如头戴式显示器(HMDs)，在试图隐藏显示表面位置的视觉线索，同时添加双目立体和运动视差，以符合所渲染的世界的几何形状。</strong></p>
<h1 id="21-Tone-Reproduction-色调再现"><a href="#21-Tone-Reproduction-色调再现" class="headerlink" title="21 Tone Reproduction 色调再现"></a>21 Tone Reproduction 色调再现</h1><p><strong>正如在第20章中讨论的，人类的视觉系统适应广泛的观看条件。在正常观察下，我们可以分辨出大约4至5对数单位的照明，即我们能看到细节的最亮和最暗区域的比例可能高达100,000:1。通过适应过程，我们可以适应更大范围的光照。我们称与人类视觉系统能力相匹配的图像为高动态范围。</strong></p>
<p><strong>视觉模拟通常产生具有高动态范围的图像(Ward Larson &amp; Shakespeare, 1998)。图像捕捉技术的最新发展允许多个曝光对齐并重新组合成一个单一的高动态范围图像(Debevec &amp; Malik, 1997)。多种曝光技术也可用于视频。此外，我们希望未来的硬件能够直接拍摄或拍摄高动态范围的场景。一般来说，我们可以把每个像素看作是由三个浮点数组成的三元组。</strong></p>
<p><strong>随着创建高动态范围图像变得越来越容易，显示此类数据的需求也在迅速增加。不幸的是，大多数当前的显示设备，显示器和打印机，只能显示大约2个日志单位的动态范围。我们认为这种器件具有较低的动态范围。今天存在的大多数图像都是用每个字节每个像素每个颜色的通道表示的，这个通道与当前的显示设备相匹配，而不是与它们所代表的场景相匹配。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110407.png" class="" title="image-20211023110407">

<p>在传统摄影中，场景的某些部分可能曝光不足或过度。为了形象化斯诺克球台，在左边的图像中，透过窗户的视野被烧光了。另一方面，如果这个场景的室外部分暴露得很好，斯诺克桌就会太暗。与下图相比，下图显示了使用色调复制算法准备显示的高动态范围图像。</p>
<p><strong>通常，低动态范围的图像无法在不丢失信息的情况下表示场景。一个常见的例子是一个室内房间和一个室外透过窗户可以看到门区。人们可以很容易地看到室内和室外部分的细节。传统的照片通常不能捕捉到全部的信息，摄影师必须选择是否室内或室外部分的场景正确曝光(见上图)。通过使用高动态范围成像和使用本章描述的技术(见下图)准备这些图像用于显示，可以避免这些决策。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110426.png" class="" title="image-20211023110426">

<p>一种高动态范围的图像，使用最近的色调复制操作符进行显示(Reinhard &amp; Devlin, 2005)。在这张图片中，室内部分和透过窗户的视野都被适当地暴露出来。</p>
<p><strong>有两种策略可用来显示高动态范围的图像。首先,我们可以开发一些显示设备可以直接适应高动态范围(Seetzen, Whitehead， &amp; Ward, 2003;Seetzen等人，2004)。其次，我们可以准备高动态范围的图像在低动态范围显示设备上显示(Upstill, 1985)。这是目前比较常用的方法，也是本章的主题。尽管我们预见到这么高动态范围显示设备将在(不久的)将来得到广泛的应用，对图像动态范围的压缩需求可能会减少，但不会消失。特别是，像这本书这样的印刷媒体，就其本质而言，是低动态范围的。</strong></p>
<p><strong>压缩图像的值范围以在低动态范围显示设备上显示为目的，称为音调映射或音调复制。一个简单的压缩函数是对图像进行归一化(见下图(左))。这构成了一个线性缩放，只有当图像的动态范围仅略高于显示设备的动态范围时才趋于充分。对于动态范围较大的图像，微小的强度差异将被量化为相同的显示值，从而导致可见细节丢失。在下图(中间)中，所有大于用户指定最大值的像素值都被设置为这个最大值(即它们被夹住了)。这使得归一化不那么依赖于噪声异常值，但是在这里我们丢失了图像中明亮区域的信息。为了比较，下图(右)是一个色调映射版本，在暗区和亮区都显示了细节。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110619.png" class="" title="image-20211023110619">

<p>线性缩放高动态范围图像以适应给定的显示设备可能会导致重要的细节丢失(左边和中间)。左边的图像是线性缩放的。在中间图像的高值被夹住。为了比较，右边的图像被映射了，使得明亮和黑暗区域的细节都可以看到。</p>
<p><strong>一般来说，线性缩放不适合于音色再现。色调复制的关键问题是压缩图像，同时保留图像的一个或多个属性。不同的色调再现算法关注不同的属性，如对比度、可见细节、亮度或外观。</strong></p>
<p><strong>理想情况下，在低动态范围显示设备上显示色调映射的图像将在观察者中产生与原始场景相同的视觉响应。由于显示设备的限制，这是无法实现的，尽管我们可以尽可能接近这个目标。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110831.png" class="" title="image-20211023110831">

<p>用于演示下图中色调再现目标的图像。</p>
<p><strong>作为示例，我们创建了如上图所示的高动态范围图像。然后这个图像被映射并显示在一个显示设备上。显示设备本身被放置在场景中，这样它就显示了自己的背景(下图)。在理想的情况下，显示应该是透明的。根据色调再现算子的质量以及所描述的场景的性质，这个目标可能或多或少是可以实现的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110848.png" class="" title="image-20211023110848">

<p>在对上图中的图像进行映射并将其显示在监视器上之后，监视器被放置在场景中大约拍摄图像的位置。根据音调再现运算符的质量，结果应该看起来就像监视器是透明的。</p>
<h2 id="Classification-分类"><a href="#Classification-分类" class="headerlink" title="Classification 分类"></a>Classification 分类</h2><p><strong>虽然可以根据色调再现操作符的目标属性来分类，或者根据它们的任务来分类，但是我们根据它们的一般技术来分类算法。这将使我们能够显示大量不同操作符之间的差异和相似之处，因此，希望有助于为给定的音调复制任务选择有意义的特定操作符。</strong></p>
<p><strong>我们所遵循的主要分类方案是基于音调再现运算符是基于从各个学科获得的见解的认识。特别是，一些操作是基于人类视觉感知的知识。</strong></p>
<p><strong>人类的视觉系统利用位于视网膜上的光感受器来探测光线。光被转换成电信号，在视网膜中进行部分处理，然后传送到大脑。除了视网膜的前几层细胞外，由探测到的光产生的信号是用脉冲序列传输的。携带信息的量是这些电脉冲发生的频率。</strong></p>
<p><strong>人类视觉系统能探测到的光的范围远远大于人类大脑用来传输信息的频率范围。因此，人类视觉系统毫不费力地解决了音调再现问题——大范围的亮度转换为小范围的脉冲序列频率。因此，模仿人类视觉系统的相关方面是一种有价值的色调再现方法;这种方法将在第21.7节中进行更详细的解释。</strong></p>
<p><strong>第二类运算符是基于物理的。光在被光感受器吸收之前与表面和体积相互作用。在计算机图形学中，光的相互作用通常由绘制方程来建模。对于纯粹的漫反射表面，这个方程可以简化为入射到一个表面上的光(照度)和这个表面反射光的能力(反射率)之间的乘积(Oppenheim, Schafer， &amp; Stockham, 1968)。</strong></p>
<p><strong>由于反射是表面的一种被动特性，对于漫反射表面，根据定义，它是低动态范围——通常在0.005到1之间(Stockham, 1972)。一个表面的反射率不能大于1，因为这样它就会反射比入射更多的光。另一方面，照度可以产生任意大的值，并且只受光源的强度和接近程度的限制。</strong></p>
<p><strong>因此，图像的动态范围主要由照度分量控制。面对漫反射场景，一个可行的色调复制方法可能是分离反射和照度，压缩照度成分，然后重新组合图像。</strong></p>
<p><strong>然而，假设场景中的所有表面都是漫反射的，这通常是不正确的。许多高动态范围的图像描绘了高光和/或直接可见光源(图21.3)。镜面反射的亮度几乎和它反射的光源一样高。</strong></p>
<p><strong>目前使用的各种色调再现操作符将图像分割为高动态范围基片层和低动态范围细节层。如果所描绘的场景是完全漫反射的，这些层将代表照明和反射。对于包含直接可见光源或镜面高光的场景，分离到基础层和细节层仍然允许有效的色调再现操作符的设计，尽管对单独的层没有直接的意义。这些运算符将在第21.5节中讨论。</strong></p>
<h2 id="Dynamic-Range-动态范围-1"><a href="#Dynamic-Range-动态范围-1" class="headerlink" title="Dynamic Range 动态范围"></a>Dynamic Range 动态范围</h2><p><strong>传统的图像存储为每一个像素一个字节的红、绿、蓝分量。这种编码提供的动态范围取决于最小和最大可表示值之间的比率，以及连续值之间的步长。因此，对于低动态范围的图像，每个颜色通道只有256个不同的值。</strong></p>
<p><strong>高动态范围图像编码的可能值显著更大的集合;可表示值的最大值可能要大得多，而连续值之间的步长可能要小得多。文件大小高动态因此，范围图像通常也更大，尽管至少有一个标准(OpenEXR高动态范围文件格式(Kainz, Bogart， &amp; Hess, 2003))包括一个非常强大的压缩方案。</strong></p>
<p><strong>限制文件大小的另一种方法是对高动态数据应用色调复制操作符。然后可以将结果编码为JPEG格式。此外，输入图像可以按像素划分为色调映射图像。这种划分的结果可以被下采样，并作为少量数据存储在同一JPEG图像的头部(G. Ward &amp; Simmons, 2004)。这种子带编码图像的文件大小与传统JPEG编码图像相同。显示程序可以直接显示JPEG图像，也可以通过将色调映射的图像与头部存储的数据相乘来重建高动态范围的图像。</strong></p>
<p><strong>一般来说，最小步长和最小和最大可表示值的比值的组合决定了图像编码方案提供的动态范围。对于计算机生成的图像，图像通常在写入文件或显示在屏幕上之前存储为浮点值的三组，尽管可能有更有效的编码方案(Reinhard, Ward, Debevec， &amp; Pattanaik, 2005)。由于大多数显示设备仍然配备8位D/A转换器，我们可以将音调再现看作是浮点数到字节的映射，这样结果就可以在低动态范围显示设备上显示。</strong></p>
<p><strong>单个图像的动态范围通常较小，由场景中发现的最小和最大亮度决定。因此，一种简单的测量图像动态范围的方法可以计算图像的最大像素值和最小像素值之间的比率。忽略一小部分最暗和最亮的像素，可能会降低对异常值的敏感度。</strong></p>
<p><strong>或者，同样的比率可以表示为对数域中的差。这种方法对异常值不太敏感。本页页边空白处显示的图像是具有不同动态范围的图像示例。注意，在这种情况下，夜景的动态范围并不比白天场景小。虽然夜景中所有的值都变小了，但是最大值和最小值之间的比例却不一样。</strong></p>
<p><strong>然而，记录设备或渲染算法可能会引入噪声，从而降低有用的动态范围。因此，对图像动态范围的测量应该考虑噪声因素。因此，在信号处理中使用的信噪比(以分贝表示)是衡量动态范围的更好方法。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111213.png" class="" title="image-20211023111213">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111227.png" class="" title="image-20211023111227">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111243.png" class="" title="image-20211023111243">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111257.png" class="" title="image-20211023111257">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111309.png" class="" title="image-20211023111309">

<p>从上到下动态范围依次为2.65，3.96，4.22，5.01，6.56 log₂ 单位。</p>
<h2 id="Color-颜色-1"><a href="#Color-颜色-1" class="headerlink" title="Color 颜色"></a>Color 颜色</h2><p><strong>色调复制操作员通常压缩亮度值，而不是直接在彩色图像的红、绿、蓝组件上工作。这些亮度值被压缩为显示值Ld(x, y)之后，通过保持彩色通道之间的比率与压缩前相同(使用s = 1)，可以重建彩色图像(Schlick, 1994b):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111747.png" class="" title="image-20211023111747">

<p><strong>结果经常出现过度饱和，因为人类的颜色感知是非线性的整体亮度水平。这意味着，如果我们在昏暗的环境中通过显示器观看明亮的室外场景，我们的眼睛会适应昏暗的环境，而不是室外照明。通过保持色比不变，我们不考虑这个影响。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111828.png" class="" title="image-20211023111828">

<p>每通道的伽玛校正可能降低图像的饱和度。左边图像的饱和度为s = 0.5。右侧图像未去饱和度(s = 1)。</p>
<p><strong>另外，饱和常数s也可以选择小于1。这种每通道的伽马校正可以将结果降低到一个适当的水平，如上图所示(Fattal, Lischinski， &amp; Werman, 2002)。一个更全面的解决方案是将颜色外观建模领域的想法纳入色调复制操作(Pattanaik, Ferwerda, Fairchild， &amp; Greenberg, 1998;Fairchild &amp; Johnson, 2004;Reinhard &amp; Devlin, 2005)。</strong></p>
<p><strong>最后，如果已经有具有代表性配色方案的示例图像，则可以将该配色方案应用于新图像。这种图像之间的颜色映射可以用于微妙的颜色校正，如饱和度调整或更有创意的颜色映射。映射通过将源和目标图像转换到一个不相关的颜色空间进行。在这样的颜色空间中，每个颜色通道中的像素值可以独立处理，而不会引入太多的伪像(Reinhard, Ashikhmin, Gooch， &amp; Shirley, 2001)。</strong></p>
<p><strong>在非相关颜色空间中将颜色从一幅图像映射到另一幅图像很简单:分别计算源图像和目标图像中三个颜色通道中所有像素的平均值和标准差。然后,移动和缩放目标图像，以便每个颜色通道的目标图像的均值和标准差与源图像相同。然后，通过将非相关的颜色空间转换为RGB并将负像素固定为零，得到得到的图像。应用该算法后，图像的动态范围可能会发生变化。因此建议动态范围图像，然后应用传统的色调再现算法。一个合适的非相关颜色空间是19.2.4节中的对手空间。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111939.png" class="" title="image-20211023111939">

<p>用于演示的图像色彩转移技术。下图和21.31显示了应用该算法的结果。</p>
<p><strong>对上图中的图像应用这种颜色变换的结果如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111951.png" class="" title="image-20211023111951">

<p>左边的图像用于调整上图中图像的颜色。结果显示在右边。</p>
<h2 id="Image-Formation-图像形成"><a href="#Image-Formation-图像形成" class="headerlink" title="Image Formation 图像形成"></a>Image Formation 图像形成</h2><p><strong>现在，我们假设光被表面漫反射的结果形成了图像。在本章的后面，我们放宽了这个限制，直接描绘光源和高光。亮度Lv 每个像素的近似值为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023112151.png" class="" title="image-20211023112151">

<p><strong>其中，r为曲面的反射率，Ev 为曲面的反射率表示照度。下标v表示我们用的是光度加权的量。或者，我们可以在对数域中写出这个表达式(Oppenheim et al.， 1968):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023112201.png" class="" title="image-20211023112201">

<p><strong>照相透明度是通过改变材料的密度来记录图像的。在传统摄影中，这种变化与亮度成对数关系。因此，与摄影中的常见做法类似，我们将使用术语密度表示(D)来表示对数亮度。当在对数域中表示时，反射率和照度是相加的。这有助于分离这两个组成部分，尽管事实上分离反射率或照度是一个不足约束的问题。在实践中，分离只在一定程度上是可能的，并取决于图像的组成。然而，色调再现可以基于图像形成的这两个组成部分的分离，如下两部分所示。</strong></p>
<h2 id="Frequency-Based-Operators-基于频率的算子"><a href="#Frequency-Based-Operators-基于频率的算子" class="headerlink" title="Frequency-Based Operators 基于频率的算子"></a>Frequency-Based Operators 基于频率的算子</h2><p><strong>对于典型的漫反射场景，由于纹理表面以及表面边缘的存在，反射分量往往表现出高空间频率。另一方面，照度在空间上是一个缓慢变化的函数。</strong></p>
<p><strong>由于反射率是低动态范围，照度是高动态范围，我们可以尝试将这两个分量分开。反射率和照度的频率依赖性提供了一个解决方案。例如，我们可以计算图像的傅里叶变换，只衰减低频。这压缩了照度分量，而保留了反射分量基本不受影响——我们所知的第一个数字音色再现操作员采用了这种方法(Oppenheim et al.， 1968)。</strong></p>
<p><strong>最近，其他算子也遵循了这一思路。特别地，双边和三边滤波器被用来将图像分割为基础和细节层(Durand &amp; Dorsey, 2002;Choudhury &amp; Tumblin, 2003)。这两个滤波器都是边缘保持平滑算子，可用于各种不同的方式。将边缘保持平滑算子应用到密度图像会得到模糊图像，其中锐利的边缘仍然存在(下图(左))。我们可以把这样一个图像看作一个基础层。如果我们将高动态范围图像按像素划分为基础层，我们得到一个包含所有高频细节的细节层(下图(右))。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023121555.png" class="" title="image-20211023121555">

<p>双边滤波消除了小细节，但保留了尖锐的梯度(左)。相关的细节层显示在右边。</p>
<p><strong>对于漫反射场景，基础和细节层类似于照度和反射率的表示。对于描绘高光和光源的图像，这种类比是站不住脚的。然而，无论图像的内容如何，将图像分离为基础层和细节层都是可能的。在重新组合为压缩密度图像之前，通过压缩基础层，可以创建低动态范围密度图像(下图)。取幂后，得到一个可显示的图像。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023121614.png" class="" title="image-20211023121614">

<p>一种使用双边滤波进行映射的图像。如上上图所示的基础层和细节层在压缩基础层后被重新组合。</p>
<p><strong>边缘保持平滑算子也可用来计算每个像素的局部自适应水平可用于空间变化或局部色调再现算子。我们在第21.7节中描述了双边和三边过滤器的使用。</strong></p>
<h2 id="Gradient-Domain-Operators-梯度域算子"><a href="#Gradient-Domain-Operators-梯度域算子" class="headerlink" title="Gradient-Domain Operators 梯度域算子"></a>Gradient-Domain Operators 梯度域算子</h2><p><strong>上一节对基于频率的算子所作的论证也适用于梯度场。假设没有直接可见的光源，在梯度场中反射分量将是一个具有尖峰的常数函数。类似地，照明组件将导致小梯度到处。</strong></p>
<p><strong>在典型场景中，人类通常能够区分光照和反射。扣除光源后对表面反射率的感知称为亮度。为了评估只描绘漫反射表面的图像的亮度，B. K. P. Horn是第一个使用梯度场分离反射和照度的人(Horn, 1974)。他使用简单的阈值去除所有小的梯度，然后集成图像，这涉及使用全多重网格法求解泊松方程(Press, Teukolsky, Vetterling， &amp; Flannery, 1992)。</strong></p>
<p><strong>其结果类似于边缘保持平滑滤波器。这与预期相符，因为Oppenheim的基于频率的算子在相同的场景反射率和图像形成假设下工作。特别是，霍恩的作品直接针对“蒙德里安的迷你世界”，这是类似于荷兰著名画家皮埃·蒙德里安的抽象派绘画的漫射场景的简化版本。</strong></p>
<p><strong>Horn的作品不能直接用作色调再现算子，因为大多数高动态范围图像描述的是光源。然而，一个相对较小的变化将使这个工作成为一个合适的色调复制运算符。如果光源或镜面在图像中被描述，那么大的梯度将与光源和高光的边缘相关联。这使得图像具有较高的动态范围。下图显示了一个例子，其中斯诺克球上的高亮部分导致了明显的梯度。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122004.png" class="" title="image-20211023122004">

<p>左边的图像(使用梯度域压缩映射)显示了一个高亮的场景。这些高亮显示为右侧的大梯度，其中梯度的大小映射为灰度(黑色是0的梯度，白色是图像中的最大梯度)。</p>
<p><strong>因此，我们可以压缩高动态范围的图像通过衰减大梯度，而不是阈值梯度场。Fattal等人采用了这种方法，他们发现通过积分压缩梯度场可以成功地压缩高动态范围图像(下图)(Fattal等人，2002)。Fat- tal的梯度域压缩并不局限于扩散场景。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122101.png" class="" title="image-20211023122101">

<p>使用梯度域压缩映射的图像。</p>
<h2 id="Spatial-Operators-空间算子"><a href="#Spatial-Operators-空间算子" class="headerlink" title="Spatial Operators 空间算子"></a>Spatial Operators 空间算子</h2><p><strong>在下面的部分中，我们将讨论色调再现运算符，它直接对像素进行压缩而不向其他域进行转换。通常，全球和本地运营商是不同的。前一类中的色调再现算子根据每个像素相同的压缩函数来改变每个像素的亮度值。术语global源于这样一个事实:许多这样的函数需要被锚定到通过分析整个图像确定的一些值上。在实践中，大多数运算符使用几何平均L¯v 为了控制压缩:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122238.png" class="" title="image-20211023122238">

<p><strong>在上式中，引入了一个小的常数δ，以防止在黑色像素存在时平均值变为零。几何平均值通常被映射到一个预定义的显示值。将几何平均值映射到不同显示值的效果如下图所示。或者，有时使用最小或最大图像亮度。全局算符的设计面临的主要挑战在于压缩函数的选择。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122323.png" class="" title="image-20211023122323">

<p>将几何平均值映射到不同的显示值(左:0.12，右:0.38)后应用空间音调映射算子。</p>
<p><strong>另一方面，局部算子根据一个特定的压缩函数来压缩每个像素，这个压缩函数是由相邻像素的选择而不是整个图像的信息调制的。其基本原理是，明亮邻域中的亮像素可能与昏暗邻域中的亮像素被感知不同。本地运营商发展中的设计挑战包括选择压缩函数，每个像素的局部邻域的大小，以及使用局部像素值的方式。通常，本地操作符比全局操作符实现了更好的压缩(下图)，尽管计算成本更高。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122426.png" class="" title="image-20211023122426">

<p>每个图像的全局色调再现算子(左)和局部色调再现算子(右)(Reinhard, Stark, Shirley， &amp; Ferwerda, 2002)。本地操作符显示更多细节;例如，右边的金属徽章对比度更好，高光更清晰。</p>
<p><strong>无论是全球的还是本地的操作者都经常受到人类视觉系统的启发。大多数操作符使用两个不同的压缩函数之一，它与局部操作符和全局操作符的区别是正交的。显示值Ld(x, y)最常由图像亮度Lv(x, y)派生乘以以下两种形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122539.png" class="" title="image-20211023122539">

<p><strong>在这些方程中，f(x, y)可以是一个常数，也可以是每个像素变化的函数。在前一种情况下，我们有一个全局算子，而一个空间变化的函数f(x, y)得到一个局部算子。指数n通常是一个常数，对于特定的运算符是固定的。</strong></p>
<p><strong>上上公式用从完整图像或局部邻域得到的值除以每个像素的亮度。上方程在对数线性图上有一条S形曲线，因此称为S形曲线。这种功能形式与测量不同物种光感受器对闪光的电反应所获得的数据相吻合。在下面的小节中，我们将讨论这两种函数形式。</strong></p>
<h2 id="Division-分部"><a href="#Division-分部" class="headerlink" title="Division 分部"></a>Division 分部</h2><p><strong>每个像素可以除以一个常数，使高动态范围的图像在一个可显示范围内。这种划分实质上是线性缩放，如图21.3所示。虽然图21.3显示了特设线性标度，但这种方法可以通过使用心理物理数据来提炼(21.2)式中的标度常数f(x, y) = k (G. J. Ward, 1994;Ferwerda, Pattanaik, Shirley， &amp; Greenberg, 1996)。</strong></p>
<p><strong>另外，有几种方法可以计算空间变化的除数。在这些情况下，f(x, y)是图像的模糊版本，即 f(x, y) = Lv^blur (x, y)。模糊是通过将图像与高斯滤波器卷积来实现的(Chiu et al.， 1993;Rahman, Jobson， &amp; Woodell, 1996)。此外，通过模糊图像来计算f(x, y)可能与白点的偏移相结合，以达到彩色外观建模的目的(Fairchild &amp; Johnson, 2002;通用·约翰逊&amp;费尔柴尔德，2003年;Fairchild &amp; Johnson, 2004)。</strong></p>
<p><strong>高斯滤波器的大小和权重对结果的可显示图像有深刻的影响。高斯滤波器具有选择加权局部平均的效果。色调再现就是将每个像素除以其相关的加权局部平均值。如果过滤器内核的大小被选择得太小，那么光环工件就会出现(下图(左))。光晕是本地运算符的一个常见问题，当色调映射依赖于除法时尤其明显。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024155700.png" class="" title="image-20211024155700">

<p>图像被高斯模糊版本划分映射。左边图像的滤波核大小为64像素，右边图像的滤波核大小为512像素。对于基于分割的算法，通过选择大的滤波核来最小化光晕伪影。</p>
<p><strong>通常，在这种方法中，通过使滤波器内核变大(上图(右))，晕轮工件可以最小化。通过选择至少为图像四分之一的滤波器大小，可以获得合理的结果。有时甚至需要更大的过滤器内核来最小化人为因素。注意，在这个限制下，滤镜的大小会和图像本身一样大。在这种情况下，本地操作符变成了全局操作符，而通常由本地方法提供的额外压缩就会丢失。</strong></p>
<p><strong>在相同的空间位置上，每个像素被一个高斯模糊像素分割的函数形式需要在压缩量和伪像严重程度之间进行不理想的权衡。</strong></p>
<h2 id="Sigmoids-Sigmoids-函数"><a href="#Sigmoids-Sigmoids-函数" class="headerlink" title="Sigmoids Sigmoids 函数"></a>Sigmoids Sigmoids 函数</h2><p><strong>方程(21.3)采用了与简单除法不同的函数形式，因此，在压缩量、工件的存在和计算速度之间提供了不同的权衡。</strong></p>
<p><strong>Sigmoids有几个可取的性质。对于非常小的亮度值，映射是近似线性的，因此对比度保留在图像的黑暗区域。函数的渐近线是1，这意味着输出映射总是在0和1之间有界。</strong></p>
<p><strong>在式(21.3)中，函数f(x, y)可以作为全局常数计算，也可以作为空间变化函数计算。按照电生理学的惯例，我们把f(x, y)称为半饱和常数。它的值决定了输入图像中哪些值在色调映射后是最优可见的。特别地，如果我们假设指数n等于1，那么亮度值等于半饱和常数将被映射为0.5。选择不同半饱和常数的效果如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024160854.png" class="" title="image-20211024160854">

<p>半饱和常数的选择决定了输入值的映射方式显示值。</p>
<p><strong>函数f(x, y)可以用几种不同的方法计算(Reinhard et al.， 2005)。最简单的形式是，f(x, y)设为L¯v/k，从而将几何平均映射到用户参数k(下图)(Reinhard et al.， 2002)。在这种情况下，k的初始值是0.18，尽管对于特别明亮或黑暗的场景，这个值可能会升高或降低。它的价值可以从图像本身估计(Reinhard, 2003)。式(21.3)中的指数n可设为1。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161025.png" class="" title="image-20211024161025">

<p>一个线性缩放的图像(左)和一个使用s形压缩映射的图像(右)。</p>
<p><strong>在这种方法中，半饱和常数是几何平均的函数，因此算子是全局的。这个全局算子的一个变体通过线性插值来计算半饱和常数几何平均和每个像素的亮度:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161102.png" class="" title="image-20211024161102">

<p><strong>插值由用户参数a控制，该参数可以改变可显示图像的对比度(下图)(Reinhard &amp; Devlin, 2005)。对比度越大，在明暗区域的可见细节就越少，反之亦然。这种插值可以被看作是完全全局和完全局部运算符之间的中间地带，它在两个极端之间进行插值，而不需要使用昂贵的模糊运算。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161138.png" class="" title="image-20211024161138">

<p>线性插值改变了色调映射图像的对比度。参数a在左边的图像中设置为0.0，在右边的图像中设置为1.0。</p>
<p><strong>虽然操作符通常压缩亮度值，但这个特殊的操作符可以扩展到包括一种简单形式的色适应。因此，它提供了一个机会来调整通常与色调映射相关的饱和度水平，正如本章开始所讨论的。</strong></p>
<p><strong>不是只压缩亮度通道，而是对三个颜色通道中的每一个应用sigmoidal压缩:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161242.png" class="" title="image-20211024161242">

<p><strong>对f(x, y)的计算进行了改进，可以在几何平均亮度和像素亮度之间以及每个独立颜色通道和像素亮度值之间进行双线性插值。因此我们计算几何平均亮度值L¯v，以及红、绿、蓝通道的几何平均值(I¯r,I¯g,I¯b)．从这些值，我们分别为每个像素和每个颜色通道计算f(x, y)。我们给出这个方程为红色通道(fr(x, y)):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161416.png" class="" title="image-20211024161416">

<p><strong>插值参数a和之前一样控制对比度，新的插值参数c允许一种简单的颜色校正(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161502.png" class="" title="image-20211024161502">

<p>用于颜色校正的线性插值。参数c在左边的图像中设置为0.0，在右边的图像中设置为1.0。</p>
<p><strong>到目前为止，我们还没有讨论(21.3)式中指数n的值。电生理学研究报告了n = 0.2和n = 0.9之间的值(Hood, Finkelstein， &amp; Buckingham, 1979)。虽然指数可以由用户指定，但对于各种各样的图像，我们可以从几何平均亮度L¯v估计一个合理的值和图像中的最小和最大亮度(Lmin 和Lmax)，其经验公式如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161729.png" class="" title="image-20211024161729">

<p><strong>到目前为止所展示的几种s形压缩的变体本质上都是全局的。其优点是计算速度快，非常适用于中、高动态范围的图像。对于非常高的动态范围图像，可能需要求助于局部运算符，因为这可能会带来一些额外的压缩。一种扩展s形压缩的直接方法是用一个空间变化的函数代替全局半饱和常数，这个函数可以用几种不同的方法计算。</strong></p>
<p><strong>换句话说，函数f(x, y)到目前为止被假定为常数，但也可以作为一个空间局部平均值来计算。也许实现这一点最简单的方法是再次使用高斯模糊图像。每个像素的模糊图像代表局部平均值，可以将其视为半饱和常数的合适选择。</strong></p>
<p><strong>与前一节讨论的基于除法的操作符一样，我们必须考虑晕轮工件。然而，当图像被自身的高斯模糊版本所分割时，高斯滤波器核的大小需要很大，以最小化晕。如果sigmoids与空间变量半饱和常数一起使用，则高斯滤波器核需要变得很小，以最小化伪影。这是一个显著的改进，因为少量的高斯模糊可以直接在空间域有效地计算。换句话说，没有必要求助于昂贵的傅里叶变换。在实际应用中，只有几个像素宽的滤波核足以抑制明显的伪影，同时在被映射的图像中产生更多的局部对比度。</strong></p>
<p><strong>高斯模糊的一个潜在问题是，滤镜模糊了尖锐的对比度边缘，就像它模糊了小细节一样。在实践中，如果有在嘶鸣中是否有很大的反差梯度考虑的像素的邻域，这导致高斯模糊像素与像素本身有显著的不同。这就是晕的直接原因。通过在基于分割的方法中使用一个非常大的滤波核，这样大的对比度被平均出来。</strong></p>
<p><strong>在sigmoids压缩格式中，一个小的高斯滤波器最大限度地减少重叠的机会与强烈的反差梯度。在这种情况下，光晕仍然会出现，但它们的大小通常不被注意，反而被认为是增强对比。</strong></p>
<p><strong>另一种模糊图像的方法是，在尽量减少附近大对比度步骤的负面影响的同时，避免模糊这些边缘。一种简单但计算代价昂贵的方法是，计算一个具有不同核大小的高斯模糊图像堆栈。对于每个像素，我们可以选择最大的高斯函数，它不会与显著的梯度重叠。</strong></p>
<p><strong>在一个相对均匀的邻域中，高斯模糊像素的值应该是相同的，而不管滤波器核的大小。因此，用两种不同高斯滤波器过滤的像素之间的差值应该近似为零。只有当更宽的过滤器内核重叠时，这种差异才会发生显著变化与邻域包含一个强烈的对比步长，而较小的滤波器核没有。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161855.png" class="" title="image-20211024161855">

<p>用于演示下图所示的比例选择机制的示例图像。</p>
<p><strong>因此，通过检查不同核大小下高斯函数的差异，可以找到一个像素周围不包含尖锐边缘的最大邻域。对于上图所示的图像，每个像素选择的比例如下图(左)所示。这种尺度选择机制被摄影色调复制算子(Reinhard et al.， 2002)以及Ashikhmin的算子(Ashikhmin, 2002)所采用。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161906.png" class="" title="image-20211024161906">

<p>比例选择机制:左图为上图所示图像中每个像素所选择的比例;像素越深，刻度越小。总共使用了8种不同的尺度来计算这幅图像。右图显示的是基于邻域选择机制计算出的每个像素的局部平均值。</p>
<p><strong>一旦已知每个像素的合适邻域，高斯模糊平均Lblur 对于这个邻域(如上图右侧所示)，可以用来控制半饱和常数，例如摄影色调复制操作符所使用的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024162022.png" class="" title="image-20211024162022">

<p><strong>另一种可能更好的方法是使用边缘保持平滑算子，这种算子是专门设计用来去除小细节，同时保持鲜明的对比。一些这样的滤波器，如双边滤波器(下图)，三边滤波器，苏珊滤波器，LCIS算法和均值移位算法是合适的，尽管其中一些是昂贵的计算(Durand &amp; Dorsey, 2002;Choudhury &amp; Tumblin, 2003;Pattanaik &amp; Yee, 2002;Tumblin &amp; Turk, 1999;Comaniciu &amp; Meer, 2002)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024162100.png" class="" title="image-20211024162100">

<p>sigmoidal压缩(左)和使用双边滤波计算半饱和常数的s形压缩(右)。注意右图中天空对比度的改善。</p>
<h2 id="Other-Approaches-其他方法"><a href="#Other-Approaches-其他方法" class="headerlink" title="Other Approaches 其他方法"></a>Other Approaches 其他方法</h2><p><strong>虽然前面几节一起讨论了迄今为止的大多数色调再现操作符，但仍有一两个操作符不能直接适用于上述类型血淋淋的。其中最简单的一种是对数压缩的变体，另一种是基于直方图的方法。</strong></p>
<p><strong>动态范围缩小可以通过取对数来实现，只要这个数字大于1。任何正数都可以用下面的方程在0和1之间进行非线性缩放:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184342.png" class="" title="image-20211024184342">

<p><strong>虽然上面的对数以b为底没有指定，但任何选择的底都可以。选择对数底数的自由可以用来根据输入亮度改变底数，从而实现与被压缩图像更好匹配的运算符(Drago, Myszkowski, Annen， &amp; Chiba, 2003)。该方法采用Perlin和Hoffert的偏置函数，取用户参数p (Perlin &amp; Hoffert, 1989):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184430.png" class="" title="image-20211024184430">

<p><strong>使基数b依赖于亮度，并在2和10之间平滑地插值基数，可以细化上面的对数映射:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184507.png" class="" title="image-20211024184507">

<p><strong>对于用户参数p，初始值约为0.85往往会产生可信的结果(下图(右))。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184547.png" class="" title="image-20211024184547">

<p>使用底数为10的对数的对数压缩(左)和不同底数的对数压缩(右)。</p>
<p><strong>或者，色调再现可以基于直方图均衡化。传统的直方图均衡化的目的是使每个亮度值在输出图像中出现的概率相等。Greg Ward以保留对比的方式改进了这个方法(Ward Larson, Rushmeier， &amp; Piatko, 1997)。</strong></p>
<p><strong>首先，根据高动态范围图像的亮度计算直方图。从这个直方图中，可以计算出一个累积直方图，这样每个箱子都包含亮度值小于或等于箱子所代表的亮度值的像素数。累积直方图是一个单调递增的函数。因此，将每个箱中的值与每个箱所代表的亮度值绘制成一个函数，该函数可被视为亮度映射函数。缩放这个功能，使垂直轴跨越显示设备的范围，产生一个色调再现操作符。这种技术称为直方图均衡化。</strong></p>
<p><strong>沃德进一步完善了这个方法，确保这个函数的梯度永远不超过1。这意味着，如果累积直方图中相邻值之间的差值太大，则此差值固定为1。这避免了输入亮度的微小变化可能导致输出图像的巨大差异的问题。换句话说，通过将累积直方图的梯度限制为1，对比度永远不会被夸大。得到的算法称为直方图调整(见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184739.png" class="" title="image-20211024184739">

<p>线性缩放图像(左)和直方图调整图像(右)。图片由佛罗里达州冬季公园的Albin Polasek博物馆许可制作。</p>
<h2 id="Night-Tonemapping-夜间色调映射"><a href="#Night-Tonemapping-夜间色调映射" class="headerlink" title="Night Tonemapping 夜间色调映射"></a>Night Tonemapping 夜间色调映射</h2><p><strong>到目前为止所讨论的色调再现算子几乎都假设图像代表了在光视条件下的场景，即就像在正常光线下看到的那样。对于暗点场景，即在非常黑暗的场景中，人类的视觉系统表现出截然不同的行为。特别是感知对比度较低，视觉敏锐度(即视力)较低。这是我们能分辨的最小细节)的颜色较低，所有的东西都有轻微的蓝色外观。</strong></p>
<p><strong>为了使这些图像能够在放置在光照明条件下的监视器上正确地观看，我们可以对图像进行预处理，使其看起来像是我们适应了一个非常黑暗的观看环境。这种预处理通常采取亮度和对比度降低、图像饱和度降低、蓝移和视觉灵敏度降低的形式(Thompson, Shirley， &amp; Ferwerda, 2002)。</strong></p>
<p><strong>一种典型的方法是将图像从RGB转换为XYZ。然后计算每个像素的暗亮度V:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024185016.png" class="" title="image-20211024185016">

<p><strong>这个单一通道的图像然后可以缩放和乘以经验选择的蓝灰色。下图显示了一个示例。如果一些像素在感光范围内通过将蓝灰色图像与输入图像线性混合，可以生成夜间图像。每个像素使用的分数取决于V。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024185058.png" class="" title="image-20211024185058">

<p>使用如图21.12所示的图像模拟夜景。</p>
<p><strong>视觉灵敏度的损失可能是通过对夜间图像的低通滤波来模拟的，尽管这可能会给人一种不正确的模糊感。一种较好的方法是采用双边滤波方法在模糊小细节的同时保留锐利的边缘(Tomasi &amp; Manduchi, 1998)。</strong></p>
<p><strong>最后，在第21.3节中概述的颜色转移技术也可以用来将白天的图像转换为夜景。这种方法的有效性取决于是否有合适的夜间图像来转换颜色。例如，将图21.12中的图像转换为下图中的夜景图像。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024185211.png" class="" title="image-20211024185211">

<p>左边的图像是用来将图21.12的图像转换成夜景的，如图所示。</p>
<h2 id="Discussion-讨论"><a href="#Discussion-讨论" class="headerlink" title="Discussion 讨论"></a>Discussion 讨论</h2><p><strong>由于全局光照算法自然会产生高动态范围的图像，直接显示生成的图像是不可能的。不应采用线性缩放或夹紧，而应使用色调复制运算符。任何色调复制操作都比不使用色调复制好。根据应用程序的要求，几个操作符中的一个可能是合适的。</strong></p>
<p><strong>例如，实时呈现应用程序可能应该采用简单的sigmoidal压缩，因为它们的速度足够快，也可以实时运行。此外，它们的视觉质量通常也足够好。直方图调整技术(Ward Larson et al.， 1997)对于实时操作也可能足够快。</strong></p>
<p><strong>对于包含非常高动态范围的场景，使用局部操作符可以实现更好的压缩。然而，计算成本通常要高得多，这使得这些操作符只适合于非交互应用程序。由于该技术所提供的优化，最快的本地运算符是双边过滤器(Durand &amp; Dorsey, 2002)。</strong></p>
<p><strong>这个过滤器本身是一个有趣的色调复制运算符，或者它可以用来计算一个本地适应级别，以用于sigmoidal压缩函数。在任何一种情况下，过滤器都会考虑强烈的对比变化，并平滑较小的对比。这是一个重要的特性，可以帮助最小化光晕工件，这是本地操作符的一个常见问题。</strong></p>
<p><strong>另一种最小化光晕伪影的方法是在照相色调复制算子中使用的比例选择机制(Reinhard等人，2002)，尽管这种技术计算速度较慢。</strong></p>
<p><strong>总之，虽然目前有大量的音调复制操作符可用，但只有少量不同的方法存在。傅里叶域算子和梯度域算子都是基于形象的形成。空间域算子在本质上要么是空间变体(局部)，要么是全局。这些操作通常基于对人类视觉系统(以及许多其他物种的视觉系统)的研究。</strong></p>
<h1 id="22-Implicit-Modeling-隐式模型"><a href="#22-Implicit-Modeling-隐式模型" class="headerlink" title="22 Implicit Modeling 隐式模型"></a>22 Implicit Modeling 隐式模型</h1><p><strong>计算机图形学中的隐式建模(也称为隐式曲面)涉及许多不同的模型定义方法。这些包括骨架隐式建模、偏移曲面、水平集、变分曲面和代数曲面。在本章中，我们将简要介绍这些方法，并详细描述如何构建骨骼隐式模型。曲线可以用这种形式的隐式方程来定义</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025115817.png" class="" title="image-20211025115817">

<p><strong>如果考虑半径为r的封闭曲线，如圆，隐式方程为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025115914.png" class="" title="image-20211025115914">

<p><strong>f(x, y)的值可以是正的(在圆外)，负的(在圆内)，或者对于圆上的精确点是零。在三维空间中，等效的是一个围绕着一组占据给定体积或空间区域的点的封闭曲面。体积形成一个标量场，即我们可以为每个点计算一个值，可以看到，对于圆，负的值是由隐式曲线或曲面限定的。该曲面可以看作是场中的一条等值线，其连接点具有特定的值(如0)(见上式)。为了计算这样一个曲面，需要在空间中搜索以找到满足隐式方程的点;这种方法不太可能成为绘制圆的有效算法(在三维空间中更不可能)。这也许就是用参数曲线建模的算法方法的原因隐式方法前对曲面进行了研究;然而，开发隐式曲面的可视化算法有一些很好的理由。在本章中，我们将探讨从建模过程而不是从扫描仪中获取数据的含义。</strong></p>
<p><strong>尽管寻找隐式曲面的计算开销很大，但使用隐式建模技术进行设计比其他建模方法有一些优势。许多几何运算是用隐式方法简化的，包括:</strong></p>
<p>​    <strong>•混合物的定义;</strong> </p>
<p>​    <strong>•构造立体几何(CSG)的标准集运算(并、交、差等);</strong> </p>
<p>​    <strong>•与其他隐函数的函数组合(如R -函数、Barthe共混、Ricci共混和翘曲);</strong> </p>
<p>​    <strong>•内部/外部测试(例如，用于碰撞检测)。</strong></p>
<p><strong>可视化的表面可以通过使用算法直接射线追踪完成(Kalra &amp; Barr, 1989;米切尔,1990;哈特与贝克，1996年;deGroot &amp; Wyvill, 2005)或首先转换为多边形(Wyvill, McPheeters， &amp; Wyvill, 1986)。</strong></p>
<p><strong>最早的方法之一是里奇早在1973年就提出的(里奇，1973)，他也在同一篇论文中介绍了CSG。Jim Blinn在电子密度场中寻找轮廓的算法，称为Blobby分子(J. Blinn, 1982)， Nishimura的Metaballs (Nishimura et al.， 1985)和Wyvills的软物体(Wyvill et al.， 1986)都是隐式建模方法的早期例子。Jim Blinn的Blobby Man(见下图)是第一个非代数隐式模型的渲染。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025120206.png" class="" title="image-20211025120206">

<p>Blinn’s Blobby Man 1980。由吉姆模拟金属。</p>
<h2 id="Implicit-Functions-Skeletal-Primitives-and-Summation-Blending-隐式函数、基本骨架和混合求和"><a href="#Implicit-Functions-Skeletal-Primitives-and-Summation-Blending-隐式函数、基本骨架和混合求和" class="headerlink" title="Implicit Functions, Skeletal Primitives, and Summation Blending 隐式函数、基本骨架和混合求和"></a>Implicit Functions, Skeletal Primitives, and Summation Blending 隐式函数、基本骨架和混合求和</h2><p><strong>在建模的背景下，隐函数f 被定义为作用于点p∈E³的函数得到一个标量值∈R。</strong></p>
<p><strong>隐函数fi(x, y, z)可以分解为距离函数di(x, y, z)和衰减滤波函数gi(r)，其中r表示到骨架的距离，下标表示第i个骨架元素。</strong></p>
<p><strong>我们将使用以下符号:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124042.png" class="" title="image-20211025124042">

<p><strong>一个简单的例子是一个原始的点，我们用一个恒星向太空辐射热量的类比。场值(本例中的温度)可以在任意点p上测量，可以通过取p到恒星中心的距离，并将该值提供给一个类似于下图中给出的滤波函数来找到。在这些样本函数中，场在星的中心处的值为1;这个值随着距离的增大而减小。模型的曲面可以由隐函数f(x, y, z)导出为空间中的点，这些点的值等于某个期望的等值(iso);在星形的例子中，一个用于表示iso∈(0,1)值的球壳。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124144.png" class="" title="image-20211025124144">

<p>降低滤波函数 (0 ≤ r ≤ 1).(a)布林高斯函数或“Blobby”函数;(b)西村的“Metaball”功能;(c) Wyvill等人的“软对象”函数;(d) Wyvill函数。</p>
<p><strong>一般来说，过滤器函数(gi)，以便在骨架上的场值是最大的，并在一些选择的距离下降到零骨架。在得到的曲面混合在一起的简单情况下，一个物体的全局场f(x, y, z)，隐函数，可以定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124337.png" class="" title="image-20211025124337">

<p><strong>其中n个骨架元素贡献了得到的字段值。下图给出了一个例子，其中任意点(x, y, z)的场计算如上式所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124427.png" class="" title="image-20211025124427">

<p>每一列显示两个相互接近的点原语。从左到右:使用的衰减过滤器函数是Blobby, Metaball, soft objects，和Wyvill。图片由Erwin DeGroot提供。</p>
<p><strong>在本例中，两个点原语被放置在非常接近的位置。当两个点放在一起时，表面会凸出然后融合在一起。使用术语过滤函数是因为该函数使原语在一起模糊，有点类似于图像的过滤函数。求和混合是可以应用于隐式曲面的最紧凑、最有效的混合运算(见上公式)。</strong></p>
<p><strong>使用支持有限的过滤函数的一个优点是，远离p的原语贡献为零，因此不需要考虑(Wyvill et al.， 1986)。</strong></p>
<h3 id="C¹-Continuity-and-the-Gradient-C¹连续性和梯度"><a href="#C¹-Continuity-and-the-Gradient-C¹连续性和梯度" class="headerlink" title="C¹ Continuity and the Gradient  C¹连续性和梯度"></a>C¹ Continuity and the Gradient  C¹连续性和梯度</h3><p><strong>连续性最基本的形式是C⁰ 连续性，确保函数中没有“跳转”。高阶连续性定义为函数的导数(见第15章)。</strong></p>
<p><strong>在三维标量场f的情况下，一阶导数是一个向量函数，称为梯度，写∇f并定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124656.png" class="" title="image-20211025124656">

<p><strong>如果:f在所有点都定义，三个一维偏导数分别为C⁰，那么f 是 C¹．非正式地,C¹ 表面连续性意味着表面法线在表面上平滑变化。曲面法向量是垂直于曲面的单位向量。例如，如果一个立方体的边缘上没有唯一的曲面法线，那么这个曲面就不是C¹．对于隐式曲面上的点，曲面法线可以通过归一化梯度向量∇f来计算。在这个圆的例子中，里面的点有一个负值，外面的点有一个正值。对于许多类型的隐式曲面，内部和外部的感觉是颠倒的，并且由于法向量必须总是指向外，它可以与梯度方向相反。</strong></p>
<p><strong>框架隐式原语是通过对无符号距离字段应用衰减滤波函数来创建的，如公式(22.2)所示。虽然距离场不是C¹ 在骨架上，这些不连续可以通过使用合适的衰减函数来去除(Akleman &amp; Chen, 1999)。如果一个算子g组合隐函数f₁ 和f₂，所有点都是C¹,那么g (f1,f2)不一定需要C¹．例如，可以使用最小和最大运算符来制作尖锐的CSG结。组合不是C¹ 因为min和max运算符没有这个属性(参见第22.5节)。</strong></p>
<p><strong>操作符的分析是复杂的，因为有时需要创建一个C¹ 不连续。只要表面需要有折痕，就会出现这种情况。例如，立方体不是C¹ 因为每条边都有切线不连续。使用C¹来创建折痕原语，则操作符必须引入C¹ 不连续性，因此不可能是C¹ 本身。</strong></p>
<h3 id="Distance-Fields-R-Functions-and-F-Reps-距离字段、R-函数和F-Reps"><a href="#Distance-Fields-R-Functions-and-F-Reps-距离字段、R-函数和F-Reps" class="headerlink" title="Distance Fields, R-Functions, and F-Reps 距离字段、R-函数和F-Reps"></a>Distance Fields, R-Functions, and F-Reps 距离字段、R-函数和F-Reps</h3><p><strong>距离场是关于某几何物体T定义的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025125320.png" class="" title="image-20211025125320">

<p><strong>直观上，F(T, p)是p到T的最短距离。因此，当p在T上时，F(T, p) = 0，隐式函数创建的曲面是对象T。在T之外，返回一个非零距离。函数T可以是嵌入在3d中的任何几何实体——点、曲线、曲面或实体。距离场的过程建模始于Ricci (Ricci, 1973);R -函数(Rvachev, 1963)在20多年后首次应用于形状建模(见(Shapiro, 1994)和(A. Pasko, Adzhiev, Sourin， &amp; Savchenko, 1995))。</strong></p>
<p><strong>R函数或Rvachev函数的符号可以改变当且仅当其中一个参数的符号改变;也就是说，它的符号完全由它的参数决定。R函数为实函数的布尔组合提供了一个健壮的理论框架，允许构造Cn CSG操作员(Shapiro, 1988)。这些CSG运算符可以用来创建混合运算符，只需在结果中添加一个固定偏移量(a . Pasko et al.， 1995)。虽然这些混合函数在技术上不再是R函数，但它们具有大多数理想的性质，可以与R函数自由混合，以创建复杂的层次模型(Shapiro, 1988)。这些基于R函数的混合和CSG操作符称为r操作符(参见第22.4节)。Hyperfun系统(Adzhiev et al.， 1999)基于F-reps(函数表示)，这是隐式曲面的另一种名称。该系统使用一种程序化的类C语言来描述许多类型的隐式曲面。</strong></p>
<h3 id="Level-Sets-水平集"><a href="#Level-Sets-水平集" class="headerlink" title="Level Sets 水平集"></a>Level Sets 水平集</h3><p><strong>通过规则网格(Barthe, Mora, Dodgson， &amp; Sabin, 2002)或自适应网格(Frisken, Perry, Rockwood， &amp; Jones, 2000)离散地表示隐式场是有用的。这正是多边形化算法在关卡集中所做的;此外，网格除了用于构建多边形外，还可以用于其他各种用途。f的离散表示通常是通过在正则区间对连续函数进行抽样得到的。例如，采样函数可以由其他体积模型表示定义(V. V. Savchenko, Pasko, Sourin， &amp; Kunii, 1998)。数据也可能是使用三维成像技术采集的实物。离散体积数据通常与水平集方法(Osher &amp; Sethian, 1988)结合使用，该方法定义了一种使用曲率相关的速度函数动态修改数据结构的方法。已经定义了基于水平集的交互建模环境(Museth, Breen, Whitaker， &amp; Barr, 2002)，尽管水平集只是采用隐式场的离散表示的一种方法。还探索了使用标准隐式曲面技术交互式定义离散表示的方法(Baerentzen &amp; Christensen, 2002)。</strong></p>
<p><strong>使用离散数据结构的一个关键优势是，它能够作为potential定义的所有不同体积模型的统一方法域(是否离散)(V. V. Savchenko et al.， 1998)。将任意连续函数转换为离散表示形式，引入了如何重建连续函数的问题，这是额外建模操作和结果势场可视化的组合目的所需要的。一个众所周知的解决这个问题的方法是使用卷积算子来应用一个滤波器g(见第9章)。滤波器的选择是根据重构的期望性质来指导的，并且已经探索了许多滤波器(Marschner &amp; Lobb, 1994)。其要点是，在所选滤波器的效率和所得到的重构的平滑性之间通常存在一个折衷;参见第22.9节。</strong></p>
<p><strong>为了实现交互性，离散系统必须限制网格的大小与可用计算能力的关系。这反过来又限制了建模器包含高频细节的能力。此外，平滑的三二次滤波器使它不可能包括尖锐的边缘，如果他们想要。这个问题的部分解决方案是使用自适应网格，尽管任何离散表示都有局限性。(Schmidt, Wyvill， &amp; Galin, 2005)使用离散网格作为表示BlobTree节点的缓存。该工作中的网格用于快速原型，并使用三线性插值的位置和较慢，更准确的三二次插值来计算梯度值，因为眼睛在观察梯度误差比位置误差更敏锐。</strong></p>
<h3 id="Variational-Implicit-Surfaces-变分隐式曲面"><a href="#Variational-Implicit-Surfaces-变分隐式曲面" class="headerlink" title="Variational Implicit Surfaces 变分隐式曲面"></a>Variational Implicit Surfaces 变分隐式曲面</h3><p><strong>通常需要将采样数据转换为隐式表示。变分隐式曲面利用全局支持基函数的加权和来插值或逼近一组点(V. Savchenko, Pasko, Okunev， &amp; Ku- nii, 1995;Turk &amp; O ‘Brien, 1999年;卡尔等人，2001年;Turk &amp; O ‘Brien, 2002)。这些径向对称基函数应用于每个样本点。这种曲面的连续性取决于基函数的选择。C² 最常用的是薄板样条(Turk &amp; O ‘Brien, 2002;卡尔等人，2001)。与Blinn的指数函数(见图22.2)一样，这个函数是无界的，得到的变分隐式曲面也是无界的。</strong></p>
<p><strong>如果场是全局的C²，则不能定义折痕;然而，各向异性基函数可以用来产生变化更快且可能出现折痕的场(Dinh, Slabaugh， &amp; Turk, 2001)。在适当的尺度下，表面仍然是光滑的。平滑场意味着自交点不会因此，卷总是定义明确的。薄板样条保证全局曲率最小(Duchon, 1977)。变分插值具有许多三维建模所需的特性;然而，控制产生的表面可能是困难的。</strong></p>
<p><strong>变分隐式曲面也可以基于紧凑支持径向基函数(CS-RBFs)，以减少变分插值技术的计算成本(Morse, Yoo, Rheingans, Chen， &amp; Subramanian, 2001)。每个CS-RBF只影响一个局部区域，因此计算f(p)只需要计算p的某个小邻域内的基函数。与全局支持的对应物一样，得到的场是C^k，不支持折痕，也不会发生自交。每个基函数的局部支持导致一个有界的全局域。正如许多研究人员所指出的那样，这也保证了其他等高线将会出现(Ohtake, Belyaev， &amp; Pasko, 2003;路透社,2003)。</strong></p>
<h3 id="Convolution-Surfaces-卷积表面"><a href="#Convolution-Surfaces-卷积表面" class="headerlink" title="Convolution Surfaces 卷积表面"></a>Convolution Surfaces 卷积表面</h3><p><strong>由Bloomenthal和Shoemake (Bloomenthal &amp; Shoemake, 1991)提出的卷积曲面是通过将几何骨架S与核函数h进行卷积得到的。因此，空间中任意位置的值由对骨架的积分来定义:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131353.png" class="" title="image-20211025131353">

<p><strong>任意有限支持函数都可以用h表示;参见(Sherstyuk, 1999)对不同内核的详细分析。</strong></p>
<p><strong>像骨架基元一样，卷积曲面也有有界域。Blinn的“斑点分子”是卷积曲面的最简单形式(J. Blinn, 1982);在这种情况下，骨架只由点组成。这个想法被Bloomenthal扩展到包括线、弧、三角形和多边形骨架(Bloomenthal &amp; Shoemake, 1991)。这些代表一维和二维原语;随后，Bloomenthal描述了3D原体(Bloomenthal, 1995)。</strong></p>
<p><strong>卷积曲面的组合是由底层几何骨架的组合来定义的，它的优点是消除了在使用添加剂混合组合多个骨架基元时容易出现的凸起。如下图所示，组合骨架的卷积得到的表面没有凸起，即使组合骨架-，场也是连续的吨是凸的。卷积曲面从骨架的凸部分偏移一个固定的距离，但沿骨架的凹部分产生一个圆角。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131425.png" class="" title="image-20211025131425">

<p>两个圆柱混合。左:加法混合;右图:褶积表面，几乎看不出凸起(Bloomenthal, 1997)。图片由Erwin DeGroot提供。</p>
<p><strong>下图显示了一个通过卷积构建复杂模型的骨架元素示例。手模型包含14个原语。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131435.png" class="" title="image-20211025131435">

<p>骨骼元素的卷积建立一个手模型。图片由Jules Bloomenthal提供。</p>
<h3 id="Defining-Skeletal-Primitives-定义骨架基元"><a href="#Defining-Skeletal-Primitives-定义骨架基元" class="headerlink" title="Defining Skeletal Primitives 定义骨架基元"></a>Defining Skeletal Primitives 定义骨架基元</h3><p><strong>正如我们将在下面的章节中看到的，渲染隐式模型需要找到大量点的场值和梯度。我们需要提供距离到方程(22.2)和梯度是有用的根寻找和照明计算。为图22.2中的下降过滤器函数提供距离是计算到骨架原语的最近距离的问题，对于点原语来说很简单，但对于更复杂的几何形状来说有点棘手。线段原语(AB)可以定义为围绕着带有半球形端盖的线的圆柱体(见下图)。点P0 位于f(P0) = iso和f(P1) = 0，因为它不在行原语的影响范围之内。到某个Pi 的距离简单地投影到直线AB上，并计算垂直距离，如|CP0*|;*这是可以发现的从AC，因为A, P0，和B，都是已知的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131854.png" class="" title="image-20211025131854">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131904.png" class="" title="image-20211025131904">

<p>线ab，例子点p0,P1,p2表示距离计算。 </p>
<p><strong>在上图中，P的场值2 &gt; 0，因为P2 是在半球形端盖上，可以单独检查。这种想法的变体可以定义具有不同半径端点的原语，产生有趣的圆锥形状。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025132127.png" class="" title="image-20211025132127">

<p>圆柱体原语与球体的混合。</p>
<p><strong>各种各样的几何骨架已经被描述过了，而且，在原则上，它只是简单地定义从某一点p到骨架的距离以及在p点的梯度。例如，的偏移曲面可以定义一个三角形顶点的三角形和一个半径r。一个简单的方法来实现这个是使用线段原语来描述边界气缸连接顶点的距离(半径)。一个点在三角形内,不属于边界的线段返回原语的一个三角形的平面的垂直距离。其他的例子包括一个隐式磁盘,定义为一个圆和一个厚度参数,一个环面也定义为一个圆的半径和横截面(或内外圆半径),圆锥从一个磁盘和一个高度,一个立方体圆角等。(见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025132231.png" class="" title="image-20211025132231">

<p>隐式模型从各种骨骼原语。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025132448.png" class="" title="image-20211025132448">

<p>光线追踪的恐龙模型显示隐式骨骼原语。</p>
<h2 id="Rendering-渲染"><a href="#Rendering-渲染" class="headerlink" title="Rendering 渲染"></a>Rendering 渲染</h2><p><strong>建模方法，如参数化曲面，有利于可视化，因为它很容易迭代曲面上的点，可以直接从定义方程中找到;例如(x, y) = (cos θ， sin θ)， θ∈[0,2 π]会产生一个圆。</strong></p>
<p><strong>有两种常用的技术来渲染隐式表面:光线追踪和表面平铺。在实践中，设计师希望快速可视化一个隐含的曲面模型，为了达到交互的目的而牺牲质量。原型算法一直关注于生成一个可以在现代工作站上实时渲染的多边形网格。找到最接近理想曲面的多边形网格称为多边形化或曲面平铺。对于动画或最终的可视化，质量优先于速度，光线追踪隐式表面直接不首先多边形产生优秀的结果。</strong></p>
<p><strong>如前所述，寻找隐曲面需要在空间中搜索，以找到满足f(p) = 0的点。执行这样的搜索有两种主要方法:空间分区——将空间分区到可管理的单位，如立方体，和非空间分区，如行军三角形(Hartmann, 1998;Akkouche &amp; Galin, 2001)和shrinkwrap算法(van Overveld &amp; Wyvill, 2004)。</strong></p>
<p><strong>在本章中，我们将描述原始的空间划分算法，并将其留给读者去探索更高级的方法。该算法与网格细化的后处理(见第12章)和缓存一起提供了一种在现代工作站上交互查看隐式模型的方法。</strong></p>
<h2 id="Space-Partitioning-空间分割"><a href="#Space-Partitioning-空间分割" class="headerlink" title="Space Partitioning 空间分割"></a>Space Partitioning 空间分割</h2><h3 id="Exhaustive-Search-穷举搜索"><a href="#Exhaustive-Search-穷举搜索" class="headerlink" title="Exhaustive Search 穷举搜索"></a>Exhaustive Search 穷举搜索</h3><p><strong>用于平铺隐式曲面的基本三次空间划分算法首次发表在(Wyvill et al.， 1986)和一个类似的面向体可视化的算法，称为行进立方体(Lorensen &amp; Cline, 1987)。从那时起，有许多改进和扩展。</strong></p>
<p><strong>寻找隐式曲面的第一个方法可能是将空间均匀地细分为三次单元格，并为每个顶点计算一个值。每个单元格被替换为一组多边形，这些多边形最接近包含在该单元格内的部分表面。这种方法的问题是，许多细胞将完全在体积的外部或内部;因此，许多不含表皮部分的细胞被加工。对于大型数据网格，这可能非常耗时和内存密集型。</strong></p>
<p><strong>为了避免存储整个网格，根据(Wyvill et al.， 1986)中使用的数据结构，使用哈希表只存储包含曲面的一部分的立方体。工作软件发表于Graphics Gems IV (Bloomenthal, 1990)。该算法基于数值延拓;它从一个种子立方体开始，种子立方体与部分表面相交，并根据需要构建相邻的立方体。</strong></p>
<p><strong>算法分为两部分。在第一部分中，立方体单元包含曲面，而在第二部分中，每个立方体都被三角形所取代。该算法的第一部分由一个立方体队列驱动，每个立方体队列包含曲面的一部分;算法的第二部分是表驱动的。</strong></p>
<h3 id="Algorithm-Description-算法描述"><a href="#Algorithm-Description-算法描述" class="headerlink" title="Algorithm Description 算法描述"></a>Algorithm Description 算法描述</h3><p><strong>算法的快速概述如下:</strong></p>
<p>​    <strong>•将空间划分为立方体体素;</strong> </p>
<p>​    <strong>•搜索表面，从一个骨架元素开始;</strong> </p>
<p>​    <strong>•添加体素到队列，标记它已访问;</strong> </p>
<p>​    <strong>•搜索邻居;</strong> </p>
<p>​    <strong>•当完成时，用多边形替换体素。</strong> </p>
<p><strong>首先，将空间细分为一个立方体晶格，接下来的任务是找到包含部分曲面的种子立方体。立方体顶点vi 在曲面内部有一个字段值vi &gt;= iso和曲面外的顶点将有一个字段值vi &lt; iso;因此，具有每种顶点的边将与曲面相交。我们称它为相交边。在离第一个原语最近的立方体顶点处的字段值可以根据公式(22.3)通过求和原语的贡献来计算，尽管也可以使用其他运算符，稍后将会看到。我们假设f(v0) &gt; iso，表示v₀ 在固体中。iso的值由用户选择;一个例子是iso = 0.5，当使用软下降函数，它有一些对称性的属性，导致良好的混合(见图22.3)。沿着一个轴的顶点依次计算，直到找到vi &lt; iso为止。含有相交边的立方体称为种子立方体。</strong></p>
<p><strong>检查种子立方体的邻居，并将至少包含一条相交边的种子立方体添加到等待处理的队列中。要处理一个立方体，我们要检查每个面。如果任何边界边有相反符号的顶点，曲面将通过该面，并且必须处理该面邻居。当这个过程完成了所有的面，算法的第二阶段是应用到立方体。如果曲面是封闭的，最终一个立方体将被重新访问，没有更多未标记的邻居被发现，搜索算法将终止。处理一个多维数据集包括将其标记为已处理的，并处理其未标记的邻居。对于包含相交边的图像，我们会对其进行处理，直到整个曲面被覆盖为止(见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026143933.png" class="" title="image-20211026143933">

<p>穿过立方晶格的截面。+符号表示曲面内部的顶点(f (vi≥iso)，而-位于f (vi &lt; iso)外部。</p>
<p><strong>每个立方体都由一个标识顶点索引，我们将其定义为左下角的远角(即。(x, y, z)坐标值最低的顶点(见下图)。对于表面内部的每个顶点，相应的位将被设置成8位表中的地址(参见下图和节22.3.3)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026144047.png" class="" title="image-20211026144047">

<p>顶点数字化。</p>
<p><strong>标识顶点是通过整数i, j, k来寻址的，这些整数是从立方体的(x, y, z)坐标位置计算出来的，x =side∗i，等等，其中面是立方体的大小。每个立方体的标识顶点可能会出现在多达8个其他立方体中，而重复存储这些顶点将是低效的。因此，顶点被唯一地存储在链散列表中。由于大部分空间不包含表面的任何部分，只有那些访问的立方体将被存储。当每个顶点存储在哈希表中时，隐式函数值会被找到。</strong></p>
<p><strong>由于对该表面的拓扑结构一无所知，所以搜索必须从每一个原语开始，以避免错过任何不相关的表面部分。标量可用于扩展原语的影响。如果标量可以小于零，那么可以沿着一个轴搜索而不找到一条相交边。在这种情况下，必须进行更复杂的搜索以找到种子立方体(Galin &amp; Akkouche, 1999)。</strong></p>
<h4 id="Data-Structures-数据结构"><a href="#Data-Structures-数据结构" class="headerlink" title="Data Structures 数据结构"></a>Data Structures 数据结构</h4><p><strong>哈希表项包含5个值:</strong></p>
<p>​    <strong>•标识顶点的i, j, k格指数(见上图);</strong></p>
<p>​    <strong>•f，标识顶点的隐函数值;</strong></p>
<p>​    <strong>•布尔值，用于指示该立方体是否已被访问。</strong><br><strong>哈希函数计算哈希表中的一个地址，方法是从i, j, k中选择一些位，并对它们进行算术组合。例如，五个最低有效位产生一个15位的表地址，它必须有一个长度2^15股。这样的哈希函数可以在C预处理器中实现，如下所示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026144410.png" class="" title="image-20211026144410">

<p><strong>队列(FIFO列表)被用作临时存储，用于标识邻居进行处理。算法从标记为已访问并放置在队列中的种子立方体开始。队列上的第一个多维数据集被退出队列，它所有未访问的邻居被添加到队列中。如果每个立方体包含部分曲面，则每个立方体都被处理并传递到算法的第二阶段。然后对队列进行处理，直到为空。</strong></p>
<h3 id="Polygonization-Algorithm-多边形化算法"><a href="#Polygonization-Algorithm-多边形化算法" class="headerlink" title="Polygonization Algorithm 多边形化算法"></a>Polygonization Algorithm 多边形化算法</h3><p><strong>算法的第二阶段是独立处理每个立方体。细胞被一组最符合通过细胞的部分表面形状的三角形所取代。该算法必须在给定每个顶点隐函数值的情况下决定如何将单元格多边形化。这些值可以是正的，也可以是负的。，小于或大于等值)，给出立方体的8个顶点的256个正或负顶点组合。包含256个条目的表提供了在每个三角形中使用的正确顶点(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026155317.png" class="" title="image-20211026155317">

<p>表2包含了曲面相交的边。表1指向表2中的适当条目。</p>
<p><strong>例如，条目4(00000100)指向第二个表，该表记录了约束相交边的顶点。在这个例子中,顶点2号内表面(f (V 2) &gt; = iso),因此,我们希望能画一个三角形连接相交的点表面边缘有界(V2,V0)、(V2,V3),(V2,V6)如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026155540.png" class="" title="image-20211026155540">

<p>求曲面和立方体边缘的相交。</p>
<h4 id="Finding-Cube-Surface-Intersections-找到立方体-曲面的相交"><a href="#Finding-Cube-Surface-Intersections-找到立方体-曲面的相交" class="headerlink" title="Finding Cube-Surface Intersections 找到立方体-曲面的相交"></a>Finding Cube-Surface Intersections 找到立方体-曲面的相交</h4><p><strong>上图显示了顶点为V₂的立方体是在表面内部，而其他所有顶点都在表面外部。如图所示，与曲面相交在三条边上。曲面与边V2 −V6 相交于A。最快但不准确的方法是使用线性插值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160139.png" class="" title="image-20211026160139">

<p><strong>如果立方体边为1,f(A)的等值为0.5，则</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160214.png" class="" title="image-20211026160214">

<p><strong>这对于静态图像很有效，但在动画中帧之间的错误差异将非常明显。应采用常规法等寻根方法。这将增加计算成本，因为需要梯度来计算交点。渲染表面点也需要梯度。对于许多类型的原语，使用p附近的样本点来寻找数值近似更简单，如</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160246.png" class="" title="image-20211026160246">

<p><strong>经验发现Δ的合理值为0.01∗side，其中side是立方体边的长度。</strong></p>
<p><strong>对于制造一个网格，相对于一组独立的三角形，第二个哈希表可以维护所有相交边的列表。由于每个立方体边最多由四个邻居共享，边哈希表防止了面立方边相交计算的重复。哈希地址可以从顶点的哈希函数中派生出来(应用于边缘端点)。</strong></p>
<h3 id="Sampling-Problems-采样问题"><a href="#Sampling-Problems-采样问题" class="headerlink" title="Sampling Problems 采样问题"></a>Sampling Problems 采样问题</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160456.png" class="" title="image-20211026160456">

<p>顶点在表面内部(+)和外部(-)的例子。注意，额外的样本提供了一个线索，以避免模棱两可的情况。</p>
<p><strong>当面(或立方体)的相反角具有相同的符号，而面上的另一对顶点具有相反的符号时，就会出现歧义(参见上图)。在脸面中心采集的样本将提供线索，以确定这个立方体是代表两个表面的结合还是一个马鞍。应该清楚的是，空间网格在每个顶点上存储隐函数的一个样本。如果函数在单元格中发生了很大的变化，那么多边形表示将不会显示这种变化(参见下图)。除非对曲面的曲率有所了解，否则单靠取样是无法分辨曲面的。关于这个话题的一个很好的讨论出现在(Kalra &amp; Barr, 1989)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160511.png" class="" title="image-20211026160511">

<p>使用大的立方体来捕捉隐函数中的小的变化。</p>
<p><strong>这个模糊问题(不是欠采样问题)是通过将立方体细胞细分为四面体来避免的。这样，四面体就可以明确地变成多边形。因为每个四面体有四个顶点，所以一个包含16个条目的表将提供正确的三角形信息。缺点是将生成大约两倍数量的多边形。</strong></p>
<h4 id="Subdividing-a-Cube-细分立方体"><a href="#Subdividing-a-Cube-细分立方体" class="headerlink" title="Subdividing a Cube 细分立方体"></a>Subdividing a Cube 细分立方体</h4><p><strong>在不需要额外的单元顶点的情况下，一个立方体可以分解成5个或6个四面体，如下图6所示。这些分解在立方体表面上引入对角线，并保持立方体之间的对角线方向一致邻居，六分解更好。对角线边缘的引入产生了比直接用三角形替换每个立方体更高分辨率的表面。四面体分解和四面体替换为三角形是快速的，表格驱动的算法，产生拓扑一致的网格。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160814.png" class="" title="image-20211026160814">

<p>把一个立方体分解成六个四面体。图片由Erwin DeGroot提供。</p>
<h3 id="Cell-Polygonization-细胞多边形化"><a href="#Cell-Polygonization-细胞多边形化" class="headerlink" title="Cell Polygonization 细胞多边形化"></a>Cell Polygonization 细胞多边形化</h3><p><strong>使用统一空间细分出现了两个明显的问题。该算法输出的三角形大小不适应曲面的曲率，需要进一步的样本来解决模糊问题，即立方体单元被多边形取代。Bloomenthal (Bloomenthal, 1988)开发了一种基于八叉树的空间细分算法，它确实适应了曲面的曲率。单元被细分为8个八进制，通过使用限制八叉树格式避免了裂缝，例如:，相邻细胞之间的差异不能超过一级的细分。这确实减少了生成的多边形数量，但只有当表面的平坦区域恰好完全落在适当的八分区内时，才能充分利用大单元格的优势。实践证明，该算法比统一体素算法慢得多，实现起来也更复杂。</strong></p>
<h2 id="More-on-Blending-更多的关于混合"><a href="#More-on-Blending-更多的关于混合" class="headerlink" title="More on Blending 更多的关于混合"></a>More on Blending 更多的关于混合</h2><p><strong>第22.1节说明了在求和字段值时可以进行混合。利玛尼在其划时代的论文(利玛尼，1973)中描述了超椭圆混合。给定两个函数FA 和FB ，之前我们简单地找到了隐式值Ftotal = FA + FB ．我们可以用A◇B.利玛尼混合被定义为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161140.png" class="" title="image-20211026161140">

<p><strong>有趣的是，指出以下属性:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161229.png" class="" title="image-20211026161229">

<p><strong>此外，这种广义的混合是结合的，即f(A◇B)◇C = fA◇(B◇C)．证明了标准混合算子+是n = 1的超椭圆混合的特殊情况。当n从1到无穷时，在混合A + B和并A∪B之间创建一组混合插值(见下图)。图22.27显示了二进制或一元的节点;事实上，使用上述公式可以很容易地将二进制节点扩展到n元节点。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161504.png" class="" title="image-20211026161504">

<p>通过改变n，里奇混合可能能够顺利地从混合过渡到联合。图片由Erwin DeGroot提供。</p>
<p><strong>里奇算子的幂是它们在所有可能隐体积的空间上的运算下是封闭的，这意味着一个算子的应用只会产生另一个标量场，定义另一个隐体积。这个新字段可以与其他字段组合，同样使用里奇运算符。上上方程总会产生两个隐式体积的精确并集，不管它们有多复杂。与在B-rep曲面上应用布尔CSG操作所涉及的困难相比，隐式体积的实体建模是非常简单的。</strong></p>
<p><strong>根据Pasko的函数表示(A. Pasko et al.， 1995)，可以定义另一个广义混合函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161621.png" class="" title="image-20211026161621">

<p><strong>当α∈[−1,1]在−1到1之间变化时，它创建了一组插值并算子和交集算子的混合算子。但是，该操作符不再具有关联性，与n元操作符的定义不兼容。</strong></p>
<h2 id="Constructive-Solid-Geometry-构建实体几何"><a href="#Constructive-Solid-Geometry-构建实体几何" class="headerlink" title="Constructive Solid Geometry 构建实体几何"></a>Constructive Solid Geometry 构建实体几何</h2><p><strong>隐式模型通常被称为隐式曲面;然而，它们本质上是体积模型，对实体建模操作很有用。里奇引入了一个构造几何学，用于从诸如并、交、差和原语混合等操作中定义复杂形状(Ricci, 1973)。曲面被认为是定义内部的f(p) &lt; 1和定义外部的f(p) &gt; 1之间的边界。这种最初的实体建模方法演变成了构造实体几何或CSG (Ricci, 1973;Requicha, 1980)。CSG通常根据二叉树自底向上评估，用低次多项式原语作为叶节点和表示布尔集操作的内部节点。这些方法适用于隐式建模，对于骨架隐式曲面，布尔集运算并∪max,交∩min 和差分\minmax 定义如下(Wyvill, Galin， &amp; Guy, 1999):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161931.png" class="" title="image-20211026161931">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026162031.png" class="" title="image-20211026162031">

<p>CSG的里奇算子。图片由Erwin DeGroot提供。</p>
<p><strong>上图中给出了点原语A和B的Ricci运算符。对于联合(左下角)，联合内部所有点的字段都是其中较大的fA()和fB(）.对于交点(中心)，在标记为P1的区域内的函数的值是(fA(P1), fB (P1) = 0)，因为B在其影响范围之外的贡献为零。类似地，对于标记为P2的区域(A的影响为零，即(即最小值)只留下交集区域为正值。Difference的工作原理与three中的iso-value类似显著的区域(Pi)如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026162416.png" class="" title="image-20211026162416">

<p><strong>CSG算子创建折痕，即C¹ 不连续。例如，min()操作符(上上方程)创建C¹ 在f1(p) = f2(p).当应用于两个球体时，由并算符产生的不连续会在表面上产生一个折痕，如上图所示，这是我们想要的结果。不连续很不幸地延伸到表面外的区域，这在这张图片中是不可见的。如果将混合应用到并集的结果上，则场中的C¹ -不连续平面将产生遮阳不连续(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026162605.png" class="" title="image-20211026162605">

<p>左边的两个点原语是由利玛窦联盟连接。第三个原语被混合到结果中，在区域中产生了不想要的折痕。图片由Erwin DeGroot提供。</p>
<p><strong>这个问题在一定程度上是可以避免的(G. Pasko, Pasko, Ikeda， &amp; Kunii，</strong><br><strong>2002)，并开发了CSG算子，并且所有点有C¹，其中f1(p) = f2(p) = iso (Barthe, Dodgson, Sabin, Wyvill， &amp; Gaildrat，)2003)。</strong></p>
<h2 id="Warping-扭曲"><a href="#Warping-扭曲" class="headerlink" title="Warping 扭曲"></a>Warping 扭曲</h2><p><strong>通过扭曲周围空间来扭曲表面形状的能力是一个有用的建模工具。弯曲是一个映射R³的连续函数w(x, y, z) 在R³．Sederberg在描述自由形式变形时，为翘曲提供了一个很好的类比(Sederberg &amp; Parry, 1986)。他认为，弯曲的空间可以比作一个清晰、灵活的塑料平行六面体，要弯曲的物体就嵌在其中。通过对隐式方程简单地应用某个扭曲函数w(p)，可以定义一个扭曲元素:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163108.png" class="" title="image-20211026163108">

<p><strong>一个弯曲的元件可以由它到骨架的距离来充分表征di(x, y, z)，其衰减滤波函数gi(r)，最后是它的扭曲函数wi(x, y, z)。在隐式表面上渲染或执行操作，隐式必须找到许多点f(P)的值。首先，P被warp函数变换到某个新的点Q，并返回f(Q)代替f(P)。在下图中，不是返回某个点f(Q)的隐式值，而是返回f(P)的值。在这种情况下，返回等值，隐式曲面(2D中的曲线)通过Q而不是p，因此，圆被扭曲成椭圆。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163257.png" class="" title="image-20211026163257">

<p>点Q返回点p的字段值。</p>
<p><strong>Barr通过应用于参数曲面的扭曲、锥度和弯曲操作引入了全局和局部变形的概念(Barr, 1984)。可以对变形进行嵌套，以生成如图22.27所示的模型。从概念上讲，这些方法很容易应用到隐式曲面上，如式(22.6)所示。</strong></p>
<p><strong>注意，法线不能以类似于弯曲一个点的方式计算。这个问题类似于第13.2节中关于实例化的问题。在这种情况下，法线最容易用(22.3.3)式来近似，尽管如(Barr, 1984)所建议的，使用雅可比矩阵可以得到精确的结果。下面几节将介绍巴尔翘曲。</strong></p>
<h3 id="Twist-扭"><a href="#Twist-扭" class="headerlink" title="Twist 扭"></a>Twist 扭</h3><p><strong>在这个例子中，对于三个带有扭曲的混合隐式圆柱体，其扭曲沿z轴方向呈θ方向(见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163550.png" class="" title="image-20211026163550">

<p>三个混合隐式圆柱扭在一起。</p>
<p><strong>绕z的扭转表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163613.png" class="" title="image-20211026163613">

<h3 id="Taper-锥"><a href="#Taper-锥" class="headerlink" title="Taper 锥"></a>Taper 锥</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163910.png" class="" title="image-20211026163910">

<p>三个混合隐式圆柱先扭曲再锥化。</p>
<p><strong>锥度沿一个主轴应用。线性锥被证明是最有用的，尽管二次和立方锥很容易实现。例如，沿着y轴的线性圆锥涉及到改变x和z坐标。(参见上图)。在y之间应用一个线性比例ymax 和ymin：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163928.png" class="" title="image-20211026163928">

<h3 id="Bend-弯曲"><a href="#Bend-弯曲" class="headerlink" title="Bend 弯曲"></a>Bend 弯曲</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026164300.png" class="" title="image-20211026164300">

<p>三个混合隐式圆柱扭曲、锥化、弯曲。</p>
<p><strong>弯曲也适用于一个主轴。(参见上图)。对于下面的弯曲例子，弯曲速率为单位长度的弧度k，弯曲轴为(x0， 1/k)，角θ定义为(x−x0)∗k.绕z弯曲为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026164316.png" class="" title="image-20211026164316">

<h2 id="Precise-Contact-Modeling-精确接触模型"><a href="#Precise-Contact-Modeling-精确接触模型" class="headerlink" title="Precise Contact Modeling 精确接触模型"></a>Precise Contact Modeling 精确接触模型</h2><p><strong>精确接触建模(PCM)是一种隐式曲面原元在接触状态下变形的方法，同时保持与C¹ 连续性(Gascuel, 1993)。PCM之所以重要，是因为它是一种简单而自动的方式，可以显示模型如何对其环境作出反应。使用非隐式方法就不能这么容易地做到这一点(参见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026164834.png" class="" title="image-20211026164834">

<p>海葵变形成暗礁。</p>
<p><strong>PCM是通过包含一个变形函数s(p)来实现的，该函数对每个点返回的字段值进行修正。对于每一对对象，首先使用边界盒测试检测碰撞。一旦确定可能发生碰撞，就应用PCM。局部几何变形项si 并加到隐函数fi．将碰撞物体的体积划分为相互穿透区域和变形区域。应用si的结果是相互穿透区域被压缩，以保持接触而不发生相互穿透(见下图)。si的影响在传播区域内衰减为零，以使两个区域外的体积不变形。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026164956.png" class="" title="image-20211026164956">

<p>通过碰撞物体的二维切片，显示不同的区域和PCM变形。图片由Erwin DeGroot提供。</p>
<p><strong>给定两个生成字段的骨架元素f1(p)和f2(p)，每一个周围的表面计算为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026165422.png" class="" title="image-20211026165422">

<p><strong>我们需要生成两个元素共同的表面(上图中的虚线)，即它们在该区域的某些p的渗透区域共享一个解决方案:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026165510.png" class="" title="image-20211026165510">

<p><strong>从直观上看，物体2在物体1中渗透得越深，物体1的隐含值就越高，因此物体2被压缩得越多。</strong></p>
<p><strong>函数,si 定义为在穿透区域的边界处产生平滑的连接点，即si = 0，但它的导数大于0。从这里到传播区域的边界si 用来将传播衰减到零。在穿透区域边界上最近的点0 是由梯度求得的。</strong></p>
<p><strong>在传播区域内si(p) = hi(r)，其中p = (x, y, z)是计算其隐式值的点，r =|| p−p0||(见下图)。ri的值，由用户设置，定义传播区域的大小;这个区域以外就不会发生变形。为了控制对象在传播区域膨胀多少，用户为参数α提供了一个值。最大hi 的值是Mi．当前最小值si 是负的，并以simin,其中Mi =−αisi min．因此，物体将在穿透区被压缩，而在传播区膨胀。hi的方程由两个三次多项式组成，设计在r = ri/2，其中斜率为0:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026170039.png" class="" title="image-20211026170039">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026170201.png" class="" title="image-20211026170201">

<p>函数hi(r)的值为变形函数wi在传播区域。</p>
<p><strong>当我们从互穿区移动到传播区时，我们希望有c¹连续性。因此,h′i(0) =上图中的k，为si的方向导数在连接处(标记为p0 在上上图)。如式(22.7)所示，si  =−fi 在相互渗透区域内，则:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026170604.png" class="" title="image-20211026170604">

<p><strong>PCM算法只是一个近似的适当变形的表面，但它是一个有吸引力的算法，因为它的简单。</strong> </p>
<h2 id="The-BlobTree-融合树"><a href="#The-BlobTree-融合树" class="headerlink" title="The BlobTree 融合树"></a>The BlobTree 融合树</h2><p><strong>BlobTree是一种使用树结构的方法，它扩展了CSG树，以包含使用骨架原语的各种混合操作(Wyvill etal .， 1999)。Hyperfun项目是一个具有类似功能的系统，它使用一种专门的语言来描述F-rep对象(Adzhiev et al.， 1999)。</strong></p>
<p><strong>在BlobTree系统中，模型是通过将隐式原语和操作符∪(union)、∩(intersection)、−(difference)、+ (blend)、◇(超椭圆混合)和w(扭曲)。BlobTree不仅是由这些表达式构建的数据结构，也是一种可视化模型结构的方法。上面列出的运算符都是二进制的，但warp是个一元运算符。一般来说，使用n进制运算符比使用二元运算符更有效。BlobTree将仿射变换合并为节点，因此它也是一个场景图，并且由叶节点组成的原语(例如骨架)。</strong></p>
<h3 id="Traversing-the-BlobTree-遍历BlobTree"><a href="#Traversing-the-BlobTree-遍历BlobTree" class="headerlink" title="Traversing the BlobTree 遍历BlobTree"></a>Traversing the BlobTree 遍历BlobTree</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171119.png" class="" title="image-20211026171119">

<p>BlobTree。螺旋楼梯是由一个中央纹理圆柱体建造而成，楼梯和栏杆被混合在一起。栏杆由一系列圆柱体和两个圆形(圆环)原体混合在一起，再与一个垂直圆柱体混合而成。BlobTree也是一个场景图，实例化节点重复由适当矩阵转换的各个部分。每个楼梯都是由一个锥形多边形原体(成为一个偏移面)制成的;十字节点和并节点将膨胀盘与楼梯连接起来。</p>
<p><strong>上图显示了一个包含Barr扭曲和CSG操作的BlobTree示例。其他节点可以包括2D纹理(Schmidt, Grimm， &amp; Wyvill, 2006)，精确接触建模，以及动画和其他属性。BlobTree的遍历本质上非常简单。通过多边形或光线追踪渲染对象所需要的就是找到任意点的隐式值(以及相应的梯度)。这可以通过遍历树来实现。多边形化和射线跟踪算法需要在空间中大量点处计算隐式场函数。函数f(N, M)返回节点N在点M处的字段值，这取决于节点的类型。值L和R表示探索树的左或右分支。下面的算法被写成(为了简单起见)，就好像树是二进制的一样:</strong></p>
<p><strong>函数f(N, M)</strong></p>
<p>​    <strong>•原始:f (M);</strong></p>
<p>​    <strong>•变形:f(L(N)， w(M));</strong> </p>
<p>​    <strong>•blend: f(L(N)， M) + f(R(N)， M));</strong></p>
<p>​    <strong>•union: max(f(L(N)， M)， f(R(N)， M));</strong> </p>
<p>​    <strong>•交集:min(f(L(N)， M)， f(R(N)， M));</strong></p>
<p>​    <strong>•差:min(f(L(N)， M)，−f(R(N)， M))。</strong></p>
<p><strong>下图显示了一个复杂的BlobTree模型，其中显示了集成的许多特性。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171321.png" class="" title="image-20211026171321">

<p>“螺旋楼梯。在Erwin DeGroot的BlobTree.net系统中创建的复杂的BlobTree隐式模型。</p>
<h2 id="Interactive-Implicit-Modeling-Systems-交互式隐式模型系统"><a href="#Interactive-Implicit-Modeling-Systems-交互式隐式模型系统" class="headerlink" title="Interactive Implicit Modeling Systems 交互式隐式模型系统"></a>Interactive Implicit Modeling Systems 交互式隐式模型系统</h2><p><strong>早期基于草图的建模系统，如Teddy (Igarashi, Matsuoka， &amp; Tanaka, 1999)，使用用户绘制的一些笔画来推断3D空间中的多边形模型。有了更好的硬件和改进的算法，基于草图的隐式建模系统现在是可能的。Shapeshop使用隐式扫描表面从2D用户笔画制造3D笔画，并保留了BlobTree的层次结构，不像早期系统生成的均质网格(Schmidt, Wyvill, Sousa， &amp; Jorge, 2005)。这使得用户能够从几个简单的笔画生成任意拓扑的复杂模型。边界图显示了一个闭合的绘制笔画(下图)膨胀为一个隐式扫描和第二个扫描(下下图)，使用CSG减去一个较小的扫描对象。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171447.png" class="" title="image-20211026171447">

<p>膨胀概述。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171502.png" class="" title="image-20211026171502">

<p>可以应用BlobTree操作，例如，CSG差分。图片由Erwin DeGroot提供。</p>
<p><strong>使之成为可能的改进之一是缓存系统，该系统在BlobTree的每个节点上使用固定的三维隐式值网格，表示通过遍历节点下的树找到的值(Schmidt, wyill， &amp; Galin, 2005)。如果在节点N需要某个点p的值，则可以返回一个值，而不需要遍历N以下的树，前提是树的一部分没有改变。相反，我们使用了一个插值方案(见第9章)来寻找p的值。这个方案加快了对复杂BlobTrees的遍历速度，并且是使系统以交互速率运行的一个因素。</strong></p>
<p><strong>下一代隐式建模系统将利用硬件和软件的进步，以交互方式处理越来越复杂的层次模型。下图显示了一个更复杂的Shapeshop示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171703.png" class="" title="image-20211026171703">

<p>“下一步。“艺术家Corien Clapwijk (Andusan)在Ryan Schmidt的Shapeshop中交互创建了一个复杂的BlobTree隐式模型。</p>
<h1 id="23-Global-Illumination-全局光照"><a href="#23-Global-Illumination-全局光照" class="headerlink" title="23 Global Illumination 全局光照"></a>23 Global Illumination 全局光照</h1><p><strong>在现实世界中，许多表面从其他反射表面接收大部分或全部的入射光。这通常被称为间接照明或相互照明。例如，大多数房间的天花板很少或没有直接从灯具(发光物体)获得照明。光照的直接分量和间接分量如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027113538.png" class="" title="image-20211027113538">

<p>在左边和中间的图像中，间接照明和直接照明分别被分离出来。右边显示了两个分量的和。全局光照算法同时考虑了直接光照和间接光照。</p>
<p><strong>虽然计算光在表面之间的相互反射是简单的，但它可能是昂贵的，因为所有的表面都可能反射任何给定的表面，导致多达O(N²) N个表面的相互作用。因为对象的整个全局数据库可以照亮任何给定的对象，间接照明通常被称为全局照明问题。</strong></p>
<p><strong>关于解决全球照明问题的文献丰富而复杂(例如，Appel, 1968;gora, Torrance, Greenberg， &amp; Battaile, 1984;库克et al .,1984;伊梅尔等人，1986;Kajiya, 1986;马利,1988)。本章以粒子跟踪和路径跟踪两种算法为例进行讨论。第一个是有用的演练应用程序，如迷宫游戏，并作为批处理渲染的组件。第二个是用于真实的批处理渲染。然后我们讨论如何分离“直接”照明，即光在灯具和相机之间只发生一次反射。</strong></p>
<h2 id="Particle-Tracing-for-Lambertian-Scenes-朗伯场景的粒子追踪"><a href="#Particle-Tracing-for-Lambertian-Scenes-朗伯场景的粒子追踪" class="headerlink" title="Particle Tracing for Lambertian Scenes 朗伯场景的粒子追踪"></a>Particle Tracing for Lambertian Scenes 朗伯场景的粒子追踪</h2><p><strong>回想一下18.2节中的传播方程:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114108.png" class="" title="image-20211027114108">

<p><strong>这个方程的几何结构如下图所示。当被照点为朗伯式时，这个方程简化为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114122.png" class="" title="image-20211027114122">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114157.png" class="" title="image-20211027114157">

<p>定向形式的传播方程的几何形式。</p>
<p><strong>其中R为漫反射。近似这个方程的解的一种方法是使用有限元方法。首先，我们将场景分成N个表面，每个表面亮度Li未知,反射率Ri，发出辐亮度Ei．这就得到了N个联立线性方程组</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114254.png" class="" title="image-20211027114254">

<p><strong>kij 是与原始积分表示有关的常数。然后我们解出这组线性方程，我们可以渲染N个恒定颜色的多边形。这种有限元方法通常称为辐射度。</strong></p>
<p><strong>另一种替代辐射的方法是使用统计模拟方法，通过随机跟踪从灯具通过环境的光“粒子”。这是一种粒子追踪。有许多算法使用某种形式的粒子跟踪;我们将讨论一种粒子追踪的形式，它将光线沉积在三角形的纹理中。首先，我们回顾了一些基本的辐射关系。面积为A的朗伯曲面的辐亮度L与单位面积的入射功率成正比:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114343.png" class="" title="image-20211027114343">

<p><strong>Φ是来自地表的输出能量。请注意，在本讨论中，所有的辐射量都是光谱或RGB，这取决于实现。如果地表有发射能量Φe，事件强度Φi，反射率R，那么这个方程就变成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114352.png" class="" title="image-20211027114352">

<p><strong>如果我们有一个模型Φe 和R指定的每个三角形，我们可以进行灯具通过灯具，火力的形式从每个灯具的粒子。我们将纹理贴图与每个三角形关联起来，以存储累积的亮度，并将所有像素初始化为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114446.png" class="" title="image-20211027114446">

<p><strong>如果一个三角形的面积是A和nt 当它被一个能量为φ的粒子击中时，该粒子的亮度就会增加</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114456.png" class="" title="image-20211027114456">

<p><strong>一旦一个粒子击中一个表面，我们增加它击中的texel的亮度，概率地决定是否反射这个粒子，如果我们反射它，我们选择一个方向并调整它的功率。</strong></p>
<p><strong>注意，我们希望粒子在某一点终止。对于每个表面，我们可以为每个表面相互作用指定一个反射概率p。一个自然的选择是让p = R就像自然界中的光一样。粒子会分散在周围环境中，在被吸收之前不会失去或获得任何能量。当粒子携带单一波长时，这种方法很有效(Walter, Hubbard, Shirley， &amp; Greenberg, 1997)。然而，当光谱或RGB三重被射线携带时，就像经常实现的那样(Jensen, 2001)，没有单一的R，应该选择一些对p值的折衷。强度φ′对于反射的粒子，应加以调整，以考虑到粒子可能消失:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114633.png" class="" title="image-20211027114633">

<p><strong>注意，p可以被设为任何小于1的正常数，并且这个常数对于每次相互作用都是不同的。当p &lt; R时，粒子会在那个波长上获得能量，当p &lt; R时，粒子会在那个波长上失去能量。当p &lt; 1时，粒子将停止散射并在某一点终止。在接下来的讨论中，我们将p设为0.5。在这样的系统中，单个粒子的路径如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114708.png" class="" title="image-20211027114708">

<p>粒子存活的概率为0.5，并在最后一个交叉点被吸收的路径。显示每个路径段的RGB功率。</p>
<p><strong>这个算法的一个关键部分是我们用适当的朗伯曲面分布来散射光。如14.4.1节所讨论的，我们可以通过变换两个标准随机数(ξ1,ξ2)来找到一个具有余弦(朗伯)分布的向量如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114815.png" class="" title="image-20211027114815">

<p><strong>注意，这假设法向量平行于z轴。对于三角形，我们必须建立一个w平行于法向量的标准正交基。我们可以做到以下几点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114838.png" class="" title="image-20211027114838">

<p><strong>pi 是三角形的顶点。然后，根据定义，在适当坐标下的向量是</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114849.png" class="" title="image-20211027114849">

<p><strong>在伪代码中，p = 0.5和一个灯具的算法是:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114900.png" class="" title="image-20211027114900">

<p><strong>这里ξi 是标准随机数。一旦这段代码运行，纹理贴图存储每个三角形的亮度，可以直接为任何视点渲染，不需要额外的计算。</strong></p>
<h2 id="Path-Tracing-路径追踪"><a href="#Path-Tracing-路径追踪" class="headerlink" title="Path Tracing 路径追踪"></a>Path Tracing 路径追踪</h2><p><strong>虽然粒子跟踪非常适合于漫射场景的亮度预计算，但对于使用一般BRDFs或包含许多对象的场景创建图像是有问题的。创建这类场景的图像最直接的方法是使用路径跟踪(Kajiya, 1986)。这是一种概率方法，从眼睛发出光线，并将它们追踪回光线。通常路径追踪只用于计算间接照明。在这里，我们将以一种捕获所有照明的方式呈现它，这可能是低效的。这有时被称为暴力路径跟踪。在第23.3节中，可以添加更有效的直接照明技术。</strong></p>
<p> <strong>在路径跟踪中，我们从完整的传输方程开始:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115310.png" class="" title="image-20211027115310">

<p><strong>我们使用蒙特卡罗积分来近似解决这个方程的每一条观察射线。回忆一下14.3节，我们可以使用随机样本来近似一个积分:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115335.png" class="" title="image-20211027115335">

<p><strong>在xi 是概率密度函数p的随机点。如果我们把这个直接应用到N = 1的传播方程中，我们得到</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115345.png" class="" title="image-20211027115345">

<p><strong>所以，如果我们有办法选择随机方向ki 有了已知的密度p，我们可以得到一个估计值。问题是Lf (ki)本身就是未知数。幸运的是，我们可以应用递归并使用Lf (ki)的统计估计，通过向那个方向发送射线来找到在那个方向看到的表面。当我们碰到一个灯具和Le 为非零(下图)。这个方法假设光线的反射率为零，否则我们将继续递归。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115555.png" class="" title="image-20211027115555">

<p>在路径跟踪中，光线从眼睛通过一个像素，并在场景中散射，直到它击中灯具。</p>
<p><strong>在lambert BRDF (ρ = R/π)的情况下，我们可以使用一个余弦密度函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115707.png" class="" title="image-20211027115707">

<p><strong>可根据式(23.3)选择具有该密度的方向。这允许在我们的估计中抵消余弦项:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115724.png" class="" title="image-20211027115724">

<p><strong>在伪代码中，这种朗伯曲面的路径跟踪器的工作原理与第4章中描述的射线跟踪器类似，但射线颜色函数将被修改:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115747.png" class="" title="image-20211027115747">

<p><strong>这将导致一个非常嘈杂的图像，除非使用大的光源或非常多的样本。注意，光源的颜色必须远高于一(有时数千或数万)，以使表面的最终颜色接近一，因为只有那些偶然击中光源的光线才会产生影响，而大多数光线只会产生接近零的颜色。为了生成随机方向d，我们使用与粒子追踪相同的技术(见公式(23.2))。</strong></p>
<p><strong>一般情况下，我们可能希望使用光谱颜色或更通用的BRDF。在实践中，我们应该让material类包含成员函数来计算随机方向以及与该方向相关的p。通过这种方式，材料可以透明地添加到实现中。</strong></p>
<h2 id="Accurate-Direct-Lighting-精确的直接光照"><a href="#Accurate-Direct-Lighting-精确的直接光照" class="headerlink" title="Accurate Direct Lighting 精确的直接光照"></a>Accurate Direct Lighting 精确的直接光照</h2><p><strong>本节介绍一种比第10章更基于物理的直接照明方法。这些方法将有助于提高全局光照算法的效率。关键的想法是将阴影光线发送到灯具，就像第4章中描述的那样，但是这样做是基于前一章的传输方程。全局光照算法可以调整，以确保直接分量精确计算一次。例如，在粒子追踪中，直接来自灯具的粒子不会被记录，所以粒子只会编码间接照明。这使得好看的阴影比在全局光照环境下计算直接光照更有效。</strong></p>
<h3 id="Mathematical-Framework-数学框架"><a href="#Mathematical-Framework-数学框架" class="headerlink" title="Mathematical Framework 数学框架"></a>Mathematical Framework 数学框架</h3><p><strong>为了计算从一个灯具(发光物体)到非发光表面的直接光，我们求解第18.2节中的传播方程的形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120040.png" class="" title="image-20211027120040">

<p><strong>回想一下,Le是发射源的辐射亮度，v是一个能见度函数，如果x“看到”x′，则它等于1，否则等于0，其他变量如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120213.png" class="" title="image-20211027120213">

<p>上方程的直接光照的术语。</p>
<p><strong>如果我们要用蒙特卡罗积分对上方程进行采样，我们需要随机选取一个点x′用密度函数p (所以x′~px)。只要输入(14.5)式，就可以得到一个样本</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120555.png" class="" title="image-20211027120555">

<p><strong>如果我们在灯具上随机选取一个均匀点，那么p = 1/ A，其中A是灯具的面积。这得出</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120625.png" class="" title="image-20211027120625">

<p><strong>我们可以直接使用上式对平面(如矩形)光源进行采样。我们简单地在每个灯具上随机选择一个点。</strong></p>
<p><strong>一种灯具的代码为:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120700.png" class="" title="image-20211027120700">

<p><strong>上面的代码需要一些额外的测试，如如果余弦为负，则将其锁定为零。注意||d||⁴ 来自距离平方项 还有两个余弦，例如n·d = ||d||cos θ，因为d不一定是单位向量。</strong></p>
<p><strong>下图显示了几个软阴影的例子。</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120844.png" class="" title="image-20211027120844">

<p>带有正方形和区域光源的背光球上的各种软阴影。上图:1个样本。底部:100个样本。请注意，在决定阴影的外观时，光源的形状比它的大小更重要。</p>
<h3 id="Sampling-a-Spherical-Luminaire-球形灯具采样"><a href="#Sampling-a-Spherical-Luminaire-球形灯具采样" class="headerlink" title="Sampling a Spherical Luminaire 球形灯具采样"></a>Sampling a Spherical Luminaire 球形灯具采样</h3><p><strong>虽然可以用上方程对圆心为c、半径为R的球体进行采样，但这种采样将产生非常有噪声的图像，因为许多采样将在球体的背面，而cos θ′术语变化很大。相反，我们可以使用更复杂的p(x′)来减少噪声。</strong></p>
<p><strong>我们可以尝试的第一个非均匀密度是p(x′) ∝cos θ′。这p(x′) ∝cos θ′ / ||x′−x||²和采样一样复杂，所以我们在这里讨论这个问题。我们观察到灯具上的取样是这样的和常数密度函数q(ki) = const，定义在光源所面对的方向空间中，从x处可见。我们现在使用原点为x的坐标系，使用右手标准正交基w = (c−x)/||c−x||， v = (w × n)/||(w×n)||(见下图)。我们还定义(α， φ)为uvw坐标系下的方位角和极角。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121745.png" class="" title="image-20211027121745">

<p>球面灯具在x点直接照明的几何图形。</p>
<p><strong>包括球面灯具的最大α为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121823.png" class="" title="image-20211027121823">

<p><strong>因此，在球体所面对的方向的圆锥体内的密度(相对于立体角)是实心角2π(1 - cos αmax)的倒数由球体所包围的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121840.png" class="" title="image-20211027121840">

<p><strong>我们得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121850.png" class="" title="image-20211027121850">

<p><strong>这给了我们方向ki．为了找到实际的点，我们需要找到球面上那个方向上的第一个点。这个方向的射线是(x + tki）， ki 是由</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121943.png" class="" title="image-20211027121943">

<p><strong>我们还必须计算p(x′)，关于面积度量的概率密度函数(记得密度函数q是在立体角空间中定义的)。因为我们知道q是一个有效的概率密度函数使用ω测度，我们知道dΩ = dA(x′) cos θ′/ ||x′−x||²，我们可以将任意的概率密度函数q(ki)联系起来及其相关的概率密度函数p(x′)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027122121.png" class="" title="image-20211027122121">

<p><strong>我们可以解出p(x′)</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027122132.png" class="" title="image-20211027122132">

<p><strong>下图显示了一个很好的调试案例。</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027122214.png" class="" title="image-20211027122214">

<p>一个球面Le = 1接触一个反射球体。当两个球体接触时，反射球体的L(x′) = 1。左:1个样品。中间:100个样本。右:100个样品，特写镜头。</p>
<h3 id="Nondiffuse-Luminaries-非漫反射光源"><a href="#Nondiffuse-Luminaries-非漫反射光源" class="headerlink" title="Nondiffuse Luminaries 非漫反射光源"></a>Nondiffuse Luminaries 非漫反射光源</h3><p><strong>没有理由灯具的亮度不能随方向和位置而变化。例如，如果灯具是电视机，它可以随位置而变化。它可以随汽车前照灯和其他定向源的方向变化。在我们的分析中，与前面的部分相比几乎没有什么需要改变的，除了Le(x′)必须变成Le(x′,−ki)．改变强度随方向变化的最简单方法是对法向量n′使用类似phong的图形。为了避免在总光输出的术语中使用指数，我们可以使用这种形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027122508.png" class="" title="image-20211027122508">

<p><strong>E(x′)是x′点的辐射出度(单位面积的功率)， n是Phong指数。当n = 1时，你会得到一个漫射光。如果光通过其区域是不均匀的，例如电视机，那么E就不是一个常数。</strong></p>
<h1 id="24-Reflection-Models-反射模型"><a href="#24-Reflection-Models-反射模型" class="headerlink" title="24 Reflection Models 反射模型"></a>24 Reflection Models 反射模型</h1><p><strong>正如我们在第18章讨论的，表面的反射特性可以用BRDF (Nicodemus, Richmond, Hsia, Ginsberg， &amp; Limperis, 1977;库克和托伦斯，1982)。在本章中，我们将讨论材料属性在视觉上最重要的一些方面，以及一些非常简单的模型，这些模型对捕获这些属性非常有用。有许多BRDF模型在图形中使用，这里展示的模型只是给出一个无漫反射BRDF的概念。</strong></p>
<h2 id="Real-World-Materials-真实世界材质"><a href="#Real-World-Materials-真实世界材质" class="headerlink" title="Real-World Materials 真实世界材质"></a>Real-World Materials 真实世界材质</h2><p><strong>许多真实的材料在正常的观察距离下都有可见的结构。例如，大多数地毯都有很容易看到的绒毛，有助于外观。就我们的目的而言，这样的结构不是物质属性的一部分，而是几何模型的一部分。结构的细节在正常的观察距离是看不见的，但它确实决定了材料的宏观外观，是材料属性的一部分。例如，纸上的纤维在放大后会呈现出复杂的外观，但在一臂长的距离上观察时，它们会模糊在一起，呈现出均匀的外观。折叠成BRDF的微结构之间的区别是任意的，取决于人们定义的“正常”观察距离和视力，但这种区别在实践中被证明是非常有用的。</strong></p>
<p><strong>在本节中，我们将定义一些材料类别。在本章的后面，我们将介绍针对每种材料类型的反射模型。在讲义中在本章的最后，还讨论了一些可以解释更多奇异材料的模型。</strong></p>
<h3 id="Smooth-Dielectrics-and-Metals-光滑电介质和金属"><a href="#Smooth-Dielectrics-and-Metals-光滑电介质和金属" class="headerlink" title="Smooth Dielectrics and Metals 光滑电介质和金属"></a>Smooth Dielectrics and Metals 光滑电介质和金属</h3><p><strong>电介质是能够折射光线的透明材料;第四章总结了它们的基本性质。金属像电介质一样反射和折射光线，但它们吸收光线的速度非常非常快。因此，只有非常薄的金属片是透明的，例如，一些玻璃制品上的薄镀金。对于光滑的材料，只有两个重要的属性:</strong></p>
<p>​    <strong>1.每个入射角和波长反射多少光。</strong></p>
<p>​    <strong>2.在给定的距离和波长下，光通过材料时被吸收的比例是多少?</strong></p>
<p><strong>透射的光量是没有反射的(这是能量守恒的结果)。实际上，对于金属来说，我们可以假设所有的光都被立即吸收了。对于电介质，分数由第13章讨论的比尔定律中使用的常数决定。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028173242.png" class="" title="image-20211028173242">

<p>玻璃反射和透射的光量随角度的不同而变化。</p>
<p><strong>反射的光量由第4章讨论的菲涅耳方程确定。这些方程很简单，但很麻烦。菲涅耳方程的主要作用是随着入射角的增加而增加反射率，特别是在掠角附近。这种效应也适用于透射光。这些想法在上图中以图表形式显示出来。注意，光被反复反射和折射，如下图所示。通常只有一两个反射的图像是容易看到的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028173259.png" class="" title="image-20211028173259">

<p>光线被反复反射和重新反射由玻璃破碎，能量的破碎显示。</p>
<h3 id="Rough-Surfaces-粗糙表面"><a href="#Rough-Surfaces-粗糙表面" class="headerlink" title="Rough Surfaces 粗糙表面"></a>Rough Surfaces 粗糙表面</h3><p><strong>如果金属或电介质被粗糙到很小的程度，但又没有小到产生衍射，那么我们可以将其视为带有microfacet的表面(Cook &amp; Torrance, 1982)。这样的表面在较近距离时表现为镜面，但在较远的距离观察时，似乎将光线以一种分布方式展开。对于金属来说，这种粗糙表面的一个例子可能是拉丝钢，或大多数铝箔的“浑浊”一面。</strong></p>
<p><strong>对于电介质，如一片玻璃，划痕或其他不规则的表面特征使玻璃模糊了反射和透射的图像，我们通常可以清楚地看到。如果表面划伤严重，我们称之为半透明而不是透明。这是一个有点武断的区别，但我们通常很清楚，我们是认为玻璃是半透明的还是透明的。</strong></p>
<h3 id="Diffuse-Materials-漫反射材质"><a href="#Diffuse-Materials-漫反射材质" class="headerlink" title="Diffuse Materials 漫反射材质"></a>Diffuse Materials 漫反射材质</h3><p><strong>如果一个材料是哑光的，即是漫反射的。而不是闪闪发亮的。我们看到的许多表面都是弥散的，比如大多数石头、纸张和未完成的木头。对于第一次近似，扩散表面可以近似为朗伯常数BRDF。真实的漫反射材料通常会因为掠射角度而变得有些高光。这是一种微妙的效果，但对于现实主义来说很重要。</strong></p>
<h3 id="Translucent-Materials-半透明材质"><a href="#Translucent-Materials-半透明材质" class="headerlink" title="Translucent Materials 半透明材质"></a>Translucent Materials 半透明材质</h3><p><strong>许多薄的物体，如树叶和纸，都能漫射和反射光线。出于实际目的，这些物体不会传送清晰的图像。这些表面可以增加透射光的色相变化。例如，红纸之所以是红的，是因为它滤掉了非红光，只滤掉了进入纸内较短距离的光线，然后散射回来。这种纸也能透过红色调的光，因为原理相同，但透过的光能穿透纸张。这种性质的一个含义是，在两个方向上的透射系数应该是相同的。</strong></p>
<h3 id="Layered-Materials-分层材质"><a href="#Layered-Materials-分层材质" class="headerlink" title="Layered Materials 分层材质"></a>Layered Materials 分层材质</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028173705.png" class="" title="image-20211028173705">

<p>击中分层表面的光可以被反射，或者它可以被传输，然后漫射离开基材。</p>
<p><strong>许多表面是由“层”组成的，或者是嵌入粒子的电介质，使表面具有扩散特性(Phong, 1975)。这种材料的表面镜面反射如图所示，因此遵循菲涅耳方程。被传输的光要么被吸收，要么被散射回介质表面，在那里它可能被传输，也可能不被传输。这些光线经过透射、散射，然后在相反的方向重新透射，形成了漫射“反射”成分。</strong></p>
<p><strong>请注意漫反射分量也会随着角度的增大而衰减，因为菲涅耳方程会随着角度的增大而反射回表面，如下图所示。因此，相对于一个恒定的漫反射BRDF，在掠射角附近消失的BRDF更合适。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028173723.png" class="" title="image-20211028173723">

<p>当相对于表面法线的角度增加时，被衬底散射的光越来越不可能离开表面。</p>
<h2 id="Implementing-Reflection-Models-实时反射材质"><a href="#Implementing-Reflection-Models-实时反射材质" class="headerlink" title="Implementing Reflection Models 实时反射材质"></a>Implementing Reflection Models 实时反射材质</h2><p><strong>如18.1.6节所述，BRDF模型将生成比我们从点光源和phong -like模型获得的渲染更基于物理的渲染。不幸的是，真正的brdf通常非常复杂，不能从第一原理推导出来。相反，它们必须被衡量直接从原始数据中逼近，或者它们必须以经验的方式粗略逼近。后一种经验策略是通常所做的，这种近似模型的发展仍然是一个研究领域。本节讨论这些经验模型的几个可取的性质。</strong></p>
<p><strong>首先，物理约束意味着BRDF模型的两个性质。第一个约束是节能:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174256.png" class="" title="image-20211028174256">

<p><strong>如果你从一个表面的任何方向发射一束光i，则各方向反射的光总量最多为入射量。我们期望所有BRDFs具有的第二个物理性质是互惠性:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174305.png" class="" title="image-20211028174305">

<p><strong>其次，我们想要在漫反射和镜面组件之间有一个清晰的分离。这样做的原因是，尽管对于理想的镜面分量有一个精确的脉冲函数公式，但脉冲函数必须在实际中作为特殊情况来实现。这种特殊情况只有在BRDF模型清楚地表明什么是镜面的和什么是漫反射的情况下才可行。</strong></p>
<p><strong>第三，我们想要直观的参数。例如，Phong模型如此长寿的一个原因是，它的扩散常数和指数都与表面的直观属性明确相关，即表面颜色和高光大小。</strong></p>
<p><strong>最后，我们希望BRDF函数能够接受蒙特卡罗采样。回想一下第14章，一个积分可以被N个随机点采样xi~p 其中p的定义与积分相同:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174426.png" class="" title="image-20211028174426">

<p><strong>回忆一下第18.2节中ko 方向的表面辐亮度由传输方程给出:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174439.png" class="" title="image-20211028174439">

<p><strong>如果我们用pdf p(ki)，然后我们可以用采样来近似地表辐亮度:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174449.png" class="" title="image-20211028174449">

<p><strong>这个近似对于任何非零的p是收敛的在被积函数是非零的情况下。然而，只有当被积函数相对于p不是很大时，它才会很好地收敛。理想情况下，p(k)应该近似于ρ(kj,ko)Lf (kj ) cosθj 被积函数的形状．在实践中,Lf 是复杂的，我们能做的最好的就是让p(k)形状有点像ρ(k, ko)Lf (k) cosθ。</strong></p>
<p><strong>例如，如果BRDF是朗伯常数，那么它是常数，理想p(k)与cos θ成正比。因为p的积分必须是1，我们可以推导出前导常数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174714.png" class="" title="image-20211028174714">

<p><strong>这意味着C = 1/π，所以我们有</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174722.png" class="" title="image-20211028174722">

<p><strong>只要在被积函数非零的情况下p不变得太小，就可以得到一个可接受的有效实现。因此，常量pdf也足够了:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174732.png" class="" title="image-20211028174732">

<p><strong>这强调了对于给定的BRDF模型，许多pdfs文件是可以接受的。</strong> </p>
<h2 id="Specular-Reflection-Models-镜面反射材质"><a href="#Specular-Reflection-Models-镜面反射材质" class="headerlink" title="Specular Reflection Models 镜面反射材质"></a>Specular Reflection Models 镜面反射材质</h2><p><strong>对于金属，我们通常指定在正入射处的反射率R0(λ)。反射率应根据菲涅耳方程变化，一个很好的近似由(Schlick, 1994a)给出。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174956.png" class="" title="image-20211028174956">

<p><strong>这种近似使我们可以通过数据或肉眼设置金属的法向反射率。</strong></p>
<p><strong>对于电介质，同样的公式也适用于反射率。但是，我们可以设置R0(λ)用折射率n(λ)表示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028175006.png" class="" title="image-20211028175006">

<p><strong>通常，n不随波长而变化，但对于色散很重要的应用，n可以变化。通常有用的折射率包括水(n = 1.33)、玻璃(n = 1.4到n = 1.7)和钻石(n = 2.4)。</strong></p>
<h2 id="Smooth-Layered-Model-平滑分层模型"><a href="#Smooth-Layered-Model-平滑分层模型" class="headerlink" title="Smooth-Layered Model 平滑分层模型"></a>Smooth-Layered Model 平滑分层模型</h2><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028175258.png" class="" title="image-20211028175258">

<p>使用耦合模型的抛光瓷砖的渲染。这些图像是用蒙特卡罗路径示踪器产生的。扩散项的抽样分布为cos θ/π。</p>
<p><strong>在哑光/镜面材料中，如塑料或抛光木材，其表面的反射由菲涅耳方程控制，而在次表面则由散射控制。这种反射的一个例子可以在上图的渲染图中看到。注意，在镜面反射中的模糊主要是垂直的，这是由于在视图方向上的明显凹凸间距的压缩。这种效应导致了在有风的日子里在湖泊上看到的垂直条纹反射;它既可以使用显式微几何和简单的光滑表面反射模型建模，也可以使用更一般的模型来解释这种不对称。</strong></p>
<p><strong>我们可以对贴图使用传统的朗伯-高光模型，它线性混合了高光和朗伯术语。在标准的放射学术语中，这可以表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028175334.png" class="" title="image-20211028175334">

<p><strong>其中Rdλ是亚光项的半球反射率,Rs是镜面反射，ρs 为归一化镜面BRDF(球面上的加权狄拉克函数)。这个方程是BRDF的简化版，其中Rs 与波长无关。波长的独立性导致了一个突出的颜色，这是灯具的颜色，所以抛光而不是金属外观将实现。Ward (G. J. Ward, 1992)建议设置Rd(λ)+ Rs ≤1，以节约能源。然而，这种模型具有常数Rs 在陡峭的视角下，无法显示高光度的增加。这是关键点:在现实世界中，亚光和镜面的相对比例会随着视角的变化而变化。</strong></p>
<p><strong>一种模拟亚光外观变化的方法是显式抑制Rd(λ)作为Rs 增加(雪莉,1991):</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028175549.png" class="" title="image-20211028175549">

<p><strong>其中Rf (θ)为polish-air界面的菲涅耳反射率。这个方程的问题是它不是互反的，这可以通过交换θ和θ′看出;这改变了哑光阻尼因子的值，因为乘以(1−R)f (θ))。镜面项，一个缩放的狄拉克函数，是互易的，但这并不能弥补物质项的非互易性。尽管这个BRDF工作得很好，但它缺乏互易性可能会导致一些呈现方法有定义不清的解决方案。</strong></p>
<p><strong>我们现在提出一个模型，产生亚光/镜面权衡，同时保持互惠和能量守恒。由于新模型的关键特征是它耦合了哑光和高光的比例系数，因此它被称为耦合模型(Shirley, Smits, Hu， &amp; Lafortune, 1997)。</strong></p>
<p><strong>表面有光泽的表面通常是透明的介质，如聚氨酯或油，有一些次表面结构。反射的镜面成分是由光滑的介质表面引起的，与该表面下的结构无关。这个镜面项的大小由菲涅耳方程决定。</strong></p>
<p><strong>没有在表面反射的光通过表面透射。在那里，它要么被底面吸收，要么被颜料或底面反射，然后通过抛光液的表面传送回来。透射光形成反射的哑光部分。由于哑光组件只能包含透射的光，它将自然地减少总幅度增加的角度。</strong></p>
<p><strong>为了避免在物理上合理的模型和在一系列入射角范围内具有良好定性行为的模型之间进行选择，请注意解释镜面项的菲涅尔方程，Rf (θ)是直接从介质-空气界面的物理性质推导出来的。因此，问题一定存在于整体上。我们可以使用一个全面的地下散射模拟来实现，但是这种技术既昂贵又需要地下结构的详细知识，而这通常既不知道也不容易测量。相反，我们可以修改matte项，使之成为一个简单的近似，捕获图24.4中所示的重要的定性角度行为。</strong></p>
<p><strong>我们假设马特项不是朗伯函数，而是某个只与θ，θ′和λ有关的函数:ρm(θ,θ′,λ)。我们抛弃了依赖于φ的行为或者φ′为了简单起见。我们尽量让公式保持合理的简单因为亚光项的物理是复杂的有时需要未知的参数。我们期望亚光项接近于常数，并且大致旋转对称(He et al.， 1992)。</strong></p>
<p><strong>一个明显的候选物质的物质组分ρm(θ,θ′,λ)它的倒数是可分离形式kRm(λ)f(θ)f(θ′)。我们可以合并k和Rm(λ)变成了一个单独的项，但是我们选择把它们分开，因为这样更直观地设置Rmλ 所有波长必须在0和1之间。可分离BRDFs已被证明有几个计算优势，因此我们使用可分离模型:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180047.png" class="" title="image-20211028180047">

<p><strong>我们知道哑光组分只能包含没有在表面(镜面)组分中反射的能量。这意味着对于Rm(λ) = 1时，入射能量和反射能量相等，这说明对于每个入射θ和λ， BRDF有以下约束:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180111.png" class="" title="image-20211028180111">

<p><strong>我们可以看出f(θ)一定与(1−Rf (θ))成正比。如果我们假设吸收一些能量的哑光组分与这个理想具有相同的方向模式，我们就得到了这种形式的BRDF</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180159.png" class="" title="image-20211028180159">

<p><strong>我们现在可以插入菲涅耳方程的完整形式来得到Rf (θ)，然后使用能量守恒来求解对k的约束。相反，我们将使用24.1.1节讨论的近似</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180248.png" class="" title="image-20211028180248">

<p><strong>应用方程(24.1)得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180256.png" class="" title="image-20211028180256">

<p><strong>则为全耦合BRDF</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180305.png" class="" title="image-20211028180305">

<p><strong>运行耦合模型的结果如图24.5所示。请注意，对于高视点，镜面反射几乎是不可见的，但它在低角度的照片图像中是清晰可见的，那里的亚光行为是不明显的。</strong></p>
<p><strong>对于折射率的合理值，R0 的范围大约为0.03到0.06(值R0 = 0.05用于图24.5)。Rs 在传统的Phong模型中更难选择，因为它通常必须为静态图像的视点进行调整，并为动画的特定相机序列进行调整。因此，耦合模型在“不干涉”模式下更容易使用。</strong></p>
<h2 id="Rough-Layered-Model-粗糙分层模型"><a href="#Rough-Layered-Model-粗糙分层模型" class="headerlink" title="Rough-Layered Model 粗糙分层模型"></a>Rough-Layered Model 粗糙分层模型</h2><p><strong>之前的模型如果表面光滑就可以了。然而，如果表面不是理想的，则需要在镜面组件中进行一些扩展。本文将耦合模型扩展到这种情况(Ashikhmin &amp; Shirley, 2000)。在表面上的一个给定点上，BRDF是两个方向的函数，一个是朝向光的方向，另一个是朝向观众的方向。我们希望有一个BRDF模型，适用于“普通”表面，如金属和塑料，并具有以下特点:</strong></p>
<p>​    <strong>1.似是而非的(Plausible)。正如Lewis (R. R. Lewis, 1994)所定义的，这是指BRDF服从能量守恒和互易性。</strong></p>
<p>​    <strong>2.各向异性(Anisotropy)。该材料应模拟简单的各向异性，如在拉丝金属上看到的。</strong></p>
<p>​    <strong>3.直观的参数(Intuitive parameters)。对于材料，如塑料，应该有参数Rd 和Rs 对于法向镜面反射以及两个粗糙度参数nu 和nv．</strong></p>
<p>​    <strong>4.菲涅耳的行为(Fresnel behavior)。当入射角减小时，高光度会增大。</strong></p>
<p>​    <strong>5.Non-Lambertian扩散项(Non-Lambertian diffuse term)。材料应该允许扩散项，但成分应该是非朗伯的，以确保存在菲涅耳行为的能量守恒。</strong></p>
<p>​    <strong>6.蒙特卡罗友好(Monte Carlo friendliness)。应该有一些合理的概率密度函数，允许直接的蒙特卡罗样本生成BRDF。</strong></p>
<p><strong>具有这些性质的BRDF是一个各向异性的菲涅耳加权phong型余弦波瓣模型。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180828.png" class="" title="image-20211028180828">

<p>几何形状的反射。注意k1,k2和h共享一个平面，这个平面通常不包括n。</p>
<p><strong>我们再次将BRDF分解为一个镜面组件和一个漫反射组件(上图)。因此，我们将BRDF写成两部分的经典和:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180748.png" class="" title="image-20211028180748">

<p><strong>其中第一项解释了镜面反射(这将在下一节介绍)。而可以用朗伯BRDF来表示弥散项ρd(k1,k2)，我们将在第24.5.2节讨论更好的解决方案，并在第24.5.3节讨论如何实现该模型。只想实现模型的读者应该跳过该部分。</strong></p>
<h3 id="Anisotropic-Specular-BRDF-各向异性高光BRDF"><a href="#Anisotropic-Specular-BRDF-各向异性高光BRDF" class="headerlink" title="Anisotropic Specular BRDF 各向异性高光BRDF"></a>Anisotropic Specular BRDF 各向异性高光BRDF</h3><p><strong>为了模拟镜面的行为，我们使用了冯氏风格的镜面波瓣，但使这个波瓣各向异性，并纳入菲涅耳行为，同时试图保持初始模式的简单性。这个BRDF是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181031.png" class="" title="image-20211028181031">

<p><strong>我们再次使用了菲涅耳方程的Schlick近似:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181041.png" class="" title="image-20211028181041">

<p><strong>其中Rs 为材料在正入射时的反射率。因为ki ·h = ko ·h，这种形式是倒数。我们有一个经验模型，它的项是选择执行能源节约和互惠。Ashikhmin在论文中给出了对这些术语的充分理性化，列在章节注释中。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181253.png" class="" title="image-20211028181253">

<p>指数为10、100、1000和10000的金属球，从左到右和从上到下均递增。</p>
<p><strong>上上式的镜面BRDF对于表示反射的漫反射分量非常小的金属表面是有用的。上图显示了纹理映射的lambert平面上的一组金属球体。参数nu 和nv 变化时，球体的外观从粗糙的金属转变为几乎完美的镜面，从高度各向异性转变为更熟悉的Phong-like行为。</strong></p>
<h3 id="Diffuse-Term-for-the-Anisotropic-Phong-Model-各向异性Phong模型的扩散项"><a href="#Diffuse-Term-for-the-Anisotropic-Phong-Model-各向异性Phong模型的扩散项" class="headerlink" title="Diffuse Term for the Anisotropic Phong Model 各向异性Phong模型的扩散项"></a>Diffuse Term for the Anisotropic Phong Model 各向异性Phong模型的扩散项</h3><p><strong>可以将朗伯BRDF与各向异性镜面项结合使用;大多数模型都是这样做的，但这并不一定能节约能源。一个更好的方法是采用一种简单的依赖于角度的漫射分量形式，这种形式可以解释这样一个事实:漫射散射可用的能量量由于反射率项的全反射对入射角的依赖而变化。特别是，表面的漫反射颜色在掠射角附近消失，因为总镜面反射率接近1。这个众所周知的效应不能用朗伯扩散项来再现，因此大多数反射模型都忽略了它。</strong></p>
<p><strong>采用与耦合模型类似的方法，我们可以找到一种与各向异性Phong波瓣相容的漫射项形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181436.png" class="" title="image-20211028181436">

<p><strong>这里Rd 为正入射的漫反射系数，Rs 为冯瓣系数。下图显示了使用该模型的示例。</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181447.png" class="" title="image-20211028181447">

<p>三个视图nu = nv = 400和扩散衬底。注意镜面反射强度的变化。</p>
<h3 id="Implementing-the-Model-实现模型"><a href="#Implementing-the-Model-实现模型" class="headerlink" title="Implementing the Model 实现模型"></a>Implementing the Model 实现模型</h3><p><strong>回想一下，BRDF是漫反射和镜面的组合:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028191754.png" class="" title="image-20211028191754">

<p><strong>漫反射分量如式(24.7)所示;镜面分量如式(24.5)所示。没有必要调用三角函数计算指数，则镜面BRDF可以写成:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028191834.png" class="" title="image-20211028191834">

<p><strong>在蒙特卡罗环境中，我们对下列问题感兴趣给定k1，生成k2 的样本其分布形状与余弦加权BRDF相似。注意，被积函数的大值严重欠采样是一个严重的误差，而小值严重过采样在实践中是可以接受的。读者可以验证下面建议的密度具有这种性质。</strong></p>
<p><strong>构建一个用于采样的pdf的合适方法是考虑产生BRDF的半向量的分布。这样的函数是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028191914.png" class="" title="image-20211028191914">

<p><strong>这里选择的常量是为了确保它是一个有效的pdf。</strong></p>
<p><strong>我们可以用概率密度函数ph(h)来生成一个随机的h。然而，为了计算渲染方程，我们同时需要一个反射向量ko 概率密度函数p(ko）．重要的是要注意，如果根据h生成ph(h)然后转化为结果ko:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028192238.png" class="" title="image-20211028192238">

<p><strong>生成的k的密度o 不是ph(ko）．这是因为h和ko的测量值不同．所以实际密度p(ko)是</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028192250.png" class="" title="image-20211028192250">

<p><strong>注意，在已知BRDF是这个模型的实现中，渲染方程的估计非常简单，因为许多项抵消了。</strong></p>
<p><strong>可以生成一个h向量，其对应的向量是ko 将指向表面内部，即cosθo &lt; 0。这种样本的权重应设为零。这种情况对应的是视界以下的镜面波瓣，是模型中能量损失的主要来源。显然，随着nu,nv 变得更大。</strong></p>
<p><strong>现在唯一剩下的事情是描述如何用(24.10)式的pdf生成h向量。我们首先生成h的球角在(θ， φ)∈[0，π/2 ]×[0, π/2 ］.注意，这只是半球的第一象限。给定两个随机数(ξ1,ξ2)均匀分布于[0,1]，我们可以选择</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028192451.png" class="" title="image-20211028192451">

<p><strong>然后根据φ的值得到θ</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028192517.png" class="" title="image-20211028192517">

<p><strong>为了采样整个半球，我们在ξ1 处使用标准操作根据它是否在[0,0.25)，[0.25,0.5)，[0.5,0.75)，或[0.75,1.0)，被映射到四种可能的函数之一。例如，ξ1∈[0.25,0.5)，求φ(1−4(0.5−ξ1)，然后绕φ = π/2轴“翻转”。这确保了全面覆盖和分层。</strong></p>
<p><strong>对于扩散项，使用一种更简单的方法，根据余弦分布生成样本。这足够接近完全扩散BRDF，从而大大减少了蒙特卡罗估计的方差。</strong></p>
<h1 id="25-Computer-Graphics-in-Games-游戏中的计算机图形"><a href="#25-Computer-Graphics-in-Games-游戏中的计算机图形" class="headerlink" title="25 Computer Graphics in Games 游戏中的计算机图形"></a>25 Computer Graphics in Games 游戏中的计算机图形</h1><p><strong>在计算机图形学的所有应用中，计算机和视频游戏是最吸引人的也许是最受关注的。为给定的游戏选择的图形方法，不仅会对游戏引擎代码产生深远影响，还会对美术资产产生深远影响，甚至是游戏玩法或核心游戏机制。</strong><br><strong>虽然游戏图像依赖于前一章的所有材质，其中，有两章尤为相关。游戏需要高效使用图形硬件，所以理解在第十七章在材质是重要的。</strong></p>
<p>  <strong>在本章中，我将详细介绍适用于图形的具体考虑游戏开发中的图形，从游戏运行的平台到游戏生产过程。</strong>  </p>
<h2 id="Platforms-平台"><a href="#Platforms-平台" class="headerlink" title="Platforms 平台"></a>Platforms 平台</h2><p><strong>在这里，我使用平台这个术语来指代特定的硬件组合和API(应用程序编程接口)为其中的游戏设计。游戏运行在各种平台上，包括虚拟平台机器用于浏览器为基础的游戏到专用的游戏控制台使用专业的硬件和API。</strong></p>
<p>  <strong>在过去，面向单一平台设计游戏是很常见的。随着游戏开发成本的增加，这种情况变越来越罕见;多平台游戏现在发展是常态。开发成本的增量增加支持多个平台的回报是潜在的两倍或三倍客户基础。</strong>  </p>
<p><strong>有些平台的定义相当松散。例如，当开发一个针对Windows PC平台的游戏，开发商必须占非常大的份额各种可能的硬件配置。游戏甚至被期望运行（运行良好）在游戏开发时不存在的PC配置上！这是唯一可能的，因为API提供了抽象定义Windows平台。</strong></p>
<p><strong>开发人员解释图形性能差异的一种方法是通过缩放调整图形质量响应系统的能力。这可以确保低端系统的合理性能，同时在高性能系统上实现有竞争力的视觉效果。这种调整是有时通过分析系统性能自动完成，但更多的这个控制是留给用户的，他们可以最好地判断自己的个人对质量和速度的偏好。显示分辨率是最容易调整的，伴随着抗锯齿质量降低。提供多种质量也是相当普遍的级别的视觉效果，如阴影和运动模糊，包括选项完全关闭效果。</strong></p>
<p>  <strong>图形性能的差异可能非常大，以至于一些机器可能不能以可玩的帧率运行游戏，即使是在最低质量设置下;  因为这个原因，PC游戏开发者发行了最低和推荐的机器配置为每个游戏。</strong>  </p>
<p><strong>作为平台，游戏主机有着严格的定义。在开发游戏时例如，对于任天堂的Wii主机，开发者清楚地知道它的硬件是什么游戏将继续进行。如果平台的硬件实现发生了变化(经常发生为了降低制造成本)，控制台制造商必须确保新实现的行为与前一个完全相同，包括计时和性能。这并不是说主机开发者的任务很简单;共同唯一的API往往更抽象，更接近底层硬件。这给主机开发带来了一系列困难。在某种意义上，多平台开发(通常至少包括两个不同的控制台，通常还有Windows)是最困难的，因为它是多平台的游戏开发者既没有固定平台的保证，也没有便利性一个高级API。</strong></p>
<p><strong>基于浏览器的虚拟机(如Adobe Flash)是一个有趣的类的游戏平台。虽然这样的虚拟机运行在一个广泛的硬类软件从个人电脑到手机，抽象程度高提供了一个稳定统一的虚拟机开发平台的形式。这些平台的相对容易的开发和巨大的池对游戏开发者来说，潜在用户的吸引力越来越大。然而，这些平台是由最小公分母定义的支持的硬件，和虚拟机的性能低于本地任何给定平台上的代码。由于这些原因，此类平台最适合对图像要求不高的游戏。</strong></p>
<p><strong>平台的特点还包括对开发的开放性是商业或法律上的区别，而不是技术上的区别。例如,Windows是开放的，因为开发工具是广泛可用的，而且没有把关人控制着进入Windows游戏市场。Apple的iPhone在某种程度上是一个受限的平台，因为所有应用程序都需要它通过认证程序和某些类别的申请是禁止的正确的。主机是最严格的游戏平台，对开发工具的访问受到严格控制。这在某种程度上是开放的引入更开放的在线游戏机游戏市场。一个最有趣的例子就是微软的Xbox LIVE社区游戏服务，其中开发工具是免费可用的，并且“把关”主要由同行评审来完成。通过此服务分发的游戏为了安全起见，必须使用Microsoft提供的虚拟机平台。</strong></p>
<p><strong>游戏平台决定了游戏体验的许多元素。为例如，PC游戏玩家使用键盘和鼠标，而主机游戏玩家使用特殊的游戏控制器。许多主机游戏都支持多人游戏主机，要么共享一个屏幕，要么为每个玩家提供一个窗口。由于很难共享键盘和鼠标，这种类型的游戏在PC上是找不到的。比触摸屏电话等一个手持游戏系统将有一个不同的控制方案。</strong></p>
<p><strong>尽管游戏平台千差万别，但还是有一些共同的趋势。大多数平台都有多个处理内核，分为通用内核(CPU)和图形专用(GPU)。随着时间的推移，性能的提高是主要原因增加核心数;个别核心业绩的增长幅度不大。像GPU内核在通用性上不断增长，GPU和CPU内核之间的界线越来越模糊。存储容量的增长速度往往比处理速度慢功率和通信带宽（核心之间以及每个核心与存储之间）的增长速度仍然较慢。</strong></p>
<h2 id="Limited-Resources-有限资源"><a href="#Limited-Resources-有限资源" class="headerlink" title="Limited Resources 有限资源"></a>Limited Resources 有限资源</h2><p>  <strong>游戏图形的主要挑战之一是需要管理多个图形有限的资源池。每个平台都对硬件资源（如处理时间、存储和内存带宽）施加了自己的限制。至少更高层次的发展资源也需要管理；有一个固定的尺寸由程序员、艺术家和游戏设计师组成的团队，完成时间有限这场比赛，希望没有太多的加班！这需要采取行动在决定采用哪种图形技术时要考虑到这一点。</strong></p>
<h3 id="Processing-Time-处理时间"><a href="#Processing-Time-处理时间" class="headerlink" title="Processing Time 处理时间"></a>Processing Time 处理时间</h3><p>  <strong>早期的游戏开发者只需要担心单个处理器的预算。  当前的游戏平台包含多个CPU和GPU内核。这些处理器,  为了避免死锁或过度，需要小心地同步处理。</strong>  </p>
<p>  <strong>由于单个呈现命令所消耗的时间是高度可变的，图形处理器通过命令与系统的其他部分解耦缓冲区。这个缓冲区充当一个队列;命令存储在一端，GPU从另一个GPU读取渲染命令。增加这个的缓冲大小降低GPU资源不足的可能性。这在游戏中是很常见的，缓冲整个帧的渲染命令值，然后将它们发送到GPU;这保证了GPU不会出现资源不足的情况。然而，这种方法需要为两个完整帧的命令预留足够的存储空间  (GPU在其中一个上工作，而CPU在另一个上存放命令)。它也增加了用户输入和显示之间的延迟，这对于快节奏的游戏来说是个问题。</strong></p>
<p><strong>处理预算由帧速率(即频率)，帧缓冲区会被场景的新渲染图刷新。固定平台(如主机)，用户体验到的帧率基本上是游戏开发者也看到了同样的情况，所以帧率限制是相当严格的实施。大多数游戏的帧率都是30帧每秒(fps);在游戏中在响应延迟特别重要的地方，目标通常是60帧/秒。在高度可变的平台(如pc)，帧速率预算（根据需要）定义更加宽松。</strong> </p>
<p>  <strong>所需的帧率给图形程序员一个固定的预算框架工作。在30fps的情况下，CPU核心有33毫秒时间来收集输入，处理游戏逻辑，执行任何物理模拟，遍历场景描述，并向图形硬件发送渲染命令。同时，其他任务，如音频和网络处理必须处理，有自己所需的响应时间。当这一切发生的时候，GPU通常会执行在上一阶段提交的图形命令框架。</strong>  </p>
<p>  **在大多数情况下，CPU核是一个同质资源;所有的核心都是一样的，它们中的任何一种都同样适合给定的工作量(有一些 例外情况，如索尼PLAYSTATION 3游戏机中使用的Cell处理器)。  **</p>
<p><strong>相反，GPU包含异构的资源组合，每一种都是特殊的变成了一套特定的任务。其中一些资源由固定功能组成硬件(用于三角形栅格化、alpha混合和纹理采样)  有些是可编程核心。在较老的GPU上，可编程核心更进一步区分为顶点和像素处理核;更新的GPU设计有统一着色器核心，可以执行任何可编程着色器类型。</strong></p>
<p><strong>这些异构资源是单独预算的。通常，在任何时候，只有一种资源类型会成为瓶颈，其他的资源类型会过剩。一方面，这是好事，因为这种能力可以被利用在不降低性能的情况下提高视觉质量。另一方面，使它更难提高性能，因为减少使用任何非瓶颈资源将没有影响。即使减少瓶颈资源的使用，也只能略微提高性能，具体取决于“下一个瓶颈”的利用率。</strong>  </p>
<h3 id="Storage-存储"><a href="#Storage-存储" class="headerlink" title="Storage 存储"></a>Storage 存储</h3><p>  <strong>游戏平台，像任何现代计算系统一样，拥有多级存储层次结构，顶部的内存类型更小、更快，而更大、更慢储存在底部。这种安排完全是出于工程需要尽管这让开发商的生活变得更加复杂。大多数平台包括光学磁盘存储，速度极慢，主要用于传输。在Windows等平台上，一次移动需要执行一个漫长的安装过程， 所有的数据从光盘到硬盘驱动器，速度明显加快。光盘将不再使用(除非作为反盗版措施)。在控制台平台，这是不常见的，尽管硬盘保证存在，就像在索尼的PLAYSTATION 3游戏机上一样。  更常见的情况是，硬盘驱动器（如果有）仅用作光盘驱动器的缓存圆盘。</strong>  </p>
<p>  <strong>内存层次结构的下一步是RAM，它在许多平台上都是分为一般系统RAM和VRAM(视频RAM)，得益于图形硬件的高速接口。在RAM中，游戏级别可能太大，在这种情况下，游戏开发人员需要管理移动数据根据需要进出RAM。在Windows等平台上，虚拟内存常用于此。在控制台平台上，自定义数据流和缓存系统通常被采用。</strong>  </p>
<p>  <strong>最后，CPU和GPU都拥有各种各样的片上内存和缓存。这些都是非常小和快速的，通常由图形API管理。</strong>  </p>
<p>  <strong>图形资源占用大量的内存，所以它们是游戏开发中的存储预算主要的焦点。纹理通常是最好的记忆消费者，其次是几何图形(顶点数据)，最后是其他类型的图形数据，如动画。并不是所有的内存都可以用于图形，音频也占用相当多的空间，游戏逻辑可能会使用相当大的数据结构。在这种情况下  在处理时间方面，预算在Windows上比较宽松，因为用户系统中存在的内存的确切数量是未知的和虚拟的，记忆能掩盖许多罪孽。相反，主机上的内存预算平台是非常严格的——通常主程序员会跟踪内存，电子表格和程序员需要更多的内存，因为他们的系统需要向别人乞讨、借或偷。</strong>  </p>
<p>  <strong>内存层次结构的不同层次不仅在大小上不同，而且在访问速度上也不同。这有两个独立的维度:延迟和带宽。</strong>  </p>
<p>  <strong>延迟是存储访问请求和最终请求之间所经过的时间满足。 这从几个时钟周期(对于芯片缓存)到数百万个时钟周期不等时钟周期(用于光盘上的数据)。 延迟通常是读取的问题访问(尽管如果需要读取结果，写延迟也可能是一个问题很快从记忆中恢复)。 在某些情况下，读请求是阻塞的意味着提交读操作的处理器核心不能做其他任何事情，直到请求履行。 在其他情况下，读取是非阻塞的; 处理核心是否可以提交读请求，做其他类型的处理，然后使用结果在它到达之后。 GPU访问纹理就是一个例子非阻塞读取; GPU设计的一个重要方面是找到“隐藏”的方法纹理读取时执行不相关的计算导致纹理读取延迟被实现了。</strong></p>
<p><strong>为了这个延迟隐藏工作，必须有足够的计算量相对于纹理访问。这是着色器的一个重要考虑事项;计算和纹理访问的最佳组合一直在变化（有利于更多的计算），因为内存无法跟上处理量的增加强度。</strong>  </p>
<p>  <strong>带宽是指与存储器之间的最大传输速率。它是通常以每秒十亿字节计算。</strong>  </p>
<h3 id="Development-Resources-开发资源"><a href="#Development-Resources-开发资源" class="headerlink" title="Development Resources 开发资源"></a>Development Resources 开发资源</h3><p>  <strong>除处理能力、存储空间等硬件资源外，存储系统还提供了硬件资源，游戏图像程序员还必须应对另一种限制资源——队友的时间!在选择图形技术时，实施每一项技术所需要的工程资源必须考虑到交流中以及计算输入数据所需的任何工具(在许多情况下，工具可能比实现技术本身花费更多的时间)。也许最重要的是，对艺术家生产力的影响必须考虑到计数。大多数图像技术使用的是由游戏美术人员创造的资产这是现代游戏团队中最大的组成部分。图形程序员必须培养艺术家的生产力和创造力，这将最终决定游戏的视觉质量。</strong>  </p>
<h2 id="Optimization-Techniques-优化技术"><a href="#Optimization-Techniques-优化技术" class="headerlink" title="Optimization Techniques 优化技术"></a>Optimization Techniques 优化技术</h2><p>  <strong>明智地使用这些有限的资源是游戏图形程序员的主要挑战。为此，各种优化技术是常见的。</strong>  </p>
<p>  <strong>在许多游戏中，像素着色器处理是主要的瓶颈。大多数GPU包含分层深度剔除硬件，可避免执行像素遮蔽表面上的着色器。为了更好地利用这种硬件，不透明的对象  可以颠倒过来。或者，最佳的深度筛选使用是通过执行深度预压实现，即将所有不透明对象呈现为渲染前的深度缓冲(没有任何颜色输出或像素着色器)  正常的场景。这确实会引起一些开销(由于需要渲染每个  对象两次)，但在许多情况下，性能增益是值得的。</strong>  </p>
<p>  <strong>渲染对象的最快方法是根本不渲染它;因此,任何方法早期识别物体被遮挡是有用的。这节省了除了像素处理，还有顶点处理，甚至是CPU将对象提交给图形API的时间。视图截锥剔除(见  章节8.4.1)是普遍使用的，但在许多游戏中这是不够的。利用数据结构，经常使用高级遮挡剔除算法例如PVS(潜在可见集)或BSP(二进制空间分区)树迅速缩小潜在可见物体的范围。</strong>  </p>
<p>  <strong>即使一个物体是可见的，它的大部分细节也可能因为距离太远而无法看到可以去除而没有明显的效果。LOD(细节层次)算法渲染基于距离(或其他因素，例如屏幕覆盖率或重要性)。这可以节省大量的处理，尤其是顶点处理。示例如下图所示。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029163858.png" class="" title="image-20211029163858">

<p>  这是两个具有不同细节级别的游戏对象的例子。小插图说明可以使用简化模型的相对尺寸。  </p>
<p>  <strong>在许多情况下，处理可以在游戏开始之前执行。这种预处理的结果可以存储和使用在每一帧，从而提高速度的游戏。最常用的是照明，在全局照明算法被用来计算整个场景的照明和存储在光照贴图和其他数据结构中，以供以后使用。</strong>  </p>
<h2 id="Game-Types-游戏类型"><a href="#Game-Types-游戏类型" class="headerlink" title="Game Types 游戏类型"></a>Game Types 游戏类型</h2><p>  <strong>由于游戏的要求千差万别，所以图像技术的选择也是如此受所开发游戏类型的驱动。</strong>  </p>
<p>  <strong>处理时间的分配很大程度上取决于帧速率。最近，大多数主机游戏的目标是每秒30帧，因为这使得游戏有更高的图像质量。然而，某些游戏类型具有快速的玩法需要非常低的延迟，这种游戏通常以60帧每秒的速度渲染。</strong>  </p>
<p>  <strong>这包括像《吉他英雄》这样的音乐游戏和第一人称射击游戏《使命召唤》。</strong>  </p>
<p>  <strong>帧率决定了渲染场景的可用时间。混合涂料,  场景本身的位置也因游戏而异。大多数游戏背景几何(风景，大多是静态的)和前景之间的一种划分几何学(人物和动态对象)。处理方式不同渲染引擎。例如，背景几何通常有光照贴图包含预计算的光照，这对前景对象是不可行的。预先计算的光照通常通过某种类型应用于前景对象体积表示，可以考虑每个位置的变化随着时间的推移对象。</strong>  </p>
<p>  <strong>有些游戏有相对封闭的环境，其中摄像机基本上是已经固定的。最纯粹的例子就是《华尔街》之类的格斗游戏《Fighter》系列，但在某种程度上这也适用于《Devil May Cry》和《战神》等游戏。这些游戏有摄像机，不受直接的玩家控制，游戏往往从一个封闭的环境移动到另一个封闭的环境，在每款游戏中投入大量时间。这允许游戏开发人员浪费大量资源(处理、存储和美工时间)  在每个房间或封闭的环境中，产生非常高水平的图形。</strong>  </p>
<p>  <strong>其他游戏拥有非常大的世界，玩家可以在其中自由移动。对于《侠盗猎车手》系列等“沙盒游戏”来说更是如此以及《魔兽世界》等在线角色扮演游戏。这样的游戏对图形开发人员是巨大的挑战，因为资源分配是非常困难的，因为在每一帧中，玩家都能看到广阔的世界。更复杂的事情是，玩家可以自由地去一些以前遥远的部分并近距离观察它。这类游戏通常有变化的时间这使得预先计算光照是不可能，也是非常困难的。</strong>  </p>
<p>  <strong>大多数游戏，如第一人称射击游戏，介于两者之间。玩家可以在每一帧中看到相当数量的场景，但移动除外整个游戏世界都是受限的。许多游戏也有固定的每个游戏关卡的一天时间，以方便照明预计算。</strong>  </p>
<p>  <strong>渲染的前景对象的数量在不同的游戏中也有很大的不同类型。实时策略游戏，如《命令与征服》系列在屏幕上有几十个，甚至上百个单位。其他类型的在格斗游戏中，可见角色的数量较为有限。另一个极端，只有两个角色可见，每个都呈现非常详细。必须区分角色在任何时间可见(影响处理时间的预算)和在短时间内可能可见的唯一角色的数量(这会影响存储预算)。</strong>  </p>
<p>  <strong>游戏的类型或类型也决定了观众对图形的期望。例如，第一人称射击游戏在历史上就拥有非常高的关卡图像保真度，这一期望推动着图像设计的发展这类型的新游戏;参见下图。另一方面，益智游戏拥有通常都有相对简单的图像，所以大多数游戏开发者不会在这类游戏的图像投入大量的编程或艺术资源来开发逼真的照片。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029165909.png" class="" title="image-20211029165909">

<p>  《孤岛危机》体现了第一人称射击游戏所期望的逼真和详细的图像。  图片由Crytek。  </p>
<p>  <strong>虽然大多数游戏的目标都是逼真的外观，但也有少数游戏做了更多尝试程式化的呈现。一个有趣的例子是《Okami》  如下图所示。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029170006.png" class="" title="image-20211029170006">

<p>  一个来自游戏《Okami》的高度风格化、非真实感渲染的例子。  图片由Capcom娱乐公司提供。  </p>
<p>  <strong>开发资源的管理也因游戏类型而异。大多数游戏的开发周期是1 - 2年，之后就结束了  游戏的发售。最近，可下载内容变得很普遍  (DLC)，可以在游戏发售后购买，因此需要为此保留一些开发资源。持久世界的网络游戏是一个永远不会结束不断生成新内容的开发过程，至少只要游戏具有经济可行性(这可能是几十年)。</strong>  </p>
<p>  <strong>创造性开发的具体要求和限制特定游戏是熟练的游戏图像程序员的特征。《小小大星球》便是一个例子，它拥有一个“2.5维”空间。游戏世界包含少量的二维层，以及一个非交互的背景。这款游戏的图像质量很好，通过使用专门针对此类环境的特殊渲染技术驱动;参见下图。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029170618.png" class="" title="image-20211029170618">

<p>  《小小大星球》的开发者仔细选择了适合游戏的技术限制条件，将它们以不同寻常的方式结合在一起，以达到惊人的效果。小小大星球©2007索尼电脑娱乐欧洲。由Media Molecule开发。小小大星球是一个商标索尼电脑娱乐欧洲。  </p>
<h2 id="The-Game-Production-Process-游戏制作流程"><a href="#The-Game-Production-Process-游戏制作流程" class="headerlink" title="The Game Production Process 游戏制作流程"></a>The Game Production Process 游戏制作流程</h2><p>  <strong>游戏制作过程始于基本的游戏设计或概念。在某些情况下(如续作)，基本玩法和视觉设计是清晰的，只有渐进式的改变。对于新游戏类型来说，需要大量的原型来决定游戏玩法和设计的必要元素。大多数情况下在中间的什么地方，其中有一些新的游戏元素，视觉设计有些开放。在这一步之后，可能会有一个绿灯阶段，将一些早期的演示版本或概念呈现给游戏发行商以获得批准（和资金！）。</strong>  </p>
<p>  <strong>下一步通常是预制作。而其他团队正在工作在完成最后一款游戏时，一个小型核心团队负责制作任何需要的内容改变游戏引擎和制作工具链，以及解决任何新玩法元素的粗略细节。这个核心团队是在严格的期限。在现有的游戏发行和团队的其他成员回来之后，从一个应得的假期，整个工具链和引擎必须准备好。如果核心团队错过了这一期限，可能会有几十名开发人员无所事事——一个极其昂贵的提议!</strong>  </p>
<p>  <strong>下一步是完整的制作，与整个团队创造美术资产，设计关卡，调整游戏玩法，并进一步改变游戏引擎。在一个完美的世界里，在这个过程中所做的一切都将被用于这是最终的游戏，但实际上游戏开发具有迭代性质这将导致一些工作被丢弃和重做。我们的目标是通过仔细的规划和原型设计将其最小化。</strong>  </p>
<p>  <strong>当游戏功能完成时，最后一个阶段就开始了。Alpha版本通常是指标志着扩展开始的版本内部测试，beta版的发布标志着外部扩展的开始测试，从黄金版到最终版提交给主机制造商，但不同的公司对这些术语的定义略有不同。无论如何案例、测试或质量保证（QA）是该阶段的重要组成部分，并且包括游戏开发工作室、发行商和控制台的测试人员制造商，可能还有外部QA承包商。这些不同的回合测试结果的错误报告将提交给游戏开发者一直工作到下一个版本。</strong>  </p>
<p>  <strong>游戏发行后，大多数开发者会去度假，但是一个小团队可能不得不留下来开发补丁或可下载内容。与此同时，一个小型核心团队正在为下一款游戏进行前期制作。</strong>  </p>
<p>  <strong>美术资产创造是游戏制作的一个重要方面到图形开发，所以将详细介绍。</strong> </p>
<h3 id="Asset-Creation-资产创造"><a href="#Asset-Creation-资产创造" class="headerlink" title="Asset Creation 资产创造"></a>Asset Creation 资产创造</h3><p>  <strong>虽然美术资产创造的确切过程因游戏而异，但其轮廓却不尽相同，我在这里给的都是相当有代表性的。在过去，一个艺术家可以创造整个资产从开始到结束，但这个过程现在更加专业化了，让拥有不同技能的人在不同的时间处理不同的资产。有些阶段有明显的依赖性(例如，角色就不能被删除，需要有动画它才能被操纵，它被建模之前不能被操纵)。大多数游戏  开发者有明确的审批流程，其中包括艺术总监或主管美工在每个阶段签字，才将资产发送到下一个阶段。理想情况下一个资产在每个阶段只进行一次，但在实践中可能会发生变化要求重新提交。</strong>  </p>
<h4 id="Initial-Modeling-最初的建模"><a href="#Initial-Modeling-最初的建模" class="headerlink" title="Initial Modeling   最初的建模"></a>Initial Modeling   最初的建模</h4><p>  <strong>通常情况下，美术资产创建过程是从对象几何建模开始的。这一步是在通用建模包中执行的，例如Maya， MAX或Softimage。建模的几何图形将直接传递给游戏引擎，因此，在保持良好的轮廓的同时，最小化顶点数是很重要的。角色网格也必须被构建，以便制作动画。</strong>  </p>
<p>  <strong>在此阶段，通常会创建纹理的二维曲面参数化。这一参数化必须高度连续，因为<br>不连续性要求顶点重复，并可能导致过滤瑕疵。网格及其相关纹理参数化示例如下图所示。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029183652.png" class="" title="image-20211029183652">

<p>一个网格模型在Maya，与相关的纹理参数化。</p>
<h3 id="Texturing-纹理"><a href="#Texturing-纹理" class="headerlink" title="Texturing  纹理"></a>Texturing  纹理</h3><p>  <strong>在过去，纹理通常是在Photoshop中绘制彩色纹理的简单过程。现在，专门的细节建模包，如ZBrush或Mudbox通常用于雕刻精细的表面细节。下两图和展示这个过程的一个例子。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184059.png" class="" title="image-20211029184059">

<p>  上图中的网格被引入ZBrush中进行细节建模。  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184120.png" class="" title="image-20211029184120">

<p>  上图中的网格，在ZBrush中添加了精细的细节。 </p>
<p>  <strong>如果这个额外的细节用实际的几何学来表示，需要几百万三角形。相反，细节通常“烘培”成法线贴图被应用到原始的粗网格上，如下两图。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184455.png" class="" title="image-20211029184455">

<p>  一个可视化(在ZBrush)的网格从上上图，渲染法线源自上图中的详细网格。图的底部显示了为ZBrush的“Zmapper”工具，用于导出法线贴图。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184508.png" class="" title="image-20211029184508">

<p> 上图中使用的法线贴图。在这张图片中，红色、绿色和蓝色的通道的纹理包含表面法线的X, Y和Z坐标。</p>
<p>  <strong>除了法线贴图，还有多个纹理包含表面属性，如漫反射颜色、镜面颜色和平滑度(镜面强度)也被创建。这些要么是直接绘制在表面上的细节建模应用程序，或者在二维应用程序，如Photoshop。所有这些纹理贴图使用在初始建模阶段定义的表面参数化。当肌理是在二维绘画中应用的，艺术家必须频繁地在绘画应用和其他应用之间切换，可以显示物体的三维渲染与应用纹理。这个迭代过程如下列一系列图所示。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184955.png" class="" title="image-20211029184955">

<p>  上上图中网格的漫反射颜色纹理的早期版本，如图所示Photoshop。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029185010.png" class="" title="image-20211029185010">

<p>  一个渲染(在ZBrush)的网格法线贴图和早期漫反射颜色纹理  (由上图)适用。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029185024.png" class="" title="image-20211029185024">

<p>  颜色纹理的最终版本来自上上图。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029185037.png" class="" title="image-20211029185037">

<p>  使用法线贴图和最终颜色纹理渲染网格(来自上图)  应用。</p>
<h4 id="Shading-着色-1"><a href="#Shading-着色-1" class="headerlink" title="Shading 着色"></a>Shading 着色</h4><p>  <strong>着色器通常应用于与初始建模相同的应用程序中。在这个过程中，将应用着色器（来自为该游戏定义的着色器集）到网格。细节建模阶段产生的各种纹理如下所示：使用在过程中定义的曲面参数化作为该着色器的输入应用初始建模。通过视觉实验设置各种其他着色器输入（“调整”）；见下图</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029185551.png" class="" title="image-20211029185551">

<p>  Maya中的着色器配置。右边的界面用来选择着色器，将纹理分配给着色器输入，并设置非纹理着色器输入的值(例如“Specular”颜色”和“Specular Power”滑块)。左边的呈现是动态更新的修改，可以立即获得视觉反馈。</p>
<h4 id="Lighting-照明"><a href="#Lighting-照明" class="headerlink" title="Lighting 照明"></a>Lighting 照明</h4><p><strong>在背景场景中，在完成建模、纹理和着色后，灯光艺术家通常会开始他们的工作。光源是在预处理步骤中放置并计算其效果。此过程的结果存储在光照贴图中，供渲染引擎稍后使用。</strong></p>
<h4 id="Animation-动画"><a href="#Animation-动画" class="headerlink" title="Animation 动画"></a>Animation 动画</h4><p><strong>角色网格将经历与动画相关的几个附加步骤。用于设置游戏角色动画的主要方法是蒙皮。这需要一个rig，由附加到角色的变换节点的层次结构组成，该过程称为装配。将绘制每个变换节点的效果区域在网格顶点的子集上。最后，动画师创建移动的动画，旋转并缩放这些变换节点，“拖动”它们后面的网格。</strong></p>
<p><strong>一个典型的游戏角色将有几十个动画，对应于不同的运动模式（行走、跑步、转弯）以及不同的动作攻击等行为。对于主要角色，动画的数量可能有几百个。不同动画之间的过渡也需要进行调整定义。</strong><br><strong>对于面部动画，另一种称为“变形目标”的技术有时会被使用。在该技术中，直接操纵网格顶点以使其变形网格。存储变形网格的不同副本（例如，对于不同的面部表情），并在运行时由游戏引擎组合。创造变形目标如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029190132.png" class="" title="image-20211029190132">

<p>  Maya中的变形目标界面。底行显示四个不同的变形目标，顶部的模型显示了将多个变形目标组合在一起的效果。接口左上角用于控制应用每个变形目标的程度。</p>
<h1 id="26-Visualization-可视化"><a href="#26-Visualization-可视化" class="headerlink" title="26 Visualization 可视化"></a>26 Visualization 可视化</h1><p><strong>计算机图形学的一个主要应用领域是可视化，其中计算机生成的图像被用来帮助人们理解空间和非空间数据。当目标是在问题定义不充分、计算机无法通过算法处理的情况下增强人类的能力时，就会使用可视化。如果一个完全自动化的解决方案可以完全取代人类的判断，那么可视化通常就不需要了。可视化可以用于在探索完全不熟悉的数据集时生成新的假设，在部分理解的数据集中确认现有假设，或者向其他观众展示已知数据集的信息。</strong></p>
<p><strong>视觉化让人们把认知卸给感知系统，使用精心设计的图像作为外部记忆的一种形式。人类的视觉系统是通往大脑的一个非常高带宽的通道，有大量的处理是在前意识水平平行发生的。因此，我们可以用外部图像来代替对自己头脑中事物的追踪。举个例子，让我们考虑一下理解《G¨model, Escher, Bach: the Eternal Golden Braid》(Hofstadter, 1979)一书中一些主题子集之间的关系;参见下图。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029235929.png" class="" title="image-20211029235929">

<p>使用文本列表来记录主题之间的关系是很困难的。</p>
<p><strong>当我们把数据集看作一个文本列表时，在低水平时，我们必须阅读单词，并将它们与之前阅读的单词的记忆进行比较。仅凭认知和记忆很难追踪这十几个主题，更不用说整本书中的数百个主题了。更高层次的识别社区的问题，例如找到所有距离目标主题悖论两步远的主题，是非常困难的。</strong></p>
<p><strong>下图以节点链接图的形式显示了相同数据集的外部可视化表示，其中每个主题都是一个节点，两个主题之间的链接直接用一条线显示。通过在图像周围移动我们的眼睛来跟随线条是一种快速、低水平的操作，具有最小的认知负荷，因此更高层次的邻居发现成为可能。节点的位置和它们之间的链接路径是由点图绘制程序自动创建的(Gansner, Koutsofois, North， &amp; Vo, 1993)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029235951.png" class="" title="image-20211029235951">

<p>用感知代替认知和记忆，我们就能理解关系快速在书的主题之间切换。</p>
<p><strong>我们将数据集属性到可视化表示的映射称为可视化编码。可视化的核心问题之一是从可能的视觉表示的巨大空间中选择合适的编码，同时考虑到人类感知系统的特征、存在问题的数据集和手头的任务。</strong></p>
<h2 id="Background-背景"><a href="#Background-背景" class="headerlink" title="Background 背景"></a>Background 背景</h2><h3 id="History-历史"><a href="#History-历史" class="headerlink" title="History 历史"></a>History 历史</h3><p><strong>人们通过静态图像传达意义的历史悠久，可以追溯到3万多年前已知的最古老的洞穴壁画。今天，我们继续以各种方式进行视觉交流，从餐巾背面的草图到光滑的广告平面设计。几千年来，制图师们一直在研究如何绘制能代表我们周围世界某些方面的地图。18世纪，William Playfair (Friendly, 2008)首次创造了抽象、非空间数据集的视觉表示。</strong></p>
<p><strong>尽管我们已经有能力创建动态图像超过150年，交互式创建动态图像是最近的发展，只有在过去几十年快速计算机图形硬件和算法的广泛可用性才成为可能。微小数据集的静态可视化可以手工创建，但计算机图形使大数据集的交互式可视化成为可能。</strong></p>
<h3 id="Resource-Limitations-资源限制"><a href="#Resource-Limitations-资源限制" class="headerlink" title="Resource Limitations 资源限制"></a>Resource Limitations 资源限制</h3><p><strong>在设计可视化系统时，我们必须考虑三种不同的限制:计算能力、人类感知和认知能力以及显示能力。</strong></p>
<p><strong>与任何计算机图形的应用程序一样，计算机时间和内存是有限的资源，我们经常有硬约束。如果可视化系统需要提供交互式响应，那么它必须使用能够在几分之一秒而不是几分钟或几小时内运行的算法。</strong></p>
<p><strong>在人类方面，记忆和注意力必须被认为是有限的资源。众所周知，人类的记忆是有限的，无论是长期回忆还是短期工作记忆。在本章的后面，我们将讨论一些低水平视觉注意机制的能力和局限性，这些机制执行了大量的视野平行处理。令人惊讶的是，我们在视觉工作记忆中内部存储的信息很少，这让我们很容易发生变化盲视(change blindness)，这种现象是，如果我们在关注我们认为的其他事情，即使是非常大的变化也不会被注意到(Simons, 2000)。此外，警惕也是一种非常有限的资源;我们执行视觉搜索任务的能力迅速下降，几个小时后的结果比最初几分钟的结果差得多(Ware, 2000)。</strong></p>
<p><strong>显示能力是要考虑的第三种限制。可视化设计人员经常“用光像素”，因为屏幕的分辨率不够大，无法同时显示所有所需信息。特定帧的信息密度是编码的信息量与未使用空间的比值。同时显示尽可能多的内容(以最小化导航和探索的需求)和同时显示过多内容(用户会被视觉混乱所淹没)的成本之间存在权衡。</strong></p>
<h2 id="Data-Types-数据类型"><a href="#Data-Types-数据类型" class="headerlink" title="Data Types 数据类型"></a>Data Types 数据类型</h2><p><strong>可视化设计的许多方面是由我们需要查看的数据类型驱动的。例如，它是一个数字表，还是一组项目之间的关系，或固有的空间数据，如地球表面的位置或文档的集合?</strong></p>
<p><strong>我们首先考虑一个数据表。我们称行为数据项，列为维度，也称为属性。例如，行可能表示人，列可能是姓名、年龄、身高、衬衫尺寸和喜欢的水果。</strong></p>
<p><strong>我们区分了三种类型的维度:定量的、有序的和分类的。数量数据，如年龄或身高，是数值的，我们可以对其进行计算。例如，68英寸减去42英寸等于26英寸。对于有序的数据，比如衬衫尺寸，我们无法进行完整的运算，但有一个明确定义的顺序。例如，大减去中不是一个有意义的概念，但我们知道中介于小和大之间。分类数据，比如喜欢的水果或名字，没有隐式的排序。我们只能区分两个东西是相同的(苹果)还是不同的(苹果vs香蕉)。</strong></p>
<p><strong>关系数据或图形是另一种数据类型，其中节点通过链接连接。一种特定的图是树状图，它通常用于分层数据。节点和边都可以有关联的属性。不幸的是，单词图在可视化方面超载了。我们在这里讨论的节点-链接图，按照图论和图绘制的术语，也可以称为网络。在统计图形领域，graph常用于chart，如图26.10所示的时间序列数据折线图。</strong></p>
<p><strong>有些数据本质上是空间的，比如地理位置或三维空间的测量场，如医生用来查看人体内部结构的MRI或CT扫描。的信息,与空间中的每个点相关联的可能是标量、索引向量或张量的无序集合。相反，非空间数据可以使用空间位置进行可视化编码，但是这种编码是由设计人员选择的，而不是在数据集本身的语义中隐式给出的。这个选择是可视化设计中最核心和最困难的问题之一。</strong></p>
<h3 id="Dimension-and-Item-Count-尺寸和项目计数"><a href="#Dimension-and-Item-Count-尺寸和项目计数" class="headerlink" title="Dimension and Item Count 尺寸和项目计数"></a>Dimension and Item Count 尺寸和项目计数</h3><p><strong>需要可视化编码的数据维的数量是可视化设计问题的最基本方面之一。适用于只有几个列的低维数据集的技术，在具有几十或数百列的非常高维数据集上通常会失败。数据维可能具有层次结构，例如时间序列数据集在多个时间尺度上有有趣的模式。</strong></p>
<p><strong>数据项的数量也很重要:对于几百项表现良好的可视化通常不能扩展到数百万项。在某些情况下，难度纯粹是算法上的，计算时间太长;在另一些情况下，这是一个更深层次的感知问题，即使是瞬时算法也无法解决，即视觉混乱会让人无法使用表征。维度中可能值的范围也可能是相关的。</strong></p>
<h3 id="Data-Transformation-and-Derived-Dimensions-数据转换和派生维度"><a href="#Data-Transformation-and-Derived-Dimensions-数据转换和派生维度" class="headerlink" title="Data Transformation and Derived Dimensions 数据转换和派生维度"></a>Data Transformation and Derived Dimensions 数据转换和派生维度</h3><p><strong>作为解决领域问题的可视化管线的一部分，数据经常从一种类型转换为另一种类型。例如，原始数据维可能由定量数据组成:表示温度的浮点数。对于某些任务，比如寻找当地天气模式的异常，原始数据可能会被直接使用。对于另一个任务，比如决定淋浴的水温是否合适，数据可能被转换为一个有序的维度:热、暖或冷。在此转换中，大部分细节都被聚合。在第三个例子中，当烤面包时，一个更有损的转换到分类维度可能就足够了:烤焦或不烤焦。</strong></p>
<p><strong>将数据转换为派生维的原则，而不是简单地以原始形式可视化地编码数据，是一个强大的想法。在图26.10中，原始数据是时间序列曲线的有序集合。这种转换是对数据进行聚类，减少信息量，将其可视化编码为一些高度有意义的曲线。</strong></p>
<h2 id="Human-Centered-Design-Process-以人为本的设计过程"><a href="#Human-Centered-Design-Process-以人为本的设计过程" class="headerlink" title="Human-Centered Design Process 以人为本的设计过程"></a>Human-Centered Design Process 以人为本的设计过程</h2><p><strong>可视化设计过程可以分解为层叠的层集，如下图所示。这些层都是相互依赖的;上面一层的输出被输入到下面一层。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105033.png" class="" title="image-20211030105033">

<p>用于可视化的四个嵌套验证层。</p>
<h3 id="Task-Characterization-任务描述"><a href="#Task-Characterization-任务描述" class="headerlink" title="Task Characterization 任务描述"></a>Task Characterization 任务描述</h3><p><strong>一个给定的数据集有许多可能的可视编码。选择使用哪种视觉编码可以根据某些预期用户的特定需求进行指导。不同的问题或任务需要不同的视觉编码。例如，考虑软件工程领域。图26.11所示的Tarantula接口很好地支持理解测试套件覆盖率的任务。然而，在重构代码的同时理解软件的模块化分解的任务可能会通过更直接地以节点链接图的形式显示其层次结构来更好地完成。</strong></p>
<p><strong>理解某些目标受众的需求是一个棘手的问题。在以人为中心的设计方法中，可视化设计师随着时间的推移与一组目标用户一起工作(C. Lewis &amp; Rieman, 1993)。在大多数情况下，用户知道他们需要以某种方式查看他们的数据，但不能直接将他们的需求作为对数据类型操作的明确任务。迭代设计过程包括通过采访和观察目标用户的工作，从他们那里收集关于问题的信息，创建原型，并观察用户如何与这些原型进行交互，以了解所提议的解决方案实际工作情况。需求分析的软件工程方法论也很有用(Kovitz, 1999)。</strong></p>
<h3 id="Abstraction-抽象"><a href="#Abstraction-抽象" class="headerlink" title="Abstraction 抽象"></a>Abstraction 抽象</h3><p><strong>在第一层中确定特定领域问题之后，下一层需要将其抽象为更通用的表示，作为操作上一节讨论的数据类型。来自非常不同领域的问题可以映射到相同的可视化抽象。这些通用操作包括排序、过滤、特征趋势和分布、发现异常和异常值以及发现相关性(Amar, Eagan， &amp; Stasko, 2005)。它们还包括特定于特定数据类型的操作，例如以图或树的形式跟踪关系数据的路径。</strong></p>
<p><strong>这个抽象步骤通常涉及到从原始数据到派生维的数据转换。这些派生维的类型通常与原始数据不同:图可以转换为树，表格数据可以通过使用阈值来决定是否应该基于字段值存在链接，从而转换为图，等等。</strong></p>
<h3 id="Technique-and-Algorithm-Design-技术与算法设计"><a href="#Technique-and-Algorithm-Design-技术与算法设计" class="headerlink" title="Technique and Algorithm Design 技术与算法设计"></a>Technique and Algorithm Design 技术与算法设计</h3><p><strong>一旦选择了抽象，下一层就是设计适当的视觉编码和交互技术。第26.4节介绍了视觉编码的原则，我们将在第26.5节讨论交互原则。我们将在26.6和26.7节介绍考虑这些原则的技术。</strong></p>
<p><strong>不幸的是，可视化算法的详细讨论超出了本章的范围。</strong></p>
<h3 id="Validation-验证"><a href="#Validation-验证" class="headerlink" title="Validation 验证"></a>Validation 验证</h3><p><strong>这四层中的每一层都有不同的验证需求。</strong></p>
<p><strong>第一层被设计用来确定问题是否被正确的字符化:是否真的有目标受众在执行特定的任务，从而从所建议的工具中获益?测试假设和猜想的一个直接方法是观察或采访目标受众，以确保可视化设计师完全理解他们的任务。在构建和部署工具之前，无法进行的度量是监视其在社区中的采用率，当然，除了效用之外，还有许多其他因素会影响采用率。</strong></p>
<p><strong>下一层用于确定从域问题抽象到特定数据类型的操作是否真正解决了所需的问题。在原型或成品工具部署完成后，可以进行实地研究，以观察其目标用户是否以及如何使用它。此外，该系统产生的图像可以进行定性和定量分析。</strong></p>
<p><strong>第三层的目的是验证设计师所选择的视觉编码和交互技术是否能够有效地传达所选择的内容抽象到用户。一个直接的测试是证明个人的设计选择没有违反已知的感知和认知原则。这样的理由是必要的，但不是充分的，因为可视化设计涉及交互选择之间的许多权衡。系统建成后，可以通过正式的实验室研究对其进行测试。在实验室研究中，许多人被要求完成分配的任务，这样就可以对他们完成任务所需的时间和错误率进行统计分析。</strong></p>
<p><strong>第四层用于验证设计用于进行编码和交互选择的算法比以前的算法更快或占用更少的内存。一个直接的测试是分析所提出算法的计算复杂度。实现后，可以直接测量系统的实际时间性能和内存使用情况。</strong></p>
<h2 id="Visual-Encoding-Principles-视觉编码原理"><a href="#Visual-Encoding-Principles-视觉编码原理" class="headerlink" title="Visual Encoding Principles 视觉编码原理"></a>Visual Encoding Principles 视觉编码原理</h2><p><strong>我们可以将视觉编码描述为图形元素，称为标记，通过视觉渠道传递信息。一个零维度的标记是一个点，一个一维的标记是一条线，一个二维的标记是一个区域，一个三维的标记是一个体积。许多视觉通道可以编码信息，包括空间位置、颜色、大小、形状、方向和运动方向。可以使用多个视觉通道同时编码不同的数据维度;例如，下图显示了如何使用水平和垂直空间位置、颜色和大小来显示四个数据维度。可以使用多个通道对相同的维度进行冗余编码，这样可以显示更少的信息，但显示得更清楚。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105453.png" class="" title="image-20211030105453">

<p>水平和垂直空间位置、颜色和大小这四个视觉通道被用于在散点图图中编码信息。</p>
<h3 id="Visual-Channel-Characteristics-视觉通道特征"><a href="#Visual-Channel-Characteristics-视觉通道特征" class="headerlink" title="Visual Channel Characteristics 视觉通道特征"></a>Visual Channel Characteristics 视觉通道特征</h3><p><strong>视觉通道的重要特征是可区分性、可分离性和弹出性。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105754.png" class="" title="image-20211030105754">

<p>我们感知由视觉通道编码的信息的能力取决于所使用的数据类型，从最准确的顶部到最不准确的底部。</p>
<p><strong>通道并非都是同样可分辨的。人们已经进行了许多心理物理实验，以测量人们对不同视觉通道编码的信息进行精确区分的能力。我们的能力取决于数据类型是定量的、有序的还是分类的。上图显示了这三种数据类型的可视通道的排名。下图显示了Tableau/Polaris系统中可视通道的一些默认映射，其中考虑了数据类型。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105807.png" class="" title="image-20211030105807">

<p>根据数据类型，Tableau/Polaris系统默认映射四个可视通道。</p>
<p><strong>空间位置是三种数据最精确的视觉通道，它主导着我们对视觉编码的感知。因此，两个最重要的数据维度通常映射到水平和垂直空间位置。</strong></p>
<p><strong>然而，其他通道在不同类型之间有很大差异。长度和角度的通道对定量数据的识别能力强，而对有序和分类数据的识别能力差;对比色度对分类数据的识别能力强，对定量数据的识别能力差。</strong></p>
<p><strong>我们必须始终考虑显示数据维所需的动态范围和通道中可用的动态范围之间是否存在良好的匹配。例如，线宽编码使用一维标记和尺寸通道。有宽度有限数量的步骤,我们可以可靠地使用视觉编码信息:至少瘦实施一个像素的屏幕分辨率(忽略反锯齿简化讨论),还有一个最大厚度超过这个对象将被视为一个多边形而不是一条直线。行宽可以很好地在一个数据维中显示3或4个不同的值，但对于数十或数百个值来说，它将是一个糟糕的选择。</strong></p>
<p><strong>有些视觉通道是完整的，在前意识水平上融合在一起的，所以它们不是对不同数据维度进行视觉编码的好选择。另一些是可分离的，在视觉处理过程中它们之间没有交互，可以安全地用于编码多个维度。下图显示了两个通道对。颜色和位置是高度可分的。我们可以看到，水平尺寸和垂直尺寸并不容易区分，因为我们的视觉系统会自动将它们整合到一个统一的区域感知中。大小与许多通道相互作用:随着对象的大小变得更小，它变得更难以区分其形状或颜色。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105906.png" class="" title="image-20211030105906">

<p>颜色和位置是可分离的通道，非常适合编码不同的数据维，但水平大小和垂直大小的通道会自动融合到区域的集成感知中。</p>
<p><strong>我们可以有选择地关注一个通道，这样特定类型的项目就可以直观地“弹出”，如第20.4.3节所述。视觉弹出的一个例子是，当我们立即在蓝色物品的海洋中发现红色物品，或区分圆圈和正方形。可视化弹出窗口功能强大且可扩展，因为它是并行出现的，不需要逐个处理条目。许多视觉通道都有这种弹出属性，不仅包括上面的列表，还包括曲率、闪烁、立体深度，甚至照明方向。然而，通常情况下，我们一次只能在一个频道上使用弹出窗口。例如，白色圆圈不会从一组可以是白色或黑色的圆圈和方形中弹出，如图20.46所示。当我们需要同时搜索多个通道时，找到目标对象所需的时间与场景中目标的数量成线性关系。</strong></p>
<h3 id="Color-颜色-2"><a href="#Color-颜色-2" class="headerlink" title="Color 颜色"></a>Color 颜色</h3><p><strong>色彩可以是一个非常强大的通道，但许多人不了解它的属性，并使用不当。正如在第20.2.2节中讨论的，我们可以从三个独立的视觉通道来考虑颜色:色相、饱和度和亮度。区域的大小强烈影响我们对颜色的感知能力。小区域的颜色相对难以感知，设计师应该使用明亮、高度饱和的颜色，以确保颜色编码的可识别性。相反的情况是真实的彩色区域是大的，如在背景，低饱和度蜡笔颜色应该使用，以避免观众眼花。</strong></p>
<p><strong>Hue是对分类数据进行编码的有力线索。然而，可用的动态范围是非常有限的。当彩色区域很小且分散在显示器周围时，人们可以可靠地分辨出大约十几个色调。色彩编码的一个很好的指导原则是，类别的数量不要超过8个，记住背景和中性物体的颜色也要算在内。</strong></p>
<p><strong>对于有序数据，亮度和饱和度是有效的，因为它们有一种隐含的感知顺序。人们可以可靠地根据亮度排序，总是把灰色置于黑白之间。在饱和度方面，人们肯定会把不太饱和的粉色放在完全饱和的红色和零饱和的白色之间。然而，色调并不是有序数据的好通道，因为它没有隐含的感知顺序。当被要求对红色、蓝色、绿色和黄色进行排序时，人们并没有给出相同的答案。人们可以也确实学会了惯例，比如交通灯的黄绿红，或者彩虹的颜色顺序，但这些构建都处于一个高于纯粹感知的层次上。有序数据通常用一组离散的颜色值显示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030110331.png" class="" title="image-20211030110331">

<p>标准的彩虹色图有两个缺陷:它使用色相来表示顺序，并且它在感知上不是等线性的。图片由Bernice Rogowitz提供。</p>
<p><strong>定量数据用颜色图显示，颜色值的范围可以是连续的或离散的。在许多软件包中，一个非常不幸的默认值是rainbow彩图，如上图所示。标准的彩虹刻度存在三个问题。首先，色调用来表示秩序。更好的选择是使用亮度，因为它有一种隐含的感知顺序。更重要的是，人眼对亮度的反应最为强烈。第二，这个尺度在感知上不是线性的:在连续范围内的相等步数并不被我们的眼睛感知为相等步数。上图显示了一个示例，其中彩虹色图模糊了数据。从−2000到−1000的范围有三种不同的颜色(青色、绿色和黄色)，而从−1000到0的相同大小的范围看起来完全是黄色的。右边的图表显示，感知价值与亮度紧密相关，亮度在这个尺度上甚至不是单调增加的。</strong></p>
<p><strong>相比之下，下图显示了相同的数据，但使用了更合适的颜色图，亮度单调地增加。Hue用于创建语义上有意义的分类:查看器可以讨论数据集中的结构，如深蓝色的海、青色的大陆架、绿色的低地和白色的山脉。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030110428.png" class="" title="image-20211030110428">

<p>同样的数据集的结构是更加清晰的彩色地图，单调增加的亮度是用来显示秩序，而色调是用来分割分类区域。图片由Bernice Rogowitz提供。</p>
<p><strong>在离散和连续的情况下，颜色图应该考虑数据是连续的还是发散的。ColorBrewer应用程序(<a target="_blank" rel="noopener" href="http://www.colorbrewer.org)是构建颜色图的优秀资源/">www.colorbrewer.org)是构建颜色图的优秀资源</a>(Brewer, 1999)。</strong></p>
<p><strong>用颜色编码的另一个重要问题是，相当一部分人，大约10%的男性，存在红绿颜色缺陷。如果由于目标域中的约定而选择了使用红色和绿色的编码，请重新除了色调之外，用冗余编码亮度或饱和度是明智的。对于色觉有缺陷的人来说，应该使用像<a target="_blank" rel="noopener" href="http://www.vischeck.com这样的工具来检查配色方案是否容易被识别./">http://www.vischeck.com这样的工具来检查配色方案是否容易被识别。</a></strong></p>
<h3 id="2D-vs-3D-Spatial-Layouts-2D-VS-3D空间布局"><a href="#2D-vs-3D-Spatial-Layouts-2D-VS-3D空间布局" class="headerlink" title="2D vs. 3D Spatial Layouts 2D VS 3D空间布局"></a>2D vs. 3D Spatial Layouts 2D VS 3D空间布局</h3><p><strong>空间定位是采用二通道还是三通道的问题已经得到了广泛的研究。20世纪80年代末，当基于计算机的可视化开始时，交互式3D图形是一种新的能力，人们对3D表示有很大的热情。随着该领域的成熟，研究人员开始理解用于抽象数据集的3D方法的成本(Ware, 2001)。</strong></p>
<p><strong>遮挡，即数据集的一些部分隐藏在其他部分后面，是3D的一个主要问题。虽然隐藏的表面去除算法，如z缓冲区和BSP树，允许快速计算正确的二维图像，人们仍然必须将许多这些图像合成到一个内部的心理地图。当人们看到由熟悉的物体制成的真实场景时，通常他们能很快理解所看到的东西。然而，当他们看到一个不熟悉的数据集时，选择的视觉编码将抽象维度映射到空间位置，理解其3D结构的细节可能是具有挑战性的，即使他们可以使用交互式导航控件来改变他们的3D视图。原因再次是人类工作记忆的有限容量(Plumlee &amp; Ware, 2006)。</strong></p>
<p><strong>3D的另一个问题是透视失真。虽然现实世界中的物体在离我们的眼睛较远的时候确实显得更小，但透视缩短使得直接比较物体的高度变得困难(Tory, Kirkpatrick, Atkins， &amp; M¨oller, 2006)。再次强调，尽管我们经常可以根据过去的经验判断现实世界中熟悉的物体的高度，但我们不一定可以用具有视觉编码的完全抽象的数据来判断高度。例如，在3D条形图中判断条形高度比在多个水平对齐的2D条形图中更难。</strong></p>
<p><strong>无约束3D表示的另一个问题是，在3D空间中任意方向的文本比在2D图像平面中对齐的文本更难阅读(Grossman, Wigdor， &amp; Balakrishnan, 2007)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030110927.png" class="" title="image-20211030110927">

<p>上图:这个时间序列数据集的3D表示引入了遮挡和透视失真的问题。底部:派生的聚合曲线和日历的链接2D视图允许直接比较，并显示更细粒度的模式。图片由Jarke van Wijk (van Wijk &amp; van Selow, 1999)提供，©1999 IEEE。</p>
<p><strong>上图说明了精心选择的抽象数据集的2D视图如何避免3D视图中固有的遮挡和透视失真问题。俯视图显示了直接从原始时间序列数据创建的3D表示，其中每个横截面是一个2D时间序列曲线，显示一天的功耗，沿着挤压的第三轴，一年中的每一天都有一条曲线。虽然这种表现方式很容易创建，但我们只能看到大规模的模式，如工作时间的更高消费和冬季和夏季之间的季节性变化。为了在底部创建2D链接视图，曲线是分层聚集的，在同一个2D框架中只绘制代表顶部集群的聚合曲线。直接比较曲线高度在一天的所有时间是很容易的，因为没有透视失真或遮挡。在日历视图中使用了相同的颜色编码，这对于理解时间模式非常有效。</strong></p>
<p><strong>相反,如果一个数据集本质上包括三维空间数据,如显示流体在飞机机翼或医学影像数据集从核磁共振扫描,然后一个3D视图的成本超出了它的好处,帮助用户建立一个有用的心智模型的数据结构。</strong></p>
<h3 id="Text-Labels-文本标签"><a href="#Text-Labels-文本标签" class="headerlink" title="Text Labels 文本标签"></a>Text Labels 文本标签</h3><p><strong>标签和图例形式的文本是创建可视化的一个非常重要的因素，它是有用的，而不仅仅是漂亮的。坐标轴和刻度线应该被标记。图例应表明颜色的意义，无论是作为离散的斑块或连续的颜色坡道使用。数据集中的各个项通常都有与之关联的有意义的文本标签。在许多情况下，始终显示所有标签会导致太多的视觉混乱，因此可以使用标签定位算法显示项目的一个子集的标签，该算法在期望的位置显示标签在避免重叠的同时保持密度(Luboschik, Schumann， &amp; cord, 2008)。一种简单的方法是基于标签重要性的度量使用贪婪算法来选择最优的标签来表示一组项目，但是基于组的特征来合成一个新的标签仍然是一个困难的问题。更以交互为中心的方法是根据用户的交互指示只显示单个项目的标签。</strong></p>
<h2 id="Interaction-Principles-交互原则"><a href="#Interaction-Principles-交互原则" class="headerlink" title="Interaction Principles 交互原则"></a>Interaction Principles 交互原则</h2><p><strong>在设计可视化时，交互的几个原则是重要的。低延迟视觉反馈允许用户更流畅地探索，例如，当光标简单地悬停在一个对象上而不是要求用户显式地单击时，可以显示更多的细节。在与大型数据集交互时，选择项是一项基本操作，因为它可以用高亮显示所选的数据集。颜色编码是突出显示的一种常见形式，但也可以使用其他途径。</strong></p>
<p><strong>许多交互形式都可以根据它们改变了显示的哪个方面来考虑。导航可以被认为是视口的改变。排序是对空间排序的一种改变;也就是说，改变数据映射到空间位置视觉通道的方式。整个视觉编码也可以改变。</strong></p>
<h3 id="Overview-First-Zoom-and-Filter-Details-on-Demand-首先概述，缩放和筛选，按需提供详细信息"><a href="#Overview-First-Zoom-and-Filter-Details-on-Demand-首先概述，缩放和筛选，按需提供详细信息" class="headerlink" title="Overview First, Zoom and Filter, Details on Demand 首先概述，缩放和筛选，按需提供详细信息"></a>Overview First, Zoom and Filter, Details on Demand 首先概述，缩放和筛选，按需提供详细信息</h3><p><strong>有影响力的咒语“首先概述，缩放和过滤，细节随需应变”(Shneiderman, 1996)阐明了交互和导航在可视化设计中的作用。通过空间导航或过滤，概览可以帮助用户注意到可能会产生进一步调查的区域。正如我们下面所讨论的，细节可以通过多种方式呈现:通过点击或光标悬停弹出窗口，在单独的窗口中，通过动态更改布局来腾出空间来显示额外的信息。</strong></p>
<h3 id="Interactivity-Costs-交互性成本"><a href="#Interactivity-Costs-交互性成本" class="headerlink" title="Interactivity Costs 交互性成本"></a>Interactivity Costs 交互性成本</h3><p><strong>交互性既有力量又有成本。交互的好处在于，人们可以探索比单一静态图像所能理解的更大的信息空间。然而，交互的代价是它需要人类的时间和注意力。如果用户必须彻底检查每一种可能性，则使用可视化系统可能会沦为人工搜索。对可视化设计人员来说，通过视觉编码自动检测感兴趣的特征，明确地引起用户的注意是一个有用的目标。然而，如果手头的任务可以通过自动手段完全解决，那么首先就不需要可视化。因此，在寻找可自动化的方面和依赖循环中的人来检测模式之间总是存在权衡。</strong></p>
<h3 id="Animation-动画-1"><a href="#Animation-动画-1" class="headerlink" title="Animation 动画"></a>Animation 动画</h3><p><strong>动画显示使用时间的变化。我们将连续帧只能播放、暂停或停止的动画与真正的交互控制区分开来。有相当多的证据表明，通过帮助人们跟踪物体位置或摄像机视角的变化，动画过渡可能比跳跃剪切更有效(Heer &amp; Robertson, 2007)。尽管动画在叙述和讲故事中非常有效，但它在可视化环境中经常被低效地使用。通过使用动画(一种随时间变化的视觉模式)来显示随时间变化的数据似乎是显而易见的。然而，当人们看到由许多帧组成的动画时，他们很难在不连续的单独帧之间进行具体的比较。人类视觉记忆的能力非常有限，这意味着我们比较过去见过的事物的记忆要比比较当前视野中的事物差得多。对于需要在多达几十帧之间进行比较的任务，并排比较通常比动画更有效。此外，如果在帧间改变的对象数量很大，人们将很难跟踪发生的所有事情(Robertson et al.， 2008)。叙事动画是精心设计的，以避免同时发生太多动作，而可视化的数据集则没有这种限制。对于只有有限变化的两帧的特殊情况，非常简单的在两帧之间来回翻转的动画可以是识别两者差异的有用方法。</strong> </p>
<h2 id="Composite-and-Adjacent-Views-合成视图和相邻视图"><a href="#Composite-and-Adjacent-Views-合成视图和相邻视图" class="headerlink" title="Composite and Adjacent Views 合成视图和相邻视图"></a>Composite and Adjacent Views 合成视图和相邻视图</h2><p><strong>一个非常基本的视觉编码选择是，是使用单个复合视图在同一帧或窗口中显示所有内容，还是使用多个相邻视图。</strong></p>
<h3 id="Single-Drawing-单图"><a href="#Single-Drawing-单图" class="headerlink" title="Single Drawing 单图"></a>Single Drawing 单图</h3><p><strong>当只有一个或两个数据维度进行编码时，水平和垂直空间位置是最明显的视觉通道，因为我们对它们的感知最准确，位置对我们对数据集的内部心理模型的影响最大。传统的统计图形显示的折线图、柱状图和散点图都使用符号的空间排序来编码信息。这些显示可以通过附加的视觉通道进行增强，如颜色、大小和形状，如图26.4所示。</strong></p>
<p><strong>最简单的标记是单个像素。在面向像素的显示中，目标是提供尽可能多的项目的概述。这些方法使用了高信息密度的空间位置和颜色通道，但排除了大小和形状通道的使用。下图显示了Tarantula软件可视化工具(Jones et al.， 2002)，其中大部分屏幕都用于使用一个像素的高线概述源代码(Eick, Steffen， &amp; Sumner, 1992)。当执行一套测试用例时，每一行的颜色和亮度显示它是否通过、失败或有混合结果。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030111550.png" class="" title="image-20211030111550">

<p>Tarantula通过软件测试套件的执行状态，用一个像素线颜色编码的源代码概述。图片由John Stasko提供(Jones, harrod， &amp; Stasko, 2002)。</p>
<h3 id="Superimposing-and-Layering-叠加和分层"><a href="#Superimposing-and-Layering-叠加和分层" class="headerlink" title="Superimposing and Layering 叠加和分层"></a>Superimposing and Layering 叠加和分层</h3><p><strong>当多个项目的空间位置兼容时，可以在同一帧中叠加。当坐标轴在所有项目上共享时，可以在同一折线图中显示几条线，在同一散点图中显示许多点。单一共享观点的一个好处是，比较不同项目的位置非常容易。如果数据集中的项数量有限，那么一个视图通常就足够了。当有足够多的项目时，视觉混乱会成为一个问题，可视化分层可以扩展单个视图的有用性。下图显示了当用户将光标移动到一个单词块上时，大小、饱和度和亮度通道的冗余组合如何用于区分前景层和背景层。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030111743.png" class="" title="image-20211030111743">

<p>星座系统中大小、饱和度和亮度的视觉分层(Munzner, 2000)。</p>
<h3 id="Glyphs-符号"><a href="#Glyphs-符号" class="headerlink" title="Glyphs 符号"></a>Glyphs 符号</h3><p><strong>我们已经讨论了使用简单标记进行视觉编码的想法，其中单个标记对于所使用的每个视觉通道只能有一个值。对于更复杂的标记(我们称之为符号)，有一个内部结构，其中子区域具有不同的视觉通道编码。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030111922.png" class="" title="image-20211030111922">

<p>复杂的标记(我们称之为符号)有一些子部分，它们在视觉上对不同的数据维进行编码。图片由Matt Ward (m.o. Ward, 2002)提供。</p>
<p><strong>设计适当的字形与设计可视编码具有相同的挑战。上图显示了各种各样的字形，包括Chernoff最初提出的臭名昭著的脸。使用面孔来显示抽象数据维度的危险在于，我们对不同面部特征的感知和情绪反应是高度非线性的，这种非线性还没有被完全理解，但这种可变性比我们目前讨论过的视觉通道之间的可变性更大。相对于鼻子大小或脸型等其他特征，我们可能更倾向于眉毛方向等反映情感状态的特征。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112010.png" class="" title="image-20211030112010">

<p>复杂的符号需要显著的显示区域，这样编码信息才能被读取。图片由Matt Ward提供，使用SpiralGlyphics软件创建(M. O. Ward, 2002)。</p>
<p><strong>复杂的符号需要每个符号有显著的显示区域，如上图所示，其中小型条形图显示了沿着螺旋路径的许多点的四个不同维度的值。可以使用更简单的符号来创建全局视觉纹理，该符号的大小非常小，以至于不缩放就无法读出单个值，但可以从概述级别识别区域边界。下图显示了使用上上图中右上方那种简笔图的示例。符号可以按一定的间隔放置，或者使用原始或派生数据维放置在数据驱动的空间位置。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112112.png" class="" title="image-20211030112112">

<p>一组密集的简单符号。图片由Georges Grinstein (S. Smith, Grinstein， &amp; Bergeron, 1991)提供，©1991 IEEE。</p>
<h3 id="Multiple-Views-多个视图"><a href="#Multiple-Views-多个视图" class="headerlink" title="Multiple Views 多个视图"></a>Multiple Views 多个视图</h3><p><strong>我们现在从只使用单一帧的方法转向那些使用多个链接在一起的视图的方法。链接最常见的形式是链接高亮显示，在一个视图中选中的项在其他视图中高亮显示。在链接导航中，一个视图中的移动会触发其他视图中的移动。</strong></p>
<p><strong>有许多种多视图方法。在通常称为多视图的方法中，相同的数据在多个视图中显示，每个视图具有不同的视觉编码，最清楚地显示数据集的某些方面。跨多个可视编码的链接高亮显示功能的强大之处在于，在一个视图中位于相邻区域的项在其他视图中的分布往往非常不同。在小倍数方法中，每个视图对不同的数据集具有相同的视觉编码，通常帧之间共享轴，以便于它们之间的空间位置比较有意义。小倍数的并排比较可以替代在同一视图中叠加所有数据的视觉混乱，也可以替代人类记忆的局限性，即记住之前在动画中看到的帧，而动画会随着时间的推移而变化。</strong></p>
<p><strong>概览和详细方法是在两个视图中具有相同的数据和相同的视觉编码，它们之间的唯一区别是缩放级别。在大多数情况下，概览使用的显示空间要比详细视图少得多。概览和细节视图的组合在可视化之外的许多工具(从地图软件到照片编辑)中很常见。使用按需详细说明的方法，另一个视图可以显示有关选定项的更多信息，可以是光标附近的弹出窗口，也可以是显示的另一部分中的永久窗口。</strong></p>
<p><strong>确定视图本身相对于其他视图最合适的空间位置，可能与确定单个视图中标记的空间位置一样是一个重要的问题。在某些系统中，视图的位置是任意的，由窗口系统或用户决定。对齐视图允许它们之间进行精确的比较，可以是垂直的、水平的，也可以是两个方向的数组。就像项目可以在视图中排序一样，视图也可以在显示中排序，通常是根据衡量整个视图某些方面的派生变量，而不是其中的单个项目。</strong></p>
<p><strong>下图显示了使用多种视图的人口普查数据的可视化。除了地理信息，每个县的人口信息还包括人口、密度、性别、中位年龄、1990年以来的变化百分比和主要民族的比例。使用的视觉编码包括地理、散点图、平行坐标、表格和矩阵视图。所有视图都使用相同的颜色编码，在底部中间有一个图例。散点图矩阵在所有视图中显示了链接的高亮显示，其中蓝色项目在一些视图中靠近，而在其他视图中分散。左上角的地图是中央的大细节地图的概述。表格视图允许在感兴趣的维度中直接排序和选择。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112632.png" class="" title="image-20211030112632">

<p>我们使用了Improvise工具包来创建这个多视图可视化。</p>
<h2 id="Data-Reduction-数据简化"><a href="#Data-Reduction-数据简化" class="headerlink" title="Data Reduction 数据简化"></a>Data Reduction 数据简化</h2><p><strong>到目前为止，我们所讨论的可视化编码技术显示了数据集中的所有项。然而，许多数据集是如此之大，以至于同时显示所有内容将导致如此多的视觉混乱，以至于视觉表示将很难或不可能让观众理解。减少显示的数据量的主要策略是概述和聚合、过滤和导航、焦点+上下文技术和降维。</strong></p>
<h3 id="Overviews-and-Aggregation-简介和聚合"><a href="#Overviews-and-Aggregation-简介和聚合" class="headerlink" title="Overviews and Aggregation 简介和聚合"></a>Overviews and Aggregation 简介和聚合</h3><p><strong>使用微小的数据集，可视化编码可以很容易地显示所有项目的所有数据维。对于中等大小的数据集，可以通过减少显示每个项的详细信息来构建显示所有项信息的概述。许多数据集在多个尺度上具有内部或可派生的结构。在这些情况下，多尺度可视化表示可以提供多个级别的概述，而不仅仅是一个级别的水平。概览通常用作起点，为用户提供线索，让他们知道在哪里深入检查更详细的内容。</strong></p>
<p><strong>对于较大的数据集，创建概览需要某种形式的可视化摘要。数据简化的一种方法是使用聚合表示，其中概述中的单个可视标记显式地表示许多项。</strong></p>
<p><strong>聚合的难点在于在摘要过程中要避免消除数据集中感兴趣的信号。在地图文献中，在保留重要区别特征的同时，以地图综合的名义，广泛研究了在不同尺度上创建地图的问题(Slocum, McMaster, Kessler， &amp; Howard, 2008)。</strong></p>
<h3 id="Filtering-and-Navigation-过滤和导航"><a href="#Filtering-and-Navigation-过滤和导航" class="headerlink" title="Filtering and Navigation 过滤和导航"></a>Filtering and Navigation 过滤和导航</h3><p><strong>数据缩减的另一种方法是过滤数据，只显示项的一个子集。过滤通常通过直接选择一个或多个数据维中感兴趣的范围来执行。</strong></p>
<p><strong>导航是一种基于空间位置的特殊过滤，改变视点会改变可见的项目集。几何变焦和非几何变焦均可用于可视化。通过几何缩放，摄像机在2D或3D空间中的位置可以用标准的计算机图形控件改变。在现实场景中，项目的大小应该取决于它们与摄像机的距离，只有它们的表面大小会根据距离变化。然而，在抽象空间的视觉编码中，非几何缩放可能是有用的。在语义缩放中，对象的视觉外观会根据绘制它的可用像素的数量发生显著变化。例如，文本文件的抽象视觉表示可以从一个没有标签的彩色编码小框变成一个中等大小的框，其中只包含文件名作为文本标签，然后变成一个包含文件内容的多行摘要的大矩形。在现实场景中，距离相机足够远的物体在图像中是不可见的，例如，当它们所处的屏幕面积小于一个像素时。在保证可见性的情况下，原始或派生数据维中的一个被用作重要性的度量，足够重要的对象必须在图像平面中始终具有某种可见的表示。</strong></p>
<h3 id="Focus-Context-焦点-上下文"><a href="#Focus-Context-焦点-上下文" class="headerlink" title="Focus+Context 焦点+上下文"></a>Focus+Context 焦点+上下文</h3><p><strong>焦点+上下文技术是另一种数据简化方法。用户以交互方式选择数据集项的子集作为焦点并绘制在细节。可视编码还包括关于为上下文显示的部分或所有其余数据集的信息，集成到显示焦点项的相同视图中。许多这些技术使用精心选择的失真，将放大的焦点区域和缩小的上下文区域组合成一个统一的视图。</strong></p>
<p><strong>一个常见的互动隐喻是可移动的鱼眼镜头。双曲几何学为影响视图中所有物体的单个径向透镜提供了一个优雅的数学框架。另一个交互隐喻是使用不同形状和放大级别的多个透镜，只影响局部区域。拉伸和挤压导航使用橡胶薄片的交互隐喻，拉伸一个区域会挤压其他区域，如下图所示。工作表的边界保持固定，以便所有项目都在视口内，尽管许多项目可能被压缩到亚像素大小。鱼眼隐喻并不局限于空间布局后使用的几何透镜;它可以直接用于结构化数据，例如一些部分折叠而其他部分展开的分层文档。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112924.png" class="" title="image-20211030112924">

<p>TreeJuxtaposer系统具有拉伸和挤压导航功能，并保证用颜色标记的区域的可见性(Munzner, Guimbreti’ere, Tasiran, Zhang， &amp; Zhou, 2003)。</p>
<p><strong>这些基于扭曲的方法是与非几何缩放具有相同精神的非文字导航的另一个例子。当导航在一个大的和不熟悉的数据集与现实的相机运动，用户可能会失去知觉当他们只能看到一个小的局部区域时，在高变焦水平上被设置。这些方法的设计目的是提供更多的背景信息，而不是单一的未经扭曲的视图，希望人们可以在地标仍然可识别的情况下保持方向。然而，这些失真仍然会让用户感到困惑或难以理解。与多种观点或单一现实观点相比，扭曲的成本和收益尚未得到充分理解。标准3D透视是一种非常常见的扭曲，在早期的可视化工作中被明确地用作焦点+背景的一种形式。然而，随着第26.4节中讨论的3D空间布局成本变得更容易理解，这种方法变得不那么受欢迎了。</strong></p>
<p><strong>其他围绕焦点项目提供上下文的方法不需要失真。例如，下图所示的SpaceTree系统省略了树中的大多数节点，显示了交互选择的焦点节点和树的根之间的路径。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112955.png" class="" title="image-20211030112955">

<p>SpaceTree系统显示了根与交互选择的焦点节点之间的路径，以提供上下文(Grosjean, Plaisant， &amp; Bederson, 2002)。</p>
<h3 id="Dimensionality-Reduction-降维"><a href="#Dimensionality-Reduction-降维" class="headerlink" title="Dimensionality Reduction 降维"></a>Dimensionality Reduction 降维</h3><p><strong>到目前为止所介绍的数据简化方法减少了要绘制的项目数量。当数据维数很多时，降维也很有效。</strong></p>
<p><strong>通过切片，从要消除的维度中选择一个值，然后只提取与该维度值匹配的项，将其包含在低维切片中。对于3D空间数据，切片尤其有用，例如，当通过CT扫描检查沿着头骨不同高度的人类头部切片时。切片可用于一次性消除多个维度。</strong></p>
<p><strong>对于投影，消除的尺寸信息不会被保留;这些维度的值被简单地删除，所有项仍然显示出来。一种常见的投影形式是标准的图形透视转换，它从3D投影到2D，在此过程中会丢失有关深度的信息。在数学可视化中，高维几何物体的结构可以通过在标准投影之前从4D投影到3D投影到图像平面，并使用颜色对投影外维的信息进行编码来表示。当用于非空间数据时，这种技术有时被称为维度过滤。</strong></p>
<p><strong>在一些数据集中，在比原始数据维数低得多的空间中可能存在有趣的隐藏结构。例如，有时直接测量自变量的兴趣是困难的或这是不可能的，但有大量的因变量或间接变量是可用的。目标是找到一小组能够忠实地表示数据集中的大部分结构或方差的维。这些维度可能是原始维度，也可能是合成的新维度，是原始维度的线性或非线性组合。主成分分析是一种快速、应用广泛的线性方法。许多非线性方法已经被提出，包括多维尺度(MDS)。这些方法通常用于确定数据集中是否存在大规模聚类;低维图中的细粒度结构通常不可靠，因为在还原过程中会丢失信息。下图显示了单个散点图中的文档收集。当数据集的真实维数远高于2时，可能需要一个散点图矩阵来显示成对的合成维数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030121341.png" class="" title="image-20211030121341">

<p>微光多维尺度方法的降维显示文档数据集中的簇(Ingram, Munzner， &amp; Olano, 2009)，©2009 IEEE。</p>
<h2 id="Examples-示例"><a href="#Examples-示例" class="headerlink" title="Examples 示例"></a>Examples 示例</h2><p><strong>我们用几个使用上面讨论的技术可视化特定类型数据的例子来结束本章。</strong></p>
<h3 id="Tables-表"><a href="#Tables-表" class="headerlink" title="Tables 表"></a>Tables 表</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030123651.png" class="" title="image-20211030123651">

<p>Table Lens提供了与表格数据的焦点+上下文交互，可以立即按每个维度列中的值重新排序。图片由Stuart Card提供(Rao &amp; Card, 1994)，©1994 ACM, Inc。包括在这里的许可。</p>
<p><strong>所有电子表格用户都知道，表格数据是非常常见的。可视化的目标是通过容易感知的视觉渠道对信息进行编码，而不是强迫人们以数字和文本的形式阅读信息。上图显示了Table Lens，这是一种聚焦+上下文的方法，其中定量值被编码为上下文区域中的一个像素高线的长度，并在焦点区域中显示为数字。数据集的每个维度都显示为一列，只需单击标题，就可以根据列中的值访问项目行。</strong></p>
<p><strong>散点图的传统笛卡尔方法，即项目相对于垂直轴以点的形式绘制，仅适用于二维和三维数据。许多表包含的数据远不止三个维度，而且可以使用其他可视通道编码的额外维度的数量是有限的。平行坐标是一种利用空间位置一次性可视化更多维度的方法，其中坐标轴是平行的而不是垂直的，n维项目以折线的形式显示出来，这条折线与每个n轴相交一次(Inselberg &amp; Dimsdale, 1990;维根曼,1990)。下图显示了一个包含23万项的8维数据集，它位于多个细节级别(Fua, Ward， &amp; Rundensteiner, 1999)，从顶部的高级视图到更精细的细节在底部。使用分层平行坐标，项目被聚类，整个项目聚类由不同宽度和不透明度的频带表示，平均值在中间，每个轴的宽度取决于该维度中集群中项目的值。每个波段的着色是基于基于相似性度量的聚类之间的接近度。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030123706.png" class="" title="image-20211030123706">

<p>分层并行坐标在多个细节层次上显示高维数据。图片由Matt Ward (Fua等人，1999)提供，©1999 IEEE。</p>
<h3 id="Graphs-图形"><a href="#Graphs-图形" class="headerlink" title="Graphs 图形"></a>Graphs 图形</h3><p><strong>图绘制的领域是在二维或三维空间中为图中的节点找到一个空间位置，并在这些节点之间路由边(Di Battista, Eades, Tamassia， &amp; Tollis, 1999)。在许多情况下，边路由问题可以通过只使用直边或只允许正交布局类的直角弯曲来简化，但有些方法处理真曲线。如果图具有有向边，则可以使用分层方法通过节点的水平或垂直空间排序来显示层次结构，如图26.2所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124114.png" class="" title="image-20211030124114">

<p>图形布局美学标准。上:应尽量减少交叉边。中:Angular的分辨率应该最大化。下:对称性在左侧最大化，而交叉在右侧最小化，这显示了个别np硬标准之间的冲突。</p>
<p><strong>一套美学标准将人类对可读图形的判断作为可在拟议布局上计算的度量标准来操作(Ware, Purchase, Colpys， &amp; McGill, 2002)。上图显示了一些示例。有些参数应该最小化，比如交叉边的数量，布局的总面积，以及直角弯曲或曲线的数量。其他的应该最大化，如角分辨率或对称性。问题是困难的，因为这些标准中的大多数都是单独的NP-hard，而且它们是相互不相容的(Brandenburg, 1988)。</strong></p>
<p><strong>许多绘制节点-链接图的方法都使用力指向放置，其动机是直观的物理隐喻，即边缘的弹簧力将节点上的排斥粒子拉到一起。虽然朴素的方法具有很高的时间复杂度，而且容易陷入局部极小值，但许多工作已经投入到开发更复杂的算法中，如GEM (Frick, Ludwig， &amp; Mehldau, 1994)或ipsepo - cola (Dwyer, Koren， &amp; Marriott, 2006)。下图显示了一个使用r-PolyLog能量模型的交互式系统，其中聚类图的焦点+上下文视图是用几何和语义鱼眼创建的(van Ham &amp; van Wijk, 2004)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124125.png" class="" title="image-20211030124125">

<p>力向放置显示了具有几何和语义鱼眼的聚类图。图片由Jarke van Wijk提供(van Ham &amp; van Wijk, 2004)，©2004 IEEE。</p>
<p><strong>图也可以通过显示邻接矩阵来进行可视化编码，其中所有顶点沿每个轴放置，如果两个顶点之间有一条边，则两个顶点之间的单元格会着色。MatrixExplorer系统使用链接的多个视图来帮助社会科学研究人员通过矩阵和节点链接表示直观地分析社会网络(Henry &amp; Fekete, 2006)。下图显示了在这两个视图中由相同的图形结构创建的不同视觉模式:A表示连接多个社区的参与者;B是一个社区;C是一个团，或者完全子图。矩阵视图不会受到杂乱的边缘交叉的影响，但是使用这种方法，包括路径跟踪在内的许多任务更加困难。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124136.png" class="" title="image-20211030124136">

<p>图可以用矩阵视图或节点链接视图显示。图片由Jean- Daniel Fekete提供(Henry &amp; Fekete, 2006)，©2006 IEEE。</p>
<h3 id="Trees-树"><a href="#Trees-树" class="headerlink" title="Trees 树"></a>Trees 树</h3><p><strong>树是一种很常见的图的特殊情况，因此大量的可视化研究都致力于它们。在二维平面上布局树的简单算法对小树很有效(Reingold &amp; Tilford, 1981)，而更复杂但可扩展的方法在线性时间内运行(Buchheim, J¨unger， &amp; Leipert, 2002)。图26.17和26.18还显示了具有不同空间布局方法的树，但这四种方法都通过绘制连接父节点和子节点的链接，在视觉上编码了它们之间的关系。</strong></p>
<p><strong>树映射使用包含而不是连接来显示树中父节点和子节点之间的层次关系(B. Johnson &amp; Shneiderman, 1991)。也就是说，树映射显示嵌套在父节点轮廓中的子节点。下图显示了一个包含近100万个文件的分级文件系统，其中文件大小按矩形大小编码，文件类型按颜色编码(Fekete &amp; Plaisant, 2002)。树的叶子节点的大小可以编码一个额外的数据维，但内部节点的大小并不显示该维的值;这是由后代的累积体型决定的。尽管使用树映射比使用节点链接方法更难理解树的拓扑结构或通过树跟踪路径等任务，但涉及理解与叶节点绑定的属性的任务得到了很好的支持。树映射是一种空间填充表示，通常比节点链接方法更紧凑。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124412.png" class="" title="image-20211030124412">

<p>Treemap显示了将近100万个文件的文件系统。图片由Jean- Daniel Fekete (Fekete &amp; Plaisant, 2002)提供，©2002 IEEE。</p>
<h3 id="Geographic-地理"><a href="#Geographic-地理" class="headerlink" title="Geographic 地理"></a>Geographic 地理</h3><p><strong>许多类型的分析，如流行病学，需要理解地理和非空间数据。下图显示了一个用于可视化分析癌症人口统计数据集的工具，该数据集结合了本章中描述的许多观点(MacEachren, Dai, Hardisty, Guo， &amp; Lengerich, 2003)。链接视图的顶部矩阵具有三种视觉编码的小倍数:左下角显示阿巴拉契亚县的地理地图，矩阵对角线的直方图，以及右上方的散点图。底部的2 × 2矩阵将散点图与地图连接起来，包含了两者的颜色图例。离散二元序列色图对两个互补色系中的每个色系都有依次增加的亮度，对色觉不足的人有效。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124540.png" class="" title="image-20211030124540">

<p>显示癌症人口统计数据的两个关联小倍数矩阵(MacEachren等人，2003)，©2003 IEEE。</p>
<h3 id="Spatial-Fields-空间领域"><a href="#Spatial-Fields-空间领域" class="headerlink" title="Spatial Fields 空间领域"></a>Spatial Fields 空间领域</h3><p><strong>大多数非地理空间数据被建模为一个字段，其中有一个或多个值与2D或3D空间中的每个点相关联。标量场，例如CT或MRI医学成像扫描，通常通过寻找等值面或使用直接体积绘制来实现可视化。例如，矢量场，在水或空气中的流动，通常使用箭头、流线(McLouglin, Laramee, Peikert, Post， &amp; Chen, 2009)和线积分卷积(LIC) (Laramee et al.， 2004)来可视化。张量场，例如那些描述分子在人脑中的各向异性扩散的张量场，特别具有挑战性(Kindlmann, Weinstein， &amp; Hart, 2000)。</strong></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>OSkirito
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/" title="Fundamentals Of Computer Graphics 4th">http://example.com/2023/05/05/Fundamentals Of Computer Graphics 4th/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag"># 图形学</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/05/05/Real-Time%20Rendering%204th%20edition/" rel="prev" title="Real-Time Rendering 4th edition">
      <i class="fa fa-chevron-left"></i> Real-Time Rendering 4th edition
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/" rel="next" title="在UE中使用UI制作过场动画">
      在UE中使用UI制作过场动画 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Introduction-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">1 Introduction 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Graphics-Areas-%E5%9B%BE%E5%BD%A2%E9%A2%86%E5%9F%9F"><span class="nav-number">1.1.</span> <span class="nav-text">Graphics Areas 图形领域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Major-Applications-%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">Major Applications 主要应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Graphics-APIs-%E5%9B%BE%E5%BD%A2APIs"><span class="nav-number">1.3.</span> <span class="nav-text">Graphics APIs 图形APIs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Graphics-Pipeline-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF"><span class="nav-number">1.4.</span> <span class="nav-text">Graphics Pipeline 图形管线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Numerical-Issues-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.</span> <span class="nav-text">Numerical Issues 数学问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Efficiency-%E6%95%88%E7%8E%87"><span class="nav-number">1.6.</span> <span class="nav-text">Efficiency 效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Designing-and-Coding-Graphics-Programs-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%BC%96%E7%A0%81%E5%9B%BE%E5%BD%A2%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.7.</span> <span class="nav-text">Designing and Coding Graphics Programs 设计与编码图形程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-Design-%E7%B1%BB%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.7.1.</span> <span class="nav-text">Class Design 类设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Float-vs-Double-%E5%8D%95%E7%B2%BE%E5%BA%A6VS-%E5%8F%8C%E7%B2%BE%E5%BA%A6"><span class="nav-number">1.7.2.</span> <span class="nav-text">Float vs. Double 单精度VS.双精度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Debugging-Graphics-Programs-%E8%B0%83%E8%AF%95%E5%9B%BE%E5%BD%A2%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.7.3.</span> <span class="nav-text">Debugging Graphics Programs 调试图形程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Scientific-Method-%E7%A7%91%E5%AD%A6%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">The Scientific Method 科学方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Images-as-Coded-Debugging-Output-%E5%9B%BE%E5%83%8F%E7%BC%96%E7%A0%81%E8%B0%83%E8%AF%95%E8%BE%93%E5%87%BA"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">Images as Coded Debugging Output 图像编码调试输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-a-Debugger-%E4%BD%BF%E7%94%A8%E8%B0%83%E8%AF%95%E5%99%A8"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">Using a Debugger 使用调试器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Data-Visualization-for-Debugging-%E8%B0%83%E8%AF%95%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="nav-number">1.7.3.4.</span> <span class="nav-text">Data Visualization for Debugging 调试数据可视化</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Miscellaneous-Math-%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6"><span class="nav-number">2.</span> <span class="nav-text">2 Miscellaneous Math 基础数学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sets-and-Mappings-%E9%9B%86%E5%90%88%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="nav-number">2.0.1.</span> <span class="nav-text">Sets and Mappings 集合与映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%86%E5%87%BD%E6%95%B0-%E6%98%A0%E5%B0%84"><span class="nav-number">2.0.1.1.</span> <span class="nav-text">逆函数&#x2F;映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4"><span class="nav-number">2.0.1.2.</span> <span class="nav-text">区间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%95%B0"><span class="nav-number">2.0.1.3.</span> <span class="nav-text">对数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solving-Quadratic-Equations-%E6%B1%82%E8%A7%A3%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">Solving Quadratic Equations 求解二次方程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trigonometry-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">Trigonometry 三角函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Angles-%E8%A7%92%E5%BA%A6"><span class="nav-number">2.2.1.</span> <span class="nav-text">Angles 角度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trigonometric-Functions-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.2.</span> <span class="nav-text">Trigonometric Functions 三角函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Useful-Identitie-%E6%9C%89%E7%94%A8%E7%9A%84%E5%85%AC%E5%BC%8F"><span class="nav-number">2.2.3.</span> <span class="nav-text">Useful Identitie 有用的公式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vectors-%E5%90%91%E9%87%8F"><span class="nav-number">2.3.</span> <span class="nav-text">Vectors 向量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector-Operations-%E5%90%91%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.1.</span> <span class="nav-text">Vector Operations 向量操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cartesian-Coordinates-of-a-Vector-%E5%90%91%E9%87%8F%E7%9A%84%E7%AC%9B%E5%8D%A1%E5%B0%94%E5%9D%90%E6%A0%87"><span class="nav-number">2.3.2.</span> <span class="nav-text">Cartesian Coordinates of a Vector 向量的笛卡尔坐标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dot-Product-%E7%82%B9%E4%B9%98-%E5%86%85%E7%A7%AF"><span class="nav-number">2.3.3.</span> <span class="nav-text">Dot Product 点乘&#x2F;内积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cross-Product-%E5%8F%89%E4%B9%98-%E5%A4%96%E7%A7%AF"><span class="nav-number">2.3.4.</span> <span class="nav-text">Cross Product 叉乘&#x2F;外积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Orthonormal-Bases-and-Coordinate-Frames-%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E5%9F%BA%E5%BA%95%E5%92%8C%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="nav-number">2.3.5.</span> <span class="nav-text">Orthonormal Bases and Coordinate Frames 标准正交基底和坐标系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constructing-a-Basis-from-a-Single-Vector-%E5%8D%95%E4%B8%AA%E5%90%91%E9%87%8F%E6%9E%84%E9%80%A0%E5%9F%BA%E5%90%91%E9%87%8F"><span class="nav-number">2.3.6.</span> <span class="nav-text">Constructing a Basis from a Single Vector 单个向量构造基向量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constructing-a-Basis-from-Two-Vectors-%E4%B8%A4%E4%B8%AA%E5%90%91%E9%87%8F%E6%9E%84%E9%80%A0%E5%9F%BA%E5%90%91%E9%87%8F"><span class="nav-number">2.3.7.</span> <span class="nav-text">Constructing a Basis from Two Vectors 两个向量构造基向量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Squaring-Up-a-Basis-%E4%BF%AE%E6%AD%A3%E5%9F%BA%E5%90%91%E9%87%8F"><span class="nav-number">2.3.8.</span> <span class="nav-text">Squaring Up a Basis 修正基向量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Curves-and-Surfaces-%E6%9B%B2%E7%BA%BF%E5%92%8C%E6%9B%B2%E9%9D%A2"><span class="nav-number">2.4.</span> <span class="nav-text">Curves and Surfaces 曲线和曲面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2D-Implicit-Curves-2D%E9%9A%90%E5%BC%8F%E6%9B%B2%E7%BA%BF"><span class="nav-number">2.4.1.</span> <span class="nav-text">2D Implicit Curves 2D隐式曲线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-2D-Gradient-2D%E6%A2%AF%E5%BA%A6"><span class="nav-number">2.4.2.</span> <span class="nav-text">The 2D Gradient 2D梯度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Implicit-2D-Lines-%E9%9A%90%E5%BC%8F%E7%9B%B4%E7%BA%BF"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">Implicit 2D Lines 隐式直线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Implicit-Quadric-Curve-%E9%9A%90%E5%BC%8F%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">Implicit Quadric Curve 隐式二次曲线</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3D-Implicit-Surfaces-3D%E9%9A%90%E5%BC%8F%E6%9B%B2%E9%9D%A2"><span class="nav-number">2.4.3.</span> <span class="nav-text">3D Implicit Surfaces 3D隐式曲面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Surface-Normal-to-an-Implicit-Surface-%E9%9A%90%E5%BC%8F%E6%9B%B2%E9%9D%A2%E7%9A%84%E6%9B%B2%E9%9D%A2%E6%B3%95%E7%BA%BF"><span class="nav-number">2.4.4.</span> <span class="nav-text">Surface Normal to an Implicit Surface 隐式曲面的曲面法线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implicit-Planes-%E9%9A%90%E5%BC%8F%E5%B9%B3%E9%9D%A2"><span class="nav-number">2.4.5.</span> <span class="nav-text">Implicit Planes 隐式平面</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3D-Quadric-Surfaces-3D%E4%BA%8C%E6%AC%A1%E6%9B%B2%E9%9D%A2"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">3D Quadric Surfaces 3D二次曲面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3D-Curves-from-Implicit-Surfaces-3D%E9%9A%90%E5%BC%8F%E8%A1%A8%E9%9D%A2%E7%9A%84%E6%9B%B2%E7%BA%BF"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">3D Curves from Implicit Surfaces 3D隐式表面的曲线</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2D-Parametric-Curves-2D%E5%8F%82%E6%95%B0%E6%9B%B2%E7%BA%BF"><span class="nav-number">2.4.6.</span> <span class="nav-text">2D Parametric Curves 2D参数曲线</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2D-Parametric-Lines-2D%E5%8F%82%E6%95%B0%E7%9B%B4%E7%BA%BF"><span class="nav-number">2.4.6.1.</span> <span class="nav-text">2D Parametric Lines 2D参数直线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2D-Parametric-Circles-2D%E5%8F%82%E6%95%B0%E5%9C%86"><span class="nav-number">2.4.6.2.</span> <span class="nav-text">2D Parametric Circles 2D参数圆</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3D-Parametric-Curves-3D%E5%8F%82%E6%95%B0%E6%9B%B2%E7%BA%BF"><span class="nav-number">2.4.7.</span> <span class="nav-text">3D Parametric Curves 3D参数曲线</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3D-Parametric-Lines-3D%E5%8F%82%E6%95%B0%E7%9B%B4%E7%BA%BF"><span class="nav-number">2.4.7.1.</span> <span class="nav-text">3D Parametric Lines 3D参数直线</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3D-Parametric-Surfaces-3D%E5%8F%82%E6%95%B0%E6%9B%B2%E9%9D%A2"><span class="nav-number">2.4.8.</span> <span class="nav-text">3D Parametric Surfaces 3D参数曲面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Summary-of-Curves-and-Surfaces-%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E6%B1%87%E6%80%BB"><span class="nav-number">2.4.9.</span> <span class="nav-text">Summary of Curves and Surfaces 曲线曲面汇总</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linear-Interpolation-%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC"><span class="nav-number">2.5.</span> <span class="nav-text">Linear Interpolation 线性插值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Triangles-%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">2.6.</span> <span class="nav-text">Triangles 三角形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2D-Triangles-2D%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">2.6.1.</span> <span class="nav-text">2D Triangles 2D三角形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3D-Triangles-3D%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">2.6.2.</span> <span class="nav-text">3D Triangles 3D三角形</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Raster-Images-%E5%85%89%E6%A0%85%E5%8C%96%E5%9B%BE%E5%83%8F"><span class="nav-number">3.</span> <span class="nav-text">3 Raster Images 光栅化图像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Raster-Devices-%E5%85%89%E6%A0%85%E8%AE%BE%E5%A4%87"><span class="nav-number">3.1.</span> <span class="nav-text">Raster Devices 光栅设备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA"><span class="nav-number">3.1.0.1.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5"><span class="nav-number">3.1.0.2.</span> <span class="nav-text">输入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Displays-%E6%98%BE%E7%A4%BA"><span class="nav-number">3.1.1.</span> <span class="nav-text">Displays 显示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hardcopy-Devices-%E7%A1%AC%E6%8B%B7%E8%B4%9D%E8%AE%BE%E5%A4%87"><span class="nav-number">3.1.2.</span> <span class="nav-text">Hardcopy Devices 硬拷贝设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Input-Devices-%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87"><span class="nav-number">3.1.3.</span> <span class="nav-text">Input Devices 输入设备</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Images-Pixels-and-Geometry-%E5%9B%BE%E5%83%8F%E3%80%81%E5%83%8F%E7%B4%A0%E5%92%8C%E5%87%A0%E4%BD%95%E4%BD%93"><span class="nav-number">3.2.</span> <span class="nav-text">Images, Pixels, and Geometry 图像、像素和几何体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Pixel-Values-%E5%83%8F%E7%B4%A0%E5%80%BC"><span class="nav-number">3.2.1.</span> <span class="nav-text">Pixel Values 像素值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Monitor-Intensities-and-Gamma-%E6%98%BE%E7%A4%BA%E5%BC%BA%E5%BA%A6%E5%92%8C%E4%BC%BD%E9%A9%AC%E5%80%BC"><span class="nav-number">3.2.2.</span> <span class="nav-text">Monitor Intensities and Gamma 显示强度和伽马值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RGB-Color-RGB%E9%A2%9C%E8%89%B2"><span class="nav-number">3.3.</span> <span class="nav-text">RGB Color RGB颜色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Alpha-Compositing-Alpha%E5%90%88%E6%88%90"><span class="nav-number">3.4.</span> <span class="nav-text">Alpha Compositing Alpha合成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E5%AD%98%E5%82%A8"><span class="nav-number">3.4.1.</span> <span class="nav-text">图像存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Ray-Tracing-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA"><span class="nav-number">4.</span> <span class="nav-text">4 Ray Tracing 光线追踪</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Basic-Ray-Tracing-Algorithm-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">The Basic Ray-Tracing Algorithm 基本的光线追踪算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Perspective-%E9%80%8F%E8%A7%86"><span class="nav-number">4.2.</span> <span class="nav-text">Perspective 透视</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Computing-Viewing-Rays-%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E5%85%89%E7%BA%BF"><span class="nav-number">4.3.</span> <span class="nav-text">Computing Viewing Rays 计算可视光线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Orthographic-Views-%E6%AD%A3%E4%BA%A4%E8%A7%86%E5%9B%BE"><span class="nav-number">4.3.1.</span> <span class="nav-text">Orthographic Views 正交视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Perspective-Views-%E9%80%8F%E8%A7%86%E8%A7%86%E5%9B%BE"><span class="nav-number">4.3.2.</span> <span class="nav-text">Perspective Views 透视视图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ray-Object-Intersection-%E5%85%89%E7%BA%BF%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9B%B8%E4%BA%A4"><span class="nav-number">4.4.</span> <span class="nav-text">Ray-Object Intersection 光线与对象相交</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ray-Sphere-Intersection-%E5%85%89%E7%BA%BF%E4%B8%8E%E7%90%83%E7%9B%B8%E4%BA%A4"><span class="nav-number">4.4.1.</span> <span class="nav-text">Ray-Sphere Intersection 光线与球相交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ray-Triangle-Intersection-%E5%85%89%E7%BA%BF%E4%B8%8E%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9B%B8%E4%BA%A4"><span class="nav-number">4.4.2.</span> <span class="nav-text">Ray-Triangle Intersection 光线与三角形相交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ray-Polygon-Intersection-%E5%85%89%E7%BA%BF%E4%B8%8E%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9B%B8%E4%BA%A4"><span class="nav-number">4.4.3.</span> <span class="nav-text">Ray-Polygon Intersection 光线与多边形相交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Intersecting-a-Group-of-Objects-%E4%B8%80%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9B%B8%E4%BA%A4"><span class="nav-number">4.4.4.</span> <span class="nav-text">Intersecting a Group of Objects 一组对象相交</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shading-%E7%9D%80%E8%89%B2"><span class="nav-number">4.5.</span> <span class="nav-text">Shading 着色</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambertian-Shading-Lambertian%E7%9D%80%E8%89%B2"><span class="nav-number">4.5.1.</span> <span class="nav-text">Lambertian Shading Lambertian着色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Blinn-Phong-Shading-Blinn-Phong%E7%9D%80%E8%89%B2"><span class="nav-number">4.5.2.</span> <span class="nav-text">Blinn-Phong Shading Blinn-Phong着色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ambient-Shading-Ambient%E7%9D%80%E8%89%B2"><span class="nav-number">4.5.3.</span> <span class="nav-text">Ambient Shading Ambient着色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multiple-Point-Lights-%E5%A4%9A%E7%82%B9%E5%85%89%E6%BA%90"><span class="nav-number">4.5.4.</span> <span class="nav-text">Multiple Point Lights 多点光源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#A-Ray-Tracing-Program-%E4%B8%80%E4%B8%AA%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E7%A8%8B%E5%BA%8F"><span class="nav-number">4.6.</span> <span class="nav-text">A Ray-Tracing Program 一个光线追踪程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-Oriented-Design-for-a-Ray-Tracing-Program-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E7%A8%8B%E5%BA%8F"><span class="nav-number">4.6.1.</span> <span class="nav-text">Object-Oriented Design for a Ray-Tracing Program 面向对象设计的光线追踪程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shadows-%E9%98%B4%E5%BD%B1"><span class="nav-number">4.7.</span> <span class="nav-text">Shadows 阴影</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ideal-Specular-Reflection-%E7%90%86%E6%83%B3%E7%9A%84%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84"><span class="nav-number">4.8.</span> <span class="nav-text">Ideal Specular Reflection 理想的镜面反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Historical-Notes-%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="nav-number">4.9.</span> <span class="nav-text">Historical Notes 发展历程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Linear-Algebra-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">5 Linear Algebra 线性代数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Determinants-%E8%A1%8C%E5%88%97%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text">Determinants 行列式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">5.1.1.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Matrices-%E7%9F%A9%E9%98%B5"><span class="nav-number">5.2.</span> <span class="nav-text">Matrices 矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Matrix-Arithmetic-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99"><span class="nav-number">5.2.1.</span> <span class="nav-text">Matrix Arithmetic 矩阵的运算规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Operations-on-Matrices-%E7%9F%A9%E9%98%B5%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">5.2.2.</span> <span class="nav-text">Operations on Matrices 矩阵的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector-Operations-in-Matrix-Form-%E7%9F%A9%E9%98%B5%E7%9A%84%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97"><span class="nav-number">5.2.3.</span> <span class="nav-text">Vector Operations in Matrix Form 矩阵的向量运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Special-Types-of-Matrices-%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.2.4.</span> <span class="nav-text">Special Types of Matrices 矩阵的特殊类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E5%AD%90"><span class="nav-number">5.2.5.</span> <span class="nav-text">列子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Computing-with-Matrices-and-Determinants-%E4%BD%BF%E7%94%A8%E7%9F%A9%E9%98%B5%E5%92%8C%E8%A1%8C%E5%88%97%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="nav-number">5.3.</span> <span class="nav-text">Computing with Matrices and Determinants 使用矩阵和行列式计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Computing-Inverses-%E8%AE%A1%E7%AE%97%E9%80%86"><span class="nav-number">5.3.1.</span> <span class="nav-text">Computing Inverses 计算逆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linear-Systems-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.3.2.</span> <span class="nav-text">Linear Systems 线性系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Eigenvalues-and-Matrix-Diagonalization-%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E5%8C%96"><span class="nav-number">5.4.</span> <span class="nav-text">Eigenvalues and Matrix Diagonalization 特征值与矩阵对角化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Singular-Value-Decomposition-%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3"><span class="nav-number">5.4.1.</span> <span class="nav-text">Singular Value Decomposition 奇异值分解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Transformation-Matrices-%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2"><span class="nav-number">6.</span> <span class="nav-text">6 Transformation Matrices 矩阵变换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2D-Linear-Transformations-%E4%BA%8C%E7%BB%B4%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2"><span class="nav-number">6.1.</span> <span class="nav-text">2D Linear Transformations 二维线性变换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scaling-%E7%BC%A9%E6%94%BE"><span class="nav-number">6.1.1.</span> <span class="nav-text">Scaling 缩放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shearing-%E5%89%AA%E5%88%87"><span class="nav-number">6.1.2.</span> <span class="nav-text">Shearing 剪切</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rotation-%E6%97%8B%E8%BD%AC"><span class="nav-number">6.1.3.</span> <span class="nav-text">Rotation 旋转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflection-%E5%8F%8D%E5%B0%84"><span class="nav-number">6.1.4.</span> <span class="nav-text">Reflection 反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Composition-and-Decomposition-of-Transformations-%E5%8F%98%E6%8D%A2%E7%9A%84%E7%BB%84%E5%90%88%E5%92%8C%E5%88%86%E8%A7%A3"><span class="nav-number">6.1.5.</span> <span class="nav-text">Composition and Decomposition of Transformations 变换的组合和分解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Decomposition-of-Transformations-%E5%8F%98%E6%8D%A2%E7%9A%84%E5%88%86%E8%A7%A3"><span class="nav-number">6.1.6.</span> <span class="nav-text">Decomposition of Transformations 变换的分解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Symmetric-Eigenvalue-Decomposition-%E5%AF%B9%E7%A7%B0%E7%89%B9%E5%BE%81%E5%80%BC%E5%88%86%E8%A7%A3"><span class="nav-number">6.1.6.1.</span> <span class="nav-text">Symmetric Eigenvalue Decomposition 对称特征值分解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Singular-Value-Decomposition-%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3-1"><span class="nav-number">6.1.6.2.</span> <span class="nav-text">Singular Value Decomposition 奇异值分解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Paeth-Decomposition-of-Rotations-%E6%97%8B%E8%BD%AC%E7%9A%84Paeth%E5%88%86%E8%A7%A3"><span class="nav-number">6.1.6.3.</span> <span class="nav-text">Paeth Decomposition of Rotations 旋转的Paeth分解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3D-Linear-Transformations-%E4%B8%89%E7%BB%B4%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2"><span class="nav-number">6.2.</span> <span class="nav-text">3D Linear Transformations 三维线性变换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Arbitrary-3D-Rotations-%E4%BB%BB%E6%84%8F%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC"><span class="nav-number">6.2.1.</span> <span class="nav-text">Arbitrary 3D Rotations 任意三维旋转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transforming-Normal-Vectors-%E8%BD%AC%E6%8D%A2%E6%B3%95%E5%90%91%E9%87%8F"><span class="nav-number">6.2.2.</span> <span class="nav-text">Transforming Normal Vectors 转换法向量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Translation-and-Affine-Transformations-%E5%B9%B3%E7%A7%BB%E4%B8%8E%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2"><span class="nav-number">6.3.</span> <span class="nav-text">Translation and Affine Transformations 平移与仿射变换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inverses-of-Transformation-Matrices-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E7%9A%84%E9%80%86"><span class="nav-number">6.4.</span> <span class="nav-text">Inverses of Transformation Matrices 变换矩阵的逆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Coordinate-Transformations-%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2"><span class="nav-number">6.5.</span> <span class="nav-text">Coordinate Transformations 坐标变换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-Viewing-%E8%A7%86%E5%9B%BE"><span class="nav-number">7.</span> <span class="nav-text">7 Viewing 视图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Viewing-Transformations-%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2"><span class="nav-number">7.1.</span> <span class="nav-text">Viewing Transformations 视图变换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Viewport-Transformation-%E8%A7%86%E5%8F%A3%E5%8F%98%E6%8D%A2"><span class="nav-number">7.1.1.</span> <span class="nav-text">The Viewport Transformation 视口变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Orthographic-Projection-Transformation-%E6%AD%A3%E5%B0%84%E5%8F%98%E6%8D%A2"><span class="nav-number">7.1.2.</span> <span class="nav-text">The Orthographic Projection Transformation 正射变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Camera-Transformation-%E6%91%84%E5%83%8F%E6%9C%BA%E5%8F%98%E6%8D%A2"><span class="nav-number">7.1.3.</span> <span class="nav-text">The Camera Transformation 摄像机变换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Projective-Transformations-%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2"><span class="nav-number">7.2.</span> <span class="nav-text">Projective Transformations 投影变换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Perspective-Projection-%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1"><span class="nav-number">7.3.</span> <span class="nav-text">Perspective Projection 透视投影</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Some-Properties-of-the-Perspective-Transform-%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">7.4.</span> <span class="nav-text">Some Properties of the Perspective Transform 透视变换的性质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Field-of-View-%E8%A7%86%E5%9C%BA"><span class="nav-number">7.5.</span> <span class="nav-text">Field-of-View 视场</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-The-Graphics-Pipeline-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF"><span class="nav-number">8.</span> <span class="nav-text">8 The Graphics Pipeline 图形管线</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Rasterization-%E5%85%89%E6%A0%85%E5%8C%96"><span class="nav-number">8.1.</span> <span class="nav-text">Rasterization 光栅化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Line-Drawing-%E7%BB%98%E5%88%B6%E7%9B%B4%E7%BA%BF"><span class="nav-number">8.1.1.</span> <span class="nav-text">Line Drawing 绘制直线</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Line-Drawing-Using-Implicit-Line-Equations-%E7%94%A8%E9%9A%90%E5%BC%8F%E7%9B%B4%E7%BA%BF%E6%96%B9%E7%A8%8B%E7%BB%98%E5%88%B6%E7%9B%B4%E7%BA%BF"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">Line Drawing Using Implicit Line Equations 用隐式直线方程绘制直线</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Triangle-Rasterization-%E4%B8%89%E8%A7%92%E5%BD%A2%E5%85%89%E6%A0%85%E5%8C%96"><span class="nav-number">8.1.2.</span> <span class="nav-text">Triangle Rasterization 三角形光栅化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dealing-with-Pixels-on-Triangle-Edges-%E5%A4%84%E7%90%86%E4%B8%89%E8%A7%92%E5%BD%A2%E8%BE%B9%E7%BC%98%E4%B8%8A%E7%9A%84%E5%83%8F%E7%B4%A0"><span class="nav-number">8.1.2.1.</span> <span class="nav-text">Dealing with Pixels on Triangle Edges 处理三角形边缘上的像素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Clipping-%E8%A3%81%E5%89%AA"><span class="nav-number">8.1.3.</span> <span class="nav-text">Clipping 裁剪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Clipping-Before-the-Transform-Option-1-%E5%8F%98%E6%8D%A2%E5%89%8D%E7%9A%84%E8%A3%81%E5%89%AA-%E9%80%89%E9%A1%B91"><span class="nav-number">8.1.4.</span> <span class="nav-text">Clipping Before the Transform (Option 1) 变换前的裁剪(选项1)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Clipping-in-Homogeneous-Coordinates-Option-2-%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E8%A3%81%E5%89%AA-%E9%80%89%E9%A1%B92"><span class="nav-number">8.1.5.</span> <span class="nav-text">Clipping in Homogeneous Coordinates (Option 2) 齐次坐标裁剪(选项2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Clipping-against-a-Plane-%E5%B9%B3%E9%9D%A2%E7%9B%B8%E4%BA%A4%E8%A3%81%E5%89%AA"><span class="nav-number">8.1.6.</span> <span class="nav-text">Clipping against a Plane 平面相交裁剪</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Operations-Before-and-After-Rasterization-%E5%85%89%E6%A0%85%E5%8C%96%E7%9A%84%E5%89%8D%E5%90%8E%E6%93%8D%E4%BD%9C"><span class="nav-number">8.2.</span> <span class="nav-text">Operations Before and After Rasterization 光栅化的前后操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Simple-2D-Drawing-%E7%AE%80%E5%8D%95%E7%9A%842D%E7%BB%98%E5%88%B6"><span class="nav-number">8.2.1.</span> <span class="nav-text">Simple 2D Drawing 简单的2D绘制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Minimal-3D-Pipeline-%E6%9C%80%E5%B0%8F%E7%9A%84%E5%8C%963D%E7%AE%A1%E7%BA%BF"><span class="nav-number">8.2.2.</span> <span class="nav-text">A Minimal 3D Pipeline 最小的化3D管线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-a-z-Buffer-for-Hidden-Surfaces-%E4%B8%BA%E9%9A%90%E8%97%8F%E8%A1%A8%E9%9D%A2%E4%BD%BF%E7%94%A8z-Buffer"><span class="nav-number">8.2.3.</span> <span class="nav-text">Using a z-Buffer for Hidden Surfaces 为隐藏表面使用z-Buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Precision-Issues-%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.3.1.</span> <span class="nav-text">Precision Issues 精度问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Per-vertex-Shading-%E9%80%90%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2"><span class="nav-number">8.2.4.</span> <span class="nav-text">Per-vertex Shading 逐顶点着色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Per-fragment-Shading-%E9%80%90%E7%89%87%E7%9D%80%E8%89%B2"><span class="nav-number">8.2.5.</span> <span class="nav-text">Per-fragment Shading 逐片着色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Texture-Mapping-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84"><span class="nav-number">8.2.6.</span> <span class="nav-text">Texture Mapping 纹理映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shading-Frequency-%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87"><span class="nav-number">8.2.7.</span> <span class="nav-text">Shading Frequency 着色频率</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Simple-Antialiasing-%E7%AE%80%E5%8D%95%E6%8A%97%E9%94%AF%E9%BD%BF"><span class="nav-number">8.3.</span> <span class="nav-text">Simple Antialiasing 简单抗锯齿</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Culling-Primitives-for-Efficiency-%E5%89%94%E9%99%A4%E5%8E%9F%E8%AF%AD%E4%BB%A5%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87"><span class="nav-number">8.4.</span> <span class="nav-text">Culling Primitives for Efficiency 剔除原语以提高效率</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#View-Volume-Culling-%E8%A7%86%E9%94%A5%E4%BD%93%E5%89%94%E9%99%A4"><span class="nav-number">8.4.1.</span> <span class="nav-text">View Volume Culling 视锥体剔除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Backface-Culling-%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4"><span class="nav-number">8.4.2.</span> <span class="nav-text">Backface Culling 背面剔除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-Signal-Processing-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">9 Signal Processing 信号处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Digital-Audio-Sampling-in-1D-%E6%95%B0%E5%AD%97%E9%9F%B3%E9%A2%91%EF%BC%9A%E4%B8%80%E7%BB%B4%E9%87%87%E6%A0%B7"><span class="nav-number">9.1.</span> <span class="nav-text">Digital Audio: Sampling in 1D 数字音频：一维采样</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sampling-Artifacts-and-Aliasing-%E9%87%87%E6%A0%B7%E4%BC%AA%E5%BD%B1%E5%92%8C%E8%B5%B0%E6%A0%B7"><span class="nav-number">9.1.1.</span> <span class="nav-text">Sampling Artifacts and Aliasing 采样伪影和走样</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Convolution-%E5%8D%B7%E7%A7%AF"><span class="nav-number">9.2.</span> <span class="nav-text">Convolution 卷积</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Moving-Averages-%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%E7%BA%BF"><span class="nav-number">9.2.1.</span> <span class="nav-text">Moving Averages 移动平均线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Discrete-Convolution-%E7%A6%BB%E6%95%A3%E5%8D%B7%E7%A7%AF"><span class="nav-number">9.2.2.</span> <span class="nav-text">Discrete Convolution 离散卷积</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Convolution-Filters-%E5%8D%B7%E7%A7%AF%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">9.2.2.1.</span> <span class="nav-text">Convolution Filters 卷积过滤器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Properties-of-Convolution-%E5%8D%B7%E7%A7%AF%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">9.2.2.2.</span> <span class="nav-text">Properties of Convolution 卷积的属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Convolution-as-a-Sum-of-Shifted-Filters-%E7%A7%BB%E4%BD%8D%E5%92%8C%E5%8D%B7%E7%A7%AF%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">9.2.3.</span> <span class="nav-text">Convolution as a Sum of Shifted Filters 移位和卷积滤波器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Convolution-with-Continuous-Functions-%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E5%8D%B7%E7%A7%AF"><span class="nav-number">9.2.4.</span> <span class="nav-text">Convolution with Continuous Functions 连续函数卷积</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Dirac-Delta-Function-%E7%8B%84%E6%8B%89%E5%85%8B%E5%87%BD%E6%95%B0"><span class="nav-number">9.2.4.1.</span> <span class="nav-text">The Dirac Delta Function 狄拉克函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Discrete-Continuous-Convolution-%E7%A6%BB%E6%95%A3%E8%BF%9E%E7%BB%AD%E5%8D%B7%E7%A7%AF"><span class="nav-number">9.2.5.</span> <span class="nav-text">Discrete-Continuous Convolution 离散连续卷积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Convolution-in-More-Than-One-Dimension-%E5%A4%9A%E7%BB%B4%E5%8D%B7%E7%A7%AF"><span class="nav-number">9.2.6.</span> <span class="nav-text">Convolution in More Than One Dimension 多维卷积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Convolution-Filters-%E5%8D%B7%E7%A7%AF%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">9.3.</span> <span class="nav-text">Convolution Filters 卷积滤波器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Gallery-of-Convolution-Filters-%E5%8D%B7%E7%A7%AF%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%BA%93"><span class="nav-number">9.3.1.</span> <span class="nav-text">A Gallery of Convolution Filters 卷积滤波器库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%92%E5%9E%8B%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">9.3.1.1.</span> <span class="nav-text">盒型滤波器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%90%E7%AF%B7%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">9.3.1.2.</span> <span class="nav-text">帐篷过滤器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">9.3.1.3.</span> <span class="nav-text">高斯滤波器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B%E6%A0%B7%E6%9D%A1%E4%B8%89%E6%AC%A1%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">9.3.1.4.</span> <span class="nav-text">B样条三次滤波器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Catmull-Rom-%E7%AB%8B%E6%96%B9%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">9.3.1.5.</span> <span class="nav-text">Catmull-Rom 立方滤波器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mitchell-Netravali%E7%AB%8B%E6%96%B9%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">9.3.1.6.</span> <span class="nav-text">Mitchell-Netravali立方滤波器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">9.3.2.</span> <span class="nav-text">滤波器的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Separable-Filters-%E5%8F%AF%E5%88%86%E7%A6%BB%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">9.3.2.1.</span> <span class="nav-text">Separable Filters 可分离的过滤器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Signal-Processing-for-Images-%E5%9B%BE%E5%83%8F%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="nav-number">9.4.</span> <span class="nav-text">Signal Processing for Images 图像信号处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Image-Filtering-Using-Discrete-Filters-%E4%BD%BF%E7%94%A8%E7%A6%BB%E6%95%A3%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2"><span class="nav-number">9.4.1.</span> <span class="nav-text">Image Filtering Using Discrete Filters 使用离散滤波器进行图像滤波</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Antialiasing-in-Image-Sampling-%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E4%B8%AD%E7%9A%84%E6%8A%97%E9%94%AF%E9%BD%BF"><span class="nav-number">9.4.2.</span> <span class="nav-text">Antialiasing in Image Sampling 图像采样中的抗锯齿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reconstruction-and-Resampling-%E9%87%8D%E6%9E%84%E5%92%8C%E9%87%8D%E9%87%87%E6%A0%B7"><span class="nav-number">9.4.3.</span> <span class="nav-text">Reconstruction and Resampling 重构和重采样</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sampling-Theory-%E9%87%87%E6%A0%B7%E7%90%86%E8%AE%BA"><span class="nav-number">9.5.</span> <span class="nav-text">Sampling Theory 采样理论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Fourier-Transform-%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="nav-number">9.5.1.</span> <span class="nav-text">The Fourier Transform 傅里叶变换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E5%B9%B3%E6%96%B9%E7%A7%AF%E5%88%86"><span class="nav-number">9.5.1.1.</span> <span class="nav-text">函数及其傅里叶变换具有相同的平方积分:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B2%BFx%E8%BD%B4%E6%8B%89%E4%BC%B8%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E5%85%B6%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%B9%9F%E4%BC%9A%E6%B2%BFu%E8%BD%B4%E5%8E%8B%E7%BC%A9%E7%9B%B8%E5%90%8C%E7%9A%84%E5%9B%A0%E5%AD%90-%E4%B8%8B%E5%9B%BE"><span class="nav-number">9.5.1.2.</span> <span class="nav-text">沿x轴拉伸函数时，其傅里叶变换也会沿u轴压缩相同的因子(下图):</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#f%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC%E7%AD%89%E4%BA%8Ef%CB%86-0-%EF%BC%9A"><span class="nav-number">9.5.1.3.</span> <span class="nav-text">f的平均值等于fˆ(0)：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9Cf%E6%98%AF%E5%AE%9E%E6%95%B0-%E5%AF%B9%E6%88%91%E4%BB%AC%E6%9D%A5%E8%AF%B4%E6%80%BB%E6%98%AF%E5%AE%9E%E6%95%B0-%EF%BC%8C%E5%88%99f%CB%86%E6%98%AF%E5%81%B6%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8D%B3f-u-%CB%86-f-%E2%88%92u-%EF%BC%9A"><span class="nav-number">9.5.1.4.</span> <span class="nav-text">如果f是实数(对我们来说总是实数)，则fˆ是偶函数，即f(u)ˆ&#x3D;f(−u)：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Convolution-and-the-Fourier-Transform-%E5%8D%B7%E7%A7%AF%E4%B8%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="nav-number">9.5.2.</span> <span class="nav-text">Convolution and the Fourier Transform 卷积与傅里叶变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Gallery-of-Fourier-Transforms-%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%BA%93"><span class="nav-number">9.5.3.</span> <span class="nav-text">A Gallery of Fourier Transforms 傅里叶变换库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dirac-Impulses-in-Sampling-Theory-%E9%87%87%E6%A0%B7%E7%90%86%E8%AE%BA%E4%B8%AD%E7%9A%84Dirac%E8%84%89%E5%86%B2"><span class="nav-number">9.5.4.</span> <span class="nav-text">Dirac Impulses in Sampling Theory 采样理论中的Dirac脉冲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sampling-and-Aliasing-%E9%87%87%E6%A0%B7%E5%92%8C%E8%B5%B0%E6%A0%B7"><span class="nav-number">9.5.5.</span> <span class="nav-text">Sampling and Aliasing 采样和走样</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Preventing-Aliasing-in-Sampling-%E9%98%B2%E6%AD%A2%E9%87%87%E6%A0%B7%E4%B8%AD%E7%9A%84%E8%B5%B0%E6%A0%B7"><span class="nav-number">9.5.5.1.</span> <span class="nav-text">Preventing Aliasing in Sampling 防止采样中的走样</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Preventing-Aliasing-in-Reconstruction-%E9%98%B2%E6%AD%A2%E9%87%8D%E5%BB%BA%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%8F%A0"><span class="nav-number">9.5.5.2.</span> <span class="nav-text">Preventing Aliasing in Reconstruction 防止重建中的混叠</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Preventing-Aliasing-in-Resampling-%E9%98%B2%E6%AD%A2%E9%87%8D%E9%87%87%E6%A0%B7%E4%B8%AD%E7%9A%84%E8%B5%B0%E6%A0%B7"><span class="nav-number">9.5.5.3.</span> <span class="nav-text">Preventing Aliasing in Resampling 防止重采样中的走样</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ideal-Filters-vs-Useful-Filters-%E7%90%86%E6%83%B3%E8%BF%87%E6%BB%A4%E5%99%A8VS%E6%9C%89%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">9.5.6.</span> <span class="nav-text">Ideal Filters vs. Useful Filters 理想过滤器VS有用过滤器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-Surface-Shading-%E8%A1%A8%E9%9D%A2%E7%9D%80%E8%89%B2"><span class="nav-number">10.</span> <span class="nav-text">10 Surface Shading 表面着色</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Diffuse-Shading-%E6%BC%AB%E5%8F%8D%E5%B0%84%E7%9D%80%E8%89%B2"><span class="nav-number">10.1.</span> <span class="nav-text">Diffuse Shading 漫反射着色</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambertian-Shading-Model-%E6%9C%97%E4%BC%AF%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B"><span class="nav-number">10.1.1.</span> <span class="nav-text">Lambertian Shading Model 朗伯着色模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ambient-Shading-%E7%8E%AF%E5%A2%83%E7%9D%80%E8%89%B2"><span class="nav-number">10.1.2.</span> <span class="nav-text">Ambient Shading 环境着色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vertex-Based-Diffuse-Shading-%E5%9F%BA%E4%BA%8E%E9%A1%B6%E7%82%B9%E7%9A%84%E6%BC%AB%E5%8F%8D%E5%B0%84%E7%9D%80%E8%89%B2"><span class="nav-number">10.1.3.</span> <span class="nav-text">Vertex-Based Diffuse Shading 基于顶点的漫反射着色</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Phong-Shading-Phong-%E7%9D%80%E8%89%B2"><span class="nav-number">10.2.</span> <span class="nav-text">Phong Shading Phong 着色</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Phong-Lighting-Model-Phong%E7%85%A7%E6%98%8E%E6%A8%A1%E5%9E%8B"><span class="nav-number">10.2.1.</span> <span class="nav-text">Phong Lighting Model Phong照明模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Surface-Normal-Vector-Interpolation-%E6%9B%B2%E9%9D%A2%E6%B3%95%E5%90%91%E9%87%8F%E6%8F%92%E5%80%BC"><span class="nav-number">10.2.2.</span> <span class="nav-text">Surface Normal Vector Interpolation 曲面法向量插值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Artistic-Shading-%E8%89%BA%E6%9C%AF%E7%9D%80%E8%89%B2"><span class="nav-number">10.3.</span> <span class="nav-text">Artistic Shading 艺术着色</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Line-Drawing-%E7%BB%98%E5%88%B6%E7%BA%BF"><span class="nav-number">10.3.1.</span> <span class="nav-text">Line Drawing 绘制线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cool-to-Warm-Shading-%E5%86%B7%E6%9A%96%E7%9D%80%E8%89%B2"><span class="nav-number">10.3.2.</span> <span class="nav-text">Cool-to-Warm Shading 冷暖着色</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-Texture-Mapping-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84"><span class="nav-number">11.</span> <span class="nav-text">11 Texture Mapping 纹理映射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Looking-Up-Texture-Values-%E6%9F%A5%E6%89%BE%E7%BA%B9%E7%90%86%E5%80%BC"><span class="nav-number">11.1.</span> <span class="nav-text">Looking Up Texture Values 查找纹理值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Texture-Coordinate-Functions-%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.</span> <span class="nav-text">Texture Coordinate Functions 纹理坐标函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Geometrically-Determined-Coordinates-%E5%87%A0%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%9D%90%E6%A0%87"><span class="nav-number">11.2.1.</span> <span class="nav-text">Geometrically Determined Coordinates 几何确定坐标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Planar-Projection-%E5%B9%B3%E8%A1%8C%E6%8A%95%E5%BD%B1"><span class="nav-number">11.2.1.1.</span> <span class="nav-text">Planar Projection 平行投影</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spherical-Coordinates-%E7%90%83%E5%9D%90%E6%A0%87"><span class="nav-number">11.2.1.2.</span> <span class="nav-text">Spherical Coordinates 球坐标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cylindrical-Coordinates-%E5%9C%86%E6%9F%B1%E5%9D%90%E6%A0%87"><span class="nav-number">11.2.1.3.</span> <span class="nav-text">Cylindrical Coordinates 圆柱坐标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cubemaps-%E7%AB%8B%E6%96%B9%E4%BD%93%E6%98%A0%E5%B0%84"><span class="nav-number">11.2.1.4.</span> <span class="nav-text">Cubemaps 立方体映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interpolated-Texture-Coordinates-%E6%8F%92%E5%80%BC%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87"><span class="nav-number">11.2.2.</span> <span class="nav-text">Interpolated Texture Coordinates 插值纹理坐标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tiling-Wrapping-Modes-and-Texture-Transformations-%E5%B9%B3%E9%93%BA%E3%80%81%E5%8C%85%E8%A3%B9%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BA%B9%E7%90%86%E8%BD%AC%E6%8D%A2"><span class="nav-number">11.2.3.</span> <span class="nav-text">Tiling, Wrapping Modes, and Texture Transformations 平铺、包裹模式和纹理转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Perspective-Correct-Interpolation-%E9%80%8F%E8%A7%86%E6%AD%A3%E7%A1%AE%E6%8F%92%E5%80%BC"><span class="nav-number">11.2.4.</span> <span class="nav-text">Perspective Correct Interpolation 透视正确插值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Continuity-and-Seams-%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%92%8C%E6%8E%A5%E7%BC%9D"><span class="nav-number">11.2.5.</span> <span class="nav-text">Continuity and Seams 连续性和接缝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Antialiasing-Texture-Lookups-%E6%8A%97%E9%94%AF%E9%BD%BF%E7%BA%B9%E7%90%86%E6%9F%A5%E6%89%BE"><span class="nav-number">11.3.</span> <span class="nav-text">Antialiasing Texture Lookups 抗锯齿纹理查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Footprint-of-a-Pixel-%E5%83%8F%E7%B4%A0%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4"><span class="nav-number">11.3.1.</span> <span class="nav-text">The Footprint of a Pixel 像素占用空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reconstruction-%E9%87%8D%E5%BB%BA"><span class="nav-number">11.3.2.</span> <span class="nav-text">Reconstruction 重建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mipmapping-%E6%98%A0%E5%B0%84"><span class="nav-number">11.3.3.</span> <span class="nav-text">Mipmapping 映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Texture-Filtering-with-Mipmaps-Mipmaps%E7%BA%B9%E7%90%86%E8%BF%87%E6%BB%A4"><span class="nav-number">11.3.4.</span> <span class="nav-text">Basic Texture Filtering with Mipmaps Mipmaps纹理过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Anisotropic-Filtering-%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E8%BF%87%E6%BB%A4"><span class="nav-number">11.3.5.</span> <span class="nav-text">Anisotropic Filtering 各向异性过滤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Applications-of-Texture-Mapping-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">11.4.</span> <span class="nav-text">Applications of Texture Mapping 纹理映射的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Controlling-Shading-Parameters-%E6%8E%A7%E5%88%B6%E7%9D%80%E8%89%B2%E5%8F%82%E6%95%B0"><span class="nav-number">11.4.1.</span> <span class="nav-text">Controlling Shading Parameters 控制着色参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Normal-Maps-and-Bump-Maps-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%E5%92%8C%E5%87%B9%E5%87%B8%E8%B4%B4%E5%9B%BE"><span class="nav-number">11.4.2.</span> <span class="nav-text">Normal Maps and Bump Maps 法线贴图和凹凸贴图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Displacement-Maps-%E7%BD%AE%E6%8D%A2%E8%B4%B4%E5%9B%BE"><span class="nav-number">11.4.3.</span> <span class="nav-text">Displacement Maps 置换贴图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shadow-Maps-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE"><span class="nav-number">11.4.4.</span> <span class="nav-text">Shadow Maps 阴影贴图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Environment-Maps-%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE"><span class="nav-number">11.4.5.</span> <span class="nav-text">Environment Maps 环境贴图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Procedural-3D-Textures-%E7%A8%8B%E5%BA%8F3D%E7%BA%B9%E7%90%86"><span class="nav-number">11.5.</span> <span class="nav-text">Procedural 3D Textures 程序3D纹理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3D-Stripe-Textures-3D%E6%9D%A1%E7%BA%B9%E7%BA%B9%E7%90%86"><span class="nav-number">11.5.1.</span> <span class="nav-text">3D Stripe Textures 3D条纹纹理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solid-Noise-%E5%9B%BA%E4%BD%93%E5%99%AA%E6%B3%A2"><span class="nav-number">11.5.2.</span> <span class="nav-text">Solid Noise 固体噪波</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Turbulence-%E6%B9%8D%E6%B5%81"><span class="nav-number">11.5.3.</span> <span class="nav-text">Turbulence 湍流</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-Data-Structures-for-Graphics-%E5%9B%BE%E5%BD%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">12.</span> <span class="nav-text">12 Data Structures for Graphics 图形的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Triangle-Meshes-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%BD%91%E6%A0%BC"><span class="nav-number">12.1.</span> <span class="nav-text">Triangle Meshes 三角形网格</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mesh-Topology-%E7%BD%91%E6%A0%BC%E6%8B%93%E6%89%91"><span class="nav-number">12.1.1.</span> <span class="nav-text">Mesh Topology 网格拓扑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Indexed-Mesh-Storage-%E7%B4%A2%E5%BC%95%E7%BD%91%E6%A0%BC%E5%AD%98%E5%82%A8"><span class="nav-number">12.1.2.</span> <span class="nav-text">Indexed Mesh Storage 索引网格存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Triangle-Strips-and-Fans-%E4%B8%89%E8%A7%92%E5%BD%A2%E5%B8%A6%E5%92%8C%E6%89%87"><span class="nav-number">12.1.3.</span> <span class="nav-text">Triangle Strips and Fans 三角形带和扇</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Structures-for-Mesh-Connectivity-%E7%94%A8%E4%BA%8E%E7%BD%91%E6%A0%BC%E8%BF%9E%E9%80%9A%E6%80%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">12.1.4.</span> <span class="nav-text">Data Structures for Mesh Connectivity 用于网格连通性的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Triangle-Neighbor-Structure-%E4%B8%89%E8%A7%92%E5%BD%A2%E9%82%BB%E8%BE%B9%E7%BB%93%E6%9E%84"><span class="nav-number">12.1.4.1.</span> <span class="nav-text">The Triangle-Neighbor Structure 三角形邻边结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Winged-Edge-Structure-%E7%BF%BC%E8%BE%B9%E7%BB%93%E6%9E%84"><span class="nav-number">12.1.4.2.</span> <span class="nav-text">The Winged-Edge Structure 翼边结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Half-Edge-Structure-%E5%8D%8A%E8%BE%B9%E7%BB%93%E6%9E%84"><span class="nav-number">12.1.4.3.</span> <span class="nav-text">The Half-Edge Structure 半边结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scene-Graphs-%E5%9C%BA%E6%99%AF%E5%9B%BE%E5%BD%A2"><span class="nav-number">12.2.</span> <span class="nav-text">Scene Graphs 场景图形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spatial-Data-Structures-%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">12.3.</span> <span class="nav-text">Spatial Data Structures 空间数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bounding-Boxes-%E8%BE%B9%E7%95%8C%E6%A1%86"><span class="nav-number">12.3.1.</span> <span class="nav-text">Bounding Boxes 边界框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hierarchical-Bounding-Boxes-%E5%B1%82%E6%AC%A1%E5%8C%85%E5%9B%B4%E6%A1%86"><span class="nav-number">12.3.2.</span> <span class="nav-text">Hierarchical Bounding Boxes 层次包围框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Uniform-Spatial-Subdivision-%E7%BB%9F%E4%B8%80%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86"><span class="nav-number">12.3.3.</span> <span class="nav-text">Uniform Spatial Subdivision 统一空间划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Axis-Aligned-Binary-Space-Partitioning-%E8%BD%B4%E5%AF%B9%E9%BD%90%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A9%BA%E9%97%B4%E5%88%86%E5%8C%BA"><span class="nav-number">12.3.4.</span> <span class="nav-text">Axis-Aligned Binary Space Partitioning 轴对齐二进制空间分区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BSP-Trees-for-Visibility-%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">12.4.</span> <span class="nav-text">BSP Trees for Visibility 可视性二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Overview-of-BSP-Tree-Algorithm-BSP%E6%A0%91%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="nav-number">12.4.1.</span> <span class="nav-text">Overview of BSP Tree Algorithm BSP树算法概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Building-the-Tree-%E6%9E%84%E5%BB%BA%E6%A0%91"><span class="nav-number">12.4.2.</span> <span class="nav-text">Building the Tree 构建树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cutting-Triangles-%E8%A3%81%E5%89%AA%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">12.4.3.</span> <span class="nav-text">Cutting Triangles 裁剪三角形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optimizing-the-Tree-%E4%BC%98%E5%8C%96%E6%A0%91"><span class="nav-number">12.4.4.</span> <span class="nav-text">Optimizing the Tree 优化树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tiling-Multidimensional-Arrays-%E5%B9%B3%E9%93%BA%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">12.5.</span> <span class="nav-text">Tiling Multidimensional Arrays 平铺多维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#One-Level-Tiling-for-2D-Arrays-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E7%BA%A7%E5%B9%B3%E9%93%BA"><span class="nav-number">12.5.1.</span> <span class="nav-text">One-Level Tiling for 2D Arrays 二维数组的一级平铺</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Example-Two-Level-Tiling-for-3D-Arrays-%E7%A4%BA%E4%BE%8B-%E7%94%A8%E4%BA%8E3D%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E7%BA%A7%E5%B9%B3%E9%93%BA"><span class="nav-number">12.5.2.</span> <span class="nav-text">Example: Two-Level Tiling for 3D Arrays 示例:用于3D数组的二级平铺</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-More-Ray-Tracing-%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA"><span class="nav-number">13.</span> <span class="nav-text">13 More Ray Tracing 更多的光线追踪</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Transparency-and-Refraction-%E9%80%8F%E6%98%8E%E5%BA%A6%E5%92%8C%E6%8A%98%E5%B0%84"><span class="nav-number">13.1.</span> <span class="nav-text">Transparency and Refraction 透明度和折射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Instancing-%E5%AE%9E%E4%BE%8B"><span class="nav-number">13.2.</span> <span class="nav-text">Instancing 实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Constructive-Solid-Geometry-%E6%9E%84%E5%BB%BA%E7%AB%8B%E4%BD%93%E5%87%A0%E4%BD%95"><span class="nav-number">13.3.</span> <span class="nav-text">Constructive Solid Geometry 构建立体几何</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Distribution-Ray-Tracing-%E5%88%86%E5%B8%83%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA"><span class="nav-number">13.4.</span> <span class="nav-text">Distribution Ray Tracing 分布光线追踪</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Antialiasing-%E6%8A%97%E9%94%AF%E9%BD%BF"><span class="nav-number">13.4.1.</span> <span class="nav-text">Antialiasing 抗锯齿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Soft-Shadows-%E8%BD%AF%E9%98%B4%E5%BD%B1"><span class="nav-number">13.4.2.</span> <span class="nav-text">Soft Shadows 软阴影</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Depth-of-Field-%E6%99%AF%E6%B7%B1"><span class="nav-number">13.4.3.</span> <span class="nav-text">Depth of Field 景深</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Glossy-Reflection-%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84"><span class="nav-number">13.4.4.</span> <span class="nav-text">Glossy Reflection 镜面反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Motion-Blur-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A"><span class="nav-number">13.4.5.</span> <span class="nav-text">Motion Blur 运动模糊</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-Sampling-%E9%87%87%E6%A0%B7"><span class="nav-number">14.</span> <span class="nav-text">14 Sampling 采样</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Integration-%E6%B7%B7%E5%90%88"><span class="nav-number">14.1.</span> <span class="nav-text">Integration 混合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Measures-and-Averages-%E5%BA%A6%E9%87%8F%E5%92%8C%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="nav-number">14.1.1.</span> <span class="nav-text">Measures and Averages 度量和平均值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Example-Measures-on-the-Lines-in-the-2D-Plane-%E4%BE%8B-%E5%9C%A8%E4%BA%8C%E7%BB%B4%E5%B9%B3%E9%9D%A2%E7%9A%84%E7%9B%B4%E7%BA%BF%E4%B8%8A%E5%BA%A6%E9%87%8F"><span class="nav-number">14.1.2.</span> <span class="nav-text">Example: Measures on the Lines in the 2D Plane 例:在二维平面的直线上度量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Example-Measure-of-Lines-in-3D-%E4%BE%8B-%E5%9C%A83D%E4%B8%AD%E5%BA%A6%E9%87%8F%E7%9B%B4%E7%BA%BF"><span class="nav-number">14.1.3.</span> <span class="nav-text">Example: Measure of Lines in 3D 例:在3D中度量直线</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Continuous-Probability-%E8%BF%9E%E7%BB%AD%E6%A6%82%E7%8E%87"><span class="nav-number">14.2.</span> <span class="nav-text">Continuous Probability 连续概率</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#One-Dimensional-Continuous-Probability-Density-Functions-%E4%B8%80%E7%BB%B4%E8%BF%9E%E7%BB%AD%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="nav-number">14.2.1.</span> <span class="nav-text">One-Dimensional Continuous Probability Density Functions 一维连续概率密度函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#One-Dimensional-Expected-Value-%E4%B8%80%E7%BB%B4%E6%9C%9F%E6%9C%9B%E5%80%BC"><span class="nav-number">14.2.2.</span> <span class="nav-text">One-Dimensional Expected Value 一维期望值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multidimensional-Random-Variables-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F"><span class="nav-number">14.2.3.</span> <span class="nav-text">Multidimensional Random Variables 多维随机变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Variance-%E6%96%B9%E5%B7%AE"><span class="nav-number">14.2.4.</span> <span class="nav-text">Variance 方差</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Estimated-Means-%E4%BC%B0%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="nav-number">14.2.5.</span> <span class="nav-text">Estimated Means 估计方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Monte-Carlo-Integration-%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86"><span class="nav-number">14.3.</span> <span class="nav-text">Monte Carlo Integration 蒙特卡洛积分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Quasi%E2%80%93Monte-Carlo-Integration-%E5%87%86%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%A7%AF%E5%88%86"><span class="nav-number">14.3.1.</span> <span class="nav-text">Quasi–Monte Carlo Integration 准蒙特卡罗积分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Choosing-Random-Points-%E9%80%89%E6%8B%A9%E9%9A%8F%E6%9C%BA%E7%82%B9"><span class="nav-number">14.4.</span> <span class="nav-text">Choosing Random Points 选择随机点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-Inversion-%E5%87%BD%E6%95%B0%E6%B1%82%E9%80%86"><span class="nav-number">14.4.1.</span> <span class="nav-text">Function Inversion 函数求逆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rejection-%E6%8B%92%E7%BB%9D"><span class="nav-number">14.4.2.</span> <span class="nav-text">Rejection 拒绝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Metropolis"><span class="nav-number">14.4.3.</span> <span class="nav-text">Metropolis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Example-Choosing-Random-Lines-in-the-Square-%E4%BE%8B-%E5%9C%A8%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%AD%E9%80%89%E6%8B%A9%E9%9A%8F%E6%9C%BA%E7%BA%BF"><span class="nav-number">14.4.4.</span> <span class="nav-text">Example: Choosing Random Lines in the Square 例:在正方形中选择随机线</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-Curves-%E6%9B%B2%E7%BA%BF"><span class="nav-number">15.</span> <span class="nav-text">15 Curves 曲线</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Curves-%E6%9B%B2%E7%BA%BF"><span class="nav-number">15.1.</span> <span class="nav-text">Curves 曲线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Parameterizations-and-Reparameterizations-%E5%8F%82%E6%95%B0%E5%8C%96%E5%92%8C%E9%87%8D%E6%96%B0%E5%8F%82%E6%95%B0%E5%8C%96"><span class="nav-number">15.1.1.</span> <span class="nav-text">Parameterizations and Reparameterizations 参数化和重新参数化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Piecewise-Parametric-Representations-%E5%88%86%E6%AE%B5%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA"><span class="nav-number">15.1.2.</span> <span class="nav-text">Piecewise Parametric Representations 分段参数表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Splines-%E6%A0%B7%E6%9D%A1%E7%BA%BF"><span class="nav-number">15.1.3.</span> <span class="nav-text">Splines 样条线</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Curve-Properties-%E6%9B%B2%E7%BA%BF%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">15.2.</span> <span class="nav-text">Curve Properties 曲线的性质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Continuity-%E8%BF%9E%E7%BB%AD%E6%80%A7"><span class="nav-number">15.2.1.</span> <span class="nav-text">Continuity 连续性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Polynomial-Pieces-%E5%88%86%E5%B8%83%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="nav-number">15.3.</span> <span class="nav-text">Polynomial Pieces 分布多项式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Polynomial-Notation-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AC%A6%E5%8F%B7"><span class="nav-number">15.3.1.</span> <span class="nav-text">Polynomial Notation 多项式符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Line-Segment-A%E7%BA%BF%E6%AE%B5"><span class="nav-number">15.3.2.</span> <span class="nav-text">A Line Segment  A线段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Matrix-Form-for-Polynomials-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F"><span class="nav-number">15.3.2.1.</span> <span class="nav-text">Matrix Form for Polynomials 多项式的矩阵形式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Beyond-Line-Segments-%E8%B6%85%E5%87%BA%E7%BA%BF%E6%AE%B5"><span class="nav-number">15.3.3.</span> <span class="nav-text">Beyond Line Segments 超出线段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Basis-Matrices-for-Cubics-%E4%B8%89%E6%AC%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%9F%BA%E7%9F%A9%E9%98%B5"><span class="nav-number">15.3.4.</span> <span class="nav-text">Basis Matrices for Cubics 三次多项式的基矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Blending-Functions-%E6%B7%B7%E5%90%88%E5%87%BD%E6%95%B0"><span class="nav-number">15.3.5.</span> <span class="nav-text">Blending Functions 混合函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interpolating-Polynomials-%E6%8F%92%E5%80%BC%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="nav-number">15.3.6.</span> <span class="nav-text">Interpolating Polynomials 插值多项式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Putting-Pieces-Together-%E6%8B%BC%E5%87%91"><span class="nav-number">15.4.</span> <span class="nav-text">Putting Pieces Together 拼凑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Knots-%E7%BB%93"><span class="nav-number">15.4.1.</span> <span class="nav-text">Knots 结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-Independent-Pieces-%E4%BD%BF%E7%94%A8%E7%8B%AC%E7%AB%8B%E5%9D%97"><span class="nav-number">15.4.2.</span> <span class="nav-text">Using Independent Pieces 使用独立块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Putting-Segments-Together-%E6%8B%BC%E8%A3%85%E7%89%87%E6%AE%B5"><span class="nav-number">15.4.3.</span> <span class="nav-text">Putting Segments Together 拼装片段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cubics-%E4%B8%89%E6%AC%A1%E6%9B%B2%E7%BA%BF"><span class="nav-number">15.5.</span> <span class="nav-text">Cubics 三次曲线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Natural-Cubics-%E8%87%AA%E7%84%B6%E4%B8%89%E6%AC%A1%E6%9B%B2%E7%BA%BF"><span class="nav-number">15.5.1.</span> <span class="nav-text">Natural Cubics 自然三次曲线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hermite-Cubics-Hermite%E4%B8%89%E6%AC%A1%E6%9B%B2%E7%BA%BF"><span class="nav-number">15.5.2.</span> <span class="nav-text">Hermite Cubics Hermite三次曲线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cardinal-%E5%9F%BA%E6%95%B0%E4%B8%89%E6%AC%A1%E6%9B%B2%E7%BA%BF"><span class="nav-number">15.5.3.</span> <span class="nav-text">Cardinal 基数三次曲线</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Approximating-Curves-%E8%BF%91%E4%BC%BC%E6%9B%B2%E7%BA%BF"><span class="nav-number">15.6.</span> <span class="nav-text">Approximating Curves 近似曲线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B%C2%B4ezier-Curves-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="nav-number">15.6.1.</span> <span class="nav-text">B´ezier Curves 贝塞尔曲线</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Geometric-Intuition-for-Bezier-Curves-B%C2%B4ezier%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%87%A0%E4%BD%95%E5%A4%96%E8%A7%82"><span class="nav-number">15.6.1.1.</span> <span class="nav-text">Geometric Intuition for Bezier Curves B´ezier曲线的几何外观</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-de-Casteljau-Algorithm-de-Casteljau%E7%AE%97%E6%B3%95"><span class="nav-number">15.6.1.2.</span> <span class="nav-text">The de Casteljau Algorithm de Casteljau算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Splines-B%E6%A0%B7%E6%9D%A1"><span class="nav-number">15.6.2.</span> <span class="nav-text">B-Splines B样条</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Uniform-Linear-B-Splines-%E7%BB%9F%E4%B8%80%E7%9A%84%E7%BA%BF%E6%80%A7B%E6%A0%B7%E6%9D%A1"><span class="nav-number">15.6.2.1.</span> <span class="nav-text">Uniform Linear B-Splines 统一的线性B样条</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Uniform-Quadratic-B-Splines-%E4%BA%8C%E6%AC%A1%E5%9D%87%E5%8C%80B%E6%A0%B7%E6%9D%A1"><span class="nav-number">15.6.2.2.</span> <span class="nav-text">Uniform Quadratic B-Splines 二次均匀B样条</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Uniform-Cubic-B-Splines-%E5%9D%87%E5%8C%80%E4%B8%89%E6%AC%A1B%E6%A0%B7%E6%9D%A1"><span class="nav-number">15.6.2.3.</span> <span class="nav-text">Uniform Cubic B-Splines 均匀三次B样条</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nonuniform-B-Splines-%E9%9D%9E%E5%9D%87%E5%8C%80B%E6%A0%B7%E6%9D%A1"><span class="nav-number">15.6.3.</span> <span class="nav-text">Nonuniform B-Splines 非均匀B样条</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Repeated-Knots-and-B-Spline-Interpolation-%E9%87%8D%E5%A4%8D%E7%BB%93%E7%82%B9%E5%92%8CB%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC"><span class="nav-number">15.6.3.1.</span> <span class="nav-text">Repeated Knots and B-Spline Interpolation 重复结点和B样条插值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NURBS"><span class="nav-number">15.6.4.</span> <span class="nav-text">NURBS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Summary-%E6%80%BB%E7%BB%93"><span class="nav-number">15.7.</span> <span class="nav-text">Summary 总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-Computer-Animation-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%A8%E7%94%BB"><span class="nav-number">16.</span> <span class="nav-text">16 Computer Animation 计算机动画</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Principles-of-Animation-%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86"><span class="nav-number">16.1.</span> <span class="nav-text">Principles of Animation 动画原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Timing-%E8%8A%82%E5%A5%8F"><span class="nav-number">16.1.1.</span> <span class="nav-text">Timing 节奏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Action-Layout-%E8%A1%8C%E5%8A%A8%E5%B8%83%E5%B1%80"><span class="nav-number">16.1.2.</span> <span class="nav-text">Action Layout 行动布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Animation-Techniques-%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF"><span class="nav-number">16.1.3.</span> <span class="nav-text">Animation Techniques 动画技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Animator-Control-vs-Automatic-Methods-%E5%8A%A8%E7%94%BB%E6%8E%A7%E5%88%B6vs-%E8%87%AA%E5%8A%A8%E6%96%B9%E6%B3%95"><span class="nav-number">16.1.4.</span> <span class="nav-text">Animator Control vs. Automatic Methods 动画控制vs.自动方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Keyframing-%E5%85%B3%E9%94%AE%E5%B8%A7"><span class="nav-number">16.2.</span> <span class="nav-text">Keyframing 关键帧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Motion-Controls-%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6"><span class="nav-number">16.2.1.</span> <span class="nav-text">Motion Controls 运动控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interpolating-Rotation-%E6%8F%92%E5%80%BC%E6%97%8B%E8%BD%AC"><span class="nav-number">16.2.2.</span> <span class="nav-text">Interpolating Rotation 插值旋转</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deformations-%E5%8F%98%E5%BD%A2"><span class="nav-number">16.3.</span> <span class="nav-text">Deformations 变形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Character-Animation-%E8%A7%92%E8%89%B2%E5%8A%A8%E7%94%BB"><span class="nav-number">16.4.</span> <span class="nav-text">Character Animation 角色动画</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Facial-Animation-%E9%9D%A2%E9%83%A8%E8%A1%A8%E6%83%85%E5%8A%A8%E7%94%BB"><span class="nav-number">16.4.1.</span> <span class="nav-text">Facial Animation 面部表情动画</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Motion-Capture-%E5%8A%A8%E4%BD%9C%E6%8D%95%E6%8D%89"><span class="nav-number">16.4.2.</span> <span class="nav-text">Motion Capture 动作捕捉</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Physics-Based-Animation-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB"><span class="nav-number">16.5.</span> <span class="nav-text">Physics-Based Animation 基于物理的动画</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Procedural-Techniques-%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF"><span class="nav-number">16.6.</span> <span class="nav-text">Procedural Techniques 程序技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Groups-of-Objects-%E5%AF%B9%E8%B1%A1%E7%BB%84"><span class="nav-number">16.7.</span> <span class="nav-text">Groups of Objects 对象组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-Using-Graphics-Hardware-%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BD%A2%E7%A1%AC%E4%BB%B6"><span class="nav-number">17.</span> <span class="nav-text">17 Using Graphics Hardware 使用图形硬件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Hardware-Overview-%E7%A1%AC%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">17.1.</span> <span class="nav-text">Hardware Overview 硬件概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What-Is-Graphics-Hardware-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE%E5%BD%A2%E7%A1%AC%E4%BB%B6"><span class="nav-number">17.2.</span> <span class="nav-text">What Is Graphics Hardware 什么是图形硬件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heterogeneous-Multiprocessing-%E5%BC%82%E6%9E%84%E5%A4%9A%E5%A4%84%E7%90%86"><span class="nav-number">17.3.</span> <span class="nav-text">Heterogeneous Multiprocessing 异构多处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Programming-with-OpenGL-%E4%BD%BF%E7%94%A8OpenGL%E7%BC%96%E7%A8%8B"><span class="nav-number">17.3.1.</span> <span class="nav-text">Programming with OpenGL 使用OpenGL编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Graphics-Hardware-Programming-Buffers-State-and-Shaders-%E5%9B%BE%E5%BD%A2%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BC%93%E5%86%B2%E5%8C%BA%E3%80%81%E7%8A%B6%E6%80%81%E5%92%8C%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">17.4.</span> <span class="nav-text">Graphics Hardware Programming: Buffers, State, and Shaders 图形硬件编程：缓冲区、状态和着色器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffers-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">17.4.1.</span> <span class="nav-text">Buffers 缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Display-Buffer-%E6%98%BE%E7%A4%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">17.4.2.</span> <span class="nav-text">Display Buffer 显示缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cycle-of-Refresh-%E5%88%B7%E6%96%B0%E5%91%A8%E6%9C%9F"><span class="nav-number">17.4.3.</span> <span class="nav-text">Cycle of Refresh 刷新周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#State-Machine-%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">17.5.</span> <span class="nav-text">State Machine 状态机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-OpenGL-Application-Layout-%E5%9F%BA%E6%9C%ACOpenGL%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%B8%83%E5%B1%80"><span class="nav-number">17.6.</span> <span class="nav-text">Basic OpenGL Application Layout 基本OpenGL应用程序布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Geometry-%E5%87%A0%E4%BD%95%E5%AD%A6"><span class="nav-number">17.7.</span> <span class="nav-text">Geometry 几何学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Describing-Geometry-for-the-Hardware-%E7%A1%AC%E4%BB%B6%E4%B8%8A%E6%8F%8F%E8%BF%B0%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6"><span class="nav-number">17.7.1.</span> <span class="nav-text">Describing Geometry for the Hardware 硬件上描述几何形状</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#A-First-Look-at-Shaders-%E5%88%9D%E6%8E%A2%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">17.8.</span> <span class="nav-text">A First Look at Shaders 初探着色器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vertex-Shader-Example-%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">17.8.1.</span> <span class="nav-text">Vertex Shader Example 顶点着色器示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fragment-Shader-Example-%E7%A2%8E%E7%89%87%E7%9D%80%E8%89%B2%E5%99%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">17.8.2.</span> <span class="nav-text">Fragment Shader Example 碎片着色器示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Loading-Compiling-and-Using-Shaders-%E5%8A%A0%E8%BD%BD%E3%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%BF%E7%94%A8%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">17.8.3.</span> <span class="nav-text">Loading, Compiling, and Using Shaders 加载、编译和使用着色器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vertex-Buffer-Objects-%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">17.9.</span> <span class="nav-text">Vertex Buffer Objects 顶点缓冲区对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vertex-Array-Objects-%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">17.10.</span> <span class="nav-text">Vertex Array Objects 顶点数组对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transformation-Matrices-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5"><span class="nav-number">17.11.</span> <span class="nav-text">Transformation Matrices 变换矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GLM"><span class="nav-number">17.11.1.</span> <span class="nav-text">GLM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-an-Orthographic-Projection-%E4%BD%BF%E7%94%A8%E6%AD%A3%E6%8A%95%E5%BD%B1%E6%B3%95"><span class="nav-number">17.11.2.</span> <span class="nav-text">Using an Orthographic Projection 使用正投影法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shading-with-Per-Vertex-Attributes-%E9%80%90%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7%E7%9D%80%E8%89%B2"><span class="nav-number">17.12.</span> <span class="nav-text">Shading with Per-Vertex Attributes 逐顶点属性着色</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Structs-of-Vertex-Data-%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">17.12.1.</span> <span class="nav-text">Structs of Vertex Data 顶点数据结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shading-in-the-Fragment-Processor-%E7%A2%8E%E7%89%87%E5%A4%84%E7%90%86%E5%99%A8%E7%9D%80%E8%89%B2"><span class="nav-number">17.13.</span> <span class="nav-text">Shading in the Fragment Processor 碎片处理器着色</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Blinn-Phong-Shader-Program-Vertex-Shader-Blinn-Phong%E7%9D%80%E8%89%B2%E7%A8%8B%E5%BA%8F-%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">17.13.1.</span> <span class="nav-text">Blinn-Phong Shader Program: Vertex Shader Blinn-Phong着色程序:顶点着色器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Blinn-Phong-Shader-Program-Fragment-Shader-Blinn-Phong-%E7%9D%80%E8%89%B2%E7%A8%8B%E5%BA%8F-%E7%A2%8E%E7%89%87%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">17.13.2.</span> <span class="nav-text">Blinn-Phong Shader Program: Fragment Shader Blinn-Phong 着色程序:碎片着色器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Normal-Shader-%E6%B3%95%E7%BA%BF%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">17.13.3.</span> <span class="nav-text">A Normal Shader 法线着色器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Meshes-and-Instancing-%E7%BD%91%E6%A0%BC%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">17.14.</span> <span class="nav-text">Meshes and Instancing 网格和实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Instancing-Models-%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="nav-number">17.14.1.</span> <span class="nav-text">Instancing Models 实例化模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Texture-Objects-%E7%BA%B9%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="nav-number">17.15.</span> <span class="nav-text">Texture Objects 纹理对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Texture-Lookup-in-Shaders-%E7%9D%80%E8%89%B2%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BA%B9%E7%90%86%E6%9F%A5%E6%89%BE"><span class="nav-number">17.15.1.</span> <span class="nav-text">Texture Lookup in Shaders 着色器中的纹理查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-Oriented-Design-for-Graphics-Hardware-Programming-%E5%9B%BE%E5%BD%A2%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A8%8B%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="nav-number">17.16.</span> <span class="nav-text">Object-Oriented Design for Graphics Hardware Programming 图形硬件编程的面向对象设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Continued-Learning-%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0"><span class="nav-number">17.17.</span> <span class="nav-text">Continued Learning 继续学习</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-Light-%E5%85%89%E7%85%A7"><span class="nav-number">18.</span> <span class="nav-text">18 Light 光照</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Radiometry-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6"><span class="nav-number">18.1.</span> <span class="nav-text">Radiometry 辐射度量学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Photons-%E5%85%89%E5%AD%90"><span class="nav-number">18.1.1.</span> <span class="nav-text">Photons 光子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spectral-Energy-%E5%85%89%E8%B0%B1%E8%83%BD%E9%87%8F"><span class="nav-number">18.1.2.</span> <span class="nav-text">Spectral Energy 光谱能量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Power-%E5%8A%9F%E7%8E%87"><span class="nav-number">18.1.3.</span> <span class="nav-text">Power 功率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Irradiance-%E8%BE%90%E7%85%A7%E5%BA%A6"><span class="nav-number">18.1.4.</span> <span class="nav-text">Irradiance 辐照度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Radiance-%E8%BE%90%E4%BA%AE%E5%BA%A6"><span class="nav-number">18.1.5.</span> <span class="nav-text">Radiance 辐亮度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Radiance-and-Other-Radiometric-Quantities-%E8%BE%90%E4%BA%AE%E5%BA%A6%E5%92%8C%E5%85%B6%E4%BB%96%E8%BE%90%E5%B0%84%E9%87%8F"><span class="nav-number">18.1.5.1.</span> <span class="nav-text">Radiance and Other Radiometric Quantities 辐亮度和其他辐射量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BRDF-%E5%8F%8C%E5%90%91%E5%8F%8D%E5%B0%84"><span class="nav-number">18.1.6.</span> <span class="nav-text">BRDF 双向反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Directional-Hemispherical-Reflectance-%E5%AE%9A%E5%90%91%E5%8D%8A%E7%90%83%E5%BD%A2%E5%8F%8D%E5%B0%84"><span class="nav-number">18.1.6.1.</span> <span class="nav-text">Directional Hemispherical Reflectance 定向半球形反射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ideal-Diffuse-BRDF-%E7%90%86%E6%83%B3%E7%9A%84%E5%8F%8C%E5%90%91%E5%8F%8D%E5%B0%84"><span class="nav-number">18.1.6.2.</span> <span class="nav-text">Ideal Diffuse BRDF 理想的双向反射</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transport-Equation-%E4%BC%A0%E6%92%AD%E6%96%B9%E7%A8%8B"><span class="nav-number">18.2.</span> <span class="nav-text">Transport Equation  传播方程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Photometry-%E5%85%89%E5%BA%A6%E6%B5%8B%E5%AE%9A"><span class="nav-number">18.3.</span> <span class="nav-text">Photometry 光度测定</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-Color-%E9%A2%9C%E8%89%B2"><span class="nav-number">19.</span> <span class="nav-text">19 Color 颜色</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Colorimetry-%E6%AF%94%E8%89%B2%E6%B3%95"><span class="nav-number">19.1.</span> <span class="nav-text">Colorimetry 比色法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Grassmann%E2%80%99s-Laws-%E6%A0%BC%E6%8B%89%E6%96%AF%E6%9B%BC%E5%AE%9A%E5%BE%8B"><span class="nav-number">19.1.1.</span> <span class="nav-text">Grassmann’s Laws 格拉斯曼定律</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cone-Responses-%E9%94%A5%E5%8F%8D%E5%BA%94"><span class="nav-number">19.1.2.</span> <span class="nav-text">Cone Responses 锥反应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Color-Matching-Experiments-%E9%85%8D%E8%89%B2%E5%AE%9E%E9%AA%8C"><span class="nav-number">19.1.3.</span> <span class="nav-text">Color Matching Experiments 配色实验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Standard-Observers-%E6%A0%87%E5%87%86%E8%A7%82%E5%AF%9F%E8%80%85"><span class="nav-number">19.1.4.</span> <span class="nav-text">Standard Observers 标准观察者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chromaticity-Coordinates-%E8%89%B2%E5%BA%A6%E5%9D%90%E6%A0%87"><span class="nav-number">19.1.5.</span> <span class="nav-text">Chromaticity Coordinates 色度坐标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Color-Spaces-%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4"><span class="nav-number">19.2.</span> <span class="nav-text">Color Spaces 颜色空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Constructing-a-Matrix-Transform-%E6%9E%84%E9%80%A0%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2"><span class="nav-number">19.2.1.</span> <span class="nav-text">Constructing a Matrix Transform 构造矩阵变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Device-Dependent-RGB-Spaces-%E8%AE%BE%E5%A4%87%E4%BE%9D%E8%B5%96%E7%9A%84RGB%E7%A9%BA%E9%97%B4"><span class="nav-number">19.2.2.</span> <span class="nav-text">Device-Dependent RGB Spaces 设备依赖的RGB空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LMS-Cone-Space-LMS%E9%94%A5%E4%BD%93%E7%A9%BA%E9%97%B4"><span class="nav-number">19.2.3.</span> <span class="nav-text">LMS Cone Space LMS锥体空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIE-1976-L-a-b"><span class="nav-number">19.2.4.</span> <span class="nav-text">CIE 1976 L* a* b*</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chromatic-Adaptation-%E8%89%B2%E5%BD%A9%E9%80%82%E5%BA%94"><span class="nav-number">19.3.</span> <span class="nav-text">Chromatic Adaptation 色彩适应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Color-Appearance-%E9%A2%9C%E8%89%B2%E5%A4%96%E8%A7%82"><span class="nav-number">19.4.</span> <span class="nav-text">Color Appearance 颜色外观</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-Visual-Perception-%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5"><span class="nav-number">20.</span> <span class="nav-text">20 Visual Perception 视觉感知</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vision-Science-%E8%A7%86%E8%A7%89%E7%A7%91%E5%AD%A6"><span class="nav-number">20.1.</span> <span class="nav-text">Vision Science 视觉科学</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Visual-Sensitivity-%E8%A7%86%E8%A7%89%E7%81%B5%E6%95%8F%E5%BA%A6"><span class="nav-number">20.2.</span> <span class="nav-text">Visual Sensitivity 视觉灵敏度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Brightness-and-Contrast-%E4%BA%AE%E5%BA%A6%E5%92%8C%E5%AF%B9%E6%AF%94%E5%BA%A6"><span class="nav-number">20.2.1.</span> <span class="nav-text">Brightness and Contrast 亮度和对比度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Color-%E9%A2%9C%E8%89%B2"><span class="nav-number">20.2.2.</span> <span class="nav-text">Color 颜色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dynamic-Range-%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4"><span class="nav-number">20.2.3.</span> <span class="nav-text">Dynamic Range 动态范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Field-of-View-and-Acuity-%E8%A7%86%E9%87%8E%E5%92%8C%E6%95%8F%E9%94%90%E5%BA%A6"><span class="nav-number">20.2.4.</span> <span class="nav-text">Field-of-View and Acuity 视野和敏锐度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Motion-%E8%BF%90%E5%8A%A8"><span class="nav-number">20.2.5.</span> <span class="nav-text">Motion 运动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spatial-Vision-%E7%A9%BA%E9%97%B4%E8%A7%86%E8%A7%89"><span class="nav-number">20.3.</span> <span class="nav-text">Spatial Vision 空间视觉</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Frames-of-Reference-and-Measurement-Scales-%E5%8F%82%E8%80%83%E6%A1%86%E6%9E%B6%E5%92%8C%E6%B5%8B%E9%87%8F%E9%87%8F%E8%A1%A8"><span class="nav-number">20.3.1.</span> <span class="nav-text">Frames of Reference and Measurement Scales 参考框架和测量量表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ocularmotor-Cues-%E7%9C%BC%E5%8A%A8%E4%BF%A1%E6%81%AF"><span class="nav-number">20.3.2.</span> <span class="nav-text">Ocularmotor Cues 眼动信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binocular-Disparity-%E5%8F%8C%E7%9C%BC%E5%B7%AE%E5%BC%82"><span class="nav-number">20.3.3.</span> <span class="nav-text">Binocular Disparity 双眼差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Motion-Cues-%E8%BF%90%E5%8A%A8%E4%BF%A1%E6%81%AF"><span class="nav-number">20.3.4.</span> <span class="nav-text">Motion Cues 运动信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pictorial-Cues-%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF"><span class="nav-number">20.3.5.</span> <span class="nav-text">Pictorial Cues 图像信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Objects-Locations-and-Events-%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%8D%E7%BD%AE%E5%92%8C%E4%BA%8B%E4%BB%B6"><span class="nav-number">20.4.</span> <span class="nav-text">Objects, Locations, and Events 对象、位置和事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-Recognition-%E5%AF%B9%E8%B1%A1%E8%AF%86%E5%88%AB"><span class="nav-number">20.4.1.</span> <span class="nav-text">Object Recognition 对象识别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Size-and-Distance-%E5%B0%BA%E5%AF%B8%E5%92%8C%E8%B7%9D%E7%A6%BB"><span class="nav-number">20.4.2.</span> <span class="nav-text">Size and Distance 尺寸和距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Events-%E4%BA%8B%E4%BB%B6"><span class="nav-number">20.4.3.</span> <span class="nav-text">Events 事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Picture-Perception-%E5%9B%BE%E5%83%8F%E6%84%9F%E7%9F%A5"><span class="nav-number">20.5.</span> <span class="nav-text">Picture Perception 图像感知</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-Tone-Reproduction-%E8%89%B2%E8%B0%83%E5%86%8D%E7%8E%B0"><span class="nav-number">21.</span> <span class="nav-text">21 Tone Reproduction 色调再现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Classification-%E5%88%86%E7%B1%BB"><span class="nav-number">21.1.</span> <span class="nav-text">Classification 分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dynamic-Range-%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4-1"><span class="nav-number">21.2.</span> <span class="nav-text">Dynamic Range 动态范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Color-%E9%A2%9C%E8%89%B2-1"><span class="nav-number">21.3.</span> <span class="nav-text">Color 颜色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Image-Formation-%E5%9B%BE%E5%83%8F%E5%BD%A2%E6%88%90"><span class="nav-number">21.4.</span> <span class="nav-text">Image Formation 图像形成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Frequency-Based-Operators-%E5%9F%BA%E4%BA%8E%E9%A2%91%E7%8E%87%E7%9A%84%E7%AE%97%E5%AD%90"><span class="nav-number">21.5.</span> <span class="nav-text">Frequency-Based Operators 基于频率的算子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gradient-Domain-Operators-%E6%A2%AF%E5%BA%A6%E5%9F%9F%E7%AE%97%E5%AD%90"><span class="nav-number">21.6.</span> <span class="nav-text">Gradient-Domain Operators 梯度域算子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spatial-Operators-%E7%A9%BA%E9%97%B4%E7%AE%97%E5%AD%90"><span class="nav-number">21.7.</span> <span class="nav-text">Spatial Operators 空间算子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Division-%E5%88%86%E9%83%A8"><span class="nav-number">21.8.</span> <span class="nav-text">Division 分部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sigmoids-Sigmoids-%E5%87%BD%E6%95%B0"><span class="nav-number">21.9.</span> <span class="nav-text">Sigmoids Sigmoids 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Other-Approaches-%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-number">21.10.</span> <span class="nav-text">Other Approaches 其他方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Night-Tonemapping-%E5%A4%9C%E9%97%B4%E8%89%B2%E8%B0%83%E6%98%A0%E5%B0%84"><span class="nav-number">21.11.</span> <span class="nav-text">Night Tonemapping 夜间色调映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Discussion-%E8%AE%A8%E8%AE%BA"><span class="nav-number">21.12.</span> <span class="nav-text">Discussion 讨论</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-Implicit-Modeling-%E9%9A%90%E5%BC%8F%E6%A8%A1%E5%9E%8B"><span class="nav-number">22.</span> <span class="nav-text">22 Implicit Modeling 隐式模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Implicit-Functions-Skeletal-Primitives-and-Summation-Blending-%E9%9A%90%E5%BC%8F%E5%87%BD%E6%95%B0%E3%80%81%E5%9F%BA%E6%9C%AC%E9%AA%A8%E6%9E%B6%E5%92%8C%E6%B7%B7%E5%90%88%E6%B1%82%E5%92%8C"><span class="nav-number">22.1.</span> <span class="nav-text">Implicit Functions, Skeletal Primitives, and Summation Blending 隐式函数、基本骨架和混合求和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C%C2%B9-Continuity-and-the-Gradient-C%C2%B9%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%92%8C%E6%A2%AF%E5%BA%A6"><span class="nav-number">22.1.1.</span> <span class="nav-text">C¹ Continuity and the Gradient  C¹连续性和梯度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Distance-Fields-R-Functions-and-F-Reps-%E8%B7%9D%E7%A6%BB%E5%AD%97%E6%AE%B5%E3%80%81R-%E5%87%BD%E6%95%B0%E5%92%8CF-Reps"><span class="nav-number">22.1.2.</span> <span class="nav-text">Distance Fields, R-Functions, and F-Reps 距离字段、R-函数和F-Reps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Level-Sets-%E6%B0%B4%E5%B9%B3%E9%9B%86"><span class="nav-number">22.1.3.</span> <span class="nav-text">Level Sets 水平集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Variational-Implicit-Surfaces-%E5%8F%98%E5%88%86%E9%9A%90%E5%BC%8F%E6%9B%B2%E9%9D%A2"><span class="nav-number">22.1.4.</span> <span class="nav-text">Variational Implicit Surfaces 变分隐式曲面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Convolution-Surfaces-%E5%8D%B7%E7%A7%AF%E8%A1%A8%E9%9D%A2"><span class="nav-number">22.1.5.</span> <span class="nav-text">Convolution Surfaces 卷积表面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Defining-Skeletal-Primitives-%E5%AE%9A%E4%B9%89%E9%AA%A8%E6%9E%B6%E5%9F%BA%E5%85%83"><span class="nav-number">22.1.6.</span> <span class="nav-text">Defining Skeletal Primitives 定义骨架基元</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rendering-%E6%B8%B2%E6%9F%93"><span class="nav-number">22.2.</span> <span class="nav-text">Rendering 渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Space-Partitioning-%E7%A9%BA%E9%97%B4%E5%88%86%E5%89%B2"><span class="nav-number">22.3.</span> <span class="nav-text">Space Partitioning 空间分割</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exhaustive-Search-%E7%A9%B7%E4%B8%BE%E6%90%9C%E7%B4%A2"><span class="nav-number">22.3.1.</span> <span class="nav-text">Exhaustive Search 穷举搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Algorithm-Description-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="nav-number">22.3.2.</span> <span class="nav-text">Algorithm Description 算法描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Data-Structures-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">22.3.2.1.</span> <span class="nav-text">Data Structures 数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Polygonization-Algorithm-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%8C%96%E7%AE%97%E6%B3%95"><span class="nav-number">22.3.3.</span> <span class="nav-text">Polygonization Algorithm 多边形化算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Finding-Cube-Surface-Intersections-%E6%89%BE%E5%88%B0%E7%AB%8B%E6%96%B9%E4%BD%93-%E6%9B%B2%E9%9D%A2%E7%9A%84%E7%9B%B8%E4%BA%A4"><span class="nav-number">22.3.3.1.</span> <span class="nav-text">Finding Cube-Surface Intersections 找到立方体-曲面的相交</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sampling-Problems-%E9%87%87%E6%A0%B7%E9%97%AE%E9%A2%98"><span class="nav-number">22.3.4.</span> <span class="nav-text">Sampling Problems 采样问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Subdividing-a-Cube-%E7%BB%86%E5%88%86%E7%AB%8B%E6%96%B9%E4%BD%93"><span class="nav-number">22.3.4.1.</span> <span class="nav-text">Subdividing a Cube 细分立方体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cell-Polygonization-%E7%BB%86%E8%83%9E%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%8C%96"><span class="nav-number">22.3.5.</span> <span class="nav-text">Cell Polygonization 细胞多边形化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#More-on-Blending-%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%85%B3%E4%BA%8E%E6%B7%B7%E5%90%88"><span class="nav-number">22.4.</span> <span class="nav-text">More on Blending 更多的关于混合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Constructive-Solid-Geometry-%E6%9E%84%E5%BB%BA%E5%AE%9E%E4%BD%93%E5%87%A0%E4%BD%95"><span class="nav-number">22.5.</span> <span class="nav-text">Constructive Solid Geometry 构建实体几何</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Warping-%E6%89%AD%E6%9B%B2"><span class="nav-number">22.6.</span> <span class="nav-text">Warping 扭曲</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Twist-%E6%89%AD"><span class="nav-number">22.6.1.</span> <span class="nav-text">Twist 扭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Taper-%E9%94%A5"><span class="nav-number">22.6.2.</span> <span class="nav-text">Taper 锥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bend-%E5%BC%AF%E6%9B%B2"><span class="nav-number">22.6.3.</span> <span class="nav-text">Bend 弯曲</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Precise-Contact-Modeling-%E7%B2%BE%E7%A1%AE%E6%8E%A5%E8%A7%A6%E6%A8%A1%E5%9E%8B"><span class="nav-number">22.7.</span> <span class="nav-text">Precise Contact Modeling 精确接触模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-BlobTree-%E8%9E%8D%E5%90%88%E6%A0%91"><span class="nav-number">22.8.</span> <span class="nav-text">The BlobTree 融合树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Traversing-the-BlobTree-%E9%81%8D%E5%8E%86BlobTree"><span class="nav-number">22.8.1.</span> <span class="nav-text">Traversing the BlobTree 遍历BlobTree</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Interactive-Implicit-Modeling-Systems-%E4%BA%A4%E4%BA%92%E5%BC%8F%E9%9A%90%E5%BC%8F%E6%A8%A1%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="nav-number">22.9.</span> <span class="nav-text">Interactive Implicit Modeling Systems 交互式隐式模型系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-Global-Illumination-%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7"><span class="nav-number">23.</span> <span class="nav-text">23 Global Illumination 全局光照</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Particle-Tracing-for-Lambertian-Scenes-%E6%9C%97%E4%BC%AF%E5%9C%BA%E6%99%AF%E7%9A%84%E7%B2%92%E5%AD%90%E8%BF%BD%E8%B8%AA"><span class="nav-number">23.1.</span> <span class="nav-text">Particle Tracing for Lambertian Scenes 朗伯场景的粒子追踪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Path-Tracing-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA"><span class="nav-number">23.2.</span> <span class="nav-text">Path Tracing 路径追踪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Accurate-Direct-Lighting-%E7%B2%BE%E7%A1%AE%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%85%89%E7%85%A7"><span class="nav-number">23.3.</span> <span class="nav-text">Accurate Direct Lighting 精确的直接光照</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mathematical-Framework-%E6%95%B0%E5%AD%A6%E6%A1%86%E6%9E%B6"><span class="nav-number">23.3.1.</span> <span class="nav-text">Mathematical Framework 数学框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sampling-a-Spherical-Luminaire-%E7%90%83%E5%BD%A2%E7%81%AF%E5%85%B7%E9%87%87%E6%A0%B7"><span class="nav-number">23.3.2.</span> <span class="nav-text">Sampling a Spherical Luminaire 球形灯具采样</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nondiffuse-Luminaries-%E9%9D%9E%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%85%89%E6%BA%90"><span class="nav-number">23.3.3.</span> <span class="nav-text">Nondiffuse Luminaries 非漫反射光源</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-Reflection-Models-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B"><span class="nav-number">24.</span> <span class="nav-text">24 Reflection Models 反射模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-World-Materials-%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E6%9D%90%E8%B4%A8"><span class="nav-number">24.1.</span> <span class="nav-text">Real-World Materials 真实世界材质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Smooth-Dielectrics-and-Metals-%E5%85%89%E6%BB%91%E7%94%B5%E4%BB%8B%E8%B4%A8%E5%92%8C%E9%87%91%E5%B1%9E"><span class="nav-number">24.1.1.</span> <span class="nav-text">Smooth Dielectrics and Metals 光滑电介质和金属</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rough-Surfaces-%E7%B2%97%E7%B3%99%E8%A1%A8%E9%9D%A2"><span class="nav-number">24.1.2.</span> <span class="nav-text">Rough Surfaces 粗糙表面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Diffuse-Materials-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8"><span class="nav-number">24.1.3.</span> <span class="nav-text">Diffuse Materials 漫反射材质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Translucent-Materials-%E5%8D%8A%E9%80%8F%E6%98%8E%E6%9D%90%E8%B4%A8"><span class="nav-number">24.1.4.</span> <span class="nav-text">Translucent Materials 半透明材质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Layered-Materials-%E5%88%86%E5%B1%82%E6%9D%90%E8%B4%A8"><span class="nav-number">24.1.5.</span> <span class="nav-text">Layered Materials 分层材质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementing-Reflection-Models-%E5%AE%9E%E6%97%B6%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8"><span class="nav-number">24.2.</span> <span class="nav-text">Implementing Reflection Models 实时反射材质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Specular-Reflection-Models-%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8"><span class="nav-number">24.3.</span> <span class="nav-text">Specular Reflection Models 镜面反射材质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Smooth-Layered-Model-%E5%B9%B3%E6%BB%91%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">24.4.</span> <span class="nav-text">Smooth-Layered Model 平滑分层模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rough-Layered-Model-%E7%B2%97%E7%B3%99%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">24.5.</span> <span class="nav-text">Rough-Layered Model 粗糙分层模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Anisotropic-Specular-BRDF-%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E9%AB%98%E5%85%89BRDF"><span class="nav-number">24.5.1.</span> <span class="nav-text">Anisotropic Specular BRDF 各向异性高光BRDF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Diffuse-Term-for-the-Anisotropic-Phong-Model-%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7Phong%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%89%A9%E6%95%A3%E9%A1%B9"><span class="nav-number">24.5.2.</span> <span class="nav-text">Diffuse Term for the Anisotropic Phong Model 各向异性Phong模型的扩散项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementing-the-Model-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9E%8B"><span class="nav-number">24.5.3.</span> <span class="nav-text">Implementing the Model 实现模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-Computer-Graphics-in-Games-%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2"><span class="nav-number">25.</span> <span class="nav-text">25 Computer Graphics in Games 游戏中的计算机图形</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Platforms-%E5%B9%B3%E5%8F%B0"><span class="nav-number">25.1.</span> <span class="nav-text">Platforms 平台</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Limited-Resources-%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90"><span class="nav-number">25.2.</span> <span class="nav-text">Limited Resources 有限资源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Processing-Time-%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4"><span class="nav-number">25.2.1.</span> <span class="nav-text">Processing Time 处理时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Storage-%E5%AD%98%E5%82%A8"><span class="nav-number">25.2.2.</span> <span class="nav-text">Storage 存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Development-Resources-%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90"><span class="nav-number">25.2.3.</span> <span class="nav-text">Development Resources 开发资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Optimization-Techniques-%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="nav-number">25.3.</span> <span class="nav-text">Optimization Techniques 优化技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Game-Types-%E6%B8%B8%E6%88%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">25.4.</span> <span class="nav-text">Game Types 游戏类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Game-Production-Process-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">25.5.</span> <span class="nav-text">The Game Production Process 游戏制作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Asset-Creation-%E8%B5%84%E4%BA%A7%E5%88%9B%E9%80%A0"><span class="nav-number">25.5.1.</span> <span class="nav-text">Asset Creation 资产创造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Initial-Modeling-%E6%9C%80%E5%88%9D%E7%9A%84%E5%BB%BA%E6%A8%A1"><span class="nav-number">25.5.1.1.</span> <span class="nav-text">Initial Modeling   最初的建模</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Texturing-%E7%BA%B9%E7%90%86"><span class="nav-number">25.5.2.</span> <span class="nav-text">Texturing  纹理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Shading-%E7%9D%80%E8%89%B2-1"><span class="nav-number">25.5.2.1.</span> <span class="nav-text">Shading 着色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lighting-%E7%85%A7%E6%98%8E"><span class="nav-number">25.5.2.2.</span> <span class="nav-text">Lighting 照明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Animation-%E5%8A%A8%E7%94%BB"><span class="nav-number">25.5.2.3.</span> <span class="nav-text">Animation 动画</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-Visualization-%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="nav-number">26.</span> <span class="nav-text">26 Visualization 可视化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Background-%E8%83%8C%E6%99%AF"><span class="nav-number">26.1.</span> <span class="nav-text">Background 背景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#History-%E5%8E%86%E5%8F%B2"><span class="nav-number">26.1.1.</span> <span class="nav-text">History 历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Resource-Limitations-%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="nav-number">26.1.2.</span> <span class="nav-text">Resource Limitations 资源限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Data-Types-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">26.2.</span> <span class="nav-text">Data Types 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dimension-and-Item-Count-%E5%B0%BA%E5%AF%B8%E5%92%8C%E9%A1%B9%E7%9B%AE%E8%AE%A1%E6%95%B0"><span class="nav-number">26.2.1.</span> <span class="nav-text">Dimension and Item Count 尺寸和项目计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Transformation-and-Derived-Dimensions-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%B4%BE%E7%94%9F%E7%BB%B4%E5%BA%A6"><span class="nav-number">26.2.2.</span> <span class="nav-text">Data Transformation and Derived Dimensions 数据转换和派生维度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Human-Centered-Design-Process-%E4%BB%A5%E4%BA%BA%E4%B8%BA%E6%9C%AC%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">26.3.</span> <span class="nav-text">Human-Centered Design Process 以人为本的设计过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Task-Characterization-%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0"><span class="nav-number">26.3.1.</span> <span class="nav-text">Task Characterization 任务描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Abstraction-%E6%8A%BD%E8%B1%A1"><span class="nav-number">26.3.2.</span> <span class="nav-text">Abstraction 抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Technique-and-Algorithm-Design-%E6%8A%80%E6%9C%AF%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="nav-number">26.3.3.</span> <span class="nav-text">Technique and Algorithm Design 技术与算法设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Validation-%E9%AA%8C%E8%AF%81"><span class="nav-number">26.3.4.</span> <span class="nav-text">Validation 验证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Visual-Encoding-Principles-%E8%A7%86%E8%A7%89%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86"><span class="nav-number">26.4.</span> <span class="nav-text">Visual Encoding Principles 视觉编码原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Visual-Channel-Characteristics-%E8%A7%86%E8%A7%89%E9%80%9A%E9%81%93%E7%89%B9%E5%BE%81"><span class="nav-number">26.4.1.</span> <span class="nav-text">Visual Channel Characteristics 视觉通道特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Color-%E9%A2%9C%E8%89%B2-2"><span class="nav-number">26.4.2.</span> <span class="nav-text">Color 颜色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2D-vs-3D-Spatial-Layouts-2D-VS-3D%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="nav-number">26.4.3.</span> <span class="nav-text">2D vs. 3D Spatial Layouts 2D VS 3D空间布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Text-Labels-%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE"><span class="nav-number">26.4.4.</span> <span class="nav-text">Text Labels 文本标签</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Interaction-Principles-%E4%BA%A4%E4%BA%92%E5%8E%9F%E5%88%99"><span class="nav-number">26.5.</span> <span class="nav-text">Interaction Principles 交互原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Overview-First-Zoom-and-Filter-Details-on-Demand-%E9%A6%96%E5%85%88%E6%A6%82%E8%BF%B0%EF%BC%8C%E7%BC%A9%E6%94%BE%E5%92%8C%E7%AD%9B%E9%80%89%EF%BC%8C%E6%8C%89%E9%9C%80%E6%8F%90%E4%BE%9B%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="nav-number">26.5.1.</span> <span class="nav-text">Overview First, Zoom and Filter, Details on Demand 首先概述，缩放和筛选，按需提供详细信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interactivity-Costs-%E4%BA%A4%E4%BA%92%E6%80%A7%E6%88%90%E6%9C%AC"><span class="nav-number">26.5.2.</span> <span class="nav-text">Interactivity Costs 交互性成本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Animation-%E5%8A%A8%E7%94%BB-1"><span class="nav-number">26.5.3.</span> <span class="nav-text">Animation 动画</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Composite-and-Adjacent-Views-%E5%90%88%E6%88%90%E8%A7%86%E5%9B%BE%E5%92%8C%E7%9B%B8%E9%82%BB%E8%A7%86%E5%9B%BE"><span class="nav-number">26.6.</span> <span class="nav-text">Composite and Adjacent Views 合成视图和相邻视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Single-Drawing-%E5%8D%95%E5%9B%BE"><span class="nav-number">26.6.1.</span> <span class="nav-text">Single Drawing 单图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Superimposing-and-Layering-%E5%8F%A0%E5%8A%A0%E5%92%8C%E5%88%86%E5%B1%82"><span class="nav-number">26.6.2.</span> <span class="nav-text">Superimposing and Layering 叠加和分层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Glyphs-%E7%AC%A6%E5%8F%B7"><span class="nav-number">26.6.3.</span> <span class="nav-text">Glyphs 符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multiple-Views-%E5%A4%9A%E4%B8%AA%E8%A7%86%E5%9B%BE"><span class="nav-number">26.6.4.</span> <span class="nav-text">Multiple Views 多个视图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Data-Reduction-%E6%95%B0%E6%8D%AE%E7%AE%80%E5%8C%96"><span class="nav-number">26.7.</span> <span class="nav-text">Data Reduction 数据简化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Overviews-and-Aggregation-%E7%AE%80%E4%BB%8B%E5%92%8C%E8%81%9A%E5%90%88"><span class="nav-number">26.7.1.</span> <span class="nav-text">Overviews and Aggregation 简介和聚合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Filtering-and-Navigation-%E8%BF%87%E6%BB%A4%E5%92%8C%E5%AF%BC%E8%88%AA"><span class="nav-number">26.7.2.</span> <span class="nav-text">Filtering and Navigation 过滤和导航</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Focus-Context-%E7%84%A6%E7%82%B9-%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">26.7.3.</span> <span class="nav-text">Focus+Context 焦点+上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dimensionality-Reduction-%E9%99%8D%E7%BB%B4"><span class="nav-number">26.7.4.</span> <span class="nav-text">Dimensionality Reduction 降维</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Examples-%E7%A4%BA%E4%BE%8B"><span class="nav-number">26.8.</span> <span class="nav-text">Examples 示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tables-%E8%A1%A8"><span class="nav-number">26.8.1.</span> <span class="nav-text">Tables 表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Graphs-%E5%9B%BE%E5%BD%A2"><span class="nav-number">26.8.2.</span> <span class="nav-text">Graphs 图形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trees-%E6%A0%91"><span class="nav-number">26.8.3.</span> <span class="nav-text">Trees 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Geographic-%E5%9C%B0%E7%90%86"><span class="nav-number">26.8.4.</span> <span class="nav-text">Geographic 地理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spatial-Fields-%E7%A9%BA%E9%97%B4%E9%A2%86%E5%9F%9F"><span class="nav-number">26.8.5.</span> <span class="nav-text">Spatial Fields 空间领域</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OSkirito"
      src="/images/head_image.png">
  <p class="site-author-name" itemprop="name">OSkirito</p>
  <div class="site-description" itemprop="description">CG技术的记录与分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oskirito" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oskirito" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OSkirito</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
