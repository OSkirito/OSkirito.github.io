<!DOCTYPE html>
<html lang="zh-CN">
    <head prefix="og: https://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>21-混合 - OS&#39;s Blog</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
  
  
  <meta property="og:title" content="21-混合 - OS&#39;s Blog" />
  
  <meta property="og:type" content="article" />
  
  <meta property="og:url" content="http://example.com/2024/02/28/21-%E6%B7%B7%E5%90%88/index.html" />
  
  <meta property="og:image" content="/favicon.png" />
  
  <meta property="og:article:published_time" content="2024-02-28T09:26:52.000Z" />
  
  <meta property="og:article:author" content="OSkirito" />
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
  
<link rel="stylesheet" href="/css/rainbow-banner.css">

  
  
  
<link rel="stylesheet" href="/css/toc.css">

  
  
  
  
  
<link rel="stylesheet" href="/css/post.css">

  
  
  
  
  

  
<meta name="generator" content="Hexo 5.4.2"></head>
    <body
        data-color-scheme="auto"
        data-uppercase-categories="true"
        
        data-rainbow-banner="true"
        data-rainbow-banner-shown="auto"
        data-rainbow-banner-month="6"
        data-rainbow-banner-colors="#e50000,#ff8d00,#ffee00,#008121,#004cff,#760188"
        
        data-config-root="/"
        
        data-toc="true"
        data-toc-max-depth="2"
        
        
    >
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/archives">Archives</a>
            
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/projects">Projects</a>
            
            
            
            <a class="nav-item" href="/about">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/MrWillCom" target="_blank" aria-label="GitHub">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-codepen nav-item-icon" href="https://codepen.io/mrwillcom" target="_blank" aria-label="CodePen">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-patreon nav-item-icon" href="https://www.patreon.com/MrWillCom" target="_blank" aria-label="Patreon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-mastodon nav-item-icon" href="https://noc.social/@MrWillCom" target="_blank" aria-label="Mastodon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-discord nav-item-icon" href="https://discord.gg/UKuFDjcfY8" target="_blank" aria-label="Discord">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-search nav-item-icon" href="/search" target="_blank" aria-label="Search">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        
<article class="post">
    <div class="meta">
        

        
        <div class="date" id="date">
            <span>February</span>
            <span>28,</span>
            <span>2024</span>
        </div>
        

        <h1 class="title">21-混合</h1>
    </div>

    <div class="divider"></div>

    <div class="content">
        <p>OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体不是纯色，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。</p>
<p>透明的物体可以是完全透明的（让所有的颜色穿过），或者是半透明的（它让颜色通过，同时也会显示自身的颜色）。一个物体的透明度是通过它颜色的alpha值来决定的。Alpha颜色值是颜色向量的第四个分量，对每个纹素(Texel)都包含了一个alpha值。这个alpha值精确地代表纹理各个部分的透明度。</p>
<h2 id="舍弃片段"><a href="#舍弃片段" class="headerlink" title="舍弃片段"></a>舍弃片段</h2><p>有些图片并不需要半透明，只需要根据纹理颜色值，显示一部分，或者不显示一部分，没有中间情况。比如说草，如果想不太费劲地创建草这种东西，你需要将一个草的纹理贴在一个2D四边形(Quad)上，然后将这个四边形放到场景中。然而，草的形状和2D四边形的形状并不完全相同，所以你只想显示草纹理的某些部分，而忽略剩下的部分。</p>
<p>下图这个纹理正是这样的，它要么是完全不透明的，要么是完全透明的，没有中间情况。可以看到，只要不是草的部分，这个图片显示的都是背景颜色而不是它本身的颜色。</p>
<img src="/2024/02/28/21-%E6%B7%B7%E5%90%88/grass.png" class="" title="grass">

<p>所以当添加像草这样的植被到场景中时，只显示草的部。这就需要丢弃(Discard)显示纹理中透明部分的片段，不将这些片段存储到颜色缓冲中。在此之前，还要知道如何加载一个透明的纹理。要想加载有alpha值的纹理，stb_image在纹理有alpha通道的时候会自动加载，但仍要告诉OpenGL，现在使用alpha通道了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br></pre></td></tr></table></figure>

<p>并且需要保证片段着色器中获取了纹理的全部4个颜色分量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(texture1, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个vector，向里面添加几个glm::vec3变量来代表草的位置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;glm::vec3&gt; vegetation;</span><br><span class="line">vegetation.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>(<span class="number">-1.5f</span>,  <span class="number">0.0f</span>, <span class="number">-0.48f</span>));</span><br><span class="line">vegetation.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>( <span class="number">1.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.51f</span>));</span><br><span class="line">vegetation.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>( <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.7f</span>));</span><br><span class="line">vegetation.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>(<span class="number">-0.3f</span>,  <span class="number">0.0f</span>, <span class="number">-2.3f</span>));</span><br><span class="line">vegetation.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>( <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-0.6f</span>));</span><br></pre></td></tr></table></figure>

<p>因为草的纹理是添加到四边形对象上的，还需要创建另外一个VAO，填充VBO，设置正确的顶点属性指针。接下来，在绘制完地板和两个立方体后，将绘制草：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindVertexArray</span>(vegetationVAO);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, grassTexture);  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; vegetation.<span class="built_in">size</span>(); i++) </span><br><span class="line">&#123;</span><br><span class="line">    model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    model = glm::<span class="built_in">translate</span>(model, vegetation[i]);               </span><br><span class="line">    shader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序你将看到：</p>
<img src="/2024/02/28/21-%E6%B7%B7%E5%90%88/image-20240304151817554.png" class="" title="image-20240304151817554">

<p>出现这种情况是OpenGL默认不知道怎么处理alpha值的，更不知道什么时候应该丢弃片段。GLSL中的discard命令，一旦被调用，它就会保证片段不会被进一步处理，所以就不会进入颜色缓冲。有了这个指令，就能够在片段着色器中检测一个片段的alpha值是否低于某个阈值，如果是的话，则丢弃这个片段，就好像它不存在一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D texture1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    vec4 texColor = <span class="built_in">texture</span>(texture1, TexCoords);</span><br><span class="line">    <span class="keyword">if</span>(texColor.a &lt; <span class="number">0.1</span>)</span><br><span class="line">        discard;</span><br><span class="line">    FragColor = texColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里检测被采样的纹理颜色的alpha值是否低于0.1的阈值，如果是的话，则丢弃这个片段。片段着色器保证了它只会渲染不是（几乎）完全透明的片段，现在的运行结果如下：</p>
<img src="/2024/02/28/21-%E6%B7%B7%E5%90%88/image-20240304153852736.png" class="" title="image-20240304153852736">

<p>注意，当采样纹理的边缘的时候，OpenGL会对边缘的值和纹理下一个重复的值进行插值（因为我们将它的环绕方式设置为了GL_REPEAT。这通常是没问题的，但是由于使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值）。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你alpha纹理的时候，请将纹理的环绕方式设置为GL_CLAMP_TO_EDGE：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure>

<p>可以在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/42a74efb9767caf8d469ed855e9b18e0b516d2ea/2024/02/28/21-%E6%B7%B7%E5%90%88/blending_code_01.rar">这里</a>获取到完整的代码</p>
<h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><p>虽然直接丢弃片段很好，但不能渲染半透明的图像。要想渲染有多个透明度级别的图像，需要启用混合(Blending)。和OpenGL大多数的功能一样，可以启用GL_BLEND来启用混合：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_BLEND);</span><br></pre></td></tr></table></figure>

<p>启用了混合之后，我们需要告诉OpenGL它该如何混合。OpenGL中的混合是通过下面这个方程来实现的：</p>
<img src="/2024/02/28/21-%E6%B7%B7%E5%90%88/image-20240306173043115.png" class="" title="image-20240306173043115">

<ul>
<li>方程右边第一个符号代表源颜色向量。这是源自纹理的颜色向量。</li>
<li>方程右边第二个符号代表源因子值。指定了alpha值对源颜色的影响。</li>
<li>方程右边第三个符号代表目标颜色向量。这是当前储存在颜色缓冲中的颜色向量。</li>
<li>方程右边第四个符号代表目标因子值。指定了alpha值对目标颜色的影响。</li>
</ul>
<p>片段着色器运行完成后，并且所有的测试都通过之后，这个混合方程(Blend Equation)才会应用到片段颜色输出与当前颜色缓冲中的值（当前片段之前储存的之前片段的颜色）上。源颜色和目标颜色将会由OpenGL自动设定，但源因子和目标因子的值可以由我们来决定。先来看一个例子：</p>
<img src="/2024/02/28/21-%E6%B7%B7%E5%90%88/blending_equation.png" class="" title="img">

<p>有两个方形，我们希望将这个半透明的绿色方形绘制在红色方形之上。红色的方形将会是目标颜色（所以它应该先在颜色缓冲中），我们将要在这个红色方形之上绘制这个绿色方形。</p>
<p>将源因子值设置为源颜色向量的alpha值，也就是0.6。目标方形的贡献应该为剩下的alpha值。如果绿色方形对最终颜色贡献了60%，那么红色方块应该对最终颜色贡献了40%，即1.0 - 0.6。所以将目标因子值设置为1减去源颜色向量的alpha值。这个方程变成了：</p>
<img src="/2024/02/28/21-%E6%B7%B7%E5%90%88/image-20240306173523895.png" class="" title="image-20240306173523895">

<p>结果就是重叠方形的片段包含了一个60%绿色，40%红色的一种脏兮兮的颜色：</p>
<img src="/2024/02/28/21-%E6%B7%B7%E5%90%88/blending_equation_mixed.png" class="" title="img">

<p>最终的颜色将会被储存到颜色缓冲中，替代之前的颜色。</p>
<p>该如何让OpenGL使用这样的因子呢？正好有一个专门的函数，叫做glBlendFunc。</p>
<p>glBlendFunc(GLenum sfactor, GLenum dfactor)函数接受两个参数，来设置源和目标因子。OpenGL定义了很多个选项，在下面列出大部分最常用的选项。注意常数源颜色向量可以通过glBlendColor函数来另外设置。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>GL_ZERO</code></td>
<td align="left">因子等于00</td>
</tr>
<tr>
<td align="left"><code>GL_ONE</code></td>
<td align="left">因子等于11</td>
</tr>
<tr>
<td align="left"><code>GL_SRC_COLOR</code></td>
<td align="left">因子等于源颜色向量</td>
</tr>
<tr>
<td align="left"><code>GL_ONE_MINUS_SRC_COLOR</code></td>
<td align="left">因子等于1−源颜色向量</td>
</tr>
<tr>
<td align="left"><code>GL_DST_COLOR</code></td>
<td align="left">因子等于目标颜色向量</td>
</tr>
<tr>
<td align="left"><code>GL_ONE_MINUS_DST_COLOR</code></td>
<td align="left">因子等于1−目标颜色向量</td>
</tr>
<tr>
<td align="left"><code>GL_SRC_ALPHA</code></td>
<td align="left">因子等于源颜色向量的alpha分量</td>
</tr>
<tr>
<td align="left"><code>GL_ONE_MINUS_SRC_ALPHA</code></td>
<td align="left">因子等于1−源颜色向量的alpha分量</td>
</tr>
<tr>
<td align="left"><code>GL_DST_ALPHA</code></td>
<td align="left">因子等于目标颜色向量的alpha分量</td>
</tr>
<tr>
<td align="left"><code>GL_ONE_MINUS_DST_ALPHA</code></td>
<td align="left">因子等于1−目标颜色向量的alpha分量</td>
</tr>
<tr>
<td align="left"><code>GL_CONSTANT_COLOR</code></td>
<td align="left">因子等于常数颜色向量</td>
</tr>
<tr>
<td align="left"><code>GL_ONE_MINUS_CONSTANT_COLOR</code></td>
<td align="left">因子等于1−常数颜色向量</td>
</tr>
<tr>
<td align="left"><code>GL_CONSTANT_ALPHA</code></td>
<td align="left">因子等于常数颜色向量的alpha分量</td>
</tr>
<tr>
<td align="left"><code>GL_ONE_MINUS_CONSTANT_ALPHA</code></td>
<td align="left">因子等于1−常数颜色向量的alpha分量</td>
</tr>
</tbody></table>
<p>为了获得之前两个方形的混合结果，我们需要使用源颜色向量的alpha作为源因子，使用1−alpha作为目标因子。这将会产生以下的glBlendFunc：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure>

<p>也可以使用glBlendFuncSeparate为RGB和alpha通道分别设置不同的选项：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBlendFuncSeparate</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);</span><br></pre></td></tr></table></figure>

<p>这个函数和之前设置的那样设置了RGB分量，但这样只能让最终的alpha分量被源颜色向量的alpha值所影响到。</p>
<p>OpenGL甚至给了更多的灵活性，允许改变方程中源和目标部分的运算符。当前源和目标是相加的，但如果愿意的话，也可以让它们相减。glBlendEquation(GLenum mode)允许我们设置运算符，它提供了三个选项：</p>
<ul>
<li>GL_FUNC_ADD：默认选项，将两个分量相加：result=𝑆𝑟𝑐+𝐷𝑠𝑡。</li>
<li>GL_FUNC_SUBTRACT：将两个分量相减： result=𝑆𝑟𝑐−𝐷𝑠𝑡。</li>
<li>GL_FUNC_REVERSE_SUBTRACT：将两个分量相减，但顺序相反：result=𝐷𝑠𝑡−𝑆𝑟𝑐。</li>
</ul>
<p>通常都可以省略调用glBlendEquation，因为GL_FUNC_ADD对大部分的操作来说都是希望的混合方程。</p>
<h2 id="渲染半透明纹理"><a href="#渲染半透明纹理" class="headerlink" title="渲染半透明纹理"></a>渲染半透明纹理</h2><p>既然已经知道OpenGL是如何处理混合的了，现在将使用下面的透明的窗户纹理。</p>
<img src="/2024/02/28/21-%E6%B7%B7%E5%90%88/blending_transparent_window.png" class="" title="blending_transparent_window">

<p>首先，在初始化时启用混合，并设定相应的混合函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line"><span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure>

<p>由于启用了混合，就不需要丢弃片段了，所以把片段着色器还原：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D texture1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(texture1, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在每当OpenGL渲染了一个片段时，它都会将当前片段的颜色和当前颜色缓冲中的片段颜色根据alpha值来进行混合。由于窗户纹理的玻璃部分是半透明的，应该能通窗户中看到背后的场景了。</p>
<img src="/2024/02/28/21-%E6%B7%B7%E5%90%88/image-20240307205941960.png" class="" title="image-20240307205941960">

<p>如果仔细看的话，最前面窗户的透明部分遮蔽了背后的窗户。发生这一现象的原因是，深度测试和混合一起使用的时候，当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，透明的部分会和其它值一样写入到深度缓冲中。结果窗户的整个四边形不论透明都会进行深度测试，深度测试丢弃了它们。</p>
<p>要想保证窗户中能够显示它们背后的窗户，需要先绘制背后的这部分窗户。这也就是说在绘制的时候，必须先手动将窗户按照最远到最近来排序，再按照顺序渲染。注意，对于草这种全透明的物体，可以选择丢弃透明的片段而不是混合它们，这样就解决了这些头疼的问题（没有深度问题）。</p>
<p>要想让混合在多个物体上工作，需要最先绘制最远的物体，最后绘制最近的物体。普通不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序。但仍要保证它们在绘制（排序的）透明物体之前已经绘制完毕了。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下：</p>
<ol>
<li>先绘制所有不透明的物体。</li>
<li>对所有透明的物体排序。</li>
<li>按顺序绘制所有透明的物体。</li>
</ol>
<p>排序透明物体的一种方法是，从观察者视角获取物体的距离。这可以通过计算摄像机位置向量和物体的位置向量之间的距离所获得。接下来把距离和它对应的位置向量存储到一个STL库的map数据结构中。map会自动根据键值(Key)对它的值排序，所以只要添加了所有的位置，并以它的距离作为键，它们就会自动根据距离值排序了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">float</span>, glm::vec3&gt; sorted;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; windows.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> distance = glm::<span class="built_in">length</span>(camera.Position - windows[i]);</span><br><span class="line">    sorted[distance] = windows[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的结果就是一个排序后的容器对象，它根据distance键值从低到高储存了每个窗户的位置。</p>
<p>之后，这次在渲染的时候，我们将以逆序（从远到近）从map中获取值，之后以正确的顺序绘制对应的窗户：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(std::map&lt;<span class="type">float</span>,glm::vec3&gt;::reverse_iterator it = sorted.<span class="built_in">rbegin</span>(); it != sorted.<span class="built_in">rend</span>(); ++it) </span><br><span class="line">&#123;</span><br><span class="line">    model = glm::<span class="built_in">mat4</span>();</span><br><span class="line">    model = glm::<span class="built_in">translate</span>(model, it-&gt;second);              </span><br><span class="line">    shader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用了map的一个反向迭代器(Reverse Iterator)，反向遍历其中的条目，并将每个窗户四边形位移到对应的窗户位置上。这是排序透明物体的一个比较简单的实现，它能够修复之前的问题，现在场景看起来是这样的：</p>
<img src="/2024/02/28/21-%E6%B7%B7%E5%90%88/image-20240308143341358.png" class="" title="image-20240308143341358">

<p>在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/18db67053d9186fa26b93c4874c49c0888f291e9/2024/02/28/21-%E6%B7%B7%E5%90%88/blending_code_02.rar">这里</a>获取完整的源代码。</p>
<p>虽然按照距离排序物体这种方法对我们这个场景能够正常工作，但它并没有考虑旋转、缩放或者其它的变换，奇怪形状的物体需要一个不同的计量，而不是仅仅一个位置向量。在场景中排序物体是一个很困难的技术，很大程度上由场景的类型所决定，更别说它额外需要消耗的处理能力了。完整渲染一个包含不透明和透明物体的场景并不是那么容易。更高级的技术还有次序无关透明度(Order Independent Transparency, OIT)。</p>

    </div>

    
    <div class="about">
        <h1>About this Post</h1>
        <div class="details">
            <p>This post is written by OSkirito, licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
        </div>
        
        <p class="tags">
            
            <i class="icon"></i>
            <a href="/tags/图形学/" class="tag">#图形学</a><a href="/tags/Shader/" class="tag">#Shader</a><a href="/tags/OpenGL/" class="tag">#OpenGL</a><a href="/tags/GLSL/" class="tag">#GLSL</a>
        </p>
        
    </div>
    

    <div class="container post-prev-next">
        
        <a href="/2024/03/08/22-%E9%9D%A2%E5%89%94%E9%99%A4/" class="next">
            <div>
                <div class="text">
                    <p class="label">Next</p>
                    <h3 class="title">22-面剔除</h3>
                </div>
            </div>
        </a>
        
        
        <a href="/2024/02/22/20-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95/" class="prev">
            <div>
                <div class="text">
                    <p class="label">Previous</p>
                    <h3 class="title">20-模板测试</>
                </div>
            </div>
        </a>
        
    </div>

    
        
        
    
</article>

        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h2 class="title">Blog</h2>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/archives" class="item">Archives</a>
                
                <a href="/tags" class="item">Tags</a>
                
                <a href="/categories" class="item">Categories</a>
                
                <a href="/search" class="item">Search</a>
                
                <a href="/friends" class="item">Friends</a>
                
                <a href="/projects" class="item">Projects</a>
                
                <a href="/resume" class="item">Resume</a>
                
                <a href="/about" class="item">About</a>
                
                <a href="/atom.xml" class="item">RSS</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Projects</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/rsa-cli" class="item">RSA CLI</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/hexo-theme-cupertino" class="item">Hexo Theme Cupertino</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/a-calendar" class="item">A Calendar</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/auto-mirroring-bucket" class="item">Auto Mirroring Bucket</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Me</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom" class="item">GitHub</a>
                
                <a target="_blank" rel="noopener" href="https://codepen.io/mrwillcom" class="item">CodePen</a>
                
                <a target="_blank" rel="noopener" href="https://www.patreon.com/MrWillCom" class="item">Patreon</a>
                
                <a target="_blank" rel="noopener" href="https://noc.social/@MrWillCom" class="item">Mastodon</a>
                
                <a target="_blank" rel="noopener" href="https://discord.gg/UKuFDjcfY8" class="item">Discord</a>
                
                <a href="mailto:mr.will.com@outlook.com" class="item">Email</a>
                
            </div>
            
        </div>
        <span>&copy; 2024 OSkirito<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> </span>
        
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
        
        

        
        <script src="https://unpkg.com/scrollreveal"></script>
        <script>
            window.addEventListener('load', () => {
                ScrollReveal({ delay: 250, reset: true, easing: 'cubic-bezier(0, 0, 0, 1)' })
                ScrollReveal().reveal('.post-list-item .cover-img img')
                ScrollReveal().reveal('.post-list-item, .card, .content p img, .content .block-large img', { distance: '60px', origin: 'bottom', duration: 800 })
            })
        </script>
        
    </body>
</html>