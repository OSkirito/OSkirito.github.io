<!DOCTYPE html>
<html lang="zh-CN">
    <head prefix="og: https://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>25-高级GLSL - OS&#39;s Blog</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
  
  
  <meta property="og:title" content="25-高级GLSL - OS&#39;s Blog" />
  
  <meta property="og:type" content="article" />
  
  <meta property="og:url" content="http://example.com/2024/03/27/25-%E9%AB%98%E7%BA%A7GLSL/index.html" />
  
  <meta property="og:image" content="/favicon.png" />
  
  <meta property="og:article:published_time" content="2024-03-27T09:53:50.000Z" />
  
  <meta property="og:article:author" content="OSkirito" />
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
  
<link rel="stylesheet" href="/css/rainbow-banner.css">

  
  
  
<link rel="stylesheet" href="/css/toc.css">

  
  
  
  
  
<link rel="stylesheet" href="/css/post.css">

  
  
  
  
  

  
<meta name="generator" content="Hexo 5.4.2"></head>
    <body
        data-color-scheme="auto"
        data-uppercase-categories="true"
        
        data-rainbow-banner="true"
        data-rainbow-banner-shown="always"
        data-rainbow-banner-month="auto"
        data-rainbow-banner-colors="#e50000,#ff8d00,#ffee00,#008121,#004cff,#760188"
        
        data-config-root="/"
        
        data-toc="true"
        data-toc-max-depth="2"
        
        
    >
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/archives">Archives</a>
            
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/projects">Projects</a>
            
            
            
            <a class="nav-item" href="/about">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/MrWillCom" target="_blank" aria-label="GitHub">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-codepen nav-item-icon" href="https://codepen.io/mrwillcom" target="_blank" aria-label="CodePen">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-patreon nav-item-icon" href="https://www.patreon.com/MrWillCom" target="_blank" aria-label="Patreon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-mastodon nav-item-icon" href="https://noc.social/@MrWillCom" target="_blank" aria-label="Mastodon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-discord nav-item-icon" href="https://discord.gg/UKuFDjcfY8" target="_blank" aria-label="Discord">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-search nav-item-icon" href="/search" target="_blank" aria-label="Search">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        
<article class="post">
    <div class="meta">
        

        
        <div class="date" id="date">
            <span>March</span>
            <span>27,</span>
            <span>2024</span>
        </div>
        

        <h1 class="title">25-高级GLSL</h1>
    </div>

    <div class="divider"></div>

    <div class="content">
        <h2 id="高级数据"><a href="#高级数据" class="headerlink" title="高级数据"></a>高级数据</h2><p>OpenGL中的缓冲只是一个管理特定内存块的对象，没有其它更多的功能了。将它绑定到一个缓冲目标(Buffer Target)时，才赋予了其意义。当绑定一个缓冲到GL_ARRAY_BUFFER时，它就是一个顶点数组缓冲，但也可以将其绑定到GL_ELEMENT_ARRAY_BUFFER。OpenGL内部会为每个目标储存一个缓冲，并且会根据目标的不同，以不同的方式处理缓冲。</p>
<p>到目前为止，一直是调用glBufferData函数来填充缓冲对象所管理的内存，这个函数会分配一块内存，并将数据添加到这块内存中。如果将它的<code>data</code>参数设置为<code>NULL</code>，那么这个函数将只会分配内存，但不进行填充。这需要预留(Reserve)特定大小的内存，之后回到这个缓冲一点一点填充。</p>
<p>除了使用一次函数调用填充整个缓冲之外，也可以使用glBufferSubData，填充缓冲的特定区域。这个函数需要一个缓冲目标、一个偏移量、数据的大小和数据本身作为它的参数。这个函数不同的地方在于，可以提供一个偏移量，指定从何处开始填充这个缓冲。要注意的是，缓冲需要有足够的已分配内存，所以对一个缓冲调用glBufferSubData之前必须要先调用glBufferData。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">24</span>, <span class="built_in">sizeof</span>(data), &amp;data); <span class="comment">// 范围： [24, 24 + sizeof(data)]</span></span><br></pre></td></tr></table></figure>

<p>将数据导入缓冲的另外一种方法是，请求缓冲内存的指针，直接将数据复制到缓冲当中。通过调用glMapBuffer函数，OpenGL会返回当前绑定缓冲的内存指针，供我们操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> data[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">-0.35f</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="comment">// 获取指针</span></span><br><span class="line"><span class="type">void</span> *ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class="line"><span class="comment">// 复制数据到内存</span></span><br><span class="line"><span class="built_in">memcpy</span>(ptr, data, <span class="built_in">sizeof</span>(data));</span><br><span class="line"><span class="comment">// 记得告诉OpenGL我们不再需要这个指针了</span></span><br><span class="line"><span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br></pre></td></tr></table></figure>

<p>当使用glUnmapBuffer函数，告诉OpenGL已经完成指针操作之后，OpenGL就会知道已经完成了。在解除映射(Unmapping)之后，指针将会不再可用，并且如果OpenGL能够成功将数据映射到缓冲中，这个函数将会返回GL_TRUE。</p>
<p>如果要直接映射数据到缓冲，而不事先将其存储到临时内存中，glMapBuffer这个函数会很有用。比如说，可以从文件中读取数据，并直接将它们复制到缓冲内存中。</p>
<p>通过使用glVertexAttribPointer，能够指定顶点数组缓冲内容的属性布局。在顶点数组缓冲中，对属性进行了交错(Interleave)处理，也就是说，将每一个顶点的位置、法线和/或纹理坐标紧密放置在一起。将每一种属性类型的向量数据打包(Batch)为一个大的区块，而不是对它们进行交错储存。与交错布局123123123123不同，我们将采用分批(Batched)的方式111122223333。</p>
<p>当从文件中加载顶点数据的时候，通常获取到的是一个位置数组、一个法线数组和/或一个纹理坐标数组。需要花点力气才能将这些数组转化为一个大的交错数据数组。使用分批的方式可以很容易使用glBufferSubData函数实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = &#123; ... &#125;;</span><br><span class="line"><span class="type">float</span> normals[] = &#123; ... &#125;;</span><br><span class="line"><span class="type">float</span> tex[] = &#123; ... &#125;;</span><br><span class="line"><span class="comment">// 填充缓冲</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">0</span>, <span class="built_in">sizeof</span>(positions), &amp;positions);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), <span class="built_in">sizeof</span>(normals), &amp;normals);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions) + <span class="built_in">sizeof</span>(normals), <span class="built_in">sizeof</span>(tex), &amp;tex);</span><br></pre></td></tr></table></figure>

<p>这样子就能直接将属性数组作为一个整体传递给缓冲，而不需要事先处理它们了。仍可以将它们合并为一个大的数组，再使用glBufferData来填充缓冲，但对于这种工作，使用glBufferSubData会更合适一点。</p>
<p>还需要更新顶点属性指针来反映这些改变：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);  </span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="built_in">sizeof</span>(positions)));  </span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(</span><br><span class="line">  <span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="built_in">sizeof</span>(positions) + <span class="built_in">sizeof</span>(normals)));</span><br></pre></td></tr></table></figure>

<p>注意<code>stride</code>参数等于顶点属性的大小，因为下一个顶点属性向量能在3个（或2个）分量之后找到。</p>
<p>使用哪种方法都不会对OpenGL有什么影响，它只是设置顶点属性的一种更整洁的方式。具体使用的方法将完全取决于你的喜好与程序类型。</p>
<p>当缓冲填充好数据之后，可能会想与其它的缓冲共享其中的数据，或者想要将缓冲的内容复制到另一个缓冲当中。glCopyBufferSubData能够从一个缓冲中复制数据到另一个缓冲中。这个函数的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glCopyBufferSubData</span><span class="params">(GLenum readtarget, GLenum writetarget, GLintptr readoffset,</span></span></span><br><span class="line"><span class="params"><span class="function">                         GLintptr writeoffset, GLsizeiptr size)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>readtarget</code>和<code>writetarget</code>参数需要填入复制源和复制目标的缓冲目标。比如说，可以将VERTEX_ARRAY_BUFFER缓冲复制到VERTEX_ELEMENT_ARRAY_BUFFER缓冲，分别将这些缓冲目标设置为读和写的目标。当前绑定到这些缓冲目标的缓冲将会被影响到。</p>
<p>不能同时将两个缓冲绑定到同一个缓冲目标上。正是出于这个原因，OpenGL提供给另外两个缓冲目标，叫做GL_COPY_READ_BUFFER和GL_COPY_WRITE_BUFFER。接下来就可以将需要的缓冲绑定到这两个缓冲目标上，并将这两个目标作为<code>readtarget</code>和<code>writetarget</code>参数。接下来glCopyBufferSubData会从<code>readtarget</code>中读取<code>size</code>大小的数据，并将其写入<code>writetarget</code>缓冲的<code>writeoffset</code>偏移量处：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_READ_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(vertexData));</span><br></pre></td></tr></table></figure>

<p>也可以只将<code>writetarget</code>缓冲绑定为新的缓冲目标类型之一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(vertexData));</span><br></pre></td></tr></table></figure>

<h2 id="GLSL的内建变量"><a href="#GLSL的内建变量" class="headerlink" title="GLSL的内建变量"></a>GLSL的内建变量</h2><p>着色器都是最简化的，如果需要当前着色器以外地方的数据的话，必须要将数据传进来。我们已经学会使用顶点属性、uniform和采样器来完成这一任务了。除此之外，GLSL还定义了另外几个以<code>gl_</code>为前缀的变量，它们能提供给更多的方式来读取/写入数据。如果想知道所有的内建变量的话，请查看OpenGL的<a target="_blank" rel="noopener" href="http://www.opengl.org/wiki/Built-in_Variable_(GLSL)">wiki</a>。</p>
<h3 id="顶点着色器变量"><a href="#顶点着色器变量" class="headerlink" title="顶点着色器变量"></a>顶点着色器变量</h3><p>我们已经见过gl_Position了，它是顶点着色器的裁剪空间输出位置向量。如果想在屏幕上显示任何东西，在顶点着色器中设置gl_Position是必须的步骤。这已经是它的全部功能了。</p>
<h4 id="gl-PointSize"><a href="#gl-PointSize" class="headerlink" title="gl_PointSize"></a>gl_PointSize</h4><p>我们能够选用的其中一个图元是GL_POINTS，如果使用它的话，每一个顶点都是一个图元，都会被渲染为一个点。可以通过OpenGL的glPointSize函数来设置渲染出来的点的大小，但也可以在顶点着色器中修改这个值。</p>
<p>GLSL定义了一个叫做gl_PointSize输出变量，它是一个float变量，可以使用它来设置点的宽高（像素）。在顶点着色器中修改点的大小的话，就能对每个顶点设置不同的值了。</p>
<p>在顶点着色器中修改点大小的功能默认是禁用的，如果需要启用它，可以使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_PROGRAM_POINT_SIZE);</span><br></pre></td></tr></table></figure>

<p>将点的大小设置为裁剪空间位置的z值，也就是顶点距观察者的距离。点的大小会随着观察者距顶点距离变远而增大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);    </span><br><span class="line">    gl_PointSize = gl_Position.z;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果就是，当远离这些点的时候，它们会变得更大：</p>
<h4 id="gl-VertexID"><a href="#gl-VertexID" class="headerlink" title="gl_VertexID"></a>gl_VertexID</h4><p>gl_Position和gl_PointSize都是输出变量，因为它们的值是作为顶点着色器的输出被读取的。可以对它们进行写入，来改变结果。顶点着色器还提供了一个有趣的输入变量，我们只能对它进行读取，它叫做gl_VertexID。</p>
<p>整型变量gl_VertexID储存了正在绘制顶点的当前ID。当（使用glDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。当（使用glDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。</p>
<h3 id="片段着色器变量"><a href="#片段着色器变量" class="headerlink" title="片段着色器变量"></a>片段着色器变量</h3><p>在片段着色器中，也能访问到一些变量。GLSL提供了两个输入变量：gl_FragCoord和gl_FrontFacing。</p>
<h4 id="gl-FragCoord"><a href="#gl-FragCoord" class="headerlink" title="gl_FragCoord"></a>gl_FragCoord</h4><p>在深度测试的时候，已经使用过gl_FragCoord很多次了，因为gl_FragCoord的z分量等于对应片段的深度值。然而，也能使用它的x和y分量来实现一些有趣的效果。</p>
<p>gl_FragCoord的x和y分量是片段的窗口空间(Window-space)坐标，其原点为窗口的左下角。我们已经使用glViewport设定了一个800x600的窗口了，所以片段窗口空间坐标的x分量将在0到800之间，y分量在0到600之间。</p>
<p>通过利用片段着色器，我们可以根据片段的窗口坐标，计算出不同的颜色。gl_FragCoord的一个常见用处是用于对比不同片段计算的视觉输出效果，这在技术演示中可以经常看到。比如说，我们能够将屏幕分成两部分，在窗口的左侧渲染一种输出，在窗口的右侧渲染另一种输出。下面这个例子片段着色器会根据窗口坐标输出不同的颜色：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="keyword">if</span>(gl_FragCoord.x &lt; <span class="number">400</span>)</span><br><span class="line">        FragColor = <span class="built_in">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        FragColor = <span class="built_in">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为窗口的宽度是800。当一个像素的x坐标小于400时，它一定在窗口的左侧，所以我们给它一个不同的颜色。</p>

    </div>

    
    <div class="about">
        <h1>About this Post</h1>
        <div class="details">
            <p>This post is written by OSkirito, licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
        </div>
        
        <p class="tags">
            
            <i class="icon"></i>
            <a href="/tags/图形学/" class="tag">#图形学</a><a href="/tags/Shader/" class="tag">#Shader</a><a href="/tags/OpenGL/" class="tag">#OpenGL</a><a href="/tags/GLSL/" class="tag">#GLSL</a>
        </p>
        
    </div>
    

    <div class="container post-prev-next">
        <a class="next"></a>
        
        <a href="/2024/03/14/24-%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE/" class="prev">
            <div>
                <div class="text">
                    <p class="label">Previous</p>
                    <h3 class="title">24-立方体贴图</>
                </div>
            </div>
        </a>
        
    </div>

    
        
        
    
</article>

        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h2 class="title">Blog</h2>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/archives" class="item">Archives</a>
                
                <a href="/tags" class="item">Tags</a>
                
                <a href="/categories" class="item">Categories</a>
                
                <a href="/search" class="item">Search</a>
                
                <a href="/friends" class="item">Friends</a>
                
                <a href="/projects" class="item">Projects</a>
                
                <a href="/resume" class="item">Resume</a>
                
                <a href="/about" class="item">About</a>
                
                <a href="/atom.xml" class="item">RSS</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Projects</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/rsa-cli" class="item">RSA CLI</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/hexo-theme-cupertino" class="item">Hexo Theme Cupertino</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/a-calendar" class="item">A Calendar</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/auto-mirroring-bucket" class="item">Auto Mirroring Bucket</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Me</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom" class="item">GitHub</a>
                
                <a target="_blank" rel="noopener" href="https://codepen.io/mrwillcom" class="item">CodePen</a>
                
                <a target="_blank" rel="noopener" href="https://www.patreon.com/MrWillCom" class="item">Patreon</a>
                
                <a target="_blank" rel="noopener" href="https://noc.social/@MrWillCom" class="item">Mastodon</a>
                
                <a target="_blank" rel="noopener" href="https://discord.gg/UKuFDjcfY8" class="item">Discord</a>
                
                <a href="mailto:mr.will.com@outlook.com" class="item">Email</a>
                
            </div>
            
        </div>
        <span>&copy; 2024 OSkirito<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> </span>
        
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
        
        

        
        <script src="https://unpkg.com/scrollreveal"></script>
        <script>
            window.addEventListener('load', () => {
                ScrollReveal({ delay: 250, reset: true, easing: 'cubic-bezier(0, 0, 0, 1)' })
                ScrollReveal().reveal('.post-list-item .cover-img img')
                ScrollReveal().reveal('.post-list-item, .card, .content p img, .content .block-large img', { distance: '60px', origin: 'bottom', duration: 800 })
            })
        </script>
        
    </body>
</html>