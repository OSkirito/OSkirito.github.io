<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="阴影是光线被阻挡的结果；当一个光源的光线由于其他物体的阻挡不能够达到一个物体的表面的时候，那么这个物体就处在阴影中了。阴影能够使场景看起来真实得多，并且可以让观察者获得物体之间的空间位置关系，场景和物体的深度感能够得到极大提升。 阴影还是比较不好实现的，因为当前实时渲染领域还没找到一种完美的阴影算法。目前有几种近似阴影技术，但它们都有自己的缺点和不足，这是我们必须要考虑到的。视频游戏中较多使用的一">
<meta property="og:type" content="article">
<meta property="og:title" content="31-阴影贴图">
<meta property="og:url" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/index.html">
<meta property="og:site_name" content="OS&#39;s Blog">
<meta property="og:description" content="阴影是光线被阻挡的结果；当一个光源的光线由于其他物体的阻挡不能够达到一个物体的表面的时候，那么这个物体就处在阴影中了。阴影能够使场景看起来真实得多，并且可以让观察者获得物体之间的空间位置关系，场景和物体的深度感能够得到极大提升。 阴影还是比较不好实现的，因为当前实时渲染领域还没找到一种完美的阴影算法。目前有几种近似阴影技术，但它们都有自己的缺点和不足，这是我们必须要考虑到的。视频游戏中较多使用的一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_theory.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_theory_spaces.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241118124001483.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241129162924357.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203153007456.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_acne_diagram.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_acne_bias.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203154054133.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203154400331.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_culling.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203164257058.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203165556309.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203165704357.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203171805737.png">
<meta property="og:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_projection.png">
<meta property="article:published_time" content="2024-10-14T12:45:41.000Z">
<meta property="article:modified_time" content="2024-12-03T09:52:25.582Z">
<meta property="article:author" content="OSkirito">
<meta property="article:tag" content="图形学">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="OpenGL">
<meta property="article:tag" content="GLSL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_theory.png">

<link rel="canonical" href="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>31-阴影贴图 | OS's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OS's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">47</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          31-阴影贴图
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-14 20:45:41" itemprop="dateCreated datePublished" datetime="2024-10-14T20:45:41+08:00">2024-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-03 17:52:25" itemprop="dateModified" datetime="2024-12-03T17:52:25+08:00">2024-12-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>阴影是光线被阻挡的结果；当一个光源的光线由于其他物体的阻挡不能够达到一个物体的表面的时候，那么这个物体就处在阴影中了。阴影能够使场景看起来真实得多，并且可以让观察者获得物体之间的空间位置关系，场景和物体的深度感能够得到极大提升。</p>
<p>阴影还是比较不好实现的，因为当前实时渲染领域还没找到一种完美的阴影算法。目前有几种近似阴影技术，但它们都有自己的缺点和不足，这是我们必须要考虑到的。视频游戏中较多使用的一种技术是阴影贴图（shadow mapping），效果不错，而且相对容易实现。阴影贴图并不难以理解，性能也不会太低，而且非常容易扩展成更高级的算法。</p>
<h2 id="阴影贴图"><a href="#阴影贴图" class="headerlink" title="阴影贴图"></a>阴影贴图</h2><p>阴影映射(Shadow Mapping)背后的思路非常简单：我们以光的位置为视角进行渲染，我们能看到的东西都将被点亮，看不见的一定是在阴影之中了。假设有一个地板，在光源和它之间有一个大盒子。由于光源处向光线方向看去，可以看到这个盒子，但看不到地板的一部分，这部分就应该在阴影中了。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_theory.png" class="" title="img">

<p>这里的所有蓝线代表光源可以看到的fragment。黑线代表被遮挡的fragment：它们应该渲染为带阴影的。如果我们绘制一条从光源出发，到达最右边盒子上的一个片段上的线段或射线，那么射线将先击中悬浮的盒子，随后才会到达最右侧的盒子。结果就是悬浮的盒子被照亮，而最右侧的盒子将处于阴影之中。</p>
<p>我们希望得到射线第一次击中的那个物体，然后用这个最近点和射线上其他点进行对比。然后我们将测试一下看看射线上的其他点是否比最近点更远，如果是的话，这个点就在阴影中。对从光源发出的射线上的成千上万个点进行遍历是个极端消耗性能的举措，实时渲染上基本不可取。我们可以采取相似举措，不用投射出光的射线，使用另一个非常熟悉的东西：深度缓冲。</p>
<p>在深度缓冲里的一个值是摄像机视角下，对应于一个片段的一个0到1之间的深度值。如果我们从光源的透视图来渲染场景，并把深度值的结果储存到纹理中。通过这种方式，我们就能对光源的透视图所见的最近的深度值进行采样。最终，深度值就会显示从光源的透视图下见到的第一个片段了。我们把储存在纹理中的所有这些深度值，叫做深度贴图（depth map）或阴影贴图。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_theory_spaces.png" class="" title="img">

<p>左侧的图片展示了一个定向光源（所有光线都是平行的）在立方体下的表面投射的阴影。通过储存到深度贴图中的深度值，我们就能找到最近点，用以决定片段是否在阴影中。我们使用一个来自光源的视图和投影矩阵来渲染场景就能创建一个深度贴图。这个投影和视图矩阵结合在一起成为一个<em><strong>T</strong></em>变换，它可以将任何三维位置转变到光源的可见坐标空间。</p>
<p><em>定向光并没有位置，因为它被规定为无穷远。然而，为了实现阴影贴图，我们得从一个光的透视图渲染场景，这样就得在光的方向的某一点上渲染场景。</em></p>
<p>在右边的图中我们显示出同样的平行光和观察者。我们渲染一个点P处的片段，需要决定它是否在阴影中。我们先得使用<em><strong>T</strong></em>把P变换到光源的坐标空间里。既然点P是从光的透视图中看到的，它的z坐标就对应于它的深度，例子中这个值是0.9。使用点P在光源的坐标空间的坐标，我们可以索引深度贴图，来获得从光的视角中最近的可见深度，结果是点C，最近的深度是0.4。因为索引深度贴图的结果是一个小于点P的深度，我们可以断定P被挡住了，它在阴影中了。</p>
<p>阴影映射由两个步骤组成：首先，我们渲染深度贴图，然后我们像往常一样渲染场景，使用生成的深度贴图来计算片段是否在阴影之中。</p>
<h3 id="深度贴图"><a href="#深度贴图" class="headerlink" title="深度贴图"></a>深度贴图</h3><p>第一步我们需要生成一张深度贴图(Depth Map)。深度贴图是从光的透视图里渲染的深度纹理，用它计算阴影。因为我们需要将场景的渲染结果储存到一个纹理中，所以我们需要再次用到帧缓冲。</p>
<p>首先，为渲染的深度贴图创建一个帧缓冲对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint depthMapFBO;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;depthMapFBO);</span><br></pre></td></tr></table></figure>

<p>然后，创建一个2D纹理，提供给帧缓冲的深度缓冲使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> GLuint SHADOW_WIDTH = <span class="number">1024</span>, SHADOW_HEIGHT = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">GLuint depthMap;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;depthMap);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, depthMap);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT, </span><br><span class="line">             SHADOW_WIDTH, SHADOW_HEIGHT, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br></pre></td></tr></table></figure>

<p>生成深度贴图不会太复杂。因为只关心深度值，所以把纹理格式指定为GL_DEPTH_COMPONENT，并且把纹理的高宽设置为1024：深度贴图的分辨率。把生成的深度纹理作为帧缓冲的深度缓冲：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glDrawBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glReadBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>我们需要的只是在从光的透视图下渲染场景的时候深度信息，所以颜色缓冲没有用。但是，不包含颜色缓冲的帧缓冲对象是不完整的，所以需要告诉OpenGL不适用任何颜色数据进行渲染。将调用glDrawBuffer和glReadBuffer把读和绘制缓冲设置为GL_NONE。合理配置将深度值渲染到纹理的帧缓冲后，就可以开始第一步了：生成深度贴图。两个步骤的完整的渲染阶段，看起来有点像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首选渲染深度贴图</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. 像之前一样渲染场景，但这次使用深度贴图</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, depthMap);</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>

<p>这段代码隐去了一些细节，但它表达了阴影映射的基本思路。这里一定要记得调用glViewport。因为阴影贴图经常和原来渲染的场景（通常是窗口分辨率）有着不同的分辨率，需要改变视口（viewport）的参数以适应阴影贴图的尺寸。如果我们忘了更新视口参数，最后的深度贴图要么太小要么就不完整。</p>
<h4 id="光源空间的变换"><a href="#光源空间的变换" class="headerlink" title="光源空间的变换"></a>光源空间的变换</h4><p>前面那段代码中一个不清楚的函数是<code>ConfigureShaderAndMatrices</code>。它是用来在第二个步骤确保为每个物体设置了合适的投影和视图矩阵，以及相关的模型矩阵。然而，第一个步骤中，我们从光的位置的视野下使用了不同的投影和视图矩阵来渲染的场景。</p>
<p>因为我们使用的是一个所有光线都平行的定向光。出于这个原因，我们将为光源使用正交投影矩阵，透视图将没有任何变形：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLfloat near_plane = <span class="number">1.0f</span>, far_plane = <span class="number">7.5f</span>;</span><br><span class="line">glm::mat4 lightProjection = glm::<span class="built_in">ortho</span>(<span class="number">-10.0f</span>, <span class="number">10.0f</span>, <span class="number">-10.0f</span>, <span class="number">10.0f</span>, near_plane, far_plane);</span><br></pre></td></tr></table></figure>

<p>这里有个本节教程的demo场景中使用的正交投影矩阵的例子。因为投影矩阵间接决定可视区域的范围，以及哪些东西不会被裁切，你需要保证投影视锥（frustum）的大小，以包含打算在深度贴图中包含的物体。当物体和片段不在深度贴图中时，它们就不会产生阴影。</p>
<p>为了创建一个视图矩阵来变换每个物体，把它们变换到从光源视角可见的空间中，我们将使用glm::lookAt函数；这次从光源的位置看向场景中央。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 lightView = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(<span class="number">-2.0f</span>, <span class="number">4.0f</span>, <span class="number">-1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>

<p>二者相结合为我们提供了一个光空间的变换矩阵，它将每个世界空间坐标变换到光源处所见到的那个空间；这正是我们渲染深度贴图所需要的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 lightSpaceMatrix = lightProjection * lightView;</span><br></pre></td></tr></table></figure>

<p>这个lightSpaceMatrix正是前面我们称为TT的那个变换矩阵。有了lightSpaceMatrix只要给shader提供光空间的投影和视图矩阵，我们就能像往常那样渲染场景了。然而，我们只关心深度值，并非所有片段计算都在我们的着色器中进行。为了提升性能，我们将使用一个与之不同但更为简单的着色器来渲染出深度贴图。</p>
<h4 id="渲染至深度贴图"><a href="#渲染至深度贴图" class="headerlink" title="渲染至深度贴图"></a>渲染至深度贴图</h4><p>当我们以光的透视图进行场景渲染的时候，会用一个比较简单的着色器，这个着色器把顶点变换到光空间。这个简单的着色器叫做<code>simpleDepthShader</code>，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line">uniform mat4 lightSpaceMatrix;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = lightSpaceMatrix * model * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个顶点着色器将一个单独模型的一个顶点，使用lightSpaceMatrix变换到光空间中。由于我们没有颜色缓冲，最后的片段不需要任何处理，所以我们可以简单地使用一个空的片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="comment">// gl_FragDepth = gl_FragCoord.z;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个空的片段着色器什么也不干，运行完后，深度缓冲会被更新。可以取消那行的注释，来显式设置深度，但是这个（指注释掉那行之后）是更有效率的，因为底层无论如何都会默认去设置深度缓冲。渲染深度缓冲现在成了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">simpleDepthShader.<span class="built_in">Use</span>();</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(lightSpaceMatrixLocation, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(lightSpaceMatrix));</span><br><span class="line"></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">RenderScene</span>(simpleDepthShader);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>RenderScene函数的参数是一个着色器程序（shader program），它调用所有相关的绘制函数，并在需要的地方设置相应的模型矩阵。最后，在光的透视图视角下，很完美地用每个可见片段的最近深度填充了深度缓冲。通过将这个纹理投射到一个2D四边形上，就能在屏幕上显示出来，运行结果如下：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241118124001483.png" class="" title="image-20241118124001483">将深度贴图渲染到四边形上的片段着色器：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 color;</span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D depthMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="type">float</span> depthValue = <span class="built_in">texture</span>(depthMap, TexCoords).r;</span><br><span class="line">    color = <span class="built_in">vec4</span>(<span class="built_in">vec3</span>(depthValue), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是当用透视投影矩阵取代正交投影矩阵来显示深度时，有一些轻微的改动，因为使用透视投影时，深度是非线性的。</p>
<p>你可以在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/ec9d678b2e57eb1b487568cadc2bd46d4b8b2be3/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/41_shadow_mapping_depth.rar">这里</a>获得把场景渲染成深度贴图的源码。</p>
<h2 id="渲染阴影"><a href="#渲染阴影" class="headerlink" title="渲染阴影"></a>渲染阴影</h2><p>当正确地生成深度贴图后，我们就可以开始渲染阴影了。下面这段代码在片段着色器中执行，用来检验一个片段是否在阴影之中，不过我们在顶点着色器中进行光空间的变换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 texCoords;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec4 FragPosLightSpace;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 lightSpaceMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">    vs_out.FragPos = <span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>));</span><br><span class="line">    vs_out.Normal = <span class="built_in">transpose</span>(<span class="built_in">inverse</span>(<span class="built_in">mat3</span>(model))) * normal;</span><br><span class="line">    vs_out.TexCoords = texCoords;</span><br><span class="line">    vs_out.FragPosLightSpace = lightSpaceMatrix * <span class="built_in">vec4</span>(vs_out.FragPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加了一个新的输出向量FragPosLightSpace，用同一个lightSpaceMatrix，把世界空间顶点位置转换为光空间。顶点着色器传递一个普通的经变换的世界空间顶点位置vs_out.FragPos和一个光空间的vs_out.FragPosLightSpace给片段着色器。</p>
<p>片段着色器使用Blinn-Phong光照模型渲染场景。接着计算出一个shadow值，当fragment在阴影中时是1.0，在阴影外是0.0。然后，diffuse和specular颜色会乘以这个阴影元素。由于阴影不会是全黑的，所以我们把ambient分量从乘法中剔除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec4 FragPosLightSpace;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseTexture;</span><br><span class="line">uniform sampler2D shadowMap;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(diffuseTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    vec3 lightColor = <span class="built_in">vec3</span>(<span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// Ambient</span></span><br><span class="line">    vec3 ambient = <span class="number">0.15</span> * color;</span><br><span class="line">    <span class="comment">// Diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    <span class="comment">// Specular</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">64.0</span>);</span><br><span class="line">    vec3 specular = spec * lightColor;    </span><br><span class="line">    <span class="comment">// 计算阴影</span></span><br><span class="line">    <span class="type">float</span> shadow = <span class="built_in">ShadowCalculation</span>(fs_in.FragPosLightSpace);       </span><br><span class="line">    vec3 lighting = (ambient + (<span class="number">1.0</span> - shadow) * (diffuse + specular)) * color;    </span><br><span class="line"></span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(lighting, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器大部分是从高级光照教程中复制过来，只不过加上了个阴影计算。我们声明一个shadowCalculation函数，用它计算阴影。片段着色器的最后，我们把diffuse和specular乘以(1-阴影元素)，这表示这个片段有多大成分不在阴影中。这个片段着色器还需要两个额外输入，一个是光空间的片段位置和第一个渲染阶段得到的深度贴图。</p>
<p>首先要检查一个片段是否在阴影中，把光空间片段位置转换为裁切空间的标准化设备坐标。当我们在顶点着色器输出一个裁切空间顶点位置到gl_Position时，OpenGL自动进行一个透视除法，将裁切空间坐标的范围-w到w转为-1到1，这将x、y、z元素除以向量的w元素来实现。由于裁切空间的FragPosLightSpace并不会通过gl_Position传到片段着色器里，我们必须自己做透视除法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行透视除法</span></span><br><span class="line">    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数返回了片段在光空间的-1到1的范围。</p>
<p>当使用正交投影矩阵，顶点w元素仍保持不变，所以这一步实际上毫无意义。可是，当使用透视投影的时候就是必须的了，所以为了保证在两种投影矩阵下都有效就得留着这行代码。</p>
<p>因为来自深度贴图的深度在0到1的范围，我们也打算使用projCoords从深度贴图中去采样，所以将NDC坐标变换为0到1的范围。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<p>有了投影坐标，就能从深度贴图中采样得到0到1的结果，从第一个渲染阶段的projCoords坐标直接对应于变换过的NDC坐标。我们将得到光的位置视野下最近的深度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> closestDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy).r;</span><br></pre></td></tr></table></figure>

<p>为了得到片段的当前深度，获取投影向量的z坐标，它等于来自光的透视视角的片段的深度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> currentDepth = projCoords.z;</span><br></pre></td></tr></table></figure>

<p>实际的对比就是简单检查currentDepth是否高于closetDepth，如果是，那么片段就在阴影中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>完整的shadowCalculation函数是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行透视除法</span></span><br><span class="line">    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    <span class="comment">// 变换到[0,1]的范围</span></span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)</span></span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy).r; </span><br><span class="line">    <span class="comment">// 取得当前片段在光源视角下的深度</span></span><br><span class="line">    <span class="type">float</span> currentDepth = projCoords.z;</span><br><span class="line">    <span class="comment">// 检查当前片段是否在阴影中</span></span><br><span class="line">    <span class="type">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>激活这个着色器，绑定合适的纹理，激活第二个渲染阶段默认的投影以及视图矩阵，结果如下图所示：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241129162924357.png" class="" title="image-20241129162924357">

<p>如上图所示，你会看到地板和上有立方体的阴影。可以从<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/ec9d678b2e57eb1b487568cadc2bd46d4b8b2be3/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/42_render_shadow.rar">这里</a>找到demo程序的代码。</p>
<h2 id="改进阴影贴图"><a href="#改进阴影贴图" class="headerlink" title="改进阴影贴图"></a>改进阴影贴图</h2><p>我们现在成功让阴影贴图工作了，但是阴影贴图还是不够真实，接下来我们要尝试修复它。</p>
<h3 id="阴影失真"><a href="#阴影失真" class="headerlink" title="阴影失真"></a>阴影失真</h3><p>目前我们绘制的场景明显有不对的地方，放大看会发现明显的线条样式：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203153007456.png" class="" title="image-20241203153007456">

<p>我们可以看到地板四边形渲染出很大一块交替黑线。这种阴影贴图的不真实感叫做<strong>阴影失真</strong>(Shadow Acne)，下图解释了成因：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_acne_diagram.png" class="" title="img">

<p>因为阴影贴图受限于分辨率，在距离光源比较远的情况下，多个片段可能从深度贴图的同一个值中去采样。图片每个斜坡代表深度贴图一个单独的纹理像素。你可以看到，多个片段从同一个深度值进行采样。虽然很多时候没问题，但是当光源以一个角度朝向表面的时候就会出问题，这种情况下深度贴图也是从一个角度下进行渲染的。多个片段就会从同一个斜坡的深度纹理像素中采样，有些在地板上面，有些在地板下面；这样我们所得到的阴影就有了差异。因为这个，有些片段被认为是在阴影之中，有些不在，由此产生了图片中的条纹样式。</p>
<p>我们可以用一个叫做<strong>阴影偏移</strong>（shadow bias）的技巧来解决这个问题，我们简单的对表面的深度（或深度贴图）应用一个偏移量，这样片段就不会被错误地认为在表面之下了。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_acne_bias.png" class="" title="img">

<p>使用了偏移量后，所有采样点都获得了比表面深度更小的深度值，这样整个表面就正确地被照亮，没有任何阴影。在阴影贴图的片段着色器中可以使用下面的代码实现偏移：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="number">0.005</span>;</span><br><span class="line"><span class="type">float</span> shadow = currentDepth - bias &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>一个0.005的偏移就能有效解决这个问题，但是有些表面坡度很大，仍然会产生阴影失真。有一个更加可靠的办法能够根据表面朝向光线的角度更改偏移量，即使用点乘：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="built_in">max</span>(<span class="number">0.05</span> * (<span class="number">1.0</span> - <span class="built_in">dot</span>(normal, lightDir)), <span class="number">0.005</span>);</span><br><span class="line"><span class="type">float</span> shadow = currentDepth - bias &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>这里我们有一个偏移量的最大值0.05，和一个最小值0.005，它们是基于表面法线和光照方向的。这样像地板这样的表面几乎与光源垂直，得到的偏移就很小，而比如立方体的侧面这种表面得到的偏移就更大。下图展示了同一个场景，但使用了阴影偏移，效果的确更好：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203154054133.png" class="" title="image-20241203154054133">

<p>使用正确的偏移数值，在不同的场景中需要一些像这样的轻微调校，但大多情况下，实际上就是增加偏移量直到所有失真都被消除。</p>
<h3 id="悬浮"><a href="#悬浮" class="headerlink" title="悬浮"></a>悬浮</h3><p>使用阴影偏移的一个缺点是你对物体的实际深度应用了平移。偏移有可能足够大，以至于可以看出阴影相对实际物体位置的偏移，你可以从下图看到这个现象（这是一个夸张的偏移值）：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203154400331.png" class="" title="image-20241203154400331">

<p>这个阴影失真叫做悬浮(Peter Panning)，因为物体看起来悬浮在表面之上。我们可以使用一个叫技巧解决大部分的悬浮问题：当渲染深度贴图时候使用正面剔除，你也许记得在面剔除教程中OpenGL默认是背面剔除。但是现在我们要告诉OpenGL我们要剔除正面。</p>
<p>因为我们只需要深度贴图的深度值，对于实体物体无论我们用它们的正面还是背面都没问题。使用背面深度不会有错误，因为阴影在物体内部有错误我们也看不见。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_culling.png" class="" title="img">

<p>为了修复悬浮，我们要进行正面剔除，先必须开启GL_CULL_FACE：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glCullFace</span>(GL_FRONT);</span><br><span class="line"><span class="built_in">RenderSceneToDepthMap</span>();</span><br><span class="line"><span class="built_in">glCullFace</span>(GL_BACK); <span class="comment">// 不要忘记设回原先的culling face</span></span><br></pre></td></tr></table></figure>

<p>这十分有效地解决了悬浮的问题，但只对封闭的实体物体有效。在现在的场景中，在立方体上工作的很好，但在地板上无效，因为正面剔除完全移除了地板。地面是一个单独的平面，不会被完全剔除。如果打算使用这个技巧解决悬浮必须考虑到，只有剔除物体的正面才有意义。另一个要考虑到的地方是接近阴影的物体仍然会出现不正确的效果。必须考虑到何时使用正面剔除对物体才有意义。不过使用普通的偏移值通常就能避免悬浮。</p>
<h3 id="采样过多"><a href="#采样过多" class="headerlink" title="采样过多"></a>采样过多</h3><p>还有一个视觉差异，就是光的视锥不可见的区域一律被认为是处于阴影中，不管它是否真的处于阴影之中。出现这个状况是因为超出光的视锥的投影坐标比1.0大，这样采样的深度纹理就会超出他默认的0到1的范围。根据纹理环绕方式，我们将会得到不正确的深度结果，它不是基于真实的来自光源的深度值。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203164257058.png" class="" title="image-20241203164257058">

<p>可以在图中看到，光照有一个区域，超出该区域的就成为了阴影；这个区域实际上代表着深度贴图的大小，这个贴图投影到了地板上。发生这种情况的原因是，之前将深度贴图的环绕方式设置成了GL_REPEAT。我们宁可让所有超出深度贴图的坐标的深度范围是1.0，这样超出的坐标将永远不在阴影之中。我们可以储存一个边框颜色，然后把深度贴图的纹理环绕选项设置为GL_CLAMP_TO_BORDER：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">GLfloat borderColor[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line"><span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure>

<p>现在如果我们采样深度贴图0到1坐标范围以外的区域，纹理函数总会返回一个1.0的深度值，阴影值为0.0。现在仍有一部分是黑暗区域，那里的坐标超出了光的正交视锥的远平面。可以看到这片黑色区域总是出现在光源视锥的极远处。当一个点比光的远平面还要远时，它的投影坐标的z坐标大于1.0。这种情况下，GL_CLAMP_TO_BORDER环绕方式不起作用，因为把坐标的z元素和深度贴图的值进行了对比，它总是为大于1.0的z返回true。</p>
<p>解决这个问题也很简单，只要投影向量的z坐标大于1.0，我们就把shadow的值强制设为0.0，修改阴影贴图的片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="keyword">if</span>(projCoords.z &gt; <span class="number">1.0</span>)</span><br><span class="line">        shadow = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查远平面，并将深度贴图限制为一个手工指定的边界颜色，就能解决深度贴图采样超出的问题，最终会得到下图所示的效果：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203165556309.png" class="" title="image-20241203165556309">

<p>这些结果意味着，只有在深度贴图范围以内的被投影的fragment坐标才有阴影，所以任何超出范围的都将会没有阴影。由于在游戏中通常这只发生在远处，所以会比之前的那个明显的黑色区域效果更真实。</p>
<h2 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h2><p>阴影现在已经被绘制到场景中了，不过这仍不是我们想要的。如果你放大看阴影，阴影贴图对分辨率的依赖很快变得很明显。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203165704357.png" class="" title="image-20241203165704357">

<p>因为深度贴图有一个固定的分辨率，多个片段对应于一个纹理像素。结果就是多个片段会从深度贴图的同一个深度值进行采样，这几个片段便得到的是同一个阴影，这就会导致产生锯齿。可以通过增加深度贴图的分辨率的方式来降低锯齿块，也可以尝试尽可能的让光的视锥接近场景。</p>
<p>另一个解决方案叫做PCF（percentage-closer filtering），这是一种多个不同过滤方式的组合，它产生柔和阴影，使它们出现更少的锯齿块和硬边。核心思想是从深度贴图中多次采样，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，就得到了柔和阴影。</p>
<p>一个简单的PCF的实现是简单的从纹理像素四周对深度贴图采样，然后把结果平均起来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line">vec2 texelSize = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(shadowMap, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-1</span>; x &lt;= <span class="number">1</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-1</span>; y &lt;= <span class="number">1</span>; ++y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> pcfDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy + <span class="built_in">vec2</span>(x, y) * texelSize).r; </span><br><span class="line">        shadow += currentDepth - bias &gt; pcfDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">shadow /= <span class="number">9.0</span>;</span><br></pre></td></tr></table></figure>

<p>textureSize返回vec2类型的采样器纹理的0级mipmap的宽和高。用1除以它返回一个单独纹理像素的大小，我们用以对纹理坐标进行偏移，确保每个新样本，来自不同的深度值。这里采样得到9个值，它们在投影坐标的x和y值的周围，为阴影阻挡进行测试，并最终通过样本的总数目将结果平均化。使用更多的样本，更改texelSize变量，你就可以增加阴影的柔和程度。下面你可以看到应用了PCF的阴影：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203171805737.png" class="" title="image-20241203171805737">

<p>从稍微远一点的距离看去，阴影效果好多了，也不那么生硬了。如果你放大，仍会看到阴影贴图分辨率的不真实感，但通常对于大多数应用来说效果已经很好了。实际上PCF还有更多的内容，以及很多技术要点需要考虑以提升柔和阴影的效果，我们将留在以后讨论。</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/ec9d678b2e57eb1b487568cadc2bd46d4b8b2be3/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/43_render_shadow_fix.rar">这里</a>可以获取修复了上述错误的完整代码。</p>
<h2 id="正交-vs-投影"><a href="#正交-vs-投影" class="headerlink" title="正交 vs 投影"></a>正交 vs 投影</h2><p>在渲染深度贴图的时候，正交(Orthographic)和投影(Projection)矩阵之间有所不同。正交投影矩阵并不会将场景用透视图进行变形，所有视线/光线都是平行的，这使它对于定向光来说是个很好的投影矩阵。然而透视投影矩阵，会将所有顶点根据透视关系进行变形，结果因此而不同。下图展示了两种投影方式所产生的不同阴影区域：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_projection.png" class="" title="img">

<p>透视投影对于光源来说更合理，不像定向光，它是有自己的位置的。透视投影因此更经常用在点光源和聚光灯上，而正交投影经常用在定向光上。</p>
<p>另一个细微差别是，透视投影矩阵，将深度缓冲视觉化经常会得到一个几乎全白的结果。发生这个是因为透视投影下，深度变成了非线性的深度值，它的大多数可辨范围都位于近平面附近。为了可以像使用正交投影一样合适地观察深度值，你必须先将非线性深度值转变为线性的，如我们在深度测试教程中已经讨论过的那样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 color;</span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D depthMap;</span><br><span class="line">uniform <span class="type">float</span> near_plane;</span><br><span class="line">uniform <span class="type">float</span> far_plane;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">LinearizeDepth</span><span class="params">(<span class="type">float</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> z = depth * <span class="number">2.0</span> - <span class="number">1.0</span>; <span class="comment">// Back to NDC </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2.0</span> * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="type">float</span> depthValue = <span class="built_in">texture</span>(depthMap, TexCoords).r;</span><br><span class="line">    color = <span class="built_in">vec4</span>(<span class="built_in">vec3</span>(<span class="built_in">LinearizeDepth</span>(depthValue) / far_plane), <span class="number">1.0</span>); <span class="comment">// perspective</span></span><br><span class="line">    <span class="comment">// color = vec4(vec3(depthValue), 1.0); // orthographic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个深度值与我们见到的用正交投影的很相似。需要注意的是，这个只适用于调试；正交或投影矩阵的深度检查仍然保持原样，因为相关的深度并没有改变。</p>
<h2 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a>附加资源</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">Tutorial 16 : Shadow mapping</a>：提供类似的阴影贴图教程，里面有一些额外的解释。</li>
<li><a target="_blank" rel="noopener" href="http://ogldev.atspace.co.uk/www/tutorial23/tutorial23.html">Shadow Mapping – Part 1：ogldev</a>：提供的另一个阴影贴图教程。</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=EsccgeUpdsM">How Shadow Mapping Works</a>：一个第三方YouTube视频教程，里面解释了阴影贴图及其实现。</li>
<li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324(v=vs.85).aspx">Common Techniques to Improve Shadow Depth Maps</a>：微软的一篇文章，其中列出了很多提升阴影贴图质量的技术。</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>OSkirito
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/" title="31-阴影贴图">http://example.com/2024/10/14/31-阴影贴图/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag"># 图形学</a>
              <a href="/tags/Shader/" rel="tag"># Shader</a>
              <a href="/tags/OpenGL/" rel="tag"># OpenGL</a>
              <a href="/tags/GLSL/" rel="tag"># GLSL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/" rel="prev" title="30-Gammma校正">
      <i class="fa fa-chevron-left"></i> 30-Gammma校正
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE"><span class="nav-number">1.</span> <span class="nav-text">阴影贴图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E8%B4%B4%E5%9B%BE"><span class="nav-number">1.1.</span> <span class="nav-text">深度贴图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%89%E6%BA%90%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="nav-number">1.1.1.</span> <span class="nav-text">光源空间的变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E8%87%B3%E6%B7%B1%E5%BA%A6%E8%B4%B4%E5%9B%BE"><span class="nav-number">1.1.2.</span> <span class="nav-text">渲染至深度贴图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E9%98%B4%E5%BD%B1"><span class="nav-number">2.</span> <span class="nav-text">渲染阴影</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE"><span class="nav-number">3.</span> <span class="nav-text">改进阴影贴图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B4%E5%BD%B1%E5%A4%B1%E7%9C%9F"><span class="nav-number">3.1.</span> <span class="nav-text">阴影失真</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%AC%E6%B5%AE"><span class="nav-number">3.2.</span> <span class="nav-text">悬浮</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%87%E6%A0%B7%E8%BF%87%E5%A4%9A"><span class="nav-number">3.3.</span> <span class="nav-text">采样过多</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PCF"><span class="nav-number">4.</span> <span class="nav-text">PCF</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E4%BA%A4-vs-%E6%8A%95%E5%BD%B1"><span class="nav-number">5.</span> <span class="nav-text">正交 vs 投影</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E8%B5%84%E6%BA%90"><span class="nav-number">6.</span> <span class="nav-text">附加资源</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OSkirito"
      src="/images/head_image.png">
  <p class="site-author-name" itemprop="name">OSkirito</p>
  <div class="site-description" itemprop="description">CG技术的记录与分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oskirito" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oskirito" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OSkirito</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
