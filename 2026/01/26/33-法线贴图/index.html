<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="目前的场景中已经充满了各种物体，其中每个都可能由成百上千平整的三角形组成。我们以向三角形上附加纹理的方式来增加额外细节，提升真实感，隐藏这些物体是由无数三角形组成的事实。纹理确有助益，但是当你靠近仔细观察它们时，就会发现问题。现实中的物体表面并非是平整的，而是表现出无数起伏的（凹凸不平的）细节。 例如，木砖的表面，木砖的表面会有一些粗糙，显然不是完全平整的：它包含着接缝处的凹痕，以及非常多的细小的">
<meta property="og:type" content="article">
<meta property="og:title" content="33-法线贴图">
<meta property="og:url" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/index.html">
<meta property="og:site_name" content="OS&#39;s Blog">
<meta property="og:description" content="目前的场景中已经充满了各种物体，其中每个都可能由成百上千平整的三角形组成。我们以向三角形上附加纹理的方式来增加额外细节，提升真实感，隐藏这些物体是由无数三角形组成的事实。纹理确有助益，但是当你靠近仔细观察它们时，就会发现问题。现实中的物体表面并非是平整的，而是表现出无数起伏的（凹凸不平的）细节。 例如，木砖的表面，木砖的表面会有一些粗糙，显然不是完全平整的：它包含着接缝处的凹痕，以及非常多的细小的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127105324895.png">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_surfaces.png">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/wool_fabric_normal.jpg">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_ground_normals.png">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_tbn_vectors.png">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_surface_edges.png">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174432809.png">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174452326.png">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174528702.png">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174552719.png">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174616582.png">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260209164528383.png">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_complex_compare.png">
<meta property="og:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_comparison.png">
<meta property="article:published_time" content="2026-01-26T07:32:53.000Z">
<meta property="article:modified_time" content="2026-02-09T10:17:31.640Z">
<meta property="article:author" content="OSkirito">
<meta property="article:tag" content="图形学">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="OpenGL">
<meta property="article:tag" content="GLSL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127105324895.png">

<link rel="canonical" href="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>33-法线贴图 | OS's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OS's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">29</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">56</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          33-法线贴图
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-01-26 15:32:53" itemprop="dateCreated datePublished" datetime="2026-01-26T15:32:53+08:00">2026-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-02-09 18:17:31" itemprop="dateModified" datetime="2026-02-09T18:17:31+08:00">2026-02-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>目前的场景中已经充满了各种物体，其中每个都可能由成百上千平整的三角形组成。我们以向三角形上附加纹理的方式来增加额外细节，提升真实感，隐藏这些物体是由无数三角形组成的事实。纹理确有助益，但是当你靠近仔细观察它们时，就会发现问题。现实中的物体表面并非是平整的，而是表现出无数起伏的（凹凸不平的）细节。</p>
<p>例如，木砖的表面，木砖的表面会有一些粗糙，显然不是完全平整的：它包含着接缝处的凹痕，以及非常多的细小的木纹。如果我们在一个有光照的场景中看这样一个木地板的表面，问题就出来了。就像下图所示现在的场景：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127105324895.png" class="" title="image-20260127105324895">

<p>光照并没有呈现出任何接缝和细节，完全忽略了砖块之间凹进去的线条；表面看起来完全就是平的。我们可以使用specular贴图根据深度或其他细节阻止部分表面被照的更亮，以此部分地解决问题，但这并不是一个好方案。我们需要的是某种可以告知光照系统给所有有关物体表面类似深度这样的细节的方式。</p>
<p>如果我们以光的视角来看这个问题：为什么表面被照亮为完全平整？答案是表面的法线向量。以光照算法的视角考虑的话，只有垂直于它的法线向量可以决定物体的形状。砖块表面只有一个法线向量，表面完全根据这个法线向量被以一致的方式照亮。如果每个fragment都是用自己的不同的法线，我们就可以根据表面细微的细节对法线向量进行改变；这样就会获得一种表面看起来要复杂得多的错觉：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_surfaces.png" class="" title="img">

<p>每个fragment使用了自己的法线，我们就可以让光照将表面照亮为很多微笑（垂直于法线向量的）平面，物体表面的细节将会得到极大提升。这种每个fragment使用各自的法线，替代一个面上所有fragment使用同一个法线的技术叫做法线贴图（normal mapping）或凹凸贴图（bump mapping）。通过这种方式使细节获得了极大提升，开销却不大。因为只需要改变每个fragment的法线向量，并不需要改变所有光照公式。现在我们是为每个fragment传递一个法线，不再使用插值表面法线。这样光照就使表面拥有了自己的细节。</p>
<h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><p>为使法线贴图能够正常工作，我们需要为每个fragment提供一个法线。像diffuse贴图和specular贴图一样，我们可以使用一个2D纹理来储存法线数据。2D纹理不仅可以储存颜色和光照数据，还可以储存法向量。这样我们可以从2D纹理中采样得到特定纹理的法线向量。</p>
<p>由于法向量是个几何工具，而纹理通常只用于储存颜色信息，用纹理储存法向量并不直观。类似于纹理中的颜色向量用r、g、b元素代表一个3D向量，我们也可以将法线向量的x、y、z元素储存到纹理中，用来代替颜色的r、g、b元素。法向量的范围在-1到1之间，所以我们先要将其范围进行映射：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从法线贴图范围[0,1]获取法线</span></span><br><span class="line">normal = <span class="built_in">texture</span>(normalTexture, fs_in.TexCoords).rgb;</span><br><span class="line"><span class="comment">// 将法线向量转换为范围[-1,1]</span></span><br><span class="line">normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>将法向量变换为像这样的RGB颜色，我们就能把根据表面的形状的fragment的法线保存在2D纹理中。下图是一个法线贴图：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/wool_fabric_normal.jpg" class="" title="wool_fabric_normal">

<p>法线贴图看起来会是一种偏蓝色调的纹理（在网上找到的所有法线贴图几乎都是这样的）。这是因为所有法线的指向都偏向z轴（0, 0, 1）这是一种偏蓝的颜色。法线向量从z轴方向也向其他方向轻微偏移，颜色也就发生了轻微变化，这样看起来便有了一种深度。例如，你可以看到在每个凸起的顶部，颜色倾向于偏绿，这是因为此处的顶部的法线偏向于指向正y轴方向（0, 1, 0），这样它就是绿色的了。</p>
<p>在一个简单的朝向正z轴的平面上，我们可以用<a target="_blank" rel="noopener" href="https://learnopengl.com/img/textures/brickwall.jpg">这个diffuse纹理</a>和<a target="_blank" rel="noopener" href="https://learnopengl.com/img/textures/brickwall_normal.jpg">这个法线贴图</a>来渲染前面部分的图片。要注意的是这个链接里的法线贴图和上面展示的那个不一样。原因是OpenGL读取的纹理的y（或V）坐标和纹理通常被创建的方式相反。链接里的法线贴图的y（或绿色）元素是相反的（你可以看到绿色现在在下边）；如果你没考虑这个，光照就不正确了（如果你现在不再使用SOIL了，那就不要用链接里的那个法线贴图，这个问题是SOIL载入纹理上下颠倒所致，它也会把法线在y方向上颠倒）。加载纹理，把它们绑定到合适的纹理单元，然后使用下面的改变了的片段着色器来渲染一个平面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D normalMap;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    <span class="comment">// 从法线贴图范围[0,1]获取法线</span></span><br><span class="line">    normal = <span class="built_in">texture</span>(normalMap, fs_in.TexCoords).rgb;</span><br><span class="line">    <span class="comment">// 将法线向量转换为范围[-1,1]</span></span><br><span class="line">    normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);   </span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// 像往常那样处理光照</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们将被采样的法线颜色从0到1重新映射回-1到1，便能将RGB颜色重新处理成法线，然后使用采样出的法向量应用于光照的计算。</p>
<p>然而有个问题限制了刚才讲的那种法线贴图的使用。我们使用的法线贴图中所有法线向量都是指向正z方向的。如果物体的表面法线也是指向正z方向的，那这看起来就没有问题。但是如果物体的表面法线现在指向了y，而采样得到的法线仍然指向的是z。结果就是光照仍然认为表面法线和之前朝向正z方向时一样；这样光照就不对了。下面的图片展示了这个表面上采样的法线的近似情况：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_ground_normals.png" class="" title="img">

<p>可以看到所有法线都指向z方向，它们本该朝着表面法线指向y方向的。一个可行方案是为每个表面制作一个单独的法线贴图。如果是一个立方体的话我们就需要6个法线贴图，但是如果模型上有无数的朝向不同方向的表面，这就不可行了；另一个解决方案是，在一个不同的坐标空间中进行光照，这个坐标空间里，法线贴图向量总是指向这个坐标空间的正z方向。所有的光照向量都相对与这个正z方向进行变换。这样我们就能始终使用同样的法线贴图，不管朝向问题。这个坐标空间叫做切线空间（tangent space）。</p>
<h2 id="切线空间"><a href="#切线空间" class="headerlink" title="切线空间"></a>切线空间</h2><p>在切线空间中，法线永远指着正z方向。切线空间是位于三角形表面之上的空间：法线相对于单个三角形的局部坐标系。它就像法线贴图向量的局部空间；它们都被定义为指向正z方向，无论最终变换到什么方向。使用一个特定的矩阵我们就能将本地/切线空间中的法线向量转成世界或视图空间下，使它们变换到最终的贴图表面的方向。</p>
<p>我们可以说，前面那个朝向正y的法线贴图错误的贴到了表面上。法线贴图被定义在切线空间中，所以这种解决方式是计算出一种矩阵，把法线从切线空间变换到一个不同的空间，这样它们就能和表面法线方向对齐了：法线向量都会指向正y方向。切线空间的一大好处是我们可以为任何类型的表面计算出一个这样的矩阵，由此我们可以把切线空间的z方向和表面的法线方向对齐。</p>
<p>这种矩阵叫做TBN矩阵这三个字母分别代表tangent、bitangent和normal向量。这是建构这个矩阵所需的向量。要建构这样一个把切线空间转变为不同空间的变异矩阵，我们需要三个相互垂直的向量，它们沿一个表面的法线贴图对齐于：上、右、前；这和之前在摄像机教程中做的类似。</p>
<p>已知上向量是表面的法线向量。右和前向量是切线(Tagent)和副切线(Bitangent)向量。下面的图片展示了一个表面的三个向量：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_tbn_vectors.png" class="" title="img">

<p>计算出切线和副切线并不像法线向量那么容易。从图中可以看到法线贴图的切线和副切线与纹理坐标的两个方向对齐。我们就是用到这个特性计算每个表面的切线和副切线的。需要用到一些数学才能得到它们；请看下图：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_surface_edges.png" class="" title="img">

<p>注意上图中边E2与纹理坐标的差ΔU2、ΔV2构成一个三角形。ΔU2与切线向量T方向相同，而ΔV2与副切线向量B方向相同。这也就是说，所以我们可以将三角形的边E1与E2写成切线向量\T和副切线向量B的线性组合：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174432809.png" class="" title="image-20260127174432809">

<p>也可以写成这样：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174452326.png" class="" title="image-20260127174452326">

<p>E是两个向量位置的差，ΔU和ΔV是纹理坐标的差。然后我们得到两个未知数（切线T和副切线B）和两个等式。</p>
<p>上面的方程允许我们把它们写成另一种格式：矩阵乘法</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174528702.png" class="" title="image-20260127174528702">

<p>尝试会意一下矩阵乘法，它们确实是同一种等式。把等式写成矩阵形式的好处是，解T和B会因此变得很容易。两边都乘以ΔUΔV的逆矩阵等于：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174552719.png" class="" title="image-20260127174552719">

<p>这样我们就可以解出T和B了。这需要我们计算出delta纹理坐标矩阵的逆矩阵。我不打算讲解计算逆矩阵的细节，但大致是把它变化为，1除以矩阵的行列式，再乘以它的伴随矩阵。</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174616582.png" class="" title="image-20260127174616582">

<p>有了最后这个等式，我们就可以用公式、三角形的两条边以及纹理坐标计算出切线向量T和副切线B。</p>
<p>如果你对这些数学内容不理解也不用担心。当你知道我们可以用一个三角形的顶点和纹理坐标（因为纹理坐标和切线向量在同一空间中）计算出切线和副切线你就已经部分地达到目的了。</p>
<h3 id="使用代码计算切线和副切线"><a href="#使用代码计算切线和副切线" class="headerlink" title="使用代码计算切线和副切线"></a>使用代码计算切线和副切线</h3><p>假设平面使用下面的向量建立起来（1、2、3和1、3、4，它们是两个三角形）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// positions</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">pos1</span><span class="params">(<span class="number">-1.0</span>,  <span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">pos2</span><span class="params">(<span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">pos3</span><span class="params">(<span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">pos4</span><span class="params">(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="comment">// texture coordinates</span></span><br><span class="line"><span class="function">glm::vec2 <span class="title">uv1</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec2 <span class="title">uv2</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec2 <span class="title">uv3</span><span class="params">(<span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec2 <span class="title">uv4</span><span class="params">(<span class="number">1.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="comment">// normal vector</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">nm</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们先计算第一个三角形的边和deltaUV坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 edge1 = pos2 - pos1;</span><br><span class="line">glm::vec3 edge2 = pos3 - pos1;</span><br><span class="line">glm::vec2 deltaUV1 = uv2 - uv1;</span><br><span class="line">glm::vec2 deltaUV2 = uv3 - uv1;</span><br></pre></td></tr></table></figure>

<p>有了计算切线和副切线的必备数据，我们就可以开始写出来自于前面部分中的下列等式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GLfloat f = <span class="number">1.0f</span> / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);</span><br><span class="line"></span><br><span class="line">tangent1.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);</span><br><span class="line">tangent1.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);</span><br><span class="line">tangent1.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);</span><br><span class="line">tangent1 = glm::<span class="built_in">normalize</span>(tangent1);</span><br><span class="line"></span><br><span class="line">bitangent1.x = f * (-deltaUV2.x * edge1.x + deltaUV1.x * edge2.x);</span><br><span class="line">bitangent1.y = f * (-deltaUV2.x * edge1.y + deltaUV1.x * edge2.y);</span><br><span class="line">bitangent1.z = f * (-deltaUV2.x * edge1.z + deltaUV1.x * edge2.z);</span><br><span class="line">bitangent1 = glm::<span class="built_in">normalize</span>(bitangent1);  </span><br><span class="line"></span><br><span class="line">[...] <span class="comment">// 对平面的第二个三角形采用类似步骤计算切线和副切线</span></span><br></pre></td></tr></table></figure>

<p>我们预先计算出等式的分数部分<code>f</code>，然后把它和每个向量的元素进行相应矩阵乘法。如果你把代码和最终的等式对比你会发现，这就是直接套用。最后我们还要进行标准化，来确保切线/副切线向量最后是单位向量。</p>
<p>因为一个三角形永远是平整的形状，我们只需为每个三角形计算一个切线/副切线，它们对于每个三角形上的顶点都是一样的。要注意的是大多数实现通常三角形和三角形之间都会共享顶点。这种情况下开发者通常将每个顶点的法线和切线/副切线等顶点属性平均化，以获得更加柔和的效果。我们的平面的三角形之间分享了一些顶点，但是因为两个三角形相互并行，因此并不需要将结果平均化。</p>
<p>最后的切线和副切线向量的值应该是(1, 0, 0)和(0, 1, 0)，它们和法线(0, 0, 1)组成相互垂直的TBN矩阵。</p>
<p>每个顶点定义了切线和副切线向量，我们就可以开始实现正确的法线贴图了。</p>
<h3 id="切线空间法线贴图"><a href="#切线空间法线贴图" class="headerlink" title="切线空间法线贴图"></a>切线空间法线贴图</h3><p>为让法线贴图工作，我们先得在着色器中创建一个TBN矩阵。我们先将前面计算出来的切线和副切线向量传给顶点着色器，作为它的属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aNormal;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 aTexCoords;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">3</span>) in vec3 aTangent;</span><br></pre></td></tr></table></figure>

<p>在顶点着色器的main函数中我们创建TBN矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 T = <span class="built_in">normalize</span>(normalMatrix * aTangent);</span><br><span class="line">    vec3 N = <span class="built_in">normalize</span>(normalMatrix * aNormal);</span><br><span class="line"></span><br><span class="line">    T = <span class="built_in">normalize</span>(T - <span class="built_in">dot</span>(T, N) * N);</span><br><span class="line">    vec3 B = <span class="built_in">cross</span>(N, T);</span><br><span class="line">    </span><br><span class="line">    mat3 TBN = <span class="built_in">transpose</span>(<span class="built_in">mat3</span>(T, B, N));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先将所有TBN向量变换到我们所操作的坐标系中，现在是世界空间，可以乘以model矩阵。然后我们创建实际的TBN矩阵，直接把相应的向量应用到mat3构造器就行。注意，如果我们希望更精确的话就不要将TBN向量乘以model矩阵，而是使用法线矩阵，因为我们只关心向量的方向，不关心平移和缩放。</p>
<p>现在我们有了TBN矩阵，如何来使用它呢？通常来说有两种方式使用它，我们会把这两种方式都说明一下：</p>
<ol>
<li>我们直接使用TBN矩阵，这个矩阵可以把切线坐标空间的向量转换到世界坐标空间。因此我们把它传给片段着色器中，把通过采样得到的法线坐标左乘上TBN矩阵，转换到世界坐标空间中，这样所有法线和其他光照变量就在同一个坐标系中了。</li>
<li>我们也可以使用TBN矩阵的逆矩阵，这个矩阵可以把世界坐标空间的向量转换到切线坐标空间。因此我们使用这个矩阵左乘其他光照变量，把他们转换到切线空间，这样法线和其他光照变量再一次在一个坐标系中了。</li>
</ol>
<p><strong>我们来看看第一种情况。</strong>我们从法线贴图采样得来的法线向量，是在切线空间表示的，尽管其他光照向量都是在世界空间表示的。把TBN传给像素着色器，我们就能将采样得来的切线空间的法线乘以这个TBN矩阵，将法线向量变换到和其他光照向量一样的参考空间中。这种方式随后所有光照计算都可以简单的理解。</p>
<p>把TBN矩阵发给片段着色器很简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    mat3 TBN;</span><br><span class="line">&#125; vs_out;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    vs_out.TBN = <span class="built_in">mat3</span>(T, B, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在片段着色器中我们用mat3作为输入变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    mat3 TBN;</span><br><span class="line">&#125; fs_in;</span><br></pre></td></tr></table></figure>

<p>有了TBN矩阵我们现在就可以更新法线贴图代码，引入切线到世界空间变换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">normal = <span class="built_in">texture</span>(normalMap, fs_in.TexCoords).rgb;</span><br><span class="line">normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);   </span><br><span class="line">normal = <span class="built_in">normalize</span>(fs_in.TBN * normal);</span><br></pre></td></tr></table></figure>

<p>因为最后的normal现在在世界空间中了，就不用改变其他像素着色器的代码了，因为光照代码就是假设法线向量在世界空间中。</p>
<p><strong>我们同样看看第二种情况。</strong>我们用TBN矩阵的逆矩阵将所有相关的世界空间向量转变到采样所得法线向量的空间：切线空间。TBN的建构还是一样，但我们在将其发送给片段着色器之前先要求逆矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs_out.TBN = <span class="built_in">transpose</span>(<span class="built_in">mat3</span>(T, B, N));</span><br></pre></td></tr></table></figure>

<p>注意，这里我们使用transpose函数，而不是inverse函数。正交矩阵（每个轴既是单位向量同时相互垂直）的一大属性是一个正交矩阵的置换矩阵与它的逆矩阵相等。这个属性很重要因为逆矩阵的求得比求置换开销大；结果却是一样的。</p>
<p>在片段着色器中我们不用对法线向量变换，但我们要把其他相关向量转换到切线空间，它们是lightDir和viewDir。这样每个向量还是在同一个空间（切线空间）中了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 normal = <span class="built_in">texture</span>(normalMap, fs_in.TexCoords).rgb;</span><br><span class="line">    normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);   </span><br><span class="line"></span><br><span class="line">    vec3 lightDir = fs_in.TBN * <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    vec3 viewDir  = fs_in.TBN * <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);    </span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法看似要做的更多，它还需要在片段着色器中进行更多的乘法操作，所以为何还用第二种方法呢？</p>
<p>将向量从世界空间转换到切线空间有个额外好处，我们可以把所有相关向量在顶点着色器中转换到切线空间，不用在片段着色器中做这件事。这是可行的，因为lightPos和viewPos不是每个fragment运行都要改变，对于fs_in.FragPos，我们也可以在顶点着色器计算它的切线空间位置。基本上，不需要把任何向量在顶点着色器中进行变换，而第一种方法中就是必须的，因为采样出来的法线向量对于每个片段着色器都不一样。</p>
<p>所以现在不是把TBN矩阵的逆矩阵发送给片段着色器，而是将切线空间的光源位置，观察位置以及顶点位置发送给片段着色器。这样我们就不用在顶点着色器里进行矩阵乘法了。这是一个极佳的优化，因为顶点着色器的运行频率明显低于片段着色器。这也是为什么这种方法是一种更好的实现方式的原因。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec3 TangentLightPos;</span><br><span class="line">    vec3 TangentViewPos;</span><br><span class="line">    vec3 TangentFragPos;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    [...]</span><br><span class="line">    mat3 TBN = <span class="built_in">transpose</span>(<span class="built_in">mat3</span>(T, B, N));</span><br><span class="line">    vs_out.TangentLightPos = TBN * lightPos;</span><br><span class="line">    vs_out.TangentViewPos  = TBN * viewPos;</span><br><span class="line">    vs_out.TangentFragPos  = TBN * <span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(position, <span class="number">0.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在片段着色器中我们使用这些新的输入变量来计算切线空间的光照。因为法线向量已经在切线空间中了，光照就有意义了。</p>
<p>将法线贴图应用到切线空间上，我们会得到混合教程一开始那个例子相似的结果，但这次我们可以将平面朝向各个方向，光照一直都会是正确的，最终的效果如下所示：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260209164528383.png" class="" title="image-20260209164528383">

<p>在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping.rar">这里</a>可以获取完整的代码</p>
<h2 id="复杂物体"><a href="#复杂物体" class="headerlink" title="复杂物体"></a>复杂物体</h2><p>我们已经知道如何计算切线和副切线向量，使用切线空间和法线贴图。所幸，计算这些切线和副切线向量对于你来说不是经常能遇到的事；大多数时候，在模型加载器中实现一次就行了，Assimp的那个加载器中有进行实现。</p>
<p>Assimp有个很有用的配置，在我们加载模型的时候调用aiProcess_CalcTangentSpace。当aiProcess_CalcTangentSpace应用到Assimp的ReadFile函数时，Assimp会为每个加载的顶点计算出柔和的切线和副切线向量，它所使用的方法和我们前面使用的类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> aiScene* scene = importer.<span class="built_in">ReadFile</span>(</span><br><span class="line">    path, aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>我们可以通过下面的代码用Assimp获取计算出来的切线空间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector.x = mesh-&gt;mTangents[i].x;</span><br><span class="line">vector.y = mesh-&gt;mTangents[i].y;</span><br><span class="line">vector.z = mesh-&gt;mTangents[i].z;</span><br><span class="line">vertex.Tangent = vector;</span><br></pre></td></tr></table></figure>

<p>然后，你还必须更新模型加载器，用以从带纹理模型中加载法线贴图。wavefront的模型格式（.obj）导出的法线贴图有点不一样，Assimp的aiTextureType_NORMAL并不会加载它的法线贴图，而aiTextureType_HEIGHT却能，所以我们经常这样加载它们：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector normalMaps = <span class="built_in">loadMaterialTextures</span>(material, aiTextureType_HEIGHT, <span class="string">&quot;texture_normal&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当然，这对于每个模型的类型和文件格式来说都是不同的。计算切线需要依据纹理坐标，有些模型制作者使用一些纹理小技巧比如镜像一个模型上的纹理表面时也镜像了另一半的纹理坐标；这样当不考虑这个镜像的特别操作的时候（Assimp就不考虑）结果就不对了。</p>
<p>运行程序，用新的模型加载器，加载一个有specular和法线贴图的模型，看起来会像这样：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_complex_compare.png" class="" title="img">

<p>你可以看到在没有太多点的额外开销的情况下法线贴图难以置信地提升了物体的细节。</p>
<p>使用法线贴图也是一种提升你的场景的表现的重要方式。在使用法线贴图之前你不得不使用相当多的顶点才能表现出一个更精细的网格，但使用了法线贴图我们可以使用更少的顶点表现出同样丰富的细节。下图来自Paolo Cignoni，图中对比了两种方式：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_comparison.png" class="" title="img">

<p>高精度网格和使用法线贴图的低精度网格几乎区分不出来。所以法线贴图不仅看起来漂亮，它也是一个将高精度多边形转换为低精度多边形而不失细节的重要工具。</p>
<h2 id="最后一件事"><a href="#最后一件事" class="headerlink" title="最后一件事"></a>最后一件事</h2><p>关于法线贴图还有最后一个技巧要讨论，它可以在不必花费太多性能开销的情况下稍稍提升画质表现。</p>
<p>当在更大的网格上计算切线向量的时候，它们往往有很大数量的共享顶点，当法向贴图应用到这些表面时将切线向量平均化通常能获得更好更平滑的结果。这样做有个问题，就是TBN向量可能会不能互相垂直，这意味着TBN矩阵不再是正交矩阵了。法线贴图可能会稍稍偏移，但这仍然可以改进。</p>
<p>使用叫做<em>格拉姆-施密特</em>正交化过程（Gram-Schmidt process）的数学技巧，我们可以对TBN向量进行重正交化，这样每个向量就又会重新垂直了。在顶点着色器中我们这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vec3 T = <span class="built_in">normalize</span>(<span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(tangent, <span class="number">0.0</span>)));</span><br><span class="line">vec3 N = <span class="built_in">normalize</span>(<span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(normal, <span class="number">0.0</span>)));</span><br><span class="line"><span class="comment">// re-orthogonalize T with respect to N</span></span><br><span class="line">T = <span class="built_in">normalize</span>(T - <span class="built_in">dot</span>(T, N) * N);</span><br><span class="line"><span class="comment">// then retrieve perpendicular vector B with the cross product of T and N</span></span><br><span class="line">vec3 B = <span class="built_in">cross</span>(T, N);</span><br><span class="line"></span><br><span class="line">mat3 TBN = <span class="built_in">mat3</span>(T, B, N)</span><br></pre></td></tr></table></figure>

<p>这样稍微花费一些性能开销就能对法线贴图进行一点提升。看看最后的那个附加资源： Normal Mapping Mathematics视频，里面有对这个过程的解释。</p>
<h2 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a>附加资源</h2><ul>
<li><a target="_blank" rel="noopener" href="http://ogldev.atspace.co.uk/www/tutorial26/tutorial26.html">Tutorial 26: Normal Mapping</a>：ogldev的法线贴图教程。</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=LIOPYmknj5Q">How Normal Mapping Works</a>：TheBennyBox的讲述法线贴图如何工作的视频。</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=4FaWLgsctqY">Normal Mapping Mathematics</a>：TheBennyBox关于法线贴图的数学原理的教程。</li>
<li><a target="_blank" rel="noopener" href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/">Tutorial 13: Normal Mapping</a>：opengl-tutorial.org提供的法线贴图教程。</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>OSkirito
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/" title="33-法线贴图">http://example.com/2026/01/26/33-法线贴图/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag"># 图形学</a>
              <a href="/tags/Shader/" rel="tag"># Shader</a>
              <a href="/tags/OpenGL/" rel="tag"># OpenGL</a>
              <a href="/tags/GLSL/" rel="tag"># GLSL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/08/06/Deadline%E5%AF%B9Job%E8%BF%9B%E8%A1%8C%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" rel="prev" title="Deadline对Job进行预处理的几种方法">
      <i class="fa fa-chevron-left"></i> Deadline对Job进行预处理的几种方法
    </a></div>
      <div class="post-nav-item">
    <a href="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/" rel="next" title="34-视差贴图">
      34-视差贴图 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE"><span class="nav-number">1.</span> <span class="nav-text">法线贴图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4"><span class="nav-number">2.</span> <span class="nav-text">切线空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E8%AE%A1%E7%AE%97%E5%88%87%E7%BA%BF%E5%92%8C%E5%89%AF%E5%88%87%E7%BA%BF"><span class="nav-number">2.1.</span> <span class="nav-text">使用代码计算切线和副切线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE"><span class="nav-number">2.2.</span> <span class="nav-text">切线空间法线贴图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E7%89%A9%E4%BD%93"><span class="nav-number">3.</span> <span class="nav-text">复杂物体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%BB%B6%E4%BA%8B"><span class="nav-number">4.</span> <span class="nav-text">最后一件事</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E8%B5%84%E6%BA%90"><span class="nav-number">5.</span> <span class="nav-text">附加资源</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OSkirito"
      src="/images/head_image.png">
  <p class="site-author-name" itemprop="name">OSkirito</p>
  <div class="site-description" itemprop="description">CG技术的记录与分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oskirito" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oskirito" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023 – 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OSkirito</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
