<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="视差贴图(Parallax Mapping)和法线贴图一样能够极大提升表面细节，使之具有深度感和细节感。它也是利用了视错觉，然而对深度有着更好的效果，与法线贴图一起使用能够产生难以置信的效果。视差贴图和光照无关，在这里是作为法线贴图的技术延续来讨论它的。 视差贴图属于置换贴图(Displacement Mapping)技术的一种，它对根据储存在纹理中的几何信息对顶点进行位移或偏移。一种实现的方式是">
<meta property="og:type" content="article">
<meta property="og:title" content="34-视差贴图">
<meta property="og:url" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/index.html">
<meta property="og:site_name" content="OS&#39;s Blog">
<meta property="og:description" content="视差贴图(Parallax Mapping)和法线贴图一样能够极大提升表面细节，使之具有深度感和细节感。它也是利用了视错觉，然而对深度有着更好的效果，与法线贴图一起使用能够产生难以置信的效果。视差贴图和光照无关，在这里是作为法线贴图的技术延续来讨论它的。 视差贴图属于置换贴图(Displacement Mapping)技术的一种，它对根据储存在纹理中的几何信息对顶点进行位移或偏移。一种实现的方式是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_height_map.png">
<meta property="og:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_plane_height.png">
<meta property="og:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_scaled_height.png">
<meta property="og:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_incorrect_p.png">
<meta property="og:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_depth.png">
<meta property="og:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-20260214153607830.png">
<meta property="og:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-20260214154953667.png">
<meta property="og:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_issues.png">
<meta property="og:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_steep_parallax_mapping_diagram.png">
<meta property="og:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-20260214160055433.png">
<meta property="og:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-20260214160203094.png">
<meta property="og:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_parallax_occlusion_mapping_diagram.png">
<meta property="og:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-20260214161408416.png">
<meta property="article:published_time" content="2026-02-09T09:22:27.000Z">
<meta property="article:modified_time" content="2026-02-14T08:21:05.603Z">
<meta property="article:author" content="OSkirito">
<meta property="article:tag" content="图形学">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="OpenGL">
<meta property="article:tag" content="GLSL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_height_map.png">

<link rel="canonical" href="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>34-视差贴图 | OS's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OS's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">29</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">56</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          34-视差贴图
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-02-09 17:22:27" itemprop="dateCreated datePublished" datetime="2026-02-09T17:22:27+08:00">2026-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-02-14 16:21:05" itemprop="dateModified" datetime="2026-02-14T16:21:05+08:00">2026-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>视差贴图(Parallax Mapping)和法线贴图一样能够极大提升表面细节，使之具有深度感和细节感。它也是利用了视错觉，然而对深度有着更好的效果，与法线贴图一起使用能够产生难以置信的效果。视差贴图和光照无关，在这里是作为法线贴图的技术延续来讨论它的。</p>
<p>视差贴图属于置换贴图(Displacement Mapping)技术的一种，它对根据储存在纹理中的几何信息对顶点进行位移或偏移。一种实现的方式是比如有1000个顶点，根据纹理中的数据对平面特定区域的顶点的高度进行位移。这样的每个纹理像素包含了高度值纹理叫做高度贴图。一张简单的砖块表面的高度贴图如下所示：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_height_map.png" class="" title="img">

<p>整个平面上的每个顶点都根据从高度贴图采样出来的高度值进行位移，根据材质的几何属性平坦的平面变换成凹凸不平的表面。置换顶点有一个问题就是平面必须由很多顶点组成才能获得具有真实感的效果，否则看起来效果并不会很好。一个平坦的表面上有1000个顶点计算量太大了。我们能否不用这么多的顶点就能取得相似的效果呢？事实上，通常的表面就是用6个顶点渲染出来的（两个三角形）。置换贴图技术不需要额外的顶点数据来表达深度，它会像法线贴图一样采用一种手段欺骗用户的眼睛。</p>
<p>视差贴图背后的思想是修改纹理坐标使一个fragment的表面看起来比实际的更高或者更低，所有这些都根据观察方向和高度贴图。为了理解它如何工作，看看下面砖块表面的图片：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_plane_height.png" class="" title="img">

<p>这里粗糙的红线代表高度贴图中的数值的立体表达，向量V¯代表观察方向。如果平面进行实际位移，观察者会在点B看到表面。然而我们的平面没有实际上进行位移，观察方向将在点A与平面接触。视差贴图的目的是，在A位置上的fragment不再使用点A的纹理坐标而是使用点B的。随后我们用点B的纹理坐标采样，观察者就像看到了点B一样。</p>
<p>这个技巧就是描述如何从点A得到点B的纹理坐标。视差贴图尝试通过对从fragment到观察者的方向向量V¯进行缩放的方式解决这个问题，缩放的大小是A处fragment的高度。所以我们将V¯的长度缩放为高度贴图在点A处H(A)采样得来的值。下图展示了经缩放得到的向量P¯：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_scaled_height.png" class="" title="img">

<p>我们随后选出P¯以及这个向量与平面对齐的坐标作为纹理坐标的偏移量。这能工作是因为向量P¯是使用从高度贴图得到的高度值计算出来的，所以一个fragment的高度越高位移的量越大。</p>
<p>这个技巧在大多数时候都没问题，但点B是粗略估算得到的。当表面的高度变化很快的时候，看起来就不会真实，因为向量P¯最终不会和B接近，就像下图这样：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_incorrect_p.png" class="" title="img">

<p>视差贴图的另一个问题是，当表面被任意旋转以后很难指出从P¯获取哪一个坐标。我们在视差贴图中使用了另一个坐标空间，这个空间P¯向量的x和y元素总是与纹理表面对齐。你也许猜到了，我们实现它的方法还是在切线空间中实现视差贴图。</p>
<p>将fragment到观察者的向量V¯转换到切线空间中，经变换的P¯向量的x和y元素将于表面的切线和副切线向量对齐。由于切线和副切线向量与表面纹理坐标的方向相同，我们可以用P¯的x和y元素作为纹理坐标的偏移量，这样就不用考虑表面的方向了。</p>
<p>理论都有了，下面我们来动手实现视差贴图。</p>
<h2 id="视差贴图"><a href="#视差贴图" class="headerlink" title="视差贴图"></a>视差贴图</h2><p>我们将使用一个简单的2D平面，在把它发送给GPU之前我们先计算它的切线和副切线向量；和法线贴图教程做的差不多。我们将在平面上使用diffuse纹理、法线贴图以及一个置换贴图，这个例子中我们将视差贴图和法线贴图一起使用。因为视差贴图使表面位移了的幻觉，当光照不匹配时这种幻觉就被破坏了。法线贴图通常根据高度贴图生成，法线贴图和高度贴图一起用能保证光照能和这些位移信息相匹配。</p>
<p>一般我们使用的高度贴图与开头所示的那个高度贴图相比是颜色是相反的。这是因为使用反色高度贴图（也叫深度贴图）去模拟深度比模拟高度更容易。下图反映了这个轻微的改变：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_depth.png" class="" title="img">

<p>我们再次获得A和B，但是这次我们用向量V¯减去点A的纹理坐标得到P¯。我们通过在着色器中用1.0减去采样得到的高度贴图中的值来取得深度值，而不再是高度值，或者简单地在图片编辑软件中把这个纹理进行反色操作，就像我们对连接中的那个深度贴图所做的一样。</p>
<p>置换贴图是在像素着色器中实现的，因为三角形表面的所有置换效果都不同。在像素着色器中我们将需要计算fragment到观察者到方向向量V¯所以我们需要观察者位置和在切线空间中的fragment位置。在之前法线贴图教程中我们已经有了一个顶点着色器，它把这些向量发送到切线空间，所以我们可以复制那个顶点着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aNormal;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 aTexCoords;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">3</span>) in vec3 aTangent;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">4</span>) in vec3 abitangent;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec3 TangentLightPos;</span><br><span class="line">    vec3 TangentViewPos;</span><br><span class="line">    vec3 TangentFragPos;</span><br><span class="line">    vec3 LightPos;</span><br><span class="line">    vec3 ViewPos;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vs_out.FragPos = <span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>));</span><br><span class="line">    vs_out.TexCoords = aTexCoords;</span><br><span class="line"></span><br><span class="line">    vec3 T = <span class="built_in">normalize</span>(<span class="built_in">mat3</span>(model) * aTangent);</span><br><span class="line">    vec3 N = <span class="built_in">normalize</span>(<span class="built_in">mat3</span>(model) * aNormal);</span><br><span class="line">    vec3 B = <span class="built_in">normalize</span>(<span class="built_in">mat3</span>(model) * abitangent);</span><br><span class="line">    </span><br><span class="line">    mat3 TBN = <span class="built_in">transpose</span>(<span class="built_in">mat3</span>(T, B, N));</span><br><span class="line"></span><br><span class="line">    vs_out.Normal = N;</span><br><span class="line">    </span><br><span class="line">    vs_out.TangentLightPos = TBN * lightPos;</span><br><span class="line">    vs_out.TangentViewPos  = TBN * viewPos;</span><br><span class="line">    vs_out.TangentFragPos  = TBN * vs_out.FragPos;</span><br><span class="line">    </span><br><span class="line">    vs_out.LightPos = lightPos;</span><br><span class="line">    vs_out.ViewPos  = viewPos;</span><br><span class="line">        </span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里有件事很重要，我们需要把position和在切线空间中的观察者的位置viewPos发送给像素着色器。</p>
<p>在片段着色器中，我们实现视差贴图的逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec3 TangentLightPos;</span><br><span class="line">    vec3 TangentViewPos;</span><br><span class="line">    vec3 TangentFragPos;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseTexture;</span><br><span class="line">uniform sampler2D normalTexture;</span><br><span class="line">uniform sampler2D depthTexture;</span><br><span class="line"></span><br><span class="line">uniform <span class="type">float</span> height_scale;</span><br><span class="line"></span><br><span class="line"><span class="function">vec2 <span class="title">ParallaxMapping</span><span class="params">(vec2 texCoords, vec3 viewDir)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    <span class="comment">// Offset texture coordinates with Parallax Mapping</span></span><br><span class="line">    vec3 viewDir   = <span class="built_in">normalize</span>(fs_in.TangentViewPos - fs_in.TangentFragPos);</span><br><span class="line">    vec2 texCoords = <span class="built_in">ParallaxMapping</span>(fs_in.TexCoords,  viewDir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then sample textures with new texture coords</span></span><br><span class="line">    vec3 diffuse = <span class="built_in">texture</span>(diffuseMap, texCoords);</span><br><span class="line">    vec3 normal  = <span class="built_in">texture</span>(normalMap, texCoords);</span><br><span class="line">    normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// proceed with lighting code</span></span><br><span class="line">    [...]    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个叫做ParallaxMapping的函数，它把fragment的纹理坐标和切线空间中的fragment到观察者的方向向量为输入。这个函数返回经位移的纹理坐标。然后我们使用这些经位移的纹理坐标进行diffuse和法线贴图的采样。最后fragment的diffuse颜色和法线向量就正确的对应于表面的经位移的位置上了。</p>
<p>我们来看看ParallaxMapping函数的内部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec2 <span class="title">ParallaxMapping</span><span class="params">(vec2 texCoords, vec3 viewDir)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">float</span> height =  <span class="built_in">texture</span>(depthTexture, texCoords).r;    </span><br><span class="line">    vec2 p = viewDir.xy / viewDir.z * (height * height_scale);</span><br><span class="line">    <span class="keyword">return</span> texCoords - p;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个相对简单的函数是我们所讨论过的内容的直接表述。我们用本来的纹理坐标texCoords从高度贴图中来采样，得到当前fragment的高度H(A)。然后计算出P¯，x和y元素在切线空间中，viewDir向量除以它的z元素，用fragment的高度对它进行缩放。我们同时引入额一个height_scale的uniform，来进行一些额外的控制，因为视差效果如果没有一个缩放参数通常会过于强烈。然后我们用P¯减去纹理坐标来获得最终的经过位移纹理坐标。</p>
<p>有一个地方需要注意，就是viewDir.xy除以viewDir.z那里。因为viewDir向量是经过了标准化的，viewDir.z会在0.0到1.0之间的某处。当viewDir大致平行于表面时，它的z元素接近于0.0，除法会返回比viewDir垂直于表面的时候更大的P¯向量。所以，从本质上，相比正朝向表面，当带有角度地看向平面时，我们会更大程度地缩放P¯的大小，从而增加纹理坐标的偏移；这样做在视角上会获得更大的真实度。</p>
<p>最后的纹理坐标随后被用来进行采样（diffuse和法线）贴图，下图所展示的位移效果中height_scale等于0.1：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-20260214153607830.png" class="" title="image-20260214153607830">

<p>这里你会看到只用法线贴图和与视差贴图相结合的法线贴图的不同之处。因为视差贴图尝试模拟深度，它实际上能够根据你观察它们的方向使砖块叠加到其他砖块上。</p>
<p>在视差贴图的那个平面里你仍然能看到在边上有古怪的失真。原因是在平面的边缘上，纹理坐标超出了0到1的范围进行采样，根据纹理的环绕方式导致了不真实的结果。解决的方法是当它超出默认纹理坐标范围进行采样的时候就丢弃这个fragment：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">texCoords = <span class="built_in">ParallaxMapping</span>(fs_in.TexCoords,  viewDir);</span><br><span class="line"><span class="keyword">if</span>(texCoords.x &gt; <span class="number">1.0</span> || texCoords.y &gt; <span class="number">1.0</span> || texCoords.x &lt; <span class="number">0.0</span> || texCoords.y &lt; <span class="number">0.0</span>)</span><br><span class="line">    discard;</span><br></pre></td></tr></table></figure>

<p>丢弃了超出默认范围的纹理坐标的所有fragment，视差贴图的表面边缘给出了正确的结果。注意，这个技巧不能在所有类型的表面上都能工作，但是应用于平面上它还是能够是平面看起来真的进行位移了：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-20260214154953667.png" class="" title="image-20260214154953667">

<p>你可以在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_01.rar">这里</a>找到源代码。</p>
<p>看起来不错，运行起来也很快，因为我们只要给视差贴图提供一个额外的纹理样本就能工作。当从一个角度看过去的时候，会有一些问题产生（和法线贴图相似），陡峭的地方会产生不正确的结果，从下图你可以看到：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_issues.png" class="" title="img">

<p>问题的原因是这只是一个大致近似的视差映射。还有一些技巧让我们在陡峭的高度上能够获得几乎完美的结果，即使当以一定角度观看的时候。例如，我们不再使用单一样本，取而代之使用多样本来找到最近点B会得到怎样的结果？</p>
<h2 id="陡峭视差映射"><a href="#陡峭视差映射" class="headerlink" title="陡峭视差映射"></a>陡峭视差映射</h2><p>陡峭视差映射(Steep Parallax Mapping)是视差映射的扩展，原则是一样的，但不是使用一个样本而是多个样本来确定向量P¯到B。即使在陡峭的高度变化的情况下，它也能得到更好的结果，原因在于该技术通过增加采样的数量提高了精确性。</p>
<p>陡峭视差映射的基本思想是将总深度范围划分为同一个深度/高度的多个层。从每个层中我们沿着P¯方向移动采样纹理坐标，直到我们找到一个采样低于当前层的深度值。看看下面的图片：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_steep_parallax_mapping_diagram.png" class="" title="img">

<p>我们从上到下遍历深度层，我们把每个深度层和储存在深度贴图中的它的深度值进行对比。如果这个层的深度值小于深度贴图的值，就意味着这一层的P¯向量部分在表面之下。我们继续这个处理过程直到有一层的深度高于储存在深度贴图中的值：这个点就在（经过位移的）表面下方。</p>
<p>这个例子中我们可以看到第二层(D(2) = 0.73)的深度贴图的值仍低于第二层的深度值0.4，所以我们继续。下一次迭代，这一层的深度值0.6大于深度贴图中采样的深度值(D(3) = 0.37)。我们便可以假设第三层向量P¯是可用的位移几何位置。我们可以用从向量P3¯的纹理坐标偏移T3来对fragment的纹理坐标进行位移。你可以看到随着深度曾的增加精确度也在提高。</p>
<p>为实现这个技术，我们只需要改变ParallaxMapping函数，因为所有需要的变量都有了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec2 <span class="title">ParallaxMapping</span><span class="params">(vec2 texCoords, vec3 viewDir)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// number of depth layers</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> numLayers = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// calculate the size of each layer</span></span><br><span class="line">    <span class="type">float</span> layerDepth = <span class="number">1.0</span> / numLayers;</span><br><span class="line">    <span class="comment">// depth of current layer</span></span><br><span class="line">    <span class="type">float</span> currentLayerDepth = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// the amount to shift the texture coordinates per layer (from vector P)</span></span><br><span class="line">    vec2 P = viewDir.xy * height_scale; </span><br><span class="line">    vec2 deltaTexCoords = P / numLayers;</span><br><span class="line"></span><br><span class="line">    [...]     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先定义层的数量，计算每一层的深度，最后计算纹理坐标偏移，每一层我们必须沿着P¯的方向进行移动。</p>
<p>然后我们遍历所有层，从上开始，知道找到小于这一层的深度值的深度贴图值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get initial values</span></span><br><span class="line">vec2  currentTexCoords     = texCoords;</span><br><span class="line"><span class="type">float</span> currentDepthMapValue = <span class="built_in">texture</span>(depthTexture, currentTexCoords).r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(currentLayerDepth &lt; currentDepthMapValue)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// shift texture coordinates along direction of P</span></span><br><span class="line">    currentTexCoords -= deltaTexCoords;</span><br><span class="line">    <span class="comment">// get depthmap value at current texture coordinates</span></span><br><span class="line">    currentDepthMapValue = <span class="built_in">texture</span>(depthTexture, currentTexCoords).r;  </span><br><span class="line">    <span class="comment">// get depth of next layer</span></span><br><span class="line">    currentLayerDepth += layerDepth;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> currentTexCoords;</span><br></pre></td></tr></table></figure>

<p>这里我们循环每一层深度，直到沿着P¯向量找到第一个返回低于（位移）表面的深度的纹理坐标偏移量。从fragment的纹理坐标减去最后的偏移量，来得到最终的经过位移的纹理坐标向量，这次就比传统的视差映射更精确了。有10个样本砖墙从一个角度看上去就已经很好了，但是当有一个强前面展示的木制表面一样陡峭的表面时，陡峭的视差映射的威力就显示出来了：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-20260214160055433.png" class="" title="image-20260214160055433">

<p>我们可以通过对视差贴图的一个属性的利用，对算法进行一点提升。当垂直看一个表面的时候纹理时位移比以一定角度看时的小。我们可以在垂直看时使用更少的样本，以一定角度看时增加样本数量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> minLayers = <span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> maxLayers = <span class="number">32</span>;</span><br><span class="line"><span class="type">float</span> numLayers = <span class="built_in">mix</span>(maxLayers, minLayers, <span class="built_in">abs</span>(<span class="built_in">dot</span>(<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>), viewDir)));</span><br></pre></td></tr></table></figure>

<p>这里我们得到viewDir和正z方向的点乘，使用它的结果根据我们看向表面的角度调整样本数量（注意正z方向等于切线空间中的表面的法线）。如果我们所看的方向平行于表面，我们就是用32层。</p>
<p>陡峭视差贴图同样有自己的问题。因为这个技术是基于有限的样本数量的，我们会遇到锯齿效果以及图层之间有明显的断层：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-20260214160203094.png" class="" title="image-20260214160203094">

<p>我们可以通过增加样本的方式减少这个问题，但是很快就会花费很多性能。有些旨在修复这个问题的方法：不适用低于表面的第一个位置，而是在两个接近的深度层进行插值找出更匹配B的。</p>
<p>两种最流行的解决方法叫做Relief Parallax Mapping和Parallax Occlusion Mapping，Relief Parallax Mapping更精确一些，但是比Parallax Occlusion Mapping性能开销更多。因为Parallax Occlusion Mapping的效果和前者差不多但是效率更高，因此这种方式更经常使用，所以我们将在下面讨论一下。</p>
<p>最终的代码你可以在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_02.rar">这里</a>获取。</p>
<h2 id="视差遮蔽映射"><a href="#视差遮蔽映射" class="headerlink" title="视差遮蔽映射"></a>视差遮蔽映射</h2><p>视差遮蔽映射(Parallax Occlusion Mapping)和陡峭视差映射的原则相同，但不是用触碰的第一个深度层的纹理坐标，而是在触碰之前和之后，在深度层之间进行线性插值。我们根据表面的高度距离那个深度层的深度层值的距离来确定线性插值的大小。看看下面的图片就能了解它是如何工作的：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_parallax_occlusion_mapping_diagram.png" class="" title="img">

<p>你可以看到大部分和陡峭视差映射一样，不一样的地方是有个额外的步骤，两个深度层的纹理坐标围绕着交叉点的线性插值。这也是近似的，但是比陡峭视差映射更精确。</p>
<p>视差遮蔽映射的代码基于陡峭视差映射，所以并不难：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[...] <span class="comment">// steep parallax mapping code here</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get texture coordinates before collision (reverse operations)</span></span><br><span class="line">vec2 prevTexCoords = currentTexCoords + deltaTexCoords;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get depth after and before collision for linear interpolation</span></span><br><span class="line"><span class="type">float</span> afterDepth  = currentDepthMapValue - currentLayerDepth;</span><br><span class="line"><span class="type">float</span> beforeDepth = <span class="built_in">texture</span>(depthTexture, prevTexCoords).r - currentLayerDepth + layerDepth;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interpolation of texture coordinates</span></span><br><span class="line"><span class="type">float</span> weight = afterDepth / (afterDepth - beforeDepth);</span><br><span class="line">vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (<span class="number">1.0</span> - weight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> finalTexCoords;</span><br></pre></td></tr></table></figure>

<p>在对（位移的）表面几何进行交叉，找到深度层之后，我们获取交叉前的纹理坐标。然后我们计算来自相应深度层的几何之间的深度之间的距离，并在两个值之间进行插值。线性插值的方式是在两个层的纹理坐标之间进行的基础插值。函数最后返回最终的经过插值的纹理坐标。</p>
<p>视差遮蔽映射的效果非常好，尽管有一些可以看到的轻微的不真实和锯齿的问题，这仍是一个好交易，因为除非是放得非常大或者观察角度特别陡，否则也看不到。</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-20260214161408416.png" class="" title="image-20260214161408416">

<p>你可以在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_03.rar">这里</a>找到源代码。</p>
<p>视差贴图是提升场景细节非常好的技术，但是使用的时候还是要考虑到它会带来一点不自然。大多数时候视差贴图用在地面和墙壁表面，这种情况下查明表面的轮廓并不容易，同时观察角度往往趋向于垂直于表面。这样视差贴图的不自然也就很难能被注意到了，对于提升物体的细节可以起到难以置信的效果。</p>
<h2 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a>附加资源</h2><ul>
<li><a target="_blank" rel="noopener" href="http://sunandblackcat.com/tipFullView.php?topicid=28">Parallax Occlusion Mapping in GLSL</a>：<a target="_blank" rel="noopener" href="http://sunandblackcat.com/">sunandblackcat.com</a>上的视差贴图教程。</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=xvOT62L-fQI">How Parallax Displacement Mapping Works</a>：TheBennyBox的关于视差贴图原理的视频教程。</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>OSkirito
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/" title="34-视差贴图">http://example.com/2026/02/09/34-视差贴图/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag"># 图形学</a>
              <a href="/tags/Shader/" rel="tag"># Shader</a>
              <a href="/tags/OpenGL/" rel="tag"># OpenGL</a>
              <a href="/tags/GLSL/" rel="tag"># GLSL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/" rel="prev" title="33-法线贴图">
      <i class="fa fa-chevron-left"></i> 33-法线贴图
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE"><span class="nav-number">1.</span> <span class="nav-text">视差贴图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%A1%E5%B3%AD%E8%A7%86%E5%B7%AE%E6%98%A0%E5%B0%84"><span class="nav-number">2.</span> <span class="nav-text">陡峭视差映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E5%B7%AE%E9%81%AE%E8%94%BD%E6%98%A0%E5%B0%84"><span class="nav-number">3.</span> <span class="nav-text">视差遮蔽映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E8%B5%84%E6%BA%90"><span class="nav-number">4.</span> <span class="nav-text">附加资源</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OSkirito"
      src="/images/head_image.png">
  <p class="site-author-name" itemprop="name">OSkirito</p>
  <div class="site-description" itemprop="description">CG技术的记录与分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oskirito" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oskirito" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023 – 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OSkirito</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
