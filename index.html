<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CG技术的记录与分享">
<meta property="og:type" content="website">
<meta property="og:title" content="OS&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="OS&#39;s Blog">
<meta property="og:description" content="CG技术的记录与分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="OSkirito">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>OS's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OS's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">50</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%EF%BC%88bat%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%EF%BC%88bat%EF%BC%89/" class="post-title-link" itemprop="url">如何使用批处理脚本（bat）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-27 11:36:48 / 修改时间：12:59:41" itemprop="dateCreated datePublished" datetime="2024-12-27T11:36:48+08:00">2024-12-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>bat（批处理文件），在DOS和Windows（任意版本）系统中，bat文件是可执行文件，由一系列命令构成，其中可以包含对其他程序的调用。这个文件的每一行都是一条DOS命令（大部分时候就好像我们在DOS提示符下执行的命令行一样），你可以使用DOS下的Edit或者Windows的记事本等任何文本文件编辑工具创建和修改批处理该类型的文件。</p>
<p>批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理，是一种简化的脚本语言，它的扩展名为bat 或cmd。比较常见的批处理包含两类：DOS批处理和PS批处理。PS批处理是基于强大的图片编辑软件Photoshop的，用来批量处理图片的脚本；而DOS批处理则是基于DOS命令的，用来自动地批量地执行DOS命令以实现特定操作的脚本。更复杂的情况，需要使用if、for、goto等命令控制程序的运行过程，如同C、Basic等高级语言一样。如果需要实现更复杂的应用，利用外部程序是必要的，这包括系统本身提供的外部命令和第三方提供的工具或者软件。批处理程序虽然是在命令行环境中运行，但不仅仅能使用命令行软件，任何当前系统下可运行的程序都可以放在批处理文件中运行。</p>
<p>对于TD/TA工作者来说，bat的编写是一项基本技能，工作中需要经常使用到bat来配置环境并且对DCC软件进行启动，下面对bat脚本进行介绍。</p>
<h2 id="基本语法和常用命令"><a href="#基本语法和常用命令" class="headerlink" title="基本语法和常用命令"></a>基本语法和常用命令</h2><h3 id="1-常用命令汇总"><a href="#1-常用命令汇总" class="headerlink" title="1.常用命令汇总"></a>1.常用命令汇总</h3><ul>
<li><code>echo</code>: 显示消息</li>
<li><code>dir</code>: 列出目录内容</li>
<li><code>cd</code>: 更改目录</li>
<li><code>del</code>: 删除文件</li>
<li><code>copy</code>: 复制文件</li>
<li><code>move</code>: 移动文件</li>
<li><code>set</code>: 设置环境变量</li>
<li><code>start</code>: 启动程序</li>
<li><code>pause</code>: 暂停</li>
<li><code>exit</code>: 退出脚本</li>
</ul>
<h3 id="2-回显"><a href="#2-回显" class="headerlink" title="2.回显"></a>2.回显</h3><p>在 Batch 文件中，<code>@</code> 符号用于禁止命令回显。通常，Batch 文件中的每一行命令执行时，命令本身都会被显示在命令行窗口中，除非你使用 <code>@echo off</code> 来禁止回显。具体来说：</p>
<h4 id="1-echo-off"><a href="#1-echo-off" class="headerlink" title="1.@echo off"></a>1.<code>@echo off</code></h4><p><code>@echo off</code> 是 Batch 文件中的常见用法。它用于禁用所有命令本身的回显，也就是不显示脚本执行的命令，在此后的所有命令都不会进行回显。通常放在 Batch 文件的开头，目的是让整个脚本在执行时不会显示命令</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br></pre></td></tr></table></figure>

<p>这条命令会让 Batch 文件在执行时不显示任何命令，只显示输出结果。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2.@"></a>2.<code>@</code></h4><p>在 <code>@echo off</code> 之外，<code>@</code> 可以加在任何命令的前面，来阻止该条命令的回显。例如：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> Hello, World!</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>@</code> 确保 <code>echo Hello, World!</code> 这一行命令不会被回显，只有它的输出会被显示。</p>
<h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. <strong>注释</strong></h3><p>在 Batch 文件中，注释是用 <code>REM</code> 或 <code>::</code> 来表示的：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">REM 这是一个注释</span></span><br><span class="line">:: 这也是注释</span><br></pre></td></tr></table></figure>

<h3 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. <strong>命令</strong></h3><p>Batch 文件的命令通常是 Windows 命令行命令（如 <code>echo</code>、<code>dir</code>、<code>del</code> 等）。每行一个命令：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> Hello, World!</span><br><span class="line"><span class="built_in">dir</span> C:\Users</span><br></pre></td></tr></table></figure>

<h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. <strong>变量</strong></h3><p>Batch 文件支持通过 <code>%</code> 访问变量。可以用 <code>set</code> 命令来定义变量：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> MY_VAR=Hello</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%MY_VAR%</span></span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>set</code> 读取和修改环境变量：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="built_in">PATH</span>=<span class="variable">%PATH%</span>;C:\MyProgram</span><br></pre></td></tr></table></figure>

<h3 id="6-控制流"><a href="#6-控制流" class="headerlink" title="6. 控制流"></a>6. <strong>控制流</strong></h3><p>Batch 文件支持基本的控制流结构，如条件语句和循环。</p>
<ul>
<li><p><strong>条件判断（if）</strong>:</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">EXIST</span> &quot;file.txt&quot; (</span><br><span class="line">    <span class="built_in">echo</span> 文件存在</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">echo</span> 文件不存在</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>跳转（goto）</strong>: <code>goto</code> 用于跳转到文件中的指定标签（label）处：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> MyLabel</span><br><span class="line">:MyLabel</span><br><span class="line"><span class="built_in">echo</span> 这是标签后的代码</span><br></pre></td></tr></table></figure></li>
<li><p><strong>循环（for）</strong>: <code>for</code> 循环可以遍历文件、目录、数字等：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">%%i</span> <span class="keyword">in</span> (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">%%i</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a>7. <strong>错误处理</strong></h3><p>Batch 文件支持基本的错误处理，可以使用 <code>if errorlevel</code> 来检查上一条命令的返回值：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">errorlevel</span> <span class="number">1</span> (</span><br><span class="line">    <span class="built_in">echo</span> 发生错误</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>errorlevel</code> 返回值通常是 0 表示成功，非零值表示失败。</p>
<h3 id="8-输入和输出"><a href="#8-输入和输出" class="headerlink" title="8. 输入和输出"></a>8. <strong>输入和输出</strong></h3><ul>
<li><p><strong>输出（echo）</strong>: <code>echo</code> 用于输出信息到控制台：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> Hello, World!</span><br></pre></td></tr></table></figure></li>
<li><p><strong>输入（set /p）</strong>: <code>set /p</code> 用于从用户获取输入：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> /p USER_INPUT=请输入你的名字: </span><br><span class="line"><span class="built_in">echo</span> 你好, <span class="variable">%USER_INPUT%</span>！</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-文件操作"><a href="#9-文件操作" class="headerlink" title="9. 文件操作"></a>9. <strong>文件操作</strong></h3><p>Batch 文件可以进行常见的文件操作，如删除、复制、移动等：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">del</span> file.txt           # 删除文件</span><br><span class="line"><span class="built_in">copy</span> file.txt D:\backup\ # 复制文件</span><br><span class="line"><span class="built_in">move</span> file.txt D:\backup\ # 移动文件</span><br></pre></td></tr></table></figure>

<h3 id="10-暂停"><a href="#10-暂停" class="headerlink" title="10. 暂停"></a>10. <strong>暂停</strong></h3><p>使用 <code>pause</code> 命令来暂停脚本的执行，直到用户按下任意键：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<h3 id="11-启动外部程序"><a href="#11-启动外部程序" class="headerlink" title="11. 启动外部程序"></a>11. <strong>启动外部程序</strong></h3><p>Batch 文件可以启动外部程序或命令：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">start</span> &quot;notepad.exe&quot;</span><br><span class="line">：：或者</span><br><span class="line">&quot;notepad.exe&quot;</span><br></pre></td></tr></table></figure>

<h3 id="12-退出脚本"><a href="#12-退出脚本" class="headerlink" title="12. 退出脚本"></a>12. <strong>退出脚本</strong></h3><p><code>exit</code> 命令用于退出脚本：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>

<h3 id="13-批量处理命令输出"><a href="#13-批量处理命令输出" class="headerlink" title="13. 批量处理命令输出"></a>13. <strong>批量处理命令输出</strong></h3><p>通过重定向操作符 <code>&gt;</code> 或 <code>&gt;&gt;</code>，可以将命令的输出重定向到文件中：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> Hello, World! &gt; output.txt  # 覆盖写入</span><br><span class="line"><span class="built_in">echo</span> Another line &gt;&gt; output.txt  # 追加写入</span><br></pre></td></tr></table></figure>

<h3 id="14-使用命令行参数"><a href="#14-使用命令行参数" class="headerlink" title="14. 使用命令行参数"></a>14. <strong>使用命令行参数</strong></h3><p>Batch 文件支持命令行参数，通过 <code>%1</code>, <code>%2</code>, <code>%3</code> 等可以访问传递给脚本的参数。例如，<code>script.bat Hello World</code> 中，<code>%1</code> 会是 <code>Hello</code>，<code>%2</code> 会是 <code>World</code>：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> %<span class="number">1</span></span><br><span class="line"><span class="built_in">echo</span> %<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="15-示例：一个简单的-Batch-脚本"><a href="#15-示例：一个简单的-Batch-脚本" class="headerlink" title="15.示例：一个简单的 Batch 脚本"></a>15.示例：一个简单的 Batch 脚本</h3><p>以下是一个示例：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> add <span class="built_in">path</span></span><br><span class="line">:: <span class="built_in">set</span> MAYA_UI_LANGUAGE=en_US</span><br><span class="line"><span class="built_in">set</span> CURRENT_PATH=%~dp0</span><br><span class="line"><span class="keyword">for</span> <span class="variable">%%i</span> <span class="keyword">in</span> (&quot;<span class="variable">%CURRENT_PATH%</span>..&quot;) <span class="keyword">do</span> <span class="built_in">set</span> MAYA_LOCATION=<span class="variable">%%~</span>fi</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%MAYA_LOCATION%</span></span><br><span class="line"><span class="built_in">echo</span> launcher maya2024</span><br><span class="line"><span class="built_in">start</span> &quot;<span class="variable">%MAYA_LOCATION%</span>\bin\maya.exe&quot;</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<p>首先我们关闭了所有命令行的回显，然后输出”add path“，设置maya的ui语言但是对该行代码进行了注释（将不会生效），将当前bat文件的位置路径存储到变量<code>CURRENT_PATH</code>中，然后获取 <code>CURRENT_PATH</code> 上一级目录的完整路径，并将该路径赋值给 <code>MAYA_LOCATION</code>，随后对 <code>MAYA_LOCATION</code>的值进行输出，输出”launcher maya2024“提示，最后启动maya并保留命令行输出窗口。</p>
<h2 id="执行-Batch-文件"><a href="#执行-Batch-文件" class="headerlink" title="执行 Batch 文件"></a>执行 Batch 文件</h2><ol>
<li>将代码保存为 <code>.bat</code> 或 <code>.cmd</code> 文件。</li>
<li>双击文件，或者在cmd命令行中执行该文件。</li>
</ol>
<img src="/2024/12/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%EF%BC%88bat%EF%BC%89/image-20241227125834799.png" class="" title="image-20241227125834799">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/04/33-%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/04/33-%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/" class="post-title-link" itemprop="url">33-级联阴影贴图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-04 14:52:13" itemprop="dateCreated datePublished" datetime="2024-12-04T14:52:13+08:00">2024-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-18 10:34:47" itemprop="dateModified" datetime="2024-12-18T10:34:47+08:00">2024-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前描述的阴影贴图是一种功能强大且相对简单的技术。但是，如果按照上述教程中的原样实现，会有一些缺点：</p>
<ul>
<li>阴影贴图始终围绕原点创建，而不是在摄像机实际查看的区域上创建。当然，如果我们能以足够的分辨率对整个场景进行阴影贴图，那将是最好的，但在当前的硬件上，这是不可行的。实际上，我们希望在视图中的对象上创建阴影贴图，从而为其他重要的事情节省宝贵的 GPU 内存。</li>
<li>阴影贴图正交投影矩阵未正确拟合到视图视锥体上。为了实现阴影贴图的最佳分辨率，正交矩阵需要尽可能紧密地适应摄像机视锥体，因为同样的场景：如果它更大，则意味着在实际可见的对象上花费的细节更少。</li>
<li>如果我们希望阴影渲染距离较大，阴影贴图（即使使用高级 PCF 函数）也会很模糊，就像我们在使用第一人称摄像机的游戏中所做的那样。我们可以提高阴影贴图的分辨率来缓解这种情况，但 GPU 内存是我们应该节省的资源。</li>
</ul>
<p>当我们使用级联阴影贴图时，可以解决第三点，但是在实现它时，我们也将解决前两点。级联阴影贴图的核心是，对于离我们很远的物体，不需要相同数量的阴影细节。我们希望为靠近近平面的物体提供清晰的阴影，并且对于数百单位外的物体，不提供太高的阴影细节。我们只需为近处和远处的物体渲染不同的阴影贴图，然后根据片段着色器中片段的深度从中采样：</p>
<ul>
<li>将我们的普通视图视锥体划分为 n 个子视锥体，其中第 i 个视锥体的远平面是第 i+1 个近平面</li>
<li>计算每个视锥体的拟合正交矩阵</li>
<li>对每个视锥体，渲染阴影贴图</li>
<li>将所有阴影贴图发送到片段着色器中</li>
<li>渲染场景，并根据片段的深度值从正确的阴影贴图中采样</li>
</ul>
<p>在下图中，我们可以看到 在低图形设置下CSGO中阴影级联的边缘。</p>
<img src="/2024/12/04/33-%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/cs_go.png" class="" title="img">

<h2 id="视图视锥体的世界坐标"><a href="#视图视锥体的世界坐标" class="headerlink" title="视图视锥体的世界坐标"></a>视图视锥体的世界坐标</h2><p>在动手处理阴影之前，我们需要解决一个问题：使投影矩阵很好地适应通用视锥体。为了能做到这一点，我们需要知道相关视锥体的世界空间坐标。我们的视图和投影矩阵将视锥体转换为 NDC 立方体。我们知道 NDC 立方体的角坐标：坐标在三个轴的[-1,1]范围内。由于矩阵乘法是一个可逆过程，因此可以在 NDC 立方体的角点上应用视图矩阵和投影矩阵的逆矩阵，以获得世界空间中的视锥体角。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;glm::vec4&gt; <span class="title">getFrustumCornersWorldSpace</span><span class="params">(<span class="type">const</span> glm::mat4&amp; proj, <span class="type">const</span> glm::mat4&amp; view)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> inv = glm::<span class="built_in">inverse</span>(proj * view);</span><br><span class="line">    std::vector&lt;glm::vec4&gt; frustumCorners;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">2</span>; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">2</span>; ++y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> z = <span class="number">0</span>; z &lt; <span class="number">2</span>; ++z)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">const</span> glm::vec4 pt = </span><br><span class="line">                    inv * glm::<span class="built_in">vec4</span>(</span><br><span class="line">                        <span class="number">2.0f</span> * x - <span class="number">1.0f</span>,</span><br><span class="line">                        <span class="number">2.0f</span> * y - <span class="number">1.0f</span>,</span><br><span class="line">                        <span class="number">2.0f</span> * z - <span class="number">1.0f</span>,</span><br><span class="line">                        <span class="number">1.0f</span>);</span><br><span class="line">                frustumCorners.<span class="built_in">push_back</span>(pt / pt.w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> frustumCorners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处描述的投影矩阵是一个透视矩阵，使用相机的纵横比和 fov，并使用正在分析的当前视锥体的近平面和远平面。视图矩阵是我们相机的视图矩阵。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> proj = glm::<span class="built_in">perspective</span>(</span><br><span class="line">    glm::<span class="built_in">radians</span>(camera.Zoom),</span><br><span class="line">    (<span class="type">float</span>)SCR_WIDTH / (<span class="type">float</span>)SCR_HEIGHT,</span><br><span class="line">    nearPlane,</span><br><span class="line">    farPlane</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<img src="/2024/12/04/33-%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/frustum_fitting.png" class="" title="img">

<p>上图由 <a target="_blank" rel="noopener" href="https://ogldev.org/www/tutorial49/tutorial49.html">OGLDev</a> 提供</p>
<h2 id="光照视图投影矩阵"><a href="#光照视图投影矩阵" class="headerlink" title="光照视图投影矩阵"></a>光照视图投影矩阵</h2><p>与普通阴影贴图一样，此矩阵是视图和投影矩阵的乘积。计算视图矩阵很简单，我们知道光线的来源方向，并且我们知道它肯定正在查看世界空间中的一个点：视锥体的中心。视锥体中心的位置可以通过平均视锥体角的坐标来获得。（之所以如此，是因为平均近平面和远平面的坐标会得到这些矩形的中心，而取这两个点的中点会得到视锥体的中心。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 center = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : corners)</span><br><span class="line">&#123;</span><br><span class="line">    center += glm::<span class="built_in">vec3</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">center /= corners.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> lightView = glm::<span class="built_in">lookAt</span>(center + lightDir, center, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>

<p>投影矩阵稍微复杂一些。因为目前讨论的光是定向光，所以需要一个正交投影矩阵。想象我们从光线的角度绘制的场景，我们尝试渲染的阴影贴图将是一个轴对齐的矩形，而这个矩形正如我们之前建立的那样需要适应视锥体。所以我们需要获取这个空间里视锥体的坐标，取沿坐标轴的坐标的最大值和最小值。这种视角正是我们的光照视图矩阵转换为我们提供的，变换 light view 空间中的视锥体角点，并找到最大和最小坐标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> minX = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"><span class="type">float</span> maxX = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">lowest</span>();</span><br><span class="line"><span class="type">float</span> minY = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"><span class="type">float</span> maxY = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">lowest</span>();</span><br><span class="line"><span class="type">float</span> minZ = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"><span class="type">float</span> maxZ = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">lowest</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : corners)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> trf = lightView * v;</span><br><span class="line">    minX = std::<span class="built_in">min</span>(minX, trf.x);</span><br><span class="line">    maxX = std::<span class="built_in">max</span>(maxX, trf.x);</span><br><span class="line">    minY = std::<span class="built_in">min</span>(minY, trf.y);</span><br><span class="line">    maxY = std::<span class="built_in">max</span>(maxY, trf.y);</span><br><span class="line">    minZ = std::<span class="built_in">min</span>(minZ, trf.z);</span><br><span class="line">    maxZ = std::<span class="built_in">max</span>(maxZ, trf.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用两个矩阵的乘积创建投影矩阵。首先，我们将创建一个正交投影矩阵，其中 left、right、top、bottom 参数设置为1或-1，z值设置为minZ和maxZ 。这将创建一个位于原点上的 3D 矩形，其宽度和高度为2，深度为 （maxZ – minZ）。在代码中，我们通过将minZ和maxZ与zMult相乘或除来增加它们所覆盖的空间量。这是因为我们想在摄像机空间中包含位于视锥体后面或前面的几何体。不仅是在视锥体中的几何体可以在视锥体中的表面上投射阴影。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tune this parameter according to the scene</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">float</span> zMult = <span class="number">10.0f</span>;</span><br><span class="line"><span class="keyword">if</span> (minZ &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    minZ *= zMult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    minZ /= zMult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (maxZ &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    maxZ /= zMult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    maxZ *= zMult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> glm::mat4 lightProjection = glm::<span class="built_in">ortho</span>(minX, maxX, minY, maxY, minZ, maxZ);</span><br><span class="line"><span class="keyword">return</span> lightProjection * lightView;</span><br></pre></td></tr></table></figure>

<p>将视图矩阵和投影矩阵相乘，我们得到给定视锥体的光照视图投影矩阵。我们需要对级联中的每个视锥体执行此过程。</p>
<h2 id="2D-数组纹理"><a href="#2D-数组纹理" class="headerlink" title="2D 数组纹理"></a>2D 数组纹理</h2><p>原则上，我们可以执行多少个级联没有限制，因此对任意值进行硬编码似乎不是一个明智的主意。而且，为着色器输入和绑定 sampler2D 会非常的麻烦。OpenGL 用2D 数组纹理的形式很好地解决了这个问题。此对象是具有相同维度的纹理数组。要在着色器中使用它们，需要先声明它们：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2DArray shadowMap;</span><br></pre></td></tr></table></figure>

<p>为了从中采样，我们可以将常规纹理函数与 vec3 参数用于纹理坐标，第三个维度指定要从哪个图层采样，从 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">texture</span>(depthMap, <span class="built_in">vec3</span>(TexCoords, currentLayer))</span><br></pre></td></tr></table></figure>

<p>创建2D数组纹理与创建常规的texture2D略有不同，需要使用 glTexImage3D 而不是 glTexImage3D 来分配内存，当将纹理绑定到帧缓冲区时，使用 glFramebufferTexture 而不是 glFramebufferTexture2D。调用 OpenGL 函数时，我们需要传递GL_TEXTURE_2D_ARRAYGL_TEXTURE_2D而不是作为目标，以告诉 OpenGL 我们正在处理哪种纹理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;lightFBO);</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;lightDepthMaps);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D_ARRAY, lightDepthMaps);</span><br><span class="line"><span class="built_in">glTexImage3D</span>(GL_TEXTURE_2D_ARRAY, <span class="number">0</span>, GL_DEPTH_COMPONENT32F, depthMapResolution, depthMapResolution, <span class="built_in">int</span>(shadowCascadeLevels.<span class="built_in">size</span>()) + <span class="number">1</span>, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">float</span> bordercolor[] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_BORDER_COLOR, bordercolor);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, lightFBO);</span><br><span class="line"><span class="built_in">glFramebufferTexture</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, lightDepthMaps, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glDrawBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glReadBuffer</span>(GL_NONE);</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> status = <span class="built_in">glCheckFramebufferStatus</span>(GL_FRAMEBUFFER);</span><br><span class="line"><span class="keyword">if</span> (status != GL_FRAMEBUFFER_COMPLETE)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::FRAMEBUFFER:: Framebuffer is not complete!&quot;</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>将此纹理绑定到采样器时，需要用GL_TEXTURE_2D_ARRAY作为目标参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D_ARRAY, lightDepthMaps);</span><br></pre></td></tr></table></figure>

<p>现在我们知道了使用 texture 数组的语义。这一切看起来都很简单，但在OpenGL中我们不能以普通方式渲染到这个纹理中，我们需要做一些叫做分层渲染的东西。这个过程与立方体贴图和点光源中所做的非常相似，使用几何着色器同时生成多层几何图形。在顶点阶段将顶点转换为光空间，然后让硬件使用空片段着色器完成其余工作。在新的深度贴图着色器中，我们只会在顶点着色器中执行世界空间变换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">    </span><br><span class="line">uniform mat4 model;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几何着色器将如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">layout</span>(triangles, invocations = <span class="number">5</span>) in;</span><br><span class="line"><span class="built_in">layout</span>(triangle_strip, max_vertices = <span class="number">3</span>) out;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">layout</span> (std140, binding = <span class="number">0</span>) uniform LightSpaceMatrices</span><br><span class="line">&#123;</span><br><span class="line">    mat4 lightSpaceMatrices[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;          </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        gl_Position = </span><br><span class="line">            lightSpaceMatrices[gl_InvocationID] * gl_in[i].gl_Position;</span><br><span class="line">        gl_Layer = gl_InvocationID;</span><br><span class="line">        <span class="built_in">EmitVertex</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>invocations声明一个新成员，用于指定调用计数。这个数字意味着，这个着色器将被实例化，这些实例并行运行，我们可以通过内置变量在着色器代码中使用此数字来指定我们要渲染到数组纹理的哪个层，以及我们将使用哪个阴影矩阵来执行光照空间转换。我们正在迭代所有三角形，并相应地设置gl_Layer和gl_Position。</p>
<p>片段着色器继续保持空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用着色器的 draw 调用如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">simpleDepthShader.<span class="built_in">use</span>();</span><br><span class="line">   </span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, lightFBO);</span><br><span class="line"><span class="built_in">glFramebufferTexture</span>(GL_FRAMEBUFFER, GL_TEXTURE_2D_ARRAY, lightDepthMaps, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, depthMapResolution, depthMapResolution);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">glCullFace</span>(GL_FRONT);</span><br><span class="line"><span class="built_in">renderScene</span>(simpleDepthShader);</span><br><span class="line"><span class="built_in">glCullFace</span>(GL_BACK);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/" class="post-title-link" itemprop="url">32-点阴影</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-03 18:25:21" itemprop="dateCreated datePublished" datetime="2024-12-03T18:25:21+08:00">2024-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-20 12:56:01" itemprop="dateModified" datetime="2024-12-20T12:56:01+08:00">2024-12-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目前为止我们学到了如何使用阴影贴图技术创建动态阴影。效果不错，但它只适合定向光，因为阴影只是在单一定向光源下生成的。所以它也叫定向阴影贴图，深度（阴影）贴图生成自定向光的视角。本节我们的焦点是在各种方向生成动态阴影，这个技术可以适用于点光源，生成所有方向上的阴影。这个技术叫做点光阴影，过去的名字是万向阴影贴图（omnidirectional shadow maps）技术。</p>
<p>本节代码基于前面的阴影贴图教程， 算法和定向阴影贴图差不多：我们从光的透视图生成一个深度贴图，基于当前fragment位置来对深度贴图采样，然后用储存的深度值和每个fragment进行对比，看看它是否在阴影中。定向阴影贴图和万向阴影贴图的主要不同在于深度贴图的使用上。对于深度贴图，我们需要从一个点光源的所有渲染场景，普通2D深度贴图不能工作；如果我们使用立方体贴图会怎样？因为立方体贴图可以储存6个面的环境数据，它可以将整个场景渲染到立方体贴图的每个面上，把它们当作点光源四周的深度值来采样。</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/point_shadows_diagram.png" class="" title="img">

<p>生成后的深度立方体贴图被传递到光照像素着色器，它会用一个方向向量来采样立方体贴图，从而得到当前的fragment的深度（从光的透视图）。大部分复杂的事情已经在阴影贴图教程中讨论过了。算法只是在深度立方体贴图生成上稍微复杂一点。</p>
<h2 id="生成深度立方体贴图"><a href="#生成深度立方体贴图" class="headerlink" title="生成深度立方体贴图"></a>生成深度立方体贴图</h2><p>为创建一个光周围的深度值的立方体贴图，我们必须渲染场景6次：每次一个面。显然渲染场景6次需要6个不同的视图矩阵，每次把一个不同的立方体贴图面附加到帧缓冲对象上。这看起来是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    GLuint face = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i;</span><br><span class="line">    <span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, face, depthCubemap, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">BindViewMatrix</span>(lightViewMatrices[i]);</span><br><span class="line">    <span class="built_in">RenderScene</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会很耗费性能因为一个深度贴图下需要进行很多渲染调用。我们将转而使用另外的一个小技巧来做这件事，几何着色器允许我们使用一次渲染过程来建立深度立方体贴图。</p>
<p>首先，我们需要创建一个立方体贴图：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint depthCubemap;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;depthCubemap);</span><br></pre></td></tr></table></figure>

<p>然后生成立方体贴图的每个面，将它们作为2D深度值纹理图像：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> GLuint SHADOW_WIDTH = <span class="number">1024</span>, SHADOW_HEIGHT = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, depthCubemap);</span><br><span class="line"><span class="keyword">for</span> (GLuint i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, <span class="number">0</span>, GL_DEPTH_COMPONENT, </span><br><span class="line">                     SHADOW_WIDTH, SHADOW_HEIGHT, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>不要忘记设置合适的纹理参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure>

<p>正常情况下，我们把立方体贴图纹理的一个面附加到帧缓冲对象上，渲染场景6次，每次将帧缓冲的深度缓冲目标改成不同立方体贴图面。由于我们将使用一个几何着色器，它允许我们把所有面在一个过程渲染，我们可以使用glFramebufferTexture直接把立方体贴图附加成帧缓冲的深度附件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glFramebufferTexture</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthCubemap, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glDrawBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glReadBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>还要记得调用glDrawBuffer和glReadBuffer：当生成一个深度立方体贴图时我们只关心深度值，所以我们必须显式告诉OpenGL这个帧缓冲对象不会渲染到一个颜色缓冲里。</p>
<p>万向阴影贴图有两个渲染阶段：首先我们生成深度贴图，然后我们正常使用深度贴图渲染，在场景中创建阴影。帧缓冲对象和立方体贴图的处理看起是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. first render to depth cubemap</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. then render scene as normal with shadow mapping (using depth cubemap)</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, depthCubemap);</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>

<p>这个过程和默认的阴影映射一样，尽管这次我们渲染和使用的是一个立方体贴图深度纹理，而不是2D深度纹理。在我们实际开始从光的视角的所有方向渲染场景之前，我们先得计算出合适的变换矩阵。</p>
<h3 id="光空间的变换"><a href="#光空间的变换" class="headerlink" title="光空间的变换"></a>光空间的变换</h3><p>设置了帧缓冲和立方体贴图，我们需要一些方法来将场景的所有几何体变换到6个光的方向中相应的光空间。与阴影贴图教程类似，我们需要一个光空间的变换矩阵T，但是这次是每个面都有一个。每个光空间的变换矩阵包含了投影和视图矩阵。对于投影矩阵来说，我们将使用一个透视投影矩阵；光源代表一个空间中的点，所以透视投影矩阵更有意义。每个光空间变换矩阵使用同样的投影矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLfloat aspect = (GLfloat)SHADOW_WIDTH/(GLfloat)SHADOW_HEIGHT;</span><br><span class="line">GLfloat near = <span class="number">1.0f</span>;</span><br><span class="line">GLfloat far = <span class="number">25.0f</span>;</span><br><span class="line">glm::mat4 shadowProj = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), aspect, near, far);</span><br></pre></td></tr></table></figure>

<p>非常重要的一点是，这里glm::perspective的视野参数，设置为90度。90度我们才能保证视野足够大到可以合适地填满立方体贴图的一个面，立方体贴图的所有面都能与其他面在边缘对齐。</p>
<p>因为投影矩阵在每个方向上并不会改变，我们可以在6个变换矩阵中重复使用。我们要为每个方向提供一个不同的视图矩阵。用glm::lookAt创建6个观察方向，每个都按顺序注视着立方体贴图的的一个方向：右、左、上、下、近、远：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;glm::mat4&gt; shadowTransforms;</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">-1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">-1.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">-1.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>)));</span><br></pre></td></tr></table></figure>

<p>这里我们创建了6个视图矩阵，把它们乘以投影矩阵，来得到6个不同的光空间变换矩阵。glm::lookAt的target参数是它注视的立方体贴图的面的一个方向。这些变换矩阵将会被发送到着色器渲染到立方体贴图里。</p>
<h3 id="深度着色器"><a href="#深度着色器" class="headerlink" title="深度着色器"></a>深度着色器</h3><p>为了把值渲染到深度立方体贴图，我们将需要3个着色器：顶点和像素着色器，以及一个它们之间的几何着色器。几何着色器是负责将所有世界空间的顶点变换到6个不同的光空间的着色器。因此顶点着色器简单地将顶点变换到世界空间，然后直接发送到几何着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = model * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着几何着色器以3个三角形的顶点作为输入，它还有一个光空间变换矩阵的uniform数组。几何着色器接下来会负责将顶点变换到光空间。几何着色器有一个内建变量叫做gl_Layer，它指定发散出基本图形送到立方体贴图的哪个面。当不管它时，几何着色器就会像往常一样把它的基本图形发送到输送管道的下一阶段，但当我们更新这个变量就能控制每个基本图形将渲染到立方体贴图的哪一个面。当然这只有当我们有了一个附加到激活的帧缓冲的立方体贴图纹理才有效：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (triangles) in;</span><br><span class="line"><span class="built_in">layout</span> (triangle_strip, max_vertices=<span class="number">18</span>) out;</span><br><span class="line"></span><br><span class="line">uniform mat4 shadowMatrices[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">out vec4 FragPos; <span class="comment">// FragPos from GS (output per emitvertex)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> face = <span class="number">0</span>; face &lt; <span class="number">6</span>; ++face)</span><br><span class="line">    &#123;</span><br><span class="line">        gl_Layer = face; <span class="comment">// built-in variable that specifies to which face we render.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) <span class="comment">// for each triangle&#x27;s vertices</span></span><br><span class="line">        &#123;</span><br><span class="line">            FragPos = gl_in[i].gl_Position;</span><br><span class="line">            gl_Position = shadowMatrices[face] * FragPos;</span><br><span class="line">            <span class="built_in">EmitVertex</span>();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">EndPrimitive</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几何着色器相对简单。我们输入一个三角形，输出总共6个三角形（6*3顶点，所以总共18个顶点）。在main函数中，我们遍历立方体贴图的6个面，我们每个面指定为一个输出面，把这个面的interger（整数）存到gl_Layer。然后，我们通过把面的光空间变换矩阵乘以FragPos，将每个世界空间顶点变换到相关的光空间，生成每个三角形。注意，我们还要将最后的FragPos变量发送给像素着色器，我们需要计算一个深度值。在之前的教程中，我们使用的是一个空的像素着色器，让OpenGL配置深度贴图的深度值。但这次我们将计算自己的深度，这个深度就是每个fragment位置和光源位置之间的线性距离。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">in vec4 FragPos;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform <span class="type">float</span> far_plane;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get distance between fragment and light source</span></span><br><span class="line">    <span class="type">float</span> lightDistance = <span class="built_in">length</span>(FragPos.xyz - lightPos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map to [0;1] range by dividing by far_plane</span></span><br><span class="line">    lightDistance = lightDistance / far_plane;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write this as modified depth</span></span><br><span class="line">    gl_FragDepth = lightDistance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像素着色器将来自几何着色器的片段位置、光的位置向量和视锥的远平面值作为输入。这里我们把片段和光源之间的距离，映射到0到1的范围，把它写入为fragment的深度值。使用这些着色器渲染场景，立方体贴图附加的帧缓冲对象激活以后，你会得到一个完全填充的深度立方体贴图，以便于进行第二阶段的阴影计算。</p>
<h2 id="万向阴影贴图"><a href="#万向阴影贴图" class="headerlink" title="万向阴影贴图"></a>万向阴影贴图</h2><p>所有事情都做好了，是时候来渲染万向阴影(Omnidirectional Shadow)了。这个过程和定向阴影贴图教程相似，尽管这次我们绑定的深度贴图是一个立方体贴图，而不是2D纹理，并且将光的投影的远平面发送给了着色器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">shader.<span class="built_in">Use</span>();  </span><br><span class="line"><span class="comment">// ... send uniforms to shader (including light&#x27;s far_plane value)</span></span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, depthCubemap);</span><br><span class="line"><span class="comment">// ... bind other textures</span></span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>

<p>这里的renderScene函数在一个大立方体房间中渲染一些立方体，它们散落在大立方体各处，光源在场景中央。顶点着色器和像素着色器和原来的阴影贴图着色器大部分都一样：不同之处是在光空间中像素着色器不再需要一个fragment位置，现在我们可以使用一个方向向量采样深度值。因为这个顶点着色器不再需要将他的位置向量变换到光空间，所以我们可以去掉FragPosLightSpace变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 texCoords;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">    vs_out.FragPos = <span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>));</span><br><span class="line">    vs_out.Normal = <span class="built_in">transpose</span>(<span class="built_in">inverse</span>(<span class="built_in">mat3</span>(model))) * normal;</span><br><span class="line">    vs_out.TexCoords = texCoords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器的Blinn-Phong光照代码和我们之前阴影相乘的结尾部分一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseTexture;</span><br><span class="line">uniform samplerCube depthMap;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line">uniform <span class="type">float</span> far_plane;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(diffuseTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    vec3 lightColor = <span class="built_in">vec3</span>(<span class="number">0.3</span>);</span><br><span class="line">    <span class="comment">// Ambient</span></span><br><span class="line">    vec3 ambient = <span class="number">0.3</span> * color;</span><br><span class="line">    <span class="comment">// Diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    <span class="comment">// Specular</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">64.0</span>);</span><br><span class="line">    vec3 specular = spec * lightColor;    </span><br><span class="line">    <span class="comment">// Calculate shadow</span></span><br><span class="line">    <span class="type">float</span> shadow = <span class="built_in">ShadowCalculation</span>(fs_in.FragPos);                      </span><br><span class="line">    vec3 lighting = (ambient + (<span class="number">1.0</span> - shadow) * (diffuse + specular)) * color;    </span><br><span class="line"></span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(lighting, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一些细微的不同：光照代码一样，但我们现在有了一个uniform变量samplerCube，shadowCalculation函数用片段的位置作为它的参数，取代了光空间的片段位置。我们现在还要引入光的视锥的远平面值，后面我们会需要它。像素着色器的最后，我们计算出阴影元素，当片段在阴影中时它是1.0，不在阴影中时是0.0。我们使用计算出来的阴影元素去影响光照的diffuse和specular元素。在ShadowCalculation函数中有很多不同之处，现在是从立方体贴图中进行采样，不再使用2D纹理了。</p>
<p>我们需要做的第一件事是获取立方体贴图的深度。我们已经将深度储存为片段和光位置之间的距离了，所以我们这里采用相似的处理方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 fragToLight = fragPos - lightPos; </span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight).r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们得到了片段的位置与光的位置之间的差向量，使用这个向量作为一个方向向量去对立方体贴图进行采样。方向向量不需要是单位向量，所以无需对它进行标准化。最后的closestDepth是光源和它最接近的可见片段之间的标准化的深度值。closestDepth值现在在0到1的范围内了，所以我们先将其转换回0到far_plane的范围，这需要把他乘以far_plane：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closestDepth *= far_plane;</span><br></pre></td></tr></table></figure>

<p>下一步我们获取当前fragment和光源之间的深度值，我们可以简单的使用fragToLight的长度来获取它，这取决于我们如何计算立方体贴图中的深度值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> currentDepth = <span class="built_in">length</span>(fragToLight);</span><br></pre></td></tr></table></figure>

<p>返回的是和closestDepth范围相同的深度值。</p>
<p>现在我们可以将两个深度值对比一下，看看哪一个更接近，以此决定当前的fragment是否在阴影当中。我们还要包含一个阴影偏移，才能避免阴影失真：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="number">0.05</span>; </span><br><span class="line"><span class="type">float</span> shadow = currentDepth -  bias &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>现在完整的ShadowCalculation现在变成了这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get vector between fragment position and light position</span></span><br><span class="line">    vec3 fragToLight = fragPos - lightPos;</span><br><span class="line">    <span class="comment">// Use the light to fragment vector to sample from the depth map    </span></span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight).r;</span><br><span class="line">    <span class="comment">// It is currently in linear range between [0,1]. Re-transform back to original value</span></span><br><span class="line">    closestDepth *= far_plane;</span><br><span class="line">    <span class="comment">// Now get current linear depth as the length between the fragment and light position</span></span><br><span class="line">    <span class="type">float</span> currentDepth = <span class="built_in">length</span>(fragToLight);</span><br><span class="line">    <span class="comment">// Now test for shadows</span></span><br><span class="line">    <span class="type">float</span> bias = <span class="number">0.05</span>; </span><br><span class="line">    <span class="type">float</span> shadow = currentDepth -  bias &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这些着色器，我们已经能得到非常好的阴影效果了，这次从一个点光源所有周围方向上都有阴影。有一个位于场景中心的点光源，看起来会像这样：</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/image-20241204122230684.png" class="" title="image-20241204122230684">

<p>在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/point_shadow.rar">这里</a>可以获取程序的完整代码</p>
<h3 id="显示立方体贴图深度缓冲"><a href="#显示立方体贴图深度缓冲" class="headerlink" title="显示立方体贴图深度缓冲"></a>显示立方体贴图深度缓冲</h3><p>如果要进行调试排错，将深度贴图显示出来以检查其是否正确。因为我们不再用2D深度贴图纹理，一个简单的把深度缓冲显示出来的技巧是，在ShadowCalculation函数中计算标准化的closestDepth变量，把变量显示，修改片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseTexture;</span><br><span class="line">uniform samplerCube depthMap;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line">uniform <span class="type">float</span> far_plane;</span><br><span class="line">uniform <span class="type">bool</span> shadows;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 fragToLight = fragPos - lightPos;</span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight).r;</span><br><span class="line">    closestDepth *= far_plane; </span><br><span class="line">    <span class="type">float</span> currentDepth = <span class="built_in">length</span>(fragToLight);</span><br><span class="line">    <span class="type">float</span> bias = <span class="number">0.05</span>;</span><br><span class="line">    <span class="type">float</span> shadow = currentDepth -  bias &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(diffuseTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    vec3 lightColor = <span class="built_in">vec3</span>(<span class="number">0.3</span>);</span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    vec3 ambient = <span class="number">0.3</span> * lightColor;</span><br><span class="line">    <span class="comment">// diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">64.0</span>);</span><br><span class="line">    vec3 specular = spec * lightColor;    </span><br><span class="line">    <span class="comment">// calculate shadow</span></span><br><span class="line">    <span class="comment">// float shadow = shadows ? ShadowCalculation(fs_in.FragPos) : 0.0;                      </span></span><br><span class="line">    <span class="comment">// vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;</span></span><br><span class="line">    vec3 fragToLight = fs_in.FragPos - lightPos;</span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight).r;</span><br><span class="line">    closestDepth *= far_plane; </span><br><span class="line">    </span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(<span class="built_in">vec3</span>(closestDepth / far_plane), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是一个灰度场景，每个颜色代表着场景的线性深度值：</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/image-20241204123534486.png" class="" title="image-20241204123534486">

<p>你可能也注意到了阴影部分在墙外。如果看起来和这个差不多，你就知道深度立方体贴图生成的没错。否则你可能做错了什么，也许是closestDepth仍然还在0到far_plane的范围。</p>
<h2 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h2><p>由于万向阴影贴图基于传统阴影贴图的原则，它便也继承了由解析度产生的非真实感。如果你放大就会看到锯齿边了。PCF（Percentage-closer filtering）允许我们通过对片段位置周围过滤多个样本，并对结果平均化。如果我们用和之前教程同样的那个简单的PCF过滤器，并加入第三个维度，就是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> bias = <span class="number">0.05</span>; </span><br><span class="line"><span class="type">float</span> samples = <span class="number">4.0</span>;</span><br><span class="line"><span class="type">float</span> offset = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">float</span> x = -offset; x &lt; offset; x += offset / (samples * <span class="number">0.5</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">float</span> y = -offset; y &lt; offset; y += offset / (samples * <span class="number">0.5</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">float</span> z = -offset; z &lt; offset; z += offset / (samples * <span class="number">0.5</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight + <span class="built_in">vec3</span>(x, y, z)).r; </span><br><span class="line">            closestDepth *= far_plane;   <span class="comment">// Undo mapping [0;1]</span></span><br><span class="line">            <span class="keyword">if</span>(currentDepth - bias &gt; closestDepth)</span><br><span class="line">                shadow += <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">shadow /= (samples * samples * samples);</span><br></pre></td></tr></table></figure>

<p>这段代码和我们传统的阴影贴图没有多少不同。这里我们根据样本的数量动态计算了纹理偏移量，我们在三个轴向采样三次，最后对子样本进行平均化。现在阴影看起来更加柔和平滑了，由此得到更加真实的效果：</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/image-20241204124224499.png" class="" title="image-20241204124224499">

<p>当samples设置为4.0，每个fragment我们会得到总共64个样本，这太多了！大多数这些采样都是多余的，与其在原始方向向量附近处采样，不如在采样方向向量的垂直方向进行采样更有意义。可是，并没有什么简单的方式能够指出哪一个子方向是多余的。可以使用一个技巧，用一个偏移量方向数组，它们差不多都是分开的，每一个指向完全不同的方向，剔除彼此接近的那些子方向。下面就是一个有着20个偏移方向的数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vec3 sampleOffsetDirections[<span class="number">20</span>] = vec3[]</span><br><span class="line">(</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">1</span>), </span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>, <span class="number">-1</span>),</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">0</span>), <span class="built_in">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">0</span>),</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">0</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">0</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">0</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>( <span class="number">0</span>,  <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>然后我们把PCF算法与从sampleOffsetDirections得到的样本数量进行适配，使用它们从立方体贴图里采样。这么做的好处是与之前的PCF算法相比，我们需要的样本数量变少了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 fragToLight = fragPos - lightPos;</span><br><span class="line">    <span class="type">float</span> currentDepth = <span class="built_in">length</span>(fragToLight);</span><br><span class="line">    <span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">float</span> bias = <span class="number">0.15</span>;</span><br><span class="line">    <span class="type">int</span> samples = <span class="number">20</span>;</span><br><span class="line">    <span class="type">float</span> viewDistance = <span class="built_in">length</span>(viewPos - fragPos);</span><br><span class="line">    <span class="type">float</span> diskRadius = (<span class="number">1.0</span> + (viewDistance / far_plane)) / <span class="number">25.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; samples; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;</span><br><span class="line">        closestDepth *= far_plane;</span><br><span class="line">        <span class="keyword">if</span>(currentDepth - bias &gt; closestDepth)</span><br><span class="line">            shadow += <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    shadow /= <span class="built_in">float</span>(samples);  </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们把一个偏移量添加到指定的diskRadius中，它在fragToLight方向向量周围从立方体贴图里采样。另一个在这里可以应用的有意思的技巧是，我们可以基于观察者里一个fragment的距离来改变diskRadius；这样我们就能根据观察者的距离来增加偏移半径了，当距离更远的时候阴影更柔和，更近了就更锐利。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> diskRadius = (<span class="number">1.0</span> + (viewDistance / far_plane)) / <span class="number">25.0</span>;</span><br></pre></td></tr></table></figure>

<p>这是柔和的阴影效果：</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/image-20241217153523483.png" class="" title="image-20241217153523483">

<p>当然了，我们添加到每个样本的bias（偏移）高度依赖于上下文，总是要根据场景进行微调的。试试这些值，看看怎样影响了场景。<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/point_shadow_soft.rar">这里</a>是最终的完整代码。</p>
<p>使用几何着色器来生成深度贴图不一定会比每个面渲染场景6次更快。使用几何着色器有它自己的性能局限，在第一个阶段使用它可能获得更好的性能表现。这取决于环境的类型，以及特定的显卡驱动等等，如果你很关心性能，就要确保对两种方法有大致了解，然后选择对你场景来说更高效的那个。使用几何着色器来进行阴影贴图的绘制的原因很简单，因为它们使用起来更简单。</p>
<h2 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a>附加资源</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.sunandblackcat.com/tipFullView.php?l=eng&topicid=36">Shadow Mapping for point light sources in OpenGL</a>：sunandblackcat的万向阴影贴图教程。</li>
<li><a target="_blank" rel="noopener" href="http://ogldev.atspace.co.uk/www/tutorial43/tutorial43.html">Multipass Shadow Mapping With Point Lights</a>：ogldev的万向阴影贴图教程。</li>
<li><a target="_blank" rel="noopener" href="http://www.cg.tuwien.ac.at/~husky/RTR/OmnidirShadows-whyCaps.pdf">Omni-directional Shadows</a>：Peter Houska的关于万向阴影贴图的一组很好的ppt。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/" class="post-title-link" itemprop="url">31-阴影贴图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-14 20:45:41" itemprop="dateCreated datePublished" datetime="2024-10-14T20:45:41+08:00">2024-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-03 17:52:25" itemprop="dateModified" datetime="2024-12-03T17:52:25+08:00">2024-12-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>阴影是光线被阻挡的结果；当一个光源的光线由于其他物体的阻挡不能够达到一个物体的表面的时候，那么这个物体就处在阴影中了。阴影能够使场景看起来真实得多，并且可以让观察者获得物体之间的空间位置关系，场景和物体的深度感能够得到极大提升。</p>
<p>阴影还是比较不好实现的，因为当前实时渲染领域还没找到一种完美的阴影算法。目前有几种近似阴影技术，但它们都有自己的缺点和不足，这是我们必须要考虑到的。视频游戏中较多使用的一种技术是阴影贴图（shadow mapping），效果不错，而且相对容易实现。阴影贴图并不难以理解，性能也不会太低，而且非常容易扩展成更高级的算法。</p>
<h2 id="阴影贴图"><a href="#阴影贴图" class="headerlink" title="阴影贴图"></a>阴影贴图</h2><p>阴影映射(Shadow Mapping)背后的思路非常简单：我们以光的位置为视角进行渲染，我们能看到的东西都将被点亮，看不见的一定是在阴影之中了。假设有一个地板，在光源和它之间有一个大盒子。由于光源处向光线方向看去，可以看到这个盒子，但看不到地板的一部分，这部分就应该在阴影中了。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_theory.png" class="" title="img">

<p>这里的所有蓝线代表光源可以看到的fragment。黑线代表被遮挡的fragment：它们应该渲染为带阴影的。如果我们绘制一条从光源出发，到达最右边盒子上的一个片段上的线段或射线，那么射线将先击中悬浮的盒子，随后才会到达最右侧的盒子。结果就是悬浮的盒子被照亮，而最右侧的盒子将处于阴影之中。</p>
<p>我们希望得到射线第一次击中的那个物体，然后用这个最近点和射线上其他点进行对比。然后我们将测试一下看看射线上的其他点是否比最近点更远，如果是的话，这个点就在阴影中。对从光源发出的射线上的成千上万个点进行遍历是个极端消耗性能的举措，实时渲染上基本不可取。我们可以采取相似举措，不用投射出光的射线，使用另一个非常熟悉的东西：深度缓冲。</p>
<p>在深度缓冲里的一个值是摄像机视角下，对应于一个片段的一个0到1之间的深度值。如果我们从光源的透视图来渲染场景，并把深度值的结果储存到纹理中。通过这种方式，我们就能对光源的透视图所见的最近的深度值进行采样。最终，深度值就会显示从光源的透视图下见到的第一个片段了。我们把储存在纹理中的所有这些深度值，叫做深度贴图（depth map）或阴影贴图。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_theory_spaces.png" class="" title="img">

<p>左侧的图片展示了一个定向光源（所有光线都是平行的）在立方体下的表面投射的阴影。通过储存到深度贴图中的深度值，我们就能找到最近点，用以决定片段是否在阴影中。我们使用一个来自光源的视图和投影矩阵来渲染场景就能创建一个深度贴图。这个投影和视图矩阵结合在一起成为一个<em><strong>T</strong></em>变换，它可以将任何三维位置转变到光源的可见坐标空间。</p>
<p><em>定向光并没有位置，因为它被规定为无穷远。然而，为了实现阴影贴图，我们得从一个光的透视图渲染场景，这样就得在光的方向的某一点上渲染场景。</em></p>
<p>在右边的图中我们显示出同样的平行光和观察者。我们渲染一个点P处的片段，需要决定它是否在阴影中。我们先得使用<em><strong>T</strong></em>把P变换到光源的坐标空间里。既然点P是从光的透视图中看到的，它的z坐标就对应于它的深度，例子中这个值是0.9。使用点P在光源的坐标空间的坐标，我们可以索引深度贴图，来获得从光的视角中最近的可见深度，结果是点C，最近的深度是0.4。因为索引深度贴图的结果是一个小于点P的深度，我们可以断定P被挡住了，它在阴影中了。</p>
<p>阴影映射由两个步骤组成：首先，我们渲染深度贴图，然后我们像往常一样渲染场景，使用生成的深度贴图来计算片段是否在阴影之中。</p>
<h3 id="深度贴图"><a href="#深度贴图" class="headerlink" title="深度贴图"></a>深度贴图</h3><p>第一步我们需要生成一张深度贴图(Depth Map)。深度贴图是从光的透视图里渲染的深度纹理，用它计算阴影。因为我们需要将场景的渲染结果储存到一个纹理中，所以我们需要再次用到帧缓冲。</p>
<p>首先，为渲染的深度贴图创建一个帧缓冲对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint depthMapFBO;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;depthMapFBO);</span><br></pre></td></tr></table></figure>

<p>然后，创建一个2D纹理，提供给帧缓冲的深度缓冲使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> GLuint SHADOW_WIDTH = <span class="number">1024</span>, SHADOW_HEIGHT = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">GLuint depthMap;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;depthMap);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, depthMap);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT, </span><br><span class="line">             SHADOW_WIDTH, SHADOW_HEIGHT, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br></pre></td></tr></table></figure>

<p>生成深度贴图不会太复杂。因为只关心深度值，所以把纹理格式指定为GL_DEPTH_COMPONENT，并且把纹理的高宽设置为1024：深度贴图的分辨率。把生成的深度纹理作为帧缓冲的深度缓冲：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glDrawBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glReadBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>我们需要的只是在从光的透视图下渲染场景的时候深度信息，所以颜色缓冲没有用。但是，不包含颜色缓冲的帧缓冲对象是不完整的，所以需要告诉OpenGL不适用任何颜色数据进行渲染。将调用glDrawBuffer和glReadBuffer把读和绘制缓冲设置为GL_NONE。合理配置将深度值渲染到纹理的帧缓冲后，就可以开始第一步了：生成深度贴图。两个步骤的完整的渲染阶段，看起来有点像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首选渲染深度贴图</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. 像之前一样渲染场景，但这次使用深度贴图</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, depthMap);</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>

<p>这段代码隐去了一些细节，但它表达了阴影映射的基本思路。这里一定要记得调用glViewport。因为阴影贴图经常和原来渲染的场景（通常是窗口分辨率）有着不同的分辨率，需要改变视口（viewport）的参数以适应阴影贴图的尺寸。如果我们忘了更新视口参数，最后的深度贴图要么太小要么就不完整。</p>
<h4 id="光源空间的变换"><a href="#光源空间的变换" class="headerlink" title="光源空间的变换"></a>光源空间的变换</h4><p>前面那段代码中一个不清楚的函数是<code>ConfigureShaderAndMatrices</code>。它是用来在第二个步骤确保为每个物体设置了合适的投影和视图矩阵，以及相关的模型矩阵。然而，第一个步骤中，我们从光的位置的视野下使用了不同的投影和视图矩阵来渲染的场景。</p>
<p>因为我们使用的是一个所有光线都平行的定向光。出于这个原因，我们将为光源使用正交投影矩阵，透视图将没有任何变形：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLfloat near_plane = <span class="number">1.0f</span>, far_plane = <span class="number">7.5f</span>;</span><br><span class="line">glm::mat4 lightProjection = glm::<span class="built_in">ortho</span>(<span class="number">-10.0f</span>, <span class="number">10.0f</span>, <span class="number">-10.0f</span>, <span class="number">10.0f</span>, near_plane, far_plane);</span><br></pre></td></tr></table></figure>

<p>这里有个本节教程的demo场景中使用的正交投影矩阵的例子。因为投影矩阵间接决定可视区域的范围，以及哪些东西不会被裁切，你需要保证投影视锥（frustum）的大小，以包含打算在深度贴图中包含的物体。当物体和片段不在深度贴图中时，它们就不会产生阴影。</p>
<p>为了创建一个视图矩阵来变换每个物体，把它们变换到从光源视角可见的空间中，我们将使用glm::lookAt函数；这次从光源的位置看向场景中央。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 lightView = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(<span class="number">-2.0f</span>, <span class="number">4.0f</span>, <span class="number">-1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>

<p>二者相结合为我们提供了一个光空间的变换矩阵，它将每个世界空间坐标变换到光源处所见到的那个空间；这正是我们渲染深度贴图所需要的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 lightSpaceMatrix = lightProjection * lightView;</span><br></pre></td></tr></table></figure>

<p>这个lightSpaceMatrix正是前面我们称为TT的那个变换矩阵。有了lightSpaceMatrix只要给shader提供光空间的投影和视图矩阵，我们就能像往常那样渲染场景了。然而，我们只关心深度值，并非所有片段计算都在我们的着色器中进行。为了提升性能，我们将使用一个与之不同但更为简单的着色器来渲染出深度贴图。</p>
<h4 id="渲染至深度贴图"><a href="#渲染至深度贴图" class="headerlink" title="渲染至深度贴图"></a>渲染至深度贴图</h4><p>当我们以光的透视图进行场景渲染的时候，会用一个比较简单的着色器，这个着色器把顶点变换到光空间。这个简单的着色器叫做<code>simpleDepthShader</code>，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line">uniform mat4 lightSpaceMatrix;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = lightSpaceMatrix * model * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个顶点着色器将一个单独模型的一个顶点，使用lightSpaceMatrix变换到光空间中。由于我们没有颜色缓冲，最后的片段不需要任何处理，所以我们可以简单地使用一个空的片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="comment">// gl_FragDepth = gl_FragCoord.z;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个空的片段着色器什么也不干，运行完后，深度缓冲会被更新。可以取消那行的注释，来显式设置深度，但是这个（指注释掉那行之后）是更有效率的，因为底层无论如何都会默认去设置深度缓冲。渲染深度缓冲现在成了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">simpleDepthShader.<span class="built_in">Use</span>();</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(lightSpaceMatrixLocation, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(lightSpaceMatrix));</span><br><span class="line"></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">RenderScene</span>(simpleDepthShader);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>RenderScene函数的参数是一个着色器程序（shader program），它调用所有相关的绘制函数，并在需要的地方设置相应的模型矩阵。最后，在光的透视图视角下，很完美地用每个可见片段的最近深度填充了深度缓冲。通过将这个纹理投射到一个2D四边形上，就能在屏幕上显示出来，运行结果如下：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241118124001483.png" class="" title="image-20241118124001483">将深度贴图渲染到四边形上的片段着色器：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 color;</span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D depthMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="type">float</span> depthValue = <span class="built_in">texture</span>(depthMap, TexCoords).r;</span><br><span class="line">    color = <span class="built_in">vec4</span>(<span class="built_in">vec3</span>(depthValue), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是当用透视投影矩阵取代正交投影矩阵来显示深度时，有一些轻微的改动，因为使用透视投影时，深度是非线性的。</p>
<p>你可以在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/ec9d678b2e57eb1b487568cadc2bd46d4b8b2be3/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/41_shadow_mapping_depth.rar">这里</a>获得把场景渲染成深度贴图的源码。</p>
<h2 id="渲染阴影"><a href="#渲染阴影" class="headerlink" title="渲染阴影"></a>渲染阴影</h2><p>当正确地生成深度贴图后，我们就可以开始渲染阴影了。下面这段代码在片段着色器中执行，用来检验一个片段是否在阴影之中，不过我们在顶点着色器中进行光空间的变换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 texCoords;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec4 FragPosLightSpace;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 lightSpaceMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">    vs_out.FragPos = <span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>));</span><br><span class="line">    vs_out.Normal = <span class="built_in">transpose</span>(<span class="built_in">inverse</span>(<span class="built_in">mat3</span>(model))) * normal;</span><br><span class="line">    vs_out.TexCoords = texCoords;</span><br><span class="line">    vs_out.FragPosLightSpace = lightSpaceMatrix * <span class="built_in">vec4</span>(vs_out.FragPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加了一个新的输出向量FragPosLightSpace，用同一个lightSpaceMatrix，把世界空间顶点位置转换为光空间。顶点着色器传递一个普通的经变换的世界空间顶点位置vs_out.FragPos和一个光空间的vs_out.FragPosLightSpace给片段着色器。</p>
<p>片段着色器使用Blinn-Phong光照模型渲染场景。接着计算出一个shadow值，当fragment在阴影中时是1.0，在阴影外是0.0。然后，diffuse和specular颜色会乘以这个阴影元素。由于阴影不会是全黑的，所以我们把ambient分量从乘法中剔除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec4 FragPosLightSpace;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseTexture;</span><br><span class="line">uniform sampler2D shadowMap;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(diffuseTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    vec3 lightColor = <span class="built_in">vec3</span>(<span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// Ambient</span></span><br><span class="line">    vec3 ambient = <span class="number">0.15</span> * color;</span><br><span class="line">    <span class="comment">// Diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    <span class="comment">// Specular</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">64.0</span>);</span><br><span class="line">    vec3 specular = spec * lightColor;    </span><br><span class="line">    <span class="comment">// 计算阴影</span></span><br><span class="line">    <span class="type">float</span> shadow = <span class="built_in">ShadowCalculation</span>(fs_in.FragPosLightSpace);       </span><br><span class="line">    vec3 lighting = (ambient + (<span class="number">1.0</span> - shadow) * (diffuse + specular)) * color;    </span><br><span class="line"></span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(lighting, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器大部分是从高级光照教程中复制过来，只不过加上了个阴影计算。我们声明一个shadowCalculation函数，用它计算阴影。片段着色器的最后，我们把diffuse和specular乘以(1-阴影元素)，这表示这个片段有多大成分不在阴影中。这个片段着色器还需要两个额外输入，一个是光空间的片段位置和第一个渲染阶段得到的深度贴图。</p>
<p>首先要检查一个片段是否在阴影中，把光空间片段位置转换为裁切空间的标准化设备坐标。当我们在顶点着色器输出一个裁切空间顶点位置到gl_Position时，OpenGL自动进行一个透视除法，将裁切空间坐标的范围-w到w转为-1到1，这将x、y、z元素除以向量的w元素来实现。由于裁切空间的FragPosLightSpace并不会通过gl_Position传到片段着色器里，我们必须自己做透视除法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行透视除法</span></span><br><span class="line">    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数返回了片段在光空间的-1到1的范围。</p>
<p>当使用正交投影矩阵，顶点w元素仍保持不变，所以这一步实际上毫无意义。可是，当使用透视投影的时候就是必须的了，所以为了保证在两种投影矩阵下都有效就得留着这行代码。</p>
<p>因为来自深度贴图的深度在0到1的范围，我们也打算使用projCoords从深度贴图中去采样，所以将NDC坐标变换为0到1的范围。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<p>有了投影坐标，就能从深度贴图中采样得到0到1的结果，从第一个渲染阶段的projCoords坐标直接对应于变换过的NDC坐标。我们将得到光的位置视野下最近的深度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> closestDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy).r;</span><br></pre></td></tr></table></figure>

<p>为了得到片段的当前深度，获取投影向量的z坐标，它等于来自光的透视视角的片段的深度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> currentDepth = projCoords.z;</span><br></pre></td></tr></table></figure>

<p>实际的对比就是简单检查currentDepth是否高于closetDepth，如果是，那么片段就在阴影中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>完整的shadowCalculation函数是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行透视除法</span></span><br><span class="line">    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    <span class="comment">// 变换到[0,1]的范围</span></span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)</span></span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy).r; </span><br><span class="line">    <span class="comment">// 取得当前片段在光源视角下的深度</span></span><br><span class="line">    <span class="type">float</span> currentDepth = projCoords.z;</span><br><span class="line">    <span class="comment">// 检查当前片段是否在阴影中</span></span><br><span class="line">    <span class="type">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>激活这个着色器，绑定合适的纹理，激活第二个渲染阶段默认的投影以及视图矩阵，结果如下图所示：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241129162924357.png" class="" title="image-20241129162924357">

<p>如上图所示，你会看到地板和上有立方体的阴影。可以从<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/ec9d678b2e57eb1b487568cadc2bd46d4b8b2be3/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/42_render_shadow.rar">这里</a>找到demo程序的代码。</p>
<h2 id="改进阴影贴图"><a href="#改进阴影贴图" class="headerlink" title="改进阴影贴图"></a>改进阴影贴图</h2><p>我们现在成功让阴影贴图工作了，但是阴影贴图还是不够真实，接下来我们要尝试修复它。</p>
<h3 id="阴影失真"><a href="#阴影失真" class="headerlink" title="阴影失真"></a>阴影失真</h3><p>目前我们绘制的场景明显有不对的地方，放大看会发现明显的线条样式：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203153007456.png" class="" title="image-20241203153007456">

<p>我们可以看到地板四边形渲染出很大一块交替黑线。这种阴影贴图的不真实感叫做<strong>阴影失真</strong>(Shadow Acne)，下图解释了成因：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_acne_diagram.png" class="" title="img">

<p>因为阴影贴图受限于分辨率，在距离光源比较远的情况下，多个片段可能从深度贴图的同一个值中去采样。图片每个斜坡代表深度贴图一个单独的纹理像素。你可以看到，多个片段从同一个深度值进行采样。虽然很多时候没问题，但是当光源以一个角度朝向表面的时候就会出问题，这种情况下深度贴图也是从一个角度下进行渲染的。多个片段就会从同一个斜坡的深度纹理像素中采样，有些在地板上面，有些在地板下面；这样我们所得到的阴影就有了差异。因为这个，有些片段被认为是在阴影之中，有些不在，由此产生了图片中的条纹样式。</p>
<p>我们可以用一个叫做<strong>阴影偏移</strong>（shadow bias）的技巧来解决这个问题，我们简单的对表面的深度（或深度贴图）应用一个偏移量，这样片段就不会被错误地认为在表面之下了。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_acne_bias.png" class="" title="img">

<p>使用了偏移量后，所有采样点都获得了比表面深度更小的深度值，这样整个表面就正确地被照亮，没有任何阴影。在阴影贴图的片段着色器中可以使用下面的代码实现偏移：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="number">0.005</span>;</span><br><span class="line"><span class="type">float</span> shadow = currentDepth - bias &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>一个0.005的偏移就能有效解决这个问题，但是有些表面坡度很大，仍然会产生阴影失真。有一个更加可靠的办法能够根据表面朝向光线的角度更改偏移量，即使用点乘：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="built_in">max</span>(<span class="number">0.05</span> * (<span class="number">1.0</span> - <span class="built_in">dot</span>(normal, lightDir)), <span class="number">0.005</span>);</span><br><span class="line"><span class="type">float</span> shadow = currentDepth - bias &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>这里我们有一个偏移量的最大值0.05，和一个最小值0.005，它们是基于表面法线和光照方向的。这样像地板这样的表面几乎与光源垂直，得到的偏移就很小，而比如立方体的侧面这种表面得到的偏移就更大。下图展示了同一个场景，但使用了阴影偏移，效果的确更好：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203154054133.png" class="" title="image-20241203154054133">

<p>使用正确的偏移数值，在不同的场景中需要一些像这样的轻微调校，但大多情况下，实际上就是增加偏移量直到所有失真都被消除。</p>
<h3 id="悬浮"><a href="#悬浮" class="headerlink" title="悬浮"></a>悬浮</h3><p>使用阴影偏移的一个缺点是你对物体的实际深度应用了平移。偏移有可能足够大，以至于可以看出阴影相对实际物体位置的偏移，你可以从下图看到这个现象（这是一个夸张的偏移值）：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203154400331.png" class="" title="image-20241203154400331">

<p>这个阴影失真叫做悬浮(Peter Panning)，因为物体看起来悬浮在表面之上。我们可以使用一个叫技巧解决大部分的悬浮问题：当渲染深度贴图时候使用正面剔除，你也许记得在面剔除教程中OpenGL默认是背面剔除。但是现在我们要告诉OpenGL我们要剔除正面。</p>
<p>因为我们只需要深度贴图的深度值，对于实体物体无论我们用它们的正面还是背面都没问题。使用背面深度不会有错误，因为阴影在物体内部有错误我们也看不见。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_culling.png" class="" title="img">

<p>为了修复悬浮，我们要进行正面剔除，先必须开启GL_CULL_FACE：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glCullFace</span>(GL_FRONT);</span><br><span class="line"><span class="built_in">RenderSceneToDepthMap</span>();</span><br><span class="line"><span class="built_in">glCullFace</span>(GL_BACK); <span class="comment">// 不要忘记设回原先的culling face</span></span><br></pre></td></tr></table></figure>

<p>这十分有效地解决了悬浮的问题，但只对封闭的实体物体有效。在现在的场景中，在立方体上工作的很好，但在地板上无效，因为正面剔除完全移除了地板。地面是一个单独的平面，不会被完全剔除。如果打算使用这个技巧解决悬浮必须考虑到，只有剔除物体的正面才有意义。另一个要考虑到的地方是接近阴影的物体仍然会出现不正确的效果。必须考虑到何时使用正面剔除对物体才有意义。不过使用普通的偏移值通常就能避免悬浮。</p>
<h3 id="采样过多"><a href="#采样过多" class="headerlink" title="采样过多"></a>采样过多</h3><p>还有一个视觉差异，就是光的视锥不可见的区域一律被认为是处于阴影中，不管它是否真的处于阴影之中。出现这个状况是因为超出光的视锥的投影坐标比1.0大，这样采样的深度纹理就会超出他默认的0到1的范围。根据纹理环绕方式，我们将会得到不正确的深度结果，它不是基于真实的来自光源的深度值。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203164257058.png" class="" title="image-20241203164257058">

<p>可以在图中看到，光照有一个区域，超出该区域的就成为了阴影；这个区域实际上代表着深度贴图的大小，这个贴图投影到了地板上。发生这种情况的原因是，之前将深度贴图的环绕方式设置成了GL_REPEAT。我们宁可让所有超出深度贴图的坐标的深度范围是1.0，这样超出的坐标将永远不在阴影之中。我们可以储存一个边框颜色，然后把深度贴图的纹理环绕选项设置为GL_CLAMP_TO_BORDER：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">GLfloat borderColor[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line"><span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure>

<p>现在如果我们采样深度贴图0到1坐标范围以外的区域，纹理函数总会返回一个1.0的深度值，阴影值为0.0。现在仍有一部分是黑暗区域，那里的坐标超出了光的正交视锥的远平面。可以看到这片黑色区域总是出现在光源视锥的极远处。当一个点比光的远平面还要远时，它的投影坐标的z坐标大于1.0。这种情况下，GL_CLAMP_TO_BORDER环绕方式不起作用，因为把坐标的z元素和深度贴图的值进行了对比，它总是为大于1.0的z返回true。</p>
<p>解决这个问题也很简单，只要投影向量的z坐标大于1.0，我们就把shadow的值强制设为0.0，修改阴影贴图的片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="keyword">if</span>(projCoords.z &gt; <span class="number">1.0</span>)</span><br><span class="line">        shadow = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查远平面，并将深度贴图限制为一个手工指定的边界颜色，就能解决深度贴图采样超出的问题，最终会得到下图所示的效果：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203165556309.png" class="" title="image-20241203165556309">

<p>这些结果意味着，只有在深度贴图范围以内的被投影的fragment坐标才有阴影，所以任何超出范围的都将会没有阴影。由于在游戏中通常这只发生在远处，所以会比之前的那个明显的黑色区域效果更真实。</p>
<h2 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h2><p>阴影现在已经被绘制到场景中了，不过这仍不是我们想要的。如果你放大看阴影，阴影贴图对分辨率的依赖很快变得很明显。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203165704357.png" class="" title="image-20241203165704357">

<p>因为深度贴图有一个固定的分辨率，多个片段对应于一个纹理像素。结果就是多个片段会从深度贴图的同一个深度值进行采样，这几个片段便得到的是同一个阴影，这就会导致产生锯齿。可以通过增加深度贴图的分辨率的方式来降低锯齿块，也可以尝试尽可能的让光的视锥接近场景。</p>
<p>另一个解决方案叫做PCF（percentage-closer filtering），这是一种多个不同过滤方式的组合，它产生柔和阴影，使它们出现更少的锯齿块和硬边。核心思想是从深度贴图中多次采样，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，就得到了柔和阴影。</p>
<p>一个简单的PCF的实现是简单的从纹理像素四周对深度贴图采样，然后把结果平均起来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line">vec2 texelSize = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(shadowMap, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-1</span>; x &lt;= <span class="number">1</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-1</span>; y &lt;= <span class="number">1</span>; ++y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> pcfDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy + <span class="built_in">vec2</span>(x, y) * texelSize).r; </span><br><span class="line">        shadow += currentDepth - bias &gt; pcfDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">shadow /= <span class="number">9.0</span>;</span><br></pre></td></tr></table></figure>

<p>textureSize返回vec2类型的采样器纹理的0级mipmap的宽和高。用1除以它返回一个单独纹理像素的大小，我们用以对纹理坐标进行偏移，确保每个新样本，来自不同的深度值。这里采样得到9个值，它们在投影坐标的x和y值的周围，为阴影阻挡进行测试，并最终通过样本的总数目将结果平均化。使用更多的样本，更改texelSize变量，你就可以增加阴影的柔和程度。下面你可以看到应用了PCF的阴影：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203171805737.png" class="" title="image-20241203171805737">

<p>从稍微远一点的距离看去，阴影效果好多了，也不那么生硬了。如果你放大，仍会看到阴影贴图分辨率的不真实感，但通常对于大多数应用来说效果已经很好了。实际上PCF还有更多的内容，以及很多技术要点需要考虑以提升柔和阴影的效果，我们将留在以后讨论。</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/ec9d678b2e57eb1b487568cadc2bd46d4b8b2be3/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/43_render_shadow_fix.rar">这里</a>可以获取修复了上述错误的完整代码。</p>
<h2 id="正交-vs-投影"><a href="#正交-vs-投影" class="headerlink" title="正交 vs 投影"></a>正交 vs 投影</h2><p>在渲染深度贴图的时候，正交(Orthographic)和投影(Projection)矩阵之间有所不同。正交投影矩阵并不会将场景用透视图进行变形，所有视线/光线都是平行的，这使它对于定向光来说是个很好的投影矩阵。然而透视投影矩阵，会将所有顶点根据透视关系进行变形，结果因此而不同。下图展示了两种投影方式所产生的不同阴影区域：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_projection.png" class="" title="img">

<p>透视投影对于光源来说更合理，不像定向光，它是有自己的位置的。透视投影因此更经常用在点光源和聚光灯上，而正交投影经常用在定向光上。</p>
<p>另一个细微差别是，透视投影矩阵，将深度缓冲视觉化经常会得到一个几乎全白的结果。发生这个是因为透视投影下，深度变成了非线性的深度值，它的大多数可辨范围都位于近平面附近。为了可以像使用正交投影一样合适地观察深度值，你必须先将非线性深度值转变为线性的，如我们在深度测试教程中已经讨论过的那样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 color;</span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D depthMap;</span><br><span class="line">uniform <span class="type">float</span> near_plane;</span><br><span class="line">uniform <span class="type">float</span> far_plane;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">LinearizeDepth</span><span class="params">(<span class="type">float</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> z = depth * <span class="number">2.0</span> - <span class="number">1.0</span>; <span class="comment">// Back to NDC </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2.0</span> * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="type">float</span> depthValue = <span class="built_in">texture</span>(depthMap, TexCoords).r;</span><br><span class="line">    color = <span class="built_in">vec4</span>(<span class="built_in">vec3</span>(<span class="built_in">LinearizeDepth</span>(depthValue) / far_plane), <span class="number">1.0</span>); <span class="comment">// perspective</span></span><br><span class="line">    <span class="comment">// color = vec4(vec3(depthValue), 1.0); // orthographic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个深度值与我们见到的用正交投影的很相似。需要注意的是，这个只适用于调试；正交或投影矩阵的深度检查仍然保持原样，因为相关的深度并没有改变。</p>
<h2 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a>附加资源</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">Tutorial 16 : Shadow mapping</a>：提供类似的阴影贴图教程，里面有一些额外的解释。</li>
<li><a target="_blank" rel="noopener" href="http://ogldev.atspace.co.uk/www/tutorial23/tutorial23.html">Shadow Mapping – Part 1：ogldev</a>：提供的另一个阴影贴图教程。</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=EsccgeUpdsM">How Shadow Mapping Works</a>：一个第三方YouTube视频教程，里面解释了阴影贴图及其实现。</li>
<li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324(v=vs.85).aspx">Common Techniques to Improve Shadow Depth Maps</a>：微软的一篇文章，其中列出了很多提升阴影贴图质量的技术。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/" class="post-title-link" itemprop="url">30-Gammma校正</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-30 17:45:28" itemprop="dateCreated datePublished" datetime="2024-09-30T17:45:28+08:00">2024-09-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-14 20:44:38" itemprop="dateModified" datetime="2024-10-14T20:44:38+08:00">2024-10-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当我们计算出场景中所有像素的最终颜色以后，我们就必须把它们显示在监视器上。过去，大多数监视器是阴极射线管显示器（CRT）。这些监视器的物理特性是两倍的输入电压不能产生两倍的亮度。输入电压产生约为输入电压的2.2次幂的亮度，这叫做监视器Gamma。</p>
<p>Gamma也叫灰度系数，每种显示设备都有自己的Gamma值，都不相同，有一个公式：设备输出亮度 = 电压的Gamma次幂，任何设备Gamma基本上都不会等于1，等于1是一种理想的线性状态，这种理想状态是：如果电压和亮度都是在0到1的区间，那么多少电压就等于多少亮度。对于CRT，Gamma通常为2.2，因而，输出亮度 = 输入电压的2.2次幂，你可以从本节第二张图中看到Gamma2.2实际显示出来的总会比预期暗，相反Gamma0.45就会比理想预期亮，如果将Gamma0.45叠加到Gamma2.2的显示设备上，便会对偏暗的显示效果做到校正，这个简单的思路就是本节的核心，人类所感知的亮度恰好和CRT所显示出来相似的指数关系非常匹配。为了更好的理解所有含义，请看下面的图片：</p>
<img src="/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/gamma_correction_brightness.png" class="" title="img">

<p>第一行是人眼所感知到的正常的灰阶，亮度要增加一倍（比如从0.1到0.2）你才会感觉比原来变亮了一倍。然而，当我们谈论光的物理亮度，如光源发射光子的数量的时候，底部（第二行）的灰阶显示出的才是物理世界真实的亮度。如底部的灰阶显示，亮度加倍时返回的也是真实的物理亮度（这里亮度是指光子数量和正相关的亮度，即物理亮度。物理亮度和感知亮度的区别在于，物理亮度基于光子数量，感知亮度基于人的感觉。），但是由于这与我们的眼睛感知亮度不完全一致（对比较暗的颜色变化更敏感），所以它看起来有差异。</p>
<p>因为人眼看到颜色的亮度更倾向于顶部的灰阶，监视器使用的也是指数关系（电压的2.2次幂），所以物理亮度通过监视器能够被映射到顶部的非线性亮度；因此看起来效果不错（CRT亮度是是电压的2.2次幂而人眼相当于2次幂，因此CRT这个缺陷正好能满足人的需要）。</p>
<p>监视器的这个非线性映射的确可以让亮度在我们眼中看起来更好，但当渲染图像时，会产生一个问题：我们在应用中配置的亮度和颜色是基于监视器所看到的，这样所有的配置实际上是非线性的亮度/颜色配置。请看下图：</p>
<img src="/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/gamma_correction_gamma_curves.png" class="" title="img">

<p>点线代表线性颜色/亮度值（译注：这表示的是理想状态，Gamma为1），实线代表监视器显示的颜色。如果我们把一个点线线性的颜色翻一倍，结果就是这个值的两倍。比如，光的颜色向量L¯=(0.5,0.0,0.0)代表的是暗红色。如果我们在线性空间中把它翻倍，就会变成(1.0,0.0,0.0)，就像你在图中看到的那样。然而，由于我们定义的颜色仍然需要输出的监视器上，监视器上显示的实际颜色就会是(0.218,0.0,0.0)。当我们将理想中直线上的那个暗红色翻一倍时，在监视器上实际上亮度翻了4.5倍以上！</p>
<p>直到现在，我们还一直假设我们所有的工作都是在线性空间中进行的（Gamma为1），但最终还是要把所有的颜色输出到监视器上，所以我们配置的所有颜色和光照变量从物理角度来看都是不正确的，在我们的监视器上很少能够正确地显示。出于这个原因，我们（以及艺术家）通常将光照值设置得比本来更亮一些（由于监视器会将其亮度显示的更暗一些），如果不是这样，在线性空间里计算出来的光照就会不正确。同时，还要记住，监视器所显示出来的图像和线性图像的最小亮度是相同的，它们最大的亮度也是相同的；只是中间亮度部分会被压暗。</p>
<p>因为所有中间亮度都是线性空间计算出来的（计算的时候假设Gamma为1）监视器显以后，实际上都会不正确。当使用更高级的光照算法时，这个问题会变得越来越明显，你可以看看下图：</p>
<img src="/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/gamma_correction_example.png" class="" title="img">

<h2 id="Gamma校正"><a href="#Gamma校正" class="headerlink" title="Gamma校正"></a>Gamma校正</h2><p>Gamma校正(Gamma Correction)的思路是在最终的颜色输出上应用监视器Gamma的倒数。回头看前面的Gamma曲线图，你会有一个短划线，它是监视器Gamma曲线的翻转曲线。我们在颜色显示到监视器的时候把每个颜色输出都加上这个翻转的Gamma曲线，这样应用了监视器Gamma以后最终的颜色将会变为线性的。我们所得到的中间色调就会更亮，所以虽然监视器使它们变暗，但是我们又将其平衡回来了。</p>
<p>我们来看另一个例子。还是那个暗红色(0.5,0.0,0.0)。在将颜色显示到监视器之前，我们先对颜色应用Gamma校正曲线。线性的颜色显示在监视器上相当于降低了2.2幂的亮度，所以倒数就是1/2.2次幂。Gamma校正后的暗红色就会成为(0.5,0.0,0.0)1/2.2=(0.5,0.0,0.0)0.45=(0.73,0.0,0.0)。校正后的颜色接着被发送给监视器，最终显示出来的颜色是(0.73,0.0,0.0)2.2=(0.5,0.0,0.0)。你会发现使用了Gamma校正，监视器最终会显示出我们在应用中设置的那种线性的颜色。</p>
<p>2.2通常是是大多数显示设备的大概平均gamma值。基于gamma2.2的颜色空间叫做sRGB颜色空间。每个监视器的gamma曲线都有所不同，但是gamma2.2在大多数监视器上表现都不错。出于这个原因，游戏经常都会为玩家提供改变游戏gamma设置的选项，以适应每个监视器（现在Gamma2.2相当于一个标准，但现在你可能会问，前面不是说Gamma2.2看起来不是正好适合人眼么，为何还需要校正。这是因为你在程序中设置的颜色，比如光照都是基于线性Gamma，即Gamma1，所以你理想中的亮度和实际表达出的不一样，如果要表达出你理想中的亮度就要对这个光照进行校正）。</p>
<p>有两种方式可以在场景中应用gamma校正：</p>
<p>使用OpenGL内建的sRGB帧缓冲。 自己在像素着色器中进行gamma校正。 第一个选项也许是最简单的方式，但是我们也会丧失一些控制权。开启GL_FRAMEBUFFER_SRGB，可以告诉OpenGL每个后续的绘制命令里，在颜色储存到颜色缓冲之前先校正sRGB颜色。sRGB这个颜色空间大致对应于gamma2.2，它也是家用设备的一个标准。开启GL_FRAMEBUFFER_SRGB以后，每次像素着色器运行后续帧缓冲，OpenGL将自动执行gamma校正，包括默认帧缓冲。开启GL_FRAMEBUFFER_SRGB简单的调用glEnable就行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_FRAMEBUFFER_SRGB);</span><br></pre></td></tr></table></figure>

<p>自此，你渲染的图像就被进行gamma校正处理，你不需要做任何事情，因为硬件已经帮你处理了。gamma校正会把线性颜色空间转变为非线性空间，所以在最后一步进行gamma校正是极其重要的。如果你在最后输出之前就进行gamma校正，所有的后续操作都是在操作不正确的颜色值。例如，如果你使用多个帧缓冲，你可能打算让两个帧缓冲之间传递的中间结果仍然保持线性空间颜色，只是给发送给监视器的最后的那个帧缓冲应用gamma校正。</p>
<p>第二个方法稍微复杂点，但同时我们对gamma操作会有完全的控制权。我们在每个相关像素着色器运行的最后应用gamma校正，所以在发送到帧缓冲前，颜色就被校正了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// do super fancy lighting </span></span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// apply gamma correction</span></span><br><span class="line">    <span class="type">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line">    fragColor.rgb = <span class="built_in">pow</span>(fragColor.rgb, <span class="built_in">vec3</span>(<span class="number">1.0</span>/gamma));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一行代码，将fragColor的每个颜色元素应用有一个1.0/gamma的幂运算，校正像素着色器的颜色输出。</p>
<p>这个方法有个问题就是为了保持一致，你必须在像素着色器里加上这个gamma校正，所以如果你有很多像素着色器，它们可能分别用于不同物体，那么你就必须在每个着色器里都加上gamma校正了。一个更简单的方案是在你的渲染循环中使用后处理，在后处理四边形上应用gamma校正，这样只做一次就好了。</p>
<h3 id="sRGB纹理"><a href="#sRGB纹理" class="headerlink" title="sRGB纹理"></a>sRGB纹理</h3><p>因为监视器总是在sRGB空间中显示应用了gamma的颜色，无论什么时候当你在计算机上绘制、编辑或者画出一个图片的时候，你所选的颜色都是根据你在监视器上看到的那种。这实际意味着所有你创建或编辑的图片并不是在线性空间，而是在sRGB空间中（sRGB空间定义的gamma接近于2.2），假如在你的屏幕上对暗红色翻一倍，便是根据你所感知到的亮度进行的，并不等于将红色元素加倍。</p>
<p>结果就是纹理编辑者，所创建的所有纹理都是在sRGB空间中的纹理，所以如果我们在渲染应用中使用这些纹理，我们必须考虑到这点。在应用gamma校正之前，这不是个问题，因为纹理在sRGB空间创建和展示，同样我们还是在sRGB空间中使用，从而不必gamma校正纹理显示也没问题。然而，现在我们是把所有东西都放在线性空间中展示的，纹理颜色就会变坏，如下图展示的那样</p>
<img src="/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/image-20241014190156915.png" class="" title="image-20241014190156915">

<p>纹理图像实在太亮了，这种情况产生的原因是，它们实际上进行了两次gamma校正。当我们基于监视器上看到的情况创建一个图像，我们就已经对颜色值进行了gamma校正，但是在渲染中又进行了一次gamma校正。</p>
<p>为了修复这个问题，我们得确保纹理制作者是在线性空间中进行创作的。但是，由于大多数纹理制作者并不知道什么是gamma校正，并且在sRGB空间中进行创作更简单，这也许不是一个好办法。</p>
<p>另一个解决方案是重校，或把这些sRGB纹理在进行任何颜色值的计算前变回线性空间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line">vec3 diffuseColor = <span class="built_in">pow</span>(<span class="built_in">texture</span>(diffuse, texCoords).rgb, <span class="built_in">vec3</span>(gamma));</span><br></pre></td></tr></table></figure>

<p>为每个sRGB空间的纹理做这件事非常烦人。幸好，OpenGL给我们提供了另一个方案来解决我们的麻烦，这就是GL_SRGB和GL_SRGB_ALPHA内部纹理格式。</p>
<p>如果我们在OpenGL中创建了一个纹理，把它指定为以上两种sRGB纹理格式其中之一，OpenGL将自动把颜色校正到线性空间中，这样我们所使用的所有颜色值都是在线性空间中的了。我们可以这样把一个纹理指定为一个sRGB纹理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_SRGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, image);</span><br></pre></td></tr></table></figure>

<p>如果你还打算在你的纹理中引入alpha元素，必须将纹理的内部格式指定为GL_SRGB_ALPHA。</p>
<p>因为不是所有纹理都是在sRGB空间中的所以当你把纹理指定为sRGB纹理时要格外小心。比如diffuse纹理，这种为物体上色的纹理几乎都是在sRGB空间中的。而为了获取光照参数的纹理，像specular贴图和法线贴图几乎都在线性空间中，所以如果你把它们也配置为sRGB纹理的话，光照就坏掉了。指定sRGB纹理时要当心。</p>
<p>将diffuse纹理定义为sRGB纹理之后，你将获得你所期望的视觉输出，但这次每个物体都会只进行一次gamma校正。</p>
<h3 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h3><p>在使用了gamma校正之后，另一个不同之处是光照衰减(Attenuation)。真实的物理世界中，光照的衰减和光源的距离的平方成反比。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> attenuation = <span class="number">1.0</span> / (distance * distance);</span><br></pre></td></tr></table></figure>

<p>然而，当我们使用这个衰减公式的时候，衰减效果总是过于强烈，光只能照亮一小圈，看起来并不真实。出于这个原因，我们使用在基本光照教程中所讨论的那种衰减方程，它给了我们更大的控制权，此外我们还可以使用双曲线函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> attenuation = <span class="number">1.0</span> / distance;</span><br></pre></td></tr></table></figure>

<p>双曲线比使用二次函数变体在不用gamma校正的时候看起来更真实，不过但我们开启gamma校正以后线性衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果。下图显示了其中的不同：</p>
<img src="/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/gamma_correction_attenuation.png" class="" title="img">

<p>这种差异产生的原因是，光的衰减方程改变了亮度值，而且屏幕上显示出来的也不是线性空间，在监视器上效果最好的衰减方程，并不是符合物理的。想想平方衰减方程，如果我们使用这个方程，而且不进行gamma校正，显示在监视器上的衰减方程实际上将变成(1.0/distance2)2.2。若不进行gamma校正，将产生更强烈的衰减。这也解释了为什么双曲线不用gamma校正时看起来更真实，因为它实际变成了(1.0/distance)2.2=1.0/distance2.2。这和物理公式是很相似的。</p>
<p>我们在基础光照教程中讨论的更高级的那个衰减方程在有gamma校正的场景中也仍然有用，因为它可以让我们对衰减拥有更多准确的控制权（不过，在进行gamma校正的场景中当然需要不同的参数）。</p>
<p>这有一个简单的demo场景，你可以在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/gamma_correction.rar">这里</a>找到源代码。按下空格就能在有gamma校正和无gamma校正的场景进行切换，两个场景使用的是相同的纹理和衰减。</p>
<p>总而言之，gamma校正使你可以在线性空间中进行操作。因为线性空间更符合物理世界，大多数物理公式现在都可以获得较好效果，比如真实的光的衰减。你的光照越真实，使用gamma校正获得漂亮的效果就越容易。这也正是为什么当引进gamma校正时，建议只去调整光照参数的原因。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/" class="post-title-link" itemprop="url">29-高级光照</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-29 20:46:52" itemprop="dateCreated datePublished" datetime="2024-09-29T20:46:52+08:00">2024-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-30 17:49:13" itemprop="dateModified" datetime="2024-09-30T17:49:13+08:00">2024-09-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Blinn-Phong"><a href="#Blinn-Phong" class="headerlink" title="Blinn-Phong"></a>Blinn-Phong</h2><p>冯氏光照不仅对真实光照有很好的近似，而且性能也很高。但是它的镜面反射会在一些情况下出现问题，特别是物体反光度很低时，会导致大片（粗糙的）高光区域。下面这张图展示了当反光度为1.0时地板会出现的效果：</p>
<img src="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/advanced_lighting_phong_limit.png" class="" title="img">

<p>可以看到，在镜面高光区域的边缘出现了一道很明显的断层。出现这个问题的原因是观察向量和反射向量间的夹角不能大于90度。如果点积的结果为负数，镜面光分量会变为0.0。你可能会觉得，当光线与视线夹角大于90度时你应该不会接收到任何光才对，所以这不是什么问题。</p>
<p>然而，这种想法仅仅只适用于漫反射分量。当考虑漫反射光的时候，如果法线和光源夹角大于90度，光源会处于被照表面的下方，这个时候光照的漫反射分量的确是为0.0。但是，在考虑镜面高光时，我们测量的角度并不是光源与法线的夹角，而是视线与反射光线向量的夹角。看一下下面这两张图：</p>
<img src="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/advanced_lighting_over_90.png" class="" title="img">

<p>现在问题就应该很明显了。左图中是我们熟悉的冯氏光照中的反射向量，其中θ角小于90度。而右图中，视线与反射方向之间的夹角明显大于90度，这种情况下镜面光分量会变为0.0。这在大多数情况下都不是什么问题，因为观察方向离反射方向都非常远。然而，当物体的反光度非常小时，它产生的镜面高光半径足以让这些相反方向的光线对亮度产生足够大的影响。在这种情况下就不能忽略它们对镜面光分量的贡献了。</p>
<p>1977年，James F. Blinn在冯氏着色模型上加以拓展，引入了Blinn-Phong着色模型。Blinn-Phong模型与冯氏模型非常相似，但是它对镜面光模型的处理上有一些不同，让我们能够解决之前提到的问题。Blinn-Phong模型不再依赖于反射向量，而是采用了所谓的半程向量(Halfway Vector)，即光线与视线夹角一半方向上的一个单位向量。当半程向量与法线向量越接近时，镜面光分量就越大。</p>
<img src="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/advanced_lighting_halfway_vector.png" class="" title="img">

<p>当视线正好与（现在不需要的）反射向量对齐时，半程向量就会与法线完美契合。所以当观察者视线越接近于原本反射光线的方向时，镜面高光就会越强。现在，不论观察者向哪个方向看，半程向量与表面法线之间的夹角都不会超过90度（除非光源在表面以下）。它产生的效果会与冯氏光照有些许不同，但是大部分情况下看起来会更自然一点，特别是低高光的区域。Blinn-Phong着色模型正是早期固定渲染管线时代时OpenGL所采用的光照模型。</p>
<p>获取半程向量的方法很简单，只需要将光线的方向向量和观察向量加到一起，并将结果正规化(Normalize)就可以了：</p>
<img src="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/image-20240929205225538.png" class="" title="image-20240929205225538">

<p>翻译成GLSL代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec3 lightDir   = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line">vec3 viewDir    = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br></pre></td></tr></table></figure>

<p>接下来，镜面光分量的实际计算只不过是对表面法线和半程向量进行一次约束点乘(Clamped Dot Product)，让点乘结果不为负，从而获取它们之间夹角的余弦值，之后我们对这个值取反光度次方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), shininess);</span><br><span class="line">vec3 specular = lightColor * spec;</span><br></pre></td></tr></table></figure>

<p>除此之外Blinn-Phong模型就没什么好说的了，Blinn-Phong与冯氏模型唯一的区别就是，Blinn-Phong测量的是法线与半程向量之间的夹角，而冯氏模型测量的是观察方向与反射向量间的夹角。</p>
<p>在引入半程向量之后，我们现在应该就不会再看到冯氏光照中高光断层的情况了。下面两个图片展示的是两种方法在镜面光分量为0.5时的对比：</p>
<img src="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/advanced_lighting_comparrison.png" class="" title="img">

<p>除此之外，冯氏模型与Blinn-Phong模型也有一些细微的差别：半程向量与表面法线的夹角通常会小于观察与反射向量的夹角。所以，如果你想获得和冯氏着色类似的效果，就必须在使用Blinn-Phong模型时将镜面反光度设置更高一点。通常我们会选择冯氏着色时反光度分量的2到4倍。</p>
<p>下面是冯氏着色与Blinn-Phong着色的一个对比（左边为phong，右边为blinn-phong）：</p>
<img src="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/image-20240930174245958.png" class="" title="image-20240930174245958">

<p>你可以看到，Blinn-Phong的镜面光分量会比冯氏模型更锐利一些。为了得到与冯氏模型类似的结果，你可能会需要不断进行一些微调，但Blinn-Phong模型通常会产出更真实的结果。</p>
<p>这里，我们使用了一个简单的片段着色器，让我们能够在冯氏反射与Blinn-Phong反射间进行切换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(blinn)</span><br><span class="line">    &#123;</span><br><span class="line">        vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">        spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">16.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">        spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">8.0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/advanced_lighting.rar">这里</a>获取完整的代码，可以按下<code>B</code>键来切换冯氏光照与Blinn-Phong光照。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/29/28-%E6%8A%97%E9%94%AF%E9%BD%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/29/28-%E6%8A%97%E9%94%AF%E9%BD%BF/" class="post-title-link" itemprop="url">28-抗锯齿</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-09-29 14:46:47 / 修改时间：20:46:03" itemprop="dateCreated datePublished" datetime="2024-09-29T14:46:47+08:00">2024-09-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在学习OpenGL的时候，你可能会时不时遇到模型边缘有锯齿的情况。这些锯齿边缘(Jagged Edges)的产生和光栅器将顶点数据转化为片段的方式有关。能够清楚看见形成边缘的像素，这种现象被称之为走样(Aliasing)。缓解这种现象的技术叫做抗锯齿（Anti-aliasing，也被称为反走样），让我们的渲染产生更平滑的边缘。</p>
<img src="/2024/09/29/28-%E6%8A%97%E9%94%AF%E9%BD%BF/image-20240929181219864.png" class="" title="image-20240929181219864">

<p>有一种叫做超采样抗锯齿(Super Sample Anti-aliasing, SSAA)的技术，它会使用比正常分辨率更高的分辨率（即超采样）来渲染场景，当图像输出在帧缓冲中更新时，分辨率会被下采样(Downsample)至正常的分辨率。这些额外的分辨率会被用来防止锯齿边缘的产生。虽然它确实能够解决走样的问题，但是由于这样比平时要绘制更多的片段，它也会带来很大的性能开销。所以这项技术只拥有了短暂的辉煌。</p>
<p>然而，在这项技术的基础上也诞生了更为现代的技术，叫做多重采样抗锯齿(Multisample Anti-aliasing, MSAA)。它借鉴了SSAA背后的理念，但却以更加高效的方式实现了抗锯齿。</p>
<h2 id="多重采样"><a href="#多重采样" class="headerlink" title="多重采样"></a>多重采样</h2><p>为了理解什么是多重采样(Multisampling)，以及它是如何解决锯齿问题的，我们有必要更加深入地了解OpenGL光栅器的工作方式。</p>
<p>光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任意值，但片段不行，因为它们受限于你窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段/屏幕坐标。</p>
<img src="/2024/09/29/28-%E6%8A%97%E9%94%AF%E9%BD%BF/anti_aliasing_rasterization.png" class="" title="img">

<p>这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个采样点(Sample Point)，它会被用来决定这个三角形是否遮盖了某个像素。图中红色的采样点被三角形所遮盖，在每一个遮住的像素处都会生成一个片段。虽然三角形边缘的一些部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形内部所遮盖，所以它们不会受到片段着色器的影响。</p>
<p>现在走样就产生了，完整渲染后的三角形在屏幕上会是这样的：</p>
<img src="/2024/09/29/28-%E6%8A%97%E9%94%AF%E9%BD%BF/anti_aliasing_rasterization_filled.png" class="" title="img">

<p>由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致了之前讨论到的锯齿边缘。</p>
<p>多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）。我们不再使用像素中心的单一采样点，取而代之的是以特定图案排列的4个子采样点(Subsample)。我们将用这些子采样点来决定像素的遮盖度。当然，这也意味着颜色缓冲的大小会随着子采样点的增加而增加。</p>
<img src="/2024/09/29/28-%E6%8A%97%E9%94%AF%E9%BD%BF/anti_aliasing_sample_points.png" class="" title="img">

<p>上图的左侧展示了正常情况下判定三角形是否遮盖的方式。在例子中的这个像素上不会运行片段着色器（所以它会保持空白）。因为它的采样点并未被三角形所覆盖。上图的右侧展示的是实施多重采样之后的版本，每个像素包含有4个采样点。这里，只有两个采样点遮盖住了三角形。采样点的数量可以是任意的，更多的采样点能带来更精确的遮盖率。</p>
<p>我们知道三角形只遮盖了2个子采样点，所以下一步是决定这个像素的颜色。你的猜想可能是，我们对每个被遮盖住的子采样点运行一次片段着色器，最后将每个像素所有子采样点的颜色平均一下。在这个例子中，我们需要在两个子采样点上对被插值的顶点数据运行两次片段着色器，并将结果的颜色储存在这些采样点中。但是这并不是它工作的方式，因为这本质上说还是需要运行更多次的片段着色器，会显著地降低性能。</p>
<p>MSAA真正的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只运行一次片段着色器，片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的4个采样点中只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。</p>
<p>这样子做之后，颜色缓冲中所有的图元边缘将会产生一种更平滑的图形：</p>
<img src="/2024/09/29/28-%E6%8A%97%E9%94%AF%E9%BD%BF/anti_aliasing_rasterization_samples.png" class="" title="img">

<p>这里，每个像素包含4个子采样点（不相关的采样点都没有标注），蓝色的采样点被三角形所遮盖，而灰色的则没有。对于三角形的内部的像素，片段着色器只会运行一次，颜色输出会被存储到全部的4个子样本中。而在三角形的边缘，并不是所有的子采样点都被遮盖，所以片段着色器的结果将只会储存到部分的子样本中。根据被遮盖的子样本的数量，最终的像素颜色将由三角形的颜色与其它子样本中所储存的颜色来决定。简单来说，一个像素中如果有更多的采样点被三角形遮盖，那么这个像素的颜色就会更接近于三角形的颜色。如果我们给上面的三角形填充颜色，就能得到以下的效果：</p>
<img src="/2024/09/29/28-%E6%8A%97%E9%94%AF%E9%BD%BF/anti_aliasing_rasterization_samples_filled.png" class="" title="img">

<p>对于每个像素来说，越少的子采样点被三角形所覆盖，那么它受到三角形的影响就越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑了。不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。</p>
<h2 id="OpenGL中的MSAA"><a href="#OpenGL中的MSAA" class="headerlink" title="OpenGL中的MSAA"></a>OpenGL中的MSAA</h2><p>如果我们想要在OpenGL中使用MSAA，必须要使用一个能在每个像素中存储大于1个颜色值的颜色缓冲（因为多重采样需要为每个采样点都储存一个颜色）。所以，需要一个新的缓冲类型，来存储特定数量的多重采样样本，它叫做多重采样缓冲(Multisample Buffer)。大多数的窗口系统都应该提供了一个多重采样缓冲，用以代替默认的颜色缓冲。GLFW同样给了我们这个功能，我们所要做的只是告诉GLFW，我们希望使用一个包含N个样本的多重采样缓冲。这可以在创建窗口之前调用glfwWindowHint来完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_SAMPLES, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>现在再调用glfwCreateWindow创建渲染窗口时，每个屏幕坐标就会使用一个包含4个子采样点的颜色缓冲了。GLFW会自动创建一个每像素4个子采样点的深度和样本缓冲。这也意味着所有缓冲的大小都增长了4倍。</p>
<p>现在我们已经向GLFW请求了多重采样缓冲，我们还需要调用glEnable并启用GL_MULTISAMPLE，来启用多重采样。在大多数OpenGL的驱动上，多重采样都是默认启用的，所以这个调用可能会有点多余，但显式地调用一下会更保险一点。这样子不论是什么OpenGL的实现都能够正常启用多重采样了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_MULTISAMPLE);</span><br></pre></td></tr></table></figure>

<p>只要默认的帧缓冲有了多重采样缓冲的附件，我们所要做的只是调用glEnable来启用多重采样。因为多重采样的算法都在OpenGL驱动的光栅器中实现了，我们不需要再多做什么。如果现在再来渲染本节一开始的那个绿色的立方体，我们应该能看到更平滑的边缘：</p>
<img src="/2024/09/29/28-%E6%8A%97%E9%94%AF%E9%BD%BF/image-20240929181208850.png" class="" title="image-20240929181208850">

<p><a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/09/29/28-%E6%8A%97%E9%94%AF%E9%BD%BF/anti_aliasing_msaa.rar">这里</a>获取完整代码</p>
<h2 id="离屏MSAA"><a href="#离屏MSAA" class="headerlink" title="离屏MSAA"></a>离屏MSAA</h2><p>由于GLFW负责了创建多重采样缓冲，启用MSAA非常简单。然而，如果我们想要使用我们自己的帧缓冲来进行离屏渲染，那么我们就必须要自己动手生成多重采样缓冲了。有两种方式可以创建多重采样缓冲，将其作为帧缓冲的附件：纹理附件和渲染缓冲附件。</p>
<h3 id="多重采样纹理附件"><a href="#多重采样纹理附件" class="headerlink" title="多重采样纹理附件"></a>多重采样纹理附件</h3><p>为了创建一个支持储存多个采样点的纹理，我们使用glTexImage2DMultisample来替代glTexImage2D，它的纹理目标是GL_TEXTURE_2D_MULTISAPLE。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D_MULTISAMPLE, tex);</span><br><span class="line"><span class="built_in">glTexImage2DMultisample</span>(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D_MULTISAMPLE, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>它的第二个参数设置的是纹理所拥有的样本个数。如果最后一个参数为GL_TRUE，图像将会对每个纹素使用相同的样本位置以及相同数量的子采样点个数。我们使用glFramebufferTexture2D将多重采样纹理附加到帧缓冲上，但这里纹理类型使用的是GL_TEXTURE_2D_MULTISAMPLE。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>当前绑定的帧缓冲现在就有了一个纹理图像形式的多重采样颜色缓冲。</p>
<h3 id="多重采样渲染缓冲对象"><a href="#多重采样渲染缓冲对象" class="headerlink" title="多重采样渲染缓冲对象"></a>多重采样渲染缓冲对象</h3><p>和纹理类似，创建一个多重采样渲染缓冲对象并不难。我们所要做的只是在指定（当前绑定的）渲染缓冲的内存存储时，将glRenderbufferStorage的调用改为glRenderbufferStorageMultisample就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glRenderbufferStorageMultisample</span>(GL_RENDERBUFFER, <span class="number">4</span>, GL_DEPTH24_STENCIL8, width, height);</span><br></pre></td></tr></table></figure>

<p>函数中，渲染缓冲对象后的参数我们将设定为样本的数量，在当前使用的是4。</p>
<h3 id="渲染到多重采样帧缓冲"><a href="#渲染到多重采样帧缓冲" class="headerlink" title="渲染到多重采样帧缓冲"></a>渲染到多重采样帧缓冲</h3><p>渲染到多重采样帧缓冲对象的过程都是自动的。只要我们在帧缓冲绑定时绘制任何东西，光栅器就会负责所有的多重采样运算。我们最终会得到一个多重采样颜色缓冲以及/或深度和模板缓冲。因为多重采样缓冲有一点特别，我们不能直接将它们的缓冲图像用于其他运算，比如在着色器中对它们进行采样。</p>
<p>一个多重采样的图像包含比普通图像更多的信息，我们所要做的是缩小或者还原(Resolve)图像。多重采样帧缓冲的还原通常是通过glBlitFramebuffer来完成，它能够将一个帧缓冲中的某个区域复制到另一个帧缓冲中，并且将多重采样缓冲还原。</p>
<p>glBlitFramebuffer会将一个用4个屏幕空间坐标所定义的源区域复制到一个同样用4个屏幕空间坐标所定义的目标区域中。在之前使用帧缓冲的时候，当我们绑定到GL_FRAMEBUFFER时，我们是同时绑定了读取和绘制的帧缓冲目标。我们也可以将帧缓冲分开绑定至GL_READ_FRAMEBUFFER与GL_DRAW_FRAMEBUFFER。glBlitFramebuffer函数会根据这两个目标，决定哪个是源帧缓冲，哪个是目标帧缓冲。接下来，我们可以将图像位块传送(Blit)到默认的帧缓冲中，将多重采样的帧缓冲传送到屏幕上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_READ_FRAMEBUFFER, multisampledFBO);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_DRAW_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, width, height, <span class="number">0</span>, <span class="number">0</span>, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);</span><br></pre></td></tr></table></figure>

<p>如果现在再来渲染这个程序，我们会得到与之前完全一样的结果：一个使用MSAA显示出来的立方体，而且锯齿边缘明显减少了（下图是运行了后期处理的效果）：</p>
<img src="/2024/09/29/28-%E6%8A%97%E9%94%AF%E9%BD%BF/image-20240929190749871.png" class="" title="image-20240929190749871">

<p><a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/09/29/28-%E6%8A%97%E9%94%AF%E9%BD%BF/anti_aliasing_offscreen.rar">这里</a>获取完整代码</p>
<p>因为屏幕纹理又变回了一个只有单一采样点的普通纹理，像是边缘检测这样的后期处理滤镜会再次出现锯齿。为了补偿这一问题，你可以之后对纹理进行模糊处理，或者想出你自己的抗锯齿算法。</p>
<p>你可以看到，如果将多重采样与离屏渲染结合起来，我们需要自己负责一些额外的细节。但所有的这些细节都是值得额外的努力的，因为多重采样能够显著提升场景的视觉质量。当然，要注意，如果使用的采样点非常多，启用多重采样会显著降低程序的性能，通常采用的是4采样点的MSAA。</p>
<h2 id="自定义抗锯齿算法"><a href="#自定义抗锯齿算法" class="headerlink" title="自定义抗锯齿算法"></a>自定义抗锯齿算法</h2><p>将一个多重采样的纹理图像不进行还原直接传入着色器也是可行的。GLSL提供了这样的选项，让我们能够对纹理图像的每个子样本进行采样，所以可以创建我们自己的抗锯齿算法，在大型的图形应用中通常都会这么做。要想获取每个子样本的颜色值，你需要将纹理uniform采样器设置为sampler2DMS，而不是平常使用的sampler2D：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2DMS screenTextureMS;</span><br></pre></td></tr></table></figure>

<p>使用texelFetch函数就能够获取每个子样本的颜色值了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec4 colorSample = <span class="built_in">texelFetch</span>(screenTextureMS, TexCoords, <span class="number">3</span>);  <span class="comment">// 第4个子样本</span></span><br></pre></td></tr></table></figure>

<p>我们不会深入探究自定义抗锯齿技术的细节，这里仅仅是一点点启发。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/23/27-%E5%AE%9E%E4%BE%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/23/27-%E5%AE%9E%E4%BE%8B%E5%8C%96/" class="post-title-link" itemprop="url">27-实例化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-23 19:17:00" itemprop="dateCreated datePublished" datetime="2024-09-23T19:17:00+08:00">2024-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-25 23:10:27" itemprop="dateModified" datetime="2024-09-25T23:10:27+08:00">2024-09-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>假设有一个绘制了很多模型的场景，而大部分的模型包含的是同一组顶点数据，只不过进行的是不同的世界空间变换。想象一个充满草的场景：每根草都是一个包含几个三角形的小模型。你可能会需要绘制很多根草，最终在每帧中你可能会需要渲染上千或者上万根草。因为每一根草仅仅是由几个三角形构成，渲染几乎是瞬间完成的，但上千个渲染函数调用却会极大地影响性能。</p>
<p>如果我们需要渲染大量物体时，代码看起来会像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; amount_of_models_to_draw; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoSomePreparations</span>(); <span class="comment">// 绑定VAO，绑定纹理，设置uniform等</span></span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, amount_of_vertices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果像这样绘制模型的大量实例(Instance)，很快就会因为绘制调用过多而达到性能瓶颈。与绘制顶点本身相比，使用glDrawArrays或glDrawElements函数告诉GPU去绘制你的顶点数据会消耗更多的性能，因为OpenGL在绘制顶点数据之前需要做很多准备工作（比如告诉GPU该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的CPU到GPU总线上进行的）。所以，即便渲染顶点非常快，命令GPU去渲染却未必。</p>
<p>如果我们能够将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL重复利用这些数据绘制多个物体，就会更方便了。这就是实例化(Instancing)。</p>
<p>实例化这项技术能够让我们使用一个渲染调用来绘制多个物体，来节省每次绘制物体时CPU -&gt; GPU的通信，它只需要一次即可。如果想使用实例化渲染，我们只需要将glDrawArrays和glDrawElements的渲染调用分别改为glDrawArraysInstanced和glDrawElementsInstanced就可以了。这些渲染函数的实例化版本需要一个额外的参数，叫做实例数量(Instance Count)，它能够设置需要渲染的实例个数。这样我们只需要将必须的数据发送到GPU一次，然后使用一次函数调用告诉GPU它应该如何绘制这些实例。GPU将会直接渲染这些实例，而不用不断地与CPU进行通信。</p>
<p>渲染同一个物体一千次对我们并没有什么用处，每个物体都是完全相同的，而且还在同一个位置。出于这个原因，GLSL在顶点着色器中嵌入了另一个内建变量，gl_InstanceID。</p>
<p>在使用实例化渲染调用时，gl_InstanceID会从0开始，在每个实例被渲染时递增1。因为每个实例都有唯一的ID，我们可以建立一个数组，将ID与位置值对应起来，将每个实例放置在世界的不同位置。</p>
<h2 id="实例化矩形"><a href="#实例化矩形" class="headerlink" title="实例化矩形"></a>实例化矩形</h2><p>接下来用一个例子来学习实例，我们将会在标准化设备坐标系中使用一个渲染调用，绘制100个2D四边形。我们会索引一个包含100个偏移向量的uniform数组，将偏移值加到每个实例化的四边形上。每个四边形由2个三角形所组成，一共有6个顶点。每个顶点包含一个2D的标准化设备坐标位置向量和一个颜色向量。 下面就是这个例子使用的顶点数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> quadVertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置          // 颜色</span></span><br><span class="line">    <span class="number">-0.05f</span>,  <span class="number">0.05f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.05f</span>, <span class="number">-0.05f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.05f</span>, <span class="number">-0.05f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.05f</span>,  <span class="number">0.05f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.05f</span>, <span class="number">-0.05f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   </span><br><span class="line">     <span class="number">0.05f</span>,  <span class="number">0.05f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>                   </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>片段着色器会从顶点着色器接受颜色向量，并将其设置为它的颜色输出，来实现四边形的颜色：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec3 fColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(fColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顶点着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec2 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line"></span><br><span class="line">out vec3 fColor;</span><br><span class="line"></span><br><span class="line">uniform vec2 offsets[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec2 offset = offsets[gl_InstanceID];</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos + offset, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个叫做offsets的数组，它包含100个偏移向量。在顶点着色器中，我们会使用gl_InstanceID来索引offsets数组，获取每个实例的偏移向量。如果我们要实例化绘制100个四边形，仅使用这个顶点着色器我们就能得到100个位于不同位置的四边形。</p>
<p>当前，我们仍要设置这些偏移位置，我们会在进入渲染循环之前使用一个嵌套for循环计算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">glm::vec2 translations[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> offset = <span class="number">0.1f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-10</span>; y &lt; <span class="number">10</span>; y += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-10</span>; x &lt; <span class="number">10</span>; x += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        glm::vec2 translation;</span><br><span class="line">        translation.x = (<span class="type">float</span>)x / <span class="number">10.0f</span> + offset;</span><br><span class="line">        translation.y = (<span class="type">float</span>)y / <span class="number">10.0f</span> + offset;</span><br><span class="line">        translations[index++] = translation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们创建100个位移向量，表示10x10网格上的所有位置。除了生成translations数组之外，我们还需要将数据转移到顶点着色器的uniform数组中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shader.<span class="built_in">use</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    string index;</span><br><span class="line">    ss &lt;&lt; i; </span><br><span class="line">    index = ss.<span class="built_in">str</span>(); </span><br><span class="line">    shader.<span class="built_in">setVec2</span>((<span class="string">&quot;offsets[&quot;</span> + index + <span class="string">&quot;]&quot;</span>).<span class="built_in">c_str</span>(), translations[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这一段代码中，我们将for循环的计数器i转换为一个string，我们可以用它来动态创建位置值的字符串，用于uniform位置值的索引。接下来，我们会对offsets uniform数组中的每一项设置对应的位移向量。</p>
<p>现在所有的准备工作都做完了，我们可以开始渲染四边形了。对于实例化渲染，我们使用glDrawArraysInstanced或glDrawElementsInstanced。因为我们使用的不是索引缓冲，我们会调用glDrawArrays版本的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindVertexArray</span>(quadVAO);</span><br><span class="line"><span class="built_in">glDrawArraysInstanced</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>除了最后多了个参数用来设置需要绘制的实例数量，glDrawArraysInstanced的参数和glDrawArrays完全一样。因为我们想要在10x10网格中显示100个四边形，我们将它设置为100。</p>
<p>运行结果如下：</p>
<img src="/2024/09/23/27-%E5%AE%9E%E4%BE%8B%E5%8C%96/image-20240924142126504.png" class="" title="image-20240924142126504">

<p>完整的主程序代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tool/shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui_impl_glfw.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui_impl_opengl3.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tool/stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tool/mesh.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tool/model.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// windows size</span></span><br><span class="line"><span class="type">int</span> SCREEN_WIDTH = <span class="number">1920</span>;</span><br><span class="line"><span class="type">int</span> SCREEN_HEIGHT = <span class="number">1080</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear color</span></span><br><span class="line">ImVec4 clear_color = <span class="built_in">ImVec4</span>(<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// camera setting</span></span><br><span class="line"><span class="type">float</span> Speed = <span class="number">0.5f</span>;</span><br><span class="line">glm::vec3 cameraPos   = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">7.5f</span>, <span class="number">22.0f</span>);</span><br><span class="line">glm::vec3 cameraFront = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glm::vec3 cameraUp    = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mouse setting</span></span><br><span class="line"><span class="type">float</span> lastX = SCREEN_WIDTH / <span class="number">2.0</span>;</span><br><span class="line"><span class="type">float</span> lastY = SCREEN_HEIGHT / <span class="number">2.0</span>;</span><br><span class="line"><span class="type">float</span> yaw   = <span class="number">-90.0f</span>;</span><br><span class="line"><span class="type">float</span> pitch =  <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">bool</span> enableMouse = <span class="literal">false</span>;</span><br><span class="line"><span class="type">float</span> fov   =  <span class="number">45.0f</span>;</span><br><span class="line"><span class="type">float</span> sensitivity = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render setting</span></span><br><span class="line"><span class="type">float</span> deltaTime = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">float</span> lastFrame = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xoffset, <span class="type">double</span> yoffset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window, <span class="type">float</span> cameraSpeed)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">loadTexture</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *path)</span></span>;</span><br><span class="line">string Shader::dirName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shader::dirName = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *glsl_version = <span class="string">&quot;#version 330&quot;</span>;</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCREEN_WIDTH, SCREEN_HEIGHT, <span class="string">&quot;MyWindow&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建imgui上下文</span></span><br><span class="line">    ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">    ImGuiIO &amp;io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">    (<span class="type">void</span>)io;</span><br><span class="line">    <span class="comment">// 设置样式</span></span><br><span class="line">    ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line">    <span class="comment">// 设置平台和渲染器</span></span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_InitForOpenGL</span>(window, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_Init</span>(glsl_version);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCREEN_WIDTH, SCREEN_HEIGHT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line">    <span class="built_in">glfwSetCursorPosCallback</span>(window, mouse_callback);</span><br><span class="line">    <span class="built_in">glfwSetScrollCallback</span>(window, scroll_callback);</span><br><span class="line"></span><br><span class="line">    <span class="function">Shader <span class="title">myshader</span><span class="params">(<span class="string">&quot;./shader/vertex.glsl&quot;</span>, <span class="string">&quot;./shader/fragment.glsl&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> quadVertices[] = &#123;</span><br><span class="line">        <span class="comment">// 位置          // 颜色</span></span><br><span class="line">        <span class="number">-0.05f</span>,  <span class="number">0.05f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.05f</span>, <span class="number">-0.05f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.05f</span>, <span class="number">-0.05f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.05f</span>,  <span class="number">0.05f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.05f</span>, <span class="number">-0.05f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   </span><br><span class="line">        <span class="number">0.05f</span>,  <span class="number">0.05f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>                   </span><br><span class="line">    &#125;;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VAO, VBO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(quadVertices), &amp;quadVertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glm::vec2 translations[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> offset = <span class="number">0.1f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-10</span>; y &lt; <span class="number">10</span>; y += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-10</span>; x &lt; <span class="number">10</span>; x += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            glm::vec2 translation;</span><br><span class="line">            translation.x = (<span class="type">float</span>)x / <span class="number">10.0f</span> + offset;</span><br><span class="line">            translation.y = (<span class="type">float</span>)y / <span class="number">10.0f</span> + offset;</span><br><span class="line">            translations[index++] = translation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> currentFrame = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">        deltaTime = currentFrame - lastFrame;</span><br><span class="line">        lastFrame = currentFrame;</span><br><span class="line">        <span class="type">float</span> cameraSpeed = Speed * deltaTime;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">processInput</span>(window, cameraSpeed);</span><br><span class="line"></span><br><span class="line">        string FPS = <span class="built_in">to_string</span>(ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">        string ms = <span class="built_in">to_string</span>(<span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">        string time = <span class="built_in">to_string</span>(<span class="built_in">glfwGetTime</span>());</span><br><span class="line">        string newTitle = <span class="string">&quot;MyWindow - &quot;</span> + ms + <span class="string">&quot; ms/frame &quot;</span> + <span class="string">&quot; fps: &quot;</span> + FPS + <span class="string">&quot; render time: &quot;</span> + time + <span class="string">&quot;s&quot;</span>;</span><br><span class="line">        <span class="built_in">glfwSetWindowTitle</span>(window, newTitle.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">        ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Sence Setting&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">CollapsingHeader</span>(<span class="string">&quot;Window Settings&quot;</span>), ImGuiTreeNodeFlags_DefaultOpen)</span><br><span class="line">        &#123;</span><br><span class="line">            ImGui::<span class="built_in">SliderInt</span>(<span class="string">&quot;Width&quot;</span>, &amp;SCREEN_WIDTH, <span class="number">1</span>, <span class="number">2560</span>);</span><br><span class="line">            ImGui::<span class="built_in">SliderInt</span>(<span class="string">&quot;Height&quot;</span>, &amp;SCREEN_HEIGHT, <span class="number">1</span>, <span class="number">1440</span>);</span><br><span class="line">            ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;Clear Color&quot;</span>, (<span class="type">float</span> *)&amp;clear_color);</span><br><span class="line">            ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;Camera Speed&quot;</span>, &amp;Speed, <span class="number">0.01f</span>, <span class="number">4.0f</span>);</span><br><span class="line">            ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;Sensitivity&quot;</span>, &amp;sensitivity, <span class="number">0.01f</span>, <span class="number">0.5f</span>);</span><br><span class="line">            ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Enable Mouse&quot;</span>, &amp;enableMouse);</span><br><span class="line">        &#125;</span><br><span class="line">        ImGui::<span class="built_in">End</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glClearColor</span>(clear_color.x, clear_color.y, clear_color.z, clear_color.w);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        myshader.<span class="built_in">use</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            stringstream ss;</span><br><span class="line">            string index;</span><br><span class="line">            ss &lt;&lt; i; </span><br><span class="line">            index = ss.<span class="built_in">str</span>(); </span><br><span class="line">            myshader.<span class="built_in">setVec2</span>((<span class="string">&quot;offsets[&quot;</span> + index + <span class="string">&quot;]&quot;</span>).<span class="built_in">c_str</span>(), translations[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">        <span class="built_in">glDrawArraysInstanced</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">Render</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window, <span class="type">float</span> cameraSpeed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 控制摄像机</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_W) == GLFW_PRESS <span class="keyword">or</span> <span class="built_in">glfwGetKey</span>(window, GLFW_KEY_UP) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos += cameraSpeed * cameraFront;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_S) == GLFW_PRESS <span class="keyword">or</span> <span class="built_in">glfwGetKey</span>(window, GLFW_KEY_DOWN) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos -= cameraSpeed * cameraFront;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_A) == GLFW_PRESS <span class="keyword">or</span> <span class="built_in">glfwGetKey</span>(window, GLFW_KEY_LEFT) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos -= glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_D) == GLFW_PRESS <span class="keyword">or</span> <span class="built_in">glfwGetKey</span>(window, GLFW_KEY_RIGHT) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos += glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_Q) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos += cameraSpeed * cameraUp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_E) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos -= cameraSpeed * cameraUp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_LEFT_ALT) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        enableMouse = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        enableMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 摄像机重置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_F) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos   = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">        cameraFront = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">        cameraUp    = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enableMouse == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> xoffset = xpos - lastX;</span><br><span class="line">        <span class="type">float</span> yoffset = lastY - ypos; </span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line"></span><br><span class="line">        xoffset *= sensitivity;</span><br><span class="line">        yoffset *= sensitivity;</span><br><span class="line"></span><br><span class="line">        yaw += xoffset;</span><br><span class="line">        pitch += yoffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">            pitch = <span class="number">89.0f</span>;</span><br><span class="line">        <span class="keyword">if</span> (pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">            pitch = <span class="number">-89.0f</span>;</span><br><span class="line"></span><br><span class="line">        glm::vec3 front;</span><br><span class="line">        front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">        front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">        front.z = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">        cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xoffset, <span class="type">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fov -= (<span class="type">float</span>)yoffset;</span><br><span class="line">    <span class="keyword">if</span> (fov &lt; <span class="number">1.0f</span>)</span><br><span class="line">        fov = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (fov &gt; <span class="number">45.0f</span>)</span><br><span class="line">        fov = <span class="number">45.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然现在目前的情况下能够正常工作，但是如果我们要渲染远超过100个实例的时候，我们最终会超过最大能够发送至着色器的uniform数据大小<a target="_blank" rel="noopener" href="http://www.opengl.org/wiki/Uniform_(GLSL)#Implementation_limits">上限</a>。解决方案是实例化数组(Instanced Array)，它被定义为一个顶点属性（能够让我们储存更多的数据），仅在顶点着色器渲染一个新的实例时才会更新。</p>
<p>使用顶点属性时，顶点着色器的每次运行都会让GLSL获取新一组适用于当前顶点的属性。而当我们将顶点属性定义为一个实例化数组时，顶点着色器就只需要对每个实例，而不是每个顶点，更新顶点属性的内容了。这允许我们对逐顶点的数据使用普通的顶点属性，而对逐实例的数据使用实例化数组。现在我们将偏移量uniform数组设置为一个实例化数组，需要在顶点着色器中再添加一个顶点属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec2 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 aOffset;</span><br><span class="line"></span><br><span class="line">out vec3 fColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos + aOffset, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不再使用gl_InstanceID，现在不需要索引一个uniform数组就能够直接使用offset属性了。因为实例化数组和position与color变量一样，都是顶点属性，我们还需要将它的内容存在顶点缓冲对象中，并且配置它的属性指针。我们首先将之前的translations数组存到一个新的缓冲对象中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> instanceVBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;instanceVBO);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, instanceVBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(glm::vec2) * <span class="number">100</span>, &amp;translations[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>之后我们还需要设置它的顶点属性指针，并启用顶点属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, instanceVBO);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);   </span><br><span class="line"><span class="built_in">glVertexAttribDivisor</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码的最后一行，我们调用了glVertexAttribDivisor，这个函数告诉了OpenGL该什么时候更新顶点属性的内容至新一组数据。它的第一个参数是需要的顶点属性，第二个参数是属性除数(Attribute Divisor)。默认情况下，属性除数是0，告诉OpenGL我们需要在顶点着色器的每次迭代时更新顶点属性。将它设置为1时，我们告诉OpenGL我们希望在渲染一个新实例的时候更新顶点属性。而设置为2时，我们希望每2个实例更新一次属性，以此类推。我们将属性除数设置为1，是在告诉OpenGL，处于位置值2的顶点属性是一个实例化数组。</p>
<p>如果我们现在使用glDrawArraysInstanced，再次渲染，会得到和之前一样的运行结果：</p>
<img src="/2024/09/23/27-%E5%AE%9E%E4%BE%8B%E5%8C%96/image-20240924144108494.png" class="" title="image-20240924144108494">

<p>这和之前的例子是完全一样的，但这次是使用实例化数组实现的，这让我们能够传递更多的数据到顶点着色器（只要内存允许）来用于实例化绘制。我们也可以使用gl_InstanceID，从右上到左下逐渐缩小四边形，修改顶点着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec2 pos = aPos * (gl_InstanceID / <span class="number">100.0</span>);</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(pos + aOffset, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果就是，第一个四边形的实例会非常小，随着绘制实例的增加，gl_InstanceID会越来越接近100，四边形也就越来越接近原始大小。像这样将实例化数组与gl_InstanceID结合使用是完全可行的。运行结果如下：</p>
<img src="/2024/09/23/27-%E5%AE%9E%E4%BE%8B%E5%8C%96/image-20240924144330469.png" class="" title="image-20240924144330469">

<p><a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/09/23/27-%E5%AE%9E%E4%BE%8B%E5%8C%96/instancing_rect.rar">这里</a>可以获取完整的代码</p>
<h2 id="绘制小行星带"><a href="#绘制小行星带" class="headerlink" title="绘制小行星带"></a>绘制小行星带</h2><p>想象这样一个场景，在宇宙中有一个大的行星，它位于小行星带的中央。这样的小行星带可能包含成千上万的岩块，在很不错的显卡上也很难完成这样的渲染。实例化渲染正是适用于这样的场景，因为所有的小行星都可以使用一个模型来表示。每个小行星可以再使用不同的变换矩阵来进行少许的变化。</p>
<p>我们首先会不使用实例化渲染，来渲染小行星绕着行星飞行的场景。这个场景将会包含一个大的行星模型，它可以在<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/data/planet.rar">这里</a>下载，以及很多环绕着行星的小行星。小行星的岩石模型可以在<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/data/rock.rar">这里</a>下载。</p>
<p>为了得到想要的效果，我们将会为每个小行星生成一个变换矩阵，用作它们的模型矩阵。变换矩阵首先将小行星位移到小行星带中的某处，我们还会加一个小的随机偏移值到这个偏移量上，让这个圆环看起来更自然一点。接下来，我们应用一个随机的缩放，并且以一个旋转向量为轴进行一个随机的旋转。最终的变换矩阵不仅能将小行星变换到行星的周围，而且会让它看起来更自然，与其它小行星不同。最终的结果是一个布满小行星的圆环，其中每一个小行星都与众不同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> amount = <span class="number">1000</span>;</span><br><span class="line">glm::mat4 *modelMatrices;</span><br><span class="line">modelMatrices = <span class="keyword">new</span> glm::mat4[amount];</span><br><span class="line"><span class="comment">// 初始化随机种子</span></span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">glfwGetTime</span>()); </span><br><span class="line"><span class="type">float</span> radius = <span class="number">50.0</span>;</span><br><span class="line"><span class="type">float</span> offset = <span class="number">2.5f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; amount; i++)</span><br><span class="line">&#123;</span><br><span class="line">    glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    <span class="comment">// 1. 位移：分布在半径为 &#x27;radius&#x27; 的圆形上，偏移的范围是 [-offset, offset]</span></span><br><span class="line">    <span class="type">float</span> angle = (<span class="type">float</span>)i / (<span class="type">float</span>)amount * <span class="number">360.0f</span>;</span><br><span class="line">    <span class="type">float</span> displacement = (<span class="built_in">rand</span>() % (<span class="type">int</span>)(<span class="number">2</span> * offset * <span class="number">100</span>)) / <span class="number">100.0f</span> - offset;</span><br><span class="line">    <span class="type">float</span> x = <span class="built_in">sin</span>(angle) * radius + displacement;</span><br><span class="line">    displacement = (<span class="built_in">rand</span>() % (<span class="type">int</span>)(<span class="number">2</span> * offset * <span class="number">100</span>)) / <span class="number">100.0f</span> - offset;</span><br><span class="line">    <span class="comment">// 让行星带的高度比x和z的宽度要小</span></span><br><span class="line">    <span class="type">float</span> y = displacement * <span class="number">0.4f</span>; </span><br><span class="line">    displacement = (<span class="built_in">rand</span>() % (<span class="type">int</span>)(<span class="number">2</span> * offset * <span class="number">100</span>)) / <span class="number">100.0f</span> - offset;</span><br><span class="line">    <span class="type">float</span> z = <span class="built_in">cos</span>(angle) * radius + displacement;</span><br><span class="line">    model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(x, y, z));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 缩放：在 0.05 和 0.25f 之间缩放</span></span><br><span class="line">    <span class="type">float</span> scale = (<span class="built_in">rand</span>() % <span class="number">20</span>) / <span class="number">100.0f</span> + <span class="number">0.05</span>;</span><br><span class="line">    model = glm::<span class="built_in">scale</span>(model, glm::<span class="built_in">vec3</span>(scale));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 旋转：绕着一个（半）随机选择的旋转轴向量进行随机的旋转</span></span><br><span class="line">    <span class="type">float</span> rotAngle = (<span class="built_in">rand</span>() % <span class="number">360</span>);</span><br><span class="line">    model = glm::<span class="built_in">rotate</span>(model, rotAngle, glm::<span class="built_in">vec3</span>(<span class="number">0.4f</span>, <span class="number">0.6f</span>, <span class="number">0.8f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加到矩阵的数组中</span></span><br><span class="line">    modelMatrices[i] = model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看起来可能有点吓人，但我们只是将小行星的<code>x</code>和<code>z</code>位置变换到了一个半径为radius的圆形上，并且在半径的基础上偏移了-offset到offset。我们让<code>y</code>偏移的影响更小一点，让小行星带更扁平一点。接下来，我们应用了缩放和旋转变换，并将最终的变换矩阵储存在modelMatrices中，这个数组的大小是amount。这里，我们一共生成1000个模型矩阵，每个小行星一个。</p>
<p>在加载完行星和岩石模型，并编译完着色器之后，渲染的代码看起来是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制行星</span></span><br><span class="line">myshader.<span class="built_in">use</span>();</span><br><span class="line">glm::mat4 model;</span><br><span class="line">model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">-3.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">model = glm::<span class="built_in">scale</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">4.0f</span>, <span class="number">4.0f</span>, <span class="number">4.0f</span>));</span><br><span class="line">myshader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">planet_model.<span class="built_in">Draw</span>(myshader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制小行星</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; amount; i++)</span><br><span class="line">&#123;</span><br><span class="line">    myshader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, modelMatrices[i]);</span><br><span class="line">    rock_model.<span class="built_in">Draw</span>(myshader);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>我们首先绘制了行星的模型，并对它进行位移和缩放，以适应场景，接下来，我们绘制amount数量的岩石模型。在绘制每个岩石之前，我们首先需要在着色器内设置对应的模型变换矩阵。</p>
<p>最终的结果是一个看起来像是太空的场景，环绕着行星的是看起来很自然的小行星带：</p>
<img src="/2024/09/23/27-%E5%AE%9E%E4%BE%8B%E5%8C%96/image-20240924230306105.png" class="" title="image-20240924230306105">

<p><a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/09/23/27-%E5%AE%9E%E4%BE%8B%E5%8C%96/planet_without_instancing.rar">这里</a>可以获取完整的代码</p>
<p>如果我们开始增加小行星的数量，就会发现场景不再能够流畅运行了，帧数也下降很厉害。现在，我们来尝试使用实例化渲染来渲染相同的场景。我们首先修改顶点着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec3 Normal;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">2</span>) in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">3</span>) in mat4 instanceMatrix;</span><br><span class="line"></span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line">out vec2 oTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  oTexCoord = TexCoords;</span><br><span class="line">  gl_Position = projection * view * instanceMatrix * <span class="built_in">vec4</span>(Position, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不使用模型uniform变量，改为一个mat4的顶点属性，让我们能够存储一个实例化数组的变换矩阵。顶点属性最大允许的数据大小等于一个vec4。因为一个mat4本质上是4个vec4，我们需要为这个矩阵预留4个顶点属性。因为我们将它的位置值设置为3，矩阵每一列的顶点属性位置值就是3、4、5和6。接下来，我们需要为这4个顶点属性设置属性指针，并将它们设置为实例化数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点缓冲对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, amount * <span class="built_in">sizeof</span>(glm::mat4), &amp;modelMatrices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; rock.meshes.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VAO = rock.meshes[i].VAO;</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="comment">// 顶点属性</span></span><br><span class="line">    GLsizei vec4Size = <span class="built_in">sizeof</span>(glm::vec4);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">3</span>); </span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">3</span>, <span class="number">4</span>, GL_FLOAT, GL_FALSE, <span class="number">4</span> * vec4Size, (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">4</span>); </span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">4</span>, <span class="number">4</span>, GL_FLOAT, GL_FALSE, <span class="number">4</span> * vec4Size, (<span class="type">void</span>*)(vec4Size));</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">5</span>); </span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">5</span>, <span class="number">4</span>, GL_FLOAT, GL_FALSE, <span class="number">4</span> * vec4Size, (<span class="type">void</span>*)(<span class="number">2</span> * vec4Size));</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">6</span>); </span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">6</span>, <span class="number">4</span>, GL_FLOAT, GL_FALSE, <span class="number">4</span> * vec4Size, (<span class="type">void</span>*)(<span class="number">3</span> * vec4Size));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glVertexAttribDivisor</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribDivisor</span>(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribDivisor</span>(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribDivisor</span>(<span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>注意这里我们将Mesh的VAO从私有变量改为了公有变量，让我们能够访问它的顶点数组对象。这并不是最好的解决方案，只是为了配合本小节的一个简单的改动。除此之外代码就应该很清楚了。我们告诉了OpenGL应该如何解释每个缓冲顶点属性的缓冲，并且告诉它这些顶点属性是实例化数组。接下来，我们再次使用网格的VAO，这一次使用glDrawElementsInstanced进行绘制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制小行星</span></span><br><span class="line">instanceShader.<span class="built_in">use</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; rock.meshes.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(rock.meshes[i].VAO);</span><br><span class="line">    <span class="built_in">glDrawElementsInstanced</span>(</span><br><span class="line">        GL_TRIANGLES, rock.meshes[i].indices.<span class="built_in">size</span>(), GL_UNSIGNED_INT, <span class="number">0</span>, amount</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了实例化渲染之后，我们渲染了100000个岩石，每个岩石模型有576个顶点，每帧加起来大概要绘制5700万个顶点，但性能却没有受到任何影响！<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/09/23/27-%E5%AE%9E%E4%BE%8B%E5%8C%96/instancing_planet.rar">这里</a>可以获取完整代码</p>
<img src="/2024/09/23/27-%E5%AE%9E%E4%BE%8B%E5%8C%96/image-20240925210150965.png" class="" title="image-20240925210150965">

<p>可以看到，在合适的环境下，实例化渲染能够大大增加显卡的渲染能力。正是出于这个原因，实例化渲染通常会用于渲染草、植被、粒子，以及上面这样的场景，基本上只要场景中有很多重复的形状，都能够使用实例化渲染来提高性能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/" class="post-title-link" itemprop="url">26-几何着色器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-19 19:26:54" itemprop="dateCreated datePublished" datetime="2024-09-19T19:26:54+08:00">2024-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-23 19:16:35" itemprop="dateModified" datetime="2024-09-23T19:16:35+08:00">2024-09-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在顶点和片段着色器之间有一个可选的几何着色器(Geometry Shader)，几何着色器的输入是一个图元（如点或三角形）的一组顶点。几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换，它能够将（这一组）顶点变换为完全不同的图元，并且还能生成比原来更多的顶点。</p>
<p>下面是一个几何着色器的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (points) in;</span><br><span class="line"><span class="built_in">layout</span> (line_strip, max_vertices = <span class="number">2</span>) out;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + <span class="built_in">vec4</span>(<span class="number">-0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); </span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + <span class="built_in">vec4</span>( <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在几何着色器最前面，我们需要声明从顶点着色器输入的图元类型。这需要在in关键字前声明一个布局修饰符(Layout Qualifier)。这个输入布局修饰符可以从顶点着色器接收下列任何一个图元值：</p>
<ul>
<li><code>points</code>：绘制GL_POINTS图元时（1）；</li>
<li><code>lines</code>：绘制GL_LINES或GL_LINE_STRIP时（2）；</li>
<li><code>lines_adjacency</code>：GL_LINES_ADJACENCY或GL_LINE_STRIP_ADJACENCY（4）；</li>
<li><code>triangles</code>：GL_TRIANGLES、GL_TRIANGLE_STRIP或GL_TRIANGLE_FAN（3）；</li>
<li><code>triangles_adjacency</code>：GL_TRIANGLES_ADJACENCY或GL_TRIANGLE_STRIP_ADJACENCY（6）</li>
</ul>
<p>以上是能提供给glDrawArrays渲染函数的几乎所有图元了。如果我们想要将顶点绘制为GL_TRIANGLES，我们就要将输入修饰符设置为<code>triangles</code>。括号内的数字表示的是一个图元所包含的最小顶点数。</p>
<p>接下来，我们还需要指定几何着色器输出的图元类型，这需要在out关键字前面加一个布局修饰符。输出布局修饰符也可以接受几个图元值：</p>
<ul>
<li><code>points</code></li>
<li><code>line_strip</code></li>
<li><code>triangle_strip</code></li>
</ul>
<p>有了这3个输出修饰符，我们就可以使用输入图元创建几乎任意的形状了。要生成一个三角形的话，我们将输出定义为<code>triangle_strip</code>，并输出3个顶点。</p>
<p>几何着色器希望我们设置一个它最大能够输出的顶点数量（如果你超过了这个值，OpenGL将不会绘制多出的顶点），这个也可以在out关键字的布局修饰符中设置。在上面的例子中，我们将输出一个<code>line_strip</code>，并将最大顶点数设置为2个。</p>
<p>什么是线条(Line Strip)：线条连接了一组点，形成一条连续的线，它最少要由两个点来组成。在渲染函数中每多加一个点，就会在这个点与前一个点之间形成一条新的线。如下图所示，绘制了5个顶点：</p>
<img src="/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/geometry_shader_line_strip.png" class="" title="img">

<p>如果使用的是上面定义的着色器，那么这将只能输出一条线段，因为最大顶点数等于2。</p>
<p>为了生成更有意义的结果，我们需要获取前一着色器阶段的输出。GLSL提供给了一个内建(Built-in)变量，会有如下的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in gl_Vertex</span><br><span class="line">&#123;</span><br><span class="line">    vec4  gl_Position;</span><br><span class="line">    <span class="type">float</span> gl_PointSize;</span><br><span class="line">    <span class="type">float</span> gl_ClipDistance[];</span><br><span class="line">&#125; gl_in[];</span><br></pre></td></tr></table></figure>

<p>这里，它被声明为一个接口块（Interface Block，我们在之前已经讨论过），它包含了几个变量，其中gl_Position是和顶点着色器输出非常相似的一个向量。它被声明为一个数组，因为大多数的渲染图元包含多于1个的顶点，而几何着色器的输入是一个图元的所有顶点。</p>
<p>有了顶点着色器阶段的顶点数据，就可以使用2个几何着色器函数，EmitVertex和EndPrimitive，来生成新的数据了。几何着色器希望生成输出至少一个，定义为输出的图元。在上面的例子中，至少生成一个线条图元。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + <span class="built_in">vec4</span>(<span class="number">-0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); </span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position + <span class="built_in">vec4</span>( <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次我们调用EmitVertex时，gl_Position中的向量会被添加到图元中来。当EndPrimitive被调用时，所有发射出的(Emitted)顶点都会合成为指定的输出渲染图元。在一个或多个EmitVertex调用之后重复调用EndPrimitive能够生成多个图元。在这个例子中，我们发射了两个顶点，它们从原始顶点位置平移了一段距离，之后调用了EndPrimitive，将这两个顶点合成为一个包含两个顶点的线条。</p>
<h2 id="使用几何着色器"><a href="#使用几何着色器" class="headerlink" title="使用几何着色器"></a>使用几何着色器</h2><p>为了展示几何着色器的用法，使用一个非常简单的场景，只会在标准化设备坐标的z平面上绘制四个点。这些点的坐标是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> points[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="comment">// 左上</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="comment">// 右上</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>  <span class="comment">// 左下</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>顶点着色器只需要在z平面绘制点就可以了，所以我们将使用一个最基本顶点着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec2 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos.x, aPos.y, <span class="number">0.0</span>, <span class="number">1.0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接在片段着色器中硬编码，将所有的点都输出为绿色：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为点的顶点数据生成一个VAO和一个VBO，然后使用glDrawArrays进行绘制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shader.<span class="built_in">use</span>();</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_POINTS, <span class="number">0</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>运行的结果是在黑暗的场景中有四个（很难看见的）绿点：</p>
<img src="/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/image-20240920121637994.png" class="" title="image-20240920121637994">

<p>出于学习目的，我们将会创建一个传递(Pass-through)几何着色器，它会接收一个点图元，并直接将它传递到下一个着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (points) in;</span><br><span class="line"><span class="built_in">layout</span> (points, max_vertices = <span class="number">1</span>) out;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    gl_Position = gl_in[<span class="number">0</span>].gl_Position; </span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这个几何着色器只是将它接收到的顶点位置不作修改直接发射出去，并生成一个点图元。</p>
<p>和顶点与片段着色器一样，几何着色器也需要编译和链接，直接在我们的着色器类中传入几何着色器的路径：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Shader <span class="title">myshader</span><span class="params">(<span class="string">&quot;./shader/vertex.glsl&quot;</span>, <span class="string">&quot;./shader/fragment.glsl&quot;</span>, <span class="string">&quot;./shader/geometry.glsl&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果你现在编译并运行程序，会看到和下面类似的结果：</p>
<img src="/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/image-20240920124224815.png" class="" title="image-20240920124224815">

<p>这和没使用几何着色器时是完全一样的，但既然我们仍然能够绘制这些点，那就证明几何着色器是正常工作的。</p>
<p>完整的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tool/shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui_impl_glfw.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui_impl_opengl3.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tool/stb_image.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// windows size</span></span><br><span class="line"><span class="type">int</span> SCREEN_WIDTH = <span class="number">1920</span>;</span><br><span class="line"><span class="type">int</span> SCREEN_HEIGHT = <span class="number">1080</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear color</span></span><br><span class="line">ImVec4 clear_color = <span class="built_in">ImVec4</span>(<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// camera setting</span></span><br><span class="line"><span class="type">float</span> Speed = <span class="number">0.5f</span>;</span><br><span class="line">glm::vec3 cameraPos   = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">glm::vec3 cameraFront = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glm::vec3 cameraUp    = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mouse setting</span></span><br><span class="line"><span class="type">float</span> lastX = SCREEN_WIDTH / <span class="number">2.0</span>;</span><br><span class="line"><span class="type">float</span> lastY = SCREEN_HEIGHT / <span class="number">2.0</span>;</span><br><span class="line"><span class="type">float</span> yaw   = <span class="number">-90.0f</span>;</span><br><span class="line"><span class="type">float</span> pitch =  <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">bool</span> enableMouse = <span class="literal">false</span>;</span><br><span class="line"><span class="type">float</span> fov   =  <span class="number">45.0f</span>;</span><br><span class="line"><span class="type">float</span> sensitivity = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render setting</span></span><br><span class="line"><span class="type">float</span> deltaTime = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">float</span> lastFrame = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xoffset, <span class="type">double</span> yoffset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window, <span class="type">float</span> cameraSpeed)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">loadTexture</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *path)</span></span>;</span><br><span class="line">string Shader::dirName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shader::dirName = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *glsl_version = <span class="string">&quot;#version 330&quot;</span>;</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCREEN_WIDTH, SCREEN_HEIGHT, <span class="string">&quot;MyWindow&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建imgui上下文</span></span><br><span class="line">    ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">    ImGuiIO &amp;io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">    (<span class="type">void</span>)io;</span><br><span class="line">    <span class="comment">// 设置样式</span></span><br><span class="line">    ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line">    <span class="comment">// 设置平台和渲染器</span></span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_InitForOpenGL</span>(window, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_Init</span>(glsl_version);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCREEN_WIDTH, SCREEN_HEIGHT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line">    <span class="built_in">glfwSetCursorPosCallback</span>(window, mouse_callback);</span><br><span class="line">    <span class="built_in">glfwSetScrollCallback</span>(window, scroll_callback);</span><br><span class="line"></span><br><span class="line">    <span class="function">Shader <span class="title">myshader</span><span class="params">(<span class="string">&quot;./shader/vertex.glsl&quot;</span>, <span class="string">&quot;./shader/fragment.glsl&quot;</span>, <span class="string">&quot;./shader/geometry.glsl&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> points[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VAO, VBO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(points), &amp;points, GL_STATIC_DRAW);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> currentFrame = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">        deltaTime = currentFrame - lastFrame;</span><br><span class="line">        lastFrame = currentFrame;</span><br><span class="line">        <span class="type">float</span> cameraSpeed = Speed * deltaTime;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">processInput</span>(window, cameraSpeed);</span><br><span class="line"></span><br><span class="line">        string FPS = <span class="built_in">to_string</span>(ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">        string ms = <span class="built_in">to_string</span>(<span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">        string time = <span class="built_in">to_string</span>(<span class="built_in">glfwGetTime</span>());</span><br><span class="line">        string newTitle = <span class="string">&quot;MyWindow - &quot;</span> + ms + <span class="string">&quot; ms/frame &quot;</span> + <span class="string">&quot; fps: &quot;</span> + FPS + <span class="string">&quot; render time: &quot;</span> + time + <span class="string">&quot;s&quot;</span>;</span><br><span class="line">        <span class="built_in">glfwSetWindowTitle</span>(window, newTitle.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">        ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Sence Setting&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">CollapsingHeader</span>(<span class="string">&quot;Window Settings&quot;</span>), ImGuiTreeNodeFlags_DefaultOpen)</span><br><span class="line">        &#123;</span><br><span class="line">            ImGui::<span class="built_in">SliderInt</span>(<span class="string">&quot;Width&quot;</span>, &amp;SCREEN_WIDTH, <span class="number">1</span>, <span class="number">2560</span>);</span><br><span class="line">            ImGui::<span class="built_in">SliderInt</span>(<span class="string">&quot;Height&quot;</span>, &amp;SCREEN_HEIGHT, <span class="number">1</span>, <span class="number">1440</span>);</span><br><span class="line">            ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;Clear Color&quot;</span>, (<span class="type">float</span> *)&amp;clear_color);</span><br><span class="line">            ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;Camera Speed&quot;</span>, &amp;Speed, <span class="number">0.01f</span>, <span class="number">4.0f</span>);</span><br><span class="line">            ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;Sensitivity&quot;</span>, &amp;sensitivity, <span class="number">0.01f</span>, <span class="number">0.5f</span>);</span><br><span class="line">            ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Enable Mouse&quot;</span>, &amp;enableMouse);</span><br><span class="line">        &#125;</span><br><span class="line">        ImGui::<span class="built_in">End</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glClearColor</span>(clear_color.x, clear_color.y, clear_color.z, clear_color.w);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        myshader.<span class="built_in">use</span>();</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_POINTS, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">Render</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window, <span class="type">float</span> cameraSpeed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 控制摄像机</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_W) == GLFW_PRESS <span class="keyword">or</span> <span class="built_in">glfwGetKey</span>(window, GLFW_KEY_UP) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos += cameraSpeed * cameraFront;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_S) == GLFW_PRESS <span class="keyword">or</span> <span class="built_in">glfwGetKey</span>(window, GLFW_KEY_DOWN) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos -= cameraSpeed * cameraFront;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_A) == GLFW_PRESS <span class="keyword">or</span> <span class="built_in">glfwGetKey</span>(window, GLFW_KEY_LEFT) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos -= glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_D) == GLFW_PRESS <span class="keyword">or</span> <span class="built_in">glfwGetKey</span>(window, GLFW_KEY_RIGHT) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos += glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_Q) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos += cameraSpeed * cameraUp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_E) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos -= cameraSpeed * cameraUp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_LEFT_ALT) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        enableMouse = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        enableMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 摄像机重置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_F) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraPos   = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">        cameraFront = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">        cameraUp    = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enableMouse == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> xoffset = xpos - lastX;</span><br><span class="line">        <span class="type">float</span> yoffset = lastY - ypos; </span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line"></span><br><span class="line">        xoffset *= sensitivity;</span><br><span class="line">        yoffset *= sensitivity;</span><br><span class="line"></span><br><span class="line">        yaw += xoffset;</span><br><span class="line">        pitch += yoffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">            pitch = <span class="number">89.0f</span>;</span><br><span class="line">        <span class="keyword">if</span> (pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">            pitch = <span class="number">-89.0f</span>;</span><br><span class="line"></span><br><span class="line">        glm::vec3 front;</span><br><span class="line">        front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">        front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">        front.z = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">        cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xoffset, <span class="type">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fov -= (<span class="type">float</span>)yoffset;</span><br><span class="line">    <span class="keyword">if</span> (fov &lt; <span class="number">1.0f</span>)</span><br><span class="line">        fov = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (fov &gt; <span class="number">45.0f</span>)</span><br><span class="line">        fov = <span class="number">45.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>接下来是使用几何着色器的一个例子，利用几何着色器在每个点的位置上绘制一个房子。要实现这个，我们可以将几何着色器的输出设置为triangle_strip，并绘制三个三角形：其中两个组成一个正方形，另一个用作房顶。</p>
<p>OpenGL中，三角形带(Triangle Strip)是绘制三角形更高效的方式，它使用顶点更少。在第一个三角形绘制完之后，每个后续顶点将会在上一个三角形边上生成另一个三角形：每3个临近的顶点将会形成一个三角形。如果我们一共有6个构成三角形带的顶点，那么我们会得到这些三角形：(1, 2, 3)、(2, 3, 4)、(3, 4, 5)和(4, 5, 6)，共形成4个三角形。一个三角形带至少需要3个顶点，并会生成N-2个三角形。使用6个顶点，我们创建了6-2 = 4个三角形。如下图所示：</p>
<img src="/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/geometry_shader_triangle_strip.png" class="" title="img">

<p>通过使用三角形带作为几何着色器的输出，我们可以很容易创建出需要的房子形状，只需要以正确的顺序生成3个相连的三角形就行了。下面这幅图展示了顶点绘制的顺序，蓝点代表的是输入点：</p>
<img src="/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/geometry_shader_house.png" class="" title="img">

<p>现在的几何着色器是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (points) in;</span><br><span class="line"><span class="built_in">layout</span> (triangle_strip, max_vertices = <span class="number">5</span>) out;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_house</span><span class="params">(vec4 position)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    gl_Position = position + <span class="built_in">vec4</span>(<span class="number">-0.2</span>, <span class="number">-0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 1:左下</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();   </span><br><span class="line">    gl_Position = position + <span class="built_in">vec4</span>( <span class="number">0.2</span>, <span class="number">-0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 2:右下</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    gl_Position = position + <span class="built_in">vec4</span>(<span class="number">-0.2</span>,  <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 3:左上</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    gl_Position = position + <span class="built_in">vec4</span>( <span class="number">0.2</span>,  <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 4:右上</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    gl_Position = position + <span class="built_in">vec4</span>( <span class="number">0.0</span>,  <span class="number">0.4</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 5:顶部</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="built_in">build_house</span>(gl_in[<span class="number">0</span>].gl_Position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个几何着色器生成了5个顶点，每个顶点都是原始点的位置加上一个偏移量，来组成一个大的三角形带。最终的图元会被光栅化，然后片段着色器会处理整个三角形带，最终在每个绘制的点处生成一个绿色房子：</p>
<img src="/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/image-20240920125239236.png" class="" title="image-20240920125239236">

<p>你可以看到，每个房子实际上是由3个三角形组成的——全部都是使用空间中一点来绘制的。现在我们会再给每个房子分配一个不同的颜色。为了实现这个，我们需要在顶点着色器中添加一个额外的顶点属性，表示颜色信息，将它传递至几何着色器，并再次发送到片段着色器中。</p>
<p>下面是更新后的顶点数据，并传入数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> points[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左上</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 右上</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>  <span class="comment">// 左下</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们更新顶点着色器，使用一个接口块将颜色属性发送到几何着色器中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec2 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 color;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos.x, aPos.y, <span class="number">0.0</span>, <span class="number">1.0</span>); </span><br><span class="line">    vs_out.color = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们还需要在几何着色器中声明相同的接口块（使用一个不同的接口名）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 color;</span><br><span class="line">&#125; gs_in[];</span><br></pre></td></tr></table></figure>

<p>因为几何着色器是作用于输入的一组顶点的，从顶点着色器发来输入数据总是会以数组的形式表示出来，即便我们现在只有一个顶点。并不是必须要用接口块来向几何着色器传递数据。如果顶点着色器发送的颜色向量是<code>out vec3 vColor</code>，也可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in vec3 vColor[];</span><br></pre></td></tr></table></figure>

<p>实际上，几何着色器的输入能够变得非常大，将它们合并为一个大的接口块数组会更符合逻辑一点。接下来我们还需要为下个片段着色器阶段声明一个输出颜色向量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out vec3 fColor;</span><br></pre></td></tr></table></figure>

<p>因为片段着色器只需要一个（插值的）颜色，发送多个颜色并没有什么意义。所以，fColor向量就不是一个数组，而是一个单独的向量。当发射一个顶点的时候，每个顶点将会使用最后在fColor中储存的值，来用于片段着色器的运行。我们只需要在第一个顶点发射之前，使用顶点着色器中的颜色填充fColor一次就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fColor = gs_in[<span class="number">0</span>].color; <span class="comment">// gs_in[0] 因为只有一个输入顶点</span></span><br><span class="line">gl_Position = position + <span class="built_in">vec4</span>(<span class="number">-0.2</span>, <span class="number">-0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 1:左下  </span></span><br><span class="line"><span class="built_in">EmitVertex</span>();   </span><br><span class="line">gl_Position = position + <span class="built_in">vec4</span>( <span class="number">0.2</span>, <span class="number">-0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 2:右下</span></span><br><span class="line"><span class="built_in">EmitVertex</span>();</span><br><span class="line">gl_Position = position + <span class="built_in">vec4</span>(<span class="number">-0.2</span>,  <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 3:左上</span></span><br><span class="line"><span class="built_in">EmitVertex</span>();</span><br><span class="line">gl_Position = position + <span class="built_in">vec4</span>( <span class="number">0.2</span>,  <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 4:右上</span></span><br><span class="line"><span class="built_in">EmitVertex</span>();</span><br><span class="line">gl_Position = position + <span class="built_in">vec4</span>( <span class="number">0.0</span>,  <span class="number">0.4</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 5:顶部</span></span><br><span class="line"><span class="built_in">EmitVertex</span>();</span><br><span class="line"><span class="built_in">EndPrimitive</span>();  </span><br></pre></td></tr></table></figure>

<p>所有发射出的顶点都将嵌有最后储存在fColor中的值，即顶点的颜色属性值。所有的房子都会有它们自己的颜色了：</p>
<img src="/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/image-20240923133910010.png" class="" title="image-20240923133910010">

<p><a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/geometry_shader_house.rar">这里</a>获取完整代码</p>
<h2 id="爆破物体"><a href="#爆破物体" class="headerlink" title="爆破物体"></a>爆破物体</h2><p>当我们说爆破一个物体时，并不是指要将宝贵的顶点集给炸掉，而是要将每个三角形沿着法向量的方向移动一小段时间。整个物体看起来像是沿着每个三角形的法线向量爆炸一样。使用几何着色器的好处是，无论物体有多复杂，它都能够应用上去。</p>
<p>因为我们想要沿着三角形的法向量位移每个顶点，首先需要计算这个法向量。所以要做的是计算垂直于三角形表面的向量，仅使用我们能够访问的3个顶点。如果我们能够获取两个平行于三角形表面的向量a和b，我们就能够对这两个向量进行叉乘来获取法向量。下面这个几何着色器函数做的正是这个，来使用3个输入顶点坐标来获取法向量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">GetNormal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   vec3 a = <span class="built_in">vec3</span>(gl_in[<span class="number">0</span>].gl_Position) - <span class="built_in">vec3</span>(gl_in[<span class="number">1</span>].gl_Position);</span><br><span class="line">   vec3 b = <span class="built_in">vec3</span>(gl_in[<span class="number">2</span>].gl_Position) - <span class="built_in">vec3</span>(gl_in[<span class="number">1</span>].gl_Position);</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">normalize</span>(<span class="built_in">cross</span>(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用减法获取了两个平行于三角形表面的向量a和b。因为两个向量相减能够得到这两个向量之间的差值，并且三个点都位于三角平面上，对任意两个向量相减都能够得到一个平行于平面的向量。注意，如果我们交换了cross函数中a和b的位置，我们会得到一个指向相反方向的法向量——这里的顺序很重要！</p>
<p>既然知道了如何计算法向量了，我们创建一个explode函数，使用法向量和顶点位置向量作为参数。这个函数会返回一个新的向量，它是位置向量沿着法线向量进行位移之后的结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec4 <span class="title">explode</span><span class="params">(vec4 position, vec3 normal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> magnitude = <span class="number">2.0</span>;</span><br><span class="line">    vec3 direction = normal * ((<span class="built_in">sin</span>(time) + <span class="number">1.0</span>) / <span class="number">2.0</span>) * magnitude; </span><br><span class="line">    <span class="keyword">return</span> position + <span class="built_in">vec4</span>(direction, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sin函数接收一个time参数，它根据时间返回一个-1.0到1.0之间的值。因为我们不想让物体向内偏移，所以将sin值变换到了[0, 1]的范围内。最终的结果会乘以normal向量，并且最终的direction向量会被加到位置向量上。</p>
<p>完整几何着色器是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (triangles) in;</span><br><span class="line"><span class="built_in">layout</span> (triangle_strip, max_vertices = <span class="number">3</span>) out;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec2 texCoords;</span><br><span class="line">&#125; gs_in[];</span><br><span class="line"></span><br><span class="line">out vec2 TexCoords; </span><br><span class="line"></span><br><span class="line">uniform <span class="type">float</span> time;</span><br><span class="line"></span><br><span class="line"><span class="function">vec4 <span class="title">explode</span><span class="params">(vec4 position, vec3 normal)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">GetNormal</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    vec3 normal = <span class="built_in">GetNormal</span>();</span><br><span class="line"></span><br><span class="line">    gl_Position = <span class="built_in">explode</span>(gl_in[<span class="number">0</span>].gl_Position, normal);</span><br><span class="line">    TexCoords = gs_in[<span class="number">0</span>].texCoords;</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    gl_Position = <span class="built_in">explode</span>(gl_in[<span class="number">1</span>].gl_Position, normal);</span><br><span class="line">    TexCoords = gs_in[<span class="number">1</span>].texCoords;</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    gl_Position = <span class="built_in">explode</span>(gl_in[<span class="number">2</span>].gl_Position, normal);</span><br><span class="line">    TexCoords = gs_in[<span class="number">2</span>].texCoords;</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意我们在发射顶点之前输出了对应的纹理坐标。而且别忘了在OpenGL代码中设置time变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shader.<span class="built_in">setFloat</span>(<span class="string">&quot;time&quot;</span>, <span class="built_in">glfwGetTime</span>());</span><br></pre></td></tr></table></figure>

<p>最终的效果是，3D模型看起来随着时间不断在爆破它的顶点，在这之后又回到正常状态。</p>
<img src="/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/image-20240923182239872.png" class="" title="image-20240923182239872">

<p><a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/geometry_shader_exploding.rar">这里</a>获得完整的代码</p>
<h2 id="法向量可视化"><a href="#法向量可视化" class="headerlink" title="法向量可视化"></a>法向量可视化</h2><p>当编写光照着色器时，可能会最终会得到一些奇怪的视觉输出，但又很难确定导致问题的原因。一个常见的原因就是法向量错误，这可能是由于不正确加载顶点数据、错误地将它们定义为顶点属性或在着色器中不正确地管理所导致的。我们想要的是使用某种方式来检测提供的法向量是正确的。通过几何着色器实现法向量可视化，可以用于检测法向量是否正确。</p>
<p>首先不使用几何着色器正常绘制场景。然后再次绘制场景，但这次只显示通过几何着色器生成法向量。几何着色器接收一个三角形图元，并沿着法向量生成三条线——每个顶点一个法向量。伪代码看起来会像是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shader.<span class="built_in">use</span>();</span><br><span class="line"><span class="built_in">DrawScene</span>();</span><br><span class="line">normalDisplayShader.<span class="built_in">use</span>();</span><br><span class="line"><span class="built_in">DrawScene</span>();</span><br></pre></td></tr></table></figure>

<p>这次在几何着色器中，我们使用模型提供的顶点法线，而不是自己生成，为了适配（观察和模型矩阵的）缩放和旋转，将法线变换到观察空间坐标之前，先使用法线矩阵变换一次（几何着色器接受的位置向量是观察空间坐标，所以我们应该将法向量变换到相同的空间中）。顶点着色器如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aNormal;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 normal;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>); </span><br><span class="line">    mat3 normalMatrix = <span class="built_in">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(view * model)));</span><br><span class="line">    vs_out.normal = <span class="built_in">normalize</span>(<span class="built_in">vec3</span>(<span class="built_in">vec4</span>(normalMatrix * aNormal, <span class="number">0.0</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变换后的观察空间法向量会以接口块的形式传递到下个着色器阶段。接下来，几何着色器会接收每一个顶点（包括一个位置向量和一个法向量），并在每个位置向量处绘制一个法线向量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (triangles) in;</span><br><span class="line"><span class="built_in">layout</span> (line_strip, max_vertices = <span class="number">6</span>) out;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 normal;</span><br><span class="line">&#125; gs_in[];</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> MAGNITUDE = <span class="number">0.4</span>;</span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GenerateLine</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * gl_in[index].gl_Position;</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    gl_Position = projection * (gl_in[index].gl_Position + </span><br><span class="line">                                <span class="built_in">vec4</span>(gs_in[index].normal, <span class="number">0.0</span>) * MAGNITUDE);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GenerateLine</span>(<span class="number">0</span>); <span class="comment">// 第一个顶点法线</span></span><br><span class="line">    <span class="built_in">GenerateLine</span>(<span class="number">1</span>); <span class="comment">// 第二个顶点法线</span></span><br><span class="line">    <span class="built_in">GenerateLine</span>(<span class="number">2</span>); <span class="comment">// 第三个顶点法线</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将法向量乘以了一个MAGNITUDE向量，来限制显示出的法向量长度。</p>
<p>因为法线的可视化通常都是用于调试目的，我们可以使用片段着色器，将它们显示为单色的线（如果你愿意也可以是非常好看的线）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在运行的效果如下：</p>
<img src="/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/image-20240923183406635.png" class="" title="image-20240923183406635">

<p>在主程序中同时使用两个着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">Shader <span class="title">normalshader</span><span class="params">(<span class="string">&quot;./shader/normalvertex.glsl&quot;</span>, <span class="string">&quot;./shader/normalfragment.glsl&quot;</span>, <span class="string">&quot;./shader/normalgeometry.glsl&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Shader <span class="title">myshader</span><span class="params">(<span class="string">&quot;./shader/vertex.glsl&quot;</span>, <span class="string">&quot;./shader/fragment.glsl&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Model <span class="title">myModel</span><span class="params">(<span class="string">&quot;./static/model/nanosuit/nanosuit.obj&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        myshader.<span class="built_in">use</span>();</span><br><span class="line">        myshader.<span class="built_in">setFloat</span>(<span class="string">&quot;time&quot;</span>, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">        myshader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">        myshader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">        myshader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">        myModel.<span class="built_in">Draw</span>(myshader);</span><br><span class="line"></span><br><span class="line">        normalshader.<span class="built_in">use</span>();</span><br><span class="line">        normalshader.<span class="built_in">setFloat</span>(<span class="string">&quot;time&quot;</span>, <span class="built_in">glfwGetTime</span>());</span><br><span class="line">        normalshader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">        normalshader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">        normalshader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">        myModel.<span class="built_in">Draw</span>(normalshader);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>最终运行结果如下：</p>
<img src="/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/image-20240923185733015.png" class="" title="image-20240923185733015">

<p><a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/09/19/26-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/geometry_shader_normal.rar">这里</a>获取完整的代码</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/27/25-%E9%AB%98%E7%BA%A7GLSL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/27/25-%E9%AB%98%E7%BA%A7GLSL/" class="post-title-link" itemprop="url">25-高级GLSL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-27 17:53:50" itemprop="dateCreated datePublished" datetime="2024-03-27T17:53:50+08:00">2024-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-19 19:25:45" itemprop="dateModified" datetime="2024-09-19T19:25:45+08:00">2024-09-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="高级数据"><a href="#高级数据" class="headerlink" title="高级数据"></a>高级数据</h2><p>OpenGL中的缓冲只是一个管理特定内存块的对象，没有其它功能。将它绑定到一个缓冲目标(Buffer Target)时，它才有意义。当绑定一个缓冲到GL_ARRAY_BUFFER时，它就是一个顶点数组缓冲，但也可以将其绑定到GL_ELEMENT_ARRAY_BUFFER，它就是一个元素数组缓冲对象。OpenGL内部会为每个目标储存一个缓冲，并且会根据目标的不同，以不同的方式处理缓冲。</p>
<p>到目前为止，一直是调用glBufferData函数来填充缓冲对象所管理的内存，这个函数会分配一块内存，并将数据添加到这块内存中。如果将它的<code>data</code>参数设置为<code>NULL</code>，那么这个函数将只会分配内存，但不进行填充。这需要预留(Reserve)特定大小的内存，之后回到这个缓冲一点一点填充。</p>
<p>除了使用一次函数调用填充整个缓冲之外，也可以使用glBufferSubData，填充缓冲的特定区域。这个函数需要一个缓冲目标、一个偏移量、数据的大小和数据本身作为它的参数。这个函数不同的地方在于，可以提供一个偏移量，指定从何处开始填充这个缓冲。要注意的是，缓冲需要有足够的已分配内存，所以对一个缓冲调用glBufferSubData之前必须要先调用glBufferData。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">24</span>, <span class="built_in">sizeof</span>(data), &amp;data); <span class="comment">// 范围： [24, 24 + sizeof(data)]</span></span><br></pre></td></tr></table></figure>

<p>将数据导入缓冲的另外一种方法是，请求缓冲内存的指针，直接将数据复制到缓冲当中。通过调用glMapBuffer函数，OpenGL会返回当前绑定缓冲的内存指针，供我们操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> data[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">-0.35f</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="comment">// 获取指针</span></span><br><span class="line"><span class="type">void</span> *ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class="line"><span class="comment">// 复制数据到内存</span></span><br><span class="line"><span class="built_in">memcpy</span>(ptr, data, <span class="built_in">sizeof</span>(data));</span><br><span class="line"><span class="comment">// 记得告诉OpenGL我们不再需要这个指针了</span></span><br><span class="line"><span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br></pre></td></tr></table></figure>

<p>当使用glUnmapBuffer函数，告诉OpenGL已经完成指针操作之后，OpenGL就会知道已经完成了。在解除映射(Unmapping)之后，指针将会不再可用，并且如果OpenGL能够成功将数据映射到缓冲中，这个函数将会返回GL_TRUE。</p>
<p>如果要直接映射数据到缓冲，而不事先将其存储到临时内存中，glMapBuffer这个函数会很有用。比如说，可以从文件中读取数据，并直接将它们复制到缓冲内存中。</p>
<p>通过使用glVertexAttribPointer，能够指定顶点数组缓冲内容的属性布局。在顶点数组缓冲中，对属性进行了交错(Interleave)处理，也就是说，将每一个顶点的位置、法线和/或纹理坐标紧密放置在一起。将每一种属性类型的向量数据打包(Batch)为一个大的区块，而不是对它们进行交错储存。与交错布局123123123123不同，我们将采用分批(Batched)的方式111122223333。</p>
<p>当从文件中加载顶点数据的时候，通常获取到的是一个位置数组、一个法线数组和/或一个纹理坐标数组。需要花点力气才能将这些数组转化为一个大的交错数据数组。使用分批的方式可以很容易使用glBufferSubData函数实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = &#123; ... &#125;;</span><br><span class="line"><span class="type">float</span> normals[] = &#123; ... &#125;;</span><br><span class="line"><span class="type">float</span> tex[] = &#123; ... &#125;;</span><br><span class="line"><span class="comment">// 填充缓冲</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">0</span>, <span class="built_in">sizeof</span>(positions), &amp;positions);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), <span class="built_in">sizeof</span>(normals), &amp;normals);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions) + <span class="built_in">sizeof</span>(normals), <span class="built_in">sizeof</span>(tex), &amp;tex);</span><br></pre></td></tr></table></figure>

<p>这样子就能直接将属性数组作为一个整体传递给缓冲，而不需要事先处理它们了。仍可以将它们合并为一个大的数组，再使用glBufferData来填充缓冲，但对于这种工作，使用glBufferSubData会更合适一点。</p>
<p>还需要更新顶点属性指针来反映这些改变：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);  </span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="built_in">sizeof</span>(positions)));  </span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(</span><br><span class="line">  <span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="built_in">sizeof</span>(positions) + <span class="built_in">sizeof</span>(normals)));</span><br></pre></td></tr></table></figure>

<p>注意<code>stride</code>参数等于顶点属性的大小，因为下一个顶点属性向量能在3个（或2个）分量之后找到。</p>
<p>使用哪种方法都不会对OpenGL有什么影响，它只是设置顶点属性的一种更整洁的方式。具体使用的方法将完全取决于你的喜好与程序类型。</p>
<p>当缓冲填充好数据之后，可能会想与其它的缓冲共享其中的数据，或者想要将缓冲的内容复制到另一个缓冲当中。glCopyBufferSubData能够从一个缓冲中复制数据到另一个缓冲中。这个函数的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glCopyBufferSubData</span><span class="params">(GLenum readtarget, GLenum writetarget, GLintptr readoffset,</span></span></span><br><span class="line"><span class="params"><span class="function">                         GLintptr writeoffset, GLsizeiptr size)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>readtarget</code>和<code>writetarget</code>参数需要填入复制源和复制目标的缓冲目标。比如说，可以将VERTEX_ARRAY_BUFFER缓冲复制到VERTEX_ELEMENT_ARRAY_BUFFER缓冲，分别将这些缓冲目标设置为读和写的目标。当前绑定到这些缓冲目标的缓冲将会被影响到。</p>
<p>不能同时将两个缓冲绑定到同一个缓冲目标上。正是出于这个原因，OpenGL提供给另外两个缓冲目标，叫做GL_COPY_READ_BUFFER和GL_COPY_WRITE_BUFFER。接下来就可以将需要的缓冲绑定到这两个缓冲目标上，并将这两个目标作为<code>readtarget</code>和<code>writetarget</code>参数。接下来glCopyBufferSubData会从<code>readtarget</code>中读取<code>size</code>大小的数据，并将其写入<code>writetarget</code>缓冲的<code>writeoffset</code>偏移量处：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_READ_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(vertexData));</span><br></pre></td></tr></table></figure>

<p>也可以只将<code>writetarget</code>缓冲绑定为新的缓冲目标类型之一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(vertexData));</span><br></pre></td></tr></table></figure>

<h2 id="GLSL的内建变量"><a href="#GLSL的内建变量" class="headerlink" title="GLSL的内建变量"></a>GLSL的内建变量</h2><p>着色器都是最简化的，如果需要当前着色器以外地方的数据的话，必须要将数据传进来。我们已经学会使用顶点属性、uniform和采样器来完成这一任务了。除此之外，GLSL还定义了另外几个以<code>gl_</code>为前缀的变量，它们能提供给更多的方式来读取/写入数据。如果想知道所有的内建变量的话，请查看OpenGL的<a target="_blank" rel="noopener" href="http://www.opengl.org/wiki/Built-in_Variable_(GLSL)">wiki</a>。</p>
<h3 id="顶点着色器变量"><a href="#顶点着色器变量" class="headerlink" title="顶点着色器变量"></a>顶点着色器变量</h3><p>我们已经使用过gl_Position了，它是顶点着色器的裁剪空间输出位置向量。如果想在屏幕上显示任何东西，在顶点着色器中设置gl_Position是必须的步骤。这已经是它的全部功能了。</p>
<h4 id="gl-PointSize"><a href="#gl-PointSize" class="headerlink" title="gl_PointSize"></a>gl_PointSize</h4><p>如果使用GL_POINTS，每一个顶点都是一个图元，都会被渲染为一个点。可以通过OpenGL的glPointSize函数来设置渲染出来的点的大小，但也可以在顶点着色器中修改这个值。</p>
<p>GLSL定义了一个叫做gl_PointSize输出变量，它是一个float变量，可以使用它来设置点的宽高（像素）。在顶点着色器中修改点的大小的话，就能对每个顶点设置不同的值了。</p>
<p>在顶点着色器中修改点大小的功能默认是禁用的，如果需要启用它，可以使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_PROGRAM_POINT_SIZE);</span><br></pre></td></tr></table></figure>

<p>将点的大小设置为裁剪空间位置的z值，也就是顶点距观察者的距离。点的大小会随着观察者距顶点距离变远而增大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);    </span><br><span class="line">    gl_PointSize = gl_Position.z;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用一个简单的场景实例，修改绘制模式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_POINTS, <span class="number">0</span>, <span class="number">36</span>);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<img src="/2024/03/27/25-%E9%AB%98%E7%BA%A7GLSL/image-20240914114001663.png" class="" title="image-20240914114001663">

<p><a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/03/27/25-%E9%AB%98%E7%BA%A7GLSL/advanced_GLSL_gl_PointSize.rar">这里</a>获取完整代码。</p>
<h4 id="gl-VertexID"><a href="#gl-VertexID" class="headerlink" title="gl_VertexID"></a>gl_VertexID</h4><p>gl_Position和gl_PointSize都是输出变量，因为它们的值是作为顶点着色器的输出被读取的。可以对它们进行写入，来改变结果。顶点着色器还提供了一个只能进行读取的输入变量gl_VertexID。</p>
<p>整型变量gl_VertexID储存了正在绘制顶点的当前ID。当（使用glDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。当（使用glDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始已处理顶点的数量。</p>
<h3 id="片段着色器变量"><a href="#片段着色器变量" class="headerlink" title="片段着色器变量"></a>片段着色器变量</h3><p>在片段着色器中，也能访问到一些变量。GLSL提供了两个输入变量：gl_FragCoord和gl_FrontFacing。</p>
<h4 id="gl-FragCoord"><a href="#gl-FragCoord" class="headerlink" title="gl_FragCoord"></a>gl_FragCoord</h4><p>在深度测试的时候，已经使用过gl_FragCoord很多次了，因为gl_FragCoord的z分量等于对应片段的深度值。然而，也能使用它的x和y分量来实现一些有趣的效果。</p>
<p>gl_FragCoord的x和y分量是片段的窗口空间(Window-space)坐标，其原点为窗口的左下角。我们已经使用glViewport设定了一个800x600的窗口了，所以片段窗口空间坐标的x分量将在0到800之间，y分量在0到600之间。</p>
<p>通过利用片段着色器，可以根据片段的窗口坐标，计算出不同的颜色。gl_FragCoord的一个常见用处是用于对比不同片段计算的视觉输出效果，这在技术演示中可以经常看到。比如说，我们能够将屏幕分成两部分，在窗口的左侧渲染一种输出，在窗口的右侧渲染另一种输出。下面这个例子片段着色器会根据窗口坐标输出不同的颜色：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="keyword">if</span>(gl_FragCoord.x &lt; <span class="number">400</span>)</span><br><span class="line">        FragColor = <span class="built_in">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        FragColor = <span class="built_in">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为窗口的宽度是800。当一个像素的x坐标小于400时，它一定在窗口的左侧，所以我们给它一个不同的颜色。</p>
<img src="/2024/03/27/25-%E9%AB%98%E7%BA%A7GLSL/image-20240914122146864.png" class="" title="image-20240914122146864">

<p><a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/03/27/25-%E9%AB%98%E7%BA%A7GLSL/advanced_GLSL_gl_FragCoord.rar">这里</a>获取完整代码。</p>
<p>现在可以计算出两个完全不同的片段着色器结果，并将它们显示在窗口的两侧，可以将它用于不同的光照的同屏对比。</p>
<h4 id="gl-FrontFacing"><a href="#gl-FrontFacing" class="headerlink" title="gl_FrontFacing"></a>gl_FrontFacing</h4><p>gl_FrontFacing变量是一个bool，如果当前片段是正向面的一部分那么就是<code>true</code>，否则就是<code>false</code>。比如，可以创建一个立方体，在内部和外部使用不同的纹理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D frontTexture;</span><br><span class="line">uniform sampler2D backTexture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="keyword">if</span>(gl_FrontFacing)</span><br><span class="line">        FragColor = <span class="built_in">texture</span>(frontTexture, TexCoords);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        FragColor = <span class="built_in">texture</span>(backTexture, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们往箱子里面看，就能看到使用的是不同的纹理。</p>
<img src="/2024/03/27/25-%E9%AB%98%E7%BA%A7GLSL/image-20240918141803844.png" class="" title="image-20240918141803844">

<p>注意，如果开启了面剔除，就看不到箱子内部的面了。<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/03/27/25-%E9%AB%98%E7%BA%A7GLSL/advanced_GLSL_gl_FrontFacing.rar">这里</a>获取完整代码。</p>
<h4 id="gl-FragDepth"><a href="#gl-FragDepth" class="headerlink" title="gl_FragDepth"></a>gl_FragDepth</h4><p>gl_FragCoord能让我们读取当前片段的窗口空间坐标，并获取它的深度值，但它是一个只读(Read-only)变量。不能修改片段的窗口空间坐标，但实际上是可以修改片段的深度值的。GLSL提供了一个输出变量gl_FragDepth，可以使用它来在着色器内设置片段的深度值。</p>
<p>要想设置深度值，直接写入一个0.0到1.0之间的float值到输出变量就可以了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl_FragDepth = <span class="number">0.0</span>; <span class="comment">// 这个片段现在的深度值为 0.0</span></span><br></pre></td></tr></table></figure>

<p>如果着色器没有写入值到gl_FragDepth，它会自动取用<code>gl_FragCoord.z</code>的值。</p>
<p>只要我们在片段着色器中对gl_FragDepth进行写入，OpenGL就会禁用所有的提前深度测试(Early Depth Testing)。因为，OpenGL无法在片段着色器运行之前得知片段的深度值，片段着色器可能会完全修改这个值。</p>
<p>在写入gl_FragDepth时，就需要考虑到它所带来的性能影响。从OpenGL 4.2起，仍可以对两者进行一定的调和，在片段着色器的顶部使用深度条件(Depth Condition)重新声明gl_FragDepth变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">layout</span> (depth_&lt;condition&gt;) out <span class="type">float</span> gl_FragDepth;</span><br></pre></td></tr></table></figure>

<p><code>condition</code>可以为下面的值：</p>
<table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>any</code></td>
<td align="left">默认值。提前深度测试是禁用的，你会损失很多性能</td>
</tr>
<tr>
<td align="left"><code>greater</code></td>
<td align="left">你只能让深度值比<code>gl_FragCoord.z</code>更大</td>
</tr>
<tr>
<td align="left"><code>less</code></td>
<td align="left">你只能让深度值比<code>gl_FragCoord.z</code>更小</td>
</tr>
<tr>
<td align="left"><code>unchanged</code></td>
<td align="left">如果你要写入<code>gl_FragDepth</code>，你将只能写入<code>gl_FragCoord.z</code>的值</td>
</tr>
</tbody></table>
<p>通过将深度条件设置为<code>greater</code>或者<code>less</code>，OpenGL就能假设你只会写入比当前片段深度值更大或者更小的值了。这样子的话，当深度值比片段的深度值要小的时候，OpenGL仍是能够进行提前深度测试的。</p>
<p>下面这个例子中，我们对片段的深度值进行了递增，但仍然也保留了一些提前深度测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 420 core <span class="comment">// 注意GLSL的版本！</span></span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"><span class="built_in">layout</span> (depth_greater) out <span class="type">float</span> gl_FragDepth;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(<span class="number">1.0</span>);</span><br><span class="line">    gl_FragDepth = gl_FragCoord.z + <span class="number">0.1</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>注意这个特性只在OpenGL 4.2版本或以上才提供。</p>
<h2 id="接口块"><a href="#接口块" class="headerlink" title="接口块"></a>接口块</h2><p>到目前为止，每当希望从顶点着色器向片段着色器发送数据时，我们都声明了几个对应的输入/输出变量。但当程序变得更大时，你希望发送的可能就不只是几个变量了，它还可能包括数组和结构体。</p>
<p>为了帮助我们管理这些变量，GLSL提供了一个叫做接口块(Interface Block)的东西，来方便组合这些变量。接口块的声明和struct的声明有点相像，不同的是，现在根据它是一个输入还是输出块(Block)，使用in或out关键字来定义的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec2 aTexCoords;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line">out VS_OUT</span><br><span class="line">&#123;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);    </span><br><span class="line">    vs_out.TexCoords = aTexCoords;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>我们声明了一个叫做vs_out的接口块，它打包了我们希望发送到下一个着色器中的所有输出变量。之后，我们还需要在下一个着色器，即片段着色器，中定义一个输入接口块。块名(Block Name)应该是和着色器中一样的（VS_OUT），但实例名(Instance Name)（顶点着色器中用的是vs_out）可以是随意的，但要避免使用误导性的名称，比如对实际上包含输入变量的接口块命名为vs_out。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT</span><br><span class="line">&#123;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D texture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(texture, fs_in.TexCoords);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要两个接口块的名字一样，它们对应的输入和输出将会匹配起来。</p>
<h2 id="Uniform缓冲对象"><a href="#Uniform缓冲对象" class="headerlink" title="Uniform缓冲对象"></a>Uniform缓冲对象</h2><p>当使用多于一个的着色器时，尽管大部分的uniform变量都是相同的，我们还是需要不断地设置它们，所以为什么要这么麻烦地重复设置它们呢？</p>
<p>OpenGL为我们提供了一个叫做Uniform缓冲对象(Uniform Buffer Object)的工具，它允许我们定义一系列在多个着色器程序中相同的全局Uniform变量。当使用Uniform缓冲对象的时候，我们只需要设置相关的uniform一次。当然，我们仍需要手动设置每个着色器中不同的uniform。并且创建和配置Uniform缓冲对象会有一点繁琐。</p>
<p>因为Uniform缓冲对象仍是一个缓冲，我们可以使用glGenBuffers来创建它，将它绑定到GL_UNIFORM_BUFFER缓冲目标，并将所有相关的uniform数据存入缓冲。首先，我们将使用一个简单的顶点着色器，将projection和view矩阵存储到Uniform块(Uniform Block)中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span> (std140) uniform Matrices</span><br><span class="line">&#123;</span><br><span class="line">    mat4 projection;</span><br><span class="line">    mat4 view;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下我们都会在每个渲染迭代中，对每个着色器设置projection和view Uniform矩阵，现在我们只需要存储这些矩阵一次就可以了。</p>
<p>这里，我们声明了一个叫做Matrices的Uniform块，它储存了两个4x4矩阵。Uniform块中的变量可以直接访问，不需要加块名作为前缀。接下来，在OpenGL代码中将这些矩阵值存入缓冲中，每个声明了这个Uniform块的着色器都能够访问这些矩阵。</p>
<p><code>layout (std140)</code>的意思是，当前定义的Uniform块对它的内容使用一个特定的内存布局。这个语句设置了Uniform块布局(Uniform Block Layout)。</p>
<h3 id="Uniform块布局"><a href="#Uniform块布局" class="headerlink" title="Uniform块布局"></a>Uniform块布局</h3><p>Uniform块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存。因为这块内存并不会保存它具体保存的是什么类型的数据，我们还需要告诉OpenGL内存的哪一部分对应着着色器中的哪一个uniform变量。</p>
<p>假设着色器中有以下的这个Uniform块：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">layout</span> (std140) uniform ExampleBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> value;</span><br><span class="line">    vec3  vector;</span><br><span class="line">    mat4  matrix;</span><br><span class="line">    <span class="type">float</span> values[<span class="number">3</span>];</span><br><span class="line">    <span class="type">bool</span>  boolean;</span><br><span class="line">    <span class="type">int</span>   integer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们需要知道的是每个变量的大小（字节）和（从块起始位置的）偏移量。每个元素的大小都是在OpenGL中有清楚地声明的，而且直接对应C++数据类型，其中向量和矩阵都是大的float数组。OpenGL没有声明的是这些变量间的间距(Spacing)。这允许硬件能够在它认为合适的位置放置变量。</p>
<p>默认情况下，GLSL会使用一个叫做共享(Shared)布局的Uniform内存布局，共享是因为一旦硬件定义了偏移量，它们在多个程序中是共享并一致的。使用共享布局时，只要变量的顺序保持不变，GLSL可以为了优化而对uniform变量的位置进行变动。因为我们无法知道每个uniform变量的偏移量，也不知道如何填充Uniform缓冲。</p>
<p>虽然共享布局给了很多节省空间的优化，但需要查询每个uniform变量的偏移量，这会产生非常多的工作量。通常的做法是，不使用共享布局，而是使用std140布局。std140布局声明了每个变量的偏移量都是由一系列规则所决定的，这显式地声明了每个变量类型的内存布局，我们可以手动计算出每个变量的偏移量。</p>
<p>每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在Uniform块中所占据的空间（包括填充量(Padding)），这个基准对齐量是使用std140的规则计算出来的。对每个变量，再计算它的对齐偏移量(Aligned Offset)，一个变量的对齐字节偏移量必须等于基准对齐量的倍数。</p>
<p>布局规则的原文可以在OpenGL的Uniform缓冲规范<a target="_blank" rel="noopener" href="http://www.opengl.org/registry/specs/ARB/uniform_buffer_object.txt">这里</a>找到，下面是一些最常见的规则。GLSL中的每个变量，比如说int、float和bool，都被定义为4字节量。每4个字节将会用一个<code>N</code>来表示。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">布局规则</th>
</tr>
</thead>
<tbody><tr>
<td align="left">标量，比如int和bool</td>
<td align="left">每个标量的基准对齐量为N。</td>
</tr>
<tr>
<td align="left">向量</td>
<td align="left">2N或者4N。这意味着vec3的基准对齐量为4N。</td>
</tr>
<tr>
<td align="left">标量或向量的数组</td>
<td align="left">每个元素的基准对齐量与vec4的相同。</td>
</tr>
<tr>
<td align="left">矩阵</td>
<td align="left">储存为列向量的数组，每个向量的基准对齐量与vec4的相同。</td>
</tr>
<tr>
<td align="left">结构体</td>
<td align="left">等于所有元素根据规则计算后的大小，但会填充到vec4大小的倍数。</td>
</tr>
</tbody></table>
<p>使用之前ExampleBlock的Uniform块，并使用std140布局计算出每个成员的对齐偏移量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">layout</span> (std140) uniform ExampleBlock</span><br><span class="line">&#123;</span><br><span class="line">                     <span class="comment">// 基准对齐量       // 对齐偏移量</span></span><br><span class="line">    <span class="type">float</span> value;     <span class="comment">// 4               // 0 </span></span><br><span class="line">    vec3 vector;     <span class="comment">// 16              // 16  (必须是16的倍数，所以 4-&gt;16)</span></span><br><span class="line">    mat4 matrix;     <span class="comment">// 16              // 32  (列 0)</span></span><br><span class="line">                     <span class="comment">// 16              // 48  (列 1)</span></span><br><span class="line">                     <span class="comment">// 16              // 64  (列 2)</span></span><br><span class="line">                     <span class="comment">// 16              // 80  (列 3)</span></span><br><span class="line">    <span class="type">float</span> values[<span class="number">3</span>]; <span class="comment">// 16              // 96  (values[0])</span></span><br><span class="line">                     <span class="comment">// 16              // 112 (values[1])</span></span><br><span class="line">                     <span class="comment">// 16              // 128 (values[2])</span></span><br><span class="line">    <span class="type">bool</span> boolean;    <span class="comment">// 4               // 144</span></span><br><span class="line">    <span class="type">int</span> integer;     <span class="comment">// 4               // 148</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>虽然std140布局不是最高效的布局，但它保证了内存布局在每个声明了这个Uniform块的程序中是一致的。</p>
<p>除此之外还可以选择两个布局，但它们都需要我们在填充缓冲之前先查询每个偏移量。一个是<code>shared</code>布局，还有一个布局是<code>packed</code>。当使用紧凑(Packed)布局时，是不能保证这个布局在每个程序中保持不变的（即非共享），因为它允许编译器去将uniform变量从Uniform块中优化掉，这导致在每个着色器中都可能是不同的。</p>
<h3 id="使用Uniform缓冲"><a href="#使用Uniform缓冲" class="headerlink" title="使用Uniform缓冲"></a>使用Uniform缓冲</h3><p>首先，我们需要调用glGenBuffers，创建一个Uniform缓冲对象。然后，需要将它绑定到GL_UNIFORM_BUFFER目标，并调用glBufferData，分配足够的内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uboExampleBlock;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;uboExampleBlock);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboExampleBlock);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_UNIFORM_BUFFER, <span class="number">152</span>, <span class="literal">NULL</span>, GL_STATIC_DRAW); <span class="comment">// 分配152字节的内存</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>现在，每当我们需要对缓冲更新或者插入数据，都会绑定到uboExampleBlock，并使用glBufferSubData来更新它的内存。我们只需要更新这个Uniform缓冲一次，所有使用这个缓冲的着色器就都使用的是更新后的数据了。但是，如何才能让OpenGL知道哪个Uniform缓冲对应的是哪个Uniform块呢？</p>
<p>在OpenGL上下文中，定义了一些绑定点(Binding Point)，可以将一个Uniform缓冲链接至它。在创建Uniform缓冲之后，将它绑定到其中一个绑定点上，并将着色器中的Uniform块绑定到相同的绑定点，把它们连接到一起。下图展示了这个过程：</p>
<img src="/2024/03/27/25-%E9%AB%98%E7%BA%A7GLSL/advanced_glsl_binding_points.png" class="" title="img">

<p>可以看到，我们可以绑定多个Uniform缓冲到不同的绑定点上。因为着色器A和着色器B都有一个链接到绑定点0的Uniform块，它们的Uniform块将会共享相同的uniform数据，uboMatrices，前提条件是两个着色器都定义了相同的Matrices Uniform块。</p>
<p>为了将Uniform块绑定到一个特定的绑定点中，需要调用glUniformBlockBinding函数，它的第一个参数是一个程序对象，之后是一个Uniform块索引和链接到的绑定点。Uniform块索引是着色器中已定义Uniform块的位置值索引，可以通过调用glGetUniformBlockIndex来获取，它接受一个程序对象和Uniform块的名称。用以下方式将图示中的Lights Uniform块链接到绑定点2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> lights_index = <span class="built_in">glGetUniformBlockIndex</span>(shaderA.ID, <span class="string">&quot;Lights&quot;</span>);   </span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderA.ID, lights_index, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><em>注意我们需要对每个着色器重复这一步骤。</em></p>
<p>从OpenGL 4.2版本起，你也可以添加一个布局标识符，显式地将Uniform块的绑定点储存在着色器中，这样就不用再调用glGetUniformBlockIndex和glUniformBlockBinding了。下面的代码显式地设置了Lights Uniform块的绑定点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">layout</span>(std140, binding = <span class="number">2</span>) uniform Lights &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>还需要绑定Uniform缓冲对象到相同的绑定点上，可以使用glBindBufferBase或glBindBufferRange来完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindBufferBase</span>(GL_UNIFORM_BUFFER, <span class="number">2</span>, uboExampleBlock); </span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="built_in">glBindBufferRange</span>(GL_UNIFORM_BUFFER, <span class="number">2</span>, uboExampleBlock, <span class="number">0</span>, <span class="number">152</span>);</span><br></pre></td></tr></table></figure>

<p>glBindbufferBase需要一个目标，一个绑定点索引和一个Uniform缓冲对象作为它的参数。这个函数将uboExampleBlock链接到绑定点2上，自此，绑定点的两端都链接上了。也可以使用glBindBufferRange函数，它需要一个附加的偏移量和大小参数，这样可以绑定Uniform缓冲的特定一部分到绑定点中。通过使用glBindBufferRange函数，可以让多个不同的Uniform块绑定到同一个Uniform缓冲对象上。</p>
<p>现在，所有的东西都配置完毕了，可以开始向Uniform缓冲中添加数据了。可以使用glBufferSubData函数，用一个字节数组添加所有的数据，或者更新缓冲的一部分。要想更新uniform变量boolean，可以用以下方式更新Uniform缓冲对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboExampleBlock);</span><br><span class="line"><span class="type">int</span> b = <span class="literal">true</span>; <span class="comment">// GLSL中的bool是4字节的，所以我们将它存为一个integer</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_UNIFORM_BUFFER, <span class="number">144</span>, <span class="number">4</span>, &amp;b); </span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>同样的操作也能应用到Uniform块中其它的uniform变量上，但需要使用不同的范围参数。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>看看之前所有的代码例子，我们不断地在使用3个矩阵：投影、观察和模型矩阵。在所有的这些矩阵中，只有模型矩阵会频繁变动。如果我们有多个着色器使用了这同一组矩阵，那么使用Uniform缓冲对象可能会更好。</p>
<p>将投影和模型矩阵存储到一个叫做Matrices的Uniform块中。因为模型矩阵在不同的着色器中会不断改变，所以使用Uniform缓冲对象并不会带来什么好处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span> (std140) uniform Matrices</span><br><span class="line">&#123;</span><br><span class="line">    mat4 projection;</span><br><span class="line">    mat4 view;</span><br><span class="line">&#125;;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，会显示4个立方体，每个立方体都是使用不同的着色器程序渲染的。这4个着色器程序将使用相同的顶点着色器，使用不同的片段着色器，每个着色器会输出不同的颜色。</p>
<p>首先，将顶点着色器的Uniform块设置为绑定点0。<em>注意需要对每个着色器都设置一遍。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uniformBlockIndexRed    = <span class="built_in">glGetUniformBlockIndex</span>(shaderRed.ID, <span class="string">&quot;Matrices&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uniformBlockIndexGreen  = <span class="built_in">glGetUniformBlockIndex</span>(shaderGreen.ID, <span class="string">&quot;Matrices&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uniformBlockIndexBlue   = <span class="built_in">glGetUniformBlockIndex</span>(shaderBlue.ID, <span class="string">&quot;Matrices&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uniformBlockIndexYellow = <span class="built_in">glGetUniformBlockIndex</span>(shaderYellow.ID, <span class="string">&quot;Matrices&quot;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderRed.ID,    uniformBlockIndexRed, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderGreen.ID,  uniformBlockIndexGreen, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderBlue.ID,   uniformBlockIndexBlue, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderYellow.ID, uniformBlockIndexYellow, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>接下来，创建Uniform缓冲对象，并将其绑定到绑定点0：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> uboMatrices</span></span><br><span class="line"><span class="function"><span class="title">glGenBuffers</span><span class="params">(<span class="number">1</span>, &amp;uboMatrices)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboMatrices);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_UNIFORM_BUFFER, <span class="number">2</span> * <span class="built_in">sizeof</span>(glm::mat4), <span class="literal">NULL</span>, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBufferRange</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>, uboMatrices, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">sizeof</span>(glm::mat4));</span><br></pre></td></tr></table></figure>

<p>首先我们为缓冲分配了足够的内存，它等于glm::mat4大小的两倍。GLM矩阵类型的大小直接对应于GLSL中的mat4。接下来，将缓冲中的特定范围（在这里是整个缓冲）链接到绑定点0。</p>
<p>剩余的就是填充这个缓冲了。如果我们将投影矩阵的视野(Field of View)值保持不变，只需将它插入到缓冲中一次。因为已经为缓冲对象分配了足够的内存，可以使用glBufferSubData在进入渲染循环之前存储投影矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), (<span class="type">float</span>)width/(<span class="type">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboMatrices);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>, <span class="built_in">sizeof</span>(glm::mat4), glm::<span class="built_in">value_ptr</span>(projection));</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>将投影矩阵储存在Uniform缓冲的前半部分。在每次渲染迭代中绘制物体之前，我们会将观察矩阵更新到缓冲的后半部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view = camera.<span class="built_in">GetViewMatrix</span>();           </span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboMatrices);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_UNIFORM_BUFFER, <span class="built_in">sizeof</span>(glm::mat4), <span class="built_in">sizeof</span>(glm::mat4), glm::<span class="built_in">value_ptr</span>(view));</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>Uniform缓冲对象的部分就结束了。每个包含了Matrices这个Uniform块的顶点着色器将会包含储存在uboMatrices中的数据。所以，如果现在要用4个不同的着色器绘制4个立方体，它们的投影和观察矩阵都会是一样的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindVertexArray</span>(cubeVAO);</span><br><span class="line">shaderRed.<span class="built_in">use</span>();</span><br><span class="line">glm::mat4 model;</span><br><span class="line">model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">-0.75f</span>, <span class="number">0.75f</span>, <span class="number">0.0f</span>));  <span class="comment">// 移动到左上角</span></span><br><span class="line">shaderRed.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);        </span><br><span class="line"><span class="comment">// ... 绘制绿色立方体</span></span><br><span class="line"><span class="comment">// ... 绘制蓝色立方体</span></span><br><span class="line"><span class="comment">// ... 绘制黄色立方体 </span></span><br></pre></td></tr></table></figure>

<p>唯一需要设置的uniform只剩model uniform了。在像这样的场景中使用Uniform缓冲对象会让我们在每个着色器中都剩下一些uniform调用。最终的结果会是这样的：</p>
<img src="/2024/03/27/25-%E9%AB%98%E7%BA%A7GLSL/image-20240919185115661.png" class="" title="image-20240919185115661">

<p>因为修改了模型矩阵，每个立方体都移动到了窗口的一边，并且由于使用了不同的片段着色器，它们的颜色也不同。这只是一个很简单的情景，我们可能会需要使用Uniform缓冲对象，但任何大型的渲染程序都可能同时激活有上百个着色器程序，这时候Uniform缓冲对象的优势就会很大地体现出来了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/03/27/25-%E9%AB%98%E7%BA%A7GLSL/advanced_GLSL.rar">这里</a>获取完整源代码</p>
<p>Uniform缓冲对象比起独立的uniform有很多好处。第一，一次设置很多uniform会比一个一个设置多个uniform要快很多；第二，比起在多个着色器中修改同样的uniform，在Uniform缓冲中修改一次会更容易一些。最后一个，如果使用Uniform缓冲对象的话，可以在着色器中使用更多的uniform。OpenGL限制了它能够处理的uniform数量，这可以通过GL_MAX_VERTEX_UNIFORM_COMPONENTS来查询。当你达到了uniform的最大数量时（比如再做骨骼动画的时候），可以选择使用Uniform缓冲对象。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OSkirito"
      src="/images/head_image.png">
  <p class="site-author-name" itemprop="name">OSkirito</p>
  <div class="site-description" itemprop="description">CG技术的记录与分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oskirito" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oskirito" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OSkirito</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
