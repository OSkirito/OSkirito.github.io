<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CG技术的记录与分享">
<meta property="og:type" content="website">
<meta property="og:title" content="OS&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="OS&#39;s Blog">
<meta property="og:description" content="CG技术的记录与分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="OSkirito">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>OS's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OS's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">54</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/" class="post-title-link" itemprop="url">在Katana中渲染AOV并输出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-18 17:20:32 / 修改时间：17:22:55" itemprop="dateCreated datePublished" datetime="2025-07-18T17:20:32+08:00">2025-07-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一个katana最基本的渲染结构"><a href="#一个katana最基本的渲染结构" class="headerlink" title="一个katana最基本的渲染结构"></a>一个katana最基本的渲染结构</h1><p>首先，在katana中进行一个渲染的最基本结构（使用Arnold渲染器）如下所示：</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718162415463.png" class="" title="image-20250718162415463">

<p>一个最基本的katana渲染工程应该包括上面这几部分：</p>
<p>1.数据的入口，包括了模型、摄像机、材质等，这些渲染数据可以是在katana中创建的，也可以是使用节点读入的，总之你要渲染的东西就从这里开始，并且摄像机是必须的（模型和材质可以没有，渲染结果没有东西而已，没有摄像机就不能渲染）。</p>
<p>2.材质的赋予，这个操作可以是手动的，也可以是节点解析自动赋予的。</p>
<p>3.灯光节点，灯光师会在这里创建灯光对渲染场景进行照明，大多数渲染分层是必须灯光照明的（部分AOV渲染可能不需要灯光，比如AO、Wireframe等）。</p>
<p>4.渲染设置相关节点，RenderSettings节点是对渲染的全局进行设置，包括了摄像机的指定、渲染器的指定、渲染分辨率等，ArnoldGlobalSettings节点是对Arnold渲染器的渲染设置。</p>
<p>5.待前序的所有数据和设置准备完毕，就可以右键Render进行渲染。</p>
<h1 id="渲染输出AOV相关分层"><a href="#渲染输出AOV相关分层" class="headerlink" title="渲染输出AOV相关分层"></a>渲染输出AOV相关分层</h1><p><strong>AOV</strong> 是 <strong>Arbitrary Output Variables</strong>（任意输出变量）的缩写。</p>
<p>它是现代渲染管线中非常重要的一个概念，尤其在电影和视觉特效制作中非常常见。</p>
<p><strong>AOV</strong> 指的是在渲染时，从一个场景或材质里，除了最终合成用的主图（beauty pass）之外，额外输出的各种图层或通道。每个 AOV 通常包含某种特定的图像信息，用于后期合成、调色、特效、调试等。比如：Diffuse、Specular、Object ID、RestP等。</p>
<p>那么如何在katana中输出AOV层，以AO和CryptoMatte为例，大致需要分为下面的几步：</p>
<ol>
<li><p>创建AOV材质</p>
<p>对于cryptomatte，katana提供了封装好的AOV材质节点，只需要创建Material节点选择cryptomatte类型材质即可</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718164724073.png" class="" title="image-20250718164724073">

<p>对于AO材质就要麻烦一点，首先我们需要创建这个材质，再将这个材质写入到AOV中并且定义写入的AOV名称（一定要记住这个名称后面需要用到）</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718165017275.png" class="" title="image-20250718165017275">

<p>然后再将这个材质添加到katana的层级中</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718165235235.png" class="" title="image-20250718165235235"></li>
<li><p>设置AOV属性</p>
<p>对于cryptomatte分层，我们需要对每个对象进行属性的定义，Arnold进行渲染时会为每一个不同的ID的对象分配不同的颜色，从而呈现object分层效果，可以通过OpScript节点创建属性：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment">/root/world/geo/World/asset//*&#123;attr(&quot;type&quot;) == &quot;component&quot;&#125;</span></span><br><span class="line"><span class="comment">--/root/world//*&#123;hasattr(&quot;materialAssign&quot;)&#125;</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> op_path=Interface.GetRootLocationPath()</span><br><span class="line"><span class="keyword">local</span> asset_name = <span class="built_in">string</span>.<span class="built_in">match</span>(op_path, <span class="string">&quot;([^/]+)$&quot;</span>)</span><br><span class="line">Interface.SetAttr(<span class="string">&quot;geometry.arbitrary.crypto_asset.value&quot;</span>, StringAttribute(asset_name))</span><br><span class="line">Interface.SetAttr(<span class="string">&quot;geometry.arbitrary.crypto_asset.scope&quot;</span>, StringAttribute(<span class="string">&quot;primitive&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--local surfShader = Interface.GetAttr(&#x27;materialAssign&#x27;)</span></span><br><span class="line"><span class="comment">--if surfShader then</span></span><br><span class="line"><span class="comment">--    Interface.SetAttr(&quot;geometry.arbitrary.crypto_material.scope&quot;, StringAttribute(&quot;primitive&quot;))</span></span><br><span class="line"><span class="comment">--    Interface.SetAttr(&#x27;geometry.arbitrary.crypto_material.value&#x27;, surfShader  )</span></span><br><span class="line"><span class="comment">--end</span></span><br></pre></td></tr></table></figure>

<p>而AO分层的所有对象使用的是同一种材质（不需要经过上述的计算），所以不需要进行设置。</p>
</li>
<li><p>“赋予材质”</p>
<p>我们创建了这些材质，那么如何让这个材质起作用呢？直接进行赋予的话那么我们的渲染结果就只有AOV那一层了，我们需要在ArnoldGlobalSettings中将AOV材质添加到AOV Shader中</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718170640684.png" class="" title="image-20250718170640684"></li>
<li><p>定义输出通道和路径</p>
<p>接下来我们创建ArnoldOutputChannelDefine节点定义AOV输出的层的名称，通道填写我们创建材质时定义的AOV名称</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718170910425.png" class="" title="image-20250718170910425">

<p>接着创建RenderOutputDefine接收我们的渲染分层并输出，这里的通道是ArnoldOutputChannelDefine中创建的名字</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718171126881.png" class="" title="image-20250718171126881"></li>
</ol>
<p>最后我们便可以渲染我们的AOV分层了，同样的可以创建其他的AOV分层，效果如下：</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718171459066.png" class="" title="image-20250718171459066">

<p><img src="%E5%9C%A8katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718171751520.png" alt="image-20250718171751520"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/18/Katana%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/18/Katana%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Katana的常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-18 17:20:01 / 修改时间：17:22:25" itemprop="dateCreated datePublished" datetime="2025-07-18T17:20:01+08:00">2025-07-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="1-需要导入的包"><a href="#1-需要导入的包" class="headerlink" title="1.需要导入的包"></a>1.需要导入的包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Katana <span class="keyword">import</span> NodegraphAPI, KatanaFile</span><br><span class="line"><span class="keyword">from</span> fnpxr <span class="keyword">import</span> Usd</span><br></pre></td></tr></table></figure>

<h2 id="2-文件操作相关命令"><a href="#2-文件操作相关命令" class="headerlink" title="2.文件操作相关命令"></a>2.文件操作相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>KatanaFile.Load(filename)</code></td>
<td>加载 <code>.katana</code> 文件为当前工程（替换当前内容）</td>
</tr>
<tr>
<td><code>KatanaFile.Save(filename)</code></td>
<td>将当前工程保存为指定路径</td>
</tr>
<tr>
<td><code>KatanaFile.Save()</code></td>
<td>保存当前工程（覆盖当前文件）</td>
</tr>
<tr>
<td><code>KatanaFile.Import(filename)</code></td>
<td>将其他 <code>.katana</code> 文件导入到当前工程中</td>
</tr>
<tr>
<td><code>KatanaFile.IsFileDirty()</code></td>
<td>当前工程是否修改过未保存</td>
</tr>
<tr>
<td><code>KatanaFile.GetCurrentFilename()</code></td>
<td>获取当前工程文件名</td>
</tr>
<tr>
<td><code>KatanaFile.New()</code></td>
<td>新建一个空工程（清空当前）</td>
</tr>
<tr>
<td><code>KatanaFile.SetCurrentFilename(path)</code></td>
<td>设置当前工程名（注意：不保存，只设置路径）</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetRootNode().getParameter(&#39;inTime&#39;).getValue(0)</code></td>
<td>获取当前工程project settings中的设置</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetRootNode().getParameter(&#39;currentTime&#39;).setValue(1001， 0)</code></td>
<td>设置当前工程project settings中的设置</td>
</tr>
<tr>
<td><code>NodegraphAPI.SetWorkingInTime(1001)</code></td>
<td>设置工程起始帧</td>
</tr>
<tr>
<td><code>NodegraphAPI.SetTimeIncrement(1)</code></td>
<td>设置时间增量</td>
</tr>
<tr>
<td><code>NodegraphAPI.SetCurrentTime(1001)</code></td>
<td>设置当前滑块时间</td>
</tr>
<tr>
<td><code>NodegraphAPI.SetWorkingOutTime(1200)</code></td>
<td>设置工程结束帧</td>
</tr>
</tbody></table>
<h2 id="3-节点相关操作"><a href="#3-节点相关操作" class="headerlink" title="3.节点相关操作"></a>3.节点相关操作</h2><h3 id="1-获取节点信息"><a href="#1-获取节点信息" class="headerlink" title="1.获取节点信息"></a>1.获取节点信息</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>NodegraphAPI.CreateNode(nodeType, parent=None)</code></td>
<td>创建指定类型的节点</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetNode(nodeName)</code></td>
<td>获取指定名称的节点对象</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetAllNodes()</code></td>
<td>获取当前场景中的所有节点</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetAllNodesByType(nodeType)</code></td>
<td>获取所有某种类型的节点</td>
</tr>
<tr>
<td><code>NodegraphAPI.DeleteNode(node)</code></td>
<td>删除节点（或多个）</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetRootNode()</code></td>
<td>获取整个 NodeGraph 的根节点</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetGroupNodes(node)</code></td>
<td>获取组节点中的子节点</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetGroupParent(node)</code></td>
<td>获取所属的父组节点</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetSelectedNodes()</code></td>
<td>获取当前选中的节点</td>
</tr>
</tbody></table>
<h3 id="2-获取节点的属性"><a href="#2-获取节点的属性" class="headerlink" title="2.获取节点的属性"></a>2.获取节点的属性</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>node.getParameter(&quot;paramName&quot;)</code></td>
<td>获取节点上指定参数对象</td>
</tr>
<tr>
<td><code>node.getParameters()</code></td>
<td>获取所有参数</td>
</tr>
<tr>
<td><code>node.setName(name)</code></td>
<td>设置节点名称</td>
</tr>
<tr>
<td><code>node.getName()</code></td>
<td>获取节点名称</td>
</tr>
</tbody></table>
<h3 id="3-节点连接与位置排版"><a href="#3-节点连接与位置排版" class="headerlink" title="3.节点连接与位置排版"></a>3.节点连接与位置排版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input_port = node.getInputPort(<span class="string">&quot;in&quot;</span>)</span><br><span class="line">output_port = otherNode.getOutputPort(<span class="string">&quot;out&quot;</span>)</span><br><span class="line">input_port.connect(output_port)</span><br><span class="line"></span><br><span class="line">NodegraphAPI.SetNodePosition(node, (<span class="number">100</span>, <span class="number">300</span>))</span><br><span class="line">pos = NodegraphAPI.GetNodePosition(node)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>node.getInputPort(name)</code> / <code>node.getOutputPort(name)</code></td>
<td>获取输入/输出端口</td>
</tr>
<tr>
<td><code>node.getInputPort(&quot;in&quot;).connect(outputPort)</code></td>
<td>将端口连接起来</td>
</tr>
<tr>
<td><code>node.getInputPort(&quot;in&quot;).disconnect()</code></td>
<td>断开端口连接</td>
</tr>
<tr>
<td><code>node.getConnectedPort()</code></td>
<td>获取已连接端口</td>
</tr>
<tr>
<td><code>node.GetNodePosition(node)</code></td>
<td>获取节点位置</td>
</tr>
<tr>
<td><code>node.SetNodePosition(node, (x, y))</code></td>
<td>设置节点在图中的位置</td>
</tr>
</tbody></table>
<h1 id="lua（在katana的OpScript节点中使用）"><a href="#lua（在katana的OpScript节点中使用）" class="headerlink" title="lua（在katana的OpScript节点中使用）"></a>lua（在katana的OpScript节点中使用）</h1><h2 id="1-开启材质中image节点的ignore-missing-textures属性"><a href="#1-开启材质中image节点的ignore-missing-textures属性" class="headerlink" title="1.开启材质中image节点的ignore_missing_textures属性"></a>1.开启材质中image节点的ignore_missing_textures属性</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">This script can set aiImage ignore_missing_textures attribute to True</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment"> /root/world//*&#123;attr(&quot;type&quot;) == &quot;material&quot;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">script:</span></span><br><span class="line"><span class="comment">local module = require(&#x27;prl_katana.mat.image&#x27;)</span></span><br><span class="line"><span class="comment">module.SetImageAttrs()</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.SetImageAttrs</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> nodeListAttr = Interface.GetAttr(<span class="string">&#x27;material.nodes&#x27;</span>)</span><br><span class="line">    <span class="keyword">local</span> childNum = nodeListAttr:getNumberOfChildren()</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>, childNum <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> nodeAttr = nodeListAttr:getChildByIndex(i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeName = nodeListAttr:getChildName(i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeTarget = nodeAttr:getChildByName(<span class="string">&#x27;target&#x27;</span>):getValue()</span><br><span class="line">        <span class="keyword">local</span> nodeType = nodeAttr:getChildByName(<span class="string">&#x27;type&#x27;</span>):getValue()</span><br><span class="line">        <span class="comment">--print(nodeName, nodeTarget, nodeType)</span></span><br><span class="line">        <span class="comment">--print(nodeType)</span></span><br><span class="line">        <span class="keyword">if</span> nodeType == <span class="string">&#x27;image&#x27;</span> <span class="keyword">then</span></span><br><span class="line">            Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.ignore_missing_textures&#x27;</span>, IntAttribute(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure>

<h2 id="2-将USD材质转换为Arnold材质"><a href="#2-将USD材质转换为Arnold材质" class="headerlink" title="2.将USD材质转换为Arnold材质"></a>2.将USD材质转换为Arnold材质</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">This script can convert usd material to arnold material</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment"> /root/world//*&#123;attr(&quot;type&quot;) == &quot;material&quot;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">script:</span></span><br><span class="line"><span class="comment">local module = require(&#x27;prl_katana.mat.shader&#x27;)</span></span><br><span class="line"><span class="comment">module.ResolveUsdMat()</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.ResolveUsdMat</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> nodeListAttr = Interface.GetAttr(<span class="string">&#x27;material.nodes&#x27;</span>)</span><br><span class="line">    <span class="keyword">local</span> childNum = nodeListAttr:getNumberOfChildren()</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>, childNum <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> nodeAttr = nodeListAttr:getChildByIndex(i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeName = nodeListAttr:getChildName(i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeTarget = nodeAttr:getChildByName(<span class="string">&#x27;target&#x27;</span>):getValue()</span><br><span class="line">        <span class="keyword">local</span> nodeType = nodeAttr:getChildByName(<span class="string">&#x27;type&#x27;</span>):getValue()</span><br><span class="line">        <span class="comment">--print(nodeName, nodeTarget, nodeType)</span></span><br><span class="line">        <span class="keyword">if</span> nodeTarget == <span class="string">&#x27;usd&#x27;</span> <span class="keyword">then</span></span><br><span class="line">            Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.target&#x27;</span>, StringAttribute(<span class="string">&#x27;arnold&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> nodeType == <span class="string">&#x27;UsdPreviewSurface&#x27;</span> <span class="keyword">then</span></span><br><span class="line">                Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.type&#x27;</span>, StringAttribute(<span class="string">&#x27;standard_surface&#x27;</span>))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> diffuseColorParamAttr = nodeAttr:getChildByName(<span class="string">&#x27;parameters.diffuseColor&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> diffuseColorParamAttr ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> diffuseColorValue = diffuseColorParamAttr:getNearestSample(<span class="number">0</span>)</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.base_color&#x27;</span>, FloatAttribute(diffuseColorValue))</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">local</span> diffuseColorConnectAttr = nodeAttr:getChildByName(<span class="string">&#x27;connections.diffuseColor&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> diffuseColorConnectAttr ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> diffuseColorConnect = diffuseColorConnectAttr:getValue()</span><br><span class="line">                    <span class="keyword">local</span> baseColorConnect = pystring.replace(diffuseColorConnect, <span class="string">&#x27;rgb&#x27;</span>, <span class="string">&#x27;out&#x27;</span>)</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.connections.base_color&#x27;</span>, StringAttribute(baseColorConnect))</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> specularColorParamAttr = nodeAttr:getChildByName(<span class="string">&#x27;parameters.specularColor&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> specularColorParamAttr ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> specularColorValue = specularColorParamAttr:getNearestSample(<span class="number">0</span>)</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.specular_color&#x27;</span>, FloatAttribute(specularColorValue))</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.specular_color&#x27;</span>, FloatAttribute(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, <span class="number">3</span>))</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> roughnessParamAttr = nodeAttr:getChildByName(<span class="string">&#x27;parameters.roughness&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> roughnessParamAttr ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> roughnessValue = roughnessParamAttr:getValue()</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.specular_roughness&#x27;</span>, FloatAttribute(roughnessValue))</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.specular_roughness&#x27;</span>, FloatAttribute(<span class="number">0.5</span>))</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> opacityParamAttr = nodeAttr:getChildByName(<span class="string">&#x27;parameters.opacity&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> opacityParamAttr ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> opacityValue = opacityParamAttr:getValue()</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.opacity&#x27;</span>, FloatAttribute(&#123;opacityValue, opacityValue, opacityValue&#125;, <span class="number">3</span>))</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> nodeType == <span class="string">&#x27;UsdUVTexture&#x27;</span> <span class="keyword">then</span></span><br><span class="line">                Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.type&#x27;</span>, StringAttribute(<span class="string">&#x27;image&#x27;</span>))</span><br><span class="line">                <span class="keyword">local</span> filestring = nodeAttr:getChildByName(<span class="string">&#x27;parameters.file&#x27;</span>):getValue()</span><br><span class="line">                Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.filename&#x27;</span>, StringAttribute(filestring))</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> nodeType == <span class="string">&#x27;UsdPrimvarReader_float2&#x27;</span> <span class="keyword">then</span></span><br><span class="line">                Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.type&#x27;</span>, StringAttribute(<span class="string">&#x27;user_data_rgba&#x27;</span>))</span><br><span class="line">                <span class="comment">--local filestring = nodeAttr:getChildByName(&#x27;parameters.file&#x27;):getValue()</span></span><br><span class="line">                <span class="comment">--Interface.SetAttr(&#x27;material.nodes.&#x27; .. nodeName .. &#x27;.parameters.filename&#x27;, StringAttribute(filestring))</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure>

<h2 id="3-强行转换Arnold-standard-surface材质为ambient-occlusion，以获取带有颜色的AO材质"><a href="#3-强行转换Arnold-standard-surface材质为ambient-occlusion，以获取带有颜色的AO材质" class="headerlink" title="3.强行转换Arnold standard_surface材质为ambient_occlusion，以获取带有颜色的AO材质"></a>3.强行转换Arnold standard_surface材质为ambient_occlusion，以获取带有颜色的AO材质</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">This script can forced convert standard_surface to ambient_occlusion</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment"> /root/world//*&#123;attr(&quot;type&quot;) == &quot;material&quot;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">script:</span></span><br><span class="line"><span class="comment">local module = require(&#x27;prl_katana.mat.convertao&#x27;)</span></span><br><span class="line"><span class="comment">module.ConcertAO()</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.ConcertAO</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> matNodesAttr = Interface.GetAttr(<span class="string">&#x27;material.nodes&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matNodesAttr <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> count = matNodesAttr:getNumberOfChildren()</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, count <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> nodeAttr = matNodesAttr:getChildByIndex(i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeName = matNodesAttr:getChildName(i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> nodeTypeAttr = nodeAttr:getChildByName(<span class="string">&#x27;type&#x27;</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeTargetAttr = nodeAttr:getChildByName(<span class="string">&#x27;target&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> nodeType = nodeTypeAttr <span class="keyword">and</span> nodeTypeAttr:getValue() <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">local</span> nodeTarget = nodeTargetAttr <span class="keyword">and</span> nodeTargetAttr:getValue() <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nodeTarget == <span class="string">&#x27;arnold&#x27;</span> <span class="keyword">and</span> nodeType == <span class="string">&#x27;standard_surface&#x27;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> base = <span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName</span><br><span class="line">            Interface.SetAttr(base .. <span class="string">&#x27;.type&#x27;</span>, StringAttribute(<span class="string">&#x27;ambient_occlusion&#x27;</span>))</span><br><span class="line">            Interface.SetAttr(base .. <span class="string">&#x27;.target&#x27;</span>, StringAttribute(<span class="string">&#x27;arnold&#x27;</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">local</span> baseColorConnAttr = nodeAttr:getChildByName(<span class="string">&#x27;connections.base_color&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> baseColorConnAttr <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">local</span> src = baseColorConnAttr:getValue()</span><br><span class="line">                Interface.SetAttr(base .. <span class="string">&#x27;.connections.white&#x27;</span>, StringAttribute(src))</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">local</span> baseColorAttr = nodeAttr:getChildByName(<span class="string">&#x27;parameters.base_color&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> baseColorAttr <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> colorValue = baseColorAttr:getNearestSample(<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> colorValue <span class="keyword">and</span> #colorValue &gt;= <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">                        Interface.SetAttr(base .. <span class="string">&#x27;.parameters.white&#x27;</span>, FloatAttribute(colorValue, <span class="number">3</span>))</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure>

<h2 id="4-赋予的材质是否有效并添加标识以清除等操作"><a href="#4-赋予的材质是否有效并添加标识以清除等操作" class="headerlink" title="4.赋予的材质是否有效并添加标识以清除等操作"></a>4.赋予的材质是否有效并添加标识以清除等操作</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment">/root/world//*&#123;attr(&quot;type&quot;) == &quot;polymesh&quot;&#125;</span></span><br><span class="line"><span class="comment">/root/world//*&#123;attr(&quot;type&quot;) == &quot;subdmesh&quot;&#125;</span></span><br><span class="line"><span class="comment">/root/world//*&#123;attr(&quot;type&quot;) == &quot;mesh&quot;&#125;</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> matAttr = Interface.GetAttr(<span class="string">&quot;materialAssign&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> matAttr ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    matPath = matAttr:getValue()</span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">path</span> = Interface.GetOutputLocationPath()</span><br><span class="line">    <span class="keyword">local</span> type_name = Interface.GetAttr(<span class="string">&quot;type&quot;</span>,matPath)</span><br><span class="line">    <span class="keyword">if</span> type_name == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;---------------------------&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">path</span>)</span><br><span class="line">        <span class="built_in">print</span>(type_name)</span><br><span class="line">        <span class="built_in">print</span>(matPath)</span><br><span class="line">        Interface.SetAttr(<span class="string">&quot;user.mat_invalid&quot;</span>, StringAttribute(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="5-检查无效的模型层级并添加标识以清除等操作"><a href="#5-检查无效的模型层级并添加标识以清除等操作" class="headerlink" title="5.检查无效的模型层级并添加标识以清除等操作"></a>5.检查无效的模型层级并添加标识以清除等操作</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment">/root/world//*&#123;attr(&quot;type&quot;) == &quot;polymesh&quot;&#125;</span></span><br><span class="line"><span class="comment">/root/world//*&#123;attr(&quot;type&quot;) == &quot;subdmesh&quot;&#125;</span></span><br><span class="line"><span class="comment">/root/world//*&#123;attr(&quot;type&quot;) == &quot;mesh&quot;&#125;</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> Interface.GetAttr(<span class="string">&quot;geometry.point&quot;</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    Interface.SetAttr(<span class="string">&quot;user.to_delete&quot;</span>, StringAttribute(<span class="string">&quot;1&quot;</span>))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="6-为层级添加cryptomatte相关属性"><a href="#6-为层级添加cryptomatte相关属性" class="headerlink" title="6.为层级添加cryptomatte相关属性"></a>6.为层级添加cryptomatte相关属性</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment">/root/world/geo/World/asset//*&#123;attr(&quot;type&quot;) == &quot;component&quot;&#125;</span></span><br><span class="line"><span class="comment">/root/world//*&#123;hasattr(&quot;materialAssign&quot;)&#125;</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> op_path=Interface.GetRootLocationPath()</span><br><span class="line"><span class="keyword">local</span> asset_name = <span class="built_in">string</span>.<span class="built_in">match</span>(op_path, <span class="string">&quot;([^/]+)$&quot;</span>)</span><br><span class="line">Interface.SetAttr(<span class="string">&quot;geometry.arbitrary.crypto_asset.value&quot;</span>, StringAttribute(asset_name))</span><br><span class="line">Interface.SetAttr(<span class="string">&quot;geometry.arbitrary.crypto_asset.scope&quot;</span>, StringAttribute(<span class="string">&quot;primitive&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> surfShader = Interface.GetAttr(<span class="string">&#x27;materialAssign&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> surfShader <span class="keyword">then</span></span><br><span class="line">    Interface.SetAttr(<span class="string">&quot;geometry.arbitrary.crypto_material.scope&quot;</span>, StringAttribute(<span class="string">&quot;primitive&quot;</span>))</span><br><span class="line">    Interface.SetAttr(<span class="string">&#x27;geometry.arbitrary.crypto_material.value&#x27;</span>, surfShader  )</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="7-重新连接材质中断开的贴图节点"><a href="#7-重新连接材质中断开的贴图节点" class="headerlink" title="7.重新连接材质中断开的贴图节点"></a>7.重新连接材质中断开的贴图节点</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">This script can use the first tex connect shader color</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment"> /root/world//*&#123;@type == &quot;material&quot;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">script:</span></span><br><span class="line"><span class="comment">local module = require(&#x27;prl_katana.mat.texreconnect&#x27;)</span></span><br><span class="line"><span class="comment">module.Reconnect()</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.Reconnect</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> matNodesAttr = Interface.GetAttr(<span class="string">&#x27;material.nodes&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matNodesAttr <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> count = matNodesAttr:getNumberOfChildren()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> tex_nodeName = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">local</span> fallback_nodeName = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, count <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> nodeAttr = matNodesAttr:getChildByIndex(i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeName = matNodesAttr:getChildName(i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> nodeTypeAttr = nodeAttr:getChildByName(<span class="string">&#x27;type&#x27;</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeTargetAttr = nodeAttr:getChildByName(<span class="string">&#x27;target&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> nodeType = nodeTypeAttr <span class="keyword">and</span> nodeTypeAttr:getValue() <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">local</span> nodeTarget = nodeTargetAttr <span class="keyword">and</span> nodeTargetAttr:getValue() <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nodeTarget == <span class="string">&#x27;usd&#x27;</span> <span class="keyword">and</span> nodeType == <span class="string">&#x27;UsdUVTexture&#x27;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">string</span>.<span class="built_in">find</span>(nodeName, <span class="string">&#x27;file&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">                tex_nodeName = nodeName</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fallback_nodeName <span class="keyword">then</span></span><br><span class="line">                fallback_nodeName = nodeName</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tex_nodeName <span class="keyword">then</span></span><br><span class="line">        tex_nodeName = fallback_nodeName</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tex_nodeName <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, count <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> nodeAttr = matNodesAttr:getChildByIndex(i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeName = matNodesAttr:getChildName(i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> nodeTypeAttr = nodeAttr:getChildByName(<span class="string">&#x27;type&#x27;</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeTargetAttr = nodeAttr:getChildByName(<span class="string">&#x27;target&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> nodeType = nodeTypeAttr <span class="keyword">and</span> nodeTypeAttr:getValue() <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">local</span> nodeTarget = nodeTargetAttr <span class="keyword">and</span> nodeTargetAttr:getValue() <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> nodeTarget == <span class="string">&#x27;usd&#x27;</span> <span class="keyword">and</span> nodeType == <span class="string">&#x27;UsdPreviewSurface&#x27;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> base = <span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName</span><br><span class="line">            <span class="keyword">local</span> destAttrPath = base .. <span class="string">&#x27;.connections.diffuseColor&#x27;</span></span><br><span class="line">            Interface.SetAttr(destAttrPath, StringAttribute(<span class="string">&#x27;rgb@&#x27;</span> .. tex_nodeName))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/06/%E4%BD%BF%E7%94%A8%E5%90%AF%E5%8A%A8%E5%99%A8%E5%90%AF%E5%8A%A8maya%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E5%88%B0maya%E8%8F%9C%E5%8D%95%E6%A0%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/06/%E4%BD%BF%E7%94%A8%E5%90%AF%E5%8A%A8%E5%99%A8%E5%90%AF%E5%8A%A8maya%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E5%88%B0maya%E8%8F%9C%E5%8D%95%E6%A0%8F/" class="post-title-link" itemprop="url">使用启动器启动maya并添加自定义工具到maya菜单栏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-06 12:12:06" itemprop="dateCreated datePublished" datetime="2025-01-06T12:12:06+08:00">2025-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-10 15:37:11" itemprop="dateModified" datetime="2025-02-10T15:37:11+08:00">2025-02-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>要在 Maya 启动时加载 XML 文件中的子项到菜单栏，并通过点击这些菜单项来运行特定的代码，你可以通过 Maya 的 Python 脚本来实现。以下是一个基本的步骤指南：</p>
<h3 id="1-准备-XML-文件"><a href="#1-准备-XML-文件" class="headerlink" title="1. 准备 XML 文件"></a>1. 准备 XML 文件</h3><p>首先，你需要准备一个 XML 文件来存储菜单项和对应的代码。例如，你可以创建一个简单的 XML 文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;menu name=&quot;My Maya Tools&quot;&gt;</span><br><span class="line">    &lt;submenu name=&quot;Load Maya Tools&quot; icon=&quot;tool.svg&quot; type=&quot;command&quot;  mode=&quot;python&quot;</span><br><span class="line">             cmd=&quot;print(&#x27;11111111111111111&#x27;)&quot; /&gt;</span><br><span class="line">    &lt;submenu name= &quot;----------&quot; type=&quot;separator&quot;/&gt;</span><br><span class="line">    &lt;submenu name=&quot;Maya Tools Test&quot; icon=&quot;test.svg&quot; type=&quot;command&quot;  mode=&quot;python&quot;</span><br><span class="line">             cmd=&quot;from MAYA_TOOLS import test_tools;test_tools.run()&quot; /&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>

<p>这个 XML 文件包含三个菜单项，每个菜单项有 <code>name</code> 属性、<code>type</code>属性，分别定义了xml菜单项的名称和类型，对于特别的类型（command），在<code>mode</code>属性中定义使用的语言，<code>cmd</code>中调用代码。</p>
<h3 id="2-编写-Maya-启动脚本"><a href="#2-编写-Maya-启动脚本" class="headerlink" title="2. 编写 Maya 启动脚本"></a>2. 编写 Maya 启动脚本</h3><p>你需要编写一个 解析xml的脚本，并且在Maya 启动时运行脚本，在maya启动完成后动态地将这些菜单项添加到 Maya 菜单栏。</p>
<p>创建一个名为 <code>userSetup.py</code>的脚本，maya在启动时会自动运行该脚本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> maya.cmds <span class="keyword">as</span> cmds</span><br><span class="line"><span class="keyword">import</span> maya.utils <span class="keyword">as</span> utils</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gui_launcher</span>():</span><br><span class="line">    <span class="keyword">import</span> ui_start</span><br><span class="line">    ui_start.MayaStart().start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cmds.about(batch=<span class="literal">True</span>):</span><br><span class="line">    utils.executeDeferred(gui_launcher)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Maya Startup Script is running...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="3-配置-Maya-启动脚本"><a href="#3-配置-Maya-启动脚本" class="headerlink" title="3. 配置 Maya 启动脚本"></a>3. 配置 Maya 启动脚本</h3><p>将 <code>userSetup.py</code>所在的路径添加到 Maya 的启动路径中，确保 Maya 启动时执行该脚本。你可以通过bat配置maya环境并启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> MAYA_UI_LANGUAGE=en_US</span><br><span class="line"><span class="built_in">set</span> CURRENT_PATH=%~dp0</span><br><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (<span class="string">&quot;%CURRENT_PATH%..&quot;</span>) <span class="keyword">do</span> <span class="built_in">set</span> LAUNCHER_LOCATION=%%~<span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> MAYA_PIPELINE=%LAUNCHER_LOCATION%</span><br><span class="line"><span class="built_in">set</span> MAYA_STARTUP=%LAUNCHER_LOCATION%/MAYA_STARTUP</span><br><span class="line"><span class="built_in">set</span> MAYA_SCRIPTS=%MAYA_STARTUP%/scripts</span><br><span class="line"><span class="built_in">set</span> MAYA_SCRIPT_PATH=%MAYA_SCRIPTS%;%MAYA_SCRIPT_PATH%</span><br><span class="line"><span class="built_in">set</span> PYTHONPATH=%MAYA_SCRIPTS%;%MAYA_PIPELINE%;%PYTHONPATH%</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> MAYA_VERSION=2024</span><br><span class="line"><span class="built_in">set</span> MAYA_DIR=D:\Autodesk\Maya%MAYA_VERSION%</span><br><span class="line"><span class="string">&quot;%MAYA_DIR%\bin\maya.exe&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-运行效果"><a href="#4-运行效果" class="headerlink" title="4. 运行效果"></a>4. 运行效果</h3><p>当 通过bat启动Maya时，解析函数会读取指定的 XML 文件，并将其中的菜单项添加到 Maya 的菜单栏中。点击菜单项时，会执行对应的 Python 代码。</p>
<p>通过这种方法，你可以灵活地管理和动态加载菜单项及其对应的功能，而不需要每次修改代码文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/27/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/27/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Linux系统的基础操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-27 14:51:38" itemprop="dateCreated datePublished" datetime="2024-12-27T14:51:38+08:00">2024-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-15 16:49:03" itemprop="dateModified" datetime="2025-01-15T16:49:03+08:00">2025-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux （ Linux is not Unix）是一种自由和开放源码的类 UNIX 操作系统，在很多影视公司会使用Linux系统进行工作，所以掌握一些基本的Linux操作是很有必要的。</p>
<p>在Linux的桌面或者任何资源管理器空白处点击鼠标右键，选择”打开终端“。</p>
<img src="/2024/12/27/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/Snipaste_2024-12-27_15-29-21.png" class="" title="Snipaste_2024-12-27_15-29-21">

<p>会出现类似Windows的cmd界面的窗口，同样的，我们可以在这里输入Linux命令对系统进行操作。</p>
<img src="/2024/12/27/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/Snipaste_2024-12-27_15-30-09.png" class="" title="Snipaste_2024-12-27_15-30-09">

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="1-文件和目录操作"><a href="#1-文件和目录操作" class="headerlink" title="1. 文件和目录操作"></a>1. 文件和目录操作</h3><ul>
<li><p><code>ls</code>：列出当前目录中的文件和文件夹。</p>
<p><code>ls -l</code>：显示详细信息（包括权限、所有者、文件大小等）。</p>
<p><code>ls -a</code>：显示所有文件，包括隐藏文件（以点 <code>.</code> 开头的文件）。</p>
</li>
<li><p><code>cd</code>：改变目录。</p>
<p><code>cd /path/to/directory</code>：进入指定目录。</p>
<p><code>cd ..</code>：返回上一级目录。</p>
<p><code>cd ~</code>：返回用户的主目录。</p>
</li>
<li><p><code>pwd</code>：显示当前工作目录。</p>
</li>
<li><p><code>mkdir</code>：创建新目录。</p>
<p><code>mkdir new_directory</code>：创建名为 <code>new_directory</code> 的目录。</p>
</li>
<li><p><code>rmdir</code>：删除空目录。</p>
<p><code>rmdir directory</code>：删除名为 <code>directory</code> 的空目录。</p>
</li>
<li><p><code>rm</code>：删除文件或目录。</p>
<p><code>rm file_name</code>：删除文件。</p>
<p><code>rm -r directory_name</code>：递归删除目录及其内容。</p>
</li>
<li><p><code>cp</code>：复制文件或目录。</p>
<p><code>cp source_file destination_file</code>：复制文件。</p>
<p><code>cp -r source_directory destination_directory</code>：复制目录及其内容。</p>
</li>
<li><p><code>mv</code>：移动文件或目录，或重命名文件。</p>
<p><code>mv old_name new_name</code>：重命名文件。</p>
<p><code>mv file_name destination_directory</code>：将文件移动到指定目录。</p>
</li>
</ul>
<h3 id="2-文件内容查看和编辑"><a href="#2-文件内容查看和编辑" class="headerlink" title="2. 文件内容查看和编辑"></a>2. 文件内容查看和编辑</h3><ul>
<li><p><code>cat</code>：查看文件内容。</p>
<p><code>cat file_name</code>：显示文件内容。</p>
</li>
<li><p><code>more</code>：逐屏查看文件内容。</p>
<p><code>more file_name</code>：显示文件内容，每次显示一页。</p>
</li>
<li><p><code>less</code>：逐屏查看文件内容，支持向前和向后滚动。</p>
<p><code>less file_name</code>：查看文件内容。</p>
</li>
<li><p><code>head</code>：查看文件的前几行。</p>
<p><code>head -n 10 file_name</code>：显示文件的前 10 行。</p>
</li>
<li><p><code>tail</code>：查看文件的最后几行。</p>
<p><code>tail -n 10 file_name</code>：显示文件的最后 10 行。</p>
<p><code>tail -f file_name</code>：实时查看文件更新（如日志文件）。</p>
</li>
<li><p><code>nano</code>、<code>vim</code>、<code>vi</code>：编辑文件。</p>
<p><code>nano file_name</code>：使用 nano 编辑器打开文件。</p>
<p><code>vim file_name</code> 或 <code>vi file_name</code>：使用 Vim 或 Vi 编辑器打开文件。</p>
</li>
</ul>
<h3 id="3-系统信息和资源"><a href="#3-系统信息和资源" class="headerlink" title="3. 系统信息和资源"></a>3. 系统信息和资源</h3><ul>
<li><p><code>top</code>：查看系统的实时资源使用情况。</p>
</li>
<li><p><code>htop</code>：一个更为友好的 <code>top</code> 命令版本（需要安装）。</p>
</li>
<li><p><code>df</code>：显示磁盘空间使用情况。</p>
<p><code>df -h</code>：以可读性更强的方式显示磁盘空间（GB、MB等）。</p>
</li>
<li><p><code>du</code>：显示目录或文件的磁盘使用情况。</p>
<p><code>du -sh directory_name</code>：显示目录总的磁盘使用情况。</p>
</li>
<li><p><code>free</code>：查看系统内存使用情况。</p>
<p><code>free -h</code>：以易于理解的格式显示内存使用情况。</p>
</li>
<li><p><code>ps</code>：查看当前进程。</p>
<p><code>ps aux</code>：列出所有进程。</p>
</li>
<li><p><code>kill</code>：终止进程。</p>
<p><code>kill process_id</code>：终止指定进程。</p>
<p><code>kill -9 process_id</code>：强制终止进程。</p>
</li>
<li><p><code>uptime</code>：查看系统的运行时间和负载。</p>
</li>
<li><p><code>whoami</code>：显示当前用户。</p>
</li>
</ul>
<h3 id="4-网络管理"><a href="#4-网络管理" class="headerlink" title="4. 网络管理"></a>4. 网络管理</h3><ul>
<li><p><code>ping</code>：测试与目标主机的网络连接。</p>
<p><code>ping host_name_or_ip</code>：ping 一个主机或 IP 地址。</p>
</li>
<li><p><code>ifconfig</code>：查看或配置网络接口（较老的命令，现代 Linux 系统可能使用 <code>ip</code>）。</p>
<p><code>ifconfig</code>：查看网络接口信息。</p>
</li>
<li><p><code>ip</code>：更现代的网络管理命令，替代 <code>ifconfig</code>。</p>
<p><code>ip a</code>：查看网络接口的 IP 地址信息。</p>
</li>
<li><p><code>ssh</code>：远程连接到另一台 Linux 主机。</p>
<p><code>ssh root@192.168.194.108</code>：通过 SSH 登录远程主机。</p>
</li>
<li><p><code>scp</code>：安全地复制文件到远程主机。</p>
<p><code>scp file_name user@hostname_or_ip:/path/to/destination</code>：将文件复制到远程主机。</p>
</li>
</ul>
<h3 id="5-用户和权限管理"><a href="#5-用户和权限管理" class="headerlink" title="5. 用户和权限管理"></a>5. 用户和权限管理</h3><ul>
<li><p><code>useradd</code>：创建新用户。</p>
<p><code>useradd username</code>：创建一个名为 <code>username</code> 的新用户。</p>
</li>
<li><p><code>passwd</code>：设置或更改密码。</p>
<p><code>passwd username</code>：更改指定用户的密码。</p>
</li>
<li><p><code>chown</code>：改变文件或目录的所有者。</p>
<p><code>chown user:group file_name</code>：将文件的所有者更改为指定用户和组。</p>
</li>
<li><p><code>chmod</code>：改变文件或目录的权限。</p>
<p><code>chmod 755 file_name</code>：为文件设置权限。</p>
<p><code>chmod 777 file_name</code>：为用户设置所有权限。</p>
<p><code>chmod -R 755 directory_name</code>：递归更改目录的权限。</p>
<ul>
<li><p><code>chmod</code> 是用来修改文件权限的命令。</p>
</li>
<li><p>```<br>777</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">     是一个权限值，表示：</span><br><span class="line">  </span><br><span class="line">    - 第一个数字 `7`：文件所有者（用户）拥有读、写、执行的权限。</span><br><span class="line">    - 第二个数字 `7`：文件所属的组拥有读、写、执行的权限。</span><br><span class="line">    - 第三个数字 `7`：其他用户也拥有读、写、执行的权限。</span><br><span class="line">  </span><br><span class="line">  权限值是由三个数字组成，每个数字代表不同权限的组合：</span><br><span class="line">  </span><br><span class="line">  - `r`（读） = 4</span><br><span class="line">  - `w`（写） = 2</span><br><span class="line">  - `x`（执行） = 1</span><br><span class="line">  </span><br><span class="line">  将这些数字相加来设置权限：</span><br><span class="line">  </span><br><span class="line">  - `7` = `4 (r)` + `2 (w)` + `1 (x)`。</span><br><span class="line"></span><br><span class="line">### 6. 文件查找和搜索</span><br><span class="line"></span><br><span class="line">- `find`：查找文件或目录。</span><br><span class="line"></span><br><span class="line">  `find /path/to/directory -name &quot;file_name&quot;`：在指定目录下查找文件。</span><br><span class="line"></span><br><span class="line">- `grep`：在文件中搜索文本。</span><br><span class="line"></span><br><span class="line">  `grep &quot;search_text&quot; file_name`：查找文件中包含指定文本的行。</span><br><span class="line"></span><br><span class="line">- `locate`：查找文件（依赖于文件数据库，需要先执行 `updatedb`）。</span><br><span class="line"></span><br><span class="line">  `locate file_name`：查找文件。</span><br><span class="line"></span><br><span class="line">### 7. 压缩与解压</span><br><span class="line"></span><br><span class="line">- `tar`：打包和解压文件。</span><br><span class="line"></span><br><span class="line">  `tar -czvf archive.tar.gz directory_name`：将目录压缩为 `.tar.gz` 格式。</span><br><span class="line"></span><br><span class="line">  `tar -xzvf archive.tar.gz`：解压 `.tar.gz` 文件。</span><br><span class="line"></span><br><span class="line">- `zip` 和 `unzip`：压缩和解压 `.zip` 文件。</span><br><span class="line"></span><br><span class="line">  `zip archive.zip file_name`：压缩文件。</span><br><span class="line"></span><br><span class="line">  `unzip archive.zip`：解压 `.zip` 文件。</span><br><span class="line"></span><br><span class="line">### 9.切换root用户：</span><br><span class="line"></span><br><span class="line">在 Linux 中，`su` 命令用于切换用户身份。要以 root 用户身份登录，可以执行以下命令：</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">su root</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>这将提示你输入 root 用户的密码。如果密码正确，成功登录后，你将以 root 用户身份操作。需要注意的是，<code>su</code> 命令通常需要 root 用户的密码，而不是当前用户的密码。</p>
<ol>
<li><strong>输入密码</strong>：系统会提示你输入 root 用户的密码。</li>
<li><strong>切换到 root 用户</strong>：输入密码后，你将切换到 root 用户，终端提示符通常会变为 <code>#</code>，表示你以 root 用户身份操作。</li>
</ol>
<img src="/2024/12/27/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/Snipaste_2024-12-27_16-16-15.png" class="" title="Snipaste_2024-12-27_16-16-15">

<h3 id="10-安装库："><a href="#10-安装库：" class="headerlink" title="10.安装库："></a>10.安装库：</h3><p>在 Linux 中，可以执行以下命令进行安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install tcsh</span><br></pre></td></tr></table></figure>

<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>要在Linux上进行开发工作，Shell脚本是无法绕开的。Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。</p>
<h3 id="1-一个基本-Shell-脚本示例"><a href="#1-一个基本-Shell-脚本示例" class="headerlink" title="1. 一个基本 Shell 脚本示例"></a>1. 一个基本 Shell 脚本示例</h3><h4 id="脚本结构："><a href="#脚本结构：" class="headerlink" title="脚本结构："></a>脚本结构：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是一个简单的 Shell 脚本</span></span><br><span class="line"></span><br><span class="line">echo &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>#!/bin/bash</code> 是脚本的 shebang（约定的标记），告诉系统使用哪个解释器来执行脚本（在这个例子中是 <code>/bin/bash</code>）。</li>
<li><code>echo</code> 命令用于打印输出。</li>
</ul>
<h4 id="运行脚本："><a href="#运行脚本：" class="headerlink" title="运行脚本："></a>运行脚本：</h4><p>假设我们现在有一个叫做script.sh的脚本，我们想要运行他，只需要在Linux的终端中输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./script.sh</span><br></pre></td></tr></table></figure>

<p>或输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ./script.sh</span><br></pre></td></tr></table></figure>

<h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. <strong>注释</strong></h3><p>在 Shell 脚本中，注释是用 <code>#</code> 来表示的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是一个注释</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Shell-脚本中的变量和输入"><a href="#3-Shell-脚本中的变量和输入" class="headerlink" title="3. Shell 脚本中的变量和输入"></a>3. Shell 脚本中的变量和输入</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取用户输入并打印</span></span><br><span class="line"></span><br><span class="line">echo &quot;请输入你的名字:&quot;</span><br><span class="line">read name</span><br><span class="line">echo &quot;你好, $name!&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>read</code> 用来获取用户输入，并将输入值保存在变量中。</li>
<li>变量 <code>$name</code> 用来引用输入的值。</li>
</ul>
<h3 id="4-条件语句（if-else）"><a href="#4-条件语句（if-else）" class="headerlink" title="4. 条件语句（if-else）"></a>4. 条件语句（if-else）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断一个数字是否为正数、负数或零</span></span><br><span class="line"></span><br><span class="line">echo &quot;请输入一个数字:&quot;</span><br><span class="line">read number</span><br><span class="line"></span><br><span class="line">if [ $number -gt 0 ]; then</span><br><span class="line">  echo &quot;这是一个正数&quot;</span><br><span class="line">elif [ $number -lt 0 ]; then</span><br><span class="line">  echo &quot;这是一个负数&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;这是零&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-gt</code> 表示“大于”，<code>-lt</code> 表示“小于”，<code>-eq</code> 表示“等于”。</li>
<li><code>if</code>、<code>elif</code> 和 <code>else</code> 语句用于条件判断。</li>
</ul>
<h3 id="5-循环语句（for-while）"><a href="#5-循环语句（for-while）" class="headerlink" title="5. 循环语句（for, while）"></a>5. 循环语句（for, while）</h3><h4 id="for-循环："><a href="#for-循环：" class="headerlink" title="for 循环："></a><code>for</code> 循环：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 <span class="keyword">for</span> 循环打印 1 到 5</span></span><br><span class="line"></span><br><span class="line">for i in &#123;1..5&#125;</span><br><span class="line">do</span><br><span class="line">  echo &quot;数字是: $i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="while-循环："><a href="#while-循环：" class="headerlink" title="while 循环："></a><code>while</code> 循环：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 <span class="keyword">while</span> 循环打印 1 到 5</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">while [ $i -le 5 ]</span><br><span class="line">do</span><br><span class="line">  echo &quot;数字是: $i&quot;</span><br><span class="line">  ((i++))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="6-函数定义"><a href="#6-函数定义" class="headerlink" title="6. 函数定义"></a>6. 函数定义</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义一个函数并调用它</span></span><br><span class="line"></span><br><span class="line">greet() &#123;</span><br><span class="line">  echo &quot;你好, $1!&quot;  # $1 是传递给函数的第一个参数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;请输入你的名字:&quot;</span><br><span class="line">read name</span><br><span class="line">greet $name</span><br></pre></td></tr></table></figure>

<ul>
<li><code>greet</code> 函数接受一个参数 <code>$1</code>，并打印消息。</li>
</ul>
<h3 id="7-文件操作"><a href="#7-文件操作" class="headerlink" title="7. 文件操作"></a>7. 文件操作</h3><h4 id="创建文件并写入内容："><a href="#创建文件并写入内容：" class="headerlink" title="创建文件并写入内容："></a>创建文件并写入内容：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建文件并写入内容</span></span><br><span class="line"></span><br><span class="line">echo &quot;Hello, World!&quot; &gt; hello.txt</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&gt;</code> 用于将内容写入文件，如果文件已存在则覆盖。</li>
<li><code>&gt;&gt;</code> 用于将内容追加到文件。</li>
</ul>
<h4 id="读取文件内容："><a href="#读取文件内容：" class="headerlink" title="读取文件内容："></a>读取文件内容：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取文件内容并打印</span></span><br><span class="line"></span><br><span class="line">while IFS= read -r line</span><br><span class="line">do</span><br><span class="line">  echo &quot;$line&quot;</span><br><span class="line">done &lt; hello.txt</span><br></pre></td></tr></table></figure>

<ul>
<li><code>IFS</code> 用来指定分隔符，<code>read -r</code> 用于读取文件的每一行。</li>
</ul>
<h3 id="8-查找文件"><a href="#8-查找文件" class="headerlink" title="8. 查找文件"></a>8. 查找文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找当前目录下所有的 .txt 文件</span></span><br><span class="line"></span><br><span class="line">find . -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>find</code> 命令用于递归查找文件。<code>-name &quot;*.txt&quot;</code> 查找所有扩展名为 <code>.txt</code> 的文件。</li>
</ul>
<h3 id="9-执行系统命令"><a href="#9-执行系统命令" class="headerlink" title="9. 执行系统命令"></a>9. 执行系统命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示当前系统时间</span></span><br><span class="line"></span><br><span class="line">current_time=$(date)</span><br><span class="line">echo &quot;当前时间: $current_time&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$(command)</code> 用来执行命令并将结果存储到变量中。</li>
</ul>
<h3 id="10-错误处理"><a href="#10-错误处理" class="headerlink" title="10. 错误处理"></a>10. 错误处理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果某个命令失败，则打印错误信息</span></span><br><span class="line"></span><br><span class="line">echo &quot;请输入一个文件名:&quot;</span><br><span class="line">read filename</span><br><span class="line"></span><br><span class="line">if [ ! -f &quot;$filename&quot; ]; then</span><br><span class="line">  echo &quot;错误: 文件 &#x27;$filename&#x27; 不存在!&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;文件 &#x27;$filename&#x27; 存在!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[ ! -f &quot;$filename&quot; ]</code> 用于检查文件是否存在。</li>
</ul>
<h3 id="11-示例：一个简单的shell脚本"><a href="#11-示例：一个简单的shell脚本" class="headerlink" title="11.示例：一个简单的shell脚本"></a>11.示例：一个简单的shell脚本</h3><p>以下是一个shell脚本示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export APP_NAME=houdini_20.0.653</span><br><span class="line">export HOUDINI_VERSION=20.0.653</span><br><span class="line"></span><br><span class="line">exec /opt/hfs20.0.653/bin/houdini $@</span><br></pre></td></tr></table></figure>

<p>我们设置了两个环境变量，并启动了houdini。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%EF%BC%88bat%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%EF%BC%88bat%EF%BC%89/" class="post-title-link" itemprop="url">如何使用批处理脚本（bat）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-27 11:36:48 / 修改时间：14:32:28" itemprop="dateCreated datePublished" datetime="2024-12-27T11:36:48+08:00">2024-12-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>bat（批处理文件），在DOS和Windows（任意版本）系统中，bat文件是可执行文件，由一系列命令构成，其中可以包含对其他程序的调用。这个文件的每一行都是一条DOS命令（大部分时候就好像我们在DOS提示符下执行的命令行一样），你可以使用DOS下的Edit或者Windows的记事本等任何文本文件编辑工具创建和修改批处理该类型的文件。</p>
<p>批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理，是一种简化的脚本语言，它的扩展名为bat 或cmd。比较常见的批处理包含两类：DOS批处理和PS批处理。PS批处理是基于强大的图片编辑软件Photoshop的，用来批量处理图片的脚本；而DOS批处理则是基于DOS命令的，用来自动地批量地执行DOS命令以实现特定操作的脚本。更复杂的情况，需要使用if、for、goto等命令控制程序的运行过程，如同C、Basic等高级语言一样。如果需要实现更复杂的应用，利用外部程序是必要的，这包括系统本身提供的外部命令和第三方提供的工具或者软件。批处理程序虽然是在命令行环境中运行，但不仅仅能使用命令行软件，任何当前系统下可运行的程序都可以放在批处理文件中运行。</p>
<p>对于TD/TA工作者来说，bat的编写是一项基本技能，工作中需要经常使用到bat来配置环境并且对DCC软件进行启动，下面对bat脚本进行介绍。</p>
<h2 id="基本语法和常用命令"><a href="#基本语法和常用命令" class="headerlink" title="基本语法和常用命令"></a>基本语法和常用命令</h2><h3 id="1-常用命令汇总"><a href="#1-常用命令汇总" class="headerlink" title="1.常用命令汇总"></a>1.常用命令汇总</h3><ul>
<li><code>echo</code>: 显示消息</li>
<li><code>dir</code>: 列出目录内容</li>
<li><code>cd</code>: 更改目录</li>
<li><code>del</code>: 删除文件</li>
<li><code>copy</code>: 复制文件</li>
<li><code>move</code>: 移动文件</li>
<li><code>set</code>: 设置环境变量</li>
<li><code>start</code>: 启动程序</li>
<li><code>pause</code>: 暂停</li>
<li><code>exit</code>: 退出脚本</li>
</ul>
<h3 id="2-回显"><a href="#2-回显" class="headerlink" title="2.回显"></a>2.回显</h3><p>在 Batch 文件中，<code>@</code> 符号用于禁止命令回显。通常，Batch 文件中的每一行命令执行时，命令本身都会被显示在命令行窗口中，除非你使用 <code>@echo off</code> 来禁止回显。具体来说：</p>
<h4 id="1-echo-off"><a href="#1-echo-off" class="headerlink" title="1.@echo off"></a>1.<code>@echo off</code></h4><p><code>@echo off</code> 是 Batch 文件中的常见用法。它用于禁用所有命令本身的回显，也就是不显示脚本执行的命令，在此后的所有命令都不会进行回显。通常放在 Batch 文件的开头，目的是让整个脚本在执行时不会显示命令</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br></pre></td></tr></table></figure>

<p>这条命令会让 Batch 文件在执行时不显示任何命令，只显示输出结果。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2.@"></a>2.<code>@</code></h4><p>在 <code>@echo off</code> 之外，<code>@</code> 可以加在任何命令的前面，来阻止该条命令的回显。例如：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> Hello, World!</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>@</code> 确保 <code>echo Hello, World!</code> 这一行命令不会被回显，只有它的输出会被显示。</p>
<h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. <strong>注释</strong></h3><p>在 Batch 文件中，注释是用 <code>REM</code> 或 <code>::</code> 来表示的：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">REM 这是一个注释</span></span><br><span class="line">:: 这也是注释</span><br></pre></td></tr></table></figure>

<h3 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. <strong>命令</strong></h3><p>Batch 文件的命令通常是 Windows 命令行命令（如 <code>echo</code>、<code>dir</code>、<code>del</code> 等）。每行一个命令：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> Hello, World!</span><br><span class="line"><span class="built_in">dir</span> C:\Users</span><br></pre></td></tr></table></figure>

<h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. <strong>变量</strong></h3><p>Batch 文件支持通过 <code>%</code> 访问变量。可以用 <code>set</code> 命令来定义变量：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> MY_VAR=Hello</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%MY_VAR%</span></span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>set</code> 读取和修改环境变量：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="built_in">PATH</span>=<span class="variable">%PATH%</span>;C:\MyProgram</span><br></pre></td></tr></table></figure>

<p><strong>特别注意，在设置变量时，<code>set</code> 命令中的等号两边不能有空格，空格会导致变量设置失败。</strong></p>
<h3 id="6-控制流"><a href="#6-控制流" class="headerlink" title="6. 控制流"></a>6. <strong>控制流</strong></h3><p>Batch 文件支持基本的控制流结构，如条件语句和循环。</p>
<ul>
<li><p><strong>条件判断（if）</strong>:</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">EXIST</span> &quot;file.txt&quot; (</span><br><span class="line">    <span class="built_in">echo</span> 文件存在</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">echo</span> 文件不存在</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>跳转（goto）</strong>: <code>goto</code> 用于跳转到文件中的指定标签（label）处：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> MyLabel</span><br><span class="line">:MyLabel</span><br><span class="line"><span class="built_in">echo</span> 这是标签后的代码</span><br></pre></td></tr></table></figure></li>
<li><p><strong>循环（for）</strong>: <code>for</code> 循环可以遍历文件、目录、数字等：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">%%i</span> <span class="keyword">in</span> (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">%%i</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a>7. <strong>错误处理</strong></h3><p>Batch 文件支持基本的错误处理，可以使用 <code>if errorlevel</code> 来检查上一条命令的返回值：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">errorlevel</span> <span class="number">1</span> (</span><br><span class="line">    <span class="built_in">echo</span> 发生错误</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>errorlevel</code> 返回值通常是 0 表示成功，非零值表示失败。</p>
<h3 id="8-输入和输出"><a href="#8-输入和输出" class="headerlink" title="8. 输入和输出"></a>8. <strong>输入和输出</strong></h3><ul>
<li><p><strong>输出（echo）</strong>: <code>echo</code> 用于输出信息到控制台：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> Hello, World!</span><br></pre></td></tr></table></figure></li>
<li><p><strong>输入（set /p）</strong>: <code>set /p</code> 用于从用户获取输入：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> /p USER_INPUT=请输入你的名字: </span><br><span class="line"><span class="built_in">echo</span> 你好, <span class="variable">%USER_INPUT%</span>！</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-文件操作"><a href="#9-文件操作" class="headerlink" title="9. 文件操作"></a>9. <strong>文件操作</strong></h3><p>Batch 文件可以进行常见的文件操作，如删除、复制、移动等：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">del</span> file.txt           # 删除文件</span><br><span class="line"><span class="built_in">copy</span> file.txt D:\backup\ # 复制文件</span><br><span class="line"><span class="built_in">move</span> file.txt D:\backup\ # 移动文件</span><br></pre></td></tr></table></figure>

<h3 id="10-暂停"><a href="#10-暂停" class="headerlink" title="10. 暂停"></a>10. <strong>暂停</strong></h3><p>使用 <code>pause</code> 命令来暂停脚本的执行，直到用户按下任意键：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<h3 id="11-启动外部程序"><a href="#11-启动外部程序" class="headerlink" title="11. 启动外部程序"></a>11. <strong>启动外部程序</strong></h3><p>Batch 文件可以启动外部程序或命令：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">start</span> &quot;notepad.exe&quot;</span><br><span class="line">：：或者</span><br><span class="line">&quot;notepad.exe&quot;</span><br></pre></td></tr></table></figure>

<h3 id="12-退出脚本"><a href="#12-退出脚本" class="headerlink" title="12. 退出脚本"></a>12. <strong>退出脚本</strong></h3><p><code>exit</code> 命令用于退出脚本：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>

<h3 id="13-批量处理命令输出"><a href="#13-批量处理命令输出" class="headerlink" title="13. 批量处理命令输出"></a>13. <strong>批量处理命令输出</strong></h3><p>通过重定向操作符 <code>&gt;</code> 或 <code>&gt;&gt;</code>，可以将命令的输出重定向到文件中：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> Hello, World! &gt; output.txt  # 覆盖写入</span><br><span class="line"><span class="built_in">echo</span> Another line &gt;&gt; output.txt  # 追加写入</span><br></pre></td></tr></table></figure>

<h3 id="14-使用命令行参数"><a href="#14-使用命令行参数" class="headerlink" title="14. 使用命令行参数"></a>14. <strong>使用命令行参数</strong></h3><p>Batch 文件支持命令行参数，通过 <code>%1</code>, <code>%2</code>, <code>%3</code> 等可以访问传递给脚本的参数。例如，<code>script.bat Hello World</code> 中，<code>%1</code> 会是 <code>Hello</code>，<code>%2</code> 会是 <code>World</code>：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> %<span class="number">1</span></span><br><span class="line"><span class="built_in">echo</span> %<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="15-示例：一个简单的-Batch-脚本"><a href="#15-示例：一个简单的-Batch-脚本" class="headerlink" title="15.示例：一个简单的 Batch 脚本"></a>15.示例：一个简单的 Batch 脚本</h3><p>以下是一个示例：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> add <span class="built_in">path</span></span><br><span class="line">:: <span class="built_in">set</span> MAYA_UI_LANGUAGE=en_US</span><br><span class="line"><span class="built_in">set</span> CURRENT_PATH=%~dp0</span><br><span class="line"><span class="keyword">for</span> <span class="variable">%%i</span> <span class="keyword">in</span> (&quot;<span class="variable">%CURRENT_PATH%</span>..&quot;) <span class="keyword">do</span> <span class="built_in">set</span> MAYA_LOCATION=<span class="variable">%%~</span>fi</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%MAYA_LOCATION%</span></span><br><span class="line"><span class="built_in">echo</span> launcher maya2024</span><br><span class="line"><span class="built_in">start</span> &quot;<span class="variable">%MAYA_LOCATION%</span>\bin\maya.exe&quot;</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<p>首先我们关闭了所有命令行的回显，然后输出”add path“，设置maya的ui语言但是对该行代码进行了注释（将不会生效），将当前bat文件的位置路径存储到变量<code>CURRENT_PATH</code>中，然后获取 <code>CURRENT_PATH</code> 上一级目录的完整路径，并将该路径赋值给 <code>MAYA_LOCATION</code>，随后对 <code>MAYA_LOCATION</code>的值进行输出，输出”launcher maya2024“提示，最后启动maya并保留命令行输出窗口。</p>
<h2 id="执行-Batch-文件"><a href="#执行-Batch-文件" class="headerlink" title="执行 Batch 文件"></a>执行 Batch 文件</h2><ol>
<li>将代码保存为 <code>.bat</code> 或 <code>.cmd</code> 文件。</li>
<li>双击文件，或者在cmd命令行中执行该文件。</li>
</ol>
<img src="/2024/12/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%EF%BC%88bat%EF%BC%89/image-20241227125834799.png" class="" title="image-20241227125834799">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/04/33-%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/04/33-%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/" class="post-title-link" itemprop="url">33-级联阴影贴图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-04 14:52:13" itemprop="dateCreated datePublished" datetime="2024-12-04T14:52:13+08:00">2024-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-10 16:33:26" itemprop="dateModified" datetime="2025-07-10T16:33:26+08:00">2025-07-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前描述的阴影贴图是一种功能强大且相对简单的技术。但是，如果按照上述教程中的原样实现，会有一些缺点：</p>
<ul>
<li>阴影贴图始终围绕原点创建，而不是在摄像机实际查看的区域上创建。当然，如果我们能以足够的分辨率对整个场景进行阴影贴图，那将是最好的，但在当前的硬件上，这是不可行的。实际上，我们希望在视图中的对象上创建阴影贴图，从而为其他重要的事情节省宝贵的 GPU 内存。</li>
<li>阴影贴图正交投影矩阵未正确拟合到视图视锥体上。为了实现阴影贴图的最佳分辨率，正交矩阵需要尽可能紧密地适应摄像机视锥体，因为同样的场景：如果它更大，则意味着在实际可见的对象上花费的细节更少。</li>
<li>如果我们希望阴影渲染距离较大，阴影贴图（即使使用高级 PCF 函数）也会很模糊，就像我们在使用第一人称摄像机的游戏中所做的那样。我们可以提高阴影贴图的分辨率来缓解这种情况，但 GPU 内存是我们应该节省的资源。</li>
</ul>
<p>当我们使用级联阴影贴图时，可以解决第三点，但是在实现它时，我们也将解决前两点。级联阴影贴图的核心是，对于离我们很远的物体，不需要相同数量的阴影细节。我们希望为靠近近平面的物体提供清晰的阴影，并且对于数百单位外的物体，不提供太高的阴影细节。我们只需为近处和远处的物体渲染不同的阴影贴图，然后根据片段着色器中片段的深度从中采样：</p>
<ul>
<li>将我们的普通视图视锥体划分为 n 个子视锥体，其中第 i 个视锥体的远平面是第 i+1 个近平面</li>
<li>计算每个视锥体的拟合正交矩阵</li>
<li>对每个视锥体，渲染阴影贴图</li>
<li>将所有阴影贴图发送到片段着色器中</li>
<li>渲染场景，并根据片段的深度值从正确的阴影贴图中采样</li>
</ul>
<p>在下图中，我们可以看到 在低图形设置下CSGO中阴影级联的边缘。</p>
<img src="/2024/12/04/33-%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/cs_go.png" class="" title="img">

<h2 id="视图视锥体的世界坐标"><a href="#视图视锥体的世界坐标" class="headerlink" title="视图视锥体的世界坐标"></a>视图视锥体的世界坐标</h2><p>在动手处理阴影之前，我们需要解决一个问题：使投影矩阵很好地适应通用视锥体。为了能做到这一点，我们需要知道相关视锥体的世界空间坐标。我们的视图和投影矩阵将视锥体转换为 NDC 立方体。我们知道 NDC 立方体的角坐标：坐标在三个轴的[-1,1]范围内。由于矩阵乘法是一个可逆过程，因此可以在 NDC 立方体的角点上应用视图矩阵和投影矩阵的逆矩阵，以获得世界空间中的视锥体角。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;glm::vec4&gt; <span class="title">getFrustumCornersWorldSpace</span><span class="params">(<span class="type">const</span> glm::mat4&amp; proj, <span class="type">const</span> glm::mat4&amp; view)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> inv = glm::<span class="built_in">inverse</span>(proj * view);</span><br><span class="line">    std::vector&lt;glm::vec4&gt; frustumCorners;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">2</span>; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">2</span>; ++y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> z = <span class="number">0</span>; z &lt; <span class="number">2</span>; ++z)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">const</span> glm::vec4 pt = </span><br><span class="line">                    inv * glm::<span class="built_in">vec4</span>(</span><br><span class="line">                        <span class="number">2.0f</span> * x - <span class="number">1.0f</span>,</span><br><span class="line">                        <span class="number">2.0f</span> * y - <span class="number">1.0f</span>,</span><br><span class="line">                        <span class="number">2.0f</span> * z - <span class="number">1.0f</span>,</span><br><span class="line">                        <span class="number">1.0f</span>);</span><br><span class="line">                frustumCorners.<span class="built_in">push_back</span>(pt / pt.w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> frustumCorners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处描述的投影矩阵是一个透视矩阵，使用相机的纵横比和 fov，并使用正在分析的当前视锥体的近平面和远平面。视图矩阵是我们相机的视图矩阵。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> proj = glm::<span class="built_in">perspective</span>(</span><br><span class="line">    glm::<span class="built_in">radians</span>(camera.Zoom),</span><br><span class="line">    (<span class="type">float</span>)SCR_WIDTH / (<span class="type">float</span>)SCR_HEIGHT,</span><br><span class="line">    nearPlane,</span><br><span class="line">    farPlane</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<img src="/2024/12/04/33-%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/frustum_fitting.png" class="" title="img">

<p>上图由 <a target="_blank" rel="noopener" href="https://ogldev.org/www/tutorial49/tutorial49.html">OGLDev</a> 提供</p>
<h2 id="光照视图投影矩阵"><a href="#光照视图投影矩阵" class="headerlink" title="光照视图投影矩阵"></a>光照视图投影矩阵</h2><p>与普通阴影贴图一样，此矩阵是视图和投影矩阵的乘积。计算视图矩阵很简单，我们知道光线的来源方向，并且我们知道它肯定正在查看世界空间中的一个点：视锥体的中心。视锥体中心的位置可以通过平均视锥体角的坐标来获得。（之所以如此，是因为平均近平面和远平面的坐标会得到这些矩形的中心，而取这两个点的中点会得到视锥体的中心。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 center = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : corners)</span><br><span class="line">&#123;</span><br><span class="line">    center += glm::<span class="built_in">vec3</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">center /= corners.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> lightView = glm::<span class="built_in">lookAt</span>(center + lightDir, center, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>

<p>投影矩阵稍微复杂一些。因为目前讨论的光是定向光，所以需要一个正交投影矩阵。想象我们从光线的角度绘制的场景，我们尝试渲染的阴影贴图将是一个轴对齐的矩形，而这个矩形正如我们之前建立的那样需要适应视锥体。所以我们需要获取这个空间里视锥体的坐标，取沿坐标轴的坐标的最大值和最小值。这种视角正是我们的光照视图矩阵转换为我们提供的，变换 light view 空间中的视锥体角点，并找到最大和最小坐标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> minX = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"><span class="type">float</span> maxX = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">lowest</span>();</span><br><span class="line"><span class="type">float</span> minY = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"><span class="type">float</span> maxY = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">lowest</span>();</span><br><span class="line"><span class="type">float</span> minZ = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"><span class="type">float</span> maxZ = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">lowest</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : corners)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> trf = lightView * v;</span><br><span class="line">    minX = std::<span class="built_in">min</span>(minX, trf.x);</span><br><span class="line">    maxX = std::<span class="built_in">max</span>(maxX, trf.x);</span><br><span class="line">    minY = std::<span class="built_in">min</span>(minY, trf.y);</span><br><span class="line">    maxY = std::<span class="built_in">max</span>(maxY, trf.y);</span><br><span class="line">    minZ = std::<span class="built_in">min</span>(minZ, trf.z);</span><br><span class="line">    maxZ = std::<span class="built_in">max</span>(maxZ, trf.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用两个矩阵的乘积创建投影矩阵。首先，我们将创建一个正交投影矩阵，其中 left、right、top、bottom 参数设置为1或-1，z值设置为minZ和maxZ 。这将创建一个位于原点上的 3D 矩形，其宽度和高度为2，深度为 （maxZ – minZ）。在代码中，我们通过将minZ和maxZ与zMult相乘或除来增加它们所覆盖的空间量。这是因为我们想在摄像机空间中包含位于视锥体后面或前面的几何体。不仅是在视锥体中的几何体可以在视锥体中的表面上投射阴影。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tune this parameter according to the scene</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">float</span> zMult = <span class="number">10.0f</span>;</span><br><span class="line"><span class="keyword">if</span> (minZ &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    minZ *= zMult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    minZ /= zMult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (maxZ &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    maxZ /= zMult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    maxZ *= zMult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> glm::mat4 lightProjection = glm::<span class="built_in">ortho</span>(minX, maxX, minY, maxY, minZ, maxZ);</span><br><span class="line"><span class="keyword">return</span> lightProjection * lightView;</span><br></pre></td></tr></table></figure>

<p>将视图矩阵和投影矩阵相乘，我们得到给定视锥体的光照视图投影矩阵。我们需要对级联中的每个视锥体执行此过程。</p>
<h2 id="2D-数组纹理"><a href="#2D-数组纹理" class="headerlink" title="2D 数组纹理"></a>2D 数组纹理</h2><p>原则上，我们可以执行多少个级联没有限制，因此对任意值进行硬编码似乎不是一个明智的主意。而且，为着色器输入和绑定 sampler2D 会非常的麻烦。OpenGL 用2D 数组纹理的形式很好地解决了这个问题。此对象是具有相同维度的纹理数组。要在着色器中使用它们，需要先声明它们：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2DArray shadowMap;</span><br></pre></td></tr></table></figure>

<p>为了从中采样，我们可以将常规纹理函数与 vec3 参数用于纹理坐标，第三个维度指定要从哪个图层采样，从 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">texture</span>(depthMap, <span class="built_in">vec3</span>(TexCoords, currentLayer))</span><br></pre></td></tr></table></figure>

<p>创建2D数组纹理与创建常规的texture2D略有不同，需要使用 glTexImage3D 而不是 glTexImage3D 来分配内存，当将纹理绑定到帧缓冲区时，使用 glFramebufferTexture 而不是 glFramebufferTexture2D。调用 OpenGL 函数时，我们需要传递GL_TEXTURE_2D_ARRAYGL_TEXTURE_2D而不是作为目标，以告诉 OpenGL 我们正在处理哪种纹理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;lightFBO);</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;lightDepthMaps);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D_ARRAY, lightDepthMaps);</span><br><span class="line"><span class="built_in">glTexImage3D</span>(GL_TEXTURE_2D_ARRAY, <span class="number">0</span>, GL_DEPTH_COMPONENT32F, depthMapResolution, depthMapResolution, <span class="built_in">int</span>(shadowCascadeLevels.<span class="built_in">size</span>()) + <span class="number">1</span>, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">float</span> bordercolor[] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_BORDER_COLOR, bordercolor);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, lightFBO);</span><br><span class="line"><span class="built_in">glFramebufferTexture</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, lightDepthMaps, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glDrawBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glReadBuffer</span>(GL_NONE);</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> status = <span class="built_in">glCheckFramebufferStatus</span>(GL_FRAMEBUFFER);</span><br><span class="line"><span class="keyword">if</span> (status != GL_FRAMEBUFFER_COMPLETE)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::FRAMEBUFFER:: Framebuffer is not complete!&quot;</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>将此纹理绑定到采样器时，需要用GL_TEXTURE_2D_ARRAY作为目标参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D_ARRAY, lightDepthMaps);</span><br></pre></td></tr></table></figure>

<p>现在我们知道了使用 texture 数组的语义。这一切看起来都很简单，但在OpenGL中我们不能以普通方式渲染到这个纹理中，我们需要做一些叫做分层渲染的东西。这个过程与立方体贴图和点光源中所做的非常相似，使用几何着色器同时生成多层几何图形。在顶点阶段将顶点转换为光空间，然后让硬件使用空片段着色器完成其余工作。在新的深度贴图着色器中，我们只会在顶点着色器中执行世界空间变换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">    </span><br><span class="line">uniform mat4 model;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几何着色器将如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">layout</span>(triangles, invocations = <span class="number">5</span>) in;</span><br><span class="line"><span class="built_in">layout</span>(triangle_strip, max_vertices = <span class="number">3</span>) out;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">layout</span> (std140, binding = <span class="number">0</span>) uniform LightSpaceMatrices</span><br><span class="line">&#123;</span><br><span class="line">    mat4 lightSpaceMatrices[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;          </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        gl_Position = </span><br><span class="line">            lightSpaceMatrices[gl_InvocationID] * gl_in[i].gl_Position;</span><br><span class="line">        gl_Layer = gl_InvocationID;</span><br><span class="line">        <span class="built_in">EmitVertex</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>invocations声明一个新成员，用于指定调用计数。这个数字意味着，这个着色器将被实例化，这些实例并行运行，我们可以通过内置变量在着色器代码中使用此数字来指定我们要渲染到数组纹理的哪个层，以及我们将使用哪个阴影矩阵来执行光照空间转换。我们正在迭代所有三角形，并相应地设置gl_Layer和gl_Position。</p>
<p>片段着色器继续保持空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用着色器的 draw 调用如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">simpleDepthShader.<span class="built_in">use</span>();</span><br><span class="line">   </span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, lightFBO);</span><br><span class="line"><span class="built_in">glFramebufferTexture</span>(GL_FRAMEBUFFER, GL_TEXTURE_2D_ARRAY, lightDepthMaps, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, depthMapResolution, depthMapResolution);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">glCullFace</span>(GL_FRONT);</span><br><span class="line"><span class="built_in">renderScene</span>(simpleDepthShader);</span><br><span class="line"><span class="built_in">glCullFace</span>(GL_BACK);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/" class="post-title-link" itemprop="url">32-点阴影</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-03 18:25:21" itemprop="dateCreated datePublished" datetime="2024-12-03T18:25:21+08:00">2024-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-20 12:56:01" itemprop="dateModified" datetime="2024-12-20T12:56:01+08:00">2024-12-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目前为止我们学到了如何使用阴影贴图技术创建动态阴影。效果不错，但它只适合定向光，因为阴影只是在单一定向光源下生成的。所以它也叫定向阴影贴图，深度（阴影）贴图生成自定向光的视角。本节我们的焦点是在各种方向生成动态阴影，这个技术可以适用于点光源，生成所有方向上的阴影。这个技术叫做点光阴影，过去的名字是万向阴影贴图（omnidirectional shadow maps）技术。</p>
<p>本节代码基于前面的阴影贴图教程， 算法和定向阴影贴图差不多：我们从光的透视图生成一个深度贴图，基于当前fragment位置来对深度贴图采样，然后用储存的深度值和每个fragment进行对比，看看它是否在阴影中。定向阴影贴图和万向阴影贴图的主要不同在于深度贴图的使用上。对于深度贴图，我们需要从一个点光源的所有渲染场景，普通2D深度贴图不能工作；如果我们使用立方体贴图会怎样？因为立方体贴图可以储存6个面的环境数据，它可以将整个场景渲染到立方体贴图的每个面上，把它们当作点光源四周的深度值来采样。</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/point_shadows_diagram.png" class="" title="img">

<p>生成后的深度立方体贴图被传递到光照像素着色器，它会用一个方向向量来采样立方体贴图，从而得到当前的fragment的深度（从光的透视图）。大部分复杂的事情已经在阴影贴图教程中讨论过了。算法只是在深度立方体贴图生成上稍微复杂一点。</p>
<h2 id="生成深度立方体贴图"><a href="#生成深度立方体贴图" class="headerlink" title="生成深度立方体贴图"></a>生成深度立方体贴图</h2><p>为创建一个光周围的深度值的立方体贴图，我们必须渲染场景6次：每次一个面。显然渲染场景6次需要6个不同的视图矩阵，每次把一个不同的立方体贴图面附加到帧缓冲对象上。这看起来是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    GLuint face = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i;</span><br><span class="line">    <span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, face, depthCubemap, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">BindViewMatrix</span>(lightViewMatrices[i]);</span><br><span class="line">    <span class="built_in">RenderScene</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会很耗费性能因为一个深度贴图下需要进行很多渲染调用。我们将转而使用另外的一个小技巧来做这件事，几何着色器允许我们使用一次渲染过程来建立深度立方体贴图。</p>
<p>首先，我们需要创建一个立方体贴图：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint depthCubemap;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;depthCubemap);</span><br></pre></td></tr></table></figure>

<p>然后生成立方体贴图的每个面，将它们作为2D深度值纹理图像：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> GLuint SHADOW_WIDTH = <span class="number">1024</span>, SHADOW_HEIGHT = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, depthCubemap);</span><br><span class="line"><span class="keyword">for</span> (GLuint i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, <span class="number">0</span>, GL_DEPTH_COMPONENT, </span><br><span class="line">                     SHADOW_WIDTH, SHADOW_HEIGHT, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>不要忘记设置合适的纹理参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure>

<p>正常情况下，我们把立方体贴图纹理的一个面附加到帧缓冲对象上，渲染场景6次，每次将帧缓冲的深度缓冲目标改成不同立方体贴图面。由于我们将使用一个几何着色器，它允许我们把所有面在一个过程渲染，我们可以使用glFramebufferTexture直接把立方体贴图附加成帧缓冲的深度附件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glFramebufferTexture</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthCubemap, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glDrawBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glReadBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>还要记得调用glDrawBuffer和glReadBuffer：当生成一个深度立方体贴图时我们只关心深度值，所以我们必须显式告诉OpenGL这个帧缓冲对象不会渲染到一个颜色缓冲里。</p>
<p>万向阴影贴图有两个渲染阶段：首先我们生成深度贴图，然后我们正常使用深度贴图渲染，在场景中创建阴影。帧缓冲对象和立方体贴图的处理看起是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. first render to depth cubemap</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. then render scene as normal with shadow mapping (using depth cubemap)</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, depthCubemap);</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>

<p>这个过程和默认的阴影映射一样，尽管这次我们渲染和使用的是一个立方体贴图深度纹理，而不是2D深度纹理。在我们实际开始从光的视角的所有方向渲染场景之前，我们先得计算出合适的变换矩阵。</p>
<h3 id="光空间的变换"><a href="#光空间的变换" class="headerlink" title="光空间的变换"></a>光空间的变换</h3><p>设置了帧缓冲和立方体贴图，我们需要一些方法来将场景的所有几何体变换到6个光的方向中相应的光空间。与阴影贴图教程类似，我们需要一个光空间的变换矩阵T，但是这次是每个面都有一个。每个光空间的变换矩阵包含了投影和视图矩阵。对于投影矩阵来说，我们将使用一个透视投影矩阵；光源代表一个空间中的点，所以透视投影矩阵更有意义。每个光空间变换矩阵使用同样的投影矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLfloat aspect = (GLfloat)SHADOW_WIDTH/(GLfloat)SHADOW_HEIGHT;</span><br><span class="line">GLfloat near = <span class="number">1.0f</span>;</span><br><span class="line">GLfloat far = <span class="number">25.0f</span>;</span><br><span class="line">glm::mat4 shadowProj = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), aspect, near, far);</span><br></pre></td></tr></table></figure>

<p>非常重要的一点是，这里glm::perspective的视野参数，设置为90度。90度我们才能保证视野足够大到可以合适地填满立方体贴图的一个面，立方体贴图的所有面都能与其他面在边缘对齐。</p>
<p>因为投影矩阵在每个方向上并不会改变，我们可以在6个变换矩阵中重复使用。我们要为每个方向提供一个不同的视图矩阵。用glm::lookAt创建6个观察方向，每个都按顺序注视着立方体贴图的的一个方向：右、左、上、下、近、远：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;glm::mat4&gt; shadowTransforms;</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">-1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">-1.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">-1.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>)));</span><br></pre></td></tr></table></figure>

<p>这里我们创建了6个视图矩阵，把它们乘以投影矩阵，来得到6个不同的光空间变换矩阵。glm::lookAt的target参数是它注视的立方体贴图的面的一个方向。这些变换矩阵将会被发送到着色器渲染到立方体贴图里。</p>
<h3 id="深度着色器"><a href="#深度着色器" class="headerlink" title="深度着色器"></a>深度着色器</h3><p>为了把值渲染到深度立方体贴图，我们将需要3个着色器：顶点和像素着色器，以及一个它们之间的几何着色器。几何着色器是负责将所有世界空间的顶点变换到6个不同的光空间的着色器。因此顶点着色器简单地将顶点变换到世界空间，然后直接发送到几何着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = model * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着几何着色器以3个三角形的顶点作为输入，它还有一个光空间变换矩阵的uniform数组。几何着色器接下来会负责将顶点变换到光空间。几何着色器有一个内建变量叫做gl_Layer，它指定发散出基本图形送到立方体贴图的哪个面。当不管它时，几何着色器就会像往常一样把它的基本图形发送到输送管道的下一阶段，但当我们更新这个变量就能控制每个基本图形将渲染到立方体贴图的哪一个面。当然这只有当我们有了一个附加到激活的帧缓冲的立方体贴图纹理才有效：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (triangles) in;</span><br><span class="line"><span class="built_in">layout</span> (triangle_strip, max_vertices=<span class="number">18</span>) out;</span><br><span class="line"></span><br><span class="line">uniform mat4 shadowMatrices[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">out vec4 FragPos; <span class="comment">// FragPos from GS (output per emitvertex)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> face = <span class="number">0</span>; face &lt; <span class="number">6</span>; ++face)</span><br><span class="line">    &#123;</span><br><span class="line">        gl_Layer = face; <span class="comment">// built-in variable that specifies to which face we render.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) <span class="comment">// for each triangle&#x27;s vertices</span></span><br><span class="line">        &#123;</span><br><span class="line">            FragPos = gl_in[i].gl_Position;</span><br><span class="line">            gl_Position = shadowMatrices[face] * FragPos;</span><br><span class="line">            <span class="built_in">EmitVertex</span>();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">EndPrimitive</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几何着色器相对简单。我们输入一个三角形，输出总共6个三角形（6*3顶点，所以总共18个顶点）。在main函数中，我们遍历立方体贴图的6个面，我们每个面指定为一个输出面，把这个面的interger（整数）存到gl_Layer。然后，我们通过把面的光空间变换矩阵乘以FragPos，将每个世界空间顶点变换到相关的光空间，生成每个三角形。注意，我们还要将最后的FragPos变量发送给像素着色器，我们需要计算一个深度值。在之前的教程中，我们使用的是一个空的像素着色器，让OpenGL配置深度贴图的深度值。但这次我们将计算自己的深度，这个深度就是每个fragment位置和光源位置之间的线性距离。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">in vec4 FragPos;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform <span class="type">float</span> far_plane;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get distance between fragment and light source</span></span><br><span class="line">    <span class="type">float</span> lightDistance = <span class="built_in">length</span>(FragPos.xyz - lightPos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map to [0;1] range by dividing by far_plane</span></span><br><span class="line">    lightDistance = lightDistance / far_plane;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write this as modified depth</span></span><br><span class="line">    gl_FragDepth = lightDistance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像素着色器将来自几何着色器的片段位置、光的位置向量和视锥的远平面值作为输入。这里我们把片段和光源之间的距离，映射到0到1的范围，把它写入为fragment的深度值。使用这些着色器渲染场景，立方体贴图附加的帧缓冲对象激活以后，你会得到一个完全填充的深度立方体贴图，以便于进行第二阶段的阴影计算。</p>
<h2 id="万向阴影贴图"><a href="#万向阴影贴图" class="headerlink" title="万向阴影贴图"></a>万向阴影贴图</h2><p>所有事情都做好了，是时候来渲染万向阴影(Omnidirectional Shadow)了。这个过程和定向阴影贴图教程相似，尽管这次我们绑定的深度贴图是一个立方体贴图，而不是2D纹理，并且将光的投影的远平面发送给了着色器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">shader.<span class="built_in">Use</span>();  </span><br><span class="line"><span class="comment">// ... send uniforms to shader (including light&#x27;s far_plane value)</span></span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, depthCubemap);</span><br><span class="line"><span class="comment">// ... bind other textures</span></span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>

<p>这里的renderScene函数在一个大立方体房间中渲染一些立方体，它们散落在大立方体各处，光源在场景中央。顶点着色器和像素着色器和原来的阴影贴图着色器大部分都一样：不同之处是在光空间中像素着色器不再需要一个fragment位置，现在我们可以使用一个方向向量采样深度值。因为这个顶点着色器不再需要将他的位置向量变换到光空间，所以我们可以去掉FragPosLightSpace变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 texCoords;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">    vs_out.FragPos = <span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>));</span><br><span class="line">    vs_out.Normal = <span class="built_in">transpose</span>(<span class="built_in">inverse</span>(<span class="built_in">mat3</span>(model))) * normal;</span><br><span class="line">    vs_out.TexCoords = texCoords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器的Blinn-Phong光照代码和我们之前阴影相乘的结尾部分一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseTexture;</span><br><span class="line">uniform samplerCube depthMap;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line">uniform <span class="type">float</span> far_plane;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(diffuseTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    vec3 lightColor = <span class="built_in">vec3</span>(<span class="number">0.3</span>);</span><br><span class="line">    <span class="comment">// Ambient</span></span><br><span class="line">    vec3 ambient = <span class="number">0.3</span> * color;</span><br><span class="line">    <span class="comment">// Diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    <span class="comment">// Specular</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">64.0</span>);</span><br><span class="line">    vec3 specular = spec * lightColor;    </span><br><span class="line">    <span class="comment">// Calculate shadow</span></span><br><span class="line">    <span class="type">float</span> shadow = <span class="built_in">ShadowCalculation</span>(fs_in.FragPos);                      </span><br><span class="line">    vec3 lighting = (ambient + (<span class="number">1.0</span> - shadow) * (diffuse + specular)) * color;    </span><br><span class="line"></span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(lighting, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一些细微的不同：光照代码一样，但我们现在有了一个uniform变量samplerCube，shadowCalculation函数用片段的位置作为它的参数，取代了光空间的片段位置。我们现在还要引入光的视锥的远平面值，后面我们会需要它。像素着色器的最后，我们计算出阴影元素，当片段在阴影中时它是1.0，不在阴影中时是0.0。我们使用计算出来的阴影元素去影响光照的diffuse和specular元素。在ShadowCalculation函数中有很多不同之处，现在是从立方体贴图中进行采样，不再使用2D纹理了。</p>
<p>我们需要做的第一件事是获取立方体贴图的深度。我们已经将深度储存为片段和光位置之间的距离了，所以我们这里采用相似的处理方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 fragToLight = fragPos - lightPos; </span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight).r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们得到了片段的位置与光的位置之间的差向量，使用这个向量作为一个方向向量去对立方体贴图进行采样。方向向量不需要是单位向量，所以无需对它进行标准化。最后的closestDepth是光源和它最接近的可见片段之间的标准化的深度值。closestDepth值现在在0到1的范围内了，所以我们先将其转换回0到far_plane的范围，这需要把他乘以far_plane：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closestDepth *= far_plane;</span><br></pre></td></tr></table></figure>

<p>下一步我们获取当前fragment和光源之间的深度值，我们可以简单的使用fragToLight的长度来获取它，这取决于我们如何计算立方体贴图中的深度值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> currentDepth = <span class="built_in">length</span>(fragToLight);</span><br></pre></td></tr></table></figure>

<p>返回的是和closestDepth范围相同的深度值。</p>
<p>现在我们可以将两个深度值对比一下，看看哪一个更接近，以此决定当前的fragment是否在阴影当中。我们还要包含一个阴影偏移，才能避免阴影失真：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="number">0.05</span>; </span><br><span class="line"><span class="type">float</span> shadow = currentDepth -  bias &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>现在完整的ShadowCalculation现在变成了这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get vector between fragment position and light position</span></span><br><span class="line">    vec3 fragToLight = fragPos - lightPos;</span><br><span class="line">    <span class="comment">// Use the light to fragment vector to sample from the depth map    </span></span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight).r;</span><br><span class="line">    <span class="comment">// It is currently in linear range between [0,1]. Re-transform back to original value</span></span><br><span class="line">    closestDepth *= far_plane;</span><br><span class="line">    <span class="comment">// Now get current linear depth as the length between the fragment and light position</span></span><br><span class="line">    <span class="type">float</span> currentDepth = <span class="built_in">length</span>(fragToLight);</span><br><span class="line">    <span class="comment">// Now test for shadows</span></span><br><span class="line">    <span class="type">float</span> bias = <span class="number">0.05</span>; </span><br><span class="line">    <span class="type">float</span> shadow = currentDepth -  bias &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这些着色器，我们已经能得到非常好的阴影效果了，这次从一个点光源所有周围方向上都有阴影。有一个位于场景中心的点光源，看起来会像这样：</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/image-20241204122230684.png" class="" title="image-20241204122230684">

<p>在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/point_shadow.rar">这里</a>可以获取程序的完整代码</p>
<h3 id="显示立方体贴图深度缓冲"><a href="#显示立方体贴图深度缓冲" class="headerlink" title="显示立方体贴图深度缓冲"></a>显示立方体贴图深度缓冲</h3><p>如果要进行调试排错，将深度贴图显示出来以检查其是否正确。因为我们不再用2D深度贴图纹理，一个简单的把深度缓冲显示出来的技巧是，在ShadowCalculation函数中计算标准化的closestDepth变量，把变量显示，修改片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseTexture;</span><br><span class="line">uniform samplerCube depthMap;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line">uniform <span class="type">float</span> far_plane;</span><br><span class="line">uniform <span class="type">bool</span> shadows;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 fragToLight = fragPos - lightPos;</span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight).r;</span><br><span class="line">    closestDepth *= far_plane; </span><br><span class="line">    <span class="type">float</span> currentDepth = <span class="built_in">length</span>(fragToLight);</span><br><span class="line">    <span class="type">float</span> bias = <span class="number">0.05</span>;</span><br><span class="line">    <span class="type">float</span> shadow = currentDepth -  bias &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(diffuseTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    vec3 lightColor = <span class="built_in">vec3</span>(<span class="number">0.3</span>);</span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    vec3 ambient = <span class="number">0.3</span> * lightColor;</span><br><span class="line">    <span class="comment">// diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">64.0</span>);</span><br><span class="line">    vec3 specular = spec * lightColor;    </span><br><span class="line">    <span class="comment">// calculate shadow</span></span><br><span class="line">    <span class="comment">// float shadow = shadows ? ShadowCalculation(fs_in.FragPos) : 0.0;                      </span></span><br><span class="line">    <span class="comment">// vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;</span></span><br><span class="line">    vec3 fragToLight = fs_in.FragPos - lightPos;</span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight).r;</span><br><span class="line">    closestDepth *= far_plane; </span><br><span class="line">    </span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(<span class="built_in">vec3</span>(closestDepth / far_plane), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是一个灰度场景，每个颜色代表着场景的线性深度值：</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/image-20241204123534486.png" class="" title="image-20241204123534486">

<p>你可能也注意到了阴影部分在墙外。如果看起来和这个差不多，你就知道深度立方体贴图生成的没错。否则你可能做错了什么，也许是closestDepth仍然还在0到far_plane的范围。</p>
<h2 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h2><p>由于万向阴影贴图基于传统阴影贴图的原则，它便也继承了由解析度产生的非真实感。如果你放大就会看到锯齿边了。PCF（Percentage-closer filtering）允许我们通过对片段位置周围过滤多个样本，并对结果平均化。如果我们用和之前教程同样的那个简单的PCF过滤器，并加入第三个维度，就是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> bias = <span class="number">0.05</span>; </span><br><span class="line"><span class="type">float</span> samples = <span class="number">4.0</span>;</span><br><span class="line"><span class="type">float</span> offset = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">float</span> x = -offset; x &lt; offset; x += offset / (samples * <span class="number">0.5</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">float</span> y = -offset; y &lt; offset; y += offset / (samples * <span class="number">0.5</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">float</span> z = -offset; z &lt; offset; z += offset / (samples * <span class="number">0.5</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight + <span class="built_in">vec3</span>(x, y, z)).r; </span><br><span class="line">            closestDepth *= far_plane;   <span class="comment">// Undo mapping [0;1]</span></span><br><span class="line">            <span class="keyword">if</span>(currentDepth - bias &gt; closestDepth)</span><br><span class="line">                shadow += <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">shadow /= (samples * samples * samples);</span><br></pre></td></tr></table></figure>

<p>这段代码和我们传统的阴影贴图没有多少不同。这里我们根据样本的数量动态计算了纹理偏移量，我们在三个轴向采样三次，最后对子样本进行平均化。现在阴影看起来更加柔和平滑了，由此得到更加真实的效果：</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/image-20241204124224499.png" class="" title="image-20241204124224499">

<p>当samples设置为4.0，每个fragment我们会得到总共64个样本，这太多了！大多数这些采样都是多余的，与其在原始方向向量附近处采样，不如在采样方向向量的垂直方向进行采样更有意义。可是，并没有什么简单的方式能够指出哪一个子方向是多余的。可以使用一个技巧，用一个偏移量方向数组，它们差不多都是分开的，每一个指向完全不同的方向，剔除彼此接近的那些子方向。下面就是一个有着20个偏移方向的数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vec3 sampleOffsetDirections[<span class="number">20</span>] = vec3[]</span><br><span class="line">(</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">1</span>), </span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>, <span class="number">-1</span>),</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">0</span>), <span class="built_in">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">0</span>),</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">0</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">0</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">0</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>( <span class="number">0</span>,  <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>然后我们把PCF算法与从sampleOffsetDirections得到的样本数量进行适配，使用它们从立方体贴图里采样。这么做的好处是与之前的PCF算法相比，我们需要的样本数量变少了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 fragToLight = fragPos - lightPos;</span><br><span class="line">    <span class="type">float</span> currentDepth = <span class="built_in">length</span>(fragToLight);</span><br><span class="line">    <span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">float</span> bias = <span class="number">0.15</span>;</span><br><span class="line">    <span class="type">int</span> samples = <span class="number">20</span>;</span><br><span class="line">    <span class="type">float</span> viewDistance = <span class="built_in">length</span>(viewPos - fragPos);</span><br><span class="line">    <span class="type">float</span> diskRadius = (<span class="number">1.0</span> + (viewDistance / far_plane)) / <span class="number">25.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; samples; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;</span><br><span class="line">        closestDepth *= far_plane;</span><br><span class="line">        <span class="keyword">if</span>(currentDepth - bias &gt; closestDepth)</span><br><span class="line">            shadow += <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    shadow /= <span class="built_in">float</span>(samples);  </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们把一个偏移量添加到指定的diskRadius中，它在fragToLight方向向量周围从立方体贴图里采样。另一个在这里可以应用的有意思的技巧是，我们可以基于观察者里一个fragment的距离来改变diskRadius；这样我们就能根据观察者的距离来增加偏移半径了，当距离更远的时候阴影更柔和，更近了就更锐利。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> diskRadius = (<span class="number">1.0</span> + (viewDistance / far_plane)) / <span class="number">25.0</span>;</span><br></pre></td></tr></table></figure>

<p>这是柔和的阴影效果：</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/image-20241217153523483.png" class="" title="image-20241217153523483">

<p>当然了，我们添加到每个样本的bias（偏移）高度依赖于上下文，总是要根据场景进行微调的。试试这些值，看看怎样影响了场景。<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/point_shadow_soft.rar">这里</a>是最终的完整代码。</p>
<p>使用几何着色器来生成深度贴图不一定会比每个面渲染场景6次更快。使用几何着色器有它自己的性能局限，在第一个阶段使用它可能获得更好的性能表现。这取决于环境的类型，以及特定的显卡驱动等等，如果你很关心性能，就要确保对两种方法有大致了解，然后选择对你场景来说更高效的那个。使用几何着色器来进行阴影贴图的绘制的原因很简单，因为它们使用起来更简单。</p>
<h2 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a>附加资源</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.sunandblackcat.com/tipFullView.php?l=eng&topicid=36">Shadow Mapping for point light sources in OpenGL</a>：sunandblackcat的万向阴影贴图教程。</li>
<li><a target="_blank" rel="noopener" href="http://ogldev.atspace.co.uk/www/tutorial43/tutorial43.html">Multipass Shadow Mapping With Point Lights</a>：ogldev的万向阴影贴图教程。</li>
<li><a target="_blank" rel="noopener" href="http://www.cg.tuwien.ac.at/~husky/RTR/OmnidirShadows-whyCaps.pdf">Omni-directional Shadows</a>：Peter Houska的关于万向阴影贴图的一组很好的ppt。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/" class="post-title-link" itemprop="url">31-阴影贴图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-14 20:45:41" itemprop="dateCreated datePublished" datetime="2024-10-14T20:45:41+08:00">2024-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-03 17:52:25" itemprop="dateModified" datetime="2024-12-03T17:52:25+08:00">2024-12-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>阴影是光线被阻挡的结果；当一个光源的光线由于其他物体的阻挡不能够达到一个物体的表面的时候，那么这个物体就处在阴影中了。阴影能够使场景看起来真实得多，并且可以让观察者获得物体之间的空间位置关系，场景和物体的深度感能够得到极大提升。</p>
<p>阴影还是比较不好实现的，因为当前实时渲染领域还没找到一种完美的阴影算法。目前有几种近似阴影技术，但它们都有自己的缺点和不足，这是我们必须要考虑到的。视频游戏中较多使用的一种技术是阴影贴图（shadow mapping），效果不错，而且相对容易实现。阴影贴图并不难以理解，性能也不会太低，而且非常容易扩展成更高级的算法。</p>
<h2 id="阴影贴图"><a href="#阴影贴图" class="headerlink" title="阴影贴图"></a>阴影贴图</h2><p>阴影映射(Shadow Mapping)背后的思路非常简单：我们以光的位置为视角进行渲染，我们能看到的东西都将被点亮，看不见的一定是在阴影之中了。假设有一个地板，在光源和它之间有一个大盒子。由于光源处向光线方向看去，可以看到这个盒子，但看不到地板的一部分，这部分就应该在阴影中了。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_theory.png" class="" title="img">

<p>这里的所有蓝线代表光源可以看到的fragment。黑线代表被遮挡的fragment：它们应该渲染为带阴影的。如果我们绘制一条从光源出发，到达最右边盒子上的一个片段上的线段或射线，那么射线将先击中悬浮的盒子，随后才会到达最右侧的盒子。结果就是悬浮的盒子被照亮，而最右侧的盒子将处于阴影之中。</p>
<p>我们希望得到射线第一次击中的那个物体，然后用这个最近点和射线上其他点进行对比。然后我们将测试一下看看射线上的其他点是否比最近点更远，如果是的话，这个点就在阴影中。对从光源发出的射线上的成千上万个点进行遍历是个极端消耗性能的举措，实时渲染上基本不可取。我们可以采取相似举措，不用投射出光的射线，使用另一个非常熟悉的东西：深度缓冲。</p>
<p>在深度缓冲里的一个值是摄像机视角下，对应于一个片段的一个0到1之间的深度值。如果我们从光源的透视图来渲染场景，并把深度值的结果储存到纹理中。通过这种方式，我们就能对光源的透视图所见的最近的深度值进行采样。最终，深度值就会显示从光源的透视图下见到的第一个片段了。我们把储存在纹理中的所有这些深度值，叫做深度贴图（depth map）或阴影贴图。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_theory_spaces.png" class="" title="img">

<p>左侧的图片展示了一个定向光源（所有光线都是平行的）在立方体下的表面投射的阴影。通过储存到深度贴图中的深度值，我们就能找到最近点，用以决定片段是否在阴影中。我们使用一个来自光源的视图和投影矩阵来渲染场景就能创建一个深度贴图。这个投影和视图矩阵结合在一起成为一个<em><strong>T</strong></em>变换，它可以将任何三维位置转变到光源的可见坐标空间。</p>
<p><em>定向光并没有位置，因为它被规定为无穷远。然而，为了实现阴影贴图，我们得从一个光的透视图渲染场景，这样就得在光的方向的某一点上渲染场景。</em></p>
<p>在右边的图中我们显示出同样的平行光和观察者。我们渲染一个点P处的片段，需要决定它是否在阴影中。我们先得使用<em><strong>T</strong></em>把P变换到光源的坐标空间里。既然点P是从光的透视图中看到的，它的z坐标就对应于它的深度，例子中这个值是0.9。使用点P在光源的坐标空间的坐标，我们可以索引深度贴图，来获得从光的视角中最近的可见深度，结果是点C，最近的深度是0.4。因为索引深度贴图的结果是一个小于点P的深度，我们可以断定P被挡住了，它在阴影中了。</p>
<p>阴影映射由两个步骤组成：首先，我们渲染深度贴图，然后我们像往常一样渲染场景，使用生成的深度贴图来计算片段是否在阴影之中。</p>
<h3 id="深度贴图"><a href="#深度贴图" class="headerlink" title="深度贴图"></a>深度贴图</h3><p>第一步我们需要生成一张深度贴图(Depth Map)。深度贴图是从光的透视图里渲染的深度纹理，用它计算阴影。因为我们需要将场景的渲染结果储存到一个纹理中，所以我们需要再次用到帧缓冲。</p>
<p>首先，为渲染的深度贴图创建一个帧缓冲对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint depthMapFBO;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;depthMapFBO);</span><br></pre></td></tr></table></figure>

<p>然后，创建一个2D纹理，提供给帧缓冲的深度缓冲使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> GLuint SHADOW_WIDTH = <span class="number">1024</span>, SHADOW_HEIGHT = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">GLuint depthMap;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;depthMap);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, depthMap);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT, </span><br><span class="line">             SHADOW_WIDTH, SHADOW_HEIGHT, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br></pre></td></tr></table></figure>

<p>生成深度贴图不会太复杂。因为只关心深度值，所以把纹理格式指定为GL_DEPTH_COMPONENT，并且把纹理的高宽设置为1024：深度贴图的分辨率。把生成的深度纹理作为帧缓冲的深度缓冲：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glDrawBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glReadBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>我们需要的只是在从光的透视图下渲染场景的时候深度信息，所以颜色缓冲没有用。但是，不包含颜色缓冲的帧缓冲对象是不完整的，所以需要告诉OpenGL不适用任何颜色数据进行渲染。将调用glDrawBuffer和glReadBuffer把读和绘制缓冲设置为GL_NONE。合理配置将深度值渲染到纹理的帧缓冲后，就可以开始第一步了：生成深度贴图。两个步骤的完整的渲染阶段，看起来有点像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首选渲染深度贴图</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. 像之前一样渲染场景，但这次使用深度贴图</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, depthMap);</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>

<p>这段代码隐去了一些细节，但它表达了阴影映射的基本思路。这里一定要记得调用glViewport。因为阴影贴图经常和原来渲染的场景（通常是窗口分辨率）有着不同的分辨率，需要改变视口（viewport）的参数以适应阴影贴图的尺寸。如果我们忘了更新视口参数，最后的深度贴图要么太小要么就不完整。</p>
<h4 id="光源空间的变换"><a href="#光源空间的变换" class="headerlink" title="光源空间的变换"></a>光源空间的变换</h4><p>前面那段代码中一个不清楚的函数是<code>ConfigureShaderAndMatrices</code>。它是用来在第二个步骤确保为每个物体设置了合适的投影和视图矩阵，以及相关的模型矩阵。然而，第一个步骤中，我们从光的位置的视野下使用了不同的投影和视图矩阵来渲染的场景。</p>
<p>因为我们使用的是一个所有光线都平行的定向光。出于这个原因，我们将为光源使用正交投影矩阵，透视图将没有任何变形：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLfloat near_plane = <span class="number">1.0f</span>, far_plane = <span class="number">7.5f</span>;</span><br><span class="line">glm::mat4 lightProjection = glm::<span class="built_in">ortho</span>(<span class="number">-10.0f</span>, <span class="number">10.0f</span>, <span class="number">-10.0f</span>, <span class="number">10.0f</span>, near_plane, far_plane);</span><br></pre></td></tr></table></figure>

<p>这里有个本节教程的demo场景中使用的正交投影矩阵的例子。因为投影矩阵间接决定可视区域的范围，以及哪些东西不会被裁切，你需要保证投影视锥（frustum）的大小，以包含打算在深度贴图中包含的物体。当物体和片段不在深度贴图中时，它们就不会产生阴影。</p>
<p>为了创建一个视图矩阵来变换每个物体，把它们变换到从光源视角可见的空间中，我们将使用glm::lookAt函数；这次从光源的位置看向场景中央。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 lightView = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(<span class="number">-2.0f</span>, <span class="number">4.0f</span>, <span class="number">-1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>

<p>二者相结合为我们提供了一个光空间的变换矩阵，它将每个世界空间坐标变换到光源处所见到的那个空间；这正是我们渲染深度贴图所需要的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 lightSpaceMatrix = lightProjection * lightView;</span><br></pre></td></tr></table></figure>

<p>这个lightSpaceMatrix正是前面我们称为TT的那个变换矩阵。有了lightSpaceMatrix只要给shader提供光空间的投影和视图矩阵，我们就能像往常那样渲染场景了。然而，我们只关心深度值，并非所有片段计算都在我们的着色器中进行。为了提升性能，我们将使用一个与之不同但更为简单的着色器来渲染出深度贴图。</p>
<h4 id="渲染至深度贴图"><a href="#渲染至深度贴图" class="headerlink" title="渲染至深度贴图"></a>渲染至深度贴图</h4><p>当我们以光的透视图进行场景渲染的时候，会用一个比较简单的着色器，这个着色器把顶点变换到光空间。这个简单的着色器叫做<code>simpleDepthShader</code>，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line">uniform mat4 lightSpaceMatrix;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = lightSpaceMatrix * model * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个顶点着色器将一个单独模型的一个顶点，使用lightSpaceMatrix变换到光空间中。由于我们没有颜色缓冲，最后的片段不需要任何处理，所以我们可以简单地使用一个空的片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="comment">// gl_FragDepth = gl_FragCoord.z;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个空的片段着色器什么也不干，运行完后，深度缓冲会被更新。可以取消那行的注释，来显式设置深度，但是这个（指注释掉那行之后）是更有效率的，因为底层无论如何都会默认去设置深度缓冲。渲染深度缓冲现在成了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">simpleDepthShader.<span class="built_in">Use</span>();</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(lightSpaceMatrixLocation, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(lightSpaceMatrix));</span><br><span class="line"></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">RenderScene</span>(simpleDepthShader);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>RenderScene函数的参数是一个着色器程序（shader program），它调用所有相关的绘制函数，并在需要的地方设置相应的模型矩阵。最后，在光的透视图视角下，很完美地用每个可见片段的最近深度填充了深度缓冲。通过将这个纹理投射到一个2D四边形上，就能在屏幕上显示出来，运行结果如下：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241118124001483.png" class="" title="image-20241118124001483">将深度贴图渲染到四边形上的片段着色器：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 color;</span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D depthMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="type">float</span> depthValue = <span class="built_in">texture</span>(depthMap, TexCoords).r;</span><br><span class="line">    color = <span class="built_in">vec4</span>(<span class="built_in">vec3</span>(depthValue), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是当用透视投影矩阵取代正交投影矩阵来显示深度时，有一些轻微的改动，因为使用透视投影时，深度是非线性的。</p>
<p>你可以在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/ec9d678b2e57eb1b487568cadc2bd46d4b8b2be3/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/41_shadow_mapping_depth.rar">这里</a>获得把场景渲染成深度贴图的源码。</p>
<h2 id="渲染阴影"><a href="#渲染阴影" class="headerlink" title="渲染阴影"></a>渲染阴影</h2><p>当正确地生成深度贴图后，我们就可以开始渲染阴影了。下面这段代码在片段着色器中执行，用来检验一个片段是否在阴影之中，不过我们在顶点着色器中进行光空间的变换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 texCoords;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec4 FragPosLightSpace;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 lightSpaceMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">    vs_out.FragPos = <span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>));</span><br><span class="line">    vs_out.Normal = <span class="built_in">transpose</span>(<span class="built_in">inverse</span>(<span class="built_in">mat3</span>(model))) * normal;</span><br><span class="line">    vs_out.TexCoords = texCoords;</span><br><span class="line">    vs_out.FragPosLightSpace = lightSpaceMatrix * <span class="built_in">vec4</span>(vs_out.FragPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加了一个新的输出向量FragPosLightSpace，用同一个lightSpaceMatrix，把世界空间顶点位置转换为光空间。顶点着色器传递一个普通的经变换的世界空间顶点位置vs_out.FragPos和一个光空间的vs_out.FragPosLightSpace给片段着色器。</p>
<p>片段着色器使用Blinn-Phong光照模型渲染场景。接着计算出一个shadow值，当fragment在阴影中时是1.0，在阴影外是0.0。然后，diffuse和specular颜色会乘以这个阴影元素。由于阴影不会是全黑的，所以我们把ambient分量从乘法中剔除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec4 FragPosLightSpace;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseTexture;</span><br><span class="line">uniform sampler2D shadowMap;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(diffuseTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    vec3 lightColor = <span class="built_in">vec3</span>(<span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// Ambient</span></span><br><span class="line">    vec3 ambient = <span class="number">0.15</span> * color;</span><br><span class="line">    <span class="comment">// Diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    <span class="comment">// Specular</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">64.0</span>);</span><br><span class="line">    vec3 specular = spec * lightColor;    </span><br><span class="line">    <span class="comment">// 计算阴影</span></span><br><span class="line">    <span class="type">float</span> shadow = <span class="built_in">ShadowCalculation</span>(fs_in.FragPosLightSpace);       </span><br><span class="line">    vec3 lighting = (ambient + (<span class="number">1.0</span> - shadow) * (diffuse + specular)) * color;    </span><br><span class="line"></span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(lighting, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器大部分是从高级光照教程中复制过来，只不过加上了个阴影计算。我们声明一个shadowCalculation函数，用它计算阴影。片段着色器的最后，我们把diffuse和specular乘以(1-阴影元素)，这表示这个片段有多大成分不在阴影中。这个片段着色器还需要两个额外输入，一个是光空间的片段位置和第一个渲染阶段得到的深度贴图。</p>
<p>首先要检查一个片段是否在阴影中，把光空间片段位置转换为裁切空间的标准化设备坐标。当我们在顶点着色器输出一个裁切空间顶点位置到gl_Position时，OpenGL自动进行一个透视除法，将裁切空间坐标的范围-w到w转为-1到1，这将x、y、z元素除以向量的w元素来实现。由于裁切空间的FragPosLightSpace并不会通过gl_Position传到片段着色器里，我们必须自己做透视除法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行透视除法</span></span><br><span class="line">    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数返回了片段在光空间的-1到1的范围。</p>
<p>当使用正交投影矩阵，顶点w元素仍保持不变，所以这一步实际上毫无意义。可是，当使用透视投影的时候就是必须的了，所以为了保证在两种投影矩阵下都有效就得留着这行代码。</p>
<p>因为来自深度贴图的深度在0到1的范围，我们也打算使用projCoords从深度贴图中去采样，所以将NDC坐标变换为0到1的范围。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<p>有了投影坐标，就能从深度贴图中采样得到0到1的结果，从第一个渲染阶段的projCoords坐标直接对应于变换过的NDC坐标。我们将得到光的位置视野下最近的深度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> closestDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy).r;</span><br></pre></td></tr></table></figure>

<p>为了得到片段的当前深度，获取投影向量的z坐标，它等于来自光的透视视角的片段的深度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> currentDepth = projCoords.z;</span><br></pre></td></tr></table></figure>

<p>实际的对比就是简单检查currentDepth是否高于closetDepth，如果是，那么片段就在阴影中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>完整的shadowCalculation函数是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行透视除法</span></span><br><span class="line">    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    <span class="comment">// 变换到[0,1]的范围</span></span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)</span></span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy).r; </span><br><span class="line">    <span class="comment">// 取得当前片段在光源视角下的深度</span></span><br><span class="line">    <span class="type">float</span> currentDepth = projCoords.z;</span><br><span class="line">    <span class="comment">// 检查当前片段是否在阴影中</span></span><br><span class="line">    <span class="type">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>激活这个着色器，绑定合适的纹理，激活第二个渲染阶段默认的投影以及视图矩阵，结果如下图所示：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241129162924357.png" class="" title="image-20241129162924357">

<p>如上图所示，你会看到地板和上有立方体的阴影。可以从<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/ec9d678b2e57eb1b487568cadc2bd46d4b8b2be3/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/42_render_shadow.rar">这里</a>找到demo程序的代码。</p>
<h2 id="改进阴影贴图"><a href="#改进阴影贴图" class="headerlink" title="改进阴影贴图"></a>改进阴影贴图</h2><p>我们现在成功让阴影贴图工作了，但是阴影贴图还是不够真实，接下来我们要尝试修复它。</p>
<h3 id="阴影失真"><a href="#阴影失真" class="headerlink" title="阴影失真"></a>阴影失真</h3><p>目前我们绘制的场景明显有不对的地方，放大看会发现明显的线条样式：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203153007456.png" class="" title="image-20241203153007456">

<p>我们可以看到地板四边形渲染出很大一块交替黑线。这种阴影贴图的不真实感叫做<strong>阴影失真</strong>(Shadow Acne)，下图解释了成因：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_acne_diagram.png" class="" title="img">

<p>因为阴影贴图受限于分辨率，在距离光源比较远的情况下，多个片段可能从深度贴图的同一个值中去采样。图片每个斜坡代表深度贴图一个单独的纹理像素。你可以看到，多个片段从同一个深度值进行采样。虽然很多时候没问题，但是当光源以一个角度朝向表面的时候就会出问题，这种情况下深度贴图也是从一个角度下进行渲染的。多个片段就会从同一个斜坡的深度纹理像素中采样，有些在地板上面，有些在地板下面；这样我们所得到的阴影就有了差异。因为这个，有些片段被认为是在阴影之中，有些不在，由此产生了图片中的条纹样式。</p>
<p>我们可以用一个叫做<strong>阴影偏移</strong>（shadow bias）的技巧来解决这个问题，我们简单的对表面的深度（或深度贴图）应用一个偏移量，这样片段就不会被错误地认为在表面之下了。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_acne_bias.png" class="" title="img">

<p>使用了偏移量后，所有采样点都获得了比表面深度更小的深度值，这样整个表面就正确地被照亮，没有任何阴影。在阴影贴图的片段着色器中可以使用下面的代码实现偏移：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="number">0.005</span>;</span><br><span class="line"><span class="type">float</span> shadow = currentDepth - bias &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>一个0.005的偏移就能有效解决这个问题，但是有些表面坡度很大，仍然会产生阴影失真。有一个更加可靠的办法能够根据表面朝向光线的角度更改偏移量，即使用点乘：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="built_in">max</span>(<span class="number">0.05</span> * (<span class="number">1.0</span> - <span class="built_in">dot</span>(normal, lightDir)), <span class="number">0.005</span>);</span><br><span class="line"><span class="type">float</span> shadow = currentDepth - bias &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>这里我们有一个偏移量的最大值0.05，和一个最小值0.005，它们是基于表面法线和光照方向的。这样像地板这样的表面几乎与光源垂直，得到的偏移就很小，而比如立方体的侧面这种表面得到的偏移就更大。下图展示了同一个场景，但使用了阴影偏移，效果的确更好：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203154054133.png" class="" title="image-20241203154054133">

<p>使用正确的偏移数值，在不同的场景中需要一些像这样的轻微调校，但大多情况下，实际上就是增加偏移量直到所有失真都被消除。</p>
<h3 id="悬浮"><a href="#悬浮" class="headerlink" title="悬浮"></a>悬浮</h3><p>使用阴影偏移的一个缺点是你对物体的实际深度应用了平移。偏移有可能足够大，以至于可以看出阴影相对实际物体位置的偏移，你可以从下图看到这个现象（这是一个夸张的偏移值）：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203154400331.png" class="" title="image-20241203154400331">

<p>这个阴影失真叫做悬浮(Peter Panning)，因为物体看起来悬浮在表面之上。我们可以使用一个叫技巧解决大部分的悬浮问题：当渲染深度贴图时候使用正面剔除，你也许记得在面剔除教程中OpenGL默认是背面剔除。但是现在我们要告诉OpenGL我们要剔除正面。</p>
<p>因为我们只需要深度贴图的深度值，对于实体物体无论我们用它们的正面还是背面都没问题。使用背面深度不会有错误，因为阴影在物体内部有错误我们也看不见。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_culling.png" class="" title="img">

<p>为了修复悬浮，我们要进行正面剔除，先必须开启GL_CULL_FACE：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glCullFace</span>(GL_FRONT);</span><br><span class="line"><span class="built_in">RenderSceneToDepthMap</span>();</span><br><span class="line"><span class="built_in">glCullFace</span>(GL_BACK); <span class="comment">// 不要忘记设回原先的culling face</span></span><br></pre></td></tr></table></figure>

<p>这十分有效地解决了悬浮的问题，但只对封闭的实体物体有效。在现在的场景中，在立方体上工作的很好，但在地板上无效，因为正面剔除完全移除了地板。地面是一个单独的平面，不会被完全剔除。如果打算使用这个技巧解决悬浮必须考虑到，只有剔除物体的正面才有意义。另一个要考虑到的地方是接近阴影的物体仍然会出现不正确的效果。必须考虑到何时使用正面剔除对物体才有意义。不过使用普通的偏移值通常就能避免悬浮。</p>
<h3 id="采样过多"><a href="#采样过多" class="headerlink" title="采样过多"></a>采样过多</h3><p>还有一个视觉差异，就是光的视锥不可见的区域一律被认为是处于阴影中，不管它是否真的处于阴影之中。出现这个状况是因为超出光的视锥的投影坐标比1.0大，这样采样的深度纹理就会超出他默认的0到1的范围。根据纹理环绕方式，我们将会得到不正确的深度结果，它不是基于真实的来自光源的深度值。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203164257058.png" class="" title="image-20241203164257058">

<p>可以在图中看到，光照有一个区域，超出该区域的就成为了阴影；这个区域实际上代表着深度贴图的大小，这个贴图投影到了地板上。发生这种情况的原因是，之前将深度贴图的环绕方式设置成了GL_REPEAT。我们宁可让所有超出深度贴图的坐标的深度范围是1.0，这样超出的坐标将永远不在阴影之中。我们可以储存一个边框颜色，然后把深度贴图的纹理环绕选项设置为GL_CLAMP_TO_BORDER：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">GLfloat borderColor[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line"><span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure>

<p>现在如果我们采样深度贴图0到1坐标范围以外的区域，纹理函数总会返回一个1.0的深度值，阴影值为0.0。现在仍有一部分是黑暗区域，那里的坐标超出了光的正交视锥的远平面。可以看到这片黑色区域总是出现在光源视锥的极远处。当一个点比光的远平面还要远时，它的投影坐标的z坐标大于1.0。这种情况下，GL_CLAMP_TO_BORDER环绕方式不起作用，因为把坐标的z元素和深度贴图的值进行了对比，它总是为大于1.0的z返回true。</p>
<p>解决这个问题也很简单，只要投影向量的z坐标大于1.0，我们就把shadow的值强制设为0.0，修改阴影贴图的片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="keyword">if</span>(projCoords.z &gt; <span class="number">1.0</span>)</span><br><span class="line">        shadow = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查远平面，并将深度贴图限制为一个手工指定的边界颜色，就能解决深度贴图采样超出的问题，最终会得到下图所示的效果：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203165556309.png" class="" title="image-20241203165556309">

<p>这些结果意味着，只有在深度贴图范围以内的被投影的fragment坐标才有阴影，所以任何超出范围的都将会没有阴影。由于在游戏中通常这只发生在远处，所以会比之前的那个明显的黑色区域效果更真实。</p>
<h2 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h2><p>阴影现在已经被绘制到场景中了，不过这仍不是我们想要的。如果你放大看阴影，阴影贴图对分辨率的依赖很快变得很明显。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203165704357.png" class="" title="image-20241203165704357">

<p>因为深度贴图有一个固定的分辨率，多个片段对应于一个纹理像素。结果就是多个片段会从深度贴图的同一个深度值进行采样，这几个片段便得到的是同一个阴影，这就会导致产生锯齿。可以通过增加深度贴图的分辨率的方式来降低锯齿块，也可以尝试尽可能的让光的视锥接近场景。</p>
<p>另一个解决方案叫做PCF（percentage-closer filtering），这是一种多个不同过滤方式的组合，它产生柔和阴影，使它们出现更少的锯齿块和硬边。核心思想是从深度贴图中多次采样，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，就得到了柔和阴影。</p>
<p>一个简单的PCF的实现是简单的从纹理像素四周对深度贴图采样，然后把结果平均起来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line">vec2 texelSize = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(shadowMap, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-1</span>; x &lt;= <span class="number">1</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-1</span>; y &lt;= <span class="number">1</span>; ++y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> pcfDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy + <span class="built_in">vec2</span>(x, y) * texelSize).r; </span><br><span class="line">        shadow += currentDepth - bias &gt; pcfDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">shadow /= <span class="number">9.0</span>;</span><br></pre></td></tr></table></figure>

<p>textureSize返回vec2类型的采样器纹理的0级mipmap的宽和高。用1除以它返回一个单独纹理像素的大小，我们用以对纹理坐标进行偏移，确保每个新样本，来自不同的深度值。这里采样得到9个值，它们在投影坐标的x和y值的周围，为阴影阻挡进行测试，并最终通过样本的总数目将结果平均化。使用更多的样本，更改texelSize变量，你就可以增加阴影的柔和程度。下面你可以看到应用了PCF的阴影：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203171805737.png" class="" title="image-20241203171805737">

<p>从稍微远一点的距离看去，阴影效果好多了，也不那么生硬了。如果你放大，仍会看到阴影贴图分辨率的不真实感，但通常对于大多数应用来说效果已经很好了。实际上PCF还有更多的内容，以及很多技术要点需要考虑以提升柔和阴影的效果，我们将留在以后讨论。</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/ec9d678b2e57eb1b487568cadc2bd46d4b8b2be3/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/43_render_shadow_fix.rar">这里</a>可以获取修复了上述错误的完整代码。</p>
<h2 id="正交-vs-投影"><a href="#正交-vs-投影" class="headerlink" title="正交 vs 投影"></a>正交 vs 投影</h2><p>在渲染深度贴图的时候，正交(Orthographic)和投影(Projection)矩阵之间有所不同。正交投影矩阵并不会将场景用透视图进行变形，所有视线/光线都是平行的，这使它对于定向光来说是个很好的投影矩阵。然而透视投影矩阵，会将所有顶点根据透视关系进行变形，结果因此而不同。下图展示了两种投影方式所产生的不同阴影区域：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_projection.png" class="" title="img">

<p>透视投影对于光源来说更合理，不像定向光，它是有自己的位置的。透视投影因此更经常用在点光源和聚光灯上，而正交投影经常用在定向光上。</p>
<p>另一个细微差别是，透视投影矩阵，将深度缓冲视觉化经常会得到一个几乎全白的结果。发生这个是因为透视投影下，深度变成了非线性的深度值，它的大多数可辨范围都位于近平面附近。为了可以像使用正交投影一样合适地观察深度值，你必须先将非线性深度值转变为线性的，如我们在深度测试教程中已经讨论过的那样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 color;</span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D depthMap;</span><br><span class="line">uniform <span class="type">float</span> near_plane;</span><br><span class="line">uniform <span class="type">float</span> far_plane;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">LinearizeDepth</span><span class="params">(<span class="type">float</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> z = depth * <span class="number">2.0</span> - <span class="number">1.0</span>; <span class="comment">// Back to NDC </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2.0</span> * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="type">float</span> depthValue = <span class="built_in">texture</span>(depthMap, TexCoords).r;</span><br><span class="line">    color = <span class="built_in">vec4</span>(<span class="built_in">vec3</span>(<span class="built_in">LinearizeDepth</span>(depthValue) / far_plane), <span class="number">1.0</span>); <span class="comment">// perspective</span></span><br><span class="line">    <span class="comment">// color = vec4(vec3(depthValue), 1.0); // orthographic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个深度值与我们见到的用正交投影的很相似。需要注意的是，这个只适用于调试；正交或投影矩阵的深度检查仍然保持原样，因为相关的深度并没有改变。</p>
<h2 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a>附加资源</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">Tutorial 16 : Shadow mapping</a>：提供类似的阴影贴图教程，里面有一些额外的解释。</li>
<li><a target="_blank" rel="noopener" href="http://ogldev.atspace.co.uk/www/tutorial23/tutorial23.html">Shadow Mapping – Part 1：ogldev</a>：提供的另一个阴影贴图教程。</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=EsccgeUpdsM">How Shadow Mapping Works</a>：一个第三方YouTube视频教程，里面解释了阴影贴图及其实现。</li>
<li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324(v=vs.85).aspx">Common Techniques to Improve Shadow Depth Maps</a>：微软的一篇文章，其中列出了很多提升阴影贴图质量的技术。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/" class="post-title-link" itemprop="url">30-Gammma校正</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-30 17:45:28" itemprop="dateCreated datePublished" datetime="2024-09-30T17:45:28+08:00">2024-09-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-14 20:44:38" itemprop="dateModified" datetime="2024-10-14T20:44:38+08:00">2024-10-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当我们计算出场景中所有像素的最终颜色以后，我们就必须把它们显示在监视器上。过去，大多数监视器是阴极射线管显示器（CRT）。这些监视器的物理特性是两倍的输入电压不能产生两倍的亮度。输入电压产生约为输入电压的2.2次幂的亮度，这叫做监视器Gamma。</p>
<p>Gamma也叫灰度系数，每种显示设备都有自己的Gamma值，都不相同，有一个公式：设备输出亮度 = 电压的Gamma次幂，任何设备Gamma基本上都不会等于1，等于1是一种理想的线性状态，这种理想状态是：如果电压和亮度都是在0到1的区间，那么多少电压就等于多少亮度。对于CRT，Gamma通常为2.2，因而，输出亮度 = 输入电压的2.2次幂，你可以从本节第二张图中看到Gamma2.2实际显示出来的总会比预期暗，相反Gamma0.45就会比理想预期亮，如果将Gamma0.45叠加到Gamma2.2的显示设备上，便会对偏暗的显示效果做到校正，这个简单的思路就是本节的核心，人类所感知的亮度恰好和CRT所显示出来相似的指数关系非常匹配。为了更好的理解所有含义，请看下面的图片：</p>
<img src="/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/gamma_correction_brightness.png" class="" title="img">

<p>第一行是人眼所感知到的正常的灰阶，亮度要增加一倍（比如从0.1到0.2）你才会感觉比原来变亮了一倍。然而，当我们谈论光的物理亮度，如光源发射光子的数量的时候，底部（第二行）的灰阶显示出的才是物理世界真实的亮度。如底部的灰阶显示，亮度加倍时返回的也是真实的物理亮度（这里亮度是指光子数量和正相关的亮度，即物理亮度。物理亮度和感知亮度的区别在于，物理亮度基于光子数量，感知亮度基于人的感觉。），但是由于这与我们的眼睛感知亮度不完全一致（对比较暗的颜色变化更敏感），所以它看起来有差异。</p>
<p>因为人眼看到颜色的亮度更倾向于顶部的灰阶，监视器使用的也是指数关系（电压的2.2次幂），所以物理亮度通过监视器能够被映射到顶部的非线性亮度；因此看起来效果不错（CRT亮度是是电压的2.2次幂而人眼相当于2次幂，因此CRT这个缺陷正好能满足人的需要）。</p>
<p>监视器的这个非线性映射的确可以让亮度在我们眼中看起来更好，但当渲染图像时，会产生一个问题：我们在应用中配置的亮度和颜色是基于监视器所看到的，这样所有的配置实际上是非线性的亮度/颜色配置。请看下图：</p>
<img src="/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/gamma_correction_gamma_curves.png" class="" title="img">

<p>点线代表线性颜色/亮度值（译注：这表示的是理想状态，Gamma为1），实线代表监视器显示的颜色。如果我们把一个点线线性的颜色翻一倍，结果就是这个值的两倍。比如，光的颜色向量L¯=(0.5,0.0,0.0)代表的是暗红色。如果我们在线性空间中把它翻倍，就会变成(1.0,0.0,0.0)，就像你在图中看到的那样。然而，由于我们定义的颜色仍然需要输出的监视器上，监视器上显示的实际颜色就会是(0.218,0.0,0.0)。当我们将理想中直线上的那个暗红色翻一倍时，在监视器上实际上亮度翻了4.5倍以上！</p>
<p>直到现在，我们还一直假设我们所有的工作都是在线性空间中进行的（Gamma为1），但最终还是要把所有的颜色输出到监视器上，所以我们配置的所有颜色和光照变量从物理角度来看都是不正确的，在我们的监视器上很少能够正确地显示。出于这个原因，我们（以及艺术家）通常将光照值设置得比本来更亮一些（由于监视器会将其亮度显示的更暗一些），如果不是这样，在线性空间里计算出来的光照就会不正确。同时，还要记住，监视器所显示出来的图像和线性图像的最小亮度是相同的，它们最大的亮度也是相同的；只是中间亮度部分会被压暗。</p>
<p>因为所有中间亮度都是线性空间计算出来的（计算的时候假设Gamma为1）监视器显以后，实际上都会不正确。当使用更高级的光照算法时，这个问题会变得越来越明显，你可以看看下图：</p>
<img src="/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/gamma_correction_example.png" class="" title="img">

<h2 id="Gamma校正"><a href="#Gamma校正" class="headerlink" title="Gamma校正"></a>Gamma校正</h2><p>Gamma校正(Gamma Correction)的思路是在最终的颜色输出上应用监视器Gamma的倒数。回头看前面的Gamma曲线图，你会有一个短划线，它是监视器Gamma曲线的翻转曲线。我们在颜色显示到监视器的时候把每个颜色输出都加上这个翻转的Gamma曲线，这样应用了监视器Gamma以后最终的颜色将会变为线性的。我们所得到的中间色调就会更亮，所以虽然监视器使它们变暗，但是我们又将其平衡回来了。</p>
<p>我们来看另一个例子。还是那个暗红色(0.5,0.0,0.0)。在将颜色显示到监视器之前，我们先对颜色应用Gamma校正曲线。线性的颜色显示在监视器上相当于降低了2.2幂的亮度，所以倒数就是1/2.2次幂。Gamma校正后的暗红色就会成为(0.5,0.0,0.0)1/2.2=(0.5,0.0,0.0)0.45=(0.73,0.0,0.0)。校正后的颜色接着被发送给监视器，最终显示出来的颜色是(0.73,0.0,0.0)2.2=(0.5,0.0,0.0)。你会发现使用了Gamma校正，监视器最终会显示出我们在应用中设置的那种线性的颜色。</p>
<p>2.2通常是是大多数显示设备的大概平均gamma值。基于gamma2.2的颜色空间叫做sRGB颜色空间。每个监视器的gamma曲线都有所不同，但是gamma2.2在大多数监视器上表现都不错。出于这个原因，游戏经常都会为玩家提供改变游戏gamma设置的选项，以适应每个监视器（现在Gamma2.2相当于一个标准，但现在你可能会问，前面不是说Gamma2.2看起来不是正好适合人眼么，为何还需要校正。这是因为你在程序中设置的颜色，比如光照都是基于线性Gamma，即Gamma1，所以你理想中的亮度和实际表达出的不一样，如果要表达出你理想中的亮度就要对这个光照进行校正）。</p>
<p>有两种方式可以在场景中应用gamma校正：</p>
<p>使用OpenGL内建的sRGB帧缓冲。 自己在像素着色器中进行gamma校正。 第一个选项也许是最简单的方式，但是我们也会丧失一些控制权。开启GL_FRAMEBUFFER_SRGB，可以告诉OpenGL每个后续的绘制命令里，在颜色储存到颜色缓冲之前先校正sRGB颜色。sRGB这个颜色空间大致对应于gamma2.2，它也是家用设备的一个标准。开启GL_FRAMEBUFFER_SRGB以后，每次像素着色器运行后续帧缓冲，OpenGL将自动执行gamma校正，包括默认帧缓冲。开启GL_FRAMEBUFFER_SRGB简单的调用glEnable就行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_FRAMEBUFFER_SRGB);</span><br></pre></td></tr></table></figure>

<p>自此，你渲染的图像就被进行gamma校正处理，你不需要做任何事情，因为硬件已经帮你处理了。gamma校正会把线性颜色空间转变为非线性空间，所以在最后一步进行gamma校正是极其重要的。如果你在最后输出之前就进行gamma校正，所有的后续操作都是在操作不正确的颜色值。例如，如果你使用多个帧缓冲，你可能打算让两个帧缓冲之间传递的中间结果仍然保持线性空间颜色，只是给发送给监视器的最后的那个帧缓冲应用gamma校正。</p>
<p>第二个方法稍微复杂点，但同时我们对gamma操作会有完全的控制权。我们在每个相关像素着色器运行的最后应用gamma校正，所以在发送到帧缓冲前，颜色就被校正了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// do super fancy lighting </span></span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// apply gamma correction</span></span><br><span class="line">    <span class="type">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line">    fragColor.rgb = <span class="built_in">pow</span>(fragColor.rgb, <span class="built_in">vec3</span>(<span class="number">1.0</span>/gamma));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一行代码，将fragColor的每个颜色元素应用有一个1.0/gamma的幂运算，校正像素着色器的颜色输出。</p>
<p>这个方法有个问题就是为了保持一致，你必须在像素着色器里加上这个gamma校正，所以如果你有很多像素着色器，它们可能分别用于不同物体，那么你就必须在每个着色器里都加上gamma校正了。一个更简单的方案是在你的渲染循环中使用后处理，在后处理四边形上应用gamma校正，这样只做一次就好了。</p>
<h3 id="sRGB纹理"><a href="#sRGB纹理" class="headerlink" title="sRGB纹理"></a>sRGB纹理</h3><p>因为监视器总是在sRGB空间中显示应用了gamma的颜色，无论什么时候当你在计算机上绘制、编辑或者画出一个图片的时候，你所选的颜色都是根据你在监视器上看到的那种。这实际意味着所有你创建或编辑的图片并不是在线性空间，而是在sRGB空间中（sRGB空间定义的gamma接近于2.2），假如在你的屏幕上对暗红色翻一倍，便是根据你所感知到的亮度进行的，并不等于将红色元素加倍。</p>
<p>结果就是纹理编辑者，所创建的所有纹理都是在sRGB空间中的纹理，所以如果我们在渲染应用中使用这些纹理，我们必须考虑到这点。在应用gamma校正之前，这不是个问题，因为纹理在sRGB空间创建和展示，同样我们还是在sRGB空间中使用，从而不必gamma校正纹理显示也没问题。然而，现在我们是把所有东西都放在线性空间中展示的，纹理颜色就会变坏，如下图展示的那样</p>
<img src="/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/image-20241014190156915.png" class="" title="image-20241014190156915">

<p>纹理图像实在太亮了，这种情况产生的原因是，它们实际上进行了两次gamma校正。当我们基于监视器上看到的情况创建一个图像，我们就已经对颜色值进行了gamma校正，但是在渲染中又进行了一次gamma校正。</p>
<p>为了修复这个问题，我们得确保纹理制作者是在线性空间中进行创作的。但是，由于大多数纹理制作者并不知道什么是gamma校正，并且在sRGB空间中进行创作更简单，这也许不是一个好办法。</p>
<p>另一个解决方案是重校，或把这些sRGB纹理在进行任何颜色值的计算前变回线性空间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line">vec3 diffuseColor = <span class="built_in">pow</span>(<span class="built_in">texture</span>(diffuse, texCoords).rgb, <span class="built_in">vec3</span>(gamma));</span><br></pre></td></tr></table></figure>

<p>为每个sRGB空间的纹理做这件事非常烦人。幸好，OpenGL给我们提供了另一个方案来解决我们的麻烦，这就是GL_SRGB和GL_SRGB_ALPHA内部纹理格式。</p>
<p>如果我们在OpenGL中创建了一个纹理，把它指定为以上两种sRGB纹理格式其中之一，OpenGL将自动把颜色校正到线性空间中，这样我们所使用的所有颜色值都是在线性空间中的了。我们可以这样把一个纹理指定为一个sRGB纹理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_SRGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, image);</span><br></pre></td></tr></table></figure>

<p>如果你还打算在你的纹理中引入alpha元素，必须将纹理的内部格式指定为GL_SRGB_ALPHA。</p>
<p>因为不是所有纹理都是在sRGB空间中的所以当你把纹理指定为sRGB纹理时要格外小心。比如diffuse纹理，这种为物体上色的纹理几乎都是在sRGB空间中的。而为了获取光照参数的纹理，像specular贴图和法线贴图几乎都在线性空间中，所以如果你把它们也配置为sRGB纹理的话，光照就坏掉了。指定sRGB纹理时要当心。</p>
<p>将diffuse纹理定义为sRGB纹理之后，你将获得你所期望的视觉输出，但这次每个物体都会只进行一次gamma校正。</p>
<h3 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h3><p>在使用了gamma校正之后，另一个不同之处是光照衰减(Attenuation)。真实的物理世界中，光照的衰减和光源的距离的平方成反比。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> attenuation = <span class="number">1.0</span> / (distance * distance);</span><br></pre></td></tr></table></figure>

<p>然而，当我们使用这个衰减公式的时候，衰减效果总是过于强烈，光只能照亮一小圈，看起来并不真实。出于这个原因，我们使用在基本光照教程中所讨论的那种衰减方程，它给了我们更大的控制权，此外我们还可以使用双曲线函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> attenuation = <span class="number">1.0</span> / distance;</span><br></pre></td></tr></table></figure>

<p>双曲线比使用二次函数变体在不用gamma校正的时候看起来更真实，不过但我们开启gamma校正以后线性衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果。下图显示了其中的不同：</p>
<img src="/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/gamma_correction_attenuation.png" class="" title="img">

<p>这种差异产生的原因是，光的衰减方程改变了亮度值，而且屏幕上显示出来的也不是线性空间，在监视器上效果最好的衰减方程，并不是符合物理的。想想平方衰减方程，如果我们使用这个方程，而且不进行gamma校正，显示在监视器上的衰减方程实际上将变成(1.0/distance2)2.2。若不进行gamma校正，将产生更强烈的衰减。这也解释了为什么双曲线不用gamma校正时看起来更真实，因为它实际变成了(1.0/distance)2.2=1.0/distance2.2。这和物理公式是很相似的。</p>
<p>我们在基础光照教程中讨论的更高级的那个衰减方程在有gamma校正的场景中也仍然有用，因为它可以让我们对衰减拥有更多准确的控制权（不过，在进行gamma校正的场景中当然需要不同的参数）。</p>
<p>这有一个简单的demo场景，你可以在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/09/30/30-Gammma%E6%A0%A1%E6%AD%A3/gamma_correction.rar">这里</a>找到源代码。按下空格就能在有gamma校正和无gamma校正的场景进行切换，两个场景使用的是相同的纹理和衰减。</p>
<p>总而言之，gamma校正使你可以在线性空间中进行操作。因为线性空间更符合物理世界，大多数物理公式现在都可以获得较好效果，比如真实的光的衰减。你的光照越真实，使用gamma校正获得漂亮的效果就越容易。这也正是为什么当引进gamma校正时，建议只去调整光照参数的原因。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/" class="post-title-link" itemprop="url">29-高级光照</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-29 20:46:52" itemprop="dateCreated datePublished" datetime="2024-09-29T20:46:52+08:00">2024-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-30 17:49:13" itemprop="dateModified" datetime="2024-09-30T17:49:13+08:00">2024-09-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Blinn-Phong"><a href="#Blinn-Phong" class="headerlink" title="Blinn-Phong"></a>Blinn-Phong</h2><p>冯氏光照不仅对真实光照有很好的近似，而且性能也很高。但是它的镜面反射会在一些情况下出现问题，特别是物体反光度很低时，会导致大片（粗糙的）高光区域。下面这张图展示了当反光度为1.0时地板会出现的效果：</p>
<img src="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/advanced_lighting_phong_limit.png" class="" title="img">

<p>可以看到，在镜面高光区域的边缘出现了一道很明显的断层。出现这个问题的原因是观察向量和反射向量间的夹角不能大于90度。如果点积的结果为负数，镜面光分量会变为0.0。你可能会觉得，当光线与视线夹角大于90度时你应该不会接收到任何光才对，所以这不是什么问题。</p>
<p>然而，这种想法仅仅只适用于漫反射分量。当考虑漫反射光的时候，如果法线和光源夹角大于90度，光源会处于被照表面的下方，这个时候光照的漫反射分量的确是为0.0。但是，在考虑镜面高光时，我们测量的角度并不是光源与法线的夹角，而是视线与反射光线向量的夹角。看一下下面这两张图：</p>
<img src="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/advanced_lighting_over_90.png" class="" title="img">

<p>现在问题就应该很明显了。左图中是我们熟悉的冯氏光照中的反射向量，其中θ角小于90度。而右图中，视线与反射方向之间的夹角明显大于90度，这种情况下镜面光分量会变为0.0。这在大多数情况下都不是什么问题，因为观察方向离反射方向都非常远。然而，当物体的反光度非常小时，它产生的镜面高光半径足以让这些相反方向的光线对亮度产生足够大的影响。在这种情况下就不能忽略它们对镜面光分量的贡献了。</p>
<p>1977年，James F. Blinn在冯氏着色模型上加以拓展，引入了Blinn-Phong着色模型。Blinn-Phong模型与冯氏模型非常相似，但是它对镜面光模型的处理上有一些不同，让我们能够解决之前提到的问题。Blinn-Phong模型不再依赖于反射向量，而是采用了所谓的半程向量(Halfway Vector)，即光线与视线夹角一半方向上的一个单位向量。当半程向量与法线向量越接近时，镜面光分量就越大。</p>
<img src="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/advanced_lighting_halfway_vector.png" class="" title="img">

<p>当视线正好与（现在不需要的）反射向量对齐时，半程向量就会与法线完美契合。所以当观察者视线越接近于原本反射光线的方向时，镜面高光就会越强。现在，不论观察者向哪个方向看，半程向量与表面法线之间的夹角都不会超过90度（除非光源在表面以下）。它产生的效果会与冯氏光照有些许不同，但是大部分情况下看起来会更自然一点，特别是低高光的区域。Blinn-Phong着色模型正是早期固定渲染管线时代时OpenGL所采用的光照模型。</p>
<p>获取半程向量的方法很简单，只需要将光线的方向向量和观察向量加到一起，并将结果正规化(Normalize)就可以了：</p>
<img src="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/image-20240929205225538.png" class="" title="image-20240929205225538">

<p>翻译成GLSL代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec3 lightDir   = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line">vec3 viewDir    = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br></pre></td></tr></table></figure>

<p>接下来，镜面光分量的实际计算只不过是对表面法线和半程向量进行一次约束点乘(Clamped Dot Product)，让点乘结果不为负，从而获取它们之间夹角的余弦值，之后我们对这个值取反光度次方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), shininess);</span><br><span class="line">vec3 specular = lightColor * spec;</span><br></pre></td></tr></table></figure>

<p>除此之外Blinn-Phong模型就没什么好说的了，Blinn-Phong与冯氏模型唯一的区别就是，Blinn-Phong测量的是法线与半程向量之间的夹角，而冯氏模型测量的是观察方向与反射向量间的夹角。</p>
<p>在引入半程向量之后，我们现在应该就不会再看到冯氏光照中高光断层的情况了。下面两个图片展示的是两种方法在镜面光分量为0.5时的对比：</p>
<img src="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/advanced_lighting_comparrison.png" class="" title="img">

<p>除此之外，冯氏模型与Blinn-Phong模型也有一些细微的差别：半程向量与表面法线的夹角通常会小于观察与反射向量的夹角。所以，如果你想获得和冯氏着色类似的效果，就必须在使用Blinn-Phong模型时将镜面反光度设置更高一点。通常我们会选择冯氏着色时反光度分量的2到4倍。</p>
<p>下面是冯氏着色与Blinn-Phong着色的一个对比（左边为phong，右边为blinn-phong）：</p>
<img src="/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/image-20240930174245958.png" class="" title="image-20240930174245958">

<p>你可以看到，Blinn-Phong的镜面光分量会比冯氏模型更锐利一些。为了得到与冯氏模型类似的结果，你可能会需要不断进行一些微调，但Blinn-Phong模型通常会产出更真实的结果。</p>
<p>这里，我们使用了一个简单的片段着色器，让我们能够在冯氏反射与Blinn-Phong反射间进行切换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(blinn)</span><br><span class="line">    &#123;</span><br><span class="line">        vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">        spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">16.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">        spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">8.0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/09/29/29-%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/advanced_lighting.rar">这里</a>获取完整的代码，可以按下<code>B</code>键来切换冯氏光照与Blinn-Phong光照。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OSkirito"
      src="/images/head_image.png">
  <p class="site-author-name" itemprop="name">OSkirito</p>
  <div class="site-description" itemprop="description">CG技术的记录与分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oskirito" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oskirito" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OSkirito</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
