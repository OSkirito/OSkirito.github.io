<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CG技术的记录与分享">
<meta property="og:type" content="website">
<meta property="og:title" content="OS&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="OS&#39;s Blog">
<meta property="og:description" content="CG技术的记录与分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="OSkirito">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>OS's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OS's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">29</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">56</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/" class="post-title-link" itemprop="url">34-视差贴图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-02-09 17:22:27 / 修改时间：17:42:34" itemprop="dateCreated datePublished" datetime="2026-02-09T17:22:27+08:00">2026-02-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>视差贴图(Parallax Mapping)技术和法线贴图差不多，但它有着不同的原则。和法线贴图一样视差贴图能够极大提升表面细节，使之具有深度感。它也是利用了视错觉，然而对深度有着更好的表达，与法线贴图一起用能够产生难以置信的效果。视差贴图和光照无关，我在这里是作为法线贴图的技术延续来讨论它的。需要注意的是在开始学习视差贴图之前强烈建议先对法线贴图，特别是切线空间有较好的理解。</p>
<p>视差贴图属于位移贴图(Displacement Mapping)技术的一种，它对根据储存在纹理中的几何信息对顶点进行位移或偏移。一种实现的方式是比如有1000个顶点，根据纹理中的数据对平面特定区域的顶点的高度进行位移。这样的每个纹理像素包含了高度值纹理叫做高度贴图。一张简单的砖块表面的高度贴图如下所示：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_height_map.png" class="" title="img">

<p>整个平面上的每个顶点都根据从高度贴图采样出来的高度值进行位移，根据材质的几何属性平坦的平面变换成凹凸不平的表面。例如一个平坦的平面利用上面的高度贴图进行置换能得到以下结果：</p>
<p>置换顶点有一个问题就是平面必须由很多顶点组成才能获得具有真实感的效果，否则看起来效果并不会很好。一个平坦的表面上有1000个顶点计算量太大了。我们能否不用这么多的顶点就能取得相似的效果呢？事实上，上面的表面就是用6个顶点渲染出来的（两个三角形）。上面的那个表面使用视差贴图技术渲染，位移贴图技术不需要额外的顶点数据来表达深度，它像法线贴图一样采用一种聪明的手段欺骗用户的眼睛。</p>
<p>视差贴图背后的思想是修改纹理坐标使一个fragment的表面看起来比实际的更高或者更低，所有这些都根据观察方向和高度贴图。为了理解它如何工作，看看下面砖块表面的图片：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_plane_height.png" class="" title="img">

<p>这里粗糙的红线代表高度贴图中的数值的立体表达，向量V¯代表观察方向。如果平面进行实际位移，观察者会在点B看到表面。然而我们的平面没有实际上进行位移，观察方向将在点A与平面接触。视差贴图的目的是，在A位置上的fragment不再使用点A的纹理坐标而是使用点B的。随后我们用点B的纹理坐标采样，观察者就像看到了点B一样。</p>
<p>这个技巧就是描述如何从点A得到点B的纹理坐标。视差贴图尝试通过对从fragment到观察者的方向向量V¯进行缩放的方式解决这个问题，缩放的大小是A处fragment的高度。所以我们将V¯的长度缩放为高度贴图在点A处H(A)采样得来的值。下图展示了经缩放得到的向量P¯：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_scaled_height.png" class="" title="img">

<p>我们随后选出P¯以及这个向量与平面对齐的坐标作为纹理坐标的偏移量。这能工作是因为向量P¯是使用从高度贴图得到的高度值计算出来的，所以一个fragment的高度越高位移的量越大。</p>
<p>这个技巧在大多数时候都没问题，但点B是粗略估算得到的。当表面的高度变化很快的时候，看起来就不会真实，因为向量P¯最终不会和B接近，就像下图这样：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_incorrect_p.png" class="" title="img">

<p>视差贴图的另一个问题是，当表面被任意旋转以后很难指出从P¯获取哪一个坐标。我们在视差贴图中使用了另一个坐标空间，这个空间P¯向量的x和y元素总是与纹理表面对齐。如果你看了法线贴图教程，你也许猜到了，我们实现它的方法，是的，我们还是在切线空间中实现视差贴图。</p>
<p>将fragment到观察者的向量V¯转换到切线空间中，经变换的P¯向量的x和y元素将于表面的切线和副切线向量对齐。由于切线和副切线向量与表面纹理坐标的方向相同，我们可以用P¯的x和y元素作为纹理坐标的偏移量，这样就不用考虑表面的方向了。</p>
<p>理论都有了，下面我们来动手实现视差贴图。</p>
<h2 id="视差贴图"><a href="#视差贴图" class="headerlink" title="视差贴图"></a>视差贴图</h2><p>我们将使用一个简单的2D平面，在把它发送给GPU之前我们先计算它的切线和副切线向量；和法线贴图教程做的差不多。我们将向平面贴diffuse纹理、法线贴图以及一个位移贴图，你可以点击链接下载。这个例子中我们将视差贴图和法线贴图连用。因为视差贴图生成表面位移了的幻觉，当光照不匹配时这种幻觉就被破坏了。法线贴图通常根据高度贴图生成，法线贴图和高度贴图一起用能保证光照能和位移相匹配。</p>
<p>你可能已经注意到，上面链接上的那个位移贴图和教程一开始的那个高度贴图相比是颜色是相反的。这是因为使用反色高度贴图（也叫深度贴图）去模拟深度比模拟高度更容易。下图反映了这个轻微的改变：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_depth.png" class="" title="img">

<p>我们再次获得A和B，但是这次我们用向量V¯减去点A的纹理坐标得到P¯。我们通过在着色器中用1.0减去采样得到的高度贴图中的值来取得深度值，而不再是高度值，或者简单地在图片编辑软件中把这个纹理进行反色操作，就像我们对连接中的那个深度贴图所做的一样。</p>
<p>位移贴图是在像素着色器中实现的，因为三角形表面的所有位移效果都不同。在像素着色器中我们将需要计算fragment到观察者到方向向量V¯所以我们需要观察者位置和在切线空间中的fragment位置。法线贴图教程中我们已经有了一个顶点着色器，它把这些向量发送到切线空间，所以我们可以复制那个顶点着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 texCoords;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">3</span>) in vec3 tangent;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">4</span>) in vec3 bitangent;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec3 TangentLightPos;</span><br><span class="line">    vec3 TangentViewPos;</span><br><span class="line">    vec3 TangentFragPos;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position      = projection * view * model * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">    vs_out.FragPos   = <span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>));   </span><br><span class="line">    vs_out.TexCoords = texCoords;    </span><br><span class="line"></span><br><span class="line">    vec3 T   = <span class="built_in">normalize</span>(<span class="built_in">mat3</span>(model) * tangent);</span><br><span class="line">    vec3 B   = <span class="built_in">normalize</span>(<span class="built_in">mat3</span>(model) * bitangent);</span><br><span class="line">    vec3 N   = <span class="built_in">normalize</span>(<span class="built_in">mat3</span>(model) * normal);</span><br><span class="line">    mat3 TBN = <span class="built_in">transpose</span>(<span class="built_in">mat3</span>(T, B, N));</span><br><span class="line"></span><br><span class="line">    vs_out.TangentLightPos = TBN * lightPos;</span><br><span class="line">    vs_out.TangentViewPos  = TBN * viewPos;</span><br><span class="line">    vs_out.TangentFragPos  = TBN * vs_out.FragPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里有件事很重要，我们需要把position和在切线空间中的观察者的位置viewPos发送给像素着色器。</p>
<p>在像素着色器中，我们实现视差贴图的逻辑。像素着色器看起来会是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec3 TangentLightPos;</span><br><span class="line">    vec3 TangentViewPos;</span><br><span class="line">    vec3 TangentFragPos;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseMap;</span><br><span class="line">uniform sampler2D normalMap;</span><br><span class="line">uniform sampler2D depthMap;</span><br><span class="line"></span><br><span class="line">uniform <span class="type">float</span> height_scale;</span><br><span class="line"></span><br><span class="line"><span class="function">vec2 <span class="title">ParallaxMapping</span><span class="params">(vec2 texCoords, vec3 viewDir)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    <span class="comment">// Offset texture coordinates with Parallax Mapping</span></span><br><span class="line">    vec3 viewDir   = <span class="built_in">normalize</span>(fs_in.TangentViewPos - fs_in.TangentFragPos);</span><br><span class="line">    vec2 texCoords = <span class="built_in">ParallaxMapping</span>(fs_in.TexCoords,  viewDir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then sample textures with new texture coords</span></span><br><span class="line">    vec3 diffuse = <span class="built_in">texture</span>(diffuseMap, texCoords);</span><br><span class="line">    vec3 normal  = <span class="built_in">texture</span>(normalMap, texCoords);</span><br><span class="line">    normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// proceed with lighting code</span></span><br><span class="line">    [...]    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个叫做ParallaxMapping的函数，它把fragment的纹理坐标和切线空间中的fragment到观察者的方向向量为输入。这个函数返回经位移的纹理坐标。然后我们使用这些经位移的纹理坐标进行diffuse和法线贴图的采样。最后fragment的diffuse颜色和法线向量就正确的对应于表面的经位移的位置上了。</p>
<p>我们来看看ParallaxMapping函数的内部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec2 <span class="title">ParallaxMapping</span><span class="params">(vec2 texCoords, vec3 viewDir)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">float</span> height =  <span class="built_in">texture</span>(depthMap, texCoords).r;    </span><br><span class="line">    vec2 p = viewDir.xy / viewDir.z * (height * height_scale);</span><br><span class="line">    <span class="keyword">return</span> texCoords - p;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个相对简单的函数是我们所讨论过的内容的直接表述。我们用本来的纹理坐标texCoords从高度贴图中来采样，得到当前fragment的高度H(A)。然后计算出P¯，x和y元素在切线空间中，viewDir向量除以它的z元素，用fragment的高度对它进行缩放。我们同时引入额一个height_scale的uniform，来进行一些额外的控制，因为视差效果如果没有一个缩放参数通常会过于强烈。然后我们用P¯减去纹理坐标来获得最终的经过位移纹理坐标。</p>
<p>有一个地方需要注意，就是viewDir.xy除以viewDir.z那里。因为viewDir向量是经过了标准化的，viewDir.z会在0.0到1.0之间的某处。当viewDir大致平行于表面时，它的z元素接近于0.0，除法会返回比viewDir垂直于表面的时候更大的P¯向量。所以，从本质上，相比正朝向表面，当带有角度地看向平面时，我们会更大程度地缩放P¯的大小，从而增加纹理坐标的偏移；这样做在视角上会获得更大的真实度。</p>
<p>有些人更喜欢不在等式中使用viewDir.z，因为普通的视差贴图会在角度上产生不尽如人意的结果；这个技术叫做有偏移量限制的视差贴图（Parallax Mapping with Offset Limiting）。选择哪一个技术是个人偏好问题，但我倾向于普通的视差贴图。</p>
<p>最后的纹理坐标随后被用来进行采样（diffuse和法线）贴图，下图所展示的位移效果中height_scale等于0.1：</p>
<p>这里你会看到只用法线贴图和与视差贴图相结合的法线贴图的不同之处。因为视差贴图尝试模拟深度，它实际上能够根据你观察它们的方向使砖块叠加到其他砖块上。</p>
<p>在视差贴图的那个平面里你仍然能看到在边上有古怪的失真。原因是在平面的边缘上，纹理坐标超出了0到1的范围进行采样，根据纹理的环绕方式导致了不真实的结果。解决的方法是当它超出默认纹理坐标范围进行采样的时候就丢弃这个fragment：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">texCoords = <span class="built_in">ParallaxMapping</span>(fs_in.TexCoords,  viewDir);</span><br><span class="line"><span class="keyword">if</span>(texCoords.x &gt; <span class="number">1.0</span> || texCoords.y &gt; <span class="number">1.0</span> || texCoords.x &lt; <span class="number">0.0</span> || texCoords.y &lt; <span class="number">0.0</span>)</span><br><span class="line">    discard;</span><br></pre></td></tr></table></figure>

<p>丢弃了超出默认范围的纹理坐标的所有fragment，视差贴图的表面边缘给出了正确的结果。注意，这个技巧不能在所有类型的表面上都能工作，但是应用于平面上它还是能够是平面看起来真的进行位移了：</p>
<p>你可以在这里找到源代码。</p>
<p>看起来不错，运行起来也很快，因为我们只要给视差贴图提供一个额外的纹理样本就能工作。当从一个角度看过去的时候，会有一些问题产生（和法线贴图相似），陡峭的地方会产生不正确的结果，从下图你可以看到：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_issues.png" class="" title="img">

<p>问题的原因是这只是一个大致近似的视差映射。还有一些技巧让我们在陡峭的高度上能够获得几乎完美的结果，即使当以一定角度观看的时候。例如，我们不再使用单一样本，取而代之使用多样本来找到最近点B会得到怎样的结果？</p>
<h2 id="陡峭视差映射"><a href="#陡峭视差映射" class="headerlink" title="陡峭视差映射"></a>陡峭视差映射</h2><p>陡峭视差映射(Steep Parallax Mapping)是视差映射的扩展，原则是一样的，但不是使用一个样本而是多个样本来确定向量P¯到B。即使在陡峭的高度变化的情况下，它也能得到更好的结果，原因在于该技术通过增加采样的数量提高了精确性。</p>
<p>陡峭视差映射的基本思想是将总深度范围划分为同一个深度/高度的多个层。从每个层中我们沿着P¯方向移动采样纹理坐标，直到我们找到一个采样低于当前层的深度值。看看下面的图片：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_steep_parallax_mapping_diagram.png" class="" title="img">

<p>我们从上到下遍历深度层，我们把每个深度层和储存在深度贴图中的它的深度值进行对比。如果这个层的深度值小于深度贴图的值，就意味着这一层的P¯向量部分在表面之下。我们继续这个处理过程直到有一层的深度高于储存在深度贴图中的值：这个点就在（经过位移的）表面下方。</p>
<p>这个例子中我们可以看到第二层(D(2) = 0.73)的深度贴图的值仍低于第二层的深度值0.4，所以我们继续。下一次迭代，这一层的深度值0.6大于深度贴图中采样的深度值(D(3) = 0.37)。我们便可以假设第三层向量P¯是可用的位移几何位置。我们可以用从向量P3¯的纹理坐标偏移T3来对fragment的纹理坐标进行位移。你可以看到随着深度曾的增加精确度也在提高。</p>
<p>为实现这个技术，我们只需要改变ParallaxMapping函数，因为所有需要的变量都有了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec2 <span class="title">ParallaxMapping</span><span class="params">(vec2 texCoords, vec3 viewDir)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// number of depth layers</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> numLayers = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// calculate the size of each layer</span></span><br><span class="line">    <span class="type">float</span> layerDepth = <span class="number">1.0</span> / numLayers;</span><br><span class="line">    <span class="comment">// depth of current layer</span></span><br><span class="line">    <span class="type">float</span> currentLayerDepth = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// the amount to shift the texture coordinates per layer (from vector P)</span></span><br><span class="line">    vec2 P = viewDir.xy * height_scale; </span><br><span class="line">    vec2 deltaTexCoords = P / numLayers;</span><br><span class="line"></span><br><span class="line">    [...]     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先定义层的数量，计算每一层的深度，最后计算纹理坐标偏移，每一层我们必须沿着P¯的方向进行移动。</p>
<p>然后我们遍历所有层，从上开始，知道找到小于这一层的深度值的深度贴图值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get initial values</span></span><br><span class="line">vec2  currentTexCoords     = texCoords;</span><br><span class="line"><span class="type">float</span> currentDepthMapValue = <span class="built_in">texture</span>(depthMap, currentTexCoords).r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(currentLayerDepth &lt; currentDepthMapValue)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// shift texture coordinates along direction of P</span></span><br><span class="line">    currentTexCoords -= deltaTexCoords;</span><br><span class="line">    <span class="comment">// get depthmap value at current texture coordinates</span></span><br><span class="line">    currentDepthMapValue = <span class="built_in">texture</span>(depthMap, currentTexCoords).r;  </span><br><span class="line">    <span class="comment">// get depth of next layer</span></span><br><span class="line">    currentLayerDepth += layerDepth;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> currentTexCoords;</span><br></pre></td></tr></table></figure>

<p>这里我们循环每一层深度，直到沿着P¯向量找到第一个返回低于（位移）表面的深度的纹理坐标偏移量。从fragment的纹理坐标减去最后的偏移量，来得到最终的经过位移的纹理坐标向量，这次就比传统的视差映射更精确了。</p>
<p>有10个样本砖墙从一个角度看上去就已经很好了，但是当有一个强前面展示的木制表面一样陡峭的表面时，陡峭的视差映射的威力就显示出来了：</p>
<p>我们可以通过对视差贴图的一个属性的利用，对算法进行一点提升。当垂直看一个表面的时候纹理时位移比以一定角度看时的小。我们可以在垂直看时使用更少的样本，以一定角度看时增加样本数量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> minLayers = <span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> maxLayers = <span class="number">32</span>;</span><br><span class="line"><span class="type">float</span> numLayers = <span class="built_in">mix</span>(maxLayers, minLayers, <span class="built_in">abs</span>(<span class="built_in">dot</span>(<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>), viewDir)));</span><br></pre></td></tr></table></figure>

<p>这里我们得到viewDir和正z方向的点乘，使用它的结果根据我们看向表面的角度调整样本数量（注意正z方向等于切线空间中的表面的法线）。如果我们所看的方向平行于表面，我们就是用32层。</p>
<p>你可以在这里找到最新的像素着色器代码。这里也提供木制玩具箱的表面贴图：diffuse、法线、深度。</p>
<p>陡峭视差贴图同样有自己的问题。因为这个技术是基于有限的样本数量的，我们会遇到锯齿效果以及图层之间有明显的断层：</p>
<p>我们可以通过增加样本的方式减少这个问题，但是很快就会花费很多性能。有些旨在修复这个问题的方法：不适用低于表面的第一个位置，而是在两个接近的深度层进行插值找出更匹配B的。</p>
<p>两种最流行的解决方法叫做Relief Parallax Mapping和Parallax Occlusion Mapping，Relief Parallax Mapping更精确一些，但是比Parallax Occlusion Mapping性能开销更多。因为Parallax Occlusion Mapping的效果和前者差不多但是效率更高，因此这种方式更经常使用，所以我们将在下面讨论一下。</p>
<h2 id="视差遮蔽映射"><a href="#视差遮蔽映射" class="headerlink" title="视差遮蔽映射"></a>视差遮蔽映射</h2><p>视差遮蔽映射(Parallax Occlusion Mapping)和陡峭视差映射的原则相同，但不是用触碰的第一个深度层的纹理坐标，而是在触碰之前和之后，在深度层之间进行线性插值。我们根据表面的高度距离啷个深度层的深度层值的距离来确定线性插值的大小。看看下面的图片就能了解它是如何工作的：</p>
<img src="/2026/02/09/34-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/parallax_mapping_parallax_occlusion_mapping_diagram.png" class="" title="img">

<p>你可以看到大部分和陡峭视差映射一样，不一样的地方是有个额外的步骤，两个深度层的纹理坐标围绕着交叉点的线性插值。这也是近似的，但是比陡峭视差映射更精确。</p>
<p>视差遮蔽映射的代码基于陡峭视差映射，所以并不难：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[...] <span class="comment">// steep parallax mapping code here</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get texture coordinates before collision (reverse operations)</span></span><br><span class="line">vec2 prevTexCoords = currentTexCoords + deltaTexCoords;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get depth after and before collision for linear interpolation</span></span><br><span class="line"><span class="type">float</span> afterDepth  = currentDepthMapValue - currentLayerDepth;</span><br><span class="line"><span class="type">float</span> beforeDepth = <span class="built_in">texture</span>(depthMap, prevTexCoords).r - currentLayerDepth + layerDepth;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interpolation of texture coordinates</span></span><br><span class="line"><span class="type">float</span> weight = afterDepth / (afterDepth - beforeDepth);</span><br><span class="line">vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (<span class="number">1.0</span> - weight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> finalTexCoords;</span><br></pre></td></tr></table></figure>

<p>在对（位移的）表面几何进行交叉，找到深度层之后，我们获取交叉前的纹理坐标。然后我们计算来自相应深度层的几何之间的深度之间的距离，并在两个值之间进行插值。线性插值的方式是在两个层的纹理坐标之间进行的基础插值。函数最后返回最终的经过插值的纹理坐标。</p>
<p>视差遮蔽映射的效果非常好，尽管有一些可以看到的轻微的不真实和锯齿的问题，这仍是一个好交易，因为除非是放得非常大或者观察角度特别陡，否则也看不到。</p>
<p>你可以在这里找到源代码。</p>
<p>视差贴图是提升场景细节非常好的技术，但是使用的时候还是要考虑到它会带来一点不自然。大多数时候视差贴图用在地面和墙壁表面，这种情况下查明表面的轮廓并不容易，同时观察角度往往趋向于垂直于表面。这样视差贴图的不自然也就很难能被注意到了，对于提升物体的细节可以起到难以置信的效果。</p>
<h2 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a>附加资源</h2><ul>
<li><a target="_blank" rel="noopener" href="http://sunandblackcat.com/tipFullView.php?topicid=28">Parallax Occlusion Mapping in GLSL</a>：<a target="_blank" rel="noopener" href="http://sunandblackcat.com/">sunandblackcat.com</a>上的视差贴图教程。</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=xvOT62L-fQI">How Parallax Displacement Mapping Works</a>：TheBennyBox的关于视差贴图原理的视频教程。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/" class="post-title-link" itemprop="url">33-法线贴图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-01-26 15:32:53" itemprop="dateCreated datePublished" datetime="2026-01-26T15:32:53+08:00">2026-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-02-09 18:17:31" itemprop="dateModified" datetime="2026-02-09T18:17:31+08:00">2026-02-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目前的场景中已经充满了各种物体，其中每个都可能由成百上千平整的三角形组成。我们以向三角形上附加纹理的方式来增加额外细节，提升真实感，隐藏这些物体是由无数三角形组成的事实。纹理确有助益，但是当你靠近仔细观察它们时，就会发现问题。现实中的物体表面并非是平整的，而是表现出无数起伏的（凹凸不平的）细节。</p>
<p>例如，木砖的表面，木砖的表面会有一些粗糙，显然不是完全平整的：它包含着接缝处的凹痕，以及非常多的细小的木纹。如果我们在一个有光照的场景中看这样一个木地板的表面，问题就出来了。就像下图所示现在的场景：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127105324895.png" class="" title="image-20260127105324895">

<p>光照并没有呈现出任何接缝和细节，完全忽略了砖块之间凹进去的线条；表面看起来完全就是平的。我们可以使用specular贴图根据深度或其他细节阻止部分表面被照的更亮，以此部分地解决问题，但这并不是一个好方案。我们需要的是某种可以告知光照系统给所有有关物体表面类似深度这样的细节的方式。</p>
<p>如果我们以光的视角来看这个问题：为什么表面被照亮为完全平整？答案是表面的法线向量。以光照算法的视角考虑的话，只有垂直于它的法线向量可以决定物体的形状。砖块表面只有一个法线向量，表面完全根据这个法线向量被以一致的方式照亮。如果每个fragment都是用自己的不同的法线，我们就可以根据表面细微的细节对法线向量进行改变；这样就会获得一种表面看起来要复杂得多的错觉：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_surfaces.png" class="" title="img">

<p>每个fragment使用了自己的法线，我们就可以让光照将表面照亮为很多微笑（垂直于法线向量的）平面，物体表面的细节将会得到极大提升。这种每个fragment使用各自的法线，替代一个面上所有fragment使用同一个法线的技术叫做法线贴图（normal mapping）或凹凸贴图（bump mapping）。通过这种方式使细节获得了极大提升，开销却不大。因为只需要改变每个fragment的法线向量，并不需要改变所有光照公式。现在我们是为每个fragment传递一个法线，不再使用插值表面法线。这样光照就使表面拥有了自己的细节。</p>
<h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><p>为使法线贴图能够正常工作，我们需要为每个fragment提供一个法线。像diffuse贴图和specular贴图一样，我们可以使用一个2D纹理来储存法线数据。2D纹理不仅可以储存颜色和光照数据，还可以储存法向量。这样我们可以从2D纹理中采样得到特定纹理的法线向量。</p>
<p>由于法向量是个几何工具，而纹理通常只用于储存颜色信息，用纹理储存法向量并不直观。类似于纹理中的颜色向量用r、g、b元素代表一个3D向量，我们也可以将法线向量的x、y、z元素储存到纹理中，用来代替颜色的r、g、b元素。法向量的范围在-1到1之间，所以我们先要将其范围进行映射：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从法线贴图范围[0,1]获取法线</span></span><br><span class="line">normal = <span class="built_in">texture</span>(normalTexture, fs_in.TexCoords).rgb;</span><br><span class="line"><span class="comment">// 将法线向量转换为范围[-1,1]</span></span><br><span class="line">normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>将法向量变换为像这样的RGB颜色，我们就能把根据表面的形状的fragment的法线保存在2D纹理中。下图是一个法线贴图：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/wool_fabric_normal.jpg" class="" title="wool_fabric_normal">

<p>法线贴图看起来会是一种偏蓝色调的纹理（在网上找到的所有法线贴图几乎都是这样的）。这是因为所有法线的指向都偏向z轴（0, 0, 1）这是一种偏蓝的颜色。法线向量从z轴方向也向其他方向轻微偏移，颜色也就发生了轻微变化，这样看起来便有了一种深度。例如，你可以看到在每个凸起的顶部，颜色倾向于偏绿，这是因为此处的顶部的法线偏向于指向正y轴方向（0, 1, 0），这样它就是绿色的了。</p>
<p>在一个简单的朝向正z轴的平面上，我们可以用<a target="_blank" rel="noopener" href="https://learnopengl.com/img/textures/brickwall.jpg">这个diffuse纹理</a>和<a target="_blank" rel="noopener" href="https://learnopengl.com/img/textures/brickwall_normal.jpg">这个法线贴图</a>来渲染前面部分的图片。要注意的是这个链接里的法线贴图和上面展示的那个不一样。原因是OpenGL读取的纹理的y（或V）坐标和纹理通常被创建的方式相反。链接里的法线贴图的y（或绿色）元素是相反的（你可以看到绿色现在在下边）；如果你没考虑这个，光照就不正确了（如果你现在不再使用SOIL了，那就不要用链接里的那个法线贴图，这个问题是SOIL载入纹理上下颠倒所致，它也会把法线在y方向上颠倒）。加载纹理，把它们绑定到合适的纹理单元，然后使用下面的改变了的片段着色器来渲染一个平面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D normalMap;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    <span class="comment">// 从法线贴图范围[0,1]获取法线</span></span><br><span class="line">    normal = <span class="built_in">texture</span>(normalMap, fs_in.TexCoords).rgb;</span><br><span class="line">    <span class="comment">// 将法线向量转换为范围[-1,1]</span></span><br><span class="line">    normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);   </span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// 像往常那样处理光照</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们将被采样的法线颜色从0到1重新映射回-1到1，便能将RGB颜色重新处理成法线，然后使用采样出的法向量应用于光照的计算。</p>
<p>然而有个问题限制了刚才讲的那种法线贴图的使用。我们使用的法线贴图中所有法线向量都是指向正z方向的。如果物体的表面法线也是指向正z方向的，那这看起来就没有问题。但是如果物体的表面法线现在指向了y，而采样得到的法线仍然指向的是z。结果就是光照仍然认为表面法线和之前朝向正z方向时一样；这样光照就不对了。下面的图片展示了这个表面上采样的法线的近似情况：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_ground_normals.png" class="" title="img">

<p>可以看到所有法线都指向z方向，它们本该朝着表面法线指向y方向的。一个可行方案是为每个表面制作一个单独的法线贴图。如果是一个立方体的话我们就需要6个法线贴图，但是如果模型上有无数的朝向不同方向的表面，这就不可行了；另一个解决方案是，在一个不同的坐标空间中进行光照，这个坐标空间里，法线贴图向量总是指向这个坐标空间的正z方向。所有的光照向量都相对与这个正z方向进行变换。这样我们就能始终使用同样的法线贴图，不管朝向问题。这个坐标空间叫做切线空间（tangent space）。</p>
<h2 id="切线空间"><a href="#切线空间" class="headerlink" title="切线空间"></a>切线空间</h2><p>在切线空间中，法线永远指着正z方向。切线空间是位于三角形表面之上的空间：法线相对于单个三角形的局部坐标系。它就像法线贴图向量的局部空间；它们都被定义为指向正z方向，无论最终变换到什么方向。使用一个特定的矩阵我们就能将本地/切线空间中的法线向量转成世界或视图空间下，使它们变换到最终的贴图表面的方向。</p>
<p>我们可以说，前面那个朝向正y的法线贴图错误的贴到了表面上。法线贴图被定义在切线空间中，所以这种解决方式是计算出一种矩阵，把法线从切线空间变换到一个不同的空间，这样它们就能和表面法线方向对齐了：法线向量都会指向正y方向。切线空间的一大好处是我们可以为任何类型的表面计算出一个这样的矩阵，由此我们可以把切线空间的z方向和表面的法线方向对齐。</p>
<p>这种矩阵叫做TBN矩阵这三个字母分别代表tangent、bitangent和normal向量。这是建构这个矩阵所需的向量。要建构这样一个把切线空间转变为不同空间的变异矩阵，我们需要三个相互垂直的向量，它们沿一个表面的法线贴图对齐于：上、右、前；这和之前在摄像机教程中做的类似。</p>
<p>已知上向量是表面的法线向量。右和前向量是切线(Tagent)和副切线(Bitangent)向量。下面的图片展示了一个表面的三个向量：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_tbn_vectors.png" class="" title="img">

<p>计算出切线和副切线并不像法线向量那么容易。从图中可以看到法线贴图的切线和副切线与纹理坐标的两个方向对齐。我们就是用到这个特性计算每个表面的切线和副切线的。需要用到一些数学才能得到它们；请看下图：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_surface_edges.png" class="" title="img">

<p>注意上图中边E2与纹理坐标的差ΔU2、ΔV2构成一个三角形。ΔU2与切线向量T方向相同，而ΔV2与副切线向量B方向相同。这也就是说，所以我们可以将三角形的边E1与E2写成切线向量\T和副切线向量B的线性组合：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174432809.png" class="" title="image-20260127174432809">

<p>也可以写成这样：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174452326.png" class="" title="image-20260127174452326">

<p>E是两个向量位置的差，ΔU和ΔV是纹理坐标的差。然后我们得到两个未知数（切线T和副切线B）和两个等式。</p>
<p>上面的方程允许我们把它们写成另一种格式：矩阵乘法</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174528702.png" class="" title="image-20260127174528702">

<p>尝试会意一下矩阵乘法，它们确实是同一种等式。把等式写成矩阵形式的好处是，解T和B会因此变得很容易。两边都乘以ΔUΔV的逆矩阵等于：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174552719.png" class="" title="image-20260127174552719">

<p>这样我们就可以解出T和B了。这需要我们计算出delta纹理坐标矩阵的逆矩阵。我不打算讲解计算逆矩阵的细节，但大致是把它变化为，1除以矩阵的行列式，再乘以它的伴随矩阵。</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260127174616582.png" class="" title="image-20260127174616582">

<p>有了最后这个等式，我们就可以用公式、三角形的两条边以及纹理坐标计算出切线向量T和副切线B。</p>
<p>如果你对这些数学内容不理解也不用担心。当你知道我们可以用一个三角形的顶点和纹理坐标（因为纹理坐标和切线向量在同一空间中）计算出切线和副切线你就已经部分地达到目的了。</p>
<h3 id="使用代码计算切线和副切线"><a href="#使用代码计算切线和副切线" class="headerlink" title="使用代码计算切线和副切线"></a>使用代码计算切线和副切线</h3><p>假设平面使用下面的向量建立起来（1、2、3和1、3、4，它们是两个三角形）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// positions</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">pos1</span><span class="params">(<span class="number">-1.0</span>,  <span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">pos2</span><span class="params">(<span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">pos3</span><span class="params">(<span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">pos4</span><span class="params">(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="comment">// texture coordinates</span></span><br><span class="line"><span class="function">glm::vec2 <span class="title">uv1</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec2 <span class="title">uv2</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec2 <span class="title">uv3</span><span class="params">(<span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec2 <span class="title">uv4</span><span class="params">(<span class="number">1.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="comment">// normal vector</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">nm</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们先计算第一个三角形的边和deltaUV坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 edge1 = pos2 - pos1;</span><br><span class="line">glm::vec3 edge2 = pos3 - pos1;</span><br><span class="line">glm::vec2 deltaUV1 = uv2 - uv1;</span><br><span class="line">glm::vec2 deltaUV2 = uv3 - uv1;</span><br></pre></td></tr></table></figure>

<p>有了计算切线和副切线的必备数据，我们就可以开始写出来自于前面部分中的下列等式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GLfloat f = <span class="number">1.0f</span> / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);</span><br><span class="line"></span><br><span class="line">tangent1.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);</span><br><span class="line">tangent1.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);</span><br><span class="line">tangent1.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);</span><br><span class="line">tangent1 = glm::<span class="built_in">normalize</span>(tangent1);</span><br><span class="line"></span><br><span class="line">bitangent1.x = f * (-deltaUV2.x * edge1.x + deltaUV1.x * edge2.x);</span><br><span class="line">bitangent1.y = f * (-deltaUV2.x * edge1.y + deltaUV1.x * edge2.y);</span><br><span class="line">bitangent1.z = f * (-deltaUV2.x * edge1.z + deltaUV1.x * edge2.z);</span><br><span class="line">bitangent1 = glm::<span class="built_in">normalize</span>(bitangent1);  </span><br><span class="line"></span><br><span class="line">[...] <span class="comment">// 对平面的第二个三角形采用类似步骤计算切线和副切线</span></span><br></pre></td></tr></table></figure>

<p>我们预先计算出等式的分数部分<code>f</code>，然后把它和每个向量的元素进行相应矩阵乘法。如果你把代码和最终的等式对比你会发现，这就是直接套用。最后我们还要进行标准化，来确保切线/副切线向量最后是单位向量。</p>
<p>因为一个三角形永远是平整的形状，我们只需为每个三角形计算一个切线/副切线，它们对于每个三角形上的顶点都是一样的。要注意的是大多数实现通常三角形和三角形之间都会共享顶点。这种情况下开发者通常将每个顶点的法线和切线/副切线等顶点属性平均化，以获得更加柔和的效果。我们的平面的三角形之间分享了一些顶点，但是因为两个三角形相互并行，因此并不需要将结果平均化。</p>
<p>最后的切线和副切线向量的值应该是(1, 0, 0)和(0, 1, 0)，它们和法线(0, 0, 1)组成相互垂直的TBN矩阵。</p>
<p>每个顶点定义了切线和副切线向量，我们就可以开始实现正确的法线贴图了。</p>
<h3 id="切线空间法线贴图"><a href="#切线空间法线贴图" class="headerlink" title="切线空间法线贴图"></a>切线空间法线贴图</h3><p>为让法线贴图工作，我们先得在着色器中创建一个TBN矩阵。我们先将前面计算出来的切线和副切线向量传给顶点着色器，作为它的属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aNormal;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 aTexCoords;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">3</span>) in vec3 aTangent;</span><br></pre></td></tr></table></figure>

<p>在顶点着色器的main函数中我们创建TBN矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 T = <span class="built_in">normalize</span>(normalMatrix * aTangent);</span><br><span class="line">    vec3 N = <span class="built_in">normalize</span>(normalMatrix * aNormal);</span><br><span class="line"></span><br><span class="line">    T = <span class="built_in">normalize</span>(T - <span class="built_in">dot</span>(T, N) * N);</span><br><span class="line">    vec3 B = <span class="built_in">cross</span>(N, T);</span><br><span class="line">    </span><br><span class="line">    mat3 TBN = <span class="built_in">transpose</span>(<span class="built_in">mat3</span>(T, B, N));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先将所有TBN向量变换到我们所操作的坐标系中，现在是世界空间，可以乘以model矩阵。然后我们创建实际的TBN矩阵，直接把相应的向量应用到mat3构造器就行。注意，如果我们希望更精确的话就不要将TBN向量乘以model矩阵，而是使用法线矩阵，因为我们只关心向量的方向，不关心平移和缩放。</p>
<p>现在我们有了TBN矩阵，如何来使用它呢？通常来说有两种方式使用它，我们会把这两种方式都说明一下：</p>
<ol>
<li>我们直接使用TBN矩阵，这个矩阵可以把切线坐标空间的向量转换到世界坐标空间。因此我们把它传给片段着色器中，把通过采样得到的法线坐标左乘上TBN矩阵，转换到世界坐标空间中，这样所有法线和其他光照变量就在同一个坐标系中了。</li>
<li>我们也可以使用TBN矩阵的逆矩阵，这个矩阵可以把世界坐标空间的向量转换到切线坐标空间。因此我们使用这个矩阵左乘其他光照变量，把他们转换到切线空间，这样法线和其他光照变量再一次在一个坐标系中了。</li>
</ol>
<p><strong>我们来看看第一种情况。</strong>我们从法线贴图采样得来的法线向量，是在切线空间表示的，尽管其他光照向量都是在世界空间表示的。把TBN传给像素着色器，我们就能将采样得来的切线空间的法线乘以这个TBN矩阵，将法线向量变换到和其他光照向量一样的参考空间中。这种方式随后所有光照计算都可以简单的理解。</p>
<p>把TBN矩阵发给片段着色器很简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    mat3 TBN;</span><br><span class="line">&#125; vs_out;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    vs_out.TBN = <span class="built_in">mat3</span>(T, B, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在片段着色器中我们用mat3作为输入变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    mat3 TBN;</span><br><span class="line">&#125; fs_in;</span><br></pre></td></tr></table></figure>

<p>有了TBN矩阵我们现在就可以更新法线贴图代码，引入切线到世界空间变换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">normal = <span class="built_in">texture</span>(normalMap, fs_in.TexCoords).rgb;</span><br><span class="line">normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);   </span><br><span class="line">normal = <span class="built_in">normalize</span>(fs_in.TBN * normal);</span><br></pre></td></tr></table></figure>

<p>因为最后的normal现在在世界空间中了，就不用改变其他像素着色器的代码了，因为光照代码就是假设法线向量在世界空间中。</p>
<p><strong>我们同样看看第二种情况。</strong>我们用TBN矩阵的逆矩阵将所有相关的世界空间向量转变到采样所得法线向量的空间：切线空间。TBN的建构还是一样，但我们在将其发送给片段着色器之前先要求逆矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs_out.TBN = <span class="built_in">transpose</span>(<span class="built_in">mat3</span>(T, B, N));</span><br></pre></td></tr></table></figure>

<p>注意，这里我们使用transpose函数，而不是inverse函数。正交矩阵（每个轴既是单位向量同时相互垂直）的一大属性是一个正交矩阵的置换矩阵与它的逆矩阵相等。这个属性很重要因为逆矩阵的求得比求置换开销大；结果却是一样的。</p>
<p>在片段着色器中我们不用对法线向量变换，但我们要把其他相关向量转换到切线空间，它们是lightDir和viewDir。这样每个向量还是在同一个空间（切线空间）中了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 normal = <span class="built_in">texture</span>(normalMap, fs_in.TexCoords).rgb;</span><br><span class="line">    normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);   </span><br><span class="line"></span><br><span class="line">    vec3 lightDir = fs_in.TBN * <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    vec3 viewDir  = fs_in.TBN * <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);    </span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法看似要做的更多，它还需要在片段着色器中进行更多的乘法操作，所以为何还用第二种方法呢？</p>
<p>将向量从世界空间转换到切线空间有个额外好处，我们可以把所有相关向量在顶点着色器中转换到切线空间，不用在片段着色器中做这件事。这是可行的，因为lightPos和viewPos不是每个fragment运行都要改变，对于fs_in.FragPos，我们也可以在顶点着色器计算它的切线空间位置。基本上，不需要把任何向量在顶点着色器中进行变换，而第一种方法中就是必须的，因为采样出来的法线向量对于每个片段着色器都不一样。</p>
<p>所以现在不是把TBN矩阵的逆矩阵发送给片段着色器，而是将切线空间的光源位置，观察位置以及顶点位置发送给片段着色器。这样我们就不用在顶点着色器里进行矩阵乘法了。这是一个极佳的优化，因为顶点着色器的运行频率明显低于片段着色器。这也是为什么这种方法是一种更好的实现方式的原因。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec3 TangentLightPos;</span><br><span class="line">    vec3 TangentViewPos;</span><br><span class="line">    vec3 TangentFragPos;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    [...]</span><br><span class="line">    mat3 TBN = <span class="built_in">transpose</span>(<span class="built_in">mat3</span>(T, B, N));</span><br><span class="line">    vs_out.TangentLightPos = TBN * lightPos;</span><br><span class="line">    vs_out.TangentViewPos  = TBN * viewPos;</span><br><span class="line">    vs_out.TangentFragPos  = TBN * <span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(position, <span class="number">0.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在片段着色器中我们使用这些新的输入变量来计算切线空间的光照。因为法线向量已经在切线空间中了，光照就有意义了。</p>
<p>将法线贴图应用到切线空间上，我们会得到混合教程一开始那个例子相似的结果，但这次我们可以将平面朝向各个方向，光照一直都会是正确的，最终的效果如下所示：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/image-20260209164528383.png" class="" title="image-20260209164528383">

<p>在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping.rar">这里</a>可以获取完整的代码</p>
<h2 id="复杂物体"><a href="#复杂物体" class="headerlink" title="复杂物体"></a>复杂物体</h2><p>我们已经知道如何计算切线和副切线向量，使用切线空间和法线贴图。所幸，计算这些切线和副切线向量对于你来说不是经常能遇到的事；大多数时候，在模型加载器中实现一次就行了，Assimp的那个加载器中有进行实现。</p>
<p>Assimp有个很有用的配置，在我们加载模型的时候调用aiProcess_CalcTangentSpace。当aiProcess_CalcTangentSpace应用到Assimp的ReadFile函数时，Assimp会为每个加载的顶点计算出柔和的切线和副切线向量，它所使用的方法和我们前面使用的类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> aiScene* scene = importer.<span class="built_in">ReadFile</span>(</span><br><span class="line">    path, aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>我们可以通过下面的代码用Assimp获取计算出来的切线空间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector.x = mesh-&gt;mTangents[i].x;</span><br><span class="line">vector.y = mesh-&gt;mTangents[i].y;</span><br><span class="line">vector.z = mesh-&gt;mTangents[i].z;</span><br><span class="line">vertex.Tangent = vector;</span><br></pre></td></tr></table></figure>

<p>然后，你还必须更新模型加载器，用以从带纹理模型中加载法线贴图。wavefront的模型格式（.obj）导出的法线贴图有点不一样，Assimp的aiTextureType_NORMAL并不会加载它的法线贴图，而aiTextureType_HEIGHT却能，所以我们经常这样加载它们：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector normalMaps = <span class="built_in">loadMaterialTextures</span>(material, aiTextureType_HEIGHT, <span class="string">&quot;texture_normal&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当然，这对于每个模型的类型和文件格式来说都是不同的。计算切线需要依据纹理坐标，有些模型制作者使用一些纹理小技巧比如镜像一个模型上的纹理表面时也镜像了另一半的纹理坐标；这样当不考虑这个镜像的特别操作的时候（Assimp就不考虑）结果就不对了。</p>
<p>运行程序，用新的模型加载器，加载一个有specular和法线贴图的模型，看起来会像这样：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_complex_compare.png" class="" title="img">

<p>你可以看到在没有太多点的额外开销的情况下法线贴图难以置信地提升了物体的细节。</p>
<p>使用法线贴图也是一种提升你的场景的表现的重要方式。在使用法线贴图之前你不得不使用相当多的顶点才能表现出一个更精细的网格，但使用了法线贴图我们可以使用更少的顶点表现出同样丰富的细节。下图来自Paolo Cignoni，图中对比了两种方式：</p>
<img src="/2026/01/26/33-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/normal_mapping_comparison.png" class="" title="img">

<p>高精度网格和使用法线贴图的低精度网格几乎区分不出来。所以法线贴图不仅看起来漂亮，它也是一个将高精度多边形转换为低精度多边形而不失细节的重要工具。</p>
<h2 id="最后一件事"><a href="#最后一件事" class="headerlink" title="最后一件事"></a>最后一件事</h2><p>关于法线贴图还有最后一个技巧要讨论，它可以在不必花费太多性能开销的情况下稍稍提升画质表现。</p>
<p>当在更大的网格上计算切线向量的时候，它们往往有很大数量的共享顶点，当法向贴图应用到这些表面时将切线向量平均化通常能获得更好更平滑的结果。这样做有个问题，就是TBN向量可能会不能互相垂直，这意味着TBN矩阵不再是正交矩阵了。法线贴图可能会稍稍偏移，但这仍然可以改进。</p>
<p>使用叫做<em>格拉姆-施密特</em>正交化过程（Gram-Schmidt process）的数学技巧，我们可以对TBN向量进行重正交化，这样每个向量就又会重新垂直了。在顶点着色器中我们这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vec3 T = <span class="built_in">normalize</span>(<span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(tangent, <span class="number">0.0</span>)));</span><br><span class="line">vec3 N = <span class="built_in">normalize</span>(<span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(normal, <span class="number">0.0</span>)));</span><br><span class="line"><span class="comment">// re-orthogonalize T with respect to N</span></span><br><span class="line">T = <span class="built_in">normalize</span>(T - <span class="built_in">dot</span>(T, N) * N);</span><br><span class="line"><span class="comment">// then retrieve perpendicular vector B with the cross product of T and N</span></span><br><span class="line">vec3 B = <span class="built_in">cross</span>(T, N);</span><br><span class="line"></span><br><span class="line">mat3 TBN = <span class="built_in">mat3</span>(T, B, N)</span><br></pre></td></tr></table></figure>

<p>这样稍微花费一些性能开销就能对法线贴图进行一点提升。看看最后的那个附加资源： Normal Mapping Mathematics视频，里面有对这个过程的解释。</p>
<h2 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a>附加资源</h2><ul>
<li><a target="_blank" rel="noopener" href="http://ogldev.atspace.co.uk/www/tutorial26/tutorial26.html">Tutorial 26: Normal Mapping</a>：ogldev的法线贴图教程。</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=LIOPYmknj5Q">How Normal Mapping Works</a>：TheBennyBox的讲述法线贴图如何工作的视频。</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=4FaWLgsctqY">Normal Mapping Mathematics</a>：TheBennyBox关于法线贴图的数学原理的教程。</li>
<li><a target="_blank" rel="noopener" href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/">Tutorial 13: Normal Mapping</a>：opengl-tutorial.org提供的法线贴图教程。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/06/Deadline%E5%AF%B9Job%E8%BF%9B%E8%A1%8C%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/06/Deadline%E5%AF%B9Job%E8%BF%9B%E8%A1%8C%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Deadline对Job进行预处理的几种方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-06 17:28:21 / 修改时间：17:56:11" itemprop="dateCreated datePublished" datetime="2025-08-06T17:28:21+08:00">2025-08-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="对deadline的Job进行预设置的几种思路："><a href="#对deadline的Job进行预设置的几种思路：" class="headerlink" title="对deadline的Job进行预设置的几种思路："></a>对deadline的Job进行预设置的几种思路：</h1><h2 id="1-使用Event注册回调函数"><a href="#1-使用Event注册回调函数" class="headerlink" title="1.使用Event注册回调函数"></a>1.使用Event注册回调函数</h2><p>这是官方推荐的方法，具体的可以查看官方文档：[Event Plugins — Deadline 10.4.2.2 documentation](<a target="_blank" rel="noopener" href="https://docs.thinkboxsoftware.com/products/deadline/10.4/1_User">https://docs.thinkboxsoftware.com/products/deadline/10.4/1_User</a> Manual/manual/event-plugins.html?highlight=callback)</p>
<p>这种方法可以在Job进入渲染之前就进行设置，不过存在很大的局限性，只有通过UI进行前台提交的Job会触发OnJobSubmittedCallback回调。</p>
<p>只需要在[DeadlineRepository]/custom/events文件夹下创建你的自定义事件，创建自定义事件时需要注意以下几点：</p>
<ul>
<li><p>文件夹名称与.param、.py文件名必须一致，如下图所示</p>
<img src="/2025/08/06/Deadline%E5%AF%B9Job%E8%BF%9B%E8%A1%8C%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20250806165524596.png" class="" title="image-20250806165524596"></li>
<li><p>代码报错时会导致deadline报错，引发一系列问题，需要通过重启deadline服务和数据库进行更新</p>
</li>
<li><p>调试时应该确保事件启用</p>
<p>例如，我们注册一个OnJobSubmittedCallback回调，打印一些东西</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Deadline.Events <span class="keyword">import</span> DeadlineEventListener</span><br><span class="line"><span class="keyword">from</span> Deadline.Scripting <span class="keyword">import</span> RepositoryUtils</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetDeadlineEventListener</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This is the function that Deadline calls to get an instance of the</span></span><br><span class="line"><span class="string">    main DeadlineEventListener class.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> JobInitEvent()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CleanupDeadlineEventListener</span>(<span class="params">deadlinePlugin</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This is the function that Deadline calls when the event plugin is</span></span><br><span class="line"><span class="string">    no longer in use so that it can get cleaned up.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    deadlinePlugin.Cleanup()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JobInitEvent</span>(<span class="title class_ inherited__">DeadlineEventListener</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This is the main DeadlineEventListener class for JobInitEvent&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># Set up the event callbacks here</span></span><br><span class="line">        self.OnJobSubmittedCallback += self.OnJobSubmitted</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Cleanup</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self.OnJobSubmittedCallback</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">OnJobSubmitted</span>(<span class="params">self, job</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;OnJobSubmitted!!!&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;OnJobSubmittedCallback is ran!!!&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-修改GlobalJobPreLoad脚本"><a href="#2-修改GlobalJobPreLoad脚本" class="headerlink" title="2.修改GlobalJobPreLoad脚本"></a>2.修改GlobalJobPreLoad脚本</h2><p>在deadline安装路径下，有一个脚本<code>GlobalJobPreLoad.py</code> ，他是在每一个 任务（task）启动时被调用的一个全局预加载（Pre-Load）脚本。它的主要作用是允许你在任务开始运行之前，对任务做一些全局性的设置，比如：</p>
<ul>
<li>环境变量设置</li>
<li>日志记录</li>
<li>插件参数调整</li>
<li>条件拦截任务运行</li>
<li>输出调试信息</li>
</ul>
<p>通常他的位置在”[DeadlineRepository]/custom/plugins/GlobalJobPreLoad.py”。</p>
<p>这个脚本中有一个<code>__main__</code>函数，这个脚本只会执行其中的这个函数中的内容。其他函数不会自动被执行，除非你从 <code>__main__()</code> 里调用它们。</p>
<p>例如，我们想在任务运行前对任务的优先级等做一个重设：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import  <span class="comment"># Import system&#x27;s os, not backports.os.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Deadline.Scripting <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> FranticX.Diagnostics <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> Deadline.Jobs <span class="keyword">as</span> Job</span><br><span class="line"><span class="keyword">import</span> Deadline.Plugins <span class="keyword">as</span> pg</span><br><span class="line"><span class="keyword">from</span> Deadline.Events <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Deadline.Scripting <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">job = <span class="literal">None</span>  <span class="comment"># type: Job.Job</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">job_pre_settings</span>(<span class="params">job</span>):</span><br><span class="line">    plugin = job.get_JobPlugin()</span><br><span class="line">    <span class="built_in">id</span> = job.get_ID()</span><br><span class="line">    group = job.get_Group()</span><br><span class="line">    pool = job.get_Pool()</span><br><span class="line">    batchname = job.get_BatchName()</span><br><span class="line">    comment = job.get_Comment()</span><br><span class="line">    priority = job.get_Priority()</span><br><span class="line">    comment_config = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;JobPlugin:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(plugin))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ID:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Priority:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(priority))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Group:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(group))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Pool:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(pool))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;BatchName:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(batchname))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Comment:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(comment))</span><br><span class="line"></span><br><span class="line">    comment_config = &#123;</span><br><span class="line">        <span class="string">&#x27;nuke&#x27;</span>: &#123;<span class="string">&#x27;priority&#x27;</span>: <span class="number">80</span>, <span class="string">&#x27;group&#x27;</span>: <span class="string">&#x27;nuke&#x27;</span>, <span class="string">&#x27;pool&#x27;</span>: <span class="string">&#x27;render&#x27;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;katana&#x27;</span>: &#123;<span class="string">&#x27;priority&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;group&#x27;</span>: <span class="string">&#x27;katana&#x27;</span>, <span class="string">&#x27;pool&#x27;</span>: <span class="string">&#x27;render&#x27;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;houdini&#x27;</span>: &#123;<span class="string">&#x27;priority&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;group&#x27;</span>: <span class="string">&#x27;render&#x27;</span>, <span class="string">&#x27;pool&#x27;</span>: <span class="string">&#x27;render&#x27;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;maya&#x27;</span>: &#123;<span class="string">&#x27;priority&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;group&#x27;</span>: <span class="string">&#x27;render&#x27;</span>, <span class="string">&#x27;pool&#x27;</span>: <span class="string">&#x27;render&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    config = comment_config.get(comment, &#123;</span><br><span class="line">        <span class="string">&#x27;priority&#x27;</span>: job.get_Priority(),</span><br><span class="line">        <span class="string">&#x27;group&#x27;</span>: job.get_Group(),</span><br><span class="line">        <span class="string">&#x27;pool&#x27;</span>: job.get_Pool()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    priority = config[<span class="string">&#x27;priority&#x27;</span>]</span><br><span class="line">    group = config[<span class="string">&#x27;group&#x27;</span>]</span><br><span class="line">    pool = config[<span class="string">&#x27;pool&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    job.set_Priority(priority)</span><br><span class="line">    job.set_Group(group)</span><br><span class="line">    job.set_Pool(pool)</span><br><span class="line">    <span class="comment"># job.set_SecondaryPool()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> Deadline.Scripting <span class="keyword">import</span> RepositoryUtils</span><br><span class="line">        RepositoryUtils.SaveJob(job)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Saved......&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;save error......&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;job pre set up over.......&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;set priority to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(priority))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;set group to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(group))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;set pool to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(pool))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__main__</span>(<span class="params"> deadlinePlugin:pg.DeadlinePlugin =<span class="literal">None</span> </span>):</span><br><span class="line">    <span class="keyword">global</span> job</span><br><span class="line">    job = deadlinePlugin.GetJob()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        job_pre_settings(job)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-定制化开发"><a href="#3-定制化开发" class="headerlink" title="3.定制化开发"></a>3.定制化开发</h2><p>有些时候可能是没有UI的后台提交Job，那么就需要在具体的任务提交前提前编写一个预设置的代码，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Deadline.DeadlineConnect <span class="keyword">as</span> Connect</span><br><span class="line"></span><br><span class="line">CONN = Connect.DeadlineCon(PRL_DEADLINE_URL, PRL_DEADLINE_PORT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlineJob</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.connection = CONN</span><br><span class="line">        self.job_info = &#123;&#125;</span><br><span class="line">        self.plugin_info = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">submit_pre_setting</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">submit</span>(<span class="params">self, aux_files=[]</span>):</span><br><span class="line">        self.submit_pre_setting()</span><br><span class="line">		CONN.Jobs.SubmitJob(self.job_info, self.plugin_info, aux=aux_files)</span><br><span class="line">        </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Job = DeadlineJob()</span><br><span class="line">Job.submit()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/" class="post-title-link" itemprop="url">在Katana中渲染AOV并输出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-18 17:20:32" itemprop="dateCreated datePublished" datetime="2025-07-18T17:20:32+08:00">2025-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-14 17:39:24" itemprop="dateModified" datetime="2026-01-14T17:39:24+08:00">2026-01-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一个katana最基本的渲染结构"><a href="#一个katana最基本的渲染结构" class="headerlink" title="一个katana最基本的渲染结构"></a>一个katana最基本的渲染结构</h1><p>首先，在katana中进行一个渲染的最基本结构（使用Arnold渲染器）如下所示：</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718162415463.png" class="" title="image-20250718162415463">

<p>一个最基本的katana渲染工程应该包括上面这几部分：</p>
<p>1.数据的入口，包括了模型、摄像机、材质等，这些渲染数据可以是在katana中创建的，也可以是使用节点读入的，总之你要渲染的东西就从这里开始，并且摄像机是必须的（模型和材质可以没有，渲染结果没有东西而已，没有摄像机就不能渲染）。</p>
<p>2.材质的赋予，这个操作可以是手动的，也可以是节点解析自动赋予的。</p>
<p>3.灯光节点，灯光师会在这里创建灯光对渲染场景进行照明，大多数渲染分层是必须灯光照明的（部分AOV渲染可能不需要灯光，比如AO、Wireframe等）。</p>
<p>4.渲染设置相关节点，RenderSettings节点是对渲染的全局进行设置，包括了摄像机的指定、渲染器的指定、渲染分辨率等，ArnoldGlobalSettings节点是对Arnold渲染器的渲染设置。</p>
<p>5.待前序的所有数据和设置准备完毕，就可以右键Render进行渲染。</p>
<h1 id="渲染输出AOV相关分层"><a href="#渲染输出AOV相关分层" class="headerlink" title="渲染输出AOV相关分层"></a>渲染输出AOV相关分层</h1><p><strong>AOV</strong> 是 <strong>Arbitrary Output Variables</strong>（任意输出变量）的缩写。</p>
<p>它是现代渲染管线中非常重要的一个概念，尤其在电影和视觉特效制作中非常常见。</p>
<p><strong>AOV</strong> 指的是在渲染时，从一个场景或材质里，除了最终合成用的主图（beauty pass）之外，额外输出的各种图层或通道。每个 AOV 通常包含某种特定的图像信息，用于后期合成、调色、特效、调试等。比如：Diffuse、Specular、Object ID、RestP等。</p>
<p>那么如何在katana中输出AOV层，以AO和CryptoMatte为例，大致需要分为下面的几步：</p>
<ol>
<li><p>创建AOV材质</p>
<p>对于cryptomatte，katana提供了封装好的AOV材质节点，只需要创建Material节点选择cryptomatte类型材质即可</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718164724073.png" class="" title="image-20250718164724073">

<p>对于AO材质就要麻烦一点，首先我们需要创建这个材质，再将这个材质写入到AOV中并且定义写入的AOV名称（一定要记住这个名称后面需要用到）</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718165017275.png" class="" title="image-20250718165017275">

<p>然后再将这个材质添加到katana的层级中</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718165235235.png" class="" title="image-20250718165235235"></li>
<li><p>设置AOV属性</p>
<p>对于cryptomatte分层，我们需要对每个对象进行属性的定义，Arnold进行渲染时会为每一个不同的ID的对象分配不同的颜色，从而呈现object分层效果，可以通过OpScript节点创建属性：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment">/root/world/geo/World/asset//*&#123;attr(&quot;type&quot;) == &quot;component&quot;&#125;</span></span><br><span class="line"><span class="comment">--/root/world//*&#123;hasattr(&quot;materialAssign&quot;)&#125;</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> op_path=Interface.GetRootLocationPath()</span><br><span class="line"><span class="keyword">local</span> asset_name = <span class="built_in">string</span>.<span class="built_in">match</span>(op_path, <span class="string">&quot;([^/]+)$&quot;</span>)</span><br><span class="line">Interface.SetAttr(<span class="string">&quot;geometry.arbitrary.crypto_asset.value&quot;</span>, StringAttribute(asset_name))</span><br><span class="line">Interface.SetAttr(<span class="string">&quot;geometry.arbitrary.crypto_asset.scope&quot;</span>, StringAttribute(<span class="string">&quot;primitive&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--local surfShader = Interface.GetAttr(&#x27;materialAssign&#x27;)</span></span><br><span class="line"><span class="comment">--if surfShader then</span></span><br><span class="line"><span class="comment">--    Interface.SetAttr(&quot;geometry.arbitrary.crypto_material.scope&quot;, StringAttribute(&quot;primitive&quot;))</span></span><br><span class="line"><span class="comment">--    Interface.SetAttr(&#x27;geometry.arbitrary.crypto_material.value&#x27;, surfShader  )</span></span><br><span class="line"><span class="comment">--end</span></span><br></pre></td></tr></table></figure>

<p>而AO分层的所有对象使用的是同一种材质（不需要经过上述的计算），所以不需要进行设置。</p>
</li>
<li><p>“赋予材质”</p>
<p>我们创建了这些材质，那么如何让这个材质起作用呢？直接进行赋予的话那么我们的渲染结果就只有AOV那一层了，我们需要在ArnoldGlobalSettings中将AOV材质添加到AOV Shader中</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718170640684.png" class="" title="image-20250718170640684"></li>
<li><p>定义输出通道和路径</p>
<p>接下来我们创建ArnoldOutputChannelDefine节点定义AOV输出的层的名称，通道填写我们创建材质时定义的AOV名称</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718170910425.png" class="" title="image-20250718170910425">

<p>接着创建RenderOutputDefine接收我们的渲染分层并输出，这里的通道是ArnoldOutputChannelDefine中创建的名字</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718171126881.png" class="" title="image-20250718171126881"></li>
</ol>
<p>最后我们便可以渲染我们的AOV分层了，同样的可以创建其他的AOV分层，效果如下：</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718171459066.png" class="" title="image-20250718171459066">

<p><img src="%E5%9C%A8katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20250718171751520.png" alt="image-20250718171751520"></p>
<h1 id="渲染灯光组分层"><a href="#渲染灯光组分层" class="headerlink" title="渲染灯光组分层"></a>渲染灯光组分层</h1><p>如果现在有一个灯光组（dome）想要渲染分层diffuse_direct_dome和diffuse_indirect_dome，如何实现？</p>
<p>首先需要在创建Arnold灯光时指定灯光组，设置灯光的aov属性，aov属性名称一样的灯光将被作为一个灯光组参与该灯光组分层的渲染</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20260114173329613.png" class="" title="image-20260114173329613">

<p>接着需要在aod节点中进行设置，Arnold提供了diffuse_direct和diffuse_indirect通道，只需要在节点中指定即可， 在lightGroups中选择custom（默认为all，即所有灯光），下面添加对应的灯光组命名</p>
<img src="/2025/07/18/%E5%9C%A8Katana%E4%B8%AD%E6%B8%B2%E6%9F%93AOV%E5%B9%B6%E8%BE%93%E5%87%BA/image-20260114173654767.png" class="" title="image-20260114173654767">

<p>最后配合对应的rod节点即可输出diffuse_direct_dome和diffuse_indirect_dome的灯光组分层</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/18/Katana%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/18/Katana%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Katana的常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-18 17:20:01 / 修改时间：17:22:25" itemprop="dateCreated datePublished" datetime="2025-07-18T17:20:01+08:00">2025-07-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="1-需要导入的包"><a href="#1-需要导入的包" class="headerlink" title="1.需要导入的包"></a>1.需要导入的包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Katana <span class="keyword">import</span> NodegraphAPI, KatanaFile</span><br><span class="line"><span class="keyword">from</span> fnpxr <span class="keyword">import</span> Usd</span><br></pre></td></tr></table></figure>

<h2 id="2-文件操作相关命令"><a href="#2-文件操作相关命令" class="headerlink" title="2.文件操作相关命令"></a>2.文件操作相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>KatanaFile.Load(filename)</code></td>
<td>加载 <code>.katana</code> 文件为当前工程（替换当前内容）</td>
</tr>
<tr>
<td><code>KatanaFile.Save(filename)</code></td>
<td>将当前工程保存为指定路径</td>
</tr>
<tr>
<td><code>KatanaFile.Save()</code></td>
<td>保存当前工程（覆盖当前文件）</td>
</tr>
<tr>
<td><code>KatanaFile.Import(filename)</code></td>
<td>将其他 <code>.katana</code> 文件导入到当前工程中</td>
</tr>
<tr>
<td><code>KatanaFile.IsFileDirty()</code></td>
<td>当前工程是否修改过未保存</td>
</tr>
<tr>
<td><code>KatanaFile.GetCurrentFilename()</code></td>
<td>获取当前工程文件名</td>
</tr>
<tr>
<td><code>KatanaFile.New()</code></td>
<td>新建一个空工程（清空当前）</td>
</tr>
<tr>
<td><code>KatanaFile.SetCurrentFilename(path)</code></td>
<td>设置当前工程名（注意：不保存，只设置路径）</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetRootNode().getParameter(&#39;inTime&#39;).getValue(0)</code></td>
<td>获取当前工程project settings中的设置</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetRootNode().getParameter(&#39;currentTime&#39;).setValue(1001， 0)</code></td>
<td>设置当前工程project settings中的设置</td>
</tr>
<tr>
<td><code>NodegraphAPI.SetWorkingInTime(1001)</code></td>
<td>设置工程起始帧</td>
</tr>
<tr>
<td><code>NodegraphAPI.SetTimeIncrement(1)</code></td>
<td>设置时间增量</td>
</tr>
<tr>
<td><code>NodegraphAPI.SetCurrentTime(1001)</code></td>
<td>设置当前滑块时间</td>
</tr>
<tr>
<td><code>NodegraphAPI.SetWorkingOutTime(1200)</code></td>
<td>设置工程结束帧</td>
</tr>
</tbody></table>
<h2 id="3-节点相关操作"><a href="#3-节点相关操作" class="headerlink" title="3.节点相关操作"></a>3.节点相关操作</h2><h3 id="1-获取节点信息"><a href="#1-获取节点信息" class="headerlink" title="1.获取节点信息"></a>1.获取节点信息</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>NodegraphAPI.CreateNode(nodeType, parent=None)</code></td>
<td>创建指定类型的节点</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetNode(nodeName)</code></td>
<td>获取指定名称的节点对象</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetAllNodes()</code></td>
<td>获取当前场景中的所有节点</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetAllNodesByType(nodeType)</code></td>
<td>获取所有某种类型的节点</td>
</tr>
<tr>
<td><code>NodegraphAPI.DeleteNode(node)</code></td>
<td>删除节点（或多个）</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetRootNode()</code></td>
<td>获取整个 NodeGraph 的根节点</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetGroupNodes(node)</code></td>
<td>获取组节点中的子节点</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetGroupParent(node)</code></td>
<td>获取所属的父组节点</td>
</tr>
<tr>
<td><code>NodegraphAPI.GetSelectedNodes()</code></td>
<td>获取当前选中的节点</td>
</tr>
</tbody></table>
<h3 id="2-获取节点的属性"><a href="#2-获取节点的属性" class="headerlink" title="2.获取节点的属性"></a>2.获取节点的属性</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>node.getParameter(&quot;paramName&quot;)</code></td>
<td>获取节点上指定参数对象</td>
</tr>
<tr>
<td><code>node.getParameters()</code></td>
<td>获取所有参数</td>
</tr>
<tr>
<td><code>node.setName(name)</code></td>
<td>设置节点名称</td>
</tr>
<tr>
<td><code>node.getName()</code></td>
<td>获取节点名称</td>
</tr>
</tbody></table>
<h3 id="3-节点连接与位置排版"><a href="#3-节点连接与位置排版" class="headerlink" title="3.节点连接与位置排版"></a>3.节点连接与位置排版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input_port = node.getInputPort(<span class="string">&quot;in&quot;</span>)</span><br><span class="line">output_port = otherNode.getOutputPort(<span class="string">&quot;out&quot;</span>)</span><br><span class="line">input_port.connect(output_port)</span><br><span class="line"></span><br><span class="line">NodegraphAPI.SetNodePosition(node, (<span class="number">100</span>, <span class="number">300</span>))</span><br><span class="line">pos = NodegraphAPI.GetNodePosition(node)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>node.getInputPort(name)</code> / <code>node.getOutputPort(name)</code></td>
<td>获取输入/输出端口</td>
</tr>
<tr>
<td><code>node.getInputPort(&quot;in&quot;).connect(outputPort)</code></td>
<td>将端口连接起来</td>
</tr>
<tr>
<td><code>node.getInputPort(&quot;in&quot;).disconnect()</code></td>
<td>断开端口连接</td>
</tr>
<tr>
<td><code>node.getConnectedPort()</code></td>
<td>获取已连接端口</td>
</tr>
<tr>
<td><code>node.GetNodePosition(node)</code></td>
<td>获取节点位置</td>
</tr>
<tr>
<td><code>node.SetNodePosition(node, (x, y))</code></td>
<td>设置节点在图中的位置</td>
</tr>
</tbody></table>
<h1 id="lua（在katana的OpScript节点中使用）"><a href="#lua（在katana的OpScript节点中使用）" class="headerlink" title="lua（在katana的OpScript节点中使用）"></a>lua（在katana的OpScript节点中使用）</h1><h2 id="1-开启材质中image节点的ignore-missing-textures属性"><a href="#1-开启材质中image节点的ignore-missing-textures属性" class="headerlink" title="1.开启材质中image节点的ignore_missing_textures属性"></a>1.开启材质中image节点的ignore_missing_textures属性</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">This script can set aiImage ignore_missing_textures attribute to True</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment"> /root/world//*&#123;attr(&quot;type&quot;) == &quot;material&quot;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">script:</span></span><br><span class="line"><span class="comment">local module = require(&#x27;prl_katana.mat.image&#x27;)</span></span><br><span class="line"><span class="comment">module.SetImageAttrs()</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.SetImageAttrs</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> nodeListAttr = Interface.GetAttr(<span class="string">&#x27;material.nodes&#x27;</span>)</span><br><span class="line">    <span class="keyword">local</span> childNum = nodeListAttr:getNumberOfChildren()</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>, childNum <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> nodeAttr = nodeListAttr:getChildByIndex(i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeName = nodeListAttr:getChildName(i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeTarget = nodeAttr:getChildByName(<span class="string">&#x27;target&#x27;</span>):getValue()</span><br><span class="line">        <span class="keyword">local</span> nodeType = nodeAttr:getChildByName(<span class="string">&#x27;type&#x27;</span>):getValue()</span><br><span class="line">        <span class="comment">--print(nodeName, nodeTarget, nodeType)</span></span><br><span class="line">        <span class="comment">--print(nodeType)</span></span><br><span class="line">        <span class="keyword">if</span> nodeType == <span class="string">&#x27;image&#x27;</span> <span class="keyword">then</span></span><br><span class="line">            Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.ignore_missing_textures&#x27;</span>, IntAttribute(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure>

<h2 id="2-将USD材质转换为Arnold材质"><a href="#2-将USD材质转换为Arnold材质" class="headerlink" title="2.将USD材质转换为Arnold材质"></a>2.将USD材质转换为Arnold材质</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">This script can convert usd material to arnold material</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment"> /root/world//*&#123;attr(&quot;type&quot;) == &quot;material&quot;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">script:</span></span><br><span class="line"><span class="comment">local module = require(&#x27;prl_katana.mat.shader&#x27;)</span></span><br><span class="line"><span class="comment">module.ResolveUsdMat()</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.ResolveUsdMat</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> nodeListAttr = Interface.GetAttr(<span class="string">&#x27;material.nodes&#x27;</span>)</span><br><span class="line">    <span class="keyword">local</span> childNum = nodeListAttr:getNumberOfChildren()</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>, childNum <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> nodeAttr = nodeListAttr:getChildByIndex(i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeName = nodeListAttr:getChildName(i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeTarget = nodeAttr:getChildByName(<span class="string">&#x27;target&#x27;</span>):getValue()</span><br><span class="line">        <span class="keyword">local</span> nodeType = nodeAttr:getChildByName(<span class="string">&#x27;type&#x27;</span>):getValue()</span><br><span class="line">        <span class="comment">--print(nodeName, nodeTarget, nodeType)</span></span><br><span class="line">        <span class="keyword">if</span> nodeTarget == <span class="string">&#x27;usd&#x27;</span> <span class="keyword">then</span></span><br><span class="line">            Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.target&#x27;</span>, StringAttribute(<span class="string">&#x27;arnold&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> nodeType == <span class="string">&#x27;UsdPreviewSurface&#x27;</span> <span class="keyword">then</span></span><br><span class="line">                Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.type&#x27;</span>, StringAttribute(<span class="string">&#x27;standard_surface&#x27;</span>))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> diffuseColorParamAttr = nodeAttr:getChildByName(<span class="string">&#x27;parameters.diffuseColor&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> diffuseColorParamAttr ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> diffuseColorValue = diffuseColorParamAttr:getNearestSample(<span class="number">0</span>)</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.base_color&#x27;</span>, FloatAttribute(diffuseColorValue))</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">local</span> diffuseColorConnectAttr = nodeAttr:getChildByName(<span class="string">&#x27;connections.diffuseColor&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> diffuseColorConnectAttr ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> diffuseColorConnect = diffuseColorConnectAttr:getValue()</span><br><span class="line">                    <span class="keyword">local</span> baseColorConnect = pystring.replace(diffuseColorConnect, <span class="string">&#x27;rgb&#x27;</span>, <span class="string">&#x27;out&#x27;</span>)</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.connections.base_color&#x27;</span>, StringAttribute(baseColorConnect))</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> specularColorParamAttr = nodeAttr:getChildByName(<span class="string">&#x27;parameters.specularColor&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> specularColorParamAttr ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> specularColorValue = specularColorParamAttr:getNearestSample(<span class="number">0</span>)</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.specular_color&#x27;</span>, FloatAttribute(specularColorValue))</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.specular_color&#x27;</span>, FloatAttribute(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, <span class="number">3</span>))</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> roughnessParamAttr = nodeAttr:getChildByName(<span class="string">&#x27;parameters.roughness&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> roughnessParamAttr ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> roughnessValue = roughnessParamAttr:getValue()</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.specular_roughness&#x27;</span>, FloatAttribute(roughnessValue))</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.specular_roughness&#x27;</span>, FloatAttribute(<span class="number">0.5</span>))</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> opacityParamAttr = nodeAttr:getChildByName(<span class="string">&#x27;parameters.opacity&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> opacityParamAttr ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> opacityValue = opacityParamAttr:getValue()</span><br><span class="line">                    Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.opacity&#x27;</span>, FloatAttribute(&#123;opacityValue, opacityValue, opacityValue&#125;, <span class="number">3</span>))</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> nodeType == <span class="string">&#x27;UsdUVTexture&#x27;</span> <span class="keyword">then</span></span><br><span class="line">                Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.type&#x27;</span>, StringAttribute(<span class="string">&#x27;image&#x27;</span>))</span><br><span class="line">                <span class="keyword">local</span> filestring = nodeAttr:getChildByName(<span class="string">&#x27;parameters.file&#x27;</span>):getValue()</span><br><span class="line">                Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.parameters.filename&#x27;</span>, StringAttribute(filestring))</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> nodeType == <span class="string">&#x27;UsdPrimvarReader_float2&#x27;</span> <span class="keyword">then</span></span><br><span class="line">                Interface.SetAttr(<span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName .. <span class="string">&#x27;.type&#x27;</span>, StringAttribute(<span class="string">&#x27;user_data_rgba&#x27;</span>))</span><br><span class="line">                <span class="comment">--local filestring = nodeAttr:getChildByName(&#x27;parameters.file&#x27;):getValue()</span></span><br><span class="line">                <span class="comment">--Interface.SetAttr(&#x27;material.nodes.&#x27; .. nodeName .. &#x27;.parameters.filename&#x27;, StringAttribute(filestring))</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure>

<h2 id="3-强行转换Arnold-standard-surface材质为ambient-occlusion，以获取带有颜色的AO材质"><a href="#3-强行转换Arnold-standard-surface材质为ambient-occlusion，以获取带有颜色的AO材质" class="headerlink" title="3.强行转换Arnold standard_surface材质为ambient_occlusion，以获取带有颜色的AO材质"></a>3.强行转换Arnold standard_surface材质为ambient_occlusion，以获取带有颜色的AO材质</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">This script can forced convert standard_surface to ambient_occlusion</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment"> /root/world//*&#123;attr(&quot;type&quot;) == &quot;material&quot;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">script:</span></span><br><span class="line"><span class="comment">local module = require(&#x27;prl_katana.mat.convertao&#x27;)</span></span><br><span class="line"><span class="comment">module.ConcertAO()</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.ConcertAO</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> matNodesAttr = Interface.GetAttr(<span class="string">&#x27;material.nodes&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matNodesAttr <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> count = matNodesAttr:getNumberOfChildren()</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, count <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> nodeAttr = matNodesAttr:getChildByIndex(i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeName = matNodesAttr:getChildName(i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> nodeTypeAttr = nodeAttr:getChildByName(<span class="string">&#x27;type&#x27;</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeTargetAttr = nodeAttr:getChildByName(<span class="string">&#x27;target&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> nodeType = nodeTypeAttr <span class="keyword">and</span> nodeTypeAttr:getValue() <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">local</span> nodeTarget = nodeTargetAttr <span class="keyword">and</span> nodeTargetAttr:getValue() <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nodeTarget == <span class="string">&#x27;arnold&#x27;</span> <span class="keyword">and</span> nodeType == <span class="string">&#x27;standard_surface&#x27;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> base = <span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName</span><br><span class="line">            Interface.SetAttr(base .. <span class="string">&#x27;.type&#x27;</span>, StringAttribute(<span class="string">&#x27;ambient_occlusion&#x27;</span>))</span><br><span class="line">            Interface.SetAttr(base .. <span class="string">&#x27;.target&#x27;</span>, StringAttribute(<span class="string">&#x27;arnold&#x27;</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">local</span> baseColorConnAttr = nodeAttr:getChildByName(<span class="string">&#x27;connections.base_color&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> baseColorConnAttr <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">local</span> src = baseColorConnAttr:getValue()</span><br><span class="line">                Interface.SetAttr(base .. <span class="string">&#x27;.connections.white&#x27;</span>, StringAttribute(src))</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">local</span> baseColorAttr = nodeAttr:getChildByName(<span class="string">&#x27;parameters.base_color&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> baseColorAttr <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> colorValue = baseColorAttr:getNearestSample(<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> colorValue <span class="keyword">and</span> #colorValue &gt;= <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">                        Interface.SetAttr(base .. <span class="string">&#x27;.parameters.white&#x27;</span>, FloatAttribute(colorValue, <span class="number">3</span>))</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure>

<h2 id="4-赋予的材质是否有效并添加标识以清除等操作"><a href="#4-赋予的材质是否有效并添加标识以清除等操作" class="headerlink" title="4.赋予的材质是否有效并添加标识以清除等操作"></a>4.赋予的材质是否有效并添加标识以清除等操作</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment">/root/world//*&#123;attr(&quot;type&quot;) == &quot;polymesh&quot;&#125;</span></span><br><span class="line"><span class="comment">/root/world//*&#123;attr(&quot;type&quot;) == &quot;subdmesh&quot;&#125;</span></span><br><span class="line"><span class="comment">/root/world//*&#123;attr(&quot;type&quot;) == &quot;mesh&quot;&#125;</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> matAttr = Interface.GetAttr(<span class="string">&quot;materialAssign&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> matAttr ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    matPath = matAttr:getValue()</span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">path</span> = Interface.GetOutputLocationPath()</span><br><span class="line">    <span class="keyword">local</span> type_name = Interface.GetAttr(<span class="string">&quot;type&quot;</span>,matPath)</span><br><span class="line">    <span class="keyword">if</span> type_name == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;---------------------------&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">path</span>)</span><br><span class="line">        <span class="built_in">print</span>(type_name)</span><br><span class="line">        <span class="built_in">print</span>(matPath)</span><br><span class="line">        Interface.SetAttr(<span class="string">&quot;user.mat_invalid&quot;</span>, StringAttribute(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="5-检查无效的模型层级并添加标识以清除等操作"><a href="#5-检查无效的模型层级并添加标识以清除等操作" class="headerlink" title="5.检查无效的模型层级并添加标识以清除等操作"></a>5.检查无效的模型层级并添加标识以清除等操作</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment">/root/world//*&#123;attr(&quot;type&quot;) == &quot;polymesh&quot;&#125;</span></span><br><span class="line"><span class="comment">/root/world//*&#123;attr(&quot;type&quot;) == &quot;subdmesh&quot;&#125;</span></span><br><span class="line"><span class="comment">/root/world//*&#123;attr(&quot;type&quot;) == &quot;mesh&quot;&#125;</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> Interface.GetAttr(<span class="string">&quot;geometry.point&quot;</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    Interface.SetAttr(<span class="string">&quot;user.to_delete&quot;</span>, StringAttribute(<span class="string">&quot;1&quot;</span>))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="6-为层级添加cryptomatte相关属性"><a href="#6-为层级添加cryptomatte相关属性" class="headerlink" title="6.为层级添加cryptomatte相关属性"></a>6.为层级添加cryptomatte相关属性</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment">/root/world/geo/World/asset//*&#123;attr(&quot;type&quot;) == &quot;component&quot;&#125;</span></span><br><span class="line"><span class="comment">/root/world//*&#123;hasattr(&quot;materialAssign&quot;)&#125;</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> op_path=Interface.GetRootLocationPath()</span><br><span class="line"><span class="keyword">local</span> asset_name = <span class="built_in">string</span>.<span class="built_in">match</span>(op_path, <span class="string">&quot;([^/]+)$&quot;</span>)</span><br><span class="line">Interface.SetAttr(<span class="string">&quot;geometry.arbitrary.crypto_asset.value&quot;</span>, StringAttribute(asset_name))</span><br><span class="line">Interface.SetAttr(<span class="string">&quot;geometry.arbitrary.crypto_asset.scope&quot;</span>, StringAttribute(<span class="string">&quot;primitive&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> surfShader = Interface.GetAttr(<span class="string">&#x27;materialAssign&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> surfShader <span class="keyword">then</span></span><br><span class="line">    Interface.SetAttr(<span class="string">&quot;geometry.arbitrary.crypto_material.scope&quot;</span>, StringAttribute(<span class="string">&quot;primitive&quot;</span>))</span><br><span class="line">    Interface.SetAttr(<span class="string">&#x27;geometry.arbitrary.crypto_material.value&#x27;</span>, surfShader  )</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="7-重新连接材质中断开的贴图节点"><a href="#7-重新连接材质中断开的贴图节点" class="headerlink" title="7.重新连接材质中断开的贴图节点"></a>7.重新连接材质中断开的贴图节点</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">This script can use the first tex connect shader color</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cel:</span></span><br><span class="line"><span class="comment"> /root/world//*&#123;@type == &quot;material&quot;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">script:</span></span><br><span class="line"><span class="comment">local module = require(&#x27;prl_katana.mat.texreconnect&#x27;)</span></span><br><span class="line"><span class="comment">module.Reconnect()</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.Reconnect</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> matNodesAttr = Interface.GetAttr(<span class="string">&#x27;material.nodes&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matNodesAttr <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> count = matNodesAttr:getNumberOfChildren()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> tex_nodeName = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">local</span> fallback_nodeName = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, count <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> nodeAttr = matNodesAttr:getChildByIndex(i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeName = matNodesAttr:getChildName(i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> nodeTypeAttr = nodeAttr:getChildByName(<span class="string">&#x27;type&#x27;</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeTargetAttr = nodeAttr:getChildByName(<span class="string">&#x27;target&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> nodeType = nodeTypeAttr <span class="keyword">and</span> nodeTypeAttr:getValue() <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">local</span> nodeTarget = nodeTargetAttr <span class="keyword">and</span> nodeTargetAttr:getValue() <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nodeTarget == <span class="string">&#x27;usd&#x27;</span> <span class="keyword">and</span> nodeType == <span class="string">&#x27;UsdUVTexture&#x27;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">string</span>.<span class="built_in">find</span>(nodeName, <span class="string">&#x27;file&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">                tex_nodeName = nodeName</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fallback_nodeName <span class="keyword">then</span></span><br><span class="line">                fallback_nodeName = nodeName</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tex_nodeName <span class="keyword">then</span></span><br><span class="line">        tex_nodeName = fallback_nodeName</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tex_nodeName <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, count <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> nodeAttr = matNodesAttr:getChildByIndex(i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeName = matNodesAttr:getChildName(i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> nodeTypeAttr = nodeAttr:getChildByName(<span class="string">&#x27;type&#x27;</span>)</span><br><span class="line">        <span class="keyword">local</span> nodeTargetAttr = nodeAttr:getChildByName(<span class="string">&#x27;target&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> nodeType = nodeTypeAttr <span class="keyword">and</span> nodeTypeAttr:getValue() <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">local</span> nodeTarget = nodeTargetAttr <span class="keyword">and</span> nodeTargetAttr:getValue() <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> nodeTarget == <span class="string">&#x27;usd&#x27;</span> <span class="keyword">and</span> nodeType == <span class="string">&#x27;UsdPreviewSurface&#x27;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> base = <span class="string">&#x27;material.nodes.&#x27;</span> .. nodeName</span><br><span class="line">            <span class="keyword">local</span> destAttrPath = base .. <span class="string">&#x27;.connections.diffuseColor&#x27;</span></span><br><span class="line">            Interface.SetAttr(destAttrPath, StringAttribute(<span class="string">&#x27;rgb@&#x27;</span> .. tex_nodeName))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/06/%E4%BD%BF%E7%94%A8%E5%90%AF%E5%8A%A8%E5%99%A8%E5%90%AF%E5%8A%A8maya%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E5%88%B0maya%E8%8F%9C%E5%8D%95%E6%A0%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/06/%E4%BD%BF%E7%94%A8%E5%90%AF%E5%8A%A8%E5%99%A8%E5%90%AF%E5%8A%A8maya%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E5%88%B0maya%E8%8F%9C%E5%8D%95%E6%A0%8F/" class="post-title-link" itemprop="url">使用启动器启动maya并添加自定义工具到maya菜单栏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-06 12:12:06" itemprop="dateCreated datePublished" datetime="2025-01-06T12:12:06+08:00">2025-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-10 15:37:11" itemprop="dateModified" datetime="2025-02-10T15:37:11+08:00">2025-02-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>要在 Maya 启动时加载 XML 文件中的子项到菜单栏，并通过点击这些菜单项来运行特定的代码，你可以通过 Maya 的 Python 脚本来实现。以下是一个基本的步骤指南：</p>
<h3 id="1-准备-XML-文件"><a href="#1-准备-XML-文件" class="headerlink" title="1. 准备 XML 文件"></a>1. 准备 XML 文件</h3><p>首先，你需要准备一个 XML 文件来存储菜单项和对应的代码。例如，你可以创建一个简单的 XML 文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;menu name=&quot;My Maya Tools&quot;&gt;</span><br><span class="line">    &lt;submenu name=&quot;Load Maya Tools&quot; icon=&quot;tool.svg&quot; type=&quot;command&quot;  mode=&quot;python&quot;</span><br><span class="line">             cmd=&quot;print(&#x27;11111111111111111&#x27;)&quot; /&gt;</span><br><span class="line">    &lt;submenu name= &quot;----------&quot; type=&quot;separator&quot;/&gt;</span><br><span class="line">    &lt;submenu name=&quot;Maya Tools Test&quot; icon=&quot;test.svg&quot; type=&quot;command&quot;  mode=&quot;python&quot;</span><br><span class="line">             cmd=&quot;from MAYA_TOOLS import test_tools;test_tools.run()&quot; /&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>

<p>这个 XML 文件包含三个菜单项，每个菜单项有 <code>name</code> 属性、<code>type</code>属性，分别定义了xml菜单项的名称和类型，对于特别的类型（command），在<code>mode</code>属性中定义使用的语言，<code>cmd</code>中调用代码。</p>
<h3 id="2-编写-Maya-启动脚本"><a href="#2-编写-Maya-启动脚本" class="headerlink" title="2. 编写 Maya 启动脚本"></a>2. 编写 Maya 启动脚本</h3><p>你需要编写一个 解析xml的脚本，并且在Maya 启动时运行脚本，在maya启动完成后动态地将这些菜单项添加到 Maya 菜单栏。</p>
<p>创建一个名为 <code>userSetup.py</code>的脚本，maya在启动时会自动运行该脚本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> maya.cmds <span class="keyword">as</span> cmds</span><br><span class="line"><span class="keyword">import</span> maya.utils <span class="keyword">as</span> utils</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gui_launcher</span>():</span><br><span class="line">    <span class="keyword">import</span> ui_start</span><br><span class="line">    ui_start.MayaStart().start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cmds.about(batch=<span class="literal">True</span>):</span><br><span class="line">    utils.executeDeferred(gui_launcher)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Maya Startup Script is running...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="3-配置-Maya-启动脚本"><a href="#3-配置-Maya-启动脚本" class="headerlink" title="3. 配置 Maya 启动脚本"></a>3. 配置 Maya 启动脚本</h3><p>将 <code>userSetup.py</code>所在的路径添加到 Maya 的启动路径中，确保 Maya 启动时执行该脚本。你可以通过bat配置maya环境并启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> MAYA_UI_LANGUAGE=en_US</span><br><span class="line"><span class="built_in">set</span> CURRENT_PATH=%~dp0</span><br><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (<span class="string">&quot;%CURRENT_PATH%..&quot;</span>) <span class="keyword">do</span> <span class="built_in">set</span> LAUNCHER_LOCATION=%%~<span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> MAYA_PIPELINE=%LAUNCHER_LOCATION%</span><br><span class="line"><span class="built_in">set</span> MAYA_STARTUP=%LAUNCHER_LOCATION%/MAYA_STARTUP</span><br><span class="line"><span class="built_in">set</span> MAYA_SCRIPTS=%MAYA_STARTUP%/scripts</span><br><span class="line"><span class="built_in">set</span> MAYA_SCRIPT_PATH=%MAYA_SCRIPTS%;%MAYA_SCRIPT_PATH%</span><br><span class="line"><span class="built_in">set</span> PYTHONPATH=%MAYA_SCRIPTS%;%MAYA_PIPELINE%;%PYTHONPATH%</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> MAYA_VERSION=2024</span><br><span class="line"><span class="built_in">set</span> MAYA_DIR=D:\Autodesk\Maya%MAYA_VERSION%</span><br><span class="line"><span class="string">&quot;%MAYA_DIR%\bin\maya.exe&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-运行效果"><a href="#4-运行效果" class="headerlink" title="4. 运行效果"></a>4. 运行效果</h3><p>当 通过bat启动Maya时，解析函数会读取指定的 XML 文件，并将其中的菜单项添加到 Maya 的菜单栏中。点击菜单项时，会执行对应的 Python 代码。</p>
<p>通过这种方法，你可以灵活地管理和动态加载菜单项及其对应的功能，而不需要每次修改代码文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/27/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/27/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Linux系统的基础操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-27 14:51:38" itemprop="dateCreated datePublished" datetime="2024-12-27T14:51:38+08:00">2024-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-15 16:49:03" itemprop="dateModified" datetime="2025-01-15T16:49:03+08:00">2025-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux （ Linux is not Unix）是一种自由和开放源码的类 UNIX 操作系统，在很多影视公司会使用Linux系统进行工作，所以掌握一些基本的Linux操作是很有必要的。</p>
<p>在Linux的桌面或者任何资源管理器空白处点击鼠标右键，选择”打开终端“。</p>
<img src="/2024/12/27/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/Snipaste_2024-12-27_15-29-21.png" class="" title="Snipaste_2024-12-27_15-29-21">

<p>会出现类似Windows的cmd界面的窗口，同样的，我们可以在这里输入Linux命令对系统进行操作。</p>
<img src="/2024/12/27/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/Snipaste_2024-12-27_15-30-09.png" class="" title="Snipaste_2024-12-27_15-30-09">

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="1-文件和目录操作"><a href="#1-文件和目录操作" class="headerlink" title="1. 文件和目录操作"></a>1. 文件和目录操作</h3><ul>
<li><p><code>ls</code>：列出当前目录中的文件和文件夹。</p>
<p><code>ls -l</code>：显示详细信息（包括权限、所有者、文件大小等）。</p>
<p><code>ls -a</code>：显示所有文件，包括隐藏文件（以点 <code>.</code> 开头的文件）。</p>
</li>
<li><p><code>cd</code>：改变目录。</p>
<p><code>cd /path/to/directory</code>：进入指定目录。</p>
<p><code>cd ..</code>：返回上一级目录。</p>
<p><code>cd ~</code>：返回用户的主目录。</p>
</li>
<li><p><code>pwd</code>：显示当前工作目录。</p>
</li>
<li><p><code>mkdir</code>：创建新目录。</p>
<p><code>mkdir new_directory</code>：创建名为 <code>new_directory</code> 的目录。</p>
</li>
<li><p><code>rmdir</code>：删除空目录。</p>
<p><code>rmdir directory</code>：删除名为 <code>directory</code> 的空目录。</p>
</li>
<li><p><code>rm</code>：删除文件或目录。</p>
<p><code>rm file_name</code>：删除文件。</p>
<p><code>rm -r directory_name</code>：递归删除目录及其内容。</p>
</li>
<li><p><code>cp</code>：复制文件或目录。</p>
<p><code>cp source_file destination_file</code>：复制文件。</p>
<p><code>cp -r source_directory destination_directory</code>：复制目录及其内容。</p>
</li>
<li><p><code>mv</code>：移动文件或目录，或重命名文件。</p>
<p><code>mv old_name new_name</code>：重命名文件。</p>
<p><code>mv file_name destination_directory</code>：将文件移动到指定目录。</p>
</li>
</ul>
<h3 id="2-文件内容查看和编辑"><a href="#2-文件内容查看和编辑" class="headerlink" title="2. 文件内容查看和编辑"></a>2. 文件内容查看和编辑</h3><ul>
<li><p><code>cat</code>：查看文件内容。</p>
<p><code>cat file_name</code>：显示文件内容。</p>
</li>
<li><p><code>more</code>：逐屏查看文件内容。</p>
<p><code>more file_name</code>：显示文件内容，每次显示一页。</p>
</li>
<li><p><code>less</code>：逐屏查看文件内容，支持向前和向后滚动。</p>
<p><code>less file_name</code>：查看文件内容。</p>
</li>
<li><p><code>head</code>：查看文件的前几行。</p>
<p><code>head -n 10 file_name</code>：显示文件的前 10 行。</p>
</li>
<li><p><code>tail</code>：查看文件的最后几行。</p>
<p><code>tail -n 10 file_name</code>：显示文件的最后 10 行。</p>
<p><code>tail -f file_name</code>：实时查看文件更新（如日志文件）。</p>
</li>
<li><p><code>nano</code>、<code>vim</code>、<code>vi</code>：编辑文件。</p>
<p><code>nano file_name</code>：使用 nano 编辑器打开文件。</p>
<p><code>vim file_name</code> 或 <code>vi file_name</code>：使用 Vim 或 Vi 编辑器打开文件。</p>
</li>
</ul>
<h3 id="3-系统信息和资源"><a href="#3-系统信息和资源" class="headerlink" title="3. 系统信息和资源"></a>3. 系统信息和资源</h3><ul>
<li><p><code>top</code>：查看系统的实时资源使用情况。</p>
</li>
<li><p><code>htop</code>：一个更为友好的 <code>top</code> 命令版本（需要安装）。</p>
</li>
<li><p><code>df</code>：显示磁盘空间使用情况。</p>
<p><code>df -h</code>：以可读性更强的方式显示磁盘空间（GB、MB等）。</p>
</li>
<li><p><code>du</code>：显示目录或文件的磁盘使用情况。</p>
<p><code>du -sh directory_name</code>：显示目录总的磁盘使用情况。</p>
</li>
<li><p><code>free</code>：查看系统内存使用情况。</p>
<p><code>free -h</code>：以易于理解的格式显示内存使用情况。</p>
</li>
<li><p><code>ps</code>：查看当前进程。</p>
<p><code>ps aux</code>：列出所有进程。</p>
</li>
<li><p><code>kill</code>：终止进程。</p>
<p><code>kill process_id</code>：终止指定进程。</p>
<p><code>kill -9 process_id</code>：强制终止进程。</p>
</li>
<li><p><code>uptime</code>：查看系统的运行时间和负载。</p>
</li>
<li><p><code>whoami</code>：显示当前用户。</p>
</li>
</ul>
<h3 id="4-网络管理"><a href="#4-网络管理" class="headerlink" title="4. 网络管理"></a>4. 网络管理</h3><ul>
<li><p><code>ping</code>：测试与目标主机的网络连接。</p>
<p><code>ping host_name_or_ip</code>：ping 一个主机或 IP 地址。</p>
</li>
<li><p><code>ifconfig</code>：查看或配置网络接口（较老的命令，现代 Linux 系统可能使用 <code>ip</code>）。</p>
<p><code>ifconfig</code>：查看网络接口信息。</p>
</li>
<li><p><code>ip</code>：更现代的网络管理命令，替代 <code>ifconfig</code>。</p>
<p><code>ip a</code>：查看网络接口的 IP 地址信息。</p>
</li>
<li><p><code>ssh</code>：远程连接到另一台 Linux 主机。</p>
<p><code>ssh root@192.168.194.108</code>：通过 SSH 登录远程主机。</p>
</li>
<li><p><code>scp</code>：安全地复制文件到远程主机。</p>
<p><code>scp file_name user@hostname_or_ip:/path/to/destination</code>：将文件复制到远程主机。</p>
</li>
</ul>
<h3 id="5-用户和权限管理"><a href="#5-用户和权限管理" class="headerlink" title="5. 用户和权限管理"></a>5. 用户和权限管理</h3><ul>
<li><p><code>useradd</code>：创建新用户。</p>
<p><code>useradd username</code>：创建一个名为 <code>username</code> 的新用户。</p>
</li>
<li><p><code>passwd</code>：设置或更改密码。</p>
<p><code>passwd username</code>：更改指定用户的密码。</p>
</li>
<li><p><code>chown</code>：改变文件或目录的所有者。</p>
<p><code>chown user:group file_name</code>：将文件的所有者更改为指定用户和组。</p>
</li>
<li><p><code>chmod</code>：改变文件或目录的权限。</p>
<p><code>chmod 755 file_name</code>：为文件设置权限。</p>
<p><code>chmod 777 file_name</code>：为用户设置所有权限。</p>
<p><code>chmod -R 755 directory_name</code>：递归更改目录的权限。</p>
<ul>
<li><p><code>chmod</code> 是用来修改文件权限的命令。</p>
</li>
<li><p>```<br>777</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">     是一个权限值，表示：</span><br><span class="line">  </span><br><span class="line">    - 第一个数字 `7`：文件所有者（用户）拥有读、写、执行的权限。</span><br><span class="line">    - 第二个数字 `7`：文件所属的组拥有读、写、执行的权限。</span><br><span class="line">    - 第三个数字 `7`：其他用户也拥有读、写、执行的权限。</span><br><span class="line">  </span><br><span class="line">  权限值是由三个数字组成，每个数字代表不同权限的组合：</span><br><span class="line">  </span><br><span class="line">  - `r`（读） = 4</span><br><span class="line">  - `w`（写） = 2</span><br><span class="line">  - `x`（执行） = 1</span><br><span class="line">  </span><br><span class="line">  将这些数字相加来设置权限：</span><br><span class="line">  </span><br><span class="line">  - `7` = `4 (r)` + `2 (w)` + `1 (x)`。</span><br><span class="line"></span><br><span class="line">### 6. 文件查找和搜索</span><br><span class="line"></span><br><span class="line">- `find`：查找文件或目录。</span><br><span class="line"></span><br><span class="line">  `find /path/to/directory -name &quot;file_name&quot;`：在指定目录下查找文件。</span><br><span class="line"></span><br><span class="line">- `grep`：在文件中搜索文本。</span><br><span class="line"></span><br><span class="line">  `grep &quot;search_text&quot; file_name`：查找文件中包含指定文本的行。</span><br><span class="line"></span><br><span class="line">- `locate`：查找文件（依赖于文件数据库，需要先执行 `updatedb`）。</span><br><span class="line"></span><br><span class="line">  `locate file_name`：查找文件。</span><br><span class="line"></span><br><span class="line">### 7. 压缩与解压</span><br><span class="line"></span><br><span class="line">- `tar`：打包和解压文件。</span><br><span class="line"></span><br><span class="line">  `tar -czvf archive.tar.gz directory_name`：将目录压缩为 `.tar.gz` 格式。</span><br><span class="line"></span><br><span class="line">  `tar -xzvf archive.tar.gz`：解压 `.tar.gz` 文件。</span><br><span class="line"></span><br><span class="line">- `zip` 和 `unzip`：压缩和解压 `.zip` 文件。</span><br><span class="line"></span><br><span class="line">  `zip archive.zip file_name`：压缩文件。</span><br><span class="line"></span><br><span class="line">  `unzip archive.zip`：解压 `.zip` 文件。</span><br><span class="line"></span><br><span class="line">### 9.切换root用户：</span><br><span class="line"></span><br><span class="line">在 Linux 中，`su` 命令用于切换用户身份。要以 root 用户身份登录，可以执行以下命令：</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">su root</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>这将提示你输入 root 用户的密码。如果密码正确，成功登录后，你将以 root 用户身份操作。需要注意的是，<code>su</code> 命令通常需要 root 用户的密码，而不是当前用户的密码。</p>
<ol>
<li><strong>输入密码</strong>：系统会提示你输入 root 用户的密码。</li>
<li><strong>切换到 root 用户</strong>：输入密码后，你将切换到 root 用户，终端提示符通常会变为 <code>#</code>，表示你以 root 用户身份操作。</li>
</ol>
<img src="/2024/12/27/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/Snipaste_2024-12-27_16-16-15.png" class="" title="Snipaste_2024-12-27_16-16-15">

<h3 id="10-安装库："><a href="#10-安装库：" class="headerlink" title="10.安装库："></a>10.安装库：</h3><p>在 Linux 中，可以执行以下命令进行安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install tcsh</span><br></pre></td></tr></table></figure>

<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>要在Linux上进行开发工作，Shell脚本是无法绕开的。Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。</p>
<h3 id="1-一个基本-Shell-脚本示例"><a href="#1-一个基本-Shell-脚本示例" class="headerlink" title="1. 一个基本 Shell 脚本示例"></a>1. 一个基本 Shell 脚本示例</h3><h4 id="脚本结构："><a href="#脚本结构：" class="headerlink" title="脚本结构："></a>脚本结构：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是一个简单的 Shell 脚本</span></span><br><span class="line"></span><br><span class="line">echo &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>#!/bin/bash</code> 是脚本的 shebang（约定的标记），告诉系统使用哪个解释器来执行脚本（在这个例子中是 <code>/bin/bash</code>）。</li>
<li><code>echo</code> 命令用于打印输出。</li>
</ul>
<h4 id="运行脚本："><a href="#运行脚本：" class="headerlink" title="运行脚本："></a>运行脚本：</h4><p>假设我们现在有一个叫做script.sh的脚本，我们想要运行他，只需要在Linux的终端中输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./script.sh</span><br></pre></td></tr></table></figure>

<p>或输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ./script.sh</span><br></pre></td></tr></table></figure>

<h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. <strong>注释</strong></h3><p>在 Shell 脚本中，注释是用 <code>#</code> 来表示的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是一个注释</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Shell-脚本中的变量和输入"><a href="#3-Shell-脚本中的变量和输入" class="headerlink" title="3. Shell 脚本中的变量和输入"></a>3. Shell 脚本中的变量和输入</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取用户输入并打印</span></span><br><span class="line"></span><br><span class="line">echo &quot;请输入你的名字:&quot;</span><br><span class="line">read name</span><br><span class="line">echo &quot;你好, $name!&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>read</code> 用来获取用户输入，并将输入值保存在变量中。</li>
<li>变量 <code>$name</code> 用来引用输入的值。</li>
</ul>
<h3 id="4-条件语句（if-else）"><a href="#4-条件语句（if-else）" class="headerlink" title="4. 条件语句（if-else）"></a>4. 条件语句（if-else）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断一个数字是否为正数、负数或零</span></span><br><span class="line"></span><br><span class="line">echo &quot;请输入一个数字:&quot;</span><br><span class="line">read number</span><br><span class="line"></span><br><span class="line">if [ $number -gt 0 ]; then</span><br><span class="line">  echo &quot;这是一个正数&quot;</span><br><span class="line">elif [ $number -lt 0 ]; then</span><br><span class="line">  echo &quot;这是一个负数&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;这是零&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-gt</code> 表示“大于”，<code>-lt</code> 表示“小于”，<code>-eq</code> 表示“等于”。</li>
<li><code>if</code>、<code>elif</code> 和 <code>else</code> 语句用于条件判断。</li>
</ul>
<h3 id="5-循环语句（for-while）"><a href="#5-循环语句（for-while）" class="headerlink" title="5. 循环语句（for, while）"></a>5. 循环语句（for, while）</h3><h4 id="for-循环："><a href="#for-循环：" class="headerlink" title="for 循环："></a><code>for</code> 循环：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 <span class="keyword">for</span> 循环打印 1 到 5</span></span><br><span class="line"></span><br><span class="line">for i in &#123;1..5&#125;</span><br><span class="line">do</span><br><span class="line">  echo &quot;数字是: $i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="while-循环："><a href="#while-循环：" class="headerlink" title="while 循环："></a><code>while</code> 循环：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 <span class="keyword">while</span> 循环打印 1 到 5</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">while [ $i -le 5 ]</span><br><span class="line">do</span><br><span class="line">  echo &quot;数字是: $i&quot;</span><br><span class="line">  ((i++))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="6-函数定义"><a href="#6-函数定义" class="headerlink" title="6. 函数定义"></a>6. 函数定义</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义一个函数并调用它</span></span><br><span class="line"></span><br><span class="line">greet() &#123;</span><br><span class="line">  echo &quot;你好, $1!&quot;  # $1 是传递给函数的第一个参数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;请输入你的名字:&quot;</span><br><span class="line">read name</span><br><span class="line">greet $name</span><br></pre></td></tr></table></figure>

<ul>
<li><code>greet</code> 函数接受一个参数 <code>$1</code>，并打印消息。</li>
</ul>
<h3 id="7-文件操作"><a href="#7-文件操作" class="headerlink" title="7. 文件操作"></a>7. 文件操作</h3><h4 id="创建文件并写入内容："><a href="#创建文件并写入内容：" class="headerlink" title="创建文件并写入内容："></a>创建文件并写入内容：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建文件并写入内容</span></span><br><span class="line"></span><br><span class="line">echo &quot;Hello, World!&quot; &gt; hello.txt</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&gt;</code> 用于将内容写入文件，如果文件已存在则覆盖。</li>
<li><code>&gt;&gt;</code> 用于将内容追加到文件。</li>
</ul>
<h4 id="读取文件内容："><a href="#读取文件内容：" class="headerlink" title="读取文件内容："></a>读取文件内容：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取文件内容并打印</span></span><br><span class="line"></span><br><span class="line">while IFS= read -r line</span><br><span class="line">do</span><br><span class="line">  echo &quot;$line&quot;</span><br><span class="line">done &lt; hello.txt</span><br></pre></td></tr></table></figure>

<ul>
<li><code>IFS</code> 用来指定分隔符，<code>read -r</code> 用于读取文件的每一行。</li>
</ul>
<h3 id="8-查找文件"><a href="#8-查找文件" class="headerlink" title="8. 查找文件"></a>8. 查找文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找当前目录下所有的 .txt 文件</span></span><br><span class="line"></span><br><span class="line">find . -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>find</code> 命令用于递归查找文件。<code>-name &quot;*.txt&quot;</code> 查找所有扩展名为 <code>.txt</code> 的文件。</li>
</ul>
<h3 id="9-执行系统命令"><a href="#9-执行系统命令" class="headerlink" title="9. 执行系统命令"></a>9. 执行系统命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示当前系统时间</span></span><br><span class="line"></span><br><span class="line">current_time=$(date)</span><br><span class="line">echo &quot;当前时间: $current_time&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$(command)</code> 用来执行命令并将结果存储到变量中。</li>
</ul>
<h3 id="10-错误处理"><a href="#10-错误处理" class="headerlink" title="10. 错误处理"></a>10. 错误处理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果某个命令失败，则打印错误信息</span></span><br><span class="line"></span><br><span class="line">echo &quot;请输入一个文件名:&quot;</span><br><span class="line">read filename</span><br><span class="line"></span><br><span class="line">if [ ! -f &quot;$filename&quot; ]; then</span><br><span class="line">  echo &quot;错误: 文件 &#x27;$filename&#x27; 不存在!&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;文件 &#x27;$filename&#x27; 存在!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[ ! -f &quot;$filename&quot; ]</code> 用于检查文件是否存在。</li>
</ul>
<h3 id="11-示例：一个简单的shell脚本"><a href="#11-示例：一个简单的shell脚本" class="headerlink" title="11.示例：一个简单的shell脚本"></a>11.示例：一个简单的shell脚本</h3><p>以下是一个shell脚本示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export APP_NAME=houdini_20.0.653</span><br><span class="line">export HOUDINI_VERSION=20.0.653</span><br><span class="line"></span><br><span class="line">exec /opt/hfs20.0.653/bin/houdini $@</span><br></pre></td></tr></table></figure>

<p>我们设置了两个环境变量，并启动了houdini。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%EF%BC%88bat%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%EF%BC%88bat%EF%BC%89/" class="post-title-link" itemprop="url">如何使用批处理脚本（bat）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-27 11:36:48 / 修改时间：14:32:28" itemprop="dateCreated datePublished" datetime="2024-12-27T11:36:48+08:00">2024-12-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>bat（批处理文件），在DOS和Windows（任意版本）系统中，bat文件是可执行文件，由一系列命令构成，其中可以包含对其他程序的调用。这个文件的每一行都是一条DOS命令（大部分时候就好像我们在DOS提示符下执行的命令行一样），你可以使用DOS下的Edit或者Windows的记事本等任何文本文件编辑工具创建和修改批处理该类型的文件。</p>
<p>批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理，是一种简化的脚本语言，它的扩展名为bat 或cmd。比较常见的批处理包含两类：DOS批处理和PS批处理。PS批处理是基于强大的图片编辑软件Photoshop的，用来批量处理图片的脚本；而DOS批处理则是基于DOS命令的，用来自动地批量地执行DOS命令以实现特定操作的脚本。更复杂的情况，需要使用if、for、goto等命令控制程序的运行过程，如同C、Basic等高级语言一样。如果需要实现更复杂的应用，利用外部程序是必要的，这包括系统本身提供的外部命令和第三方提供的工具或者软件。批处理程序虽然是在命令行环境中运行，但不仅仅能使用命令行软件，任何当前系统下可运行的程序都可以放在批处理文件中运行。</p>
<p>对于TD/TA工作者来说，bat的编写是一项基本技能，工作中需要经常使用到bat来配置环境并且对DCC软件进行启动，下面对bat脚本进行介绍。</p>
<h2 id="基本语法和常用命令"><a href="#基本语法和常用命令" class="headerlink" title="基本语法和常用命令"></a>基本语法和常用命令</h2><h3 id="1-常用命令汇总"><a href="#1-常用命令汇总" class="headerlink" title="1.常用命令汇总"></a>1.常用命令汇总</h3><ul>
<li><code>echo</code>: 显示消息</li>
<li><code>dir</code>: 列出目录内容</li>
<li><code>cd</code>: 更改目录</li>
<li><code>del</code>: 删除文件</li>
<li><code>copy</code>: 复制文件</li>
<li><code>move</code>: 移动文件</li>
<li><code>set</code>: 设置环境变量</li>
<li><code>start</code>: 启动程序</li>
<li><code>pause</code>: 暂停</li>
<li><code>exit</code>: 退出脚本</li>
</ul>
<h3 id="2-回显"><a href="#2-回显" class="headerlink" title="2.回显"></a>2.回显</h3><p>在 Batch 文件中，<code>@</code> 符号用于禁止命令回显。通常，Batch 文件中的每一行命令执行时，命令本身都会被显示在命令行窗口中，除非你使用 <code>@echo off</code> 来禁止回显。具体来说：</p>
<h4 id="1-echo-off"><a href="#1-echo-off" class="headerlink" title="1.@echo off"></a>1.<code>@echo off</code></h4><p><code>@echo off</code> 是 Batch 文件中的常见用法。它用于禁用所有命令本身的回显，也就是不显示脚本执行的命令，在此后的所有命令都不会进行回显。通常放在 Batch 文件的开头，目的是让整个脚本在执行时不会显示命令</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br></pre></td></tr></table></figure>

<p>这条命令会让 Batch 文件在执行时不显示任何命令，只显示输出结果。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2.@"></a>2.<code>@</code></h4><p>在 <code>@echo off</code> 之外，<code>@</code> 可以加在任何命令的前面，来阻止该条命令的回显。例如：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> Hello, World!</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>@</code> 确保 <code>echo Hello, World!</code> 这一行命令不会被回显，只有它的输出会被显示。</p>
<h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. <strong>注释</strong></h3><p>在 Batch 文件中，注释是用 <code>REM</code> 或 <code>::</code> 来表示的：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">REM 这是一个注释</span></span><br><span class="line">:: 这也是注释</span><br></pre></td></tr></table></figure>

<h3 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. <strong>命令</strong></h3><p>Batch 文件的命令通常是 Windows 命令行命令（如 <code>echo</code>、<code>dir</code>、<code>del</code> 等）。每行一个命令：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> Hello, World!</span><br><span class="line"><span class="built_in">dir</span> C:\Users</span><br></pre></td></tr></table></figure>

<h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. <strong>变量</strong></h3><p>Batch 文件支持通过 <code>%</code> 访问变量。可以用 <code>set</code> 命令来定义变量：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> MY_VAR=Hello</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%MY_VAR%</span></span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>set</code> 读取和修改环境变量：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="built_in">PATH</span>=<span class="variable">%PATH%</span>;C:\MyProgram</span><br></pre></td></tr></table></figure>

<p><strong>特别注意，在设置变量时，<code>set</code> 命令中的等号两边不能有空格，空格会导致变量设置失败。</strong></p>
<h3 id="6-控制流"><a href="#6-控制流" class="headerlink" title="6. 控制流"></a>6. <strong>控制流</strong></h3><p>Batch 文件支持基本的控制流结构，如条件语句和循环。</p>
<ul>
<li><p><strong>条件判断（if）</strong>:</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">EXIST</span> &quot;file.txt&quot; (</span><br><span class="line">    <span class="built_in">echo</span> 文件存在</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">echo</span> 文件不存在</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>跳转（goto）</strong>: <code>goto</code> 用于跳转到文件中的指定标签（label）处：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> MyLabel</span><br><span class="line">:MyLabel</span><br><span class="line"><span class="built_in">echo</span> 这是标签后的代码</span><br></pre></td></tr></table></figure></li>
<li><p><strong>循环（for）</strong>: <code>for</code> 循环可以遍历文件、目录、数字等：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">%%i</span> <span class="keyword">in</span> (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">%%i</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a>7. <strong>错误处理</strong></h3><p>Batch 文件支持基本的错误处理，可以使用 <code>if errorlevel</code> 来检查上一条命令的返回值：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">errorlevel</span> <span class="number">1</span> (</span><br><span class="line">    <span class="built_in">echo</span> 发生错误</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>errorlevel</code> 返回值通常是 0 表示成功，非零值表示失败。</p>
<h3 id="8-输入和输出"><a href="#8-输入和输出" class="headerlink" title="8. 输入和输出"></a>8. <strong>输入和输出</strong></h3><ul>
<li><p><strong>输出（echo）</strong>: <code>echo</code> 用于输出信息到控制台：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> Hello, World!</span><br></pre></td></tr></table></figure></li>
<li><p><strong>输入（set /p）</strong>: <code>set /p</code> 用于从用户获取输入：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> /p USER_INPUT=请输入你的名字: </span><br><span class="line"><span class="built_in">echo</span> 你好, <span class="variable">%USER_INPUT%</span>！</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-文件操作"><a href="#9-文件操作" class="headerlink" title="9. 文件操作"></a>9. <strong>文件操作</strong></h3><p>Batch 文件可以进行常见的文件操作，如删除、复制、移动等：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">del</span> file.txt           # 删除文件</span><br><span class="line"><span class="built_in">copy</span> file.txt D:\backup\ # 复制文件</span><br><span class="line"><span class="built_in">move</span> file.txt D:\backup\ # 移动文件</span><br></pre></td></tr></table></figure>

<h3 id="10-暂停"><a href="#10-暂停" class="headerlink" title="10. 暂停"></a>10. <strong>暂停</strong></h3><p>使用 <code>pause</code> 命令来暂停脚本的执行，直到用户按下任意键：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<h3 id="11-启动外部程序"><a href="#11-启动外部程序" class="headerlink" title="11. 启动外部程序"></a>11. <strong>启动外部程序</strong></h3><p>Batch 文件可以启动外部程序或命令：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">start</span> &quot;notepad.exe&quot;</span><br><span class="line">：：或者</span><br><span class="line">&quot;notepad.exe&quot;</span><br></pre></td></tr></table></figure>

<h3 id="12-退出脚本"><a href="#12-退出脚本" class="headerlink" title="12. 退出脚本"></a>12. <strong>退出脚本</strong></h3><p><code>exit</code> 命令用于退出脚本：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>

<h3 id="13-批量处理命令输出"><a href="#13-批量处理命令输出" class="headerlink" title="13. 批量处理命令输出"></a>13. <strong>批量处理命令输出</strong></h3><p>通过重定向操作符 <code>&gt;</code> 或 <code>&gt;&gt;</code>，可以将命令的输出重定向到文件中：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> Hello, World! &gt; output.txt  # 覆盖写入</span><br><span class="line"><span class="built_in">echo</span> Another line &gt;&gt; output.txt  # 追加写入</span><br></pre></td></tr></table></figure>

<h3 id="14-使用命令行参数"><a href="#14-使用命令行参数" class="headerlink" title="14. 使用命令行参数"></a>14. <strong>使用命令行参数</strong></h3><p>Batch 文件支持命令行参数，通过 <code>%1</code>, <code>%2</code>, <code>%3</code> 等可以访问传递给脚本的参数。例如，<code>script.bat Hello World</code> 中，<code>%1</code> 会是 <code>Hello</code>，<code>%2</code> 会是 <code>World</code>：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> %<span class="number">1</span></span><br><span class="line"><span class="built_in">echo</span> %<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="15-示例：一个简单的-Batch-脚本"><a href="#15-示例：一个简单的-Batch-脚本" class="headerlink" title="15.示例：一个简单的 Batch 脚本"></a>15.示例：一个简单的 Batch 脚本</h3><p>以下是一个示例：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> add <span class="built_in">path</span></span><br><span class="line">:: <span class="built_in">set</span> MAYA_UI_LANGUAGE=en_US</span><br><span class="line"><span class="built_in">set</span> CURRENT_PATH=%~dp0</span><br><span class="line"><span class="keyword">for</span> <span class="variable">%%i</span> <span class="keyword">in</span> (&quot;<span class="variable">%CURRENT_PATH%</span>..&quot;) <span class="keyword">do</span> <span class="built_in">set</span> MAYA_LOCATION=<span class="variable">%%~</span>fi</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%MAYA_LOCATION%</span></span><br><span class="line"><span class="built_in">echo</span> launcher maya2024</span><br><span class="line"><span class="built_in">start</span> &quot;<span class="variable">%MAYA_LOCATION%</span>\bin\maya.exe&quot;</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<p>首先我们关闭了所有命令行的回显，然后输出”add path“，设置maya的ui语言但是对该行代码进行了注释（将不会生效），将当前bat文件的位置路径存储到变量<code>CURRENT_PATH</code>中，然后获取 <code>CURRENT_PATH</code> 上一级目录的完整路径，并将该路径赋值给 <code>MAYA_LOCATION</code>，随后对 <code>MAYA_LOCATION</code>的值进行输出，输出”launcher maya2024“提示，最后启动maya并保留命令行输出窗口。</p>
<h2 id="执行-Batch-文件"><a href="#执行-Batch-文件" class="headerlink" title="执行 Batch 文件"></a>执行 Batch 文件</h2><ol>
<li>将代码保存为 <code>.bat</code> 或 <code>.cmd</code> 文件。</li>
<li>双击文件，或者在cmd命令行中执行该文件。</li>
</ol>
<img src="/2024/12/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%EF%BC%88bat%EF%BC%89/image-20241227125834799.png" class="" title="image-20241227125834799">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/" class="post-title-link" itemprop="url">32-点阴影</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-03 18:25:21" itemprop="dateCreated datePublished" datetime="2024-12-03T18:25:21+08:00">2024-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-20 12:56:01" itemprop="dateModified" datetime="2024-12-20T12:56:01+08:00">2024-12-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目前为止我们学到了如何使用阴影贴图技术创建动态阴影。效果不错，但它只适合定向光，因为阴影只是在单一定向光源下生成的。所以它也叫定向阴影贴图，深度（阴影）贴图生成自定向光的视角。本节我们的焦点是在各种方向生成动态阴影，这个技术可以适用于点光源，生成所有方向上的阴影。这个技术叫做点光阴影，过去的名字是万向阴影贴图（omnidirectional shadow maps）技术。</p>
<p>本节代码基于前面的阴影贴图教程， 算法和定向阴影贴图差不多：我们从光的透视图生成一个深度贴图，基于当前fragment位置来对深度贴图采样，然后用储存的深度值和每个fragment进行对比，看看它是否在阴影中。定向阴影贴图和万向阴影贴图的主要不同在于深度贴图的使用上。对于深度贴图，我们需要从一个点光源的所有渲染场景，普通2D深度贴图不能工作；如果我们使用立方体贴图会怎样？因为立方体贴图可以储存6个面的环境数据，它可以将整个场景渲染到立方体贴图的每个面上，把它们当作点光源四周的深度值来采样。</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/point_shadows_diagram.png" class="" title="img">

<p>生成后的深度立方体贴图被传递到光照像素着色器，它会用一个方向向量来采样立方体贴图，从而得到当前的fragment的深度（从光的透视图）。大部分复杂的事情已经在阴影贴图教程中讨论过了。算法只是在深度立方体贴图生成上稍微复杂一点。</p>
<h2 id="生成深度立方体贴图"><a href="#生成深度立方体贴图" class="headerlink" title="生成深度立方体贴图"></a>生成深度立方体贴图</h2><p>为创建一个光周围的深度值的立方体贴图，我们必须渲染场景6次：每次一个面。显然渲染场景6次需要6个不同的视图矩阵，每次把一个不同的立方体贴图面附加到帧缓冲对象上。这看起来是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    GLuint face = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i;</span><br><span class="line">    <span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, face, depthCubemap, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">BindViewMatrix</span>(lightViewMatrices[i]);</span><br><span class="line">    <span class="built_in">RenderScene</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会很耗费性能因为一个深度贴图下需要进行很多渲染调用。我们将转而使用另外的一个小技巧来做这件事，几何着色器允许我们使用一次渲染过程来建立深度立方体贴图。</p>
<p>首先，我们需要创建一个立方体贴图：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint depthCubemap;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;depthCubemap);</span><br></pre></td></tr></table></figure>

<p>然后生成立方体贴图的每个面，将它们作为2D深度值纹理图像：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> GLuint SHADOW_WIDTH = <span class="number">1024</span>, SHADOW_HEIGHT = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, depthCubemap);</span><br><span class="line"><span class="keyword">for</span> (GLuint i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, <span class="number">0</span>, GL_DEPTH_COMPONENT, </span><br><span class="line">                     SHADOW_WIDTH, SHADOW_HEIGHT, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>不要忘记设置合适的纹理参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure>

<p>正常情况下，我们把立方体贴图纹理的一个面附加到帧缓冲对象上，渲染场景6次，每次将帧缓冲的深度缓冲目标改成不同立方体贴图面。由于我们将使用一个几何着色器，它允许我们把所有面在一个过程渲染，我们可以使用glFramebufferTexture直接把立方体贴图附加成帧缓冲的深度附件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glFramebufferTexture</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthCubemap, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glDrawBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glReadBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>还要记得调用glDrawBuffer和glReadBuffer：当生成一个深度立方体贴图时我们只关心深度值，所以我们必须显式告诉OpenGL这个帧缓冲对象不会渲染到一个颜色缓冲里。</p>
<p>万向阴影贴图有两个渲染阶段：首先我们生成深度贴图，然后我们正常使用深度贴图渲染，在场景中创建阴影。帧缓冲对象和立方体贴图的处理看起是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. first render to depth cubemap</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. then render scene as normal with shadow mapping (using depth cubemap)</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, depthCubemap);</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>

<p>这个过程和默认的阴影映射一样，尽管这次我们渲染和使用的是一个立方体贴图深度纹理，而不是2D深度纹理。在我们实际开始从光的视角的所有方向渲染场景之前，我们先得计算出合适的变换矩阵。</p>
<h3 id="光空间的变换"><a href="#光空间的变换" class="headerlink" title="光空间的变换"></a>光空间的变换</h3><p>设置了帧缓冲和立方体贴图，我们需要一些方法来将场景的所有几何体变换到6个光的方向中相应的光空间。与阴影贴图教程类似，我们需要一个光空间的变换矩阵T，但是这次是每个面都有一个。每个光空间的变换矩阵包含了投影和视图矩阵。对于投影矩阵来说，我们将使用一个透视投影矩阵；光源代表一个空间中的点，所以透视投影矩阵更有意义。每个光空间变换矩阵使用同样的投影矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLfloat aspect = (GLfloat)SHADOW_WIDTH/(GLfloat)SHADOW_HEIGHT;</span><br><span class="line">GLfloat near = <span class="number">1.0f</span>;</span><br><span class="line">GLfloat far = <span class="number">25.0f</span>;</span><br><span class="line">glm::mat4 shadowProj = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), aspect, near, far);</span><br></pre></td></tr></table></figure>

<p>非常重要的一点是，这里glm::perspective的视野参数，设置为90度。90度我们才能保证视野足够大到可以合适地填满立方体贴图的一个面，立方体贴图的所有面都能与其他面在边缘对齐。</p>
<p>因为投影矩阵在每个方向上并不会改变，我们可以在6个变换矩阵中重复使用。我们要为每个方向提供一个不同的视图矩阵。用glm::lookAt创建6个观察方向，每个都按顺序注视着立方体贴图的的一个方向：右、左、上、下、近、远：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;glm::mat4&gt; shadowTransforms;</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">-1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">-1.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>)));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">-1.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>)));</span><br></pre></td></tr></table></figure>

<p>这里我们创建了6个视图矩阵，把它们乘以投影矩阵，来得到6个不同的光空间变换矩阵。glm::lookAt的target参数是它注视的立方体贴图的面的一个方向。这些变换矩阵将会被发送到着色器渲染到立方体贴图里。</p>
<h3 id="深度着色器"><a href="#深度着色器" class="headerlink" title="深度着色器"></a>深度着色器</h3><p>为了把值渲染到深度立方体贴图，我们将需要3个着色器：顶点和像素着色器，以及一个它们之间的几何着色器。几何着色器是负责将所有世界空间的顶点变换到6个不同的光空间的着色器。因此顶点着色器简单地将顶点变换到世界空间，然后直接发送到几何着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = model * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着几何着色器以3个三角形的顶点作为输入，它还有一个光空间变换矩阵的uniform数组。几何着色器接下来会负责将顶点变换到光空间。几何着色器有一个内建变量叫做gl_Layer，它指定发散出基本图形送到立方体贴图的哪个面。当不管它时，几何着色器就会像往常一样把它的基本图形发送到输送管道的下一阶段，但当我们更新这个变量就能控制每个基本图形将渲染到立方体贴图的哪一个面。当然这只有当我们有了一个附加到激活的帧缓冲的立方体贴图纹理才有效：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (triangles) in;</span><br><span class="line"><span class="built_in">layout</span> (triangle_strip, max_vertices=<span class="number">18</span>) out;</span><br><span class="line"></span><br><span class="line">uniform mat4 shadowMatrices[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">out vec4 FragPos; <span class="comment">// FragPos from GS (output per emitvertex)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> face = <span class="number">0</span>; face &lt; <span class="number">6</span>; ++face)</span><br><span class="line">    &#123;</span><br><span class="line">        gl_Layer = face; <span class="comment">// built-in variable that specifies to which face we render.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) <span class="comment">// for each triangle&#x27;s vertices</span></span><br><span class="line">        &#123;</span><br><span class="line">            FragPos = gl_in[i].gl_Position;</span><br><span class="line">            gl_Position = shadowMatrices[face] * FragPos;</span><br><span class="line">            <span class="built_in">EmitVertex</span>();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">EndPrimitive</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几何着色器相对简单。我们输入一个三角形，输出总共6个三角形（6*3顶点，所以总共18个顶点）。在main函数中，我们遍历立方体贴图的6个面，我们每个面指定为一个输出面，把这个面的interger（整数）存到gl_Layer。然后，我们通过把面的光空间变换矩阵乘以FragPos，将每个世界空间顶点变换到相关的光空间，生成每个三角形。注意，我们还要将最后的FragPos变量发送给像素着色器，我们需要计算一个深度值。在之前的教程中，我们使用的是一个空的像素着色器，让OpenGL配置深度贴图的深度值。但这次我们将计算自己的深度，这个深度就是每个fragment位置和光源位置之间的线性距离。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">in vec4 FragPos;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform <span class="type">float</span> far_plane;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get distance between fragment and light source</span></span><br><span class="line">    <span class="type">float</span> lightDistance = <span class="built_in">length</span>(FragPos.xyz - lightPos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map to [0;1] range by dividing by far_plane</span></span><br><span class="line">    lightDistance = lightDistance / far_plane;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write this as modified depth</span></span><br><span class="line">    gl_FragDepth = lightDistance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像素着色器将来自几何着色器的片段位置、光的位置向量和视锥的远平面值作为输入。这里我们把片段和光源之间的距离，映射到0到1的范围，把它写入为fragment的深度值。使用这些着色器渲染场景，立方体贴图附加的帧缓冲对象激活以后，你会得到一个完全填充的深度立方体贴图，以便于进行第二阶段的阴影计算。</p>
<h2 id="万向阴影贴图"><a href="#万向阴影贴图" class="headerlink" title="万向阴影贴图"></a>万向阴影贴图</h2><p>所有事情都做好了，是时候来渲染万向阴影(Omnidirectional Shadow)了。这个过程和定向阴影贴图教程相似，尽管这次我们绑定的深度贴图是一个立方体贴图，而不是2D纹理，并且将光的投影的远平面发送给了着色器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">shader.<span class="built_in">Use</span>();  </span><br><span class="line"><span class="comment">// ... send uniforms to shader (including light&#x27;s far_plane value)</span></span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, depthCubemap);</span><br><span class="line"><span class="comment">// ... bind other textures</span></span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>

<p>这里的renderScene函数在一个大立方体房间中渲染一些立方体，它们散落在大立方体各处，光源在场景中央。顶点着色器和像素着色器和原来的阴影贴图着色器大部分都一样：不同之处是在光空间中像素着色器不再需要一个fragment位置，现在我们可以使用一个方向向量采样深度值。因为这个顶点着色器不再需要将他的位置向量变换到光空间，所以我们可以去掉FragPosLightSpace变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 texCoords;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">    vs_out.FragPos = <span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>));</span><br><span class="line">    vs_out.Normal = <span class="built_in">transpose</span>(<span class="built_in">inverse</span>(<span class="built_in">mat3</span>(model))) * normal;</span><br><span class="line">    vs_out.TexCoords = texCoords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器的Blinn-Phong光照代码和我们之前阴影相乘的结尾部分一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseTexture;</span><br><span class="line">uniform samplerCube depthMap;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line">uniform <span class="type">float</span> far_plane;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(diffuseTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    vec3 lightColor = <span class="built_in">vec3</span>(<span class="number">0.3</span>);</span><br><span class="line">    <span class="comment">// Ambient</span></span><br><span class="line">    vec3 ambient = <span class="number">0.3</span> * color;</span><br><span class="line">    <span class="comment">// Diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    <span class="comment">// Specular</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">64.0</span>);</span><br><span class="line">    vec3 specular = spec * lightColor;    </span><br><span class="line">    <span class="comment">// Calculate shadow</span></span><br><span class="line">    <span class="type">float</span> shadow = <span class="built_in">ShadowCalculation</span>(fs_in.FragPos);                      </span><br><span class="line">    vec3 lighting = (ambient + (<span class="number">1.0</span> - shadow) * (diffuse + specular)) * color;    </span><br><span class="line"></span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(lighting, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一些细微的不同：光照代码一样，但我们现在有了一个uniform变量samplerCube，shadowCalculation函数用片段的位置作为它的参数，取代了光空间的片段位置。我们现在还要引入光的视锥的远平面值，后面我们会需要它。像素着色器的最后，我们计算出阴影元素，当片段在阴影中时它是1.0，不在阴影中时是0.0。我们使用计算出来的阴影元素去影响光照的diffuse和specular元素。在ShadowCalculation函数中有很多不同之处，现在是从立方体贴图中进行采样，不再使用2D纹理了。</p>
<p>我们需要做的第一件事是获取立方体贴图的深度。我们已经将深度储存为片段和光位置之间的距离了，所以我们这里采用相似的处理方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 fragToLight = fragPos - lightPos; </span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight).r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们得到了片段的位置与光的位置之间的差向量，使用这个向量作为一个方向向量去对立方体贴图进行采样。方向向量不需要是单位向量，所以无需对它进行标准化。最后的closestDepth是光源和它最接近的可见片段之间的标准化的深度值。closestDepth值现在在0到1的范围内了，所以我们先将其转换回0到far_plane的范围，这需要把他乘以far_plane：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closestDepth *= far_plane;</span><br></pre></td></tr></table></figure>

<p>下一步我们获取当前fragment和光源之间的深度值，我们可以简单的使用fragToLight的长度来获取它，这取决于我们如何计算立方体贴图中的深度值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> currentDepth = <span class="built_in">length</span>(fragToLight);</span><br></pre></td></tr></table></figure>

<p>返回的是和closestDepth范围相同的深度值。</p>
<p>现在我们可以将两个深度值对比一下，看看哪一个更接近，以此决定当前的fragment是否在阴影当中。我们还要包含一个阴影偏移，才能避免阴影失真：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="number">0.05</span>; </span><br><span class="line"><span class="type">float</span> shadow = currentDepth -  bias &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>现在完整的ShadowCalculation现在变成了这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get vector between fragment position and light position</span></span><br><span class="line">    vec3 fragToLight = fragPos - lightPos;</span><br><span class="line">    <span class="comment">// Use the light to fragment vector to sample from the depth map    </span></span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight).r;</span><br><span class="line">    <span class="comment">// It is currently in linear range between [0,1]. Re-transform back to original value</span></span><br><span class="line">    closestDepth *= far_plane;</span><br><span class="line">    <span class="comment">// Now get current linear depth as the length between the fragment and light position</span></span><br><span class="line">    <span class="type">float</span> currentDepth = <span class="built_in">length</span>(fragToLight);</span><br><span class="line">    <span class="comment">// Now test for shadows</span></span><br><span class="line">    <span class="type">float</span> bias = <span class="number">0.05</span>; </span><br><span class="line">    <span class="type">float</span> shadow = currentDepth -  bias &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这些着色器，我们已经能得到非常好的阴影效果了，这次从一个点光源所有周围方向上都有阴影。有一个位于场景中心的点光源，看起来会像这样：</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/image-20241204122230684.png" class="" title="image-20241204122230684">

<p>在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/point_shadow.rar">这里</a>可以获取程序的完整代码</p>
<h3 id="显示立方体贴图深度缓冲"><a href="#显示立方体贴图深度缓冲" class="headerlink" title="显示立方体贴图深度缓冲"></a>显示立方体贴图深度缓冲</h3><p>如果要进行调试排错，将深度贴图显示出来以检查其是否正确。因为我们不再用2D深度贴图纹理，一个简单的把深度缓冲显示出来的技巧是，在ShadowCalculation函数中计算标准化的closestDepth变量，把变量显示，修改片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseTexture;</span><br><span class="line">uniform samplerCube depthMap;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line">uniform <span class="type">float</span> far_plane;</span><br><span class="line">uniform <span class="type">bool</span> shadows;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 fragToLight = fragPos - lightPos;</span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight).r;</span><br><span class="line">    closestDepth *= far_plane; </span><br><span class="line">    <span class="type">float</span> currentDepth = <span class="built_in">length</span>(fragToLight);</span><br><span class="line">    <span class="type">float</span> bias = <span class="number">0.05</span>;</span><br><span class="line">    <span class="type">float</span> shadow = currentDepth -  bias &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(diffuseTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    vec3 lightColor = <span class="built_in">vec3</span>(<span class="number">0.3</span>);</span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    vec3 ambient = <span class="number">0.3</span> * lightColor;</span><br><span class="line">    <span class="comment">// diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">64.0</span>);</span><br><span class="line">    vec3 specular = spec * lightColor;    </span><br><span class="line">    <span class="comment">// calculate shadow</span></span><br><span class="line">    <span class="comment">// float shadow = shadows ? ShadowCalculation(fs_in.FragPos) : 0.0;                      </span></span><br><span class="line">    <span class="comment">// vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;</span></span><br><span class="line">    vec3 fragToLight = fs_in.FragPos - lightPos;</span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight).r;</span><br><span class="line">    closestDepth *= far_plane; </span><br><span class="line">    </span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(<span class="built_in">vec3</span>(closestDepth / far_plane), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是一个灰度场景，每个颜色代表着场景的线性深度值：</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/image-20241204123534486.png" class="" title="image-20241204123534486">

<p>你可能也注意到了阴影部分在墙外。如果看起来和这个差不多，你就知道深度立方体贴图生成的没错。否则你可能做错了什么，也许是closestDepth仍然还在0到far_plane的范围。</p>
<h2 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h2><p>由于万向阴影贴图基于传统阴影贴图的原则，它便也继承了由解析度产生的非真实感。如果你放大就会看到锯齿边了。PCF（Percentage-closer filtering）允许我们通过对片段位置周围过滤多个样本，并对结果平均化。如果我们用和之前教程同样的那个简单的PCF过滤器，并加入第三个维度，就是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> bias = <span class="number">0.05</span>; </span><br><span class="line"><span class="type">float</span> samples = <span class="number">4.0</span>;</span><br><span class="line"><span class="type">float</span> offset = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">float</span> x = -offset; x &lt; offset; x += offset / (samples * <span class="number">0.5</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">float</span> y = -offset; y &lt; offset; y += offset / (samples * <span class="number">0.5</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">float</span> z = -offset; z &lt; offset; z += offset / (samples * <span class="number">0.5</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight + <span class="built_in">vec3</span>(x, y, z)).r; </span><br><span class="line">            closestDepth *= far_plane;   <span class="comment">// Undo mapping [0;1]</span></span><br><span class="line">            <span class="keyword">if</span>(currentDepth - bias &gt; closestDepth)</span><br><span class="line">                shadow += <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">shadow /= (samples * samples * samples);</span><br></pre></td></tr></table></figure>

<p>这段代码和我们传统的阴影贴图没有多少不同。这里我们根据样本的数量动态计算了纹理偏移量，我们在三个轴向采样三次，最后对子样本进行平均化。现在阴影看起来更加柔和平滑了，由此得到更加真实的效果：</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/image-20241204124224499.png" class="" title="image-20241204124224499">

<p>当samples设置为4.0，每个fragment我们会得到总共64个样本，这太多了！大多数这些采样都是多余的，与其在原始方向向量附近处采样，不如在采样方向向量的垂直方向进行采样更有意义。可是，并没有什么简单的方式能够指出哪一个子方向是多余的。可以使用一个技巧，用一个偏移量方向数组，它们差不多都是分开的，每一个指向完全不同的方向，剔除彼此接近的那些子方向。下面就是一个有着20个偏移方向的数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vec3 sampleOffsetDirections[<span class="number">20</span>] = vec3[]</span><br><span class="line">(</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">1</span>), </span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>, <span class="number">-1</span>),</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">0</span>), <span class="built_in">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">0</span>),</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">0</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">0</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">0</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>( <span class="number">0</span>,  <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>然后我们把PCF算法与从sampleOffsetDirections得到的样本数量进行适配，使用它们从立方体贴图里采样。这么做的好处是与之前的PCF算法相比，我们需要的样本数量变少了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec3 fragPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 fragToLight = fragPos - lightPos;</span><br><span class="line">    <span class="type">float</span> currentDepth = <span class="built_in">length</span>(fragToLight);</span><br><span class="line">    <span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">float</span> bias = <span class="number">0.15</span>;</span><br><span class="line">    <span class="type">int</span> samples = <span class="number">20</span>;</span><br><span class="line">    <span class="type">float</span> viewDistance = <span class="built_in">length</span>(viewPos - fragPos);</span><br><span class="line">    <span class="type">float</span> diskRadius = (<span class="number">1.0</span> + (viewDistance / far_plane)) / <span class="number">25.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; samples; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;</span><br><span class="line">        closestDepth *= far_plane;</span><br><span class="line">        <span class="keyword">if</span>(currentDepth - bias &gt; closestDepth)</span><br><span class="line">            shadow += <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    shadow /= <span class="built_in">float</span>(samples);  </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们把一个偏移量添加到指定的diskRadius中，它在fragToLight方向向量周围从立方体贴图里采样。另一个在这里可以应用的有意思的技巧是，我们可以基于观察者里一个fragment的距离来改变diskRadius；这样我们就能根据观察者的距离来增加偏移半径了，当距离更远的时候阴影更柔和，更近了就更锐利。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> diskRadius = (<span class="number">1.0</span> + (viewDistance / far_plane)) / <span class="number">25.0</span>;</span><br></pre></td></tr></table></figure>

<p>这是柔和的阴影效果：</p>
<img src="/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/image-20241217153523483.png" class="" title="image-20241217153523483">

<p>当然了，我们添加到每个样本的bias（偏移）高度依赖于上下文，总是要根据场景进行微调的。试试这些值，看看怎样影响了场景。<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/master/2024/12/03/32-%E7%82%B9%E9%98%B4%E5%BD%B1/point_shadow_soft.rar">这里</a>是最终的完整代码。</p>
<p>使用几何着色器来生成深度贴图不一定会比每个面渲染场景6次更快。使用几何着色器有它自己的性能局限，在第一个阶段使用它可能获得更好的性能表现。这取决于环境的类型，以及特定的显卡驱动等等，如果你很关心性能，就要确保对两种方法有大致了解，然后选择对你场景来说更高效的那个。使用几何着色器来进行阴影贴图的绘制的原因很简单，因为它们使用起来更简单。</p>
<h2 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a>附加资源</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.sunandblackcat.com/tipFullView.php?l=eng&topicid=36">Shadow Mapping for point light sources in OpenGL</a>：sunandblackcat的万向阴影贴图教程。</li>
<li><a target="_blank" rel="noopener" href="http://ogldev.atspace.co.uk/www/tutorial43/tutorial43.html">Multipass Shadow Mapping With Point Lights</a>：ogldev的万向阴影贴图教程。</li>
<li><a target="_blank" rel="noopener" href="http://www.cg.tuwien.ac.at/~husky/RTR/OmnidirShadows-whyCaps.pdf">Omni-directional Shadows</a>：Peter Houska的关于万向阴影贴图的一组很好的ppt。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/" class="post-title-link" itemprop="url">31-阴影贴图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-14 20:45:41" itemprop="dateCreated datePublished" datetime="2024-10-14T20:45:41+08:00">2024-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-03 17:52:25" itemprop="dateModified" datetime="2024-12-03T17:52:25+08:00">2024-12-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>阴影是光线被阻挡的结果；当一个光源的光线由于其他物体的阻挡不能够达到一个物体的表面的时候，那么这个物体就处在阴影中了。阴影能够使场景看起来真实得多，并且可以让观察者获得物体之间的空间位置关系，场景和物体的深度感能够得到极大提升。</p>
<p>阴影还是比较不好实现的，因为当前实时渲染领域还没找到一种完美的阴影算法。目前有几种近似阴影技术，但它们都有自己的缺点和不足，这是我们必须要考虑到的。视频游戏中较多使用的一种技术是阴影贴图（shadow mapping），效果不错，而且相对容易实现。阴影贴图并不难以理解，性能也不会太低，而且非常容易扩展成更高级的算法。</p>
<h2 id="阴影贴图"><a href="#阴影贴图" class="headerlink" title="阴影贴图"></a>阴影贴图</h2><p>阴影映射(Shadow Mapping)背后的思路非常简单：我们以光的位置为视角进行渲染，我们能看到的东西都将被点亮，看不见的一定是在阴影之中了。假设有一个地板，在光源和它之间有一个大盒子。由于光源处向光线方向看去，可以看到这个盒子，但看不到地板的一部分，这部分就应该在阴影中了。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_theory.png" class="" title="img">

<p>这里的所有蓝线代表光源可以看到的fragment。黑线代表被遮挡的fragment：它们应该渲染为带阴影的。如果我们绘制一条从光源出发，到达最右边盒子上的一个片段上的线段或射线，那么射线将先击中悬浮的盒子，随后才会到达最右侧的盒子。结果就是悬浮的盒子被照亮，而最右侧的盒子将处于阴影之中。</p>
<p>我们希望得到射线第一次击中的那个物体，然后用这个最近点和射线上其他点进行对比。然后我们将测试一下看看射线上的其他点是否比最近点更远，如果是的话，这个点就在阴影中。对从光源发出的射线上的成千上万个点进行遍历是个极端消耗性能的举措，实时渲染上基本不可取。我们可以采取相似举措，不用投射出光的射线，使用另一个非常熟悉的东西：深度缓冲。</p>
<p>在深度缓冲里的一个值是摄像机视角下，对应于一个片段的一个0到1之间的深度值。如果我们从光源的透视图来渲染场景，并把深度值的结果储存到纹理中。通过这种方式，我们就能对光源的透视图所见的最近的深度值进行采样。最终，深度值就会显示从光源的透视图下见到的第一个片段了。我们把储存在纹理中的所有这些深度值，叫做深度贴图（depth map）或阴影贴图。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_theory_spaces.png" class="" title="img">

<p>左侧的图片展示了一个定向光源（所有光线都是平行的）在立方体下的表面投射的阴影。通过储存到深度贴图中的深度值，我们就能找到最近点，用以决定片段是否在阴影中。我们使用一个来自光源的视图和投影矩阵来渲染场景就能创建一个深度贴图。这个投影和视图矩阵结合在一起成为一个<em><strong>T</strong></em>变换，它可以将任何三维位置转变到光源的可见坐标空间。</p>
<p><em>定向光并没有位置，因为它被规定为无穷远。然而，为了实现阴影贴图，我们得从一个光的透视图渲染场景，这样就得在光的方向的某一点上渲染场景。</em></p>
<p>在右边的图中我们显示出同样的平行光和观察者。我们渲染一个点P处的片段，需要决定它是否在阴影中。我们先得使用<em><strong>T</strong></em>把P变换到光源的坐标空间里。既然点P是从光的透视图中看到的，它的z坐标就对应于它的深度，例子中这个值是0.9。使用点P在光源的坐标空间的坐标，我们可以索引深度贴图，来获得从光的视角中最近的可见深度，结果是点C，最近的深度是0.4。因为索引深度贴图的结果是一个小于点P的深度，我们可以断定P被挡住了，它在阴影中了。</p>
<p>阴影映射由两个步骤组成：首先，我们渲染深度贴图，然后我们像往常一样渲染场景，使用生成的深度贴图来计算片段是否在阴影之中。</p>
<h3 id="深度贴图"><a href="#深度贴图" class="headerlink" title="深度贴图"></a>深度贴图</h3><p>第一步我们需要生成一张深度贴图(Depth Map)。深度贴图是从光的透视图里渲染的深度纹理，用它计算阴影。因为我们需要将场景的渲染结果储存到一个纹理中，所以我们需要再次用到帧缓冲。</p>
<p>首先，为渲染的深度贴图创建一个帧缓冲对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint depthMapFBO;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;depthMapFBO);</span><br></pre></td></tr></table></figure>

<p>然后，创建一个2D纹理，提供给帧缓冲的深度缓冲使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> GLuint SHADOW_WIDTH = <span class="number">1024</span>, SHADOW_HEIGHT = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">GLuint depthMap;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;depthMap);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, depthMap);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT, </span><br><span class="line">             SHADOW_WIDTH, SHADOW_HEIGHT, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br></pre></td></tr></table></figure>

<p>生成深度贴图不会太复杂。因为只关心深度值，所以把纹理格式指定为GL_DEPTH_COMPONENT，并且把纹理的高宽设置为1024：深度贴图的分辨率。把生成的深度纹理作为帧缓冲的深度缓冲：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glDrawBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glReadBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>我们需要的只是在从光的透视图下渲染场景的时候深度信息，所以颜色缓冲没有用。但是，不包含颜色缓冲的帧缓冲对象是不完整的，所以需要告诉OpenGL不适用任何颜色数据进行渲染。将调用glDrawBuffer和glReadBuffer把读和绘制缓冲设置为GL_NONE。合理配置将深度值渲染到纹理的帧缓冲后，就可以开始第一步了：生成深度贴图。两个步骤的完整的渲染阶段，看起来有点像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首选渲染深度贴图</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. 像之前一样渲染场景，但这次使用深度贴图</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, depthMap);</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>

<p>这段代码隐去了一些细节，但它表达了阴影映射的基本思路。这里一定要记得调用glViewport。因为阴影贴图经常和原来渲染的场景（通常是窗口分辨率）有着不同的分辨率，需要改变视口（viewport）的参数以适应阴影贴图的尺寸。如果我们忘了更新视口参数，最后的深度贴图要么太小要么就不完整。</p>
<h4 id="光源空间的变换"><a href="#光源空间的变换" class="headerlink" title="光源空间的变换"></a>光源空间的变换</h4><p>前面那段代码中一个不清楚的函数是<code>ConfigureShaderAndMatrices</code>。它是用来在第二个步骤确保为每个物体设置了合适的投影和视图矩阵，以及相关的模型矩阵。然而，第一个步骤中，我们从光的位置的视野下使用了不同的投影和视图矩阵来渲染的场景。</p>
<p>因为我们使用的是一个所有光线都平行的定向光。出于这个原因，我们将为光源使用正交投影矩阵，透视图将没有任何变形：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLfloat near_plane = <span class="number">1.0f</span>, far_plane = <span class="number">7.5f</span>;</span><br><span class="line">glm::mat4 lightProjection = glm::<span class="built_in">ortho</span>(<span class="number">-10.0f</span>, <span class="number">10.0f</span>, <span class="number">-10.0f</span>, <span class="number">10.0f</span>, near_plane, far_plane);</span><br></pre></td></tr></table></figure>

<p>这里有个本节教程的demo场景中使用的正交投影矩阵的例子。因为投影矩阵间接决定可视区域的范围，以及哪些东西不会被裁切，你需要保证投影视锥（frustum）的大小，以包含打算在深度贴图中包含的物体。当物体和片段不在深度贴图中时，它们就不会产生阴影。</p>
<p>为了创建一个视图矩阵来变换每个物体，把它们变换到从光源视角可见的空间中，我们将使用glm::lookAt函数；这次从光源的位置看向场景中央。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 lightView = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(<span class="number">-2.0f</span>, <span class="number">4.0f</span>, <span class="number">-1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>

<p>二者相结合为我们提供了一个光空间的变换矩阵，它将每个世界空间坐标变换到光源处所见到的那个空间；这正是我们渲染深度贴图所需要的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 lightSpaceMatrix = lightProjection * lightView;</span><br></pre></td></tr></table></figure>

<p>这个lightSpaceMatrix正是前面我们称为TT的那个变换矩阵。有了lightSpaceMatrix只要给shader提供光空间的投影和视图矩阵，我们就能像往常那样渲染场景了。然而，我们只关心深度值，并非所有片段计算都在我们的着色器中进行。为了提升性能，我们将使用一个与之不同但更为简单的着色器来渲染出深度贴图。</p>
<h4 id="渲染至深度贴图"><a href="#渲染至深度贴图" class="headerlink" title="渲染至深度贴图"></a>渲染至深度贴图</h4><p>当我们以光的透视图进行场景渲染的时候，会用一个比较简单的着色器，这个着色器把顶点变换到光空间。这个简单的着色器叫做<code>simpleDepthShader</code>，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"></span><br><span class="line">uniform mat4 lightSpaceMatrix;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = lightSpaceMatrix * model * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个顶点着色器将一个单独模型的一个顶点，使用lightSpaceMatrix变换到光空间中。由于我们没有颜色缓冲，最后的片段不需要任何处理，所以我们可以简单地使用一个空的片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="comment">// gl_FragDepth = gl_FragCoord.z;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个空的片段着色器什么也不干，运行完后，深度缓冲会被更新。可以取消那行的注释，来显式设置深度，但是这个（指注释掉那行之后）是更有效率的，因为底层无论如何都会默认去设置深度缓冲。渲染深度缓冲现在成了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">simpleDepthShader.<span class="built_in">Use</span>();</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(lightSpaceMatrixLocation, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(lightSpaceMatrix));</span><br><span class="line"></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">RenderScene</span>(simpleDepthShader);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>RenderScene函数的参数是一个着色器程序（shader program），它调用所有相关的绘制函数，并在需要的地方设置相应的模型矩阵。最后，在光的透视图视角下，很完美地用每个可见片段的最近深度填充了深度缓冲。通过将这个纹理投射到一个2D四边形上，就能在屏幕上显示出来，运行结果如下：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241118124001483.png" class="" title="image-20241118124001483">将深度贴图渲染到四边形上的片段着色器：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 color;</span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D depthMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="type">float</span> depthValue = <span class="built_in">texture</span>(depthMap, TexCoords).r;</span><br><span class="line">    color = <span class="built_in">vec4</span>(<span class="built_in">vec3</span>(depthValue), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是当用透视投影矩阵取代正交投影矩阵来显示深度时，有一些轻微的改动，因为使用透视投影时，深度是非线性的。</p>
<p>你可以在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/ec9d678b2e57eb1b487568cadc2bd46d4b8b2be3/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/41_shadow_mapping_depth.rar">这里</a>获得把场景渲染成深度贴图的源码。</p>
<h2 id="渲染阴影"><a href="#渲染阴影" class="headerlink" title="渲染阴影"></a>渲染阴影</h2><p>当正确地生成深度贴图后，我们就可以开始渲染阴影了。下面这段代码在片段着色器中执行，用来检验一个片段是否在阴影之中，不过我们在顶点着色器中进行光空间的变换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 texCoords;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec4 FragPosLightSpace;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 lightSpaceMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">    vs_out.FragPos = <span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(position, <span class="number">1.0</span>));</span><br><span class="line">    vs_out.Normal = <span class="built_in">transpose</span>(<span class="built_in">inverse</span>(<span class="built_in">mat3</span>(model))) * normal;</span><br><span class="line">    vs_out.TexCoords = texCoords;</span><br><span class="line">    vs_out.FragPosLightSpace = lightSpaceMatrix * <span class="built_in">vec4</span>(vs_out.FragPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加了一个新的输出向量FragPosLightSpace，用同一个lightSpaceMatrix，把世界空间顶点位置转换为光空间。顶点着色器传递一个普通的经变换的世界空间顶点位置vs_out.FragPos和一个光空间的vs_out.FragPosLightSpace给片段着色器。</p>
<p>片段着色器使用Blinn-Phong光照模型渲染场景。接着计算出一个shadow值，当fragment在阴影中时是1.0，在阴影外是0.0。然后，diffuse和specular颜色会乘以这个阴影元素。由于阴影不会是全黑的，所以我们把ambient分量从乘法中剔除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec4 FragPosLightSpace;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseTexture;</span><br><span class="line">uniform sampler2D shadowMap;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(diffuseTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    vec3 lightColor = <span class="built_in">vec3</span>(<span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// Ambient</span></span><br><span class="line">    vec3 ambient = <span class="number">0.15</span> * color;</span><br><span class="line">    <span class="comment">// Diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    <span class="comment">// Specular</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">64.0</span>);</span><br><span class="line">    vec3 specular = spec * lightColor;    </span><br><span class="line">    <span class="comment">// 计算阴影</span></span><br><span class="line">    <span class="type">float</span> shadow = <span class="built_in">ShadowCalculation</span>(fs_in.FragPosLightSpace);       </span><br><span class="line">    vec3 lighting = (ambient + (<span class="number">1.0</span> - shadow) * (diffuse + specular)) * color;    </span><br><span class="line"></span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(lighting, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器大部分是从高级光照教程中复制过来，只不过加上了个阴影计算。我们声明一个shadowCalculation函数，用它计算阴影。片段着色器的最后，我们把diffuse和specular乘以(1-阴影元素)，这表示这个片段有多大成分不在阴影中。这个片段着色器还需要两个额外输入，一个是光空间的片段位置和第一个渲染阶段得到的深度贴图。</p>
<p>首先要检查一个片段是否在阴影中，把光空间片段位置转换为裁切空间的标准化设备坐标。当我们在顶点着色器输出一个裁切空间顶点位置到gl_Position时，OpenGL自动进行一个透视除法，将裁切空间坐标的范围-w到w转为-1到1，这将x、y、z元素除以向量的w元素来实现。由于裁切空间的FragPosLightSpace并不会通过gl_Position传到片段着色器里，我们必须自己做透视除法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行透视除法</span></span><br><span class="line">    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数返回了片段在光空间的-1到1的范围。</p>
<p>当使用正交投影矩阵，顶点w元素仍保持不变，所以这一步实际上毫无意义。可是，当使用透视投影的时候就是必须的了，所以为了保证在两种投影矩阵下都有效就得留着这行代码。</p>
<p>因为来自深度贴图的深度在0到1的范围，我们也打算使用projCoords从深度贴图中去采样，所以将NDC坐标变换为0到1的范围。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<p>有了投影坐标，就能从深度贴图中采样得到0到1的结果，从第一个渲染阶段的projCoords坐标直接对应于变换过的NDC坐标。我们将得到光的位置视野下最近的深度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> closestDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy).r;</span><br></pre></td></tr></table></figure>

<p>为了得到片段的当前深度，获取投影向量的z坐标，它等于来自光的透视视角的片段的深度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> currentDepth = projCoords.z;</span><br></pre></td></tr></table></figure>

<p>实际的对比就是简单检查currentDepth是否高于closetDepth，如果是，那么片段就在阴影中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>完整的shadowCalculation函数是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行透视除法</span></span><br><span class="line">    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    <span class="comment">// 变换到[0,1]的范围</span></span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)</span></span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy).r; </span><br><span class="line">    <span class="comment">// 取得当前片段在光源视角下的深度</span></span><br><span class="line">    <span class="type">float</span> currentDepth = projCoords.z;</span><br><span class="line">    <span class="comment">// 检查当前片段是否在阴影中</span></span><br><span class="line">    <span class="type">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>激活这个着色器，绑定合适的纹理，激活第二个渲染阶段默认的投影以及视图矩阵，结果如下图所示：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241129162924357.png" class="" title="image-20241129162924357">

<p>如上图所示，你会看到地板和上有立方体的阴影。可以从<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/ec9d678b2e57eb1b487568cadc2bd46d4b8b2be3/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/42_render_shadow.rar">这里</a>找到demo程序的代码。</p>
<h2 id="改进阴影贴图"><a href="#改进阴影贴图" class="headerlink" title="改进阴影贴图"></a>改进阴影贴图</h2><p>我们现在成功让阴影贴图工作了，但是阴影贴图还是不够真实，接下来我们要尝试修复它。</p>
<h3 id="阴影失真"><a href="#阴影失真" class="headerlink" title="阴影失真"></a>阴影失真</h3><p>目前我们绘制的场景明显有不对的地方，放大看会发现明显的线条样式：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203153007456.png" class="" title="image-20241203153007456">

<p>我们可以看到地板四边形渲染出很大一块交替黑线。这种阴影贴图的不真实感叫做<strong>阴影失真</strong>(Shadow Acne)，下图解释了成因：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_acne_diagram.png" class="" title="img">

<p>因为阴影贴图受限于分辨率，在距离光源比较远的情况下，多个片段可能从深度贴图的同一个值中去采样。图片每个斜坡代表深度贴图一个单独的纹理像素。你可以看到，多个片段从同一个深度值进行采样。虽然很多时候没问题，但是当光源以一个角度朝向表面的时候就会出问题，这种情况下深度贴图也是从一个角度下进行渲染的。多个片段就会从同一个斜坡的深度纹理像素中采样，有些在地板上面，有些在地板下面；这样我们所得到的阴影就有了差异。因为这个，有些片段被认为是在阴影之中，有些不在，由此产生了图片中的条纹样式。</p>
<p>我们可以用一个叫做<strong>阴影偏移</strong>（shadow bias）的技巧来解决这个问题，我们简单的对表面的深度（或深度贴图）应用一个偏移量，这样片段就不会被错误地认为在表面之下了。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_acne_bias.png" class="" title="img">

<p>使用了偏移量后，所有采样点都获得了比表面深度更小的深度值，这样整个表面就正确地被照亮，没有任何阴影。在阴影贴图的片段着色器中可以使用下面的代码实现偏移：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="number">0.005</span>;</span><br><span class="line"><span class="type">float</span> shadow = currentDepth - bias &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>一个0.005的偏移就能有效解决这个问题，但是有些表面坡度很大，仍然会产生阴影失真。有一个更加可靠的办法能够根据表面朝向光线的角度更改偏移量，即使用点乘：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="built_in">max</span>(<span class="number">0.05</span> * (<span class="number">1.0</span> - <span class="built_in">dot</span>(normal, lightDir)), <span class="number">0.005</span>);</span><br><span class="line"><span class="type">float</span> shadow = currentDepth - bias &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>这里我们有一个偏移量的最大值0.05，和一个最小值0.005，它们是基于表面法线和光照方向的。这样像地板这样的表面几乎与光源垂直，得到的偏移就很小，而比如立方体的侧面这种表面得到的偏移就更大。下图展示了同一个场景，但使用了阴影偏移，效果的确更好：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203154054133.png" class="" title="image-20241203154054133">

<p>使用正确的偏移数值，在不同的场景中需要一些像这样的轻微调校，但大多情况下，实际上就是增加偏移量直到所有失真都被消除。</p>
<h3 id="悬浮"><a href="#悬浮" class="headerlink" title="悬浮"></a>悬浮</h3><p>使用阴影偏移的一个缺点是你对物体的实际深度应用了平移。偏移有可能足够大，以至于可以看出阴影相对实际物体位置的偏移，你可以从下图看到这个现象（这是一个夸张的偏移值）：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203154400331.png" class="" title="image-20241203154400331">

<p>这个阴影失真叫做悬浮(Peter Panning)，因为物体看起来悬浮在表面之上。我们可以使用一个叫技巧解决大部分的悬浮问题：当渲染深度贴图时候使用正面剔除，你也许记得在面剔除教程中OpenGL默认是背面剔除。但是现在我们要告诉OpenGL我们要剔除正面。</p>
<p>因为我们只需要深度贴图的深度值，对于实体物体无论我们用它们的正面还是背面都没问题。使用背面深度不会有错误，因为阴影在物体内部有错误我们也看不见。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_culling.png" class="" title="img">

<p>为了修复悬浮，我们要进行正面剔除，先必须开启GL_CULL_FACE：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glCullFace</span>(GL_FRONT);</span><br><span class="line"><span class="built_in">RenderSceneToDepthMap</span>();</span><br><span class="line"><span class="built_in">glCullFace</span>(GL_BACK); <span class="comment">// 不要忘记设回原先的culling face</span></span><br></pre></td></tr></table></figure>

<p>这十分有效地解决了悬浮的问题，但只对封闭的实体物体有效。在现在的场景中，在立方体上工作的很好，但在地板上无效，因为正面剔除完全移除了地板。地面是一个单独的平面，不会被完全剔除。如果打算使用这个技巧解决悬浮必须考虑到，只有剔除物体的正面才有意义。另一个要考虑到的地方是接近阴影的物体仍然会出现不正确的效果。必须考虑到何时使用正面剔除对物体才有意义。不过使用普通的偏移值通常就能避免悬浮。</p>
<h3 id="采样过多"><a href="#采样过多" class="headerlink" title="采样过多"></a>采样过多</h3><p>还有一个视觉差异，就是光的视锥不可见的区域一律被认为是处于阴影中，不管它是否真的处于阴影之中。出现这个状况是因为超出光的视锥的投影坐标比1.0大，这样采样的深度纹理就会超出他默认的0到1的范围。根据纹理环绕方式，我们将会得到不正确的深度结果，它不是基于真实的来自光源的深度值。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203164257058.png" class="" title="image-20241203164257058">

<p>可以在图中看到，光照有一个区域，超出该区域的就成为了阴影；这个区域实际上代表着深度贴图的大小，这个贴图投影到了地板上。发生这种情况的原因是，之前将深度贴图的环绕方式设置成了GL_REPEAT。我们宁可让所有超出深度贴图的坐标的深度范围是1.0，这样超出的坐标将永远不在阴影之中。我们可以储存一个边框颜色，然后把深度贴图的纹理环绕选项设置为GL_CLAMP_TO_BORDER：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">GLfloat borderColor[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line"><span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure>

<p>现在如果我们采样深度贴图0到1坐标范围以外的区域，纹理函数总会返回一个1.0的深度值，阴影值为0.0。现在仍有一部分是黑暗区域，那里的坐标超出了光的正交视锥的远平面。可以看到这片黑色区域总是出现在光源视锥的极远处。当一个点比光的远平面还要远时，它的投影坐标的z坐标大于1.0。这种情况下，GL_CLAMP_TO_BORDER环绕方式不起作用，因为把坐标的z元素和深度贴图的值进行了对比，它总是为大于1.0的z返回true。</p>
<p>解决这个问题也很简单，只要投影向量的z坐标大于1.0，我们就把shadow的值强制设为0.0，修改阴影贴图的片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="keyword">if</span>(projCoords.z &gt; <span class="number">1.0</span>)</span><br><span class="line">        shadow = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查远平面，并将深度贴图限制为一个手工指定的边界颜色，就能解决深度贴图采样超出的问题，最终会得到下图所示的效果：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203165556309.png" class="" title="image-20241203165556309">

<p>这些结果意味着，只有在深度贴图范围以内的被投影的fragment坐标才有阴影，所以任何超出范围的都将会没有阴影。由于在游戏中通常这只发生在远处，所以会比之前的那个明显的黑色区域效果更真实。</p>
<h2 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h2><p>阴影现在已经被绘制到场景中了，不过这仍不是我们想要的。如果你放大看阴影，阴影贴图对分辨率的依赖很快变得很明显。</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203165704357.png" class="" title="image-20241203165704357">

<p>因为深度贴图有一个固定的分辨率，多个片段对应于一个纹理像素。结果就是多个片段会从深度贴图的同一个深度值进行采样，这几个片段便得到的是同一个阴影，这就会导致产生锯齿。可以通过增加深度贴图的分辨率的方式来降低锯齿块，也可以尝试尽可能的让光的视锥接近场景。</p>
<p>另一个解决方案叫做PCF（percentage-closer filtering），这是一种多个不同过滤方式的组合，它产生柔和阴影，使它们出现更少的锯齿块和硬边。核心思想是从深度贴图中多次采样，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，就得到了柔和阴影。</p>
<p>一个简单的PCF的实现是简单的从纹理像素四周对深度贴图采样，然后把结果平均起来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line">vec2 texelSize = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(shadowMap, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-1</span>; x &lt;= <span class="number">1</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-1</span>; y &lt;= <span class="number">1</span>; ++y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> pcfDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy + <span class="built_in">vec2</span>(x, y) * texelSize).r; </span><br><span class="line">        shadow += currentDepth - bias &gt; pcfDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">shadow /= <span class="number">9.0</span>;</span><br></pre></td></tr></table></figure>

<p>textureSize返回vec2类型的采样器纹理的0级mipmap的宽和高。用1除以它返回一个单独纹理像素的大小，我们用以对纹理坐标进行偏移，确保每个新样本，来自不同的深度值。这里采样得到9个值，它们在投影坐标的x和y值的周围，为阴影阻挡进行测试，并最终通过样本的总数目将结果平均化。使用更多的样本，更改texelSize变量，你就可以增加阴影的柔和程度。下面你可以看到应用了PCF的阴影：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/image-20241203171805737.png" class="" title="image-20241203171805737">

<p>从稍微远一点的距离看去，阴影效果好多了，也不那么生硬了。如果你放大，仍会看到阴影贴图分辨率的不真实感，但通常对于大多数应用来说效果已经很好了。实际上PCF还有更多的内容，以及很多技术要点需要考虑以提升柔和阴影的效果，我们将留在以后讨论。</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/OSkirito/OSkirito.github.io/blob/ec9d678b2e57eb1b487568cadc2bd46d4b8b2be3/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/43_render_shadow_fix.rar">这里</a>可以获取修复了上述错误的完整代码。</p>
<h2 id="正交-vs-投影"><a href="#正交-vs-投影" class="headerlink" title="正交 vs 投影"></a>正交 vs 投影</h2><p>在渲染深度贴图的时候，正交(Orthographic)和投影(Projection)矩阵之间有所不同。正交投影矩阵并不会将场景用透视图进行变形，所有视线/光线都是平行的，这使它对于定向光来说是个很好的投影矩阵。然而透视投影矩阵，会将所有顶点根据透视关系进行变形，结果因此而不同。下图展示了两种投影方式所产生的不同阴影区域：</p>
<img src="/2024/10/14/31-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/shadow_mapping_projection.png" class="" title="img">

<p>透视投影对于光源来说更合理，不像定向光，它是有自己的位置的。透视投影因此更经常用在点光源和聚光灯上，而正交投影经常用在定向光上。</p>
<p>另一个细微差别是，透视投影矩阵，将深度缓冲视觉化经常会得到一个几乎全白的结果。发生这个是因为透视投影下，深度变成了非线性的深度值，它的大多数可辨范围都位于近平面附近。为了可以像使用正交投影一样合适地观察深度值，你必须先将非线性深度值转变为线性的，如我们在深度测试教程中已经讨论过的那样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 color;</span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D depthMap;</span><br><span class="line">uniform <span class="type">float</span> near_plane;</span><br><span class="line">uniform <span class="type">float</span> far_plane;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">LinearizeDepth</span><span class="params">(<span class="type">float</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> z = depth * <span class="number">2.0</span> - <span class="number">1.0</span>; <span class="comment">// Back to NDC </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2.0</span> * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="type">float</span> depthValue = <span class="built_in">texture</span>(depthMap, TexCoords).r;</span><br><span class="line">    color = <span class="built_in">vec4</span>(<span class="built_in">vec3</span>(<span class="built_in">LinearizeDepth</span>(depthValue) / far_plane), <span class="number">1.0</span>); <span class="comment">// perspective</span></span><br><span class="line">    <span class="comment">// color = vec4(vec3(depthValue), 1.0); // orthographic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个深度值与我们见到的用正交投影的很相似。需要注意的是，这个只适用于调试；正交或投影矩阵的深度检查仍然保持原样，因为相关的深度并没有改变。</p>
<h2 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a>附加资源</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">Tutorial 16 : Shadow mapping</a>：提供类似的阴影贴图教程，里面有一些额外的解释。</li>
<li><a target="_blank" rel="noopener" href="http://ogldev.atspace.co.uk/www/tutorial23/tutorial23.html">Shadow Mapping – Part 1：ogldev</a>：提供的另一个阴影贴图教程。</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=EsccgeUpdsM">How Shadow Mapping Works</a>：一个第三方YouTube视频教程，里面解释了阴影贴图及其实现。</li>
<li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324(v=vs.85).aspx">Common Techniques to Improve Shadow Depth Maps</a>：微软的一篇文章，其中列出了很多提升阴影贴图质量的技术。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OSkirito"
      src="/images/head_image.png">
  <p class="site-author-name" itemprop="name">OSkirito</p>
  <div class="site-description" itemprop="description">CG技术的记录与分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oskirito" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oskirito" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023 – 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OSkirito</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
