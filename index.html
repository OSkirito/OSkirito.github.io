<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CG技术的记录与分享">
<meta property="og:type" content="website">
<meta property="og:title" content="OS&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="OS&#39;s Blog">
<meta property="og:description" content="CG技术的记录与分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="OSkirito">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>OS's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OS's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">7</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/" class="post-title-link" itemprop="url">code中配置OpenGL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-21 10:48:13 / 修改时间：22:39:49" itemprop="dateCreated datePublished" datetime="2023-09-21T10:48:13+08:00">2023-09-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先下载[MinGW](<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/mingw/">MinGW - Minimalist GNU for Windows download | SourceForge.net</a>)</p>
<p>下载文件后解压，双击运行guimain.exe文件</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921105739503.png" class="" title="image-20230921105739503">

<p>安装下列三个文件并更新配置</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921110136828.png" class="" title="image-20230921110136828">

<p>安装完成后，将..\MinGW\bin添加到环境变量</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921110442456.png" class="" title="image-20230921110442456">

<p>在cmd中进行验证</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921110556502.png" class="" title="image-20230921110556502">

<p>将mingw32-make.exe创建副本重命名覆盖make.exe</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921112817561.png" class="" title="image-20230921112817561">

<p>在cmd中进行验证</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921113024702.png" class="" title="image-20230921113024702">

<p>打开VScode添加[C/C++](<a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C/C++ - Visual Studio Marketplace</a>)和[C/C++ Project Generator](<a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=danielpinto8zz6.c-cpp-project-generator">C/C++ Project Generator - Visual Studio Marketplace</a>)插件</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921151743776.png" class="" title="image-20230921151743776">

<p>创建一个文件夹，并在VScode中打开，按Ctrl+Shift+P创建C++项目</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921152238812.png" class="" title="image-20230921152238812">

<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921152259595.png" class="" title="image-20230921152259595">

<p>在控制台中验证能否正常运行</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921152417704.png" class="" title="image-20230921152417704">

<p>下载[GLFW](<a target="_blank" rel="noopener" href="https://www.glfw.org/download.html">Download | GLFW</a>)</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921153030075.png" class="" title="image-20230921153030075">

<p>下载完成后解压，将GLFW文件夹、.a文件、dll文件拷贝到创建工程的对应路径下</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921153233934.png" class="" title="image-20230921153233934">

<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921153335999.png" class="" title="image-20230921153335999">

<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921153541080.png" class="" title="image-20230921153541080">

<p>打开<a href="%5Bglad.dav1d.de%5D(https://glad.dav1d.de/)">glad</a>在线生成静态库，设置好相关参数点击生成，下载zip文件</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921154202377.png" class="" title="image-20230921154202377">

<p>解压文件，在该文件夹下运行cmd命令，生成对应的文件</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc ./src/glad.c -c -I ./include/</span><br><span class="line">ar -rc libglad.a glad.o</span><br></pre></td></tr></table></figure>

<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921154631866.png" class="" title="image-20230921154631866">

<p>将将GLFW文件夹、.a文件拷贝到创建工程的对应路径下</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921160808741.png" class="" title="image-20230921160808741">

<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921160950774.png" class="" title="image-20230921160950774">

<p>打开项目中的Makefile添加代码</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921223525495.png" class="" title="image-20230921223525495">

<p>在控制台进行验证</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921223602084.png" class="" title="image-20230921223602084">

<p>将下面的代码复制到main.cpp文件保存运行</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;glad/glad.h&gt;</span></span><br><span class="line"><span class="meta">#include &lt;GLFW/glfw3.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> framebuffer_size_callback(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height);</span><br><span class="line"><span class="type">void</span> processInput(GLFWwindow *window);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unsigned <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> unsigned <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	glfwInit();</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">	GLFWwindow *window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &quot;LearnOpenGL&quot;, NULL, NULL);</span><br><span class="line">	<span class="keyword">if</span> (window == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;</span><br><span class="line">		glfwTerminate();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line">	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">	&#123;</span><br><span class="line">        glClearColor(<span class="number">0.2</span>f, <span class="number">0.3</span>f, <span class="number">0.3</span>f, <span class="number">1.0</span>f);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">		processInput(window);</span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glfwTerminate();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> processInput(GLFWwindow *window)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">		glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> framebuffer_size_callback(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span><br><span class="line">&#123;</span><br><span class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如图所示，完成OpenGL的配置</p>
<img src="/2023/09/21/%E5%9C%A8VScode%E4%B8%AD%E9%85%8D%E7%BD%AEOpenGL/image-20230921223923694.png" class="" title="image-20230921223923694">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/" class="post-title-link" itemprop="url">在UE中创建可移动的NPC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-16 14:24:16" itemprop="dateCreated datePublished" datetime="2023-07-16T14:24:16+08:00">2023-07-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-21 22:49:59" itemprop="dateModified" datetime="2023-09-21T22:49:59+08:00">2023-09-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-使用蓝图"><a href="#1-使用蓝图" class="headerlink" title="1.使用蓝图"></a>1.使用蓝图</h1><p>添加一个导航网格边界体积（P可以显示或隐藏区域），缩放至场景大小，作为AI活动区域</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716151859891.png" class="" title="image-20230716151859891">

<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716152034761.png" class="" title="image-20230716152034761">

<p>项目设置中可设置导航网格的生成方式</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716152409439.png" class="" title="image-20230716152409439">

<p>选择人物蓝图类，并双击打开，删除所有的事件图表、变量、摄像机和弹簧臂组件</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716152638590.png" class="" title="image-20230716152638590">

<p>创建一个自定义事件，完成蓝图绘制<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716155158267.png" class="" title="image-20230716155158267"></p>
<p>将AI蓝图类放置到场景中，注：<strong>需要禁用自动控制</strong></p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716160155134.png" class="" title="image-20230716160155134">

<h1 id="2-使用AI行为树"><a href="#2-使用AI行为树" class="headerlink" title="2.使用AI行为树"></a>2.使用AI行为树</h1><h2 id="随机移动-追逐玩家"><a href="#随机移动-追逐玩家" class="headerlink" title="随机移动/追逐玩家"></a>随机移动/追逐玩家</h2><p>同上选择人物蓝图类，并双击打开，删除所有的事件图表、变量、摄像机和弹簧臂组件，创建人工智能黑板和行为树，创建AI控制器蓝图类</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716162102046.png" class="" title="image-20230716162102046">

<p>双击打开黑板，创建两个变量，一个为布尔类型的是否看到玩家、一个为向量类型的目标位置</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716162545221.png" class="" title="image-20230716162545221">

<p>打开AI角色蓝图类，指定AI控制器</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716162929094.png" class="" title="image-20230716162929094">

<p>打开AI控制器，添加一个AI感知组件，选中在细节面板中设置，添加AI视力配置设置属性，勾选检测中立方，为其添加目标感知更新时的事件，改变黑板中的值，注：<strong>文字命名必须和黑板中变量名一致</strong></p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716163253680.png" class="" title="image-20230716163253680">

<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716163953841.png" class="" title="image-20230716163953841">

<p>打开AI行为树，绘制大致流程</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716164134574.png" class="" title="image-20230716164134574">

<p>添加黑板装饰器</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716164724421.png" class="" title="image-20230716164724421">

<p>设置两个序列，二者优先级设置为一样</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716164901765.png" class="" title="image-20230716164901765">

<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716164925437.png" class="" title="image-20230716164925437">

<p>在行为树中新建一个任务，作为随机找点任务，重载接收执行AI函数，并完成蓝图绘制</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716165421300.png" class="" title="image-20230716165421300">

<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716165738726.png" class="" title="image-20230716165738726">

<p>继续完善AI行为树</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716165836741.png" class="" title="image-20230716165836741">

<p>更新AI控制器蓝图</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716170008133.png" class="" title="image-20230716170008133">

<p>再在AI行为树中新建一个任务，重载函数并完成蓝图绘制，作为寻找玩家任务</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716173041087.png" class="" title="image-20230716173041087">

<p>继续完善AI行为树</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716173115373.png" class="" title="image-20230716173115373">

<p>现在AI可以实现追踪玩家，但是可能被玩家甩开，现在实现AI一直朝向玩家,打开AI角色蓝图类，选中CharacterMovement，取消勾选将旋转朝向运动</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716173308029.png" class="" title="image-20230716173308029">

<p>选中AI角色蓝图类自身，勾选使用控制器旋转Yaw</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716173405036.png" class="" title="image-20230716173405036">

<p>回到寻找玩家任务蓝图，更新蓝图</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716180746203.png" class="" title="image-20230716180746203">

<p>回到随机找点蓝图，更新蓝图</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716173559037.png" class="" title="image-20230716173559037">

<h2 id="定点移动"><a href="#定点移动" class="headerlink" title="定点移动"></a>定点移动</h2><p>新建一个actor蓝图类，为其添加一个样条组件</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716182108398.png" class="" title="image-20230716182108398">

<p>将其拖入场景，选中点，按Alt移动进行样条线绘制</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716182313079.png" class="" title="image-20230716182313079">

<p>同上新建AI控制器、黑板、行为树，新建任务，新建一个int变量，完成蓝图绘制</p>
<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716183401440.png" class="" title="image-20230716183401440">

<img src="/2023/07/16/%E5%9C%A8UE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84NPC/image-20230716182617575.png" class="" title="image-20230716182617575">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/31/Maya%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%BC%A0%E5%8A%9B%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/Maya%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%BC%A0%E5%8A%9B%E5%9B%BE/" class="post-title-link" itemprop="url">Maya中创建并使用张力图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 17:16:44 / 修改时间：18:12:02" itemprop="dateCreated datePublished" datetime="2023-05-31T17:16:44+08:00">2023-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>张力图是反映模型表面张力变化的图，用于反映模型表面拉伸和挤压的变化，其原理是通过对比一个模型变化前后的面积，判断该处是拉伸还是挤压。</p>
<p>以下是相关代码（仅作学习分享，源代码地址：<a target="_blank" rel="noopener" href="https://github.com/wiremas/tension">GitHub - wiremas/tension: tension map node for Maya</a>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">This plugin was ported to python from C++,</span></span><br><span class="line"><span class="string">All credits by Anno Schachner</span></span><br><span class="line"><span class="string">original plugin is here https://github.com/wiremas/tension</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> maya.api.OpenMaya <span class="keyword">as</span> om2</span><br><span class="line"><span class="keyword">import</span> maya.OpenMaya <span class="keyword">as</span> om</span><br><span class="line"></span><br><span class="line">kPluginNodeName = <span class="string">&quot;tensionMap&quot;</span></span><br><span class="line">origAttrName = <span class="string">&quot;orig&quot;</span></span><br><span class="line">deformedAttrName = <span class="string">&#x27;deform&#x27;</span></span><br><span class="line">kPluginNodeClassify = <span class="string">&#x27;utility/general&#x27;</span></span><br><span class="line">kPluginNodeId = om2.MTypeId( <span class="number">0x86018</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maya_useNewAPI</span>():</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">aOrigShape = om2.MObject()</span><br><span class="line">aDeformedShape = om2.MObject()</span><br><span class="line">aOutShape = om2.MObject()</span><br><span class="line">aColorRamp = om2.MObject()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tensionMap</span>( om2.MPxNode ):</span><br><span class="line"></span><br><span class="line">	isDeformedDirty = <span class="literal">True</span></span><br><span class="line">	isOrigDirty = <span class="literal">True</span></span><br><span class="line">	origEdgeLenArray = []</span><br><span class="line">	deformedEdgeLenArray = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>):</span><br><span class="line">		om2.MPxNode.__init__( self )</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">initialize_ramp</span>(<span class="params"> self, parentNode, rampObj, index, position, value, interpolation </span>):</span><br><span class="line"></span><br><span class="line">		rampPlug = om2.MPlug( parentNode, rampObj )</span><br><span class="line">		elementPlug = rampPlug.elementByLogicalIndex(index)</span><br><span class="line">		positionPlug = elementPlug.child(<span class="number">0</span>)</span><br><span class="line">		positionPlug.setFloat(position)</span><br><span class="line">		valuePlug = elementPlug.child(<span class="number">1</span>)</span><br><span class="line">		valuePlug.child(<span class="number">0</span>).setFloat(value[<span class="number">0</span>])</span><br><span class="line">		valuePlug.child(<span class="number">1</span>).setFloat(value[<span class="number">1</span>])</span><br><span class="line">		valuePlug.child(<span class="number">2</span>).setFloat(value[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">		interpPlug = elementPlug.child(<span class="number">2</span>)</span><br><span class="line">		interpPlug.setInt(interpolation)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">postConstructor</span>(<span class="params"> self </span>):</span><br><span class="line">		self.initialize_ramp( self.thisMObject(), self.aColorRamp, <span class="number">0</span>, <span class="number">0.0</span>, om2.MColor( <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> ), <span class="number">1</span> )</span><br><span class="line">		self.initialize_ramp( self.thisMObject(), self.aColorRamp, <span class="number">1</span>, <span class="number">0.5</span>, om2.MColor( <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ), <span class="number">1</span> )</span><br><span class="line">		self.initialize_ramp( self.thisMObject(), self.aColorRamp, <span class="number">2</span>, <span class="number">1.0</span>, om2.MColor( <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> ), <span class="number">1</span> )</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">setDependentsDirty</span>(<span class="params"> self, dirtyPlug, affectedPlugs </span>):</span><br><span class="line">		<span class="keyword">if</span> dirtyPlug.partialName() == deformedAttrName:</span><br><span class="line">			self.isDeformedDirty = <span class="literal">True</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			self.isDeformedDirty = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> dirtyPlug.partialName() == origAttrName:</span><br><span class="line">			self.isOrigDirty = <span class="literal">True</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			self.isOrigDirty = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params"> self, plug, data </span>):</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> plug == self.aOutShape:</span><br><span class="line">			thisObj = self.thisMObject()</span><br><span class="line">			origHandle = data.inputValue( self.aOrigShape )</span><br><span class="line">			deformedHandle = data.inputValue( self.aDeformedShape )</span><br><span class="line">			outHandle = data.outputValue( self.aOutShape )</span><br><span class="line">			colorAttribute = om2.MRampAttribute( thisObj, self.aColorRamp )</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> self.isOrigDirty:</span><br><span class="line">				self.origEdgeLenArray = self.getEdgeLen( origHandle )</span><br><span class="line">			<span class="keyword">if</span> self.isDeformedDirty:</span><br><span class="line">				self.deformedEdgeLenArray = self.getEdgeLen( deformedHandle )</span><br><span class="line"></span><br><span class="line">			outHandle.copy( deformedHandle )</span><br><span class="line">			outHandle.setMObject( deformedHandle.asMesh() )</span><br><span class="line"></span><br><span class="line">			outMesh = outHandle.asMesh()</span><br><span class="line">			meshFn = om2.MFnMesh( outMesh )</span><br><span class="line">			numVerts = meshFn.numVertices</span><br><span class="line">			vertColors = om2.MColorArray()</span><br><span class="line">			vertIds = om2.MIntArray()</span><br><span class="line">			vertColors.setLength( numVerts )</span><br><span class="line">			vertIds.setLength( numVerts )</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> xrange(numVerts):</span><br><span class="line">				delta = <span class="number">0</span></span><br><span class="line">				vertColor = om2.MColor()</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(self.origEdgeLenArray) == <span class="built_in">len</span>(self.deformedEdgeLenArray):</span><br><span class="line">					delta = ( ( self.origEdgeLenArray[i] - self.deformedEdgeLenArray[i] ) / self.origEdgeLenArray[i] ) + <span class="number">0.5</span></span><br><span class="line">				<span class="keyword">else</span>:</span><br><span class="line">					delta = <span class="number">0.5</span></span><br><span class="line">				vertColor = colorAttribute.getValueAtPosition(delta)</span><br><span class="line">				vertColors.__setitem__(i, vertColor )</span><br><span class="line">				vertIds.__setitem__(i, i)</span><br><span class="line">			meshFn.setVertexColors( vertColors, vertIds )</span><br><span class="line">		data.setClean( plug )</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">getEdgeLen</span>(<span class="params"> self, meshHandle </span>):</span><br><span class="line">		edgeLenArray = []</span><br><span class="line"></span><br><span class="line">		meshObj = meshHandle.asMesh()</span><br><span class="line">		edgeIter = om2.MItMeshEdge( meshObj )</span><br><span class="line">		vertIter = om2.MItMeshVertex( meshObj )</span><br><span class="line">		<span class="keyword">while</span> <span class="keyword">not</span> vertIter.isDone():</span><br><span class="line">			lengthSum = <span class="number">0.0</span></span><br><span class="line">			connectedEdges = om2.MIntArray()</span><br><span class="line">			connectedEdges = vertIter.getConnectedEdges()</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> xrange( connectedEdges.__len__() ):</span><br><span class="line">				edgeIter.setIndex( connectedEdges[i] )</span><br><span class="line">				length = edgeIter.length(om2.MSpace.kWorld)</span><br><span class="line">				lengthSum += length * <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">			lengthSum = lengthSum / connectedEdges.__len__()</span><br><span class="line">			edgeLenArray.append( lengthSum )</span><br><span class="line">			vertIter.<span class="built_in">next</span>()</span><br><span class="line">		<span class="keyword">return</span> edgeLenArray</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nodeCreator</span>():</span><br><span class="line">	<span class="keyword">return</span> tensionMap()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>():</span><br><span class="line">	tAttr = om2.MFnTypedAttribute()</span><br><span class="line"></span><br><span class="line">	tensionMap.aOrigShape = tAttr.create( origAttrName, origAttrName, om2.MFnMeshData.kMesh )</span><br><span class="line">	tAttr.storable = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">	tensionMap.aDeformedShape = tAttr.create( deformedAttrName, deformedAttrName, om2.MFnMeshData.kMesh )</span><br><span class="line">	tAttr.storable = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">	tensionMap.aOutShape = tAttr.create( <span class="string">&quot;out&quot;</span>, <span class="string">&quot;out&quot;</span>, om2.MFnMeshData.kMesh )</span><br><span class="line">	tAttr.writable = <span class="literal">False</span></span><br><span class="line">	tAttr.storable = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">	tensionMap.aColorRamp = om2.MRampAttribute().createColorRamp(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;color&quot;</span>)</span><br><span class="line">	tensionMap.addAttribute( tensionMap.aOrigShape )</span><br><span class="line">	tensionMap.addAttribute( tensionMap.aDeformedShape )</span><br><span class="line">	tensionMap.addAttribute( tensionMap.aOutShape )</span><br><span class="line">	tensionMap.addAttribute( tensionMap.aColorRamp )</span><br><span class="line">	tensionMap.attributeAffects( tensionMap.aOrigShape, tensionMap.aOutShape )</span><br><span class="line">	tensionMap.attributeAffects( tensionMap.aDeformedShape, tensionMap.aOutShape )</span><br><span class="line">	tensionMap.attributeAffects( tensionMap.aColorRamp, tensionMap.aOutShape )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># AE template that put the main attributes into the main attribute section</span></span><br><span class="line"><span class="comment">#@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">AEtemplateString</span>(<span class="params">nodeName</span>):</span><br><span class="line">	templStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">	templStr += <span class="string">&#x27;global proc AE%sTemplate(string $nodeName)\n&#x27;</span> % nodeName</span><br><span class="line">	templStr += <span class="string">&#x27;&#123;\n&#x27;</span></span><br><span class="line">	templStr += <span class="string">&#x27;editorTemplate -beginScrollLayout;\n&#x27;</span></span><br><span class="line">	templStr += <span class="string">&#x27;	editorTemplate -beginLayout &quot;Color Remaping&quot; -collapse 0;\n&#x27;</span></span><br><span class="line">	templStr += <span class="string">&#x27;		AEaddRampControl( $nodeName + &quot;.color&quot; );\n&#x27;</span></span><br><span class="line">	templStr += <span class="string">&#x27;	editorTemplate -endLayout;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">	templStr += <span class="string">&#x27;editorTemplate -addExtraControls; // add any other attributes\n&#x27;</span></span><br><span class="line">	templStr += <span class="string">&#x27;editorTemplate -endScrollLayout;\n&#x27;</span></span><br><span class="line">	templStr += <span class="string">&#x27;&#125;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> templStr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initializePlugin</span>(<span class="params"> mobject </span>):</span><br><span class="line">	mplugin = om2.MFnPlugin( mobject )</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		mplugin.registerNode( kPluginNodeName, kPluginNodeId, nodeCreator, initialize )</span><br><span class="line">		om.MGlobal.executeCommand( AEtemplateString( kPluginNodeName ) )</span><br><span class="line">	<span class="keyword">except</span>:</span><br><span class="line">		sys.stderr.write( <span class="string">&quot;Failed to register node: &quot;</span> + kPluginNodeName )</span><br><span class="line">		<span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uninitializePlugin</span>(<span class="params">mobject</span>):</span><br><span class="line">	mplugin = om2.MFnPlugin( mobject )</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		mplugin.deregisterNode( kPluginNodeId )</span><br><span class="line">	<span class="keyword">except</span>:</span><br><span class="line">		sys.stderr.write( <span class="string">&#x27;Failed to deregister node: &#x27;</span> + kPluginNodeName )</span><br><span class="line">		<span class="keyword">raise</span></span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<p>1.将以上代码保存为py文件，打开maya，在插件管理器中加载代码</p>
<img src="/2023/05/31/Maya%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%BC%A0%E5%8A%9B%E5%9B%BE/image-20230531173425918.png" class="" title="image-20230531173425918">

<p>2.导入或打开绑定的物体，打开节点编辑器，在脚本编辑器运行以下python代码（创建张力图节点）</p>
<img src="/2023/05/31/Maya%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%BC%A0%E5%8A%9B%E5%9B%BE/image-20230531173735686.png" class="" title="image-20230531173735686">

<p><code>import maya.cmds as mc</code><br><code>mc.createNode(&#39;tensionMap&#39;)</code></p>
<p>3.连接张力图节点，设置颜色变化</p>
<img src="/2023/05/31/Maya%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%BC%A0%E5%8A%9B%E5%9B%BE/image-20230531180726745.png" class="" title="image-20230531180726745">

<img src="/2023/05/31/Maya%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%BC%A0%E5%8A%9B%E5%9B%BE/image-20230531180746933.png" class="" title="image-20230531180746933">

<p>效果如下（需要开启属性颜色显示）：</p>
<img src="/2023/05/31/Maya%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%BC%A0%E5%8A%9B%E5%9B%BE/image-20230531181108887.png" class="" title="image-20230531181108887">

<img src="/2023/05/31/Maya%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%BC%A0%E5%8A%9B%E5%9B%BE/%E5%BC%A0%E5%8A%9B%E5%9B%BE%E6%BC%94%E7%A4%BA.gif" class="" title="张力图演示">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/22/Maya%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A4%B6%E7%9A%B1%E7%BA%B9%E7%90%86%E5%8F%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/22/Maya%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A4%B6%E7%9A%B1%E7%BA%B9%E7%90%86%E5%8F%98%E5%8C%96/" class="post-title-link" itemprop="url">Maya中实现简单的褶皱纹理变化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-22 10:22:35 / 修改时间：10:23:53" itemprop="dateCreated datePublished" datetime="2023-05-22T10:22:35+08:00">2023-05-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先准备好需要的贴图（此处使用抬眉皱纹演示，中性表情和抬眉表情的颜色贴图及法线，左右眉蒙版）</p>
<img src="/2023/05/22/Maya%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A4%B6%E7%9A%B1%E7%BA%B9%E7%90%86%E5%8F%98%E5%8C%96/image-20230521181559601.png" class="" title="image-20230521181559601">

<p>打开含有绑定完好角色的Maya文件，选择头部模型创建两个属性（设置属性名称、类型、最大最小值、默认值）</p>
<img src="/2023/05/22/Maya%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A4%B6%E7%9A%B1%E7%BA%B9%E7%90%86%E5%8F%98%E5%8C%96/image-20230521183125175.png" class="" title="image-20230521183125175">

<p>打开关键帧驱动窗口，设置相应的驱动范围（最小值k一下，最大值k一下）</p>
<img src="/2023/05/22/Maya%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A4%B6%E7%9A%B1%E7%BA%B9%E7%90%86%E5%8F%98%E5%8C%96/image-20230521183318678.png" class="" title="image-20230521183318678">

<img src="/2023/05/22/Maya%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A4%B6%E7%9A%B1%E7%BA%B9%E7%90%86%E5%8F%98%E5%8C%96/image-20230521183512309.png" class="" title="image-20230521183512309">

<p>打开材质编辑器，选择头部材质，导入蒙版贴图，创建乘法节点（通过属性值驱动蒙版强度）</p>
<img src="/2023/05/22/Maya%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A4%B6%E7%9A%B1%E7%BA%B9%E7%90%86%E5%8F%98%E5%8C%96/image-20230521183854030.png" class="" title="image-20230521183854030">

<p>打开连接编辑器，将属性值与蒙版相乘</p>
<img src="/2023/05/22/Maya%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A4%B6%E7%9A%B1%E7%BA%B9%E7%90%86%E5%8F%98%E5%8C%96/image-20230521184024439.png" class="" title="image-20230521184024439">

<p>将左右蒙版的结果相加，重新生成为贴图再与一个三维向量相乘</p>
<img src="/2023/05/22/Maya%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A4%B6%E7%9A%B1%E7%BA%B9%E7%90%86%E5%8F%98%E5%8C%96/image-20230521184223406.png" class="" title="image-20230521184223406">

<p>将颜色和法线贴图做如下操作</p>
<img src="/2023/05/22/Maya%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A4%B6%E7%9A%B1%E7%BA%B9%E7%90%86%E5%8F%98%E5%8C%96/image-20230521184344616.png" class="" title="image-20230521184344616">

<img src="/2023/05/22/Maya%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A4%B6%E7%9A%B1%E7%BA%B9%E7%90%86%E5%8F%98%E5%8C%96/image-20230521184404136.png" class="" title="image-20230521184404136">

<p>将最终的结果与材质对应节点相连并将材质赋予头部模型</p>
<img src="/2023/05/22/Maya%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A4%B6%E7%9A%B1%E7%BA%B9%E7%90%86%E5%8F%98%E5%8C%96/image-20230521184446495.png" class="" title="image-20230521184446495">

<p>最终效果</p>
<img src="/2023/05/22/Maya%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A4%B6%E7%9A%B1%E7%BA%B9%E7%90%86%E5%8F%98%E5%8C%96/%E8%A4%B6%E7%9A%B1%E6%BC%94%E7%A4%BA.gif" class="" title="褶皱演示">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/" class="post-title-link" itemprop="url">在UE中使用UI制作过场动画</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-21 12:53:36 / 修改时间：17:50:33" itemprop="dateCreated datePublished" datetime="2023-05-21T12:53:36+08:00">2023-05-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>创建一个媒体播放器，勾选创建媒体纹理</p>
<img src="/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/image-20230521131324792.png" class="" title="image-20230521131324792"><img src="/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/image-20230521131506039.png" class="" title="image-20230521131506039">

<p>创建文件媒体源和媒体播放列表，进行相应的设置</p>
<img src="/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/image-20230521132403049.png" class="" title="image-20230521132403049">

<p>创建一个材质，进行设置后，将媒体纹理连接到基础颜色</p>
<img src="/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/image-20230521132719471.png" class="" title="image-20230521132719471">

<p>创建一个用户控件蓝图，新建画布和图像，设置调整图像层赋予媒体材质</p>
<img src="/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/image-20230521133155383.png" class="" title="image-20230521133155383">

<p>在控件蓝图中创建一个类型为媒体播放器对象引用的变量，指定默认值为之前创建的媒体播放器，进行蓝图绘制</p>
<img src="/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/image-20230521133744335.png" class="" title="image-20230521133744335">

<p>打开关卡蓝图，调用对应的过场动画</p>
<img src="/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/image-20230521134308879.png" class="" title="image-20230521134308879">

<p>运行发现视频有了，但是没有声音，所以我们接下来就创建音效</p>
<p>首先对之前的视频进行处理，提取视频的音轨导出为wav格式并导入到项目中，选择该文件创建一个cue</p>
<img src="/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/image-20230521135728756.png" class="" title="image-20230521135728756">

<p>可双击进入cue进行一些设置（衰减等），将cue放入场景中并在细节面板中取消勾选自动启用</p>
<img src="/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/image-20230521140502011.png" class="" title="image-20230521140502011">

<p>在关卡蓝图中继续完善，就大功告成了</p>
<img src="/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/image-20230521140730365.png" class="" title="image-20230521140730365">

<p>注：如果需要打包项目，视频文件需要严格按照UE项目规范放置（如下所示，记得在UE中修改文件路径），否则打包出去没有视频播放</p>
<img src="/2023/05/21/%E5%9C%A8UE%E4%B8%AD%E4%BD%BF%E7%94%A8UI%E5%88%B6%E4%BD%9C%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/image-20230521141327347.png" class="" title="image-20230521141327347">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/" class="post-title-link" itemprop="url">Fundamentals Of Computer Graphics 4th</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-05 19:38:19" itemprop="dateCreated datePublished" datetime="2023-05-05T19:38:19+08:00">2023-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-21 17:52:37" itemprop="dateModified" datetime="2023-05-21T17:52:37+08:00">2023-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Introduction-介绍"><a href="#1-Introduction-介绍" class="headerlink" title="1 Introduction 介绍"></a>1 Introduction 介绍</h1><h2 id="Graphics-Areas-图形领域"><a href="#Graphics-Areas-图形领域" class="headerlink" title="Graphics Areas 图形领域"></a>Graphics Areas 图形领域</h2><p><strong>大多数从业人员认同的主要领域：</strong></p>
<p><strong>模型：使用数学描述存储在计算机上的形状或外观属性</strong></p>
<p><strong>渲染：将3D计算机模型创建为着色图像</strong></p>
<p><strong>动画：通过图像序列创造运动效果的技术</strong></p>
<p><strong>用户交互：通过输入设备或应用程序对用户进行图像和其它感官反馈的界面</strong></p>
<p><strong>虚拟现实：让用户沉浸在3D虚拟世界中的技术</strong></p>
<p><strong>可视化：通过可视化显示让用户了解复杂的信息</strong></p>
<p><strong>图像处理：用于图形和视觉领域的2D图像的操作</strong></p>
<p><strong>3D扫描：使用测距技术来刨建3D模型</strong></p>
<h2 id="Major-Applications-主要应用"><a href="#Major-Applications-主要应用" class="headerlink" title="Major Applications 主要应用"></a>Major Applications 主要应用</h2><p><strong>影视游戏</strong></p>
<p><strong>动画</strong></p>
<p><strong>视觉效果</strong></p>
<p><strong>动画电影</strong></p>
<p><strong>CAD/CAM（计算机辅助设计和计算机辅助制造的缩写）</strong></p>
<p><strong>模拟</strong></p>
<p><strong>医学成像</strong></p>
<p><strong>信息可视化</strong></p>
<h2 id="Graphics-APIs-图形APIs"><a href="#Graphics-APIs-图形APIs" class="headerlink" title="Graphics APIs 图形APIs"></a>Graphics APIs 图形APIs</h2><p><strong><em>application program interface</em> （程序接口API)用于执行集合的标准函数集合，图形API是一组执行基本操作的函数操作。每个图形程序都需要能够使用两个相关的API:用于可视化输出的API和用于从用户获取输入的用户界面API。 目前有两种主要的图形和用户界面API范例：一直是集成方法； 第二个是用Direct3D和OpenGL，在OpenGL中，绘图命令是与c++这样的语言绑定的软件库的一部分，用户界面软件是一个会因系统而异的独立实体。（在后一种方法中，它是有问题的要编写可移植代码，尽管对于简单的程序，可以使用可移植库层来封装特定于系统的用户界面代码。）无论选择什么API，基本的图形调用基本上都是一样的。</strong></p>
<h2 id="Graphics-Pipeline-图形管线"><a href="#Graphics-Pipeline-图形管线" class="headerlink" title="Graphics Pipeline 图形管线"></a>Graphics Pipeline 图形管线</h2><p><strong>这是一个特殊的软件/硬件子系统，它可以有效地绘制透视图中的3D元素。通常，这些系统用于优化处理具有共享顶点的3D三角形。管线的基本操作是将3D顶点位置映射到2D屏幕位置，并给三角形着色，以便它们看起来都很真实，并以适当的前后顺序显示。（但现在几乎总是使用z缓冲区来解决，它使用一个特殊的内存缓冲区以蛮力的方式来解决问题。）</strong></p>
<p><strong>在图形管线中使用的几何操作几乎可以完全在一个由三个传统几何坐标和一个有助于透视的第四次齐次坐标组成的4D坐标空间中完成。这些四维坐标是用4 × 4矩阵和4-向量操作的。因此，图形管道包含了许多有效处理和组合这些矩阵和向量的机器。</strong></p>
<p><strong>图像生成的速度很大程度上取决于绘制的三角形的数量。因为在许多应用中，交互性比视觉质量更重要，所以最小化用于表示模型的三角形数量是值得的。此外，如果从远处观察模型，需要的三角形比从较近的距离观察模型时要少。这表明用不同的细节级别(LOD)来表示模型是有用的。</strong></p>
<h2 id="Numerical-Issues-数学问题"><a href="#Numerical-Issues-数学问题" class="headerlink" title="Numerical Issues 数学问题"></a>Numerical Issues 数学问题</h2><p><strong>IEEE浮点数中三个实数“特殊值”：</strong></p>
<p><strong>无穷(∞)：这是一个比所有其他有效数都大的有效数。</strong></p>
<p><strong>负无穷(−∞)：这是一个比所有其他有效数都小的有效数。</strong></p>
<p><strong>不是数字(NaN)：这是一个无效的数，由结果未定义的操作产生，例如0除以0。</strong></p>
<p><strong>涉及无穷值的规则：</strong></p>
<p>​    <strong>对于任何正实数a，</strong></p>
<p>​    <strong>+a/(+∞) = +0,</strong> </p>
<p>​    <strong>−a/(+∞) = −0,</strong> </p>
<p>​    <strong>+a/(−∞) = −0,</strong> </p>
<p>​    <strong>−a/(−∞) = +0.</strong></p>
<p>​    <strong>对于正a，</strong></p>
<p>​    <strong>∞ + ∞ = +∞,</strong> </p>
<p>​    <strong>∞−∞ = NaN,</strong> </p>
<p>​    <strong>∞×∞ = ∞,</strong> </p>
<p>​    <strong>∞/∞ = NaN,</strong></p>
<p>​    <strong>∞/a = ∞,</strong></p>
<p>​    <strong>∞/0 = ∞,</strong> </p>
<p>​    <strong>0/0 = NaN.</strong></p>
<p><strong>包含无穷值的布尔表达式规则：</strong></p>
<p>​    <strong>1.所有有限有效数都小于+∞。</strong></p>
<p>​    <strong>2.所有有限有效数都大于-∞。</strong></p>
<p>​    <strong>3.−∞小于+∞。</strong></p>
<p><strong>涉及NaN值的规则：</strong></p>
<p>​    <strong>1.任何包含NaN的算术表达式的结果都是NaN。</strong></p>
<p>​    <strong>2.任何涉及NaN的布尔表达式都是假的。</strong></p>
<p><strong>IEEE浮点数对0有两种表示，一种被视为正的，一种被视为负的。对于任何正实数a，用零除的规则是成立的:</strong></p>
<p>​    <strong>+a/ +0 = +∞,</strong> </p>
<p>​    <strong>−a/ +0 = −∞.</strong></p>
<p><strong>使用IEEE规则，能使得程序更小、更健壮、更高效。</strong></p>
<h2 id="Efficiency-效率"><a href="#Efficiency-效率" class="headerlink" title="Efficiency 效率"></a>Efficiency 效率</h2><p><strong>效率是通过仔细的权衡来实现的，而这些权衡对于不同的体系结构是不同的。程序员应该更多地关注内存访问模式而不是操作计数。（发生这种切换是因为内存的速度没有跟上处理器的速度。由于这种趋势仍在继续，有限的、一致的内存访问对优化的重要性只会增加。）</strong></p>
<p><strong>使代码快速的一个合理方法是按照以下顺序进行，只采取那些需要的步骤:</strong></p>
<p>​    <strong>1.以最直接的方式编写代码。根据需要动态计算中间结果，而不是存储它们。</strong></p>
<p>​    <strong>2.在优化模式下进行编译。</strong></p>
<p>​    <strong>3.使用任何现有的分析工具来找到关键的瓶颈。</strong></p>
<p>​    <strong>4.检查数据结构以寻找改进局部性的方法。如果可能，使数据单元大小与目标体系结构上的缓存/页面大小相匹配。</strong></p>
<p>​    <strong>5.如果分析揭示了数值计算中的瓶颈，请检查编译器生成的程序集代码，以确定未达到的效率。重写源代码以解决发现的任何问题。</strong></p>
<p><strong>这些步骤中最重要的是第一步。大多数“优化”使代码难以阅读，而不会加快速度。此外，将优化代码的时间花在纠正bug或添加功能上通常会更好。在所有情况下，都需要进行分析，以确定针对特定机器和编译器的任何优化的优点。</strong></p>
<h2 id="Designing-and-Coding-Graphics-Programs-设计与编码图形程序"><a href="#Designing-and-Coding-Graphics-Programs-设计与编码图形程序" class="headerlink" title="Designing and Coding Graphics Programs 设计与编码图形程序"></a>Designing and Coding Graphics Programs 设计与编码图形程序</h2><h3 id="Class-Design-类设计"><a href="#Class-Design-类设计" class="headerlink" title="Class Design 类设计"></a>Class Design 类设计</h3><p><strong>需要编写的一些基本类:</strong></p>
<p>​    <strong>vector2：存储x和y分量的2D向量类。它应该将这些组件存储在长度为2的数组中，以便能够很好地支持索引操作符。还应包括向量加法、向量减法、点积、叉积、标量乘法和标量除法的运算。</strong></p>
<p>​    <strong>vector3：类似于vector2的3D向量类。</strong></p>
<p>​    <strong>hvector：有四个分量的齐次向量。</strong></p>
<p>​    <strong>rgb：RGB颜色，可存储三个组件。还应包括RGB加、RGB减、RGB乘、标量乘和标量除的操作。</strong></p>
<p>​    <strong>变换：一个用于变换的4 × 4矩阵。应包括一个矩阵乘法和成员函数，以应用于位置、方向和表面法向量。</strong></p>
<p>​    <strong>图像：带有输出操作的RGB像素的2D数组。</strong></p>
<p><strong>（也可以为间隔、标准正交基和坐标系添加类。）</strong></p>
<h3 id="Float-vs-Double-单精度VS-双精度"><a href="#Float-vs-Double-单精度VS-双精度" class="headerlink" title="Float vs. Double 单精度VS.双精度"></a>Float vs. Double 单精度VS.双精度</h3><p><strong>降低内存使用和保持一致的内存访问是效率的关键。这就建议使用单精度数据。然而，避免数值问题建议使用双精度算术。权衡取决于程序，但是最好在类定义中有一个默认值。建议使用单精度进行所有计算，直到发现代码的特定部分需要双精度。建议几何计算使用双精度，颜色计算使用单精度。对于占用大量内存的数据，如三角形网格，建议存储单精度数据，但通过成员函数访问数据时转换为双精度。</strong></p>
<h3 id="Debugging-Graphics-Programs-调试图形程序"><a href="#Debugging-Graphics-Programs-调试图形程序" class="headerlink" title="Debugging Graphics Programs 调试图形程序"></a>Debugging Graphics Programs 调试图形程序</h3><h4 id="The-Scientific-Method-科学方法"><a href="#The-Scientific-Method-科学方法" class="headerlink" title="The Scientific Method 科学方法"></a>The Scientific Method 科学方法</h4><p><strong>创建一个图像，并观察它有什么问题。然后，提出一个关于问题原因的假设，并对其进行检验。</strong></p>
<h4 id="Images-as-Coded-Debugging-Output-图像编码调试输出"><a href="#Images-as-Coded-Debugging-Output-图像编码调试输出" class="headerlink" title="Images as Coded Debugging Output 图像编码调试输出"></a>Images as Coded Debugging Output 图像编码调试输出</h4><p><strong>从在图形程序中直接输出图像本身。例如，如果怀疑表面法线的问题导致阴影的问题，直接复制法向量图像(y x→红色,绿色,z去蓝色),导致实际使用彩色插图的向量计算。或者，如果怀疑某个特定值有时超出了其有效范围，则让程序在发生这种情况时编写亮红色像素。其他常见的技巧包括用明显的颜色绘制表面的背面(当它们不应该是可见的)，根据物体的ID号给图像上色，或者根据计算的工作量给像素上色。</strong></p>
<h4 id="Using-a-Debugger-使用调试器"><a href="#Using-a-Debugger-使用调试器" class="headerlink" title="Using a Debugger 使用调试器"></a>Using a Debugger 使用调试器</h4><p><strong>确保程序是确定性的——在一个线程中运行它，并确保所有的随机数都是从固定的种子中计算出来的。然后，找出哪个像素或三角形显示了bug，并在怀疑错误的代码之前添加一条语句，该语句只会在怀疑的情况下执行。</strong></p>
<p><strong>在程序崩溃的情况下，传统调试器可以用来确定崩溃的位置。然后，应该在程序中开始回溯，使用断言和重新编译，以找到程序出错的地方。这些断言应该留在程序中，以防止将来添加的潜在错误。（这意味着要避免传统的分步处理，因为这不会为您的程序添加有价值的断言。）</strong></p>
<h4 id="Data-Visualization-for-Debugging-调试数据可视化"><a href="#Data-Visualization-for-Debugging-调试数据可视化" class="headerlink" title="Data Visualization for Debugging 调试数据可视化"></a>Data Visualization for Debugging 调试数据可视化</h4><p><strong>为自己绘制良好的图表和插图，以理解数据的含义。花在编写代码来可视化程序内部状态上的时间，在优化程序时也能更好地理解程序的行为。</strong></p>
<h1 id="2-Miscellaneous-Math-基础数学"><a href="#2-Miscellaneous-Math-基础数学" class="headerlink" title="2 Miscellaneous Math 基础数学"></a>2 Miscellaneous Math 基础数学</h1><h3 id="Sets-and-Mappings-集合与映射"><a href="#Sets-and-Mappings-集合与映射" class="headerlink" title="Sets and Mappings 集合与映射"></a>Sets and Mappings 集合与映射</h3><p><strong>映射，也称为函数，是数学和编程的基础。在程序中，我们说” type “;在数学中，我们叫做集合。常用的集合有：</strong><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210906101534.png" class="" title="image-20210906101534"></p>
<p>​    <strong>实数集;</strong></p>
<p>​    <strong>非负实数集(包括0);</strong></p>
<p>​    <strong>真实2D平面中的有序对;</strong></p>
<p>​    <strong>n维笛卡尔空间中的点;</strong></p>
<p>​    <strong>整数集;</strong></p>
<p>​    <strong>三维点(点为3D有序对)在单位球面上的集合。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210906102507.png" class="" title="image-20210906102507">

<p><em>整数f（实数）等同于f:R→Z，R叫做函数的定义域，Z叫做目标。点f（a）称为a的图像，且集合a的图像包括a中所有点的目标的子集。</em></p>
<p><strong>整个定义域的图像称为函数的值域。</strong></p>
<h4 id="逆函数-映射"><a href="#逆函数-映射" class="headerlink" title="逆函数/映射"></a><strong>逆函数/映射</strong></h4><p><strong>有一个函数f：A→B，可能存在一个逆函数f－¹:B→A(详细定义略)，满足所有元素一一对应关系的映射或函数被称为双射，非双射的函数没有逆函数，如下图：</strong></p>
<h4 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h4><p><strong>开闭区间及集合运算（不做赘述）</strong></p>
<h4 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210906110052.png" class="" title="image-20210906110052">

<p><strong>以a为底的对数和以a为底的指数是互逆的。所以有几个性质：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210906105546.png" class="" title="image-20210906105546">



<h2 id="Solving-Quadratic-Equations-求解二次方程"><a href="#Solving-Quadratic-Equations-求解二次方程" class="headerlink" title="Solving Quadratic Equations 求解二次方程"></a>Solving Quadratic Equations 求解二次方程</h2><p><strong>根的判别式△=b²-4ac（剩下的不必多说），求根公式x=（-b±√△）/2a</strong></p>
<h2 id="Trigonometry-三角函数"><a href="#Trigonometry-三角函数" class="headerlink" title="Trigonometry 三角函数"></a>Trigonometry 三角函数</h2><h3 id="Angles-角度"><a href="#Angles-角度" class="headerlink" title="Angles 角度"></a>Angles 角度</h3><p><strong>角度和弧度的转换：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907111227.png" class="" title="image-20210907111227">

<h3 id="Trigonometric-Functions-三角函数"><a href="#Trigonometric-Functions-三角函数" class="headerlink" title="Trigonometric Functions 三角函数"></a>Trigonometric Functions 三角函数</h3><p><strong>sin、cos、tan等三角函数</strong></p>
<h3 id="Useful-Identitie-有用的公式"><a href="#Useful-Identitie-有用的公式" class="headerlink" title="Useful Identitie 有用的公式"></a>Useful Identitie 有用的公式</h3><p><strong>三角恒等变换：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907111914.png" class="" title="image-20210907111914">

<p><strong>毕达哥拉斯等式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112035.png" class="" title="image-20210907112035">

<p><strong>加减恒等式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112206.png" class="" title="image-20210907112206">

<p><strong>半角公式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112253.png" class="" title="image-20210907112253">

<p><strong>积化和差公式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112640.png" class="" title="image-20210907112640">

<p><strong>正弦定理、余弦定理、正切定理：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907112927.png" class="" title="image-20210907112927">

<p><strong>面积公式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907113058.png" class="" title="image-20210907113058">

<h2 id="Vectors-向量"><a href="#Vectors-向量" class="headerlink" title="Vectors 向量"></a>Vectors 向量</h2><h3 id="Vector-Operations-向量操作"><a href="#Vector-Operations-向量操作" class="headerlink" title="Vector Operations 向量操作"></a>Vector Operations 向量操作</h3><p><strong>向量的基本加减法则</strong></p>
<h3 id="Cartesian-Coordinates-of-a-Vector-向量的笛卡尔坐标"><a href="#Cartesian-Coordinates-of-a-Vector-向量的笛卡尔坐标" class="headerlink" title="Cartesian Coordinates of a Vector 向量的笛卡尔坐标"></a>Cartesian Coordinates of a Vector 向量的笛卡尔坐标</h3><p><strong>向量的拆分</strong></p>
<p><strong>一个二维向量可以写成任意两个不平行的非零向量的组合。这两个向量的性质称为线性无关。两个线性无关的向量构成一个二维基，因此这些向量被称为基向量。</strong></p>
<h3 id="Dot-Product-点乘-内积"><a href="#Dot-Product-点乘-内积" class="headerlink" title="Dot Product 点乘/内积"></a>Dot Product 点乘/内积</h3><p><strong>向量的点乘（结果是一个数）：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907115024.png" class="" title="image-20210907115024">

<p><strong>一般的计算方法：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907115426.png" class="" title="image-20210907115426">

<p><strong>向量的投影</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907115119.png" class="" title="image-20210907115119">

<p><strong>点乘遵循结合律和分配律:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907115235.png" class="" title="image-20210907115235">

<h3 id="Cross-Product-叉乘-外积"><a href="#Cross-Product-叉乘-外积" class="headerlink" title="Cross Product 叉乘/外积"></a>Cross Product 叉乘/外积</h3><p><strong>向量的叉乘（结果为一个向量）：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907124717.png" class="" title="image-20210907124717">

<p><strong>一般的计算方法：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125516.png" class="" title="image-20210907125516">

<p><strong>其方向由右手定则决定：</strong></p>
<p><img src="C:\Users\86010\AppData\Roaming\Typora\typora-user-images\image-20210907125716158.png" alt="image-20210907125716158"></p>
<p><strong>把你的右手掌放在a和b连接处，四指沿a指向b，拇指所指为a × b的方向。</strong></p>
<p><strong>对于笛卡尔坐标</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125233.png" class="" title="image-20210907125233">

<p><strong>叉乘的性质：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125935.png" class="" title="image-20210907125935">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125944.png" class="" title="image-20210907125944">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907125955.png" class="" title="image-20210907125955">

<h3 id="Orthonormal-Bases-and-Coordinate-Frames-标准正交基底和坐标系"><a href="#Orthonormal-Bases-and-Coordinate-Frames-标准正交基底和坐标系" class="headerlink" title="Orthonormal Bases and Coordinate Frames 标准正交基底和坐标系"></a>Orthonormal Bases and Coordinate Frames 标准正交基底和坐标系</h3><p><strong>任何由两个二维向量u和v组成的集合，只要它们是正交的(在直角处)并且每个都是单位长度，就构成一个标准正交基。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130318.png" class="" title="image-20210907130318">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130337.png" class="" title="image-20210907130337">

<p><strong>在三维空间中，三个向量u v和w构成一个标准正交基。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130523.png" class="" title="image-20210907130523">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130540.png" class="" title="image-20210907130540">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907130550.png" class="" title="image-20210907130550">

<p><strong>注意笛卡尔标准正交基只是无穷多个可能的标准正交基中的一个。它的特殊之处在于它及其隐式的原点位置用于程序中的低级表示。因此，向量x、y和z永远不会被显式存储，正则原点位置o也不会被存储。全局模型通常存储在这个正则坐标系中，因此它通常被称为全局坐标系。但是，如果我们想要用另一个原点是p和标准正交基向量的坐标系u, v, w，然后我们明确地存储这些向量。这样的系统叫做参照系或坐标系。</strong></p>
<h3 id="Constructing-a-Basis-from-a-Single-Vector-单个向量构造基向量"><a href="#Constructing-a-Basis-from-a-Single-Vector-单个向量构造基向量" class="headerlink" title="Constructing a Basis from a Single Vector 单个向量构造基向量"></a>Constructing a Basis from a Single Vector 单个向量构造基向量</h3><p><strong>给定一个向量a，我们想要一个标准正交的u, v, w，首先使w为a方向上的单位矢量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907133314.png" class="" title="image-20210907133314">

<p><strong>然后选择任意不与w共线的向量t，用叉乘得到垂直于w的单位向量u:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907133323.png" class="" title="image-20210907133323">

<p><strong>最后使用右手定则，得到单位向量v：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907133334.png" class="" title="image-20210907133334">

<h3 id="Constructing-a-Basis-from-Two-Vectors-两个向量构造基向量"><a href="#Constructing-a-Basis-from-Two-Vectors-两个向量构造基向量" class="headerlink" title="Constructing a Basis from Two Vectors 两个向量构造基向量"></a>Constructing a Basis from Two Vectors 两个向量构造基向量</h3><p><strong>如果已知这两个向量是垂直的，那么可以简单地用u = b × a来构造第三个向量。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210907134814.png" class="" title="image-20210907134814">

<p><strong>当a和b不是垂直的时候，w将沿着a的方向构造，而v被选为所有垂直于w的向量中离b最近的向量。</strong></p>
<p><strong>让w平行于相机所观察的方向，而v应该指向相机的顶部。为了使相机垂直，我们围绕视图方向建立基础，使用直线方向作为参考向量来建立相机围绕视图方向的方向。将v设置得尽可能接近垂直，这与“保持相机垂直”的直观概念完全吻合。</strong></p>
<h3 id="Squaring-Up-a-Basis-修正基向量"><a href="#Squaring-Up-a-Basis-修正基向量" class="headerlink" title="Squaring Up a Basis 修正基向量"></a>Squaring Up a Basis 修正基向量</h3><p><strong>偶尔你可能会发现在你的计算中由一个标准正态的基引起的问题，但由于计算中的舍入误差，或基被存储在一个低精度的文件中。</strong></p>
<p><strong>可以简单地用现有的w和v向量重新构造基将会产生一个新的标准正交的基并且接近于旧的基。</strong></p>
<p><strong>这种方法对许多应用程序都很好，但它不是可用的最佳方法。它确实能产生精确的正交向量，而且对于几乎正交的起点，结果不会离起点太远。然而，它是不对称的:它“偏爱”w比v和v比u(其初始值被丢弃)。它选择一个接近起始基的基，但不能保证选择最接近的标准正交基。当这还不够好时，可以使用SVD来计算一个标准正交基，该基保证最接近原始基。</strong></p>
<h2 id="Curves-and-Surfaces-曲线和曲面"><a href="#Curves-and-Surfaces-曲线和曲面" class="headerlink" title="Curves and Surfaces 曲线和曲面"></a>Curves and Surfaces 曲线和曲面</h2><h3 id="2D-Implicit-Curves-2D隐式曲线"><a href="#2D-Implicit-Curves-2D隐式曲线" class="headerlink" title="2D Implicit Curves 2D隐式曲线"></a>2D Implicit Curves 2D隐式曲线</h3><p><strong>描述曲线的常用方法是使用隐式方程。二维的隐式方程有这样的形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908111057.png" class="" title="image-20210908111057">

<p><strong>注意，f(x, y) = c是任意常数c的曲线，c = 0只是作为惯例使用。</strong></p>
<p><strong>我们可以用向量来压缩符号。如果已知c = (xc, yc)和p = (x, y)，那么以c为圆心，半径为r的圆由满足条件的位置向量定义</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908111224.png" class="" title="image-20210908111224">

<p><strong>如果在代数上展开，但更容易看出这是一个圆的方程，上面可以理解为“圆上的p点离圆心c点的距离为r”。（这说明方程的矢量形式通常比包含x和y的完全笛卡尔形式更具有几何和直观意义。因此，如果可能，通常建议使用矢量形式。此外，您可以在代码中支持vector类;当使用向量形式时，代码会更清晰。面向矢量的方程在实现中也更不容易出错:一旦在代码中实现并调试矢量类型，涉及x、y和z的剪切和粘贴错误就会消失。习惯这些方程中的向量需要一点时间，但一旦你掌握了窍门，回报就会很大。）</strong></p>
<h3 id="The-2D-Gradient-2D梯度"><a href="#The-2D-Gradient-2D梯度" class="headerlink" title="The 2D Gradient 2D梯度"></a>The 2D Gradient 2D梯度</h3><p><strong>如果我们把函数f(x, y)看作一个高度场，高度为f(x, y)，梯度向量指向上斜率最大的方向，即指向山顶。梯度向量∇f(x, y)：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908123047.png" class="" title="image-20210908123047">

<p><strong>作为梯度的一个例子，考虑隐圆x² + y² − 1 = 0，带有梯度向量(2x, 2y)。注意，梯度向量的长度可能取决于隐式方程中的乘数。例如，单位圆Ax² + Ay² − A = 0对于任意非零A, A = 0。此曲线的梯度为(2Ax, 2Ay)，其与圆的法线(垂直)，但其长度由a决定。对于A &gt; 0，法线将从圆指向外，对于A &lt; 0，法线将指向内。这种由外向向内的转换是正常的，因为正区域在圆内转换。在高度场视图中，h = Ax² + Ay² − A，圆处于零高度。对于A &gt; 0，圆包含一个凹点，对于A &lt; 0，圆包含一个凸点。当A变得更负时，凸起的高度增加，但h = 0的圆没有改变。最大上坡方向不变，但坡度增大。坡度的长度反映了坡度程度的变化。所以直观上，你可以把梯度的方向看成是向上的它的大小是衡量斜率向上的程度的。</strong></p>
<h4 id="Implicit-2D-Lines-隐式直线"><a href="#Implicit-2D-Lines-隐式直线" class="headerlink" title="Implicit 2D Lines 隐式直线"></a>Implicit 2D Lines 隐式直线</h4><p><strong>直线的一般表示（但发现其无法表示常值函数）：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908152259.png" class="" title="image-20210908152259">

<p><strong>通过梯度向量的引入，可表示更一般的：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908152314.png" class="" title="image-20210908152314">

<p><strong>将其转化为单位向量的形式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908154023.png" class="" title="image-20210908154023">

<p><strong>相应的，可以将其转化为斜切式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908152326.png" class="" title="image-20210908152326">

<p><strong>点到直线的距离（为梯度向量k（A,B）的长度）：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908153107.png" class="" title="image-20210908153107">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908153053.png" class="" title="image-20210908153053">

<p><strong>对于(x, y) + k(A, B)点，f(x, y) = Ax + By + C是f(x + kA, y + kB) = Ax + kA² + By + kB² + C = k(A² + B²)，直线Ax + By + C = 0到点(a, b)的带符号距离为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908153127.png" class="" title="image-20210908153127">

<h4 id="Implicit-Quadric-Curve-隐式二次曲线"><a href="#Implicit-Quadric-Curve-隐式二次曲线" class="headerlink" title="Implicit Quadric Curve 隐式二次曲线"></a>Implicit Quadric Curve 隐式二次曲线</h4><p><strong>二次曲线的一般式（包括椭圆和双曲线，以及特殊情况下的抛物线、圆和直线。）：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908154640.png" class="" title="image-20210908154640">

<p><strong>圆心为(xc，yc)和半径r，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908154653.png" class="" title="image-20210908154653">

<p><strong>在(xc，yc)为中心，a和b为长半轴和短半轴的椭圆，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908154704.png" class="" title="image-20210908154704">

<h3 id="3D-Implicit-Surfaces-3D隐式曲面"><a href="#3D-Implicit-Surfaces-3D隐式曲面" class="headerlink" title="3D Implicit Surfaces 3D隐式曲面"></a>3D Implicit Surfaces 3D隐式曲面</h3><p><strong>用向量表示法，我们将p = (x, y, z)的函数写成，f(p)=0。</strong></p>
<h3 id="Surface-Normal-to-an-Implicit-Surface-隐式曲面的曲面法线"><a href="#Surface-Normal-to-an-Implicit-Surface-隐式曲面的曲面法线" class="headerlink" title="Surface Normal to an Implicit Surface 隐式曲面的曲面法线"></a>Surface Normal to an Implicit Surface 隐式曲面的曲面法线</h3><p><strong>表面法线是垂直于表面的矢量(这是光照计算所必需的)。表面上的每一点都可以有一个不同的法向量。同理，梯度为二维的隐式曲线提供了一条法线，隐式曲面上点p处的法线由隐式函数的梯度得出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908160645.png" class="" title="image-20210908160645">

<p><strong>其理由与二维情况相同:梯度指向f增长最快的方向，f垂直于与曲面相切的所有方向，其中f保持不变。梯度向量指向曲面f(p) &gt; 0的一侧，在给定的上下文中，我们可以认为它是“进入”曲面或“离开”曲面。如果f的特殊形式创建面向内的梯度，而需要面向外的梯度，则−f(p) = 0表面与f(p) = 0表面相同，但具有方向相反的梯度，即，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908160740.png" class="" title="image-20210908160740">

<h3 id="Implicit-Planes-隐式平面"><a href="#Implicit-Planes-隐式平面" class="headerlink" title="Implicit Planes 隐式平面"></a>Implicit Planes 隐式平面</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908161830.png" class="" title="image-20210908161830">

<p><strong>点p在包含点a的且法向量为n的平面内，描述平面的隐式方程</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908161841.png" class="" title="image-20210908161841">

<p><strong>通过点(a, b, c)的平面的法向量可以通过求平面上任意两个向量的外积来求，平面的法向量n为，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908161851.png" class="" title="image-20210908161851">

<p><strong>得到隐式平面方程：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908161902.png" class="" title="image-20210908161902">

<h4 id="3D-Quadric-Surfaces-3D二次曲面"><a href="#3D-Quadric-Surfaces-3D二次曲面" class="headerlink" title="3D Quadric Surfaces 3D二次曲面"></a>3D Quadric Surfaces 3D二次曲面</h4><p><strong>球体可写成，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908162655.png" class="" title="image-20210908162655">

<p><strong>椭球体可写成，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908162707.png" class="" title="image-20210908162707">

<h4 id="3D-Curves-from-Implicit-Surfaces-3D隐式表面的曲线"><a href="#3D-Curves-from-Implicit-Surfaces-3D隐式表面的曲线" class="headerlink" title="3D Curves from Implicit Surfaces 3D隐式表面的曲线"></a>3D Curves from Implicit Surfaces 3D隐式表面的曲线</h4><p><strong>由两个联立隐式方程的交点可以构造出一条三维曲线，然而，所有这些曲线都只是退化曲面，在实践中很少有用。</strong></p>
<h3 id="2D-Parametric-Curves-2D参数曲线"><a href="#2D-Parametric-Curves-2D参数曲线" class="headerlink" title="2D Parametric Curves 2D参数曲线"></a>2D Parametric Curves 2D参数曲线</h3><p><strong>参数曲线是由单个参数控制的，该参数可被视为一种沿着曲线连续运动的指标。这样的曲线有其形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170008.png" class="" title="image-20210908170008">

<p><strong>这里(x, y)是曲线上的一点，而t是影响曲线的参数。对于给定的t，会有一个由函数g和h决定的点。对于连续的g和h, t的微小变化会产生x和y的微小变化。因此，当t连续变化时，点在连续曲线上被扫走。这是一个很好的特性，因为我们可以使用参数t来显式地构造曲线上的点。通常我们可以把参数曲线写成矢量形式，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170022.png" class="" title="image-20210908170022">

<p><strong>其中f是一个向量值函数，f : R → R²。我们可以把位置看作是时间的函数。曲线可以是任意的，可以是循环的，可以是交叉的。我们也可以把曲线看成是任意一点的速度。</strong></p>
<h4 id="2D-Parametric-Lines-2D参数直线"><a href="#2D-Parametric-Lines-2D参数直线" class="headerlink" title="2D Parametric Lines 2D参数直线"></a>2D Parametric Lines 2D参数直线</h4><p><strong>通过点p的二维参数线</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170426.png" class="" title="image-20210908170426">

<p><strong>矢量形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170435.png" class="" title="image-20210908170435">

<p><strong>参数线也可以用点o和向量d来描述:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170448.png" class="" title="image-20210908170448">

<p><strong>当向量d有单位长度时，直线参数化弧长。这意味着t是直线上距离的精确度量。任何参数曲线都可以进行弧长参数化，这显然是一种非常方便的形式，但并不是所有的曲线都可以进行解析转换。</strong></p>
<h4 id="2D-Parametric-Circles-2D参数圆"><a href="#2D-Parametric-Circles-2D参数圆" class="headerlink" title="2D Parametric Circles 2D参数圆"></a>2D Parametric Circles 2D参数圆</h4><p><strong>圆心为(xc，yc)，半径r为参数形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170641.png" class="" title="image-20210908170641">

<p><strong>为保证曲线上每一点都有唯一的参数φ，可以限定其定域:φ∈[0,2π)或φ∈(- π，π)或任意长度为2π的半开区间。</strong></p>
<p><strong>也可以通过缩放x和y参数来构造一个轴向椭圆:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170650.png" class="" title="image-20210908170650">

<h3 id="3D-Parametric-Curves-3D参数曲线"><a href="#3D-Parametric-Curves-3D参数曲线" class="headerlink" title="3D Parametric Curves 3D参数曲线"></a>3D Parametric Curves 3D参数曲线</h3><p><strong>3D参数曲线的运行方式与2D参数曲线非常相似:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170840.png" class="" title="image-20210908170840">

<p><strong>我们可以写成向量形式,p: R → R³:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908170852.png" class="" title="image-20210908170852">

<h4 id="3D-Parametric-Lines-3D参数直线"><a href="#3D-Parametric-Lines-3D参数直线" class="headerlink" title="3D Parametric Lines 3D参数直线"></a>3D Parametric Lines 3D参数直线</h4><p><strong>三维参数线可以写成二维参数线的直接扩展，例如:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171218.png" class="" title="image-20210908171218">

<p><strong>这很麻烦，不能很好地转换为代码变量，所以我们将它写成向量形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171228.png" class="" title="image-20210908171228">

<p><strong>在这个例子中，o和d是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171239.png" class="" title="image-20210908171239">

<h3 id="3D-Parametric-Surfaces-3D参数曲面"><a href="#3D-Parametric-Surfaces-3D参数曲面" class="headerlink" title="3D Parametric Surfaces 3D参数曲面"></a>3D Parametric Surfaces 3D参数曲面</h3><p><strong>定义三维参数曲面：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171848.png" class="" title="image-20210908171848">

<p><strong>矢量形式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171900.png" class="" title="image-20210908171900">

<p><strong>p的导数，得到曲面上任意一点的两个切向量。曲面的法向量可以通过求这两个向量的叉积得到。叉乘的右手法则提供了一种方法来决定哪边是曲面的正面或外部;我们将使用约定向量</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908171914.png" class="" title="image-20210908171914">

<p><strong>指向表面的外面。</strong></p>
<h3 id="Summary-of-Curves-and-Surfaces-曲线曲面汇总"><a href="#Summary-of-Curves-and-Surfaces-曲线曲面汇总" class="headerlink" title="Summary of Curves and Surfaces 曲线曲面汇总"></a>Summary of Curves and Surfaces 曲线曲面汇总</h3><p><strong>二维的隐式曲线或三维的曲面由两或三个变量的标量函数f: R²→R或f: R³→R，曲面由函数为零的所有点组成:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172322.png" class="" title="image-20210908172322">

<p><strong>二维或三维的参数曲线由一个变量的向量值函数定义，p: R→R²或R→R³，当t在整个D上变化时，曲线被扫出:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172334.png" class="" title="image-20210908172334">

<p><strong>三维参数曲面是由两个变量的向量值函数定义的p: R²→R³，该曲面由定义域内所有点(u, v)的像构成:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172344.png" class="" title="image-20210908172344">

<p><strong>对于隐式曲线和曲面，法向量由f(梯度)的导数给出，而切向量(曲线)或向量(曲面)可以通过构造基从法向量推导出来。</strong></p>
<p><strong>对于参数曲线和曲面，p的导数给出了(曲线的)切向量或(曲面的)向量，法向量可以通过构造基从切线推导出来。</strong></p>
<h2 id="Linear-Interpolation-线性插值"><a href="#Linear-Interpolation-线性插值" class="headerlink" title="Linear Interpolation 线性插值"></a>Linear Interpolation 线性插值</h2><p><strong>在x轴上的一组位置:x0, x1，…，xn，对于每个xi 我们有一个相关的高度yi。我们想要创建一个连续函数y = f(x)来插值这些位置，因此f会遍历每一个数据点，也就是f (xi) = yi。对于线性插值，点(xi，yi)由直线段连接。对于这些线段，使用参数线方程是很自然的。参数t就是x之间的分数距离xi 和xi+1：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172828.png" class="" title="image-20210908172828">

<p><strong>因为权重函数是x的线性多项式，这是线性插值。</strong></p>
<p><strong>以上两个例子具有线性插值的共同形式。我们创建一个变量t，当我们从数据项a移动到数据项b时，它从0到1变化。中间值就是函数(1−t)A + tB。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210908172837.png" class="" title="image-20210908172837">

<h2 id="Triangles-三角形"><a href="#Triangles-三角形" class="headerlink" title="Triangles 三角形"></a>Triangles 三角形</h2><p><strong>在许多图形程序中，二维和三维三角形都是基本的建模元素。通常情况下，诸如颜色之类的信息会被标记到三角形顶点上，并且这些信息会被插值到整个三角形上。使这种插值直接的坐标系统称为重心坐标。</strong></p>
<h3 id="2D-Triangles-2D三角形"><a href="#2D-Triangles-2D三角形" class="headerlink" title="2D Triangles 2D三角形"></a>2D Triangles 2D三角形</h3><p><strong>如果我们有一个由2D点a，b，c定义的2D三角形，可以先求出它的面积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909121458.png" class="" title="image-20210909121458">

<p><strong>如果点a, b, c是逆时针的，这个面积就是正号，否则就是负号。</strong></p>
<p><strong>通常在图形中，我们希望在每个三角形顶点上分配一个属性，比如颜色，并在整个三角形上平滑地插入该属性的值。有多种方法可以做到这一点，但最简单的方法是使用重心坐标。将重心坐标看作非正交坐标系的一种，其中坐标原点为a，从a到b和c的向量为基向量。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909122542.png" class="" title="image-20210909122542">

<p><strong>那么任意点p都可以用表示为，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909122802.png" class="" title="image-20210909122802">

<p><strong>定义一个新的变量α，有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909122828.png" class="" title="image-20210909122828">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909122819.png" class="" title="image-20210909122819">

<p><strong>当且仅当点p在由ABC组成的三角形内,有,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909124938.png" class="" title="image-20210909124938">

<p><strong>如果其中一个坐标是0另外两个在0和1之间，那么它就在一条边上。如果其中两个坐标为0，那么另一个坐标为1，它在一个顶点上。重心坐标的性质是可以一种平滑的方式混合了三个顶点的坐标和混合其他性质，如颜色。</strong></p>
<p><strong>求一个三角形的重心坐标有，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909123607.png" class="" title="image-20210909123607">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909123620.png" class="" title="image-20210909123620">

<p><strong>但是这个方法过于麻烦，更为直观的方法是，计算Aa, Ab和Ac的子三角形的面积，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909124059.png" class="" title="image-20210909124059">

<p><strong>A是三角形的面积，A = Aa + Ab + Ac，这个规则仍然适用于三角形以外的点，只是这些是带符号的面积，只要对三角形和子三角形使用相同的带符号面积计算，就可以正确地计算出三角形A和子三角形Aa, Ab,Ac的面积。</strong></p>
<h3 id="3D-Triangles-3D三角形"><a href="#3D-Triangles-3D三角形" class="headerlink" title="3D Triangles 3D三角形"></a>3D Triangles 3D三角形</h3><p><strong>对于三维三角形，依然有，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130258.png" class="" title="image-20210909130258">

<p><strong>而三角形的法向量为，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130309.png" class="" title="image-20210909130309">

<p><strong>三角形的面积可以通过求叉乘的长度得到：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130319.png" class="" title="image-20210909130319">

<p><strong>三角形的重心坐标为，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130334.png" class="" title="image-20210909130334">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909130343.png" class="" title="image-20210909130343">

<h1 id="3-Raster-Images-光栅化图像"><a href="#3-Raster-Images-光栅化图像" class="headerlink" title="3 Raster Images 光栅化图像"></a>3 Raster Images 光栅化图像</h1><p><strong>因为光栅在设备中非常普遍，所以光栅图像是存储和处理图像最常用的方法。光栅图像只是一个2D数组，存储每个像素的像素值——通常是一种颜色，存储为三个数字，分别是红、绿和蓝。存储在内存中的光栅图像可以通过使用存储图像中的每个像素来控制显示的一个像素的颜色来显示。</strong></p>
<p><strong>但我们并不总是希望以这种方式显示图像。我们可能想要改变图像的大小或方向，纠正颜色，甚至显示粘贴在移动三维表面上的图像。即使是在电视，很少有相同的像素数量的图像被显示。这样的破坏了图像像素和显示像素之间的直接联系。最好将光栅图像看作是要显示的图像的与设备无关的描述，而显示设备则是接近理想图像的一种方法。</strong></p>
<p><strong>除了使用像素数组之外，还有其他描述图像的方法。矢量图像是通过存储对形状的描述来描述的——以线或曲线为边界的颜色区域——而不参考任何特定的像素网格。本质上，这相当于存储显示图像的指令，而不是存储显示图像所需的像素。矢量图像的主要优点是它们与分辨率无关，可以在非常高分辨率的设备上很好地显示。相应的缺点是在显示之前必须对其进行光栅化。矢量图像通常用于文本、图表、机械制图和其他应用，在这些应用中，清晰度和精度很重要，不需要摄影图像和复杂的着色。</strong></p>
<h2 id="Raster-Devices-光栅设备"><a href="#Raster-Devices-光栅设备" class="headerlink" title="Raster Devices 光栅设备"></a>Raster Devices 光栅设备</h2><p><strong>一些熟悉的光栅设备可以归类为一个简单的层次结构:</strong></p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p><strong>显示</strong></p>
<p>​    <strong>传输：液晶显示(LCD)</strong></p>
<p>​    <strong>发射：发光二极管(LED)显示</strong></p>
<p><strong>硬拷贝</strong></p>
<p>​    <strong>二进制：喷墨打印机</strong></p>
<p>​    <strong>连续色调：热敏染料转移打印机</strong></p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p><strong>二维阵列传感器：数码相机</strong></p>
<p><strong>一维阵列传感器：平板扫描仪</strong></p>
<h3 id="Displays-显示"><a href="#Displays-显示" class="headerlink" title="Displays 显示"></a>Displays 显示</h3><p><strong>目前的显示器，包括电视和数字电影放映机以及电脑上的显示器和放映机，几乎都是基于固定的像素阵列。它们可以分为发射型显示器和透射型显示器，前者使用像素直接发射可控数量的光，后者像素本身不发射光，而是改变它们允许通过的光的数量。透射式显示器需要光源来照亮它们：在直接显示器中，这是阵列后面的背光;在投影仪中，它是一盏灯，它发出的光通过阵列后投射到屏幕上。发射显示器是它自己的光源。</strong></p>
<p><strong>发光二极管(LED)显示器是发射型显示器的一个例子。每个像素都由一个或多个led组成，这些led是半导体器件(基于无机或有机半导体)，发光强度取决于通过它们的电流。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909133135.png" class="" title="image-20210909133135">

<p><strong>彩色显示器中的像素被分为三个独立控制的亚像素——一个红色，一个绿色，一个蓝色——每个都有自己的LED，使用不同的材料，以便它们发出不同颜色的光。当显示器是从远处观看的，眼睛无法分离单个的亚像素，所感知到的颜色是红、绿、蓝的混合。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210909133423.png" class="" title="image-20210909133423">

<p><strong>液晶显示器(LCDs)是透射型显示器的一个例子。如上图，液晶是一种材料，其分子结构使它能够旋转通过它的光的偏振，并且旋转的程度可以通过施加的电压来调节。一个LCD像素的后面有一层偏振光膜，因此它被偏振光照亮——假设它是水平偏振光。</strong></p>
<p><strong>在所述像素前的第二层偏振光膜定向以只传输垂直偏振光。如果将施加的电压设置为中间的液晶层不改变偏振，则所有光都被阻挡，像素处于“关闭”(最小强度)状态。如果电压设置为使液晶旋转90度的偏振，那么所有从像素后面进入的光将从前面逃逸，像素完全“打开”——它有最大的强度。中间电压将部分旋转偏振，使前偏振器部分阻挡光，导致强度介于最小和最大之间。像彩色LED显示器一样，彩色液晶显示器在每个像素内都有红、绿、蓝亚像素，这是三个独立的像素，上面有红、绿、蓝滤光片。</strong></p>
<p><strong>任何具有固定像素网格的显示器，包括这些和其他技术，都具有由网格大小决定的基本固定分辨率。对于显示器和图像，分辨率仅仅意味着像素网格的尺寸:如果桌面显示器的分辨率是1920 × 1200像素，这意味着它有2304000像素排列在1920列和1200行中。</strong></p>
<h3 id="Hardcopy-Devices-硬拷贝设备"><a href="#Hardcopy-Devices-硬拷贝设备" class="headerlink" title="Hardcopy Devices 硬拷贝设备"></a>Hardcopy Devices 硬拷贝设备</h3><p><strong>在纸上永久记录图像的过程与在显示器上短暂显示图像的过程有非常不同的限制。在印刷中，颜料分布在纸上或其他介质上，当光线从纸上反射时，就形成了想要的图像。打印机像显示器一样是光栅设备，但许多打印机只能打印二进制图像——颜料要么在每个网格位置沉积，要么不在每个网格位置，不可能有中间数量。</strong></p>
<p><strong>喷墨打印机是一个通过扫描形成光栅图像的设备。喷墨打印头含有携带颜料的液体墨水，可以在电子控制下以非常小的滴状喷射。头在纸上移动，当它通过应该接收墨水的网格位置时，水滴被发射出来;在空白区域不喷墨。每次扫完后，将纸稍稍向前移动，然后放置下一行网格。彩色打印是通过使用几个打印头，每个喷墨用不同的颜料，这样每个网格位置都可以收到不同颜色的水滴的任何组合。由于所有的水滴都是相同的，喷墨打印机打印出二值图像:在每个网格点上有水滴或没有水滴;没有中间着色。</strong></p>
<p><strong>喷墨打印机没有像素的物理阵列;分辨率是由水滴的大小和每次扫纸后纸张前进的距离决定的。许多喷墨打印机在打印头上有多个喷嘴，可以一次进行多次扫描，但最终决定行间距的是纸张的前进速度，而不是喷嘴的间距。</strong></p>
<p><strong>热敏染料转移打印机是连续色调印刷，这意味着可以在每个像素上沉积不同数量的染料——它不像喷墨打印机那样要么有要么没有。一个含有彩色染料的供体色带被压在纸张(或染料接收器)和一个打印头之间，打印头包含一个线性阵列的加热元件，每个加热元件对应图像中的每一列像素。当纸和纸带经过纸头时，加热元件就会开关，在需要染料的地方加热纸带，使染料从纸带扩散到纸上。这一过程对每种染料重复进行。由于更高的温度导致更多的染料被转移，在每个网格位置沉积的每种染料的数量可以被控制，从而允许产生连续的颜色范围。在打印头的加热元件的数量在整个页面的方向上建立了一个固定的分辨率，但是沿着页面的分辨率是由加热和冷却的速度与纸张的速度相比较决定的。</strong></p>
<p><strong>与显示器不同，打印机的分辨率是用像素密度而不是像素总数来描述的。因此，热敏染料转移打印机的打印头每英寸间距为300的元素在页面上的分辨率为每英寸300像素(ppi)。如果沿着页面的分辨率被选择为相同的，我们可以简单地说打印机的分辨率是300 ppi。在每英寸1200个网点的网格上放置点的喷墨打印机被描述为分辨率为每英寸1200个网点(dpi)。因为喷墨打印机是一种二进制设备，它需要更精细的网格，至少有两个原因。因为边缘是突然的黑/白边界，所以需要非常高的分辨率，以避免出现阶梯或混叠。在打印连续色调图像时，高分辨率要求通过打印被称为半色调的可变密度网点图案来模拟中间色。</strong></p>
<h3 id="Input-Devices-输入设备"><a href="#Input-Devices-输入设备" class="headerlink" title="Input Devices 输入设备"></a>Input Devices 输入设备</h3><p><strong>光栅图像必须来自某个地方，而任何不是由某种算法计算出来的图像必须由某些光栅输入设备测量出来，通常是相机或扫描仪。即使在渲染3D场景的图像时，照片也经常被用作纹理贴图。光栅输入设备必须对每个像素进行光测量，(像输出设备一样)它们通常基于传感器阵列。</strong></p>
<p><strong>数码相机是二维阵列输入设备。相机里的图像传感器是一种半导体装置，由光敏像素组成网格。两种常见的阵列被称为CCDs(电荷耦合器件)和CMOS(互补金属氧化物半导体)图像传感器。相机的镜头将要拍摄的场景的图像投射到传感器上，然后每个像素测量落在其上的光能，最终得到一个进入输出图像的数字。同样的颜色显示使用红色,绿色和蓝色亚像素,大部分颜色相机工作通过使用滤色镜数组或马赛克允许每个像素只看到红色,绿色或蓝色光,离开了图像处理软件来填充缺失的值在一个过程称为demosaicking(色彩重建法)。</strong></p>
<p><strong>其他相机使用三个独立的阵列，或阵列中的三个独立层，测量每个像素上独立的红、绿、蓝值，无需进一步处理就能生成可用的彩色图像。相机的分辨率是由固定数量的像素数组决定,通常是引用使用像素的总数：相机中3000行和2000列的数组产生的图像分辨率3000×2000,拥有600万像素,称为6像素(MP)相机。重要的是要记住，马赛克传感器不能测量完整的彩色图像，所以一个相机测量相同的像素数，但独立的红、绿、蓝测量记录了比马赛克传感器更多的图像信息。</strong></p>
<p><em><em>平板扫描仪也可以测量每个像素网格的红、绿、蓝值，但像热染料转移打印机一样，它使用一维阵列扫描被扫描的页面，每秒进行多次测量。整个页面的分辨率由阵列的大小确定，而沿页面的分辨率则由测量频率与扫描头移动速度的比较决定。彩色扫描仪的分辨率为3 × n</em>x* 数组,其中n*x</em> 是整个页面的像素数，其中三行由红色、绿色和蓝色过滤器覆盖。在测量三种颜色的时间之间有一个适当的延迟，这允许在每个网格点上测量三种独立的颜色。与连续色调打印机一样，扫描仪的分辨率是以每英寸像素(ppi)为单位的。**</p>
<h2 id="Images-Pixels-and-Geometry-图像、像素和几何体"><a href="#Images-Pixels-and-Geometry-图像、像素和几何体" class="headerlink" title="Images, Pixels, and Geometry 图像、像素和几何体"></a>Images, Pixels, and Geometry 图像、像素和几何体</h2><p><strong>当我们测量或复制图像时，它们采用的是光能的二维分布形式:监视器发出的光作为显示表面位置的函数;落在相机图像传感器上的光作为传感器平面上位置的函数;在纸上的反射率，或被反射的光(相对于被吸收的光)的比例，是纸上位置的函数。所以在现实世界中，图像是二维区域上定义的函数——几乎总是矩形。所以我们可以把图像抽象成函数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910095400.png" class="" title="image-20210910095400">

<p><strong>其中R⊂R² 是矩形区域，V是可能像素值的集合。</strong></p>
<p><strong>如果一个图像有nx 列和n<em>y</em> 像素行，左下角像素为(0,0)，右上角像素为(nx-1,ny-1。我们需要2D真实屏幕坐标来指定像素位置。我们将像素的采样点放置在整数坐标上，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910102619.png" class="" title="image-20210910102619">

<h3 id="Pixel-Values-像素值"><a href="#Pixel-Values-像素值" class="headerlink" title="Pixel Values 像素值"></a>Pixel Values 像素值</h3><p><strong>表示图像中某一点的强度(可能分别表示红色、绿色和蓝色)。这表明图像应该是浮点数数组，其中一个(用于灰度或黑白图像)或三个(用于RGB彩色图像)。32位浮点数存储每个像素。</strong></p>
<p><strong>对于直接显示的图像，需要更小的范围。虽然理论上可能的光强度范围是无界的，但任何给定的设备都有一个绝对有限的最大强度，所以在许多情况下，像素有一个有界的范围是完全足够的，通常为简单起见，取为[0,1]。使用浮点数存储的图像允许使用大范围的值，通常称为高动态范围(HDR)图像，以区别于使用整数存储的固定范围或低动态范围(LDR)图像。</strong></p>
<p><strong>一些典型应用中的像素格式:</strong></p>
<p>​    <strong>1位灰度：不需要中间灰度的文本和其他图像(要求高分辨率);</strong></p>
<p>​    <strong>8位固定范围RGB(24位/像素)：网页和电子邮件应用程序、用户照片;</strong></p>
<p>​    <strong>8位或10位固定范围RGB(24-30位/像素)：数字接口到计算机显示器;</strong></p>
<p>​    <strong>12- 14位固定范围RGB(36-42位/像素)原始相机图像;</strong></p>
<p>​    <strong>16位固定范围RGB(48位/像素)：专业摄影和打印;用于固定范围图像处理的中间格式;</strong></p>
<p>​    <strong>16位固定范围灰度(16位/像素)：放射学和医学成像;</strong></p>
<p>​    <strong>16位“半精度”浮点RGB：HDR图像;实时渲染的中间格式;</strong></p>
<p>​    <strong>32位浮点RGB：软件渲染和HDR图像处理通用中间格式。</strong></p>
<p><strong>减少用于存储每个像素的比特数会导致图像中出现两种不同类型的伪影，或人为引入缺陷。当将亮度高于像素最大可表示值时，具有固定范围值的图像将产生剪切。当需要将像素值四舍五入到最接近的可表示值时，编码精度有限的图像会导致量化伪影或条带，从而在强度或颜色上引入可见的跳跃。在动画和视频中，条带可能是特别明显，在静态图像中，条带可能不是令人反感的，但当它们来回移动时，就变得非常明显。</strong></p>
<h3 id="Monitor-Intensities-and-Gamma-显示强度和伽马值"><a href="#Monitor-Intensities-and-Gamma-显示强度和伽马值" class="headerlink" title="Monitor Intensities and Gamma 显示强度和伽马值"></a>Monitor Intensities and Gamma 显示强度和伽马值</h3><p><strong>要想在监视器上生成正确的图像，必须了解两个关键问题。第一，监视器对于输入是非线性的。作为这种非线性的近似表征，监视器通常用γ(“伽马”)值来表征。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910104713.png" class="" title="image-20210910104713">

<p><strong>其中a为0到1之间的输入像素值。注意，a = 0映射到零强度，a = 1映射到最大强度，与γ值无关。用γ描述显示器的非线性只是一个近似值。</strong></p>
<p><strong>我们只需要用肉眼确定一个中间强度值，即可得到伽马值：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910105656.png" class="" title="image-20210910105656">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910105705.png" class="" title="image-20210910105705">

<p><strong>一旦我们知道了γ，我们就可以校正输入，使a = 0.5的值以介于黑色和白色之间的强度显示出来。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910105919.png" class="" title="image-20210910105919">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910105951.png" class="" title="image-20210910105951">

<p><strong>在需要控制精确强度的应用中，我们必须实际测量256种可能的强度，而这些强度在屏幕上的不同点可能是不同的，尤其是CRT。它们也可能随观察角度而变化。幸运的是，很少有应用需要如此精确的校准。</strong></p>
<h2 id="RGB-Color-RGB颜色"><a href="#RGB-Color-RGB颜色" class="headerlink" title="RGB Color RGB颜色"></a>RGB Color RGB颜色</h2><p><strong>大多数计算机图形图像是用红绿蓝(RGB)颜色定义的。RGB颜色是一个简单的空间，允许直接转换为大多数计算机屏幕的控件RGB颜色空间的基本思想是，颜色由三种原光混合显示:一种红、一种绿、一种蓝。灯光以一种附加的方式混合在一起。</strong></p>
<p><strong>在RGB加色混合中（显示器的颜色混合和现实的不同，现实中的为减色混合，比如黄+蓝=绿）：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910110654.png" class="" title="image-20210910110654">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910110707.png" class="" title="image-20210910110707">

<p><strong>“cyan（青色）”是蓝绿色，“magenta（品红）”是紫色。</strong></p>
<p><strong>如果我们允许将主光源从完全关闭(用像素值0表示)调暗到完全打开(用像素值1表示)，我们就可以创建所有可以在RGB监视器上显示的颜色。红色、绿色和蓝色像素值创建一个具有红色、绿色和蓝色轴的三维RGB颜色立方体。坐标轴的允许坐标范围从0到1。颜色立方体如图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910110951.png" class="" title="image-20210910110951">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910111125.png" class="" title="image-20210910111125">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210910111135.png" class="" title="image-20210910111135">

<p><strong>实际的RGB等级通常以量化的形式给出，之前讨论的灰度一样。每个组件都用一个整数指定。这些整数最常见的大小是每个字节，所以三个RGB组件都是0到255之间的整数。这三个整数总共占用三个字节，即24位。因此，拥有“24位颜色”的系统对于三种基本颜色中的每一种都有256种可能的级别。伽马校正问题也分别适用于每个RGB分量。</strong></p>
<h2 id="Alpha-Compositing-Alpha合成"><a href="#Alpha-Compositing-Alpha合成" class="headerlink" title="Alpha Compositing Alpha合成"></a>Alpha Compositing Alpha合成</h2><p><strong>通常我们只希望部分覆盖像素的内容。一个常见的例子发生在合成中，我们有一个背景，想要在它上面插入一个前景图像。对于前景中的不透明像素，我们只需替换背景像素。对于完全透明的前景像素，我们不改变背景像素。当前景对象具有部分透明区域(如玻璃)时，就会出现部分透明像素。但是，最常见的前景和背景必须混合的情况是，当前景对象仅部分覆盖像素时，要么是在前景对象的边缘，要么是在遥远的树的叶子之间存在亚像素洞。</strong></p>
<p><strong>将前景对象与背景对象混合所需的最重要的信息是像素覆盖，它告诉前景层覆盖的像素的比例。我们称这个分数为α。如果我们想要合成前景色c<em>f</em> 背景色c<em>b</em>，则前景所覆盖像素的比例为α，则可以使用该公式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210911103651.png" class="" title="image-20210911103651">

<p><strong>对于不透明的前景层，解释为前景对象覆盖像素矩形内的区域α，背景对象覆盖剩余区域，即(1−α)。透明层(把一幅画在玻璃或描图纸,使用透明漆),解释是,前景层块分数(1−α)的光通过背景和贡献一小部分α取代了删除自己的颜色。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210911103838.png" class="" title="image-20210911103838">

<p><strong>一个图像中所有像素的α值可以存储在一个单独的灰度图像中，这被称为alpha遮罩或透明度遮罩。或者信息可以存储为RGB图像中的第四个通道，在这种情况下称为alpha通道，图像可以称为RGBA图像。对于8位图像，每个像素占用32位，这在许多计算机体系结构中是一个方便的大小块。</strong></p>
<h3 id="图像存储"><a href="#图像存储" class="headerlink" title="图像存储"></a>图像存储</h3><p><strong>大多数RGB图像格式使用红、绿、蓝通道各8位。这将为一个百万像素的图像生成大约3兆字节的原始信息。为了减少存储需求，大多数图像格式都允许某种形式的压缩。在高水平上，这种压缩要么是无损的，要么是有损的。在无损压缩中没有信息被丢弃，而在有损系统中有些信息会不可恢复地丢失。流行的图像存储格式包括:</strong></p>
<p>​    <strong>jpeg：这种有损格式基于人眼视觉系统中的阈值对图像块进行压缩。这种格式适用于自然图像。</strong></p>
<p>​    <strong>tiff：这种格式最常用来保存二进制图像或无损压缩的8位或16位RGB，尽管还有许多其他选项。</strong></p>
<p>​    <strong>ppm：对于8位RGB图像，尽管存在许多选项，这种非常简单、无损、未压缩的格式是最常用的。</strong></p>
<p>​    <strong>png：这是一组带有一组好的开源处理工具的无损格式。</strong></p>
<p><strong>由于压缩和变形，可能会涉及到为图像编写输入/输出例程。幸运的是，人们通常可以依靠库例程来读写标准文件格式。对于简单性高于效率的快速应用程序，一个选择是使用原始ppm文件，通常可以简单地通过将存储在内存中的映像的数组转储到一个文件中，并在适当的头文件之前进行编写。</strong></p>
<h1 id="4-Ray-Tracing-光线追踪"><a href="#4-Ray-Tracing-光线追踪" class="headerlink" title="4 Ray Tracing 光线追踪"></a>4 Ray Tracing 光线追踪</h1><p><strong>从根本上说，显示是一个以一组对象作为输入，并产生一个像素数组作为输出的过程。无论如何，渲染涉及到考虑每个对象对每个像素的贡献;它可以有两种一般的组织方式。在对象顺序呈现中，依次考虑每个对象，并为每个对象查找和更新其影响的所有像素。在图像顺序绘制中，依次考虑每个像素，为每个像素找到所有影响它的对象，并计算像素值。你可以从循环嵌套的角度来考虑它们的不同:在图像顺序中，“for each pixel”循环在外部，而在对象顺序中，“for each object”循环在外部。</strong></p>
<p><strong>图像顺序和对象顺序的渲染方法可以计算完全相同的图像，但它们适用于计算不同类型的效果，并且具有非常不同的性能特征。</strong></p>
<p><strong>光线追踪是一种用于3D场景渲染的图像顺序算法，我们首先考虑它，因为它可以让光线追踪器在不开发任何用于对象顺序渲染的数学机制的情况下工作。</strong></p>
<h2 id="The-Basic-Ray-Tracing-Algorithm-基本的光线追踪算法"><a href="#The-Basic-Ray-Tracing-Algorithm-基本的光线追踪算法" class="headerlink" title="The Basic Ray-Tracing Algorithm 基本的光线追踪算法"></a>The Basic Ray-Tracing Algorithm 基本的光线追踪算法</h2><p>光线追踪的工作原理是每次计算一个像素，对于每个像素，基本任务是找到在图像中该像素位置所看到的物体。每个像素“看”一个不同的方向，像素所看到的任何物体都必须与视点射线相交，视点射线是从像素所看到的方向发出的线。我们想要的特定物体是与距离相机最近的观察光线相交的那个，因为它挡住了它后面任何其他物体的视线。一旦找到对象，着色计算使用交点、表面法线和其他信息(取决于所需的渲染类型)来确定像素的颜色。如图所示，射线与两个三角形相交，但只有第一个三角形T2击中被着色。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210911105743.png" class="" title="image-20210911105743">

<p><strong>因此，一个基本的光线追踪有三个部分:</strong></p>
<p>​    <strong>1.射线生成，根据相机几何形状计算每个像素的观察射线的原点和方向;</strong></p>
<p>​    <strong>2.射线相交，找到与观察射线相交的最近的物体;</strong></p>
<p>​    <strong>3.着色，根据光线相交的结果计算像素的颜色。</strong></p>
<p><strong>基本光线追踪程序的结构如下:</strong></p>
<p><img src="C:\Users\86010\AppData\Roaming\Typora\typora-user-images\image-20210911110053834.png" alt="image-20210911110053834"></p>
<h2 id="Perspective-透视"><a href="#Perspective-透视" class="headerlink" title="Perspective 透视"></a>Perspective 透视</h2><p><strong>在电脑出现之前的几百年，艺术家们就研究过用2D图纸或绘画来表示3D物体或场景的问题。计算机图形学中,是线性的角度来看,3D对象的投影到图像平面上,这样在场景成为平面图像。</strong></p>
<p><strong>最简单的投影类型是平行投影，即将3D点沿投影方向移动，直到它们到达图像平面，将它们映射到2D。所产生的视图由投影方向和像面的选择决定。如果平面是垂直的视图方向，投影称为正交投影;否则就叫斜投影。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912091708.png" class="" title="image-20210912091708">

<p>当投影线与像平面平行且垂直时，得到的视图称为正射影。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912091734.png" class="" title="image-20210912091734">

<p>成像面与投影方向成角的平行投影称为斜投影(右)。在透视投影中，投影线全部通过视点，而不是平行(左)。图示的透视图是非斜角的，因为通过图像中心绘制的投影线将垂直于图像平面。</p>
<p><strong>平行投影经常用于机械和建筑图纸，因为它们使平行线保持平行，并保持与图像平面平行的平面物体的大小和形状。</strong></p>
<p><strong>平行投影的优点也是它的局限性。在我们的日常经验中(在照片中更是如此)，物体越远，看起来越小，因此，后退到远处的平行线就不显得平行。这是因为眼睛和相机不会收集单一观看方向的光线;它们收集通过特定视点的光线。正如文艺复兴以来的艺术家们所承认的那样，我们可以使用透视投影来产生自然的视觉效果:我们只是沿着穿过一个点的直线投影，而不是沿着平行线。这样，远离视点的物体在被投射时自然变小。透视图是由视点(而不是投影方向)和图像平面的选择决定的。与平行视图一样，也有斜透视视图和非斜透视视图;根据图像中心的投影方向来区分。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912092302.png" class="" title="image-20210912092302">

<p>在三点透视中，艺术家选择平行线相交的“消失点”。平行的水平线在地平线上相交于一点。每一组平行线都有它自己的消失点。如果我们基于正确的几何原理实现透视，这些规则会自动遵循。</p>
<p><strong>您可能已经了解了三点透视图的艺术约定，这是一个手动构建透视图的系统。关于透视法，一个令人惊讶的事实是，如果我们遵循透视法背后的简单数学规则，那么所有的透视法绘制规则都会自动遵循:物体直接投射到眼睛，然后在眼睛前面的视场平面上绘制。</strong></p>
<h2 id="Computing-Viewing-Rays-计算可视光线"><a href="#Computing-Viewing-Rays-计算可视光线" class="headerlink" title="Computing Viewing Rays 计算可视光线"></a>Computing Viewing Rays 计算可视光线</h2><p><strong>为了生成光线，我们首先需要光线的数学表示。光线其实就是原点和传播方向;一个三维参数线是理想的。从眼e到图像平面上点s的三维参数线为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912095224.png" class="" title="image-20210912095224">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912093756.png" class="" title="image-20210912093756">

<p><strong>这应该解释为，“我们从e沿着向量(s - e)的一个分量距离t前进，找到点p。”已知t，我们可以确定点p，点e是光线的原点，点s - e是光线的方向。</strong></p>
<p>*<em>请注意，p(0) = e, p(1) = s，更一般地说，如果0 &lt; t1 <em>&lt; t</em>2,那么p (t1)比p(t2)更靠近眼睛。同样，如果t &lt; 0，那么p(t)在眼睛后面。当我们搜索光线击中的离眼睛最近的物体时，这些事实会很有用。</em>*</p>
<p><strong>为了计算观察光线，我们需要知道e(给定的)和s。找到s可能看起来很困难，但如果我们在正确的坐标系下看问题，它实际上是简单的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912095348.png" class="" title="image-20210912095348">

<p><strong>我们所有的光线产生是从一个标准正交坐标系开始的，称为相机视图，我们用e表示眼睛的点或者观察点，使用u, v,w三个基向量，u指向向右(从相机的视图),v朝上,和w指向后方,所以{u, v, w}形成了一个右手坐标系。最常见的方式是用相机作为视点e，v、w定义了视图方向和向上方向。</strong></p>
<h3 id="Orthographic-Views-正交视图"><a href="#Orthographic-Views-正交视图" class="headerlink" title="Orthographic Views 正交视图"></a>Orthographic Views 正交视图</h3><p><strong>对于正交视图，所有光线的方向为- w。即使平行视图本身没有视点，我们仍然可以使用相机视图的原点来定义光线开始的位置，这样物体就有可能在相机后面。</strong></p>
<p><strong>观察光线应该从点e和向量u、v定义的平面开始;所需的唯一剩余信息是映像应该在平面上的哪个位置。我们将用四个数字定义图像的维度，用于图像的四个边:l和r是图像左右边缘的位置，从e沿着u方向测量;b和t是图像上边缘和下边缘的位置，从e沿v方向测量。通常l &lt; 0 &lt; r, b &lt; 0 &lt; t。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912100126.png" class="" title="image-20210912100126">

<p>光线生成使用相机视图。左:在正投影视图中，光线从图像平面上的像素位置开始，并且共享同一个方向，与视图方向相同。右:在透视图中，光线从视点开始，每条光线的方向由通过视点e的直线和像素在图像平面上的位置定义。</p>
<p><strong>用n来拟合图像nx ×ny像素分成大小为(r - l) × (t - b)的矩形，像素水平距离为(r - l)/n<em>x</em> 和垂直距离为(t - b)/ny，在边缘周围用半像素空间将图像矩形内的像素网格居中。这意味着在光栅图像中位于(i, j)位置的像素具有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912100649.png" class="" title="image-20210912100649">

<p><strong>其中(u, v)为像素在像面上的位置坐标，相对于原点e和基{u, v}度量。</strong></p>
<p><strong>在正交视图中，我们可以简单地使用像素的图像平面位置作为光线的起始点，并且我们已经知道光线的方向就是视图的方向。构造正交视图光线的步骤如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912101040.png" class="" title="image-20210912101040">

<p><strong>制作斜平行视图非常简单:只需要将图像平面法线w与视图方向d分开指定即可。接下来的过程完全相同，只是将d替换为−w。当然，w仍然被用来构造u和v。</strong></p>
<h3 id="Perspective-Views-透视视图"><a href="#Perspective-Views-透视视图" class="headerlink" title="Perspective Views 透视视图"></a>Perspective Views 透视视图</h3><p><strong>对于透视图，所有光线在视点处都有同一个原点;它是每个像素不同的方向。像平面不再位于e处，而是位于e前的某一距离d处;这个距离就是像面的距离，通常称为焦距，因为选择d和在真实相机中选择焦距起着相同的作用。每条光线的方向由视点和像素在图像平面上的位置定义。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912101518.png" class="" title="image-20210912101518">

<p><strong>构造过程为：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210912101636.png" class="" title="image-20210912101636">

<p><strong>与平行投影一样，通过在投影方向上单独指定图像平面法线，将射线方向表达式中的−d w替换为dd，可以实现斜透视视图。</strong></p>
<h2 id="Ray-Object-Intersection-光线与对象相交"><a href="#Ray-Object-Intersection-光线与对象相交" class="headerlink" title="Ray-Object Intersection 光线与对象相交"></a>Ray-Object Intersection 光线与对象相交</h2><h3 id="Ray-Sphere-Intersection-光线与球相交"><a href="#Ray-Sphere-Intersection-光线与球相交" class="headerlink" title="Ray-Sphere Intersection 光线与球相交"></a>Ray-Sphere Intersection 光线与球相交</h3><p><strong>给定一条射线p(t) = e + td和一个隐式曲面f(p) = 0，我们想知道它们的交点。当射线上的点满足隐式方程时就会出现交点，所以我们求的t值就是解方程的值</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102437.png" class="" title="image-20210913102437">

<p><strong>圆心为c = (xc，yc, zc)，半径R可由隐式方程表示</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102530.png" class="" title="image-20210913102530">

<p><strong>我们可以把这个方程写成向量形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102540.png" class="" title="image-20210913102540">

<p><strong>任何满足这个方程的点p都在球面上。如果我们把射线p(t) = e + td的点代入这个方程，我们得到一个关于t的方程，这个方程由球上屈服点的t值满足:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102716.png" class="" title="image-20210913102716">

<p><strong>整理得</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913102823.png" class="" title="image-20210913102823">

<p><strong>这里，除了参数t，其他都是已知的，所以这是一个经典的关于t的二次方程，如果判别式为负，则其平方根为虚数，且线与球不相交。如果判别式是正的，就有两个解一个是光线进入球面的解另一个是光线离开球面的解。如果判别式为零，射线就会擦过球体，恰好接触到一点。</strong></p>
<p><strong>在实际实现中，在计算其他项之前，应该首先检查该判别符的值。如果球体只是用作更复杂物体的边界对象，那么我们只需要确定我们是否击中它。</strong></p>
<h3 id="Ray-Triangle-Intersection-光线与三角形相交"><a href="#Ray-Triangle-Intersection-光线与三角形相交" class="headerlink" title="Ray-Triangle Intersection 光线与三角形相交"></a>Ray-Triangle Intersection 光线与三角形相交</h3><p><strong>有许多计算光线与三角形交点的算法。我们将给出包含三角形的参数平面使用重心坐标的形式，因为除了三角形的顶点之外，它不需要长期存储。</strong></p>
<p><strong>为了使光线与参数曲面相交，我们建立一个笛卡尔坐标完全匹配的方程组:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913103452.png" class="" title="image-20210913103452">

<p><strong>这里，我们有三个方程和三个未知数(t, u, v)所以我们可以用数值方法求解这些未知数。如果幸运的话，我们可以用解析法解出来。</strong></p>
<p><strong>当参数曲面为参数平面时，参数方程可以写成向量形式，如果三角形的顶点是a、b、c，那么可表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913103652.png" class="" title="image-20210913103652">

<p><strong>对于某些t， β和γ。交点p将在e+td处，如图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913103900.png" class="" title="image-20210913103900">

<p>光线击中的点p在包含三角形的平面</p>
<p><strong>同样，我们知道，当且仅当β &gt; 0， γ &gt; 0，和β + γ &lt; 1时，交点在三角形内。否则，光线击中了三角形外的平面，所以没有击中三角形。如果没有解，要么三角形退化（面积为0），要么射线平行于包含三角形的平面。</strong></p>
<p><strong>为了求解式中的t， β， γ，我们将其从矢量形式展开为三个坐标下的三个方程:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104319.png" class="" title="image-20210913104319">

<p><strong>这可以写成一个标准线性形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104331.png" class="" title="image-20210913104331">

<p><strong>求解这个3 × 3线性方程组最快的经典方法是克莱默法则。这就得出解</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104345.png" class="" title="image-20210913104345">

<p><strong>而矩阵A为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104710.png" class="" title="image-20210913104710">

<p><strong>而|A|表示A的行列式。3×3行列式有可以利用的公共子项。有哑变量的线性系统形式为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104913.png" class="" title="image-20210913104913">

<p><strong>使用克拉默法则</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104930.png" class="" title="image-20210913104930">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913104941.png" class="" title="image-20210913104941">

<p><strong>我们可以通过重复使用“ei-minus-hf”等数字来减少操作次数。</strong></p>
<p><strong>对于需要线性解的射线三角形交，算法可以有提前终止的条件。因此，函数应该如下所示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913105121.png" class="" title="image-20210913105121">

<h3 id="Ray-Polygon-Intersection-光线与多边形相交"><a href="#Ray-Polygon-Intersection-光线与多边形相交" class="headerlink" title="Ray-Polygon Intersection 光线与多边形相交"></a>Ray-Polygon Intersection 光线与多边形相交</h3><p><strong>给定一个具有m个顶点的平面多边形p1 通过p<em>m</em> 有曲面法线n，我们首先用隐式方程计算出射线e + td与包含多边形的平面的交点</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913105722.png" class="" title="image-20210913105722">

<p><strong>我们通过设p = e + td并解出t来得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913105732.png" class="" title="image-20210913105732">

<p><strong>这允许我们计算p。如果p在多边形内部，那么光线就会击中它;否则，它就不存在。</strong></p>
<p><strong>我们可以通过将点和多边形顶点投影到xy平面来得知p是否在多边形内的问题。最简单的方法是从p发出任何2D射线，并计数射线与多边形边界之间的交点数量如果交点数为奇数，则该点位于多边形内;否则就不是。因为光线进入一定会出去，从而创造了一对交点。只有从内部开始的光线才不会产生这样的一对。为了简化计算，2D射线也可以沿x轴传播:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913110022.png" class="" title="image-20210913110022">

<p><strong>计算光线与边的交点很简单，比如</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913110131.png" class="" title="image-20210913110131">

<p><strong>然而，当多边形在xy平面上的投影是一条直线时，问题就出现了。为了解决这个问题，我们可以在xy, yz或zx平面中选择一个最好的。如果我们实现点来允许索引操作，例如，p(0) = xp 然后，这可以实现如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913110149.png" class="" title="image-20210913110149">

<p><strong>现在，所有的计算都可以使用p(index0)而不是xp，等。</strong></p>
<p><strong>另一种处理多边形的方法，也是实践中经常使用的方法，是用几个三角形来替换它们。</strong></p>
<h3 id="Intersecting-a-Group-of-Objects-一组对象相交"><a href="#Intersecting-a-Group-of-Objects-一组对象相交" class="headerlink" title="Intersecting a Group of Objects 一组对象相交"></a>Intersecting a Group of Objects 一组对象相交</h3><p><strong>当然，场景包含不止一个物体，当我们将光线与场景相交时，我们必须沿着光线找到离摄像机最近的交点。实现这一点的一个简单方法是将一组对象本身视为另一种类型的对象。要使射线与组相交，只需将射线与组中的物体相交，并返回t值最小的交点。以下代码对区间t∈[t0, t1]的命中情况进行测试:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913110834.png" class="" title="image-20210913110834">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913111038.png" class="" title="image-20210913111038">

<p>一个简单的场景渲染，只有光线生成和表面交叉，但没有阴影;每个像素都被设置为固定的颜色，这取决于它击中的对象。</p>
<h2 id="Shading-着色"><a href="#Shading-着色" class="headerlink" title="Shading 着色"></a>Shading 着色</h2><p><strong>一旦已知像素的可见表面，像素值就通过评估着色模型来计算。如何做到这一点完全取决于应用方法，从非常简单的启发式到详细的数值计算。</strong></p>
<p><strong>大多数底纹模型，不管怎样，都是为了捕捉光线反射的过程而设计的，即表面被光源照亮，并将部分光线反射到相机上。简单的着色模型是根据点光源的照明来定义的。光反射的重要变量是光的方向l，它是指向光源的单位矢量;视图方向v，是指向眼睛或相机的单位矢量;表面法向量n，是垂直于反射点的单位向量;以及表面的特性——颜色、光泽或其他属性，取决于特定的模型。</strong></p>
<h3 id="Lambertian-Shading-Lambertian着色"><a href="#Lambertian-Shading-Lambertian着色" class="headerlink" title="Lambertian Shading Lambertian着色"></a>Lambertian Shading Lambertian着色</h3><p><strong>最简单的阴影模型是基于Lambert在18世纪所做的观察:光源照射在一个表面上的能量取决于该表面与光线的角度。直接面向光的表面得到最大的照明;与光方向相切的表面(或背向光的表面)没有受到光照;在两者之间，照度与表面法线与光源夹角θ的余弦成正比。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913111812.png" class="" title="image-20210913111812">

<p><strong>这就引出了lambert着色模型:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913111634.png" class="" title="image-20210913111634">

<p><strong>式中，L为像素颜色;Kd为扩散系数，或表面颜色;其中，I为光源强度。因为n和l是单位向量，我们可以用n·l作为cos θ的简写(无论是在纸上还是在代码中)。这个方程(与本节中的其他着色方程一样)分别适用于三种颜色通道，因此像素值的红色分量是红色漫反射分量、红色光源强度和点积的乘积;绿色和蓝色也是如此。</strong></p>
<p><strong>向量l的计算方法是用光源位置减去光线和表面的交点。别忘了v，l，n都是单位向量;在着色计算不归一化这些向量是一个非常常见的错误。</strong></p>
<h3 id="Blinn-Phong-Shading-Blinn-Phong着色"><a href="#Blinn-Phong-Shading-Blinn-Phong着色" class="headerlink" title="Blinn-Phong Shading Blinn-Phong着色"></a>Blinn-Phong Shading Blinn-Phong着色</h3><p><strong>Llambert着色是独立于视图的:表面的颜色不依赖于你观察的方向。许多真实的表面显示出一定程度的光泽，产生高光，或镜面反射，似乎随着视点的变化而移动。Lambert着色不产生任何高光，导致非常哑光，白垩色的外观，和许多着色模型添加一个高光组件到Lambert着色;Lambert部分就是漫反射部分。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913112456.png" class="" title="image-20210913112456">

<p>左：一个简单的场景，由单一光源的漫反射着色渲染。中：一个简单的场景，由三个光源渲染漫反射着色和阴影。一个简单的场景，由三个光源渲染，漫反射着色(蓝色球体)，Blinn- Phong着色(绿色球体)。</p>
<p><strong>Phong (Phong, 1975)提出了一个非常简单和广泛使用的高光模型，后来由Blinn (J. F. Blinn, 1976)更新为今天最常用的形式。这个想法是为了在v和l对称地穿过表面法线时产生最亮的反射，也就是镜面反射发生的时候;当矢量离开镜面结构时，反射平滑地减小。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913112507.png" class="" title="image-20210913112507">

<p><strong>通过比较半矢量h (v和l之间角的平分线)与表面法线，我们可以知道我们与镜面结构的距离有多近。如果半矢量接近表面法线，镜面分量应该是明亮的;如果是遥远的应该是昏暗的。这个结果是通过计算的点积h和n(记住他们是单位向量,所以n·h达到最大1当向量相等),然后把结果功率p &gt; 1,使其减少得更快。功率，或Phong指数，控制表面的表面光泽。半矢量本身很容易计算:因为v和l长度相同，它们的和是一个平分它们之间夹角的矢量，这个夹角只需要标准化就能得到h。</strong></p>
<p><strong>综上所述，Blinn-Phong阴影模型如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913112519.png" class="" title="image-20210913112519">

<p><strong>其中ks是镜面的镜面系数或镜面颜色。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913122738.png" class="" title="image-20210913122738">

<h3 id="Ambient-Shading-Ambient着色"><a href="#Ambient-Shading-Ambient着色" class="headerlink" title="Ambient Shading Ambient着色"></a>Ambient Shading Ambient着色</h3><p><strong>没有任何照明的表面将被渲染成完全黑色，这通常是不可取的。避免黑影的一个粗略但有用的启发式方法是在着色模型中添加一个常量组件，它对像素颜色的贡献只取决于击中的对象，而完全不依赖于表面几何形状。这就是所谓的环境着色——就好像表面被来自各处的“环境”光照亮一样。为了方便调整参数，环境着色通常表示为表面颜色与环境光颜色的乘积，因此环境着色可以单独调整表面，也可以一起调整所有表面。与Blinn-Phong模型的其余部分一起，环境着色完成了一个简单和有用的着色模型的完整版本:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913122200.png" class="" title="image-20210913122200">

<p><strong>ka是表面的环境系数，或“环境色”，a 为环境光强度。</strong> </p>
<h3 id="Multiple-Point-Lights-多点光源"><a href="#Multiple-Point-Lights-多点光源" class="headerlink" title="Multiple Point Lights 多点光源"></a>Multiple Point Lights 多点光源</h3><p><strong>光的一个非常有用的特性是叠加——由多个光源引起的效应仅仅是光源各自效应的总和。由于这个原因，我们简单的着色模型可以很容易地扩展到处理N个光源:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210913122212.png" class="" title="image-20210913122212">

<p><strong>Ii,li，hi是i^th光源的强度，方向和半矢量。</strong></p>
<h2 id="A-Ray-Tracing-Program-一个光线追踪程序"><a href="#A-Ray-Tracing-Program-一个光线追踪程序" class="headerlink" title="A Ray-Tracing Program 一个光线追踪程序"></a>A Ray-Tracing Program 一个光线追踪程序</h2><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914132257.png" class="" title="image-20210914132257">

<p><strong>在实际的实现中，曲面相交程序需要以某种方式返回被击中对象的引用，或者至少返回其法向量和着色相关的材质属性。这通常通过传递带有此类信息的记录/结构来实现。在面向对象的实现中，有一个叫做surface的类和派生类triangle, sphere, group等是一个好主意。射线可以相交的任何东西都在这个范围内。光线追踪程序将有一个参考“表面”为整个模型，新类型的对象和效率结构可以更加明显。</strong></p>
<h3 id="Object-Oriented-Design-for-a-Ray-Tracing-Program-面向对象设计的光线追踪程序"><a href="#Object-Oriented-Design-for-a-Ray-Tracing-Program-面向对象设计的光线追踪程序" class="headerlink" title="Object-Oriented Design for a Ray-Tracing Program 面向对象设计的光线追踪程序"></a>Object-Oriented Design for a Ray-Tracing Program 面向对象设计的光线追踪程序</h3><p><strong>如前所述，光线追踪的关键类层次结构是构成模型的几何对象。这些应该是一些几何对象类的子类，并且它们应该支持一个hit函数。为了避免使用“对象”这个词造成混淆，经常使用的类名是surface。有了这样一个类，您可以创建一个具有通用接口的光线跟踪器，该接口对建模原语的假设很少，只使用球体调试它。重要的一点是，任何可以被光线“击中”的东西都应该是这个类层次的一部分，例如，即使是曲面的集合也应该被认为是曲面类的子类。这包括效率结构，如边界体积层次;它们可以被射线击中，所以它们在类里。</strong></p>
<p><strong>例如，“抽象”或“基”类将指定hit函数以及一个稍后将证明有用的边界框函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914133203.png" class="" title="image-20210914133203">

<p><strong>在这里(t0，t1)是射线上返回命中值的间隔，而rec是通过引用传递的记录;它包含数据，例如hit返回true时交集处的t。该类型框是一个3D“边界框”，即两个点定义了一个轴对齐的框，该框包围了曲面。例如，对于一个球体，函数为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914133320.png" class="" title="image-20210914133320">

<p><strong>另一个有用的类是material。这允许你抽象材质的行为，然后添加透明的材质。链接对象和材质的一个简单方法是在surface类中添加一个指向材质的指针，尽管可能需要更多的可编程行为。</strong></p>
<h2 id="Shadows-阴影"><a href="#Shadows-阴影" class="headerlink" title="Shadows 阴影"></a>Shadows 阴影</h2><p><strong>一旦你有了一个基本的光线追踪程序，阴影就可以很容易地添加。光来自于某个方向l。如果我们想象我们自己在一个被阴影覆盖的表面上的点p，如果我们朝l方向“看”，看到一个物体，这个点就处于阴影中。如果没有物体，那么光线就不会被阻挡。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914133653.png" class="" title="image-20210914133653">

<p>p点不在阴影中，而q点在阴影中。</p>
<p><strong>如图所示，光线p + tl没有击中任何物体，因此不在阴影中。点q在阴影中，因为光线q + tl确实击中了一个物体。这两个点的向量l是相同的，因为光线“很远”。这一假设稍后将被放宽。决定在阴影内或阴影外的光线称为阴影光线，以区别于观察光线。</strong></p>
<p><strong>为了得到阴影的算法，我们添加了一个if语句来确定点是否在阴影中。在简单的实现中，阴影射线将检查t∈[0，∞]，但由于数值不精确，这可能导致与p所在的曲面相交。相反，为了避免这个问题，通常的调整是检验t∈[E，∞)，E其中有一个小的正常数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914134040.png" class="" title="image-20210914134040">

<p>通过在从E开始的区间内测试，我们避免了数值不精确导致射线击中表面p。</p>
<p><strong>如果我们使用着色方程为Phong照明实现阴影光线，那么我们有以下结果:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210914134052.png" class="" title="image-20210914134052">

<p><strong>注意，无论p是否在阴影中，环境色都是添加的。如果有多个光源，我们可以在评估每个光源的着色模型之前发送阴影射线。上面的代码假设d和l不一定是单位向量。这对于d是至关重要的，特别是，如果我们希望在以后干净利落地添加实例化。</strong></p>
<h2 id="Ideal-Specular-Reflection-理想的镜面反射"><a href="#Ideal-Specular-Reflection-理想的镜面反射" class="headerlink" title="Ideal Specular Reflection 理想的镜面反射"></a>Ideal Specular Reflection 理想的镜面反射</h2><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210915103352.png" class="" title="image-20210915103352">

<p><strong>将理想的镜面反射添加到光线追踪程序中是很简单的。关键观察如图所示，观测者从e方向观察时，可以看到从表面上观察到的r方向的东西。矢量r是使用Phong照明反射方程的一个变体来发现的。整理符号发生了变化，因为在这种情况下，矢量d指向曲面，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210915103521.png" class="" title="image-20210915103521">

<p><strong>在现实世界中，当光线从表面反射时，一些能量会损失，而这种损失会因颜色的不同而不同。例如，与蓝色相比，金色反射黄色的效率更高，所以它会改变所反射物体的颜色。这可以通过在raycolor中添加递归调用来实现:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210915103634.png" class="" title="image-20210915103634">

<p><strong>km (为“镜面反射”)是镜面的RGB颜色。我们需要确保∈[E，∞)的原因与我们测试阴影射线的原因相同;我们不希望反射光线击中产生它的物体。</strong></p>
<p><strong>上面递归调用的问题是它可能永远不会终止。例如，如果光线从房间内部开始，它将永远反弹。这可以通过增加最大递归深度来解决。如果只在km不是零(黑色)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210915103843.png" class="" title="image-20210915103843">

<p>一个简单的场景渲染漫反射和Blinn-Phong阴影，阴影来自三个光源，镜面反射来自地板。</p>
<h2 id="Historical-Notes-发展历程"><a href="#Historical-Notes-发展历程" class="headerlink" title="Historical Notes 发展历程"></a>Historical Notes 发展历程</h2><p><strong>光线追踪在计算机图形学的早期发展(Appel, 1968)，但直到有足够的计算能力(Kay &amp; Greenberg, 1979;Whitted,1980)。</strong></p>
<p><strong>光线跟踪具有比基本对象顺序渲染更低的渐近时间复杂度(Snyder &amp; Barr, 1987;Muuss,1995;S. Parker等人，1999;Wald, Slusallek, Benthin， &amp; Wagner, 2001)。尽管传统上认为作为一种离线的方法，实时光线追踪的实现变得越来越普遍。</strong> </p>
<h1 id="5-Linear-Algebra-线性代数"><a href="#5-Linear-Algebra-线性代数" class="headerlink" title="5 Linear Algebra 线性代数"></a>5 Linear Algebra 线性代数</h1><h2 id="Determinants-行列式"><a href="#Determinants-行列式" class="headerlink" title="Determinants 行列式"></a>Determinants 行列式</h2><p><strong>我们通常认为行列式是在线性方程的解中产生的。然而，为了我们的目标，我们把行列式看作是向量相乘的另一种方法。对于二维向量a和b，行列式|ab|为a和b形成的平行四边形的面积。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916104715.png" class="" title="image-20210916104715">

<p><strong>这是一个有符号的区域，如果a和b是右手坐标系，这个符号是正的，如果它们是左手坐标系，这个符号是负的。这意味着|ab| =−|ba|。在2D中，我们可以将“右手坐标系”解释为逆时针旋转第一个向量，使其与第二个向量形成最小的角度。在三维空间中，行列式必须一次取三个向量。为三个三维向量，a, b，和c，行列式|abc|是平行六面体（三维平行四边形）。为了计算一个二维行列式，我们首先需要确定它的一些性质。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105042.png" class="" title="image-20210916105042">

<p><strong>我们注意到，对平行四边形的一侧进行缩放，其面积也会以同样的比例缩放):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105236.png" class="" title="image-20210916105236">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105246.png" class="" title="image-20210916105246">

<p><strong>另外，我们注意到“剪切”平行四边形不会改变它的面积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105603.png" class="" title="image-20210916105603">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105616.png" class="" title="image-20210916105616">

<p><strong>最后，我们看到行列式有以下性质:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105731.png" class="" title="image-20210916105731">

<p><strong>如图所示，我们可以“滑动”两个平行四边形之间的边，形成一个单独的平行四边形，而不改变原来两个平行四边形中的任何一个的面积。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916105758.png" class="" title="image-20210916105758">

<p><strong>现在让我们用a和b的笛卡尔坐标表示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110021.png" class="" title="image-20210916110021">

<p><strong>这种简化使用了|vv| = 0，对于任何向量v，因为平行四边形都将与v共线，因此没有面积。</strong></p>
<p><strong>在三维空间中，三个三维向量a、b、c的行列式记为|abc|。有了向量的笛卡尔表示，平行六面体也有类似的规则平行四边形也有类似的规则，我们可以做一个类似的展开，就像在2D中做的那样:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110125.png" class="" title="image-20210916110125">

<p><strong>随着维数的增加，这种方式的行列式的计算变得越来越复杂。我们将在第5.3节讨论不易出错的计算行列式的方法。</strong></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h3><p><strong>当把一个向量表示成另外两个向量的线性组合时，行列式很自然地出现了。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110530.png" class="" title="image-20210916110530">

<p><strong>例如，如果我们想把一个向量c表示成向量a和b的组合:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110356.png" class="" title="image-20210916110356">

<p><strong>从图可以看出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110557.png" class="" title="image-20210916110557">



<p><strong>因为这些平行四边形只是彼此的剪切版本。得出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110647.png" class="" title="image-20210916110647">

<p><strong>一个类似得出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916110659.png" class="" title="image-20210916110659">

<p><strong>这是克莱默规则的二维版本，我们将在第5.3.2节重新讨论。</strong></p>
<h2 id="Matrices-矩阵"><a href="#Matrices-矩阵" class="headerlink" title="Matrices 矩阵"></a>Matrices 矩阵</h2><p><strong>矩阵是遵循一定算术规则的数字元素数组。矩阵在计算机图形学中经常用于各种目的，包括表示空间变换。为了便于讨论，我们假设矩阵的元素都是实数。</strong></p>
<h3 id="Matrix-Arithmetic-矩阵的运算规则"><a href="#Matrix-Arithmetic-矩阵的运算规则" class="headerlink" title="Matrix Arithmetic 矩阵的运算规则"></a>Matrix Arithmetic 矩阵的运算规则</h3><p><strong>一个矩阵乘以一个常数得到一个矩阵，其中每个元素都乘以那个常数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916111628.png" class="" title="image-20210916111628">

<p><strong>矩阵相加等于，一个元素一个元素地相加</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916111638.png" class="" title="image-20210916111638">

<p><strong>对于矩阵乘法，我们将第一个矩阵的行与第二个矩阵的列相乘</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916111855.png" class="" title="image-20210916111855">

<p><strong>所以元素pij 的乘积是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916111936.png" class="" title="image-20210916111936">

<p><strong>只有当左矩阵的列数与右矩阵的行数相同时，才能取两个矩阵的乘积。</strong></p>
<p><strong>矩阵乘法在大多数情况下是不可交换的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112037.png" class="" title="image-20210916112037">

<p><strong>此外，如果AB = AC，也不一定就得出B = C。但是，矩阵乘法是结合性和分配性的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112129.png" class="" title="image-20210916112129">

<h3 id="Operations-on-Matrices-矩阵的性质"><a href="#Operations-on-Matrices-矩阵的性质" class="headerlink" title="Operations on Matrices 矩阵的性质"></a>Operations on Matrices 矩阵的性质</h3><p><strong>单位矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112250.png" class="" title="image-20210916112250">

<p><strong>逆矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112335.png" class="" title="image-20210916112335">

<p><strong>例如</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112347.png" class="" title="image-20210916112347">

<p><strong>有性质：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112518.png" class="" title="image-20210916112518">

<p><strong>转置矩阵，形如</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112743.png" class="" title="image-20210916112743">

<p><strong>有性质：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112832.png" class="" title="image-20210916112832">

<p><strong>行列式与矩阵运算有几个很好的性质:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916112844.png" class="" title="image-20210916112844">

<h3 id="Vector-Operations-in-Matrix-Form-矩阵的向量运算"><a href="#Vector-Operations-in-Matrix-Form-矩阵的向量运算" class="headerlink" title="Vector Operations in Matrix Form 矩阵的向量运算"></a>Vector Operations in Matrix Form 矩阵的向量运算</h3><p><strong>在图形学中，我们使用方阵来变换以矩阵表示的向量。例如，如果有一个2D向量a = (xa，ya)并想绕原点旋转90度以形成向量a′=(−ya, xa)，您可以使用2×2矩阵和2×1矩阵的乘积，称为列向量。矩阵中的运算形式是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113455.png" class="" title="image-20210916113455">

<p><strong>我们可以得到同样的结果，使用这个矩阵的转置，并在左边与行向量相乘:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113504.png" class="" title="image-20210916113504">

<p><strong>现在，使用列向量的后乘法是相当标准的，但在许多旧的书籍和系统中，您会遇到行向量和前乘法。唯一的区别是变换矩阵必须用它的转置来替换。</strong></p>
<p><strong>我们也可以用矩阵形式来对向量上的运算进行编码。如果我们把点积的结果看成一个1 × 1矩阵，它可以写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113618.png" class="" title="image-20210916113618">

<p><strong>举个例子，如果我们取两个三维向量</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113632.png" class="" title="image-20210916113632">

<p><strong>一个相关的向量乘积是两个向量的外积，它可以表示为一个矩阵与左边的列向量和右边的行向量的乘积:ab^T．结果是一个矩阵由a元素和b元素的所有对的乘积组成，对于三维向量，我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113743.png" class="" title="image-20210916113743">

<p><strong>用向量运算来考虑矩阵乘法通常是有用的。为了说明使用三维的情况，我们可以把3 × 3矩阵看作是三个三维向量的集合，有两种方式:一种是由三个并排的列向量组成，另一种是由三个堆叠起来的行向量组成。例如，矩阵与向量y = Ax相乘的结果可以解释为一个向量，其元素是x与A的行数的点积，将这些行向量命名为ri,我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916113939.png" class="" title="image-20210916113939">

<p><strong>或者，我们可以把这个乘积看成是三列ci和A的，由x的分量加权:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114058.png" class="" title="image-20210916114058">

<p><strong>同理，我们可以将矩阵乘积AB理解为A的所有行与B的所有列的成对点积的数组;作为矩阵A与B的所有列向量的乘积的集合，从左到右排列;A的所有行向量与矩阵B的乘积的集合，从上到下堆叠;或者A的所有列与b的所有行的对偶外积的和。</strong></p>
<p><strong>这些对矩阵乘法的解释通常会导致对运算的有价值的几何解释，否则这些运算可能看起来非常抽象。</strong></p>
<h3 id="Special-Types-of-Matrices-矩阵的特殊类型"><a href="#Special-Types-of-Matrices-矩阵的特殊类型" class="headerlink" title="Special Types of Matrices 矩阵的特殊类型"></a>Special Types of Matrices 矩阵的特殊类型</h3><p><strong>单位矩阵是对角线矩阵的一个例子，其中所有的非零元素都沿着对角线出现。对角线由列索引等于从左上角开始计数的行索引的元素组成。</strong></p>
<p><strong>单位矩阵还有一个性质它和它的转置是一样的。这样的矩阵称为对称矩阵。</strong></p>
<p><strong>单位矩阵也是一个正交矩阵，因为它的每一列都被认为是向量长度为1并且这些列是相互正交的。行也是如此。任何正交矩阵的行列式要么是+1，要么是−1。</strong></p>
<p><strong>正交矩阵的一个非常有用的性质是它们是自己的逆。用一个正交矩阵乘以它的转置得到单位矩阵，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114444.png" class="" title="image-20210916114444">

<p><strong>这很容易看出来，因为R^TR是R列之间的点积，非对角元素是正交向量之间的点积，而对角元素是(单位长度)列与自身的点积。</strong></p>
<h3 id="列子"><a href="#列子" class="headerlink" title="列子"></a>列子</h3><p><strong>有矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114635.png" class="" title="image-20210916114635">

<p><strong>是对角线的，因此是对称的，但不是正交的(列是正交的，但它们不是单位长度)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114646.png" class="" title="image-20210916114646">

<p><strong>是对称的，但不是对角或正交的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210916114658.png" class="" title="image-20210916114658">

<p><strong>正交，但既不对角线也不对称。</strong></p>
<h2 id="Computing-with-Matrices-and-Determinants-使用矩阵和行列式计算"><a href="#Computing-with-Matrices-and-Determinants-使用矩阵和行列式计算" class="headerlink" title="Computing with Matrices and Determinants 使用矩阵和行列式计算"></a>Computing with Matrices and Determinants 使用矩阵和行列式计算</h2><p><strong>回想一下5.1节，行列式取n个n维向量并将它们组合起来得到由这些向量定义的n维平行六面体的有符号的n维体积。例如，二维的行列式就是面积由这些向量组成的平行四边形。我们可以用矩阵来处理计算行列式的问题。</strong></p>
<p><strong>如果我们有二维向量r和s，我们表示行列式|rs|;这个值是由这些向量组成的平行四边形的带符号的面积。假设我们有两个笛卡尔坐标(a, b)和(A, B)的2D向量。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917112255.png" class="" title="image-20210917112255">

<p><strong>行列式可以写成列向量的形式，或者简写为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124406.png" class="" title="image-20210917124406">

<p><strong>请注意，矩阵的行列式与它的反式行列式是相同的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124452.png" class="" title="image-20210917124452">

<p><strong>这意味着，对于任何一个二维平行四边形，都有一个“兄弟”平行四边形，其面积相同，但形状不同。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124534.png" class="" title="image-20210917124534">

<p><strong>例子</strong></p>
<p><strong>三维行列式的几何意义有助于理解为什么某些公式是有意义的。例如，通过点(xi，yi, zi)为i = 0,1,2</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124634.png" class="" title="image-20210917124634">

<p><strong>每一列是来自点(xi，yi, zi)的向量指向(x, y, z)。只有当(x, y, z)与其他三个点共面时，以这些向量为边的平行六面体的体积为零。几乎所有涉及行列式的方程都有同样简单的基础几何。</strong></p>
<p><strong>正如我们之前看到的，我们可以通过强力展开来计算行列式，其中大多数项都是零，并且有大量的加号和减号的记录。计算行列式的代数运算的标准方法是使用拉普拉斯展开的形式。用这种方法计算行列式的关键部分是求出矩阵各元素的余子式。方阵的每一个元素都有一个余子式，它是矩阵的行列式，它的行和列比矩阵少一，可能乘以- 1。更小的矩阵是通过消去问题元素所在的行和列得到的。例如，对于10×10矩阵，a82 是9×9矩阵的行列式去掉了第8行和第2列。余子式的正号为行和列指标的和是偶数，否则是负的。这可以通过棋盘格来记住:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124908.png" class="" title="image-20210917124908">

<p><strong>对于一个4 × 4矩阵，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124926.png" class="" title="image-20210917124926">

<p><strong>第一行的余子式是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917124937.png" class="" title="image-20210917124937">

<p><strong>矩阵的行列式是通过取任意行或列的元素与它们的余子式的乘积和得到的。例如，上面的4 × 4矩阵的行列式取第二列为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125024.png" class="" title="image-20210917125024">

<p><strong>我们可以对任意行或列做类似的展开它们都会得到相同的结果。注意这个扩展的递归性质。</strong></p>
<p><strong>例子</strong></p>
<p><strong>通过展开第一行的余子式求特定3 × 3矩阵的行列式的一个具体例子是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125102.png" class="" title="image-20210917125102">

<p><strong>我们可以推导出平行六面体的体积由列(或行，因为转置的行列式是相同的)定义的向量构成。这等价于说列(或行)不是线性无关的。注意，第一行和第三行的和是第二行，这意味着线性相关。</strong></p>
<h3 id="Computing-Inverses-计算逆"><a href="#Computing-Inverses-计算逆" class="headerlink" title="Computing Inverses 计算逆"></a>Computing Inverses 计算逆</h3><p><strong>行列式给了我们一个计算矩阵逆的工具。对于大型矩阵来说，这是一种非常低效的方法，但在图形学中，我们的矩阵通常都很小。发展这种方法的关键是具有两行相同的矩阵的行列式为零。这应该很清楚，因为n维平行六面体的体积是零如果它的两条边相等。假设我们有一个4 × 4A，我们希望找到它的逆矩阵A ^- 1。它的逆是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125421.png" class="" title="image-20210917125421">

<p><strong>注意，这只是矩阵的转置，其中A的元素被替换为它们各自的余子式乘以前导常数(1或-1)。这个矩阵叫做A的伴随矩阵，伴随矩阵是A的余子矩阵的转置，我们可以看出为什么它是逆矩阵。看看AA^−1我们认为它是恒等式。如果我们用A的第一行乘以伴随矩阵的第一列我们需要得到|A|(记住前面的常数除以|A|)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125614.png" class="" title="image-20210917125614">

<p><strong>这是正确的，因为A的第一行的元素恰好乘以伴随矩阵的第一列的余子式也就是行列式。由于类似的原因，结果矩阵对角线上的其他值是|A|。这些零遵循类似的逻辑:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125623.png" class="" title="image-20210917125623">

<p><strong>注意这个乘积是某个矩阵的行列式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125658.png" class="" title="image-20210917125658">

<p><strong>这个矩阵实际上是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917125903.png" class="" title="image-20210917125903">

<p><strong>因为前两行是相同的，这个矩阵是奇异的，因此，它的行列式是零。</strong></p>
<p><strong>上面的论证并不仅仅适用于4 × 4矩阵;使用这个尺寸只是简化了排版。对于任何矩阵，其逆矩阵是伴随矩阵除以被逆矩阵的行列式。伴随矩阵是余子矩阵的转置，也就是元素被其余子矩阵所取代的矩阵。</strong></p>
<p><strong>例子</strong></p>
<p><strong>这个3 × 3矩阵的逆矩阵的行列式是6</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130133.png" class="" title="image-20210917130133">

<p><strong>你可以自己检验一下通过把这些矩阵相乘确保你得到了单位矩阵。</strong></p>
<h3 id="Linear-Systems-线性系统"><a href="#Linear-Systems-线性系统" class="headerlink" title="Linear Systems 线性系统"></a>Linear Systems 线性系统</h3><p><strong>我们经常在图形中遇到“n个方程和n个未知数”的线性系统，通常是n = 2或n = 3。例如,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130206.png" class="" title="image-20210917130206">

<p><strong>这里x、y和z是我们想要解的“未知数”。我们可以把它写成矩阵形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130246.png" class="" title="image-20210917130246">

<p><strong>这种系统的一个常见的简写是Ax = b，其中假设A是一个已知常数的方阵，x是一个未知的列向量(在我们的例子中包含元素x、y和z)， b是一个已知常数的列矩阵。</strong></p>
<p><strong>有很多方法可以解决这种系统,适当的方法取决于属性和维度的矩阵a。因为在图形我们如此频繁与系统大小n≤4,我们将在这里讨论一个方法适合这些系统,称为克莱姆法则,我们之前看到的,从二维几何的观点。在这里，我们用代数方法证明。上面这个方程的解是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130448.png" class="" title="image-20210917130448">

<p><strong>这里的规则是比例的决定因素,分母是|A|和分子是替换产生的矩阵的行列式的一列A与列向量b。列替换对应的位置未知向量x。例如,y是第二个未知,第二列是更换。注意，如果|A| = 0，除法是未定义的，没有解。这只是法则的另一个版本如果A是奇异的(零行列式)那么方程就没有唯一解。</strong></p>
<h2 id="Eigenvalues-and-Matrix-Diagonalization-特征值与矩阵对角化"><a href="#Eigenvalues-and-Matrix-Diagonalization-特征值与矩阵对角化" class="headerlink" title="Eigenvalues and Matrix Diagonalization 特征值与矩阵对角化"></a>Eigenvalues and Matrix Diagonalization 特征值与矩阵对角化</h2><p><strong>方阵具有与之相关的特征值和特征向量。特征向量是非零的向量它们的方向在乘以矩阵时不会改变。例如，对于矩阵a和向量a，我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130701.png" class="" title="image-20210917130701">

<p><strong>这意味着我们已经拉伸或压缩了a，但它的方向没有改变。标度因子λ称为与特征向量a相关联的特征值矩阵的特征值和特征向量在许多实际应用中是有帮助的。我们将描述它们来深入了解几何变换矩阵，并作为下一节中描述的奇异值和向量的一步。</strong></p>
<p><strong>如果我们假设一个矩阵至少有一个特征向量，那么我们可以做一个标准的操作来找到它。首先，我们把等式两边写成方阵与向量a的乘积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130715.png" class="" title="image-20210917130715">

<p><strong>其中I是单位矩阵。这也可以写作</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130724.png" class="" title="image-20210917130724">

<p><strong>因为矩阵乘法满足分配律，我们可以将这些矩阵分组:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917130733.png" class="" title="image-20210917130733">

<p><strong>这个方程只有当矩阵(A−λI)是奇异的，因此它的行列式为零时才成立。这个矩阵中的元素是A中的数字，除了对角线上的数字。例如，对于一个2 × 2矩阵，特征值服从</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131009.png" class="" title="image-20210917131009">

<p><strong>因为这是一个二次方程，我们知道λ有两个解。这些解可能是唯一的，也可能不是真的。对n × n矩阵的类似操作将在λ中生成n次多项式。由于通常不可能找到大于4次的多项式方程的精确显式解，我们只能用解析方法计算4 × 4或更小矩阵的特征值。对于较大的矩阵，数值方法是唯一的选择。</strong></p>
<p><strong>特征值和特征向量特别简单的一个重要特例是对称矩阵(其中A = AT)．实对称矩阵的特征值总是实数，如果它们也是不同的，则它们的特征向量是相互正交的。这样的矩阵可以写成对角形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131119.png" class="" title="image-20210917131119">

<p><strong>其中Q是一个正交矩阵D是一个对角矩阵。Q的列是A的特征向量，D的对角元素是A的特征值，把A写成这种形式也叫做特征值分解，因为它把A分解成一个更简单的矩阵的乘积，揭示了它的特征向量和特征值。</strong></p>
<p><strong>例子</strong></p>
<p><strong>一个矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131226.png" class="" title="image-20210917131226">

<p><strong>A的特征值是解</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131236.png" class="" title="image-20210917131236">

<p><strong>我们得到近似值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131246.png" class="" title="image-20210917131246">

<p><strong>现在我们可以找到相关的特征向量。第一个是齐次方程的非平凡解(不是x = y = 0)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131256.png" class="" title="image-20210917131256">

<p><strong>这近似(x, y) =(0.8507, 0.5257)。注意，平行于这个二维向量的解有无穷多个，我们只选了一个单位长度的解。类似地，与λ2相关的特征向量是 (x, y) =(−0.5257,0.8507)。这意味着A的对角线形式是(由于我们的数值近似，在一定精度范围内):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917131308.png" class="" title="image-20210917131308">

<h3 id="Singular-Value-Decomposition-奇异值分解"><a href="#Singular-Value-Decomposition-奇异值分解" class="headerlink" title="Singular Value Decomposition 奇异值分解"></a>Singular Value Decomposition 奇异值分解</h3><p><strong>我们在上一节中看到，任何对称矩阵都可以对角化，或者分解成正交矩阵和对角矩阵的乘积。然而，我们在图形学中遇到的大多数矩阵都是不对称的，非对称矩阵的特征值分解并不是那么方便或明显的，而且通常涉及复值特征值和特征向量，即使是实值输入。</strong></p>
<p><strong>对非对称(甚至非方阵)矩阵的对称特征值分解还有另一种推广;它就是奇异值分解(SVD)。对称矩阵的特征值分解与非对称矩阵的奇异值分解的主要区别在于，在奇异值分解中，左右两侧的正交矩阵不需要相同:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134407.png" class="" title="image-20210917134407">

<p><strong>U和V是两个,可能不同,正交矩阵,它的列被称为左和右奇异向量,和S是一个对角矩阵的奇异值的条目被称为A .当一个是对称的,所有非负特征值,计算和特征值分解是相同的。</strong></p>
<p><strong>在奇异值和特征值之间还有另一种关系，可以用来计算SVD(尽管这不是工业强度SVD实现的工作方式)。首先我们定义M = AAT．假设我们可以对M进行SVD:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134419.png" class="" title="image-20210917134419">

<p><strong>这种替代是基于(BC)T = CTBT正交矩阵的转置就是它的逆矩阵，对角矩阵的转置就是矩阵本身。这种新形式的美妙之处在于M是对称的和美式的2UT 是它的特征值分解，S2 包含(所有非负的)特征值。因此，我们发现矩阵的奇异值是矩阵与转置乘积的特征值的平方根，而左奇异向量是该乘积的特征向量。一个类似的论证允许V，右奇异向量的矩阵，从A计算T一个。</strong></p>
<p><strong>例子</strong></p>
<p><strong>现在我们用一个例子来具体说明:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134430.png" class="" title="image-20210917134430">

<p><strong>我们在前一节看过这个矩阵的特征值分解。我们立即观察</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134441.png" class="" title="image-20210917134441">

<p><strong>我们可以用代数方法求解V:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134451.png" class="" title="image-20210917134451">

<p><strong>S的逆矩阵是一个由S的对角元素的倒数组成的对角矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210917134502.png" class="" title="image-20210917134502">

<p><strong>这种形式使用标准符号σi 对于第i个奇异值。同样，对于对称矩阵，特征值和奇异值是相同的(σi =λi)．我们将在第6.1.6节进一步研究SVD的几何结构。</strong></p>
<h1 id="6-Transformation-Matrices-矩阵变换"><a href="#6-Transformation-Matrices-矩阵变换" class="headerlink" title="6 Transformation Matrices 矩阵变换"></a>6 Transformation Matrices 矩阵变换</h1><h2 id="2D-Linear-Transformations-二维线性变换"><a href="#2D-Linear-Transformations-二维线性变换" class="headerlink" title="2D Linear Transformations 二维线性变换"></a>2D Linear Transformations 二维线性变换</h2><p><strong>我们可以使用2 × 2矩阵来改变或变换一个2D向量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918103805.png" class="" title="image-20210918103805">

<p><strong>这种运算，通过一个简单的矩阵乘法得到另一个2-向量，是一个线性变换。</strong></p>
<p><strong>通过这个简单的公式，我们可以实现各种有用的转换，这取决于我们在矩阵的项中放入了什么，这将在下面几节中讨论。出于我们的目的，考虑沿x轴的移动是水平移动，沿y轴的移动是垂直移动。</strong></p>
<h3 id="Scaling-缩放"><a href="#Scaling-缩放" class="headerlink" title="Scaling 缩放"></a>Scaling 缩放</h3><p><strong>最基本的变换是沿坐标轴的缩放。这个变换可以改变长度和可能的方向:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104010.png" class="" title="image-20210918104010">

<p><strong>注意这个矩阵对具有笛卡尔分量(x, y)的向量的作用:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104019.png" class="" title="image-20210918104019">

<p><strong>所以，只要看一个轴向比例的矩阵，我们就能读出两个比例因子。</strong></p>
<p><strong>例子</strong></p>
<p><strong>将x和y均匀地缩小为原来的两倍的矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104034.png" class="" title="image-20210918104034">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104054.png" class="" title="image-20210918104054">

<p>每个轴按一半均匀缩放:轴对齐的缩放矩阵有每个对角线元素的变化比例，非对角线元素的变化比例为零。</p>
<p><strong>一个在水平方向上减半，在垂直方向上增加三倍的矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104043.png" class="" title="image-20210918104043">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104106.png" class="" title="image-20210918104106">

<p>x和y的非均匀缩放:缩放矩阵是对角的，且不相等元素。</p>
<h3 id="Shearing-剪切"><a href="#Shearing-剪切" class="headerlink" title="Shearing 剪切"></a>Shearing 剪切</h3><p><strong>剪切是把东西往旁边推的东西，就像你用手推一副扑克牌一样。水平和垂直剪切矩阵为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104646.png" class="" title="image-20210918104646">

<p><strong>例子</strong></p>
<p><strong>水平剪切的变换，使垂直线变成45◦向右倾斜的线是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104656.png" class="" title="image-20210918104656">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104705.png" class="" title="image-20210918104705">

<p>x-剪切矩阵按其y坐标的比例向右移动。</p>
<p><strong>垂直方向的一个类似变换是(见图6.4)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104719.png" class="" title="image-20210918104719">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104733.png" class="" title="image-20210918104733">

<p>y-剪切矩阵使点按其横坐标的比例向上移动。</p>
<p><strong>在这两种情况下，被剪切的时钟的方形轮廓变成了一个平行四边形，被剪切的钟的圆形表面变成了椭圆形。</strong></p>
<p><strong>另一种考虑剪切的方法是只考虑垂直(或水平)轴的旋转。具有垂直轴并使其倾斜的剪切变换顺时针方向，φ为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104745.png" class="" title="image-20210918104745">

<p><strong>同理，以角度φ逆时针旋转水平轴的剪切矩阵为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918104754.png" class="" title="image-20210918104754">

<h3 id="Rotation-旋转"><a href="#Rotation-旋转" class="headerlink" title="Rotation 旋转"></a>Rotation 旋转</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105214.png" class="" title="image-20210918105214">

<p><strong>假设我们想让向量a逆时针旋转一个角度φ来得到向量b。如果a与x轴的夹角是α，它的长度是r= xa² + ya²，我们就知道了</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105319.png" class="" title="image-20210918105319">

<p><strong>因为b是a的旋转，它的长度也为r。因为它从a旋转一个角度φ， b与x轴形成一个角度(α + φ)。使用三角加法恒等式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105422.png" class="" title="image-20210918105422">

<p><strong>使用xa=rcosα和ya=rsinα替换</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105432.png" class="" title="image-20210918105432">

<p><strong>在矩阵形式中，从a到b的变换是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105442.png" class="" title="image-20210918105442">

<p><strong>例子</strong></p>
<p><strong>一个以π/4弧度(45度)旋转矢量的矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105628.png" class="" title="image-20210918105628">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105640.png" class="" title="image-20210918105640">

<p>逆时针旋转45◦，cos(45◦)= sin(45◦)≈0.707。</p>
<p><strong>一个沿顺时针方向旋转30度的矩阵，在我们的框架中相当于旋转−π/6度(见图6.7):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105823.png" class="" title="image-20210918105823">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918105834.png" class="" title="image-20210918105834">

<p>旋转-30度。注意，旋转是顺时针和cos(-30◦)≈0.866和sin(-30◦)= -0.5。</p>
<p><strong>因为旋转矩阵每一行的范数是1 (sin²φ+ cos²φ=1)，且行为正交(cosφ(-sinφ)+sinφcosφ=0)，则旋转矩阵为正交矩阵。通过观察这个矩阵我们可以读出两对标准正交向量这两列向量，是这个变换发送给它的标准基向量(1,0)和(0,1);这些行，就是这些变换传递给标准基向量的向量。</strong></p>
<h3 id="Reflection-反射"><a href="#Reflection-反射" class="headerlink" title="Reflection 反射"></a>Reflection 反射</h3><p><strong>我们可以通过使用一个负比例因子的比例来反映任意一个坐标轴上的向量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110125.png" class="" title="image-20210918110125">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110137.png" class="" title="image-20210918110137">

<p>关于y轴的反射是通过将所有x坐标乘以-1来实现的。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110148.png" class="" title="image-20210918110148">

<p>关于x轴的反射是通过将所有y坐标乘以-1来实现的。</p>
<p><strong>虽然人们可能认为对角线上两个元素都为−1的矩阵也是一个反射，但实际上它只是一个π弧度的旋转（这种旋转也可以称为“穿过原点的反射”。）。</strong></p>
<h3 id="Composition-and-Decomposition-of-Transformations-变换的组合和分解"><a href="#Composition-and-Decomposition-of-Transformations-变换的组合和分解" class="headerlink" title="Composition and Decomposition of Transformations 变换的组合和分解"></a>Composition and Decomposition of Transformations 变换的组合和分解</h3><p><strong>对于图形程序来说，对一个对象应用多个转换是很常见的。例如，我们可能想首先应用一个缩放S，然后再应用一个旋转R。这将在2D向量v1上分两步完成：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110530.png" class="" title="image-20210918110530">

<p><strong>另一种写法是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110538.png" class="" title="image-20210918110538">

<p><strong>因为矩阵乘法满足结合律，我们也可以写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918110546.png" class="" title="image-20210918110546">

<p><strong>换句话说，我们可以用一个大小相同的矩阵来表示将一个向量按顺序转换为两个矩阵的效果，我们可以通过将两个矩阵相乘来计算:M = RS。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918113135.png" class="" title="image-20210918113135">

<p>将两个变换矩阵按顺序应用与将它们的乘积应用一次是相同的。这是构成大多数图形硬件和软件的关键概念。</p>
<p><strong>重要的是要记住，这些变换首先是从右侧应用的。矩阵M = RS首先应用S，然后是R。</strong></p>
<p><strong>例子</strong></p>
<p><strong>假设我们想在垂直方向上缩放1 / 2，然后旋转π/4弧度(45度)。得到的矩阵是</strong>image-屏幕截图20210918122140](Fundamentals Of Computer Graphics image-幕截图 02-0-18 122140.png)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </p>
<p><strong>重要的是要始终记住矩阵乘法是不可交换的。所以变换的顺序很重要。在这个例子中，先旋转，然后缩放，会得到一个不同的矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122155.png" class="" title="image-20210918122155">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122221.png" class="" title="image-20210918122221">

<p>应用两个变换的顺序通常很重要。将应用这两个转换的顺序颠倒，将产生不同的结果。</p>
<p><strong>例子</strong></p>
<p><strong>使用我们给出的比例矩阵，非均匀比例只能沿坐标轴进行。如果我们想沿着对角线将时钟拉长50%，那么8:00到1:00移动到西北方向，2:00到7:00移动到东南方向，我们可以使用旋转矩阵结合轴向缩放矩阵来得到我们想要的结果。这个想法是使用旋转使缩放轴与坐标轴对齐，然后沿着这个轴缩放，然后旋转回来。在我们的例子中，缩放轴是正方形的“反斜线”对角线，我们可以使它与x轴平行一个旋转+45◦。把这些操作放在一起，整个转换就是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122436.png" class="" title="image-20210918122436">

<p><strong>用数学符号表示，可以写成RSR^T．这三个矩阵相乘的结果是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122446.png" class="" title="image-20210918122446">

<p><strong>从旋转和缩放转换构建一个转换实际上适用于任何线性转换，这一事实导致了一种思考这些转换的强大方法，下一节将对此进行探讨。</strong></p>
<h3 id="Decomposition-of-Transformations-变换的分解"><a href="#Decomposition-of-Transformations-变换的分解" class="headerlink" title="Decomposition of Transformations 变换的分解"></a>Decomposition of Transformations 变换的分解</h3><p><strong>有时需要“解开”转换的组合，将转换分解成更简单的部分。例如，根据单独的旋转和缩放因子向用户展示一个转换，以便进行操作，这通常是有用的，但一个转换可能在内部简单地表示为矩阵，旋转和缩放已经混合在一起。如果能计算出将矩阵分解成所需的小块，对小块进行调整，然后再将这些小块乘在一起将矩阵重新组装，就可以实现这种操作。</strong></p>
<p><strong>事实证明，这种分解或因式分解是可能的，不管矩阵中的条目是什么——这提供了一种富有成效的方式来思考转换以及它们对由它们转换的几何图形所做的事情。</strong></p>
<h4 id="Symmetric-Eigenvalue-Decomposition-对称特征值分解"><a href="#Symmetric-Eigenvalue-Decomposition-对称特征值分解" class="headerlink" title="Symmetric Eigenvalue Decomposition 对称特征值分解"></a>Symmetric Eigenvalue Decomposition 对称特征值分解</h4><p><strong>让我们从对称矩阵开始。回忆一下5.4节，对称矩阵总是可以使用特征值分解成这种形式的乘积</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122956.png" class="" title="image-20210918122956">

<p><strong>其中R是正交矩阵S是对角矩阵;我们称R的列向量为v1 和v2，我们把S(特征值)的对角线项叫做λ1 和λ2．</strong></p>
<p><strong>在几何方面，我们现在可以识别R是一个旋转，S是一个比例，所以这只是一个多步骤的几何变换:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123059.png" class="" title="image-20210918123059">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123142.png" class="" title="image-20210918123142">

<p>当单位圆被任意对称矩阵变换时会发生什么，又称非轴向、非均匀尺度。这两个垂直的向量v1 和v2，它们是A的特征向量，方向是固定的，但是被缩放了。根据初等变换，这可以被看作是首先旋转特征向量到标准基，做一个轴对齐的比例，然后旋转标准基回到特征向量。</p>
<p><strong>观察这三种变换的效果，我们可以看到它们有沿一对轴的非均匀比例的效果。与轴对齐的比例一样，轴是垂直的，但它们不是坐标轴;相反,他们是a的特征向量。这告诉我们什么是对称矩阵:对称矩阵只是缩放操作——尽管可能是非均匀的和非轴对齐的。</strong></p>
<p><strong>例子</strong></p>
<p><strong>回想一下5.4节中的例子:</strong></p>
<p><strong>上面的矩阵，然后，根据它的特征值分解，在一个方向31.7◦逆时针从3点(x轴)。如图所示，这是在下午2点之前的一次触摸。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123534.png" class="" title="image-20210918123534">

<p>对称矩阵总是沿着某一轴的一个比例尺。在这种情况下，它是沿着φ = 31.7◦方向，这意味着这个矩阵的真实特征向量是在那个方向。</p>
<p><strong>我们也可以反转这个对角化过程;按(λ1,λ2)，第一个缩放方向为从x轴顺时针方向的角度φ，我们得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123505.png" class="" title="image-20210918123505">

<p><strong>我们应该记住，这是一个对称矩阵，因为我们知道它必须是真的，因为我们从一个对称特征值分解构造它。</strong></p>
<h4 id="Singular-Value-Decomposition-奇异值分解-1"><a href="#Singular-Value-Decomposition-奇异值分解-1" class="headerlink" title="Singular Value Decomposition 奇异值分解"></a>Singular Value Decomposition 奇异值分解</h4><p><strong>对于非对称矩阵也可以进行非常类似的分解:它是奇异值分解(SVD)，也将在第5.4.1节中讨论。不同之处在于对角矩阵两边的矩阵不再相同:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123732.png" class="" title="image-20210918123732">

<p><em><em>这两个正交矩阵代替了单个旋转R称为U和V，它们的列称为U</em>i* (左奇异向量)和v*i</em> (右奇异向量)。在这种情况下，S的对角项称为奇异值而不是特征值。几何解释与对称特征值分解非常相似:**</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123745.png" class="" title="image-20210918123745">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918123806.png" class="" title="image-20210918123806">

<p>当单位圆被任意矩阵a变换时会发生什么?两个垂直的向量v1和v2，它们是A的右奇异向量，被缩放和改变方向来匹配左奇异向量u1和u2。根据初等变换，这可以看作是首先将右边的奇异向量旋转到标准基上，进行轴对齐的缩放，然后将标准基旋转到左边的奇异向量上。</p>
<p><strong>主要的区别是单个旋转和两个不同的正交矩阵之间的区别。这个差异导致了另一个不那么重要的差异。因为奇异值分解的两边有不同的奇异向量，所以不需要负奇异值:我们总是可以翻转一个奇异值的符号，改变一个相关奇异向量的方向，然后再次得到相同的变换。由于这个原因，SVD总是产生一个所有条目都是正的对角矩阵，但矩阵U和V不能保证是旋转矩阵——它们也可以包括反射。在像图形学这样的几何应用中，这是一个不便之处，但也是一个很小的不便:通过检查行列式，很容易区分旋转和反射，对于旋转，行列式是+1和−1表示反射，如果需要旋转，则其中一个奇异值可以被抵消，从而产生一个旋转-比例-旋转序列，其中反射与比例滚入，而不是与一个旋转滚入。</strong></p>
<p><strong>例子</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124032.png" class="" title="image-20210918124032">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918122824.png" class="" title="image-20210918122824">

<p>剪切矩阵的奇异值分解。</p>
<p><strong>SVD存在的直接结果是，我们看到的所有二维变换矩阵都可以由旋转矩阵和缩放矩阵构成。剪切矩阵是一种方便的方法，但表达反式并不需要它们形成。</strong></p>
<p><strong>总之，每个矩阵都可以通过SVD分解为一个旋转乘以一个比例乘以另一个旋转。只有对称矩阵才能通过特征值对角化分解为旋转乘以比例乘以反旋转，且这类矩阵是任意方向上的简单比例。对称矩阵的奇异值分解将通过稍微复杂一点的代数操作产生与特征值分解相同的三重积。</strong></p>
<h4 id="Paeth-Decomposition-of-Rotations-旋转的Paeth分解"><a href="#Paeth-Decomposition-of-Rotations-旋转的Paeth分解" class="headerlink" title="Paeth Decomposition of Rotations 旋转的Paeth分解"></a>Paeth Decomposition of Rotations 旋转的Paeth分解</h4><p><strong>另一种分解使用剪切来表示非零旋转(Paeth, 1990)。下面的标识允许这样做:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124301.png" class="" title="image-20210918124301">

<p><strong>例如，π/4(45度)的旋转是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124310.png" class="" title="image-20210918124310">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124408.png" class="" title="image-20210918124408">

<p>任何二维旋转都可以由三个顺序剪切完成。在这种情况下，旋转45◦分解如公式所示。</p>
<p><strong>这种特殊的变换对于光栅旋转非常有用，因为剪切是一种非常有效的图像光栅操作;它会带来一些粗糙，但会没有留下任何漏洞。关键的观察是，如果我们取一个光栅位置(i, j)，并对其施加一个水平剪切，我们得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124539.png" class="" title="image-20210918124539">

<p><strong>如果我们将sj四舍五入到最接近的整数，这相当于取图像中的每一行，并将其侧向移动一些量——每一行都有不同的量。因为它在一行中是相同的位移，这允许我们在结果图像中没有间隙的旋转。类似的作用也适用于垂直剪切。因此，我们可以很容易地实现一个简单的光栅旋转。</strong></p>
<h2 id="3D-Linear-Transformations-三维线性变换"><a href="#3D-Linear-Transformations-三维线性变换" class="headerlink" title="3D Linear Transformations 三维线性变换"></a>3D Linear Transformations 三维线性变换</h2><p><strong>线性三维变换是二维变换的扩展。例如，沿笛卡尔轴的缩放是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124633.png" class="" title="image-20210918124633">

<p><strong>旋转在3D中要比在2D中复杂得多，因为有更多可能的旋转轴。然而，如果我们只是想绕z轴旋转，这只会改变x和y坐标，我们可以使用2D旋转矩阵，而不需要对z进行操作:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124643.png" class="" title="image-20210918124643">

<p><strong>类似地，我们可以构造绕x轴和y轴旋转的矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124654.png" class="" title="image-20210918124654">

<p><strong>我们将在下一节讨论关于任意轴的旋转。在二维空间中，我们可以沿着特定的轴进行剪切，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124704.png" class="" title="image-20210918124704">

<p><strong>与2D转换一样，任何3D转换矩阵都可以使用SVD分解为旋转、缩放和另一个旋转。任何对称三维矩阵都有一个特征值分解为旋转、缩放和反旋转。最后，将三维旋转分解为三维剪切矩阵的乘积。</strong></p>
<h3 id="Arbitrary-3D-Rotations-任意三维旋转"><a href="#Arbitrary-3D-Rotations-任意三维旋转" class="headerlink" title="Arbitrary 3D Rotations 任意三维旋转"></a>Arbitrary 3D Rotations 任意三维旋转</h3><p><strong>和2D一样，3D旋转是正交矩阵。在几何上，这意味着矩阵的三行是三个相互正交的单位向量的笛卡尔坐标，如2.4.5节所讨论的。列向量是三个，可能不同的，相互正交的单位向量。有无限个这样的旋转矩阵。让我们写下这样一个矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124852.png" class="" title="image-20210918124852">

<p><strong>这里u = xux + yuy + zuz等对于v和w，因为这三个向量是标准正交的，我们知道</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124901.png" class="" title="image-20210918124901">

<p><strong>我们可以通过将旋转矩阵应用于向量u，v和w来推断它的一些行为，例如，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124912.png" class="" title="image-20210918124912">

<p><strong>注意RuvwU的这三行都是点积:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124921.png" class="" title="image-20210918124921">

<p><strong>同样,Ruvwv = y，Ruvww = z，所以Ruvw 将基uvw旋转到相应的笛卡尔轴上。</strong></p>
<p><strong>如果Ruvw 是一个具有标准正交行的旋转矩阵，那么Ruvw^T 也是一个具有标准正交列的旋转矩阵，实际上是Ruvw的逆矩阵 (正交矩阵的逆总是它的转置)。重要的一点是，对于变换矩阵，代数逆也是几何逆。如果Ruvw 取u到x，然后Ruvw^T 将x取到u, v和y也应如此，我们可以确认:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124932.png" class="" title="image-20210918124932">

<p><strong>所以我们总是可以用标准正交基来创建旋转矩阵。</strong></p>
<p><strong>如果我们想旋转一个任意向量a，我们可以形成一个w = a的标准正交基，将这个基旋转到标准基xyz，绕z轴旋转，然后将标准基旋转回uvw基。在矩阵形式下，绕w轴旋转一个角度φ:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918124942.png" class="" title="image-20210918124942">

<p><strong>这里我们有一个单位矢量w，在a的方向上(即a除以自身长度)。但是u和v是什么?找到合理的u和v的方法在第2.4.6节中给出。</strong></p>
<p><strong>如果我们有一个旋转矩阵，我们希望以轴角形式旋转，我们可以计算一个真实的特征值(λ = 1)，对应的特征向量是旋转轴。这是一个没有因旋转而改变的轴。</strong></p>
<p><strong>除了旋转矩阵外，还有一些常用的表示旋转的方法，请参阅第16章。</strong></p>
<h3 id="Transforming-Normal-Vectors-转换法向量"><a href="#Transforming-Normal-Vectors-转换法向量" class="headerlink" title="Transforming Normal Vectors 转换法向量"></a>Transforming Normal Vectors 转换法向量</h3><p><strong>虽然我们使用的大多数3D矢量表示位置(从原点偏移的矢量)或方向，比如光线从哪里来，但有些矢量表示表面法线。曲面法向量垂直于曲面的切平面。当下面的表面被变换时，这些法线不会以我们想要的方式进行变换。例如，如果一个曲面上的点被矩阵M变换，那么与曲面相切并乘以M的向量t将与变换后的曲面相切。然而，经过M变换的曲面法向量n可能与变换后的曲面不垂直。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125458.png" class="" title="image-20210918125458">

<p>当一个法向量使用变换对象上的点的相同矩阵进行变换时，得到的向量可能不垂直于这个剪切矩形的表面。然而，切向量确实转换成与变换后的曲面相切的向量。</p>
<p><strong>我们可以推出一个变换矩阵N它把N放到一个垂直于变换后的曲面的向量上。解决这个问题的一种方法是注意曲面法向量和切向量是垂直的，所以它们的点积是零，用矩阵的形式表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125546.png" class="" title="image-20210918125546">

<p><strong>如果我们用t表示需要的变换向量tM = Mt和nN = Nn，我们的目标是找到满足N的nN^TtM = 0．我们可以用代数方法求出N。首先，我们可以在点积中混入一个单位矩阵，然后利用M^−1M = I:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125752.png" class="" title="image-20210918125752">

<p><strong>虽然上面的操作显然没有得到任何结果，但请注意，我们可以添加括号，使上面的表达式更明显地成为一个点积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125802.png" class="" title="image-20210918125802">

<p><strong>这意味着垂直于t的行向量<em>M</em> 是上面表达式的左边部分。这个表达式对切平面上的任何切向量都成立。因为在3D中只有一个方向(和它的相反方向)垂直于所有这些切向量，我们知道上面表达式的左边部分一定是nN的行向量表达式 ,即nN^T，因此我们可以推断出N:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125839.png" class="" title="image-20210918125839">

<p><strong>我们可以用它的转置得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918125848.png" class="" title="image-20210918125848">

<p><strong>因此，我们可以看到，正确变换法向量使其保持法向量的矩阵是N = (M ^−1) ^T,即逆矩阵的转置。因为这个矩阵可以改变n的长度，我们可以把它乘以一个任意的标量它仍然会得到nN方向正确。回忆一下在第5.3节中，矩阵的逆是余子矩阵的转置除以行列式。因为我们不关心法向量的长度，我们可以跳过除法，对于3 × 3矩阵，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918130040.png" class="" title="image-20210918130040">

<p><strong>假设第i行第j列中M的元素为N是mij ．所以完整的表达式是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210918130051.png" class="" title="image-20210918130051">

<h2 id="Translation-and-Affine-Transformations-平移与仿射变换"><a href="#Translation-and-Affine-Transformations-平移与仿射变换" class="headerlink" title="Translation and Affine Transformations 平移与仿射变换"></a>Translation and Affine Transformations 平移与仿射变换</h2><p><strong>我们一直在研究用矩阵M改变向量的方法，在二维中，这些变换有这样的形式，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919131350.png" class="" title="image-20210919131350">

<p><strong>我们不能使用这种变换来移动对象，只能缩放和旋转它们。特别地，原点(0,0)在线性变换下始终是固定的。要移动或平移一个物体，通过移动其所有点的相同量，我们需要一个形式的变换，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919131419.png" class="" title="image-20210919131419">

<p><strong>用(x, y)乘以2 × 2矩阵是不可能的。将平移添加到线性变换系统中的一种可能性是，简单地将一个单独的平移向量与每个变换矩阵关联起来，让矩阵处理缩放和旋转，让向量处理平移。这是完全可行的，但组成两个转换的规则不像线性转换那样简单和干净。</strong></p>
<p><strong>相反，我们可以使用一个技巧来让一个矩阵乘法同时完成这两种操作。这个想法很简单:用一个3D矢量[x y 1]表示点(x, y)T，并使用3 × 3矩阵的形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919133120.png" class="" title="image-20210919133120">

<p><strong>固定的第三行用于将1复制到变换后的向量中，这样所有向量的最后一个位置都是1，并且前两行计算x′和y′作为x, y，和1的线性组合:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919133552.png" class="" title="image-20210919133552">

<p><strong>这个矩阵实现了一个线性变换，且这是平移。这种变换叫做仿射变换，这种通过增加额外维度来实现仿射变换的方法叫做齐次坐标(Roberts, 1965;Riesenfeld, 1981;Penna &amp; Patterson, 1986)。齐次坐标不仅为转换清理了代码，但是这个方案也使如何组合两个仿射变换变得很明显:简单地将两个矩阵相乘。</strong></p>
<p><strong>这种新形式的一个问题是，当我们需要变换不应该是位置的向量时——它们代表方向，或位置之间的偏移。表示方向或偏移量的向量在平移对象时不应改变。幸运的是，我们可以通过将第三个坐标设置为零来避免:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919135106.png" class="" title="image-20210919135106">

<p><strong>如果在矩阵的左上方2 × 2元素中有一个缩放/旋转变换，它将适用于向量，但平移仍然与0相乘并被忽略。此外，零被复制到变换后的向量中，因此方向向量在变换后仍然是方向向量。</strong></p>
<p><strong>这正是我们想要的向量的行为，所以它们平滑地适合于系统:额外的(第三个)坐标将是1或0，这取决于我们表示的是一个位置（点）还是一个方向。我们需要存储齐次坐标以便区分位置和其他向量。例如,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919135502.png" class="" title="image-20210919135502">

<p><strong>当我们进行透视时，我们将看到允许齐次坐标取除1或0以外的值是很有用的。</strong></p>
<p><strong>齐次坐标几乎普遍用于表示图形系统中的变换。特别是，在图形硬件中实现的渲染器的设计和操作是基于齐次坐标的。我们将在第7章中看到，齐次坐标还可以方便地绘制透视图场景，这也是它们流行的另一个原因。</strong></p>
<p><strong>齐次坐标可以被认为是处理变换表示的一种聪明方法，但也有不同的几何解释。当我们做一个基于z坐标的3D剪切时，我们得到这个变换:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919140317.png" class="" title="image-20210919140317">

<p><strong>注意，这几乎具有我们在x和y中想要的2D转换形式，但有一个z在2D中没有意义。现在，我们将为所有2D位置添加一个坐标z = 1。得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919140613.png" class="" title="image-20210919140613">

<p><strong>通过将a (z = 1)坐标与所有2D点联系起来，我们现在可以将平表示为矩阵形式。例如，首先在2D中平移(xt，yt)，然后旋转角度φ，我们将使用矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919141502.png" class="" title="image-20210919141502">

<p><strong>注意，2D旋转矩阵现在是3 × 3，在“平移槽”中为零。“在这种形式下，沿着z = 1使用剪切来表示平移，我们可以将任意数量的2D剪切、2D旋转和2D平移表示为一个复合的3D矩阵。矩阵的最后一行总是(0,0,1)所以我们不需要存储它。我们只需要记住，当我们把两个矩阵相乘时，它也是存在的。</strong></p>
<p><strong>在3D中，可以使用同样的技术:我们可以添加第四个坐标，一个齐次坐标，然后我们就有了平移:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919141648.png" class="" title="image-20210919141648">

<p><strong>同样，对于方向矢量，第四个坐标是零，因此矢量不受平移的影响。</strong></p>
<p><strong>示例(窗口转换)</strong></p>
<p><strong>通常在图形中，我们需要创建一个变换矩阵，取矩形中的点 [xl, xh] × [yl, yh] 到矩形xl′, xh′] × [yl′, yh′]．这可以用单一的比例和顺序转换来完成。然而，更直观的是从三个操作序列创建转换:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919141913.png" class="" title="image-20210919141913">

<p>要将一个矩形(窗口)移动到另一个，我们首先将左下角移动到原点，然后将其缩放到新的大小，然后将原点移动到目标矩形的左下角。</p>
<p><strong>1.移动点(xl，yl)到原点。</strong></p>
<p><strong>2.将矩形缩放为与目标矩形相同的大小。</strong></p>
<p> <strong>3.将原点移动到点(xl′，yl′)</strong></p>
<p><strong>记住右手边的矩阵是先应用的，我们可以这样写</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919142144.png" class="" title="image-20210919142144">

<p><strong>对于一些读者来说，得到的矩阵具有这样的形式可能并不奇怪，但是用三个矩阵构造的过程的结果毫无疑问是正确的。</strong></p>
<p><strong>一个完全类似的结构可以用来定义一个3D窗口变换，它映射框[xl, xh]×[yl,yh]×[zl, zh]到箱子里</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919143528.png" class="" title="image-20210919143528">

<p><strong>有趣的是，如果我们将一个由缩放、剪切和旋转组成的任意矩阵与一个简单的平移(平移排在第二位)相乘，我们得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919145453.png" class="" title="image-20210919145453">

<p><strong>因此，我们可以把任何矩阵看作一个缩放/旋转部分和一个平移部分，因为这些分量彼此分离。</strong></p>
<p><strong>一类重要的变换是刚体变换。它们只由平移和旋转组成，所以它们没有物体的拉伸或收缩。这种变换对aij有一个纯旋转。</strong></p>
<h2 id="Inverses-of-Transformation-Matrices-变换矩阵的逆"><a href="#Inverses-of-Transformation-Matrices-变换矩阵的逆" class="headerlink" title="Inverses of Transformation Matrices 变换矩阵的逆"></a>Inverses of Transformation Matrices 变换矩阵的逆</h2><p><strong>虽然我们总是可以用代数方法求矩阵的逆变换，但如果我们知道变换的作用，就可以用几何方法。例如，scale(sx, sy, sz)的逆变换是scale(1/sx, 1/sy, 1/sz)。旋转的逆旋转是相同的异号旋转。平移的逆是反方向的平移。如果我们有一系列矩阵M = M1M2 ···Mn，那么M^−1 = Mn^-1 ···M2^-1 M^-1。</strong></p>
<p><strong>另外，某些类型的变换矩阵很容易求逆。我们已经提到过缩放，它是对角矩阵;第二个例子是旋转，它是正交矩阵。回忆(第5.2.4节)正交矩阵的逆就是它的转置。这使求旋转和刚体转换的逆变换变得很容易。此外，知道一个底部行中有[0 0 0 1]的矩阵的逆变换在底部行中也有[0 0 0 1]。</strong></p>
<p><strong>有趣的是，我们也可以用奇异值分解(SVD)来求矩阵的逆。因为我们知道任何矩阵都可以分解成旋转乘以缩放乘以旋转，反演是非常简单的。例如，在3D中</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919150249.png" class="" title="image-20210919150249">

<p><strong>从上面的规则可以很容易地得出结论</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210919150259.png" class="" title="image-20210919150259">

<h2 id="Coordinate-Transformations-坐标变换"><a href="#Coordinate-Transformations-坐标变换" class="headerlink" title="Coordinate Transformations 坐标变换"></a>Coordinate Transformations 坐标变换</h2><p><strong>前面所有的讨论都是关于使用变换矩阵来移动点。我们也可以把它们看成是改变点所在的坐标系。例如，在下图中，我们看到了两种可视化运动的方法。在不同的情况下，这两种解释都可能更合适。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920110934.png" class="" title="image-20210920110934">

<p>点(2,1)有一个变换“translate by(-1,0)”作用于它。右上角是我们的目标，如果我们把这种转换看作是一种物理运动，而如果右下角是我们的目标，我们把它看作是坐标的变化(在这种情况下是原点的运动)。人工边界只是一种技巧，轴和点的相对位置在任何情况下都是相同的。</p>
<p><strong>例如，一款驾驶游戏可能包含一个城市模型和一个汽车模型。如果玩家看到的是挡风玻璃外的风景，汽车内的物体就会出现在屏幕上的相同位置，而街道和建筑则会随着玩家的驾驶而向后移动。在每一帧中，我们对这些物体应用一个变换，使它们比前一帧后退得更远。一种简单的理解方法是它将建筑向后移动;另一种思考方式是，建筑保持不变，但我们想要绘制它们的坐标系统——附在汽车上——在移动。在第二种解释中，转变是变化的城市几何体的坐标，表示为汽车坐标系中的坐标。这两种方法将导致完全相同的矩阵应用到汽车外的几何。</strong></p>
<p><strong>如果游戏还支持俯视视图来显示汽车在城市中的位置，那么建筑和街道就需要绘制在固定的位置上，而汽车则需要在帧间移动。同样的两种解释适用:我们可以把变换看作是把汽车从它的标准位置移动到它在世界上的当前位置;或者我们可以把这个变换看作是简单地改变汽车的几何坐标，它原本是用一个附加在汽车上的坐标系来表示的，而现在用一个相对于城市的固定坐标系来表示。坐标变换清楚地表明，在这两种模式(城市到汽车的坐标变化和汽车到城市的坐标变化)中使用的矩阵是彼此相反的。</strong></p>
<p><strong>改变坐标系统的想法很像编程中的类型转换的想法。在将浮点数添加到整数之前，需要根据需要将整数转换为浮点数或将浮点数转换为整数，以便类型匹配。在我们把城市和汽车画在一起之前，我们需要根据我们的需要，把城市转换成汽车坐标，或者把汽车转换成城市坐标，这样坐标才能匹配。</strong></p>
<p><strong>当管理多个坐标系统时，很容易混淆，并最终在错误的坐标中使用对象，导致它们出现在意想不到的地方。但是通过系统地考虑坐标系之间的变换，你可以可靠地得到正确的变换。</strong></p>
<p><strong>几何上，一个坐标系统或坐标系，由一个原点和一个基底组成——一个由三个向量组成的集合。标准正交基是如此的方便，我们通常假设框架是标准正交的，除非另有规定。在原点p和基{u, v, w}的坐标系中，坐标(u, v, w)描述了点</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112103.png" class="" title="image-20210920112103">

<p><strong>当我们在计算机中存储这些向量时，它们需要用某个坐标系来表示。我们必须指定一个规范的坐标系统，通常称为“全局”或“世界”坐标，用来描述所有其他系统。在城市示例中，我们可能会采用街道网格，并使用惯例，即x轴沿着主街指向，y轴向上，z轴沿着中央大道指向。然后，当我们用这些坐标写出车架的原点和基底时，我们的意思就很清楚了。</strong></p>
<p><strong>在2D中，我们的惯例是用点o作为原点，用x和y作为右手标准正交基向量x和y(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112214.png" class="" title="image-20210920112214">

<p>点p可以用任一坐标系表示。</p>
<p><strong>另一个坐标系可能有一个原点e和右手标准正交基向量u和v。注意，典型的标准数据o, x和y从来没有显式地存储。它们是所有其他坐标系的参照系。在那个坐标系中，我们通常把p的位置写成一个有序对，这是一个完整的向量表达式的简写:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112321.png" class="" title="image-20210920112321">

<p><strong>例如，在上图中(xp，yp) =(2.5, 0.9)。注意，这对(xp,yp)隐含地假设原点o。同样，我们可以用另一个方程表示p:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112334.png" class="" title="image-20210920112334">

<p><strong>在上图中，有(up, vp) =(0.5，−0.7)。同样，原点e作为u和v坐标系的隐式部分。</strong></p>
<p><strong>我们可以用矩阵机制来表达同样的关系，像这样:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112345.png" class="" title="image-20210920112345">

<p><strong>注意，这假设我们有点e和向量u和v存储在标准坐标中;(x, y)坐标系是等号中的第一个。基本类型的转换,我们在本章所讨论的,这是一个旋转(包括u和v),后跟一个平移(包括e)。观察旋转和平移的矩阵在一起,你可以看到它很容易写下:我们把u, v,和e为一个矩阵的列,通常在第三行(0 0 1)。为了更清楚，我们可以这样写这个矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920112821.png" class="" title="image-20210920112821">

<p><strong>我们称这个矩阵为(u, v)坐标系的坐标系到标准矩阵。它取在(u, v)坐标系中表示的点，并将它们转换为在标准坐标系中表示的相同点。</strong></p>
<p> <strong>在另一个方向</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113107.png" class="" title="image-20210920113107">

<p><strong>这是平移后的旋转;它们是我们用来构建坐标系到标准矩阵的旋转和平移的逆，当它们相乘时，就得到了坐标系到标准矩阵的逆，也就是标准坐标系到标准矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113121.png" class="" title="image-20210920113121">

<p><strong>标准坐标系矩阵取在标准坐标系中表示的点，并将它们转换为在(u,v)坐标系中表示的相同点。我们把这个矩阵写成坐标系到正则矩阵的逆矩阵因为它不能用e u v的正则坐标直接写出来但是记住所有的坐标系都是等价的;只有我们用x和y坐标来存储向量的惯例才造成了这种表面上的不对称。正规到坐标系的矩阵可以简单地用o, x, y的(u, v)坐标表示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113130.png" class="" title="image-20210920113130">

<p><strong>所有这些想法在3D中类似，我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113139.png" class="" title="image-20210920113139">

<p><strong>和</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920113151.png" class="" title="image-20210920113151">

<h1 id="7-Viewing-视图"><a href="#7-Viewing-视图" class="headerlink" title="7 Viewing 视图"></a>7 Viewing 视图</h1><p><strong>在前一章中，我们看到了如何使用矩阵变换作为工具来操作二维或三维空间中的几何对象。几何变换的第二个重要用途是在物体的3D位置和它们在3D世界的2D视图中的位置之间移动。这种从3D到2D的映射称为视口转换，它在物体顺序绘制中扮演着重要的角色，在这个过程中我们需要快速找到场景中每个物体的图像空间位置。</strong></p>
<p><strong>当我们在第4章学习光线追踪时，我们讨论了不同类型的透视视图和正投影视图，以及如何根据任意给定视图生成观察光线。本章讲述的是与此相反的过程。这里我们将解释如何使用矩阵变换来表示任何平行视图或透视图。本章中的转换将场景(世界空间)中的3D点投射到图像(图像空间)中的2D点，它们将在给定像素的观察射线上投影任何点到该像素在图像空间中的位置。</strong></p>
<p><strong>如果您最近没有看过它，在阅读本章之前，建议您回顾一下第4章中关于透视和光线生成的讨论。</strong></p>
<p><strong>就其本身而言，从世界向图像投射点的能力只适用于生成线框渲染——在这种渲染中，只绘制物体的边缘，较近的表面不会遮挡较远的表面(图7.1)。就像光线追踪器需要沿着每条观察光线找到最近的曲面交点一样，显示固体外观对象的对象顺序渲染器必须计算出在屏幕上任意给定点绘制的(可能有许多)曲面中，哪一个最接近，并只显示那一个。在本章中，我们假设绘制的模型只包含由它们的两个端点的(x, y, z)坐标指定的3D线段。后面的章节将讨论产生实体表面渲染所需的机制。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920124611.png" class="" title="image-20210920124611">

<p>左:直线投影的线框立方体。中间:透视投影的线框立方体。右图:去除隐藏线的透视投影。</p>
<h2 id="Viewing-Transformations-视图变换"><a href="#Viewing-Transformations-视图变换" class="headerlink" title="Viewing Transformations 视图变换"></a>Viewing Transformations 视图变换</h2><p><strong>视图变换的任务是将三维位置(在标准坐标系中表示为(x, y, z)坐标)映射到图像中的坐标(以像素单位表示)。它是一个复杂的东西，取决于许多不同的东西，包括相机的位置和方向，投影的类型，视野，和图像的分辨率。对于所有复杂的转换，最好将其分解为几个更简单的转换的乘积。大多数图像系统通过使用三个转换序列来做到这一点:</strong></p>
<p>​    <strong>摄像机变换或眼睛变换，这是一个刚体变换，将摄像机置于原点，使其处于一个方便的方向。它只取决于相机的位置和方向或姿势。</strong></p>
<p>​    <strong>投影变换，从相机空间投射点，使所有可见点在x和y的范围内- 1到1。它只取决于所需的投影类型。</strong></p>
<p>​    <strong>视口变换或窗口变换，它将这个单位图像矩形映射到所需的像素坐标矩形。它只取决于输出图像的大小和位置。</strong></p>
<p><strong>为了便于描述过程的各个阶段(下图)，我们为作为这些转换的输入和输出的坐标系统命名。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920130225.png" class="" title="image-20210920130225">

<p>将对象从原始坐标转换到屏幕空间的空间和转换序列。</p>
<p><strong>摄像机变换将标准坐标(或世界空间)中的点转换为摄像机坐标或将它们放置在摄像机空间中。投影变换将点从摄像机空间移动到标准视图体。最后，视口转换将规范视图卷映射到屏幕空间。</strong></p>
<p><strong>每一个变换都是非常简单的。我们将从视口转换开始详细讨论正投影的情况，然后讨论支持透视投影所需的更改。</strong></p>
<h3 id="The-Viewport-Transformation-视口变换"><a href="#The-Viewport-Transformation-视口变换" class="headerlink" title="The Viewport Transformation 视口变换"></a>The Viewport Transformation 视口变换</h3><p><strong>我们从一个问题开始，它的解决方案将被重用为任何查看条件。我们假设我们想要查看的几何图形是在正则视图体中，并且我们希望用正射相机在−z方向上查看它。正则视图体是包含所有笛卡尔坐标在−1和+1之间的三维点的立方体，即(x, y, z)∈[−1,1]³ (下图)。我们将x =−1投影到屏幕的左侧，x = +1投影到屏幕的右侧，y =−1投影到屏幕的底部，y = +1投影到屏幕的顶部。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920131502.png" class="" title="image-20210920131502">

<p>正则视图体是一个以原点为中心，边长为2的立方体。</p>
<p><em><em>回想一下第三章中关于像素坐标的约定:每个像素“拥有”一个以整数坐标为中心的单位正方形;图像边界有二分之一从像素中心的单位超调;和最小的像素中心坐标是(0,0)。如果我们绘制的图像(或屏幕上的窗口)有n</em>x* ×n*y</em> 像素，我们需要映射正方形[−1,1]² 到矩形[−0.5, nx − 0.5] × [−0.5, ny − 0.5]**</p>
<p><strong>现在，我们将假设所有要绘制的线段都完全在正则视图体内。稍后我们将在讨论裁剪时放宽这个假设。</strong></p>
<p><strong>由于视口转换将一个轴对齐的矩形映射到另一个，这是一个窗口转换的情况，如公式所示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920131817.png" class="" title="image-20210920131817">

<p><strong>注意，这个矩阵忽略了中点的z坐标，因为点在投影方向上的距离不会影响该点在图像中的投影位置。但是在我们正式称它为视口矩阵之前，我们添加一行和一列来沿着z坐标移动而不改变它。在本章中我们不需要它，但最终我们将需要z值，因为它们可以用来使较近的表面隐藏较远的表面(参见8.2.3节)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920131827.png" class="" title="image-20210920131827">

<h3 id="The-Orthographic-Projection-Transformation-正射变换"><a href="#The-Orthographic-Projection-Transformation-正射变换" class="headerlink" title="The Orthographic Projection Transformation 正射变换"></a>The Orthographic Projection Transformation 正射变换</h3><p><strong>当然，我们通常希望在空间的某些区域渲染几何体，而不是正则视图体。我们泛化视图的第一步将保持视图方向和方向固定，沿着−z和+y向上看，但将允许任意矩形被查看。我们不会替换视口矩阵，而是将其与右边的另一个矩阵相乘。</strong></p>
<p><strong>在这些约束下，视图体是一个轴对齐的框，我们将其边坐标命名为[l, r] × [b, t] × [f, n]，如图所示。我们称这个方框为直角视图体，边界平面如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920132445.png" class="" title="image-20210920132445">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920132432.png" class="" title="image-20210920132432">

<p><strong>这假设一个观察者沿着负z轴看，他的头指向y方向。这意味着n &gt; f，这可能是不直观的，但如果你假设整个正交视图体积有负的z值，那么z = n“近”平面更接近观察者，当且仅当n &gt; f;这里f比n小，也就是绝对值大于n的负数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920132415.png" class="" title="image-20210920132415">

<p>正射视图体积沿负z轴，因此f比n更负，因此n &gt; f。</p>
<p><strong>这个概念如上图所示。从正射视图体积到规范视图体积的变换是另一个窗口变换，因此我们可以简单地将正射视图体积和规范视图体积的边界代入，得到该变换的矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920132612.png" class="" title="image-20210920132612">

<p><strong>为了在正投影视图体中绘制3D线段，我们将它们投影到屏幕的x和y坐标中，而忽略z坐标。我们结合上方的方程来做这件事。请注意，在一个程序中，我们将两个矩阵相乘，形成一个矩阵，然后对点进行如下操作:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920134719.png" class="" title="image-20210920134719">

<p><strong>z坐标现在是[−1,1]。我们现在没有用它，但是当我们研究z缓冲区算法时，它会很有用。</strong></p>
<p><strong>绘制许多端点为ai 和bi的线段时变得既简单又有效:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920134907.png" class="" title="image-20210920134907">

<h3 id="The-Camera-Transformation-摄像机变换"><a href="#The-Camera-Transformation-摄像机变换" class="headerlink" title="The Camera Transformation 摄像机变换"></a>The Camera Transformation 摄像机变换</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920134940.png" class="" title="image-20210920134940">

<p>我们构建了一个右手基，其中w指向凝视的相反方向，v与g和t在同一平面上。</p>
<p><strong>我们希望能够在3D中改变视点并朝任何方向看。有许多约定来指定查看器的位置和方向。我们将使用以下方法(见下图):</strong></p>
<p>​    <strong>眼睛的位置e，</strong></p>
<p>​    <strong>注视方向g，</strong></p>
<p>​    <strong>视图向量t。</strong></p>
<p><strong>眼睛的位置是眼睛“看向”的位置。“如果你把图形看作摄影过程，它就是镜头的中心。凝视方向是观察者注视方向上的任何向量。视图向量是平面上的任意向量，它将观察者的头部分成左右两半，并且对于站在地面上的人来说指向“天空”。这些向量为我们提供了足够的信息来建立一个以e为原点，以uvw为基底的坐标系，使用第2.4.7节的构造:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920135529.png" class="" title="image-20210920135529">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920135634.png" class="" title="image-20210920135634">

<p>对于任意视图，我们需要更改存储在“适当的”坐标系统中的点。在这种情况下，它有原点e和以uvw表示的偏移坐标。</p>
<p><strong>我们的工作将完成如果所有点我们想改变存储在坐标原点e和基向量u, v,和w。但如上图所示,模型的坐标存储方面的规范(或世界)起源o和x - y和z轴。为了使用我们已经开发的机制，我们只需要转换线段端点的坐标，我们希望从xyz坐标到uvw坐标。这种变换在第6.5节中讨论过，执行这种变换的矩阵是摄像机坐标系的正则-基矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920135730.png" class="" title="image-20210920135730">

<p><strong>或者，我们可以把这个相同的变换看成是首先将e移动到原点，然后对齐u,v,w到x,y,z。</strong></p>
<p><strong>为了使我们之前的仅z轴查看算法适用于任意位置和方向的摄像机，我们只需要添加这个摄像机转换视口和投影变换的乘积，以便它在投影前将进入的点从世界转换为摄像机坐标:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210920135819.png" class="" title="image-20210920135819">

<p><strong>同样，一旦矩阵基础结构就位，几乎不需要任何代码。</strong></p>
<h2 id="Projective-Transformations-投影变换"><a href="#Projective-Transformations-投影变换" class="headerlink" title="Projective Transformations 投影变换"></a>Projective Transformations 投影变换</h2><p><strong>我们把透视法留到最后因为它需要一点技巧才能使它适应到向量和矩阵变换的系统。为了了解我们需要做什么，让我们看看透视投影变换需要对摄像机空间中的点做什么。回想一下，视点定位在原点，摄像机沿着z轴观察。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111149.png" class="" title="image-20210921111149">

<p>观众的眼睛在e，凝视方向是g(负z轴)。视平面是到眼睛的距离d。一个点被投影到e，它与视图平面相交的地方就是它被画的地方。</p>
<p><strong>透视的关键属性是，屏幕上物体的大小与1/z成比例，因为在原点向上看负z轴的眼睛。这可以用上图中的几何学方程更精确地表达:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111314.png" class="" title="image-20210921111314">

<p><strong>y是点在y轴上的距离，ys就是点应该画在屏幕上的位置。</strong></p>
<p><strong>我们真的很想使用我们为正投影开发的矩阵机制来绘制透视图像;然后我们可以把另一个矩阵乘到复合矩阵中使用我们已经学过的算法。然而，这种类型的变换，其中一个输入向量的坐标出现在分母上，不能使用仿射变换来实现。</strong></p>
<p><strong>我们可以用齐次坐标机制的一个简单的推广来进行除法我们已经在仿射变换中使用过了。我们同意用齐次矢量[x y z 1]^T来表示点(x, y, z)；额外的坐标w总是等于1，这是通过使用[0 0 0 1]^T来保证的,如仿射变换矩阵的第四行。</strong></p>
<p><strong>与其将1看作是强制矩阵乘法实现平移的额外部分，我们现在将它定义为x、y和z坐标的分母:齐次向量[x y z w]^T 表示点(x/w, y/w, z/w)。当w = 1时，这没有什么区别，但如果我们允许在变换矩阵的底部行中有任何值，则允许实现更广泛的转换，从而使w得到除1以外的值。</strong></p>
<p><strong>具体地说，线性变换允许我们计算表达式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111553.png" class="" title="image-20210921111553">

<p><strong>仿射变换将它扩展到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111606.png" class="" title="image-20210921111606">

<p><strong>将w作为分母进一步扩展了可能性，允许我们计算类似于</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111745.png" class="" title="image-20210921111745">

<p><strong>这可以被称为x, y, z的“线性有理函数”，但有一个额外的约束——变换点的所有坐标的分母都是相同的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111756.png" class="" title="image-20210921111756">

<p><strong>表示为矩阵变换，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111834.png" class="" title="image-20210921111834">

<p><strong>和</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111844.png" class="" title="image-20210921111844">

<p><strong>这样的变换被称为投影变换或单应变换。</strong></p>
<p><strong>例子</strong></p>
<p><strong>矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111939.png" class="" title="image-20210921111939">

<p><strong>表示一个二维投影变换，该变换将单元正方形([0,1]×[0,1])变换为下图所示的四边形。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921111952.png" class="" title="image-20210921111952">

<p>投影变换映射一个正方形为一个四边形，保留直线而不是平行线。</p>
<p><strong>例如，正方形(1,0)的右下角用齐次向量[1 0 1]^T表示并变换如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112154.png" class="" title="image-20210921112154">

<p><strong>哪个表示点(1/1/3,0/1/3)或(3,0)注意如果我们使用矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112203.png" class="" title="image-20210921112203">

<p><strong>结果是[3 0 1]^T，也表示(3,0)。实际上，任何标量乘以cM都是等价的:分子和分母都乘以c，这不会改变结果。</strong></p>
<p><strong>另一种方式来表达相同的想法，它避免了特殊处理w坐标。在这个观点中，一个3D投影变换仅仅是一个4D线性变换，额外的规定是一个向量的所有标量倍数指向同一个点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112404.png" class="" title="image-20210921112404">

<p><strong>符号~被理解为“等价于”，意思是两个齐次向量都描述了空间中的同一点。</strong></p>
<p><strong>例子</strong></p>
<p><strong>在一维齐次坐标中，我们用2个向量来表示实线上的点，我们可以用齐次向量[1.5 1]^T来表示点(1.5)，或在齐次空间中x = 1.5h直线上的任何点。(参见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112514.png" class="" title="image-20210921112514">

<p>点x = 1.5可以用直线x = 1.5h上的任意点表示，比如空心圆上的点。然而，在我们将x解释为一个常规的笛卡尔坐标之前，我们首先除以h，得到(x,h) =(1.5,1)，如黑点所示。</p>
<p><strong>在二维齐次坐标中，我们用3个向量来表示平面上的点，我们可以用齐次向量[−2;−1;2]^T表示点(−1, −0.5)，或直线x = α[−1 −0.5 1]^T上的任何其他点．直线上的任意齐次向量都可以映射到直线与平面w = 1得到它的笛卡尔坐标。(参见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112730.png" class="" title="image-20210921112730">

<p>齐次坐标中的一点等价于通过它和原点的直线上的任何点，对这一点进行归一化，等于这条直线与平面w = 1相交。</p>
<p><strong>可以根据需要多次变换齐次向量，而不必担心w坐标的值——事实上，如果w坐标在某个中间相位为零，那是可以的。只有当我们想要普通的笛卡尔坐标的点我们需要规范化的等价点w = 1,相当于所有坐标除以w。一旦我们这样做我们可以读出(x, y, z)前三个组件的坐标齐次向量。</strong></p>
<h2 id="Perspective-Projection-透视投影"><a href="#Perspective-Projection-透视投影" class="headerlink" title="Perspective Projection 透视投影"></a>Perspective Projection 透视投影</h2><p><strong>射影变换的机制使实现透视所需的z除法变得简单。在上一节首图所示的2D示例中，我们可以通过矩阵变换实现透视投影如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921112958.png" class="" title="image-20210921112958">

<p><strong>这个变换了二维齐次向量[y;z;1]^T 到一维齐次矢量[dy z]^T，表示一维点(dy/z)(因为它等价于一维齐次矢量[dy/z 1]T)。</strong></p>
<p><strong>对于3D中的“官方”透视投影矩阵，我们将采用我们通常的惯例，即原点的摄像机面向- z方向，因此点(x, y, z)的距离为- z。与正投影一样，我们也采用近平面和远平面的概念，这限制了可见距离的范围。在这种情况下，我们将使用近平面作为投影平面，因此像平面距离为−n。</strong></p>
<p><strong>所需的映射是ys= (n/z)y, x也是如此。这个变换可以通过透视矩阵来实现:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113151.png" class="" title="image-20210921113151">

<p><strong>第一行、第二行和第四行只是实现透视图方程。第三行，就像在正字法和视口矩阵中一样，被设计为带着z坐标，以便我们以后可以使用它来移除隐藏的表面。但是在透视投影中，加上一个非常数分母会让我们无法保持z的值——实际上不可能在得到x和y的同时保持z不变。相反，对于近平面或远平面上的点，我们选择保持z不变。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113305.png" class="" title="image-20210921113305">

<p>透视投影保持z = n平面上的点不变并映射，大z = f矩形在透视体的后面到小z = f矩形在正投影体的后面。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113315.png" class="" title="image-20210921113315">

<p>透视投影将任何通过原点/眼睛的线映射到与之平行的线z轴，并且不移动直线上z = n的点。</p>
<p><strong>有许多矩阵可以作为透视矩阵，它们都是非线性扭曲z坐标的。这个矩阵具有如上两图所示的良好性质;它让(z = n)平面上的点完全独立，也让(z = f)平面上的点在x和y中以适当的数量“挤压”它们。矩阵对点的影响</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113503.png" class="" title="image-20210921113503">

<p><strong>正如你所看到的,x和y是按比例缩小的,更重要的是,除以z。因为n和z(视图内卷)是消极的,没有“翻转”x和y。虽然它不明显,变换还保留之间的相对顺序z值z = n和z = f,允许我们做深度排序后这个矩阵。这在我们以后做隐面消除时很重要。</strong></p>
<p><strong>有时我们想求P的逆，例如，把屏幕坐标加z带回到原来的空间，就像我们想做的那样挑选。逆是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113702.png" class="" title="image-20210921113702">

<p><strong>由于齐次向量乘以标量不会改变它的意义，所以对齐次向量作用的矩阵也是如此。所以我们可以通过乘以nf把逆矩阵写成更漂亮的形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113711.png" class="" title="image-20210921113711">

<p><strong>在正投影矩阵Morth的背景下，透视矩阵简单地将透视视图体积(形状像金字塔的切片或截锥)映射到正射视图体积(轴对齐的框)。透视矩阵的美妙之处在于，一旦我们应用它，我们可以使用一个正交变换来得到规范的视图体积。因此，所有的正字法机制都适用，我们所添加的只是一个矩阵和除以w。而且，我们没有“浪费”4 × 4矩阵的底部行。</strong></p>
<p><strong>连接P和Morth 得到透视投影矩阵，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921113934.png" class="" title="image-20210921113934">

<p><strong>然而，有一个问题是:l,r,b,t是如何确定的?它们确定了我们观察的“窗口”。由于透视矩阵不改变(z = n)平面上x和y的值，我们可以指定(l, r, b, t)在该平面上。</strong></p>
<p><strong>为了将透视矩阵集成到我们的正字法基础结构中，我们只需替换Morth与Mper，将透视矩阵P插入相机矩阵Mcam 但在正投影之前。所以透视法的全部矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114158.png" class="" title="image-20210921114158">

<p><strong>得到的算法是:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114324.png" class="" title="image-20210921114324">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114342.png" class="" title="image-20210921114342">

<p><strong>注意，除了附加矩阵之外，唯一的变化是除以齐次坐标w。</strong></p>
<p><strong>乘出来，矩阵Mper 是这样的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114424.png" class="" title="image-20210921114424">

<p><strong>这种或类似的矩阵经常出现在文档中，当人们意识到它们通常是几个简单矩阵的乘积时，它们就不那么神秘了。</strong></p>
<p><strong>例子</strong></p>
<p><strong>许多API，如OpenGL (Shreiner, Neider, Woo， &amp; Davis, 2004)使用这里展示的相同规范视图量。他们还通常让用户指定n和f的绝对值。OpenGL的投影矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210921114505.png" class="" title="image-20210921114505">

<p><strong>其他API分别将n和f发送给0和1。Blinn (J. Blinn, 1996)建议使规范视图体积[0,1]³更有效率。所有这些决定会稍微改变投影矩阵。</strong></p>
<h2 id="Some-Properties-of-the-Perspective-Transform-透视变换的性质"><a href="#Some-Properties-of-the-Perspective-Transform-透视变换的性质" class="headerlink" title="Some Properties of the Perspective Transform 透视变换的性质"></a>Some Properties of the Perspective Transform 透视变换的性质</h2><p><strong>透视变换的一个重要特性是它将直线转换为直线，将平面转换为平面。此外，它将视图体积中的线段取为线在标准体积中的部分。要了解这一点，考虑线段</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104158.png" class="" title="image-20210922104158">

<p><strong>经4 × 4矩阵M变换后，为齐次坐标可能变化的点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104219.png" class="" title="image-20210922104219">

<p><strong>均匀化的三维线段为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104230.png" class="" title="image-20210922104230">

<p><strong>如果上式可以改写为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104241.png" class="" title="image-20210922104241">

<p><strong>那么所有均匀化的点都在一条3D直线上。对上上式的蛮力操作产生这样的形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104254.png" class="" title="image-20210922104254">

<p><strong>它还证明了线段映射到保留点顺序的线段，即它们不会被重新排序或“撕破”。</strong></p>
<p><strong>将线段转换为线段的一个副产品是它将一个三角形的边和顶点转换为另一个三角形的边和顶点。因此，三角形对三角形，平面对平面。</strong></p>
<h2 id="Field-of-View-视场"><a href="#Field-of-View-视场" class="headerlink" title="Field-of-View 视场"></a>Field-of-View 视场</h2><p><strong>虽然我们可以使用(l, r, b, t)和n值指定任何窗口，但有时我们希望有一个更简单的系统，我们透过窗口的中心。这意味着约束</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104637.png" class="" title="image-20210922104637">

<p><strong>如果我们还添加像素是正方形的约束，即。，则r与t的比值必须等于水平像素数与垂直像素数的比值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104646.png" class="" title="image-20210922104646">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104745.png" class="" title="image-20210922104745">

<p>视场θ是从眼睛测量的屏幕底部到屏幕顶部的角度。</p>
<p><strong>一旦nx 和ny ，则只剩下一个自由度。这通常使用上图所示的θ视场来设置。这有时被称为垂直视场，以区分左右两边的角度或对角线之间的角度。从图中我们可以看出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210922104803.png" class="" title="image-20210922104803">

<p><strong>如果n和θ是指定的，那么我们可以推导出t，并对更一般的观察系统使用代码。在某些系统中，n的值被硬编码成一个合理的值，因此我们少了一个自由度。</strong></p>
<h1 id="8-The-Graphics-Pipeline-图形管线"><a href="#8-The-Graphics-Pipeline-图形管线" class="headerlink" title="8 The Graphics Pipeline 图形管线"></a>8 The Graphics Pipeline 图形管线</h1><p><strong>前面几章已经建立了数学框架，我们需要看看渲染的第二种主要方法:一个一个地在屏幕上绘制对象，或者对象顺序渲染。不像在光线追踪中，我们依次考虑每个像素并找到影响其颜色的对象，我们现在将依次考虑每个几何对象并找到它可能产生影响的像素。找到图像中所有被几何元素占用的像素的过程称为光栅化，因此目标顺序绘制也可以称为光栅化绘制。所需的操作序列，从对象开始，到更新图像中的像素结束，称为图形管线。（基于光栅化的系统也称为扫描线渲染器。）</strong></p>
<p><strong>对象顺序呈现由于其效率而获得了巨大的成功。对于大型场景，数据访问模式的管理对性能至关重要，与重复搜索场景以获取遮蔽每个像素所需的对象相比，在场景中访问每一位几何图形具有显著的优势。</strong></p>
<p><strong>本章的标题表明，只有一种方法可以进行对象顺序呈现。当然这并不是真的——有两个目标迥异的图形管线的例子，一个是通过OpenGL和Direct3D等API支持交互渲染的硬件管道，另一个是用于电影制作的软件管线，支持RenderMan等API。硬件管线必须运行得足够快，以便对游戏、可视化和用户界面做出实时反应。制作管线必须尽可能呈现最高质量的动画和视觉效果，并将规模扩大到巨大的场景，但这可能需要很多时间有更多的时间。尽管这些不同的目标导致了不同的设计决策，但在大多数(如果不是全部)管线中，有相当一部分是共享的，本章试图关注这些共同的基础，错误的是更紧密地跟随硬件管线。</strong></p>
<p><strong>在对象顺序渲染中需要完成的工作可以组织到光栅化本身的任务中，光栅化之前对几何体所做的操作，以及光栅化之后对像素所做的操作。最常见的几何操作是应用矩阵变换，如前两章所讨论的，将定义几何的点从对象空间映射到屏幕空间，以便光栅化器的输入以像素坐标或屏幕空间表示。最常见的像素操作是隐藏的表面移除，它让离观察器更近的表面出现在离观察器更远的表面前面。在每个阶段还可以包含许多其他操作，从而使用相同的通用流程实现各种不同的渲染效果。</strong></p>
<p><strong>出于本章的目的，我们将根据四个阶段来讨论图形管道(下图)。几何对象从交互式应用程序或场景描述文件输入到管线中，它们总是由顶点集描述。在顶点处理阶段对顶点进行操作，然后使用这些顶点的原语被发送到光栅化阶段。光栅化器将每个原语分解成若干片段，每个片段对应原语覆盖的每个像素。在碎片处理阶段对碎片进行处理，然后在碎片混合阶段对每个像素对应的各个碎片进行组合。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923095933.png" class="" title="image-20210923095933">

<p><strong>我们将从讨论光栅化开始，然后通过一系列的例子说明几何和像素级的目的。</strong></p>
<h2 id="Rasterization-光栅化"><a href="#Rasterization-光栅化" class="headerlink" title="Rasterization 光栅化"></a>Rasterization 光栅化</h2><p><strong>光栅化是对象顺序图形的核心操作，而光栅化是任何图形管线的中心。对于每个传入的原语，光栅化器有两个任务:枚举原语所覆盖的像素，并在原语中插入称为属性的值——这些属性的用途将在后面的示例中明确。光栅化器的输出是一组片段，每个片段对应原语覆盖的每个像素。每个片段“存在”在一个特定的像素上，并携带自己的一组属性值。</strong></p>
<p><strong>在本章中，我们将介绍光栅化，以便使用它来渲染三维场景。同样的光栅化方法用于绘图也可以使用2D的线条和形状——尽管使用3D图形系统“在幕后”绘制所有2D图形已经变得越来越普遍。</strong></p>
<h3 id="Line-Drawing-绘制直线"><a href="#Line-Drawing-绘制直线" class="headerlink" title="Line Drawing 绘制直线"></a>Line Drawing 绘制直线</h3><p><strong>大多数图形包都包含一个线绘制命令，它在屏幕坐标中接受两个端点，并在它们之间绘制一条线。例如，调用端点(1,1)和(3,2)将打开像素(1,1)和(3,2)，并在它们之间填充一个像素。对于一般的屏幕坐标端点(x0,y0)和(x1,y1)，程序应该绘制一些“合理的”像素集合，以近似它们之间的一条线。画这样的直线是基于直线方程的，我们有两种类型的方程可以选择:隐式方程和参数方程。本节介绍使用隐式直线的方法。</strong></p>
<h4 id="Line-Drawing-Using-Implicit-Line-Equations-用隐式直线方程绘制直线"><a href="#Line-Drawing-Using-Implicit-Line-Equations-用隐式直线方程绘制直线" class="headerlink" title="Line Drawing Using Implicit Line Equations 用隐式直线方程绘制直线"></a>Line Drawing Using Implicit Line Equations 用隐式直线方程绘制直线</h4><p><strong>使用隐式方程画线最常见的方法是中点算法(Pitteway (1967);范肯和诺瓦克(1985))。中点算法最终绘制的线与Bresenham算法(Bresenham, 1965)相同，但它在某种程度上更直接。</strong></p>
<p><strong>首先要做的是找到这条直线的隐式方程:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923104351.png" class="" title="image-20210923104351">

<p>*<em>我们假设x0 <em>≤x</em>1．如果它不成立，我们交换点，使它成立。直线的斜率m是</em>*</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923104413.png" class="" title="image-20210923104413">

<p><strong>下面的讨论假设m∈(0,1]。对于m∈(−∞，−1]，m∈(−1,0]，m∈(1，∞)也可以得到类似的讨论。这四种情况涵盖了所有的可能性。</strong></p>
<p><strong>对于m∈(0,1)，“跑”比“升”多，即如果我们有一个y轴向下的API，我们可能会担心这是否会使过程更困难，但事实上，我们可以忽略这个细节。我们可以忽略“上”和“下”的几何概念，因为这两种情况的代数是完全相同的。中点算法的关键假设是我们尽可能画出最细的线没有差距。两个像素之间的对角线连接不被认为是一个间隙。</strong></p>
<p><strong>当线条从左端点向右移动时，只有两种可能:在与左端点相同的高度绘制一个像素，或者在更高的高度绘制一个像素。在端点之间的每一列像素中总是有一个精确的像素。0表示有空隙，2表示这条线太粗了。对于我们所考虑的情况，可能在同一行中有两个像素;这条线是水平的，而不是垂直的，所以有时它会向右，有时向上。这个概念如图所示，其中显示了三条“合理”的线，每条线在水平方向上比在垂直方向上前进得更多。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923104824.png" class="" title="image-20210923104824">

<p>三条“合理的”线，水平方向7个像素，垂直方向3个像素。</p>
<p><strong>m∈(0,1)的中点算法首先建立最左边的像素和最右边像素的列数(x值)，然后水平循环建立每个像素的行(y值)。算法的基本形式为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923104932.png" class="" title="image-20210923104932">

<p><strong>注意x和y是整数。也就是说，“保持从左到右绘制像素，有时在y方向上移动。关键是在if语句中建立有效的决策方法。</strong></p>
<p><strong>做出选择的一种有效方法是查看两个潜在像素中心之间的线的中点。更具体地说,只是画像素(x, y)的中心在实际屏幕坐标(x, y)候选像素是吸引到正确的像素(x + 1, y)和(x + 1, + 1)。这两个候选人的中心像素之间的中点是(x + 1, y + 0.5)。如果直线通过中点以下，我们绘制底部像素，否则我们绘制顶部像素(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105044.png" class="" title="image-20210923105044">

<p>上:线在中点之上，所以上面的像素被画出来。底部:线在中点以下，因此底部像素被绘制。</p>
<p><strong>为了确定直线是通过(x+1, y+0.5)还是通过(x, y+0.5)，我们在直线隐式方程中计算f(x, y+0.5)。回忆一下第2.5.1节，f(x, y) = 0是直线上的点(x, y)，直线一侧的点f(x, y) &gt;0，直线另一侧的点f(x, y) &lt; 0。因为−f(x, y) = 0和f(x, y) = 0都是直线的完美方程，所以f(x, y)为正是否表示(x, y)在直线之上或之下并不是立即明确的。但是，我们可以算出来;直线隐式方程中的关键项是y项(x1−x0) y。请注意,(x1 −x0)肯定是正的，因为x1&gt; x0．这意味着随着y的增加，项(x1−x0)y变大。因此，f(x， +∞)一定是正的，而且一定在直线之上，这意味着直线之上的点都是正的。另一个看它的方法是梯度向量的y分量是正的。所以在直线上，y可以任意增加，f(x, y)一定是正的。这意味着我们可以通过填充if语句使代码更具体:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105635.png" class="" title="image-20210923105635">

<p><strong>上面的代码将很好地工作的直线适当的斜率(即在0和1之间)。读者可以算出另外三种情况，它们只是在小细节上有所不同。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105742.png" class="" title="image-20210923105742">

<p>当使用两个橙色像素之间显示的决策点时，我们只画出蓝色像素，因此我们在左边显示的两个点之一计算f。</p>
<p><strong>如果需要更高的效率，使用增量方法会有所帮助。增量方法试图通过重用前一步的计算来提高循环的效率。在本文提出的中点算法中，主要计算f(x + 1, y + 0.5)的值。注意，在循环内部，在第一次迭代之后，我们已经计算了f(x−1,y + 0.5)或f(x−1,y−0.5)(上图)。还要注意这个关系:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105752.png" class="" title="image-20210923105752">

<p><strong>这允许我们编写代码的增量版本:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923105912.png" class="" title="image-20210923105912">

<p><strong>这段代码应该运行得更快,因为它几乎没有额外的设置成本,增量版本(增量算法并不总是如此),但它可能积累更多数字错误,因为f (x, y + 0.5)可能是由许多长时间行补充。然而，考虑到线条很少超过几千像素，这样的错误不太可能是严重的。通过存储(x1−x0) + (y0−y1)和(y0 −y1)作为变量。我们可能希望一个好的编译器能帮我们做到这一点，但是如果代码是关键的，那么检查编译结果是明智的。</strong></p>
<h3 id="Triangle-Rasterization-三角形光栅化"><a href="#Triangle-Rasterization-三角形光栅化" class="headerlink" title="Triangle Rasterization 三角形光栅化"></a>Triangle Rasterization 三角形光栅化</h3><p><strong>我们通常想画一个二维三角形，上面有二维点p0= (x0,y0), p1= (x1,y1), p2= (x2,y2)的屏幕坐标。这类似于线描问题，但它有自己的一些微妙之处。与线描一样，我们可能希望从顶点的值中插入颜色或其他属性。如果我们有重心坐标，这就很简单了(第2.7节)。例如，如果顶点的颜色是c0,c1,c2，质心坐标(α， β， γ)三角形中某一点的颜色为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923110431.png" class="" title="image-20210923110431">

<p><strong>这种类型的颜色插值在图形中被称为高洛插值，以其发明者(高洛，1971)命名。</strong></p>
<p><strong>光栅化三角形的另一个微妙之处是，我们通常光栅化共享顶点和边的三角形。这意味着我们想要栅格化相邻的三角形，这样就没有洞了。我们可以通过使用中点算法来绘制每个三角形的轮廓，然后填充内部像素。这意味着相邻三角形沿着每条边都画出相同的像素。如果相邻三角形有不同的颜色，图像将取决于两个三角形的绘制顺序。最常见的栅格化三角形的方法是避免顺序问题和消除洞是使用约定，当且仅当像素的中心在三角形，即像素中心的重心坐标都在区间(0,1)内。这提出了一个问题，如果中心正好在三角形的边缘，该怎么办。有几种方法可以处理这个问题，本节稍后将对此进行讨论。关键的观察是，重心坐标允许我们决定是否绘制像素，以及如果我们从顶点插值颜色，该像素应该是什么颜色。因此，我们的三角形栅格化问题归结为有效地找到像素中心的重心坐标(Pineda, 1988)。蛮力光栅化算法为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923110634.png" class="" title="image-20210923110634">

<p><strong>算法的其余部分将外循环限制在更小的候选像素集上，使重心计算更加高效。</strong></p>
<p><strong>我们可以添加一个简单的效率，通过找到三个顶点的边界矩形，并只在这个矩形上循环候选像素来绘制。质心坐标可由之前讲过的方法计算。这就产生了算法:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923110737.png" class="" title="image-20210923110737">

<p><strong>这里fij是由隐式直线方程给出的带有适当顶点的直线:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923110846.png" class="" title="image-20210923110846">

<p><strong>注意，我们已经将检验α∈(0,1)与α &gt; 0等进行了交换，因为如果所有的α， β， γ都是正的，那么我们知道它们都小于1，因为α + β + γ = 1。我们也只能计算三个重心变量中的两个然后从这个关系中得到第三个，但是不清楚一旦算法进行增量，这是否节省了计算，这在线图算法中是可能的;α， β和γ的每一个计算都是f(x, y) = Ax + By + C的形式。在内部循环中，只有x改变，它改变1。注意f(x + 1, y) = f(x, y) + A，这是增量算法的基础。在外循环中，f(x, y)的求值变化为f(x, y + 1)，因此可以达到类似的效果。因为α， β和γ在循环中以恒定的增量变化，颜色c也是如此。所以这也可以是增量的。例如，像素(x + 1, y)的红色值与像素(x, y)的红色值相差一个可预先计算的常量。一个带有颜色插值的三角形示例如图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923111110.png" class="" title="image-20210923111110">

<p>一个带重心插值的彩色三角形。注意，颜色组件的变化在每行、每列以及每条边都是线性的。事实上，它在每条直线上都是常数，比如对角线。</p>
<h4 id="Dealing-with-Pixels-on-Triangle-Edges-处理三角形边缘上的像素"><a href="#Dealing-with-Pixels-on-Triangle-Edges-处理三角形边缘上的像素" class="headerlink" title="Dealing with Pixels on Triangle Edges 处理三角形边缘上的像素"></a>Dealing with Pixels on Triangle Edges 处理三角形边缘上的像素</h4><p><strong>我们还没有讨论如何处理中心正好在三角形边缘的像素。如果一个像素恰好在三角形的边缘，那么它也在相邻三角形的边缘(如果有相邻三角形的话)。没有一种明显的方法将像素授予一个三角形或另一个三角形。最糟糕的决定是不画像素，因为两个三角形之间会出现一个洞。更好的方法是让两个三角形都绘制像素，但仍然不是很好。如果三角形是透明的，就会产生双色。我们希望将像素分配给其中一个三角形，我们希望这个过程能够简单些;选择哪个三角形并不重要，只要选择是明确的。</strong></p>
<p><strong>一种方法是注意任何离屏点都是在共享边的一边，这就是我们要画的边。对于两个不重叠的三角形，不在边上的顶点在边的相对边上。恰好有一个顶点与离屏点位于同一边(下图)。这是测试的基础。测试数字p和q是否具有相同的符号可以实现为测试pq &gt; 0，这在大多数环境中非常有效。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923111407.png" class="" title="image-20210923111407">

<p>屏幕外的点将在三角形边还是其他边。只有一个非共享顶点a和b在同一边。</p>
<p><strong>请注意，测试并不完美，因为通过边缘的线也可能通过屏幕外的点，但我们至少大大减少了问题案例的数量。使用哪个屏幕外点是任意的，(x, y) =(−1，−1)是一个很好的选择。我们将需要添加一个检查的情况下，一个点正好在边缘上。我们希望这种检查不触及普通情况下，这是完全内部或外部测试。这表明:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923111551.png" class="" title="image-20210923111551">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923111609.png" class="" title="image-20210923111609">

<p><strong>我们可能认为，只有当我们对两个三角形使用完全相同的直线方程时，上述代码才能消除洞和重复绘制。事实上，只有当两个共享顶点在每个三角形的绘制调用中具有相同的顺序时，直线方程才是相同的。否则方程可能会倒过来。这可能是一个问题，取决于编译器是否更改操作顺序。因此，如果需要健壮的实现，可能需要检查编译器和算术单元的细节。上面伪代码中的前四行必须仔细编码，以处理边缘正好碰到像素中心的情况。</strong></p>
<p><strong>除了适应增量实现之外，还有几个潜在的早期退出点。例如，如果α是负的，就不需要计算β或γ。虽然这可能会很好地提高速度，但分析总是一个好主意;额外的分支可能会减少管线或并发性，并可能降低代码速度。因此，与往常一样，如果代码是关键部分，请测试任何看起来有吸引力的优化。</strong></p>
<p><strong>上述代码的另一个细节是，对于退化三角形，除法可以是被零除法，即如果fγ = 0。应该正确地考虑浮点错误条件，否则就需要进行另一个测试。</strong></p>
<h3 id="Clipping-裁剪"><a href="#Clipping-裁剪" class="headerlink" title="Clipping 裁剪"></a>Clipping 裁剪</h3><p><strong>简单地将原语转换到屏幕空间并对它们进行光栅化并不能完全独立地工作。这是因为在视图体积之外的原语——特别是在眼睛后面的原语可能最终被光栅化，导致不正确的结果。例如，考虑下图中所示的三角形。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112055.png" class="" title="image-20210923112055">

<p>深度z转换成深度z′通过透视变换。注意当z从正到负，z′从负转换为正。因此，眼睛后面的顶点在眼睛前面移动超过z′ = n + f。这将导致错误的结果，这就是为什么三角形首先被裁剪，以确保所有顶点都在眼睛前面。</p>
<p><strong>两个顶点在视图体中，但第三个顶点在眼睛后面。投影变换将这个顶点映射到远平面后面一个毫无意义的位置，如果允许这种情况发生，三角形将不正确地光栅化。由于这个原因，光栅化之前必须进行一个剪切操作，删除部分可能延伸到眼睛后面的原语。</strong></p>
<p><strong>裁剪是图形中的一种常见操作，每当一个几何实体“裁剪”另一个实体时都需要它。例如，如果你在平面x = 0上裁剪一个三角形，如果顶点的x坐标的符号不完全相同，那么平面会将三角形切割成两部分。在大多数剪切应用中，在平面的“错误”边的三角形部分被丢弃。单个平面的操作如图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112330.png" class="" title="image-20210923112330">

<p>一个多边形被剪切到剪切平面上。平面的“内部”部分被保留。</p>
<p><strong>在为光栅化做准备的裁剪中，“错误”的一面是视图体外的一面。将视图体外的所有几何图形裁剪总是安全的——也就是说，将视图体的所有六个面都剪掉——但许多系统只能将视图体的近平面剪掉。</strong></p>
<p><strong>本节讨论裁剪模块的基本实现。那些对实现工业速度的裁剪器感兴趣的人应该看看Blinn在本章末尾的注释中提到的书。</strong></p>
<p><strong>实现裁剪的两种最常见的方法是：</strong></p>
<p>​    <strong>1.在世界坐标系中，用六个平面来连接截断的视锥金字塔，</strong></p>
<p>​    <strong>2.在齐次除法之前的四维变换空间中。</strong></p>
<p><strong>任何一种可能性都可以有效地实现(J. Blinn, 1996)，对每个三角形采用以下方法:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112619.png" class="" title="image-20210923112619">

<h3 id="Clipping-Before-the-Transform-Option-1-变换前的裁剪-选项1"><a href="#Clipping-Before-the-Transform-Option-1-变换前的裁剪-选项1" class="headerlink" title="Clipping Before the Transform (Option 1) 变换前的裁剪(选项1)"></a>Clipping Before the Transform (Option 1) 变换前的裁剪(选项1)</h3><p><strong>选项1有一个简单的实现。唯一的问题是，“这六个平面方程是什么?”“因为这些方程对于单一图像中呈现的所有三角形都是相同的，我们不需要非常高效地计算它们。出于这个原因，我们可以将转换反转并应用转换后的视图体积的8个顶点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112806.png" class="" title="image-20210923112806">

<p><strong>从这里可以推导出平面方程。或者，我们可以使用矢量几何直接从观看参数得到平面。</strong></p>
<h3 id="Clipping-in-Homogeneous-Coordinates-Option-2-齐次坐标裁剪-选项2"><a href="#Clipping-in-Homogeneous-Coordinates-Option-2-齐次坐标裁剪-选项2" class="headerlink" title="Clipping in Homogeneous Coordinates (Option 2) 齐次坐标裁剪(选项2)"></a>Clipping in Homogeneous Coordinates (Option 2) 齐次坐标裁剪(选项2)</h3><p><strong>通常实现的选项是在除法之前在齐次坐标中进行裁剪。这里的视图体是4D的，它被3D体(超平面)所包围。它们是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923112928.png" class="" title="image-20210923112928">

<p><strong>这些平面非常简单，所以效率比选择1更好。它们仍然可以通过将视图体积[l, r] × [b, t] × [f, n]转换为[0,1]³来改进。事实证明，三角形的裁剪并不比3D复杂多少。</strong></p>
<h3 id="Clipping-against-a-Plane-平面相交裁剪"><a href="#Clipping-against-a-Plane-平面相交裁剪" class="headerlink" title="Clipping against a Plane 平面相交裁剪"></a>Clipping against a Plane 平面相交裁剪</h3><p><strong>无论我们选择哪一种，我们都必须与一个平面相交。回想一下第2.5.5节，平面通过点q且法线n的隐式方程是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113253.png" class="" title="image-20210923113253">

<p><strong>这经常被写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113306.png" class="" title="image-20210923113306">

<p><strong>有趣的是，这个方程不仅描述了一个三维平面，还描述了一条二维的直线和一个四维平面的体积模拟。所有这些实体在其相应的维度上通常被称为平面。</strong></p>
<p><strong>如果我们有一条线段在点a和点b之间，我们可以使用在第12.4.3节描述的BSP树程序中切割3D三角形的边的技术将它“裁剪”到一个平面上。在这里，通过检查f(a)和f(b)是否有不同的符号来测试点a和b是否在平面f(p) = 0的相对两边。通常，f(p) &lt; 0被定义为“在”平面内，而f(p) &gt; 0被定义为“在”平面外。如果平面确实分割了直线，那么我们可以通过将方程代入参数直线来求交点，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113317.png" class="" title="image-20210923113317">

<p><strong>在平面通过点q且法线n的隐式方程的f(p) = 0平面上：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113325.png" class="" title="image-20210923113325">

<p><strong>解t得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923113336.png" class="" title="image-20210923113336">

<p><strong>然后我们可以找到交点并“缩短”这条线。</strong></p>
<p><strong>为了裁剪一个三角形，我们可以按照12.4.3节来制作一个或两个三角形。</strong></p>
<h2 id="Operations-Before-and-After-Rasterization-光栅化的前后操作"><a href="#Operations-Before-and-After-Rasterization-光栅化的前后操作" class="headerlink" title="Operations Before and After Rasterization 光栅化的前后操作"></a>Operations Before and After Rasterization 光栅化的前后操作</h2><p><strong>在可以光栅化一个原语之前，定义它的顶点必须在屏幕坐标中，并且应该在原语中插入的颜色或其他属性必须是已知的。准备这些数据是管线顶点处理阶段的工作。在这个阶段，进入的顶点通过建模、查看和投影转换进行转换，将它们从原始坐标映射到屏幕空间(回想一下，在这里，位置是用像素度量的)。同时，其他信息，如颜色、表面法线或纹理坐标，将根据需要进行转换;我们将在下面的示例中讨论这些附加属性。</strong></p>
<p><strong>光栅化后，进一步处理，为每个碎片计算颜色和深度。这个处理过程可以简单到只需通过一个插值的颜色和使用光栅化器计算的深度;或者包括复杂的着色操作。最后，混合阶段结合由重叠每个像素的(可能是几个)原语生成的片段来计算最终的颜色。最常见的混合方法是用最小的深度(最接近眼睛)选择碎片的颜色。</strong></p>
<p><strong>不同阶段的目的最好通过例子来说明。</strong></p>
<h3 id="Simple-2D-Drawing-简单的2D绘制"><a href="#Simple-2D-Drawing-简单的2D绘制" class="headerlink" title="Simple 2D Drawing 简单的2D绘制"></a>Simple 2D Drawing 简单的2D绘制</h3><p><strong>最简单的管线在顶点或片段阶段什么都不做，在混合阶段，每个片段的颜色只是覆盖前一个片段的值。应用程序直接在像素坐标中提供原语，光栅化完成所有工作。这种基本安排是许多用于绘制用户界面、绘图、图形和其他2D内容的简单、较老的API的精髓。纯色形状可以通过为每个原语的所有顶点指定相同的颜色来绘制，我们的模型管道也支持使用插值平滑地变化颜色。</strong></p>
<h3 id="A-Minimal-3D-Pipeline-最小的化3D管线"><a href="#A-Minimal-3D-Pipeline-最小的化3D管线" class="headerlink" title="A Minimal 3D Pipeline 最小的化3D管线"></a>A Minimal 3D Pipeline 最小的化3D管线</h3><p><strong>绘制3D对象,唯一的变化需要的2D绘图管线是一个矩阵变换:顶点处理阶段计算的顶点位置的产品建模、相机,投影,和视窗矩阵,导致空间三角形,然后在指定的一样,如果他们已经直接在2D。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923114158.png" class="" title="image-20210923114158">

<p>两个遮挡周期，不能画出来前后颠倒的顺序。</p>
<p><strong>最小3D管道的一个问题是，为了获得正确的遮挡关系——让较近的物体在较远的物体前面——原语必须按照前后顺序绘制。这被称为画家去除隐藏表面的算法，类似于先画一幅画的背景，然后在它上面画前景。画家的算法是去除隐藏表面的完美有效方法，但它有几个缺点。它不能处理彼此相交的三角形，因为没有正确的顺序来画它们。类似地，几个三角形，即使它们没有相交，仍然可以被安排在一个闭塞循环中，如上图所示，这是另一种前后顺序不存在的情况。最重要的是，根据深度对原语进行排序很慢，特别是在大场景中，并且干扰了数据的有效流动，这使得对象顺序渲染如此之快。下图显示了不按深度对对象排序时的处理结果。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923114209.png" class="" title="image-20210923114209">

<p>用最小的管道绘制两个相同大小的球体的结果。看起来较小的球体距离较远，但却是最后绘制的，因此它错误地覆盖了较近的球体。</p>
<h3 id="Using-a-z-Buffer-for-Hidden-Surfaces-为隐藏表面使用z-Buffer"><a href="#Using-a-z-Buffer-for-Hidden-Surfaces-为隐藏表面使用z-Buffer" class="headerlink" title="Using a z-Buffer for Hidden Surfaces 为隐藏表面使用z-Buffer"></a>Using a z-Buffer for Hidden Surfaces 为隐藏表面使用z-Buffer</h3><p><strong>实践中，画家算法很少被使用;取而代之的是一种简单而有效的隐藏表面去除算法，即z-缓冲区算法。这个方法非常简单:在每个像素处，我们跟踪到目前为止绘制的最近的表面的距离，然后丢弃比这个距离更远的碎片。最近距离是通过为每个像素分配一个额外的值来存储的，除了红色、绿色和蓝色的值，这被称为深度，或z值。深度缓冲区，或z-缓冲区，是包含深度值的网格的名称。</strong></p>
<p><strong>z-buffer算法是在碎片混合阶段实现的，通过比较每个碎片的深度与z-buffer中存储的当前值。如果片段的深度比较接近，它的颜色和深度值都会覆盖颜色和深度缓冲区中当前的值。如果碎片的深度较远，它将被丢弃。为了确保第一个片段将通过深度测试，z缓冲区被初始化为最大深度(远平面的深度)。无论表面的绘制顺序如何，相同的碎片将赢得深度测试，图像将是相同的。</strong></p>
<p><strong>z-buffer算法要求每个片段携带一个深度。这只需将z坐标插值为顶点属性，就像插值颜色或其他属性一样。</strong></p>
<p><strong>z缓冲区是处理对象顺序渲染中隐藏表面的一种简单而实用的方法，它是目前最主要的方法。它比将表面切割成可以按深度排序的块的几何方法简单得多，因为它避免了解决任何不需要解决的问题。深度顺序只需要在像素的位置上确定，这就是z缓冲区所做的。它得到了硬件图形管线的普遍支持，也是软件管线最常用的方法。下图显示了一个示例结果。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923114643.png" class="" title="image-20210923114643">

<p>结果是用z缓冲区画出两个相同的球体。</p>
<h4 id="Precision-Issues-精度问题"><a href="#Precision-Issues-精度问题" class="headerlink" title="Precision Issues 精度问题"></a>Precision Issues 精度问题</h4><p><strong>实际上，存储在缓冲区中的z值是非负整数。这比真正的浮点数更可取，因为z缓冲区所需的快速内存有点昂贵，值得保持在最小值。</strong></p>
<p><strong>使用整数会导致一些精度问题。如果我们使用一个整数范围有B值{0,1,…,B−1},裁剪面附近我们可以映射0到z = n和B−1到遥远的剪切面z = f。注意,这次讨论,我们假设z, n, f是正的。这将导致与否定情况相同的结果，但论证的细节更容易理解。我们将每个z值发送到a“桶”，深度Δz = (f−n)/B。如果内存不是额外的，我们就不会使用整数z缓冲区，因此使B尽可能小是很有用的。</strong></p>
<p><strong>如果分配b位来存储z值，那么B = 2^b．我们需要足够的位来确保任何三角形在另一个三角形前面的深度映射到不同的深度箱子。</strong></p>
<p><strong>例如，如果您正在渲染一个场景，其中三角形的间距至少为一米，那么Δz &lt; 1应该生成没有伪影的图像。有两种方法可以使Δz变小:将n和f移得更近或增加b。如果b是固定的，就像在API或特定硬件平台上一样，调整n和f是唯一的选择。</strong></p>
<p><strong>当创建透视图像时，z缓冲区的精度必须非常小心地处理。上面的值Δz是在透视划分之后使用的。回忆一下在第7.3节中透视图划分的结果是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923115137.png" class="" title="image-20210923115137">

<p><strong>实际的桶深与zw有关，世界深度，而不是z，后透视分深度。我们可以通过区分两边来近似桶的大小:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923115159.png" class="" title="image-20210923115159">

<p><strong>桶大小的深度各不相同。世界空间的箱子大小是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923115210.png" class="" title="image-20210923115210">

<p><strong>请注意，Δz的数量与前面讨论的相同。最大的箱子′= f,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923115221.png" class="" title="image-20210923115221">

<p><strong>请注意，如果我们不想在眼前丢失对象，选择n = 0是很自然的选择，这将导致一个无限大的箱子——非常糟糕的情况。让Δzw^max尽可能的小，我们需要最小化f和n。因此，仔细选择n和f总是很重要的。</strong></p>
<h3 id="Per-vertex-Shading-逐顶点着色"><a href="#Per-vertex-Shading-逐顶点着色" class="headerlink" title="Per-vertex Shading 逐顶点着色"></a>Per-vertex Shading 逐顶点着色</h3><p><strong>到目前为止，将三角形发送到管线中的应用程序负责设置颜色;光栅化器只是插入颜色，它们直接写入输出图像。对于某些应用程序来说，这已经足够了，但在很多情况下，我们想要用着色影来绘制3D对象，使用与第4章中用于图像顺序渲染的相同的渲染方程。回想一下，这些方程需要光方向、眼睛方向和表面法线来计算表面的颜色。</strong></p>
<p><strong>处理着色计算的一种方法是在顶点阶段执行它们。应用程序提供顶点的法向量，并且光源的位置和颜色是单独提供的(它们不会在整个表面上变化，所以它们不需要为每个顶点指定)。对于每个顶点，观察者的方向和每个光源的方向都是基于摄像机、光源和顶点的位置计算的。计算所需的着色方程来计算颜色，然后将其作为顶点颜色传递给光栅化器。每顶点着色有时被称为Gouraud着色。</strong></p>
<p><strong>需要做的一个决定是在做着色计算的坐标系中。世界空间或眼睛空间都是不错的选择。在世界空间中选择一个标准正交的坐标系是很重要的，因为着色方程依赖于向量之间的角度不被建模转换中经常使用的非均匀缩放操作所保留，或者透视投影，通常用于规范化视图体积的投影。视图空间中的着色有一个优点，我们不需要跟踪摄像机的位置，因为在透视投影中，摄像机总是在视图空间的原点，或者在正射影中，视图的方向总是+z。</strong></p>
<p><strong>逐顶点着色的缺点是，它不能在着色中产生比绘制表面所用的原语更小的细节，因为它只对每个顶点计算一次着色，而从不在顶点之间计算。例如,在一个房间的地板是用两个大三角形和光源照亮房间的中间,着色将评估只在房间的角落,和插入值可能会太黑暗的中心。此外，曲面的着色与高光必须使用原语小到足以解决高光。</strong></p>
<p><strong>下图显示了我们用逐顶点着色绘制的两个球体。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923120147.png" class="" title="image-20210923120147">

<p>两个球体使用每顶点(Gouraud)着色绘制。因为三角形很大，所以可以看到插值伪影。</p>
<h3 id="Per-fragment-Shading-逐片着色"><a href="#Per-fragment-Shading-逐片着色" class="headerlink" title="Per-fragment Shading 逐片着色"></a>Per-fragment Shading 逐片着色</h3><p><strong>逐片段着色有时被称为Phong着色，因为相同的名称附加到Phong光照模型。</strong></p>
<p><strong>为了避免与逐顶点着色相关的插值伪影，我们可以通过在碎片阶段的插值后执行着色计算来避免插值颜色。在每个片段着色，相同的着色方程被评估，但他们被评估为每个片段使用插值向量，而不是每个顶点使用来自应用程序的向量。</strong></p>
<p><strong>在每个碎片着色中，着色所需的几何信息作为属性通过光栅化器传递，因此顶点阶段必须与碎片阶段协调，以适当地准备数据。一种方法是插值眼空间表面法线和眼空间顶点位置，然后就可以像在每个顶点着色中那样使用它们。</strong></p>
<p><strong>下图显示了我们用每个碎片着色绘制的两个球体。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210923120520.png" class="" title="image-20210923120520">

<p>使用逐片着色绘制两个球体。因为三角形很大，所以可以看到插值伪影。</p>
<h3 id="Texture-Mapping-纹理映射"><a href="#Texture-Mapping-纹理映射" class="headerlink" title="Texture Mapping 纹理映射"></a>Texture Mapping 纹理映射</h3><p><strong>纹理(在第11章中讨论)是用来为表面的着色添加额外细节的图像，否则会看起来过于均匀和人工。这个想法很简单:每次计算着色时，我们从纹理中读取一个用于着色计算的值，例如漫反射颜色，而不是使用附加到被渲染的几何图形的属性值。这个操作被称为纹理查找:着色代码指定一个纹理坐标、纹理域中的一个点和纹理映射系统在纹理图像中找到那个点的值并返回它。纹理值随后用于着色计算。</strong></p>
<p><strong>定义纹理坐标最常见的方法是简单地将纹理坐标作为另一个顶点属性。每一个原语知道它在纹理中的位置。</strong></p>
<h3 id="Shading-Frequency-着色频率"><a href="#Shading-Frequency-着色频率" class="headerlink" title="Shading Frequency 着色频率"></a>Shading Frequency 着色频率</h3><p><strong>关于在哪里放置着色计算定取决于颜色变化的速度——计算细节的比例。具有大规模特征的着色，如在曲面上的漫射着色，可以相当不频繁地评估，然后进行插值:它可以用较低的着色频率计算。产生小尺度特征的着色，如锐利的高光或详细的纹理，需要在高着色频率下进行评估。对于需要在图像中看起来清晰和清晰的细节，着色频率需要是每个像素至少一个着色样本。</strong></p>
<p><strong>因此，即使定义原语的顶点相距许多像素，也可以在顶点阶段安全地计算大规模效果。需要高着色频率的效果也可以在顶点阶段进行计算，只要顶点在图像中距离很近;或者，当基元大于像素时，可以在片段阶段计算它们。</strong></p>
<p><strong>例如，在电脑游戏中使用的硬件管线，通常使用覆盖多个像素的原语，以确保高效率，通常为每个片段进行大多数着色计算。另一方面，PhotoRealistic RenderMan系统对每个顶点进行所有的着色计算，在第一次细分或切割之后，所有的表面都被细分为小四边形，称为微多边形，大小和像素差不多。由于原语很小，在这个系统中每个顶点的着色达到了一个高的着色频率，这适合于详细的着色。</strong></p>
<h2 id="Simple-Antialiasing-简单抗锯齿"><a href="#Simple-Antialiasing-简单抗锯齿" class="headerlink" title="Simple Antialiasing 简单抗锯齿"></a>Simple Antialiasing 简单抗锯齿</h2><p><strong>就像光线追踪一样，如果我们完全或完全不确定每个像素是否在原语内部，光栅化将产生锯齿状的线条和三角形边缘。事实上,一组简单的三角形光栅化算法产生的碎片在本章所描述的,有时被称为标准或别名光栅化,是一模一样的像素集将被映射到三角形的射线示踪发送一个射线通过每个像素的中心。</strong></p>
<p><strong>同样在光线追踪中，解决方案是允许像素部分被原语覆盖(Crow, 1978)。在实践中，这种形式的模糊有助于视觉质量，特别是在动画中。如图的第一行所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210924100325.png" class="" title="image-20210924100325">

<p>一个抗锯齿和锯齿线查看近距离，所以个别像素是可见的。</p>
<p><strong>在光栅化应用中有许多不同的抗锯齿方法。就像射线追踪器一样，我们可以通过将每个像素值设置为该像素所在正方形区域上图像的平均颜色来生成抗锯齿图像，这种方法称为框过滤。这意味着我们必须将所有可绘制的实体视为具有明确定义的区域。例如，上图中的线可以被认为近似于一个像素宽的矩形。</strong></p>
<p><strong>实现盒滤波抗锯齿最简单的方法是超采样:创建非常高分辨率的图像，然后向下采样。例如,如果我们的目标是一个256×256像素图像的线宽度1.2像素,我们可以光栅化的矩形版本与宽度4.8在1024×1024像素的屏幕,然后平均4×4组像素的颜色为每个256×256像素的图像“萎缩”。这是实际框过滤图像的近似值，但当物体相对于像素之间的距离不是非常小时，效果很好。</strong></p>
<p><strong>然而，超级采样相当昂贵。由于导致走样的非常尖锐的边缘通常是由原语的边缘引起的，而不是原语内着色的突然变化，一个广泛使用的优化是以比着色更高的频率采样可见性。如果在每个像素中存储一些点的覆盖和深度信息，即使只计算一种颜色，也可以获得非常好的抗锯齿效果。在像RenderMan这样使用逐顶点着色的系统中，这是通过高分辨率的光栅化实现的:这样做并不昂贵，因为着色只是简单地插值来为许多片段或可见性样本生成颜色。在按片段着色的系统中，例如硬件管线，多样本抗锯齿是通过为每个片段存储一个单一的颜色加上覆盖掩码和一组深度值来实现的。</strong></p>
<h2 id="Culling-Primitives-for-Efficiency-剔除原语以提高效率"><a href="#Culling-Primitives-for-Efficiency-剔除原语以提高效率" class="headerlink" title="Culling Primitives for Efficiency 剔除原语以提高效率"></a>Culling Primitives for Efficiency 剔除原语以提高效率</h2><p><strong>对象顺序渲染的优势在于，它需要对场景中的所有几何图形进行一次遍历，这在复杂场景中也是一个弱点。例如，在一个完整的城市模型中，在任何给定的时间只有少数建筑可能是可见的。一个正确的图像可以通过绘制场景中的所有原语来获得，但大量的努力将被浪费在处理可见建筑后面或观众后面的几何图形上，因此不会对最终的图像做出贡献。</strong></p>
<p><strong>识别和丢弃不可见的几何图形，以节省处理它的时间，这被称为剔除。三种常用的剔除策略(通常串联使用)是</strong></p>
<p>​    <strong>视图体剔除：移除视图外的几何形状体积;</strong> </p>
<p>​    <strong>遮挡剔除：移除可能在视图体积内的几何体，但被其他靠近相机的几何体遮挡或遮挡;</strong></p>
<p>​    <strong>背向面剔除：移除背向相机的原语。</strong></p>
<p><strong>我们将简要讨论viewvolume culling和backface culling，但是在高性能系统中剔除是一个复杂的话题;参见(Akenine-M¨oller et al.， 2008)获得完整的讨论和关于遮挡剔除的信息。</strong></p>
<h3 id="View-Volume-Culling-视锥体剔除"><a href="#View-Volume-Culling-视锥体剔除" class="headerlink" title="View Volume Culling 视锥体剔除"></a>View Volume Culling 视锥体剔除</h3><p><strong>当整个原语位于视图体之外时，它可以被剔除，因为它在光栅化时不会产生碎片。如果我们可以通过快速测试剔除许多原语，我们可能会大大加快绘图速度。另一方面，单独测试原语来决定到底需要绘制哪些，可能比让光栅化器消除它们的成本更高。</strong></p>
<p><strong>视锥体剔除，也称为视锥剔除，在许多三角形被组合成一个具有相关边界体积的对象时特别有用。如果包围体位于视图体之外，那么组成对象的所有三角形也都在视图体之外。例如，如果我们有1000个三角形被一个圆心为c，半径为r的球体包围，我们可以检查球体是否位于剪切平面之外，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210924101810.png" class="" title="image-20210924101810">

<p><strong>其中a是平面上的一点，p是一个变量。这等价于检查从球的中心c到平面的带符号的距离是否大于+r。即</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210924101907.png" class="" title="image-20210924101907">

<p><strong>请注意，即使在所有三角形都位于平面外的情况下，球体也可能与平面重叠。因此，这是一个保守的测试。测试的保守程度取决于球体与物体的边界。</strong></p>
<p><strong>如果场景是按照第12章中描述的空间数据结构组织的，那么同样的想法也可以分层应用。</strong></p>
<h3 id="Backface-Culling-背面剔除"><a href="#Backface-Culling-背面剔除" class="headerlink" title="Backface Culling 背面剔除"></a>Backface Culling 背面剔除</h3><p><strong>当多边形模型封闭时，即它们限定了一个没有孔洞的封闭空间，然后通常假设它们有向外的法向量，如第10章所讨论的。对于这样的模型，面朝眼睛的多边形肯定会被面朝眼睛的多边形画过。因此，这些多边形甚至可以在管线开始之前被剔除。此条件的测试与第10.3.1节给出的轮廓图测试相同。</strong></p>
<h1 id="9-Signal-Processing-信号处理"><a href="#9-Signal-Processing-信号处理" class="headerlink" title="9 Signal Processing 信号处理"></a>9 Signal Processing 信号处理</h1><p><strong>在图形学中，我们经常处理连续变量的函数:图像是你看到的第一个例子，但随着你继续探索图形，你会遇到更多的例子。从本质上讲，连续函数不能直接在计算机中表示;我们必须用有限的比特来表示它们。表示连续函数最有用的方法之一是使用函数的样本:将函数的值存储在许多不同的点上，并在需要的时候重建它们之间的值。</strong></p>
<p><strong>现在，您已经熟悉了使用二维像素网格表示图像的概念——因此，您已经看到了采样表示。想象一幅由数码相机捕捉的图像:由相机镜头形成的实际场景图像是图像平面上位置的连续函数，相机将该函数转换为一个二维样本网格。从数学上讲，摄像机转换了R²→C(其中C是颜色的集合)到一个二维颜色样本数组，或类型为Z²→C。</strong></p>
<p><strong>另一个例子是2D数字化平板电脑，如平板电脑的屏幕或艺术家使用的单独的手写平板电脑。在这种情况下，原始的功能是手写笔的运动，这是一个时变的2D位置，或R→R²的功能．数字化仪在许多时间点测量手写笔的位置，产生一个二维坐标序列，或Z→R²．动作捕捉系统也会做同样的事情对于附加在参与者身体上的特殊标记:它将随着时间的推移获取标记的3D位置(R→R³)，并使其成为一系列的瞬时位置测量(Z→R³)．</strong></p>
<p><strong>在维度上，医用CT扫描仪，用于非侵入性检查一个人的身体内部，测量密度作为身体内部位置的函数。扫描仪的输出是一个密度值的三维网格:它转换身体的密度(R³→R)转换为实数的三维数组(Z³→R)。</strong></p>
<p><strong>这些例子看起来不同，但实际上它们都可以用完全相同的数学方法来处理。在所有情况下，函数都是在一个或多个维度的晶格点上被采样的，在所有情况下，我们都需要能够从样本数组中重建原始的连续函数。</strong></p>
<p><strong>从2D图像的例子来看，像素似乎足够了，一旦相机离散了图像，我们就再也不需要考虑连续函数了。但如果我们想让图像在屏幕上变大或变小，尤其是通过非整数比例因子?事实证明，最简单的算法执行效果很差，引入了明显的视觉伪影，即走样。解释为什么会发生走样以及理解如何防止走样需要采样理论的数学知识。生成的算法相当简单，但它们背后的推理和使它们表现良好的细节可能是微妙的。</strong></p>
<p><strong>当然，在计算机中表示连续函数并不是图形所独有的;采样和重建的想法也不是。从数字音频到计算物理的应用程序都使用采样表示，图形只是相关算法和数学的一个用户(绝不是第一个)。自20世纪20年代以来，通信领域就已经知道如何进行采样和重建的基本事实，并在20世纪40年代以我们使用的确切形式加以阐述(Shannon &amp; Weaver, 1964)。</strong></p>
<p><strong>本章首先以数字音频的一维具体例子来总结采样和重构。然后，我们继续介绍在一维和二维采样和重建基础上的基本数学和算法。最后，我们深入到频域观点的细节，这提供了许多深入了解这些算法的行为。</strong></p>
<h2 id="Digital-Audio-Sampling-in-1D-数字音频：一维采样"><a href="#Digital-Audio-Sampling-in-1D-数字音频：一维采样" class="headerlink" title="Digital Audio: Sampling in 1D 数字音频：一维采样"></a>Digital Audio: Sampling in 1D 数字音频：一维采样</h2><p><strong>虽然采样表示法已在电信中使用了多年，但随着在前十年中数字录音的使用增加，1982年激光唱片的引入，是采样技术在用户中第一次非常明显的应用。</strong></p>
<p><strong>在音频录制中，麦克风将空气中存在的压力波的声音转换成一个时变电压，该电压相当于测量麦克风所在位置处变化的气压。这种电信号需要以某种方式储存起来，以便在以后播放，然后发送到扬声器，通过与电压同步移动膜片，将电压转换回压力波。</strong></p>
<p><strong>数字方式记录音频信号(下图)使用采样:一种模拟-数字转换器(A/D转换器,或ADC)测量电压许多每秒几千次,生成的整数,可以很容易地存储在任意数量的媒体,说在电脑上一个磁盘在录音室,或者传播到另一个位置,说一个便携式音频播放器的内存。在回放时，数据以适当的速率读出并发送到数字-模拟转换器(D/A转换器，或DAC)。DAC根据它接收到的数字产生电压，并且，如果我们取足够的样本来公平地表示电压的变化，产生的电信号，对于所有实际用途来说，与输入相同。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925130536.png" class="" title="image-20210925130536">

<p>数字音频的采样和重建。</p>
<p><strong>结果表明，每秒所需的样本数量取决于我们试图录制的声音的音调有多高。如果我们试着录制短笛或钹，一个用于复制弦乐低音或踢鼓的采样率会产生奇怪的结果;但这些声音在较高的采样率下可以很好地再现。为了避免这些欠采样伪影，数字音频记录器对ADC的输入进行过滤，以去除可能导致问题的高频。</strong></p>
<p><strong>另一种问题出现在输出端。DAC产生一个电压，当一个新样品进入时，电压会发生变化，但在下一个样品之前保持不变，产生一个阶梯形图形。这些台阶就像噪音，增加了一种高频的、依赖信号的嗡嗡声。为了消除这种重构伪影，数字音频播放器对DAC的输出进行滤波，使波形平滑。</strong></p>
<h3 id="Sampling-Artifacts-and-Aliasing-采样伪影和走样"><a href="#Sampling-Artifacts-and-Aliasing-采样伪影和走样" class="headerlink" title="Sampling Artifacts and Aliasing 采样伪影和走样"></a>Sampling Artifacts and Aliasing 采样伪影和走样</h3><p><strong>数字音频记录链可以作为图形学中发生的采样和重构过程的具体模型。在图形中，图像或其他采样信号也会出现同样的欠采样和重构伪影，解决方法是:采样前滤波，重构时再滤波。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925130810.png" class="" title="image-20210925130810">

<p>以两种不同频率采样的正弦波(蓝色曲线)。上图:在高采样率下，结果样本(黑点)很好地代表了信号。下:较低的采样率产生一个模糊的结果:采样结果与采样频率更低的波(虚线曲线)的结果完全相同。</p>
<p><strong>上图显示了由过低的样本频率产生的工件类型的具体示例。在这里，我们使用两个不同的采样频率对一个简单的正弦波进行采样:顶部为每周期10.8个样本，底部为每周期1.2个样本。更高的利率产生一组样本,显然捕获信号,但产生的样本低采样率和样本的低频正弦波,面对这组样本低频正弦信号似乎更有可能的解释。</strong></p>
<p><strong>一旦采样完成，就不可能知道这两个信号——快的还是慢的正弦波——哪个是原始的，因此也没有一种方法可以在这两种情况下正确地重建信号。由于高频信号“假装”是低频信号，这种现象被称为走样。</strong></p>
<p><strong>当采样和重建的缺陷导致惊人频率的伪影时，就会出现走样。在音频中，走样以听起来奇怪的额外音调的形式出现——一个在10KHz的铃声，在被采样到8KHz后，变成了一个6赫兹的基调。在图像中，走样通常以摩尔纹的形式出现，这是由于样本网格与图像中的规则特征相互作用而产生的。</strong></p>
<p><strong>合成图像中另一个走样的例子是用黑白像素渲染的直线上的楼梯步。这是一个小尺度特征(线条的尖锐边缘)在不同尺度上创建工件的例子(对于浅斜线，楼梯台阶非常长)。</strong></p>
<p><strong>采样和重建的基本问题可以简单地根据特征太小或太大来理解，但一些更定量的问题更难回答:</strong></p>
<p>​    <strong>什么样的采样率高到足以确保良好的结果?</strong> </p>
<p>​    <strong>什么类型的过滤器适合采样和重建?</strong></p>
<p>​    <strong>为了避免走样，需要多大程度的平滑?</strong> </p>
<p><strong>这些问题的确切答案要等到我们在第9.5节中充分发展了这个理论之后</strong></p>
<h2 id="Convolution-卷积"><a href="#Convolution-卷积" class="headerlink" title="Convolution 卷积"></a>Convolution 卷积</h2><p><strong>在讨论采样和重构算法之前，我们先来看看它们所基于的数学概念——卷积。卷积是一个简单的数学概念，它是用于采样、滤波和重构的算法的基础。这也是我们在本章后面分析这些算法的基础。</strong></p>
<p><strong>卷积是对函数的一种操作:它取两个函数并将它们组合起来生成一个新的函数。在本书中，卷积算子用星号表示:将卷积作用于函数f和g的结果是f★g。我们说f和g是卷积的，f★g是f和g的卷积。</strong></p>
<p><strong>卷积可以被应用到连续函数(函数f (x)定义为任何实际参数x)或离散序列(功能只对整数参数定义a[i] )。它也可以应用到函数定义在一维,二维,或高维域(即函数,一个,两个,甚至更多的参数)。我们将从离散的一维情况开始，然后继续讨论连续函数以及二维和三维函数。</strong></p>
<p><strong>为了方便定义，我们通常假设函数的域是无限的，尽管在实践中它们必须在某个地方停止，而且我们必须以一种特殊的方式处理端点。</strong></p>
<h3 id="Moving-Averages-移动平均线"><a href="#Moving-Averages-移动平均线" class="headerlink" title="Moving Averages 移动平均线"></a>Moving Averages 移动平均线</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132339.png" class="" title="image-20210925132339">

<p>使用移动平均线进行平滑。</p>
<p><strong>为了获得卷积的基本图像，考虑使用移动平均值平滑1D函数的例子(上图)。为了得到任意点上的平滑值，我们计算函数在每个方向上延伸距离r范围内的平均值。距离r，称为平滑操作的半径，是一个控制平滑程度的参数。</strong></p>
<p><strong>对于离散或连续函数，我们可以在数学上表述这个概念。如果我们平滑一个连续函数g(x)，平均意味着在一个区间内对g积分然后除以区间的长度:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132426.png" class="" title="image-20210925132426">

<p><strong>另一方面，如果我们平滑一个离散函数a[i]，平均意味着对一系列a求和，然后除以值的数量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132434.png" class="" title="image-20210925132434">

<p><strong>在每种情况下，选择标准化常数，这样如果我们平滑一个常数函数，结果将是相同的函数。</strong></p>
<p><strong>移动平均线的概念是卷积的本质;唯一的区别是在卷积中移动平均是加权平均。</strong></p>
<h3 id="Discrete-Convolution-离散卷积"><a href="#Discrete-Convolution-离散卷积" class="headerlink" title="Discrete Convolution 离散卷积"></a>Discrete Convolution 离散卷积</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132710.png" class="" title="image-20210925132710">

<p>计算序列a与支持五个样本宽的滤波器b的离散卷积中的一个值。b中的每个样本是a中附近样本的平均值，由b的值加权。</p>
<p><strong>我们将从卷积最具体的情况开始:将一个离散序列a[i]与另一个离散序列b[i]进行卷积。结果是一个离散序列(a★b)[i]。这个过程就像用移动平均线平滑a，但是这个我们使用第二个序列b来给每个样本赋予权重(上图)，而不是对距离r内的所有样本进行相同的权重。值b[i−j]给出位置j的样本权重，位置j与指标i有i−j的距离，我们在这里计算卷积。(a b)的定义如下，用公式表示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925132722.png" class="" title="image-20210925132722">

<p><strong>通过省略j的界限，我们表明这个和对所有整数都有效(即从−∞到+∞)。上图说明了如何计算一个输出样本，使用</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925133023.png" class="" title="image-20210925133023">

<p><strong>在图形中，这两个函数中的一个通常具有有限支持(如上图中的示例所示)，这意味着它仅在参数值的有限区间内是非零的。如果我们假设b有有限支持，当|k| &gt; r时，存在一个半径r使b[k] = 0，在这种情况下，我们可以写出上面的和为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925133147.png" class="" title="image-20210925133147">

<p><strong>我们可以用代码来表示这个定义</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925133157.png" class="" title="image-20210925133157">

<h4 id="Convolution-Filters-卷积过滤器"><a href="#Convolution-Filters-卷积过滤器" class="headerlink" title="Convolution Filters 卷积过滤器"></a>Convolution Filters 卷积过滤器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925133931.png" class="" title="image-20210925133931">

<p>一个离散盒型过滤器。</p>
<p><strong>卷积很重要，因为我们可以用它来进行滤波。回顾我们的第一个滤波例子，移动平均，我们现在可以将平滑操作重新解释为与特定序列的卷积。当我们在有限的指标范围内计算平均值时，这就相当于对范围内的所有点进行相同的加权，并对其余的点进行零加权。这种过滤器，在非零的区间内有一个常量值，被称为框过滤器(因为如果你画它的图形，它看起来像一个矩形——见上图)。对于半径为r的箱形滤波器，其权重为1/(2r + 1):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925134527.png" class="" title="image-20210925134527">

<p><strong>如果你将这个过滤器代入方程，你会发现它降低到方程中的移动平均线。</strong></p>
<p><strong>在这个例子中，卷积滤波器通常被设计成和为1。这样，它们就不会影响信号的整体水平。</strong></p>
<p><strong>例子</strong></p>
<p><strong>举一个滤波的简单例子，让信号为阶跃函数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925134538.png" class="" title="image-20210925134538">

<p><strong>滤波器是以0为中心的五点盒滤波器，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925134608.png" class="" title="image-20210925134608">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925134746.png" class="" title="image-20210925134746">

<p>盒形函数与阶跃函数的离散卷积。</p>
<p><strong>a和b的卷积结果是什么?在一个特定的索引i上，如上图所示，结果是在i−2到i + 2范围内的阶跃函数的平均值。如果i &lt;−2，我们将所有零取平均，结果为零。如果i≥2，我们取所有1的平均值，结果是1。中间有i + 3个1，结果是这个值(i+3)/5 ．输出是一个从0到1的线性斜坡c超过五个样品:1/5[…， 0, 0, 1, 2, 3, 4, 5, 5，…].</strong></p>
<h4 id="Properties-of-Convolution-卷积的属性"><a href="#Properties-of-Convolution-卷积的属性" class="headerlink" title="Properties of Convolution 卷积的属性"></a>Properties of Convolution 卷积的属性</h4><p><strong>到目前为止我们写它的方式，卷积看起来像是一个非对称运算:a是我们要平滑的序列，b提供权值。但是卷积的一个很好的特性是它实际上没有任何区别:滤波器和信号是可以互换的。要理解这一点，只需重新考虑卷积式中的和，其中指标从滤波器b的原点开始计数，而不是从a的原点出发，即用i−k代替j</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925135859.png" class="" title="image-20210925135859">

<p><strong>这与卷积式完全相同，但a作为滤波器，b作为信号。对于任意序列a和b， (a★b) = (b★a)我们说卷积是一个交换运算。</strong></p>
<p><strong>更一般地说，卷积是一种“类似乘法”的操作。与数字或函数的乘法或加法一样，参数的顺序和括号的位置都不会影响结果。此外，卷积与加法的关系与乘法的关系是一样的。确切地说，卷积是交换的和结合的，它是加法的分配律。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925140020.png" class="" title="image-20210925140020">

<p><strong>这些性质是很自然的如果我们把卷积想成乘法，它们是很容易掌握的因为它们可以帮助我们在实际计算之前通过简化卷积来节省工作。例如，假设我们要取一个序列a用三个滤波器b进行卷积b1，b2, b3也就是说，我们想要((a★b1)★b2)★b3．如果序列很长，而滤波器很短(也就是说，它们的半径很小)，首先将三个滤波器卷积在一起会快得多计算(b1★b2★b3)，最后将结果与信号卷积，计算a★(b1★b2★b3)，我们从结合律得知，它会给出相同的结果。</strong><br><strong>一个非常简单的过滤器对于离散卷积:它是半径为零的离散滤波器，或者序列d[i] =…， 0,0,1,0,0，…（下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925140422.png" class="" title="image-20210925140422">

<p>离散滤波器。</p>
<p><strong>如果我们将d与信号a卷积，则和式中只有一项非零:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925140600.png" class="" title="image-20210925140600">

<p><strong>很明显，a与d的卷积会得到a。序列d称为离散脉冲。它有时在表示滤波器时很有用:例如，用滤波器b平滑信号a，然后从原始信号中减去滤波器b的过程可以表示为与滤波器d−b的单个卷积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925140750.png" class="" title="image-20210925140750">

<h3 id="Convolution-as-a-Sum-of-Shifted-Filters-移位和卷积滤波器"><a href="#Convolution-as-a-Sum-of-Shifted-Filters-移位和卷积滤波器" class="headerlink" title="Convolution as a Sum of Shifted Filters 移位和卷积滤波器"></a>Convolution as a Sum of Shifted Filters 移位和卷积滤波器</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141121.png" class="" title="image-20210925141121">

<p>移动序列b得到b→j。</p>
<p><strong>还有另一种完全相同的方法来解释卷积式。每次看一个a★b的样本就会得到我们已经看到的加权平均解释。但是如果我们省略[i]，我们可以把和看成是把整个序列加在一起。需要一个标记来实现这个工作:如果b是一个序列，那么向右移动j位的相同序列称为b→j(上图):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141159.png" class="" title="image-20210925141159">

<p><strong>然后，我们可以将卷积式写成关于整个序列(a★b)的陈述，而不是逐个元素:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141208.png" class="" title="image-20210925141208">

<p><strong>从这个角度看，卷积是b的移位副本的和，由a的项加权(下图)。因为交换性，我们可以选a或者b作为过滤器;如果我们选择b，那么我们将为输入中的每个样本添加一个过滤器副本。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141220.png" class="" title="image-20210925141220">

<p>离散卷积作为滤波器的移位副本的和。</p>
<h3 id="Convolution-with-Continuous-Functions-连续函数卷积"><a href="#Convolution-with-Continuous-Functions-连续函数卷积" class="headerlink" title="Convolution with Continuous Functions 连续函数卷积"></a>Convolution with Continuous Functions 连续函数卷积</h3><p><strong>虽然离散序列确实是我们在计算机程序中使用的，但这些采样序列应该表示连续函数，通常我们需要对连续函数进行数学推理，以便找出该怎么做。因此，定义连续函数之间以及连续函数和离散函数之间的卷积是有用的。</strong></p>
<p><strong>两个连续函数的卷积是卷积式的明显推广，用一个积分代替和:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141657.png" class="" title="image-20210925141657">

<p><strong>一种解释这个定义的方法是f和g的卷积，在参数x处取值，是两个函数乘积曲线下的面积在我们平移g使g(0)与f(t)对齐之后。就像在离散情况下一样，卷积是一个移动平均值，滤波器提供平均值的权重(见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141758.png" class="" title="image-20210925141758">

<p>连续卷积。</p>
<p><strong>像离散卷积一样，连续函数的卷积是交换的和结合的，它是对加法的分配。同样，对于离散情况，连续卷积可以看作是滤波器副本的和，而不是加权平均的计算。除了，在本例中，有无限多个过滤器g的副本:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141903.png" class="" title="image-20210925141903">

<p><strong>例子</strong></p>
<p><strong>设f为盒型函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141949.png" class="" title="image-20210925141949">

<p><strong>那么f★f是多少？定义如下</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925141959.png" class="" title="image-20210925141959">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142102.png" class="" title="image-20210925142102">

<p>将两个盒子函数旋转就产生了一个tent函数。</p>
<p><strong>上图显示了这个积分的两种情况。当x≤−1或x≥1时，两个盒型可能没有重叠;在这种情况下，结果是零。当−1 &lt; x &lt; 1时，重叠取决于两个盒子之间的距离，这是|x|;结果为1−|x|。所以</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142353.png" class="" title="image-20210925142353">

<p><strong>这个函数被称为tent函数，是另一个常见的过滤器(参见9.3.1节)。</strong></p>
<h4 id="The-Dirac-Delta-Function-狄拉克函数"><a href="#The-Dirac-Delta-Function-狄拉克函数" class="headerlink" title="The Dirac Delta Function 狄拉克函数"></a>The Dirac Delta Function 狄拉克函数</h4><p><strong>在离散卷积中，我们看到离散脉冲d作为一个单位函数:d★a = a。在连续的情况下，还有一个单位函数，叫做狄拉克脉冲或狄拉克函数，记作δ(x)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142714.png" class="" title="image-20210925142714">

<p>狄拉克函数 δ(x)。</p>
<p><strong>直观地说，delta函数是一个非常窄、非常高的尖峰，它的宽度很小，但面积仍然等于1(上图)。函数的关键定义性质是，将它乘以一个函数会选择出在0处的值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142831.png" class="" title="image-20210925142831">

<p><strong>函数在0处没有定义明确的值(你可以把它的值看作是+∞)，但是对于所有x≠0，它的值是δ(x) = 0。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925142843.png" class="" title="image-20210925142843">

<p>将函数与δ(x)进行卷积将返回相同函数的副本。</p>
<p><strong>从选择单个值的特性可以得出，脉冲函数是连续卷积的恒等式(上图)，因为将δ与任意函数f进行卷积会产生结果</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143044.png" class="" title="image-20210925143044">

<p><strong>所以</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143101.png" class="" title="image-20210925143101">

<h3 id="Discrete-Continuous-Convolution-离散连续卷积"><a href="#Discrete-Continuous-Convolution-离散连续卷积" class="headerlink" title="Discrete-Continuous Convolution 离散连续卷积"></a>Discrete-Continuous Convolution 离散连续卷积</h3><p><strong>有两种方法可以连接离散的和连续的世界。一种是三乘法:将连续函数转换为离散函数，方法是写下函数在所有整型参数处的值，而忽略其余的。给定一个连续函数f(x)，我们可以对其进行采样，将其转换为一个离散序列a[i]:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143517.png" class="" title="image-20210925143517">

<p><strong>反过来，从离散函数，或者说序列，到连续函数，叫做重构。这是用另一种形式的卷积来完成的，离散-连续形式。在这种情况下，我们用连续滤波器f(x)对一个离散序列a[i]进行滤波:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143526.png" class="" title="image-20210925143526">

<p><strong>重构函数a f在x处的值是i在x附近值的样本a[i]的加权和(下图)。权值来自滤波器f在以一个单位为间隔的一组点上计算。例如，如果x = 5.3, f的半径为2，则f的值为1.3、0.3、−0.7和−1.7。注意，对于离散-连续卷积，我们通常先写序列，然后写滤波器，这样和就大于整数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143631.png" class="" title="image-20210925143631">

<p>离散连续卷积。</p>
<p><strong>就像离散卷积一样，如果我们知道滤波器的半径r，我们就可以对求和设定界限，消除所有x和i之间的差值至少为r的点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143817.png" class="" title="image-20210925143817">

<p><strong>注意，如果一个点恰好落在距离x的r处(即如果x−r是一个整数)，它将被排除在求和之外。这与离散情况相反，在离散情况中，我们包含了i - r点。</strong></p>
<p><strong>在代码中表示为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143831.png" class="" title="image-20210925143831">

<p><strong>与其他形式的卷积一样，离散-连续卷积可以看作是对滤波器的移位副本进行求和(下图):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925143842.png" class="" title="image-20210925143842">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144018.png" class="" title="image-20210925144018">

<p>重构（离散连续卷积）作为位移滤波器的和。</p>
<p><strong>离散-连续卷积与样条密切相关。对于均匀样条(例如均匀B样条)，样条的参数化曲线恰好是样条的基函数与控制点序列的卷积(参见15.6.2节)。</strong></p>
<h3 id="Convolution-in-More-Than-One-Dimension-多维卷积"><a href="#Convolution-in-More-Than-One-Dimension-多维卷积" class="headerlink" title="Convolution in More Than One Dimension 多维卷积"></a>Convolution in More Than One Dimension 多维卷积</h3><p><strong>到目前为止,我们已经说过的所有关于采样和重建一直是一维:已经有一个变量x或一个单一的顺序索引。许多重要的应用程序图形采样和重建的,特别应用于二维函数,2d图像。幸运的是，将采样算法和理论从一维推广到二维、三维及以上，在概念上非常简单。</strong></p>
<p><strong>从离散卷积的定义开始，我们可以将其推广到二维，将其和变为双和:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144347.png" class="" title="image-20210925144347">

<p><strong>如果b是半径为r的有限支持滤波器(即有(2r + 1)²值)，然后我们可以把这个和写成有界的(下图):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144443.png" class="" title="image-20210925144443">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144454.png" class="" title="image-20210925144454">

<p>用于在点(i, j)与半径为1的滤波器b进行离散卷积的9个输入样本的权值。</p>
<p><strong>并在代码中表达:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144529.png" class="" title="image-20210925144529">

<p><strong>这个定义可以用与在1D情况下相同的方式来解释:每个输出样本是输入区域的加权平均值，使用2D过滤器作为“掩码”来确定每个样本在平均值中的权重。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144615.png" class="" title="image-20210925144615">

<p>输入信号中由(x, y)处的连续卷积产生的一个无限小的区域权重。</p>
<p><strong>继续推广，我们也可以在2D中写出连续-连续(上图)和离散-连续(下图)卷积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144735.png" class="" title="image-20210925144735">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210925144745.png" class="" title="image-20210925144745">

<p>对于半径为2的重构滤波器，参与在(x, y)点离散-连续卷积的16个输入样本的权值。</p>
<p><strong>在每种情况下，特定点的结果是该点附近输入的加权平均值。对于连续-连续的情况，它是一个以该点为中心的区域的加权积分，而在离散-连续的情况下，它是所有落在该点附近的样本的加权平均值。</strong></p>
<p><strong>一旦我们从1D发展到2D，就应该很清楚如何进一步推广到3D甚至更高维度。</strong></p>
<h2 id="Convolution-Filters-卷积滤波器"><a href="#Convolution-Filters-卷积滤波器" class="headerlink" title="Convolution Filters 卷积滤波器"></a>Convolution Filters 卷积滤波器</h2><p><strong>现在我们已经了解了卷积的原理，让我们来研究一些在图形中常用的特殊滤波器。</strong></p>
<p>**下面的每个过滤器都有一个自然半径，当采样间隔为一个单位时，这是用于采样或重建的默认大小。在本节中，过滤器被定义为这个自然大小:例如，盒子过滤器的自然半径为1/2，而立方过滤器的自然半径是2。我们还安排每个过滤器积分为1:  **</p>
<p><strong></strong></p>
<p><strong>在不改变信号平均值的情况下进行采样和重构所需要的。</strong></p>
<p><strong>正如我们将在9.4.3节中看到的，一些应用程序需要不同大小的过滤器，可以通过缩放基本过滤器获得。对于滤波器f(x)，我们可以定义一个缩放s的版本:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123550.png" class="" title="image-20210926123550">

<p><strong>过滤器水平拉伸s倍，然后垂直压缩s倍 1/s 所以它的面积不变。一个过滤器的自然半径为r，并且在缩放s中使用，它的支持半径为sr。</strong></p>
<h3 id="A-Gallery-of-Convolution-Filters-卷积滤波器库"><a href="#A-Gallery-of-Convolution-Filters-卷积滤波器库" class="headerlink" title="A Gallery of Convolution Filters 卷积滤波器库"></a>A Gallery of Convolution Filters 卷积滤波器库</h3><h4 id="盒型滤波器"><a href="#盒型滤波器" class="headerlink" title="盒型滤波器"></a>盒型滤波器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123749.png" class="" title="image-20210926123749">

<p>离散和连续盒型滤波器。</p>
<p><strong>盒状滤波器是一个积分为1的分段常数函数。作为一个离散滤波器，它可以写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123758.png" class="" title="image-20210926123758">

<p><strong>注意，为了对称，我们包含了两个端点。作为一个连续过滤器，我们写</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123808.png" class="" title="image-20210926123808">

<p><strong>在本例中，我们排除了一个端点，这使得半径为0.5的方框可用作重构过滤器。因为盒状过滤器是不连续的这些边界情况很重要，所以对于这个特殊的过滤器我们需要注意它们。就写成fbox 对于自然半径r = 1/2。</strong></p>
<h4 id="帐篷过滤器"><a href="#帐篷过滤器" class="headerlink" title="帐篷过滤器"></a>帐篷过滤器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123930.png" class="" title="image-20210926123930">

<p>帐篷过滤器和两个缩放版本。</p>
<p><strong>帐篷，或线性滤波器，是一个连续的、分段的线性函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926123939.png" class="" title="image-20210926123939">

<p><strong>它的自然半径是1。过滤器,这样,至少C⁰(也就是说,没有突然跳跃值,有盒),我们不再需要单独的离散和连续的定义过滤器:离散滤波器只是连续过滤采样的整数。</strong></p>
<h4 id="高斯滤波器"><a href="#高斯滤波器" class="headerlink" title="高斯滤波器"></a>高斯滤波器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124057.png" class="" title="image-20210926124057">

<p>高斯滤波器</p>
<p><strong>高斯函数，也称为正态分布，在理论上和实践中都是一个重要的滤波器。随着这一章的继续，我们会看到它的更多特殊属性:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124107.png" class="" title="image-20210926124107">

<p><strong>参数σ称为标准差。高斯滤波器是很好的采样滤波器，因为它非常光滑;我们将在本章后面更精确地说明这一点。</strong></p>
<p><strong>高斯滤波器没有任何特定的自然半径;它是σ范围内有用的采样滤波器。高斯也没有一个有限的支持半径，尽管因为指数衰减，它的值迅速变得小到可以忽略。当需要的时候，我们可以通过在半径r之外将函数的尾部设置为零来修剪函数的尾部，从而得到修剪过的高斯函数。这意味着滤波器的宽度和自然半径可以取决于应用程序,和削减高斯缩放的年代是一样的一个们修剪与标准差σ和高斯半径老在实践中处理这个问题的最好方法是让σ和r的属性设置过滤器,过滤时固定指定,然后规模筛选时就像任何其他应用（一般起点是σ = 1和r = 3。）。</strong></p>
<h4 id="B样条三次滤波器"><a href="#B样条三次滤波器" class="headerlink" title="B样条三次滤波器"></a>B样条三次滤波器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124320.png" class="" title="image-20210926124320">

<p>B样条滤波器</p>
<p><strong>许多滤波器被定义为分段多项式，四段(自然半径为2)的立方滤波器常被用作重构滤波器。这样一个过滤器被称为B样条滤波器，因为它的起源是样条曲线的混合函数(见第15章):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124329.png" class="" title="image-20210926124329">

<p><strong>在分段三次函数中，B样条是特殊的，因为它有连续的一阶导数和二阶导数，也就是C²。定义这个过滤器的更简洁的方法是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124339.png" class="" title="image-20210926124339">

<p><strong>证明上面的长形式是等价的是一个很好的卷积练习。</strong></p>
<h4 id="Catmull-Rom-立方滤波器"><a href="#Catmull-Rom-立方滤波器" class="headerlink" title="Catmull-Rom 立方滤波器"></a>Catmull-Rom 立方滤波器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124519.png" class="" title="image-20210926124519">

<p>Catmull-Rom 立方滤波器</p>
<p><strong>另一个以样条命名的分段三次滤波器Catmull-Rom滤波器，在x =−2，−1,1和2处的值为零，这意味着它将作为重构滤波器用于插值样本(章节9.3.2):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124528.png" class="" title="image-20210926124528">

<h4 id="Mitchell-Netravali立方滤波器"><a href="#Mitchell-Netravali立方滤波器" class="headerlink" title="Mitchell-Netravali立方滤波器"></a>Mitchell-Netravali立方滤波器</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124616.png" class="" title="image-20210926124616">

<p>Mitchell-Netravali立方滤波器</p>
<p><strong>对于重采样图像的所有重要应用，Mitchell和Netravali (Mitchell &amp; Netravali, 1988)研究了立方滤波器，并推荐在前两个滤波器之间的一个中间位置作为最佳的全面选择。它只是前面两个过滤器的加权组合:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926124633.png" class="" title="image-20210926124633">

<h3 id="滤波器的属性"><a href="#滤波器的属性" class="headerlink" title="滤波器的属性"></a>滤波器的属性</h3><p><strong>过滤器有一些传统的术语，我们用它们来描述过滤器，并相互比较。</strong></p>
<p><strong>滤波器的脉冲响应只是函数的另一个名称:它是滤波器对只包含脉冲的信号的响应(回想一下，与脉冲卷积就会返回滤波器)。</strong></p>
<p><strong>连续滤波器是插值，当它被用来从一个离散序列重建一个连续函数时，得到的函数恰好是采样点上的样本值，也就是说，它“连接点”，而不是仅仅产生一个函数靠近点。插值ters就是那些f(0) = 1和f(i) = 0的过滤器f，对于所有非零整数i(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125132.png" class="" title="image-20210926125132">

<p>一个插值滤波器重构采样点恰好是因为它在所有非零整数处的值都是零。</p>
<p><strong>负值的过滤器有铃声或超调:它会产生额外的振荡值左右急剧变化被过滤函数的值。</strong></p>
<p><strong>例如，Catmull-Rom滤波器两个方向上都有负，如果你过滤一个阶跃函数重建一个尖锐的不连续。有了它，它会夸大步骤a位，导致函数值下冲0和上冲1(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125623.png" class="" title="image-20210926125623">

<p>带有负瓣的滤波器在滤波或滤波时总是产生一些超调</p>
<p><strong>连续滤波器是无纹波的，当作为重构滤波器使用时，它将一个常数序列重构为常数函数(下图)。这相当于要求过滤器在任何整数间隔网格上的和为1:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125752.png" class="" title="image-20210926125752">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125714.png" class="" title="image-20210926125714">

<p>半径为1的帐篷滤波器为无波纹重建滤波器;而标准差为1/2的高斯滤波器则不然。</p>
<p><strong>第9.3.1节中的所有滤波器在其自然半径处都是无纹波的，除了高斯分布，但当它们在非整数范围内使用时，它们都不一定是无纹波的。如果需要消除离散-连续卷积中的纹波，很容易做到:将每个计算的样本除以计算它所用的权值之和:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926125821.png" class="" title="image-20210926125821">

<p><strong>这个表达式仍然可以解释为a和过滤器ˉf之间的卷积(参见练习6)。</strong></p>
<p><strong>连续滤波器具有一定的连续性，即处处可见的最高阶导数。一个过滤器，像盒过滤器，其值有突然的跳跃，根本不是连续的。一个连续但有尖角(一阶导数不连续)的滤波器，例如帐篷滤波器，连续阶为零，我们说它是C⁰。具有连续导数(无尖角)的滤波器，如前一节中的分段立方滤波器，为C¹;如果它的二阶导数也是连续的，就像b样条滤波器一样，它就是C²．由于重构函数继承了滤波器的连续性，因此重构滤波器的连续性顺序对重构滤波器尤为重要。</strong></p>
<h4 id="Separable-Filters-可分离的过滤器"><a href="#Separable-Filters-可分离的过滤器" class="headerlink" title="Separable Filters 可分离的过滤器"></a>Separable Filters 可分离的过滤器</h4><p><strong>到目前为止，我们只讨论了用于1D卷积的滤波器，但对于图像和其他多维信号，我们也需要滤波器。一般来说，任何2D函数都可以是一个2D过滤器，偶尔这样定义它们是有用的。但是，在大多数情况下，我们可以从我们已经看到的一维滤波器构建合适的二维(或高维)滤波器。</strong></p>
<p><strong>最有用的方法是使用可分离过滤器。可分离滤波器f2(x, y)在特定的x和y处是f1 (1D滤波器)在x和y处求值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130448.png" class="" title="image-20210926130448">

<p><strong>类似地，对于离散滤波器，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130456.png" class="" title="image-20210926130456">

<p><strong>通过f的任何水平或垂直切片f2是f1的缩放副本．f2 是f1积分的平方，特别是如果f1 是标准化的，那么f2也是．</strong></p>
<p><strong>例子(可分离的帐篷过滤器)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130711.png" class="" title="image-20210926130711">

<p>可分离的2D帐篷滤波器。</p>
<p><strong>如果我们为f1选择帐篷函数，得到的分段双线性函数(上图)为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130848.png" class="" title="image-20210926130848">

<p><strong>沿着坐标轴的轮廓是帐篷函数，但是沿着对角线的轮廓是二次曲线(例如，沿着直线x = y的正方向)象限，我们看到二次函数(1 - x)²)．</strong></p>
<p><strong>例子(2D高斯滤波器)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926130949.png" class="" title="image-20210926130949">

<p>二维高斯滤波器，既可分离又径向对称。</p>
<p><strong>如果我们选择高斯函数作为f1，得到的2D函数(上图)为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131008.png" class="" title="image-20210926131008">

<p><strong>注意，如果我们将一维高斯函数绕原点旋转，生成一个圆对称的函数，我们得到的函数是相同的(直到一个比例因子)函数。同时具有圆对称和可分离的性质是高斯函数所独有的。沿着坐标轴的轮廓是高斯曲线，沿着任意方向的轮廓也是高斯曲线中心。</strong></p>
<p><strong>与其他二维滤波器相比，可分离滤波器的关键优势在于实现效率。我们代入a2的定义 引入离散卷积的定义:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131120.png" class="" title="image-20210926131120">

<p><strong>请注意,b1[i-i′]不依赖于j′并且可以从内部和中求出:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131129.png" class="" title="image-20210926131129">

<p><strong>让我们将内部和缩写为S[i′]:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131314.png" class="" title="image-20210926131314">

<p><strong>用这种形式的方程，我们可以先计算和存储S[i′]对i′的每个值，然后使用这些存储值计算外部总和。乍一看，这似乎没什么了不起的，因为我们仍然要做与(2r + 1)²成比例的功来计算所有的内部和。然而，如果我们想要计算多个点[i, j]的值，情况就大不相同了。</strong></p>
<p><strong>假设我们需要计算a★2 在[2,2]和[3,2]，和b1 半径是2。检上式，我们可以看到我们将需要S[0]，…，S[4]来计算[2,2]处的结果，我们需要S[1]，…，S[5]来计算[3,2]处的结果。因此，在可分离公式中，我们可以计算所有的6个S值并共享S[1]，…S[4] (下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131716.png" class="" title="image-20210926131716">

<p>使用分离计算两个输出点对包含25个样本的2D数组(上图)进行处理，对列进行一次过滤，然后使用包含5个样本的单独1D数组(下图)。</p>
<p><strong>这种节省对于大型过滤器有很大的意义。一般情况下，用半径为r的滤波器过滤图像需要每像素计算(2r + 1)²个，而用相同大小的可分离滤波器过滤图像需要2(2r + 1)个产品(以牺牲一些中间存储为代价)。从O(r²)到O(r)的渐近复杂度的变化使得使用更大的滤波器成为可能。</strong></p>
<p><strong>该算法是:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926131930.png" class="" title="image-20210926131930">

<p><strong>为简单起见，该函数通过在输出图像的所有四边修剪r像素来避免所有边界问题。在实践中，有各种方法来处理边界;9.4.3看到部分。</strong></p>
<h2 id="Signal-Processing-for-Images-图像信号处理"><a href="#Signal-Processing-for-Images-图像信号处理" class="headerlink" title="Signal Processing for Images 图像信号处理"></a>Signal Processing for Images 图像信号处理</h2><p><strong>到目前为止，我们已经讨论了抽象的采样、滤波和重构，主要以一维信号为例。但正如我们在本章开始时所观察到的，信号处理在图形中的最重要和最常见的应用是采样图像。让我们仔细看看这些如何应用于图像。</strong></p>
<h3 id="Image-Filtering-Using-Discrete-Filters-使用离散滤波器进行图像滤波"><a href="#Image-Filtering-Using-Discrete-Filters-使用离散滤波器进行图像滤波" class="headerlink" title="Image Filtering Using Discrete Filters 使用离散滤波器进行图像滤波"></a>Image Filtering Using Discrete Filters 使用离散滤波器进行图像滤波</h3><p><strong>也许卷积最简单的应用是使用离散卷积处理图像。图像处理程序的一些最广泛使用的特性是简单的卷积滤波器。图像模糊可以通过与许多常见的低通滤波器进行卷积来实现，范围从方框到高斯(下图)。高斯滤波器创建一个非常光滑的模糊，通常用于这个目的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132154.png" class="" title="image-20210926132154">

<p>用三个不同的过滤器中的每一个卷积模糊图像。</p>
<p><strong>与模糊相反的是锐化，其中一种方法是使用“非锐化遮罩”程序:从模糊图像中减去一个α分数原创。为了避免改变整体亮度，我们进行了调整</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132307.png" class="" title="image-20210926132307">

<p><strong>fg,σ为宽度σ的高斯滤波器。使用离散脉冲d和卷积的分配律，我们可以将整个过程写成一个单独的过滤器，它取决于模糊的宽度和锐化的程度(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132316.png" class="" title="image-20210926132316">

<p>使用卷积过滤器锐化图像。</p>
<p><strong>结合两个离散过滤器的另一个例子是投影。这是常见的采取模糊，移动的副本的对象的轮廓，以创建一个软下降阴影(下图)。我们可以将移位操作表示为与偏心脉冲的卷积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132447.png" class="" title="image-20210926132447">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132437.png" class="" title="image-20210926132437">

<p>一个软下降阴影</p>
<p><strong>移动，然后模糊，是通过与两个过滤器卷积来实现的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132455.png" class="" title="image-20210926132455">

<p><strong>在这里，我们使用结合性将两个操作组合成一个带有三个参数的过滤器。</strong></p>
<h3 id="Antialiasing-in-Image-Sampling-图像采样中的抗锯齿"><a href="#Antialiasing-in-Image-Sampling-图像采样中的抗锯齿" class="headerlink" title="Antialiasing in Image Sampling 图像采样中的抗锯齿"></a>Antialiasing in Image Sampling 图像采样中的抗锯齿</h3><p><strong>在图像合成中，我们经常有这样的任务:生成图像的采样表示，我们有一个连续的数学公式(或者至少是一个程序，我们可以用来计算任意点的颜色，而不仅仅是在整数像素位置)。射线追踪是一个常见的例子;关于光线追踪和反走样的具体方法在第四章。在信号处理语言中，我们有一个连续的二维信号(图像)，我们需要在一个规则的二维晶格上采样。如果我们继续在没有任何特殊措施的情况下对图像进行采样，结果将显示出各种走样现象(下图)。在图像的尖锐边缘，我们看到阶梯状的物体，称为“锯齿”。“在有重复图案的区域，我们看到被称为摩尔图案的宽条纹。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132718.png" class="" title="image-20210926132718">

<p>图像中的两种伪影:周期性纹理中的莫尔图案(左)和直线上的“锯齿”(右)。</p>
<p><strong>这里的问题是图像包含了太多的小尺度特征;我们需要在采样前通过过滤使其平滑。回顾连续卷积的定义，我们需要在像素位置周围的区域上平均图像，而不仅仅是在单个点上取值。具体的方法将在第4章中讨论。一个简单的滤镜，像一个盒子，将改善锐利边缘的外观，但它仍然产生一些摩尔图案(下图)。高斯滤波器，这是非常平滑的，是更有效的摩尔模式，在整体上更模糊的代价。这两个例子说明了清晰度和走样之间的权衡，这是选择抗锯齿滤波器的基础。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926132907.png" class="" title="image-20210926132907">

<p>比较三种不同的采样滤波器用于消除锯齿的一个困难的测试图像，其中包含圆圈，间距越来越近，因为他们变得更大。</p>
<h3 id="Reconstruction-and-Resampling-重构和重采样"><a href="#Reconstruction-and-Resampling-重构和重采样" class="headerlink" title="Reconstruction and Resampling 重构和重采样"></a>Reconstruction and Resampling 重构和重采样</h3><p><strong>最常见的图像操作之一，其中仔细的过滤是至关重要的重采样——改变采样率，或改变图像大小。</strong></p>
<p><strong>假设我们用一个3000 × 2000像素的数码相机拍摄了一张图像，我们想在一个只有1280 × 1024像素的显示器上显示它。为了使它适合，同时保持3:2的宽高比，我们需要重新采样到1278 × 852像素。我们该怎么做呢?</strong></p>
<p><strong>解决这个问题的一种方法是将这个过程想象成减少像素:大小比率介于2和3之间，所以我们必须在保留的像素之间减少1或2个像素。可以用这种方法缩小图像，但结果的质量很低。然而，像素下降非常快，在交互操作期间预览调整大小的图像是一个合理的选择。</strong></p>
<p><strong>考虑调整图像大小的方法是作为一个重采样操作:我们想要一组图像的样本在一个特定的网格上，由新的图像的维数，我们通过对输入样本重建的连续函数进行采样得到它们(下图)。从这个角度看，它只是一系列标准图像处理操作:首先我们从输入样本重构一个连续函数，然后我们对这个函数进行采样就像对其他连续图像进行采样一样。为了避免走样，需要在每个阶段使用适当的过滤器。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926133423.png" class="" title="image-20210926133423">

<p>对图像的重新采样由两个逻辑步骤组成，并在代码中合并为单个操作。首先，我们使用重构滤波器从输入样本定义一个平滑的连续函数。然后，我们在一个新的网格上对该函数进行采样以获得输出样本。</p>
<p><strong>一个小例子如下图:如果原始图像12×9像素和新一是8×6像素,有2/3尽可能多的输出像素作为输入像素在每一个维度,所以他们的间距在图像是3/2的间距原始样本。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926133510.png" class="" title="image-20210926133510">

<p>在对一个12 × 9的图像进行重采样以生成一个8 × 6的图像时，输入和输出网格的样本位置。</p>
<p><strong>为了得到每个输出样本的值，我们需要以某种方式计算样本之间的图像值。像素丢弃算法为我们提供了一种方法:取输入图像中最接近的样本的值，并将其作为输出值。这完全相当于用1像素宽(半径为1 / 2)的盒状滤波器重建图像，然后进行点采样。</strong></p>
<p><strong>当然，如果选择像素下降或其他非常简单的过滤的主要原因是性能，那么就不会将该方法作为一种特殊的方法来实现一般重建和重采样程序的情况。事实上，由于不连续性，很难使盒形过滤器在一般框架下工作。但是，对于高质量的重采样，重构/采样框架提供了宝贵的灵活性。</strong></p>
<p><strong>要计算出算法的细节，最简单的方法是降至1D并讨论重新采样序列。编写实现的最简单方法是使用9.2.5节中定义的重构函数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926133631.png" class="" title="image-20210926133631">

<p><strong>参数x0 根据旧序列的样本给出新序列的第一个样本的位置。也就是说，如果第一个输出样本落在输入序列中样本3和样本4之间，x0是3.5。</strong></p>
<p><strong>该程序通过将输入序列与连续滤波器进行卷积，然后对其进行点采样来重建连续图像。这并不是说这两个操作是顺序发生的——连续函数仅在原理上存在，其值仅在采样点处计算。但在数学上，这个函数计算a★f的一组点样本。</strong></p>
<p><strong>这个点采样似乎是错误的，因为我们刚刚说过信号应该用适当的平滑滤波器进行采样以避免混叠。我们应该将重构函数与采样滤波器g和点采样g★(f★a)卷积，但由于这和(g★f)★a相同，我们可以把采样滤波器和重构滤波器放在一起;我们只需要一个卷积运算(下图)。这种重构和采样滤波器的组合称为重采样滤波器。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926133835.png" class="" title="image-20210926133835">

<p>重采样包括对重建和采样进行滤波。由于顺序应用的两个卷积滤波器可以用一个滤波器代替，所以我们只需要一个重采样滤波器，它起到重构和采样的作用。</p>
<p><strong>当对图像进行重新采样时，我们通常用旧图像的单位指定源矩形，该单位指定我们想要保留在新图像中的部分。例如，使用第3章中的像素样本定位约定，我们用于重新采样整个图像的矩形是(−0.5,nx ^old−0.5)×(−0.5,ny ^old−0.5)。给定源矩形(xl, xh)×(yl,yh)，新图像的样本间距</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926134049.png" class="" title="image-20210926134049">

<p><strong>低采样为(xl +Δx / 2, yl +Δy / 2)。</strong></p>
<p><strong>修改1D伪代码以使用此约定，并扩展调用为了使重构函数进入隐含的双循环，我们得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926134244.png" class="" title="image-20210926134244">

<p><strong>这个例程包含了重新采样图像的所有基础。最后一个问题有待解决的是在图像的边缘做什么，这里的简单版本将访问超出输入序列的边界。我们可能会做以下几件事:</strong></p>
<p>​    <strong>只要在序列的末尾停止循环即可。这相当于填充所有边都是零的图像。</strong></p>
<p>​    <strong>将所有数组访问剪辑到序列的末尾——也就是说，当我们想访问a[−1]时返回a[0]。这相当于通过扩展最后一行或一列来填充图像的边缘。</strong></p>
<p>​    <strong>当我们接近边缘时修改过滤器，使其不会超出序列的边界。</strong></p>
<p><strong>第一种方法导致当我们重新采样整个图像时，边缘变暗，这不是真正令人满意的。第二种选择很容易实现;第三种可能是表现最好的。修改靠近图像边缘的滤波器最简单的方法是对其进行重正化:将滤波器除以位于图像内的滤波器部分的总和。这样，滤波器的加起来总是等于1除以实际的图像样本，所以它保持了图像的强度。为了提高性能，最好将边缘(需要重正化)的滤波半径内的像素带与中心(包含更多像素，不需要重正化)分开处理。</strong></p>
<p><strong>重采样滤波器的选择是很重要的。有两个单独的问题:过滤器的形状和大小(半径)。由于滤波器既可作为重构滤波器又可作为采样滤波器，因此这两种角色的要求都会影响滤波器的选择。对于重建，我们希望滤镜足够平滑，以避免在放大图像时出现混叠现象，并且滤镜应该是无波纹的。采样时，过滤器应足够大，以避免欠采样，并足够光滑，以避免摩尔现象。下图说明了这两种不同的需求。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926134521.png" class="" title="image-20210926134521">

<p>使用不同大小的滤波器对图像进行上采样(放大)或下采样(缩小)的效果。</p>
<p><strong>一般情况下，我们会根据输入和输出的相对分辨率选择一个滤波器形状，并将其缩放。较低的两项决议确定过滤器的大小:当输出比输入粗采样(将采样,或缩小图像),适当的采样所需的平滑大于所需的平滑重建,所以我们根据输出样本大小过滤器间距(半径3在上图)。另一方面,当输出更精细采样(upsampling或放大图片)然后重建所需的平滑主导(重建函数已经足够光滑的样本比它开始以更高的速度),所以过滤器的大小是由输入样本间隔(半径1在上图)。</strong></p>
<p><strong>选择过滤器本身就是在速度和质量之间的权衡。常见的选择是盒式过滤器(速度是最重要的)，帐篷式过滤器(质量中等)，或分段立方过滤器(质量优秀)。在分段三次情况下，可以通过在f之间插值来调整平滑程度fB和fC ；Mitchell-Netravali滤波器是一个不错的选择。</strong></p>
<p><strong>与图像滤波一样，可分离过滤器可以提供显著的速度提升。其基本思想是首先对所有行进行重新采样，生成一个宽度不变但高度不变的图像，然后对该图像的列进行重新采样以生成最终结果(下图)。修改前面给出的伪代码以利用这种优化是相当简单的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210926134806.png" class="" title="image-20210926134806">

<p>使用可分离方法对图像进行重采样。</p>
<h2 id="Sampling-Theory-采样理论"><a href="#Sampling-Theory-采样理论" class="headerlink" title="Sampling Theory 采样理论"></a>Sampling Theory 采样理论</h2><p><strong>如果您只对实现感兴趣，可以在这里停止阅读;前面几节中的算法和建议将让您实现执行采样和重构并获得出色结果的程序。然而，采样有一个更深层次的数学理论，其历史可以追溯到采样表示在电信中的第一次使用。采样理论回答了许多严格基于尺度论证的推理难以回答的问题。</strong></p>
<p><strong>但最重要的是，采样理论为采样和重建工作提供了有价值的见解。它为学习它的学生提供了一套额外的智力工具，用于推理如何用最有效的代码实现最佳结果。</strong></p>
<h3 id="The-Fourier-Transform-傅里叶变换"><a href="#The-Fourier-Transform-傅里叶变换" class="headerlink" title="The Fourier Transform 傅里叶变换"></a>The Fourier Transform 傅里叶变换</h3><p><strong>傅里叶变换和卷积是构成采样理论的主要数学概念。你可以在很多关于分析的数学书中读到傅里叶变换，也可以在关于信号处理的书中读到。</strong></p>
<p><strong>傅里叶变换背后的基本思想是通过将所有频率的正弦波(正弦)相加来表示任何函数。通过为不同的频率使用适当的权重，我们可以安排正弦信号相加为我们想要的任何(合理的)函数。</strong></p>
<p><strong>例如，下图中的方波可以用一个序列表示 正弦波:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133340.png" class="" title="image-20210927133340">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133226.png" class="" title="image-20210927133226">

<p>用有限正弦和逼近方波。。</p>
<p><strong>这个傅里叶级数从频率为1.0的正弦波(sin 2πx)开始——与方波相同——剩下的项加上越来越小的修正以减少波纹，在极限情况下，精确地再现方波。注意，和中的所有项的频率都是方波频率的整数倍。这是因为其他频率产生的结果与方波的周期不同。</strong></p>
<p><strong>一个令人惊讶的事实是，一个信号并不一定是周期性的，以这种方式表示为正弦信号的和:一个非周期信号只是需要更多的正弦信号。我们不是对一个离散的正弦序列求和，而是对一个连续的正弦序列积分。例如，一个盒子函数可以写成余弦波族的积分:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133457.png" class="" title="image-20210927133457">

<p><strong>上式中的积分是无穷多个余弦相加，将频率u的余弦加权(sin πu)/πu。当我们包含越来越高的频率时，结果收敛到方框函数(见下图)。当函数f用这种方式表示时，这个权值，这个频率为u的函数，叫做f的傅里叶变换，记作fˆ。函数fˆ告诉我们如何通过对一组正弦函数积分来构造f:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133645.png" class="" title="image-20210927133645">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133540.png" class="" title="image-20210927133540">

<p>用余弦函数的积分逼近一个方框函数，每个余弦函数有四个截止点。</p>
<p><strong>上式被称为傅里叶反变换(IFT)，因为它从f的傅里叶变换开始，以f结束。</strong></p>
<p><strong>注意，在上式中，复指数e^2πiux 代替了之前方程中的cos。此外，fˆ是一个复值函数。为了控制正弦信号的相位和频率，需要使用复数机制;这对于表示任何在零上不对称的函数是必要的。fˆ的大小被称为傅里叶频谱，对于我们的目的来说，这已经足够了——我们不需要担心相位或者直接使用任何复数。</strong></p>
<p><strong>事实证明，从f计算fˆ和计算f非常相似从fˆ:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927133920.png" class="" title="image-20210927133920">

<p><strong>上式称为(正向)傅里叶变换(FT)。指数中的符号是傅里叶正变换和反变换之间的唯一区别，这实际上只是一个技术细节。出于我们的目的，我们可以把FT和IFT看作是相同的操作。</strong></p>
<p><strong>有时f - fˆ符号不方便，然后我们用F {f}表示f的傅里叶变换用F^−1{fˆ}表示fˆ的傅里叶反变换一个函数和它的傅里叶变换有许多有用的联系。我们将在本章后面用到(大部分很容易验证):</strong></p>
<h4 id="函数及其傅里叶变换具有相同的平方积分"><a href="#函数及其傅里叶变换具有相同的平方积分" class="headerlink" title="函数及其傅里叶变换具有相同的平方积分:"></a>函数及其傅里叶变换具有相同的平方积分:</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134153.png" class="" title="image-20210927134153">

<p><strong>物理上的解释是两者具有相同的能量(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134322.png" class="" title="image-20210927134322">

<p>傅里叶变换保持了信号的平方积分。</p>
<p><strong>特别地，将一个函数放大a，其傅里叶变换也放大a，即F{af} = aF {f}。</strong></p>
<h4 id="沿x轴拉伸函数时，其傅里叶变换也会沿u轴压缩相同的因子-下图"><a href="#沿x轴拉伸函数时，其傅里叶变换也会沿u轴压缩相同的因子-下图" class="headerlink" title="沿x轴拉伸函数时，其傅里叶变换也会沿u轴压缩相同的因子(下图):"></a>沿x轴拉伸函数时，其傅里叶变换也会沿u轴压缩相同的因子(下图):</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134521.png" class="" title="image-20210927134521">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134510.png" class="" title="image-20210927134510">

<p>在空间域中沿x轴缩放信号会导致在频域沿u轴的反缩放。</p>
<p><strong>(为了保持能量不变，需要b的重正化)</strong></p>
<p><strong>这意味着如果我们感兴趣的是一个家庭的功能不同的宽度和高度(说所有框功能集中在零),然后我们只需要知道一个正则函数的傅里叶变换(说盒子函数与宽度和高度等于1),我们可以很容易地知道的傅里叶变换的缩放和扩张版本的函数。例如，我们可以推广得到宽b高a的方框的傅里叶变换:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927134530.png" class="" title="image-20210927134530">

<h4 id="f的平均值等于fˆ-0-："><a href="#f的平均值等于fˆ-0-：" class="headerlink" title="f的平均值等于fˆ(0)："></a>f的平均值等于fˆ(0)：</h4><p><strong>这是有意义的，因为f(0)ˆ应该是信号的零频率分量(如果我们考虑的是电压，则是直流分量)。</strong></p>
<h4 id="如果f是实数-对我们来说总是实数-，则fˆ是偶函数，即f-u-ˆ-f-−u-："><a href="#如果f是实数-对我们来说总是实数-，则fˆ是偶函数，即f-u-ˆ-f-−u-：" class="headerlink" title="如果f是实数(对我们来说总是实数)，则fˆ是偶函数，即f(u)ˆ=f(−u)："></a>如果f是实数(对我们来说总是实数)，则fˆ是偶函数，即f(u)ˆ=f(−u)：</h4><p><strong>同样地，如果f是偶函数，则fˆ为实数(这不是通常在我们的定义域中是这样的，但是记住我们只关心fˆ的大小。</strong></p>
<h3 id="Convolution-and-the-Fourier-Transform-卷积与傅里叶变换"><a href="#Convolution-and-the-Fourier-Transform-卷积与傅里叶变换" class="headerlink" title="Convolution and the Fourier Transform 卷积与傅里叶变换"></a>Convolution and the Fourier Transform 卷积与傅里叶变换</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135041.png" class="" title="image-20210927135041">

<p>一个交换图直观地显示了卷积和乘法之间的关系。如果我们在空间中乘以f和g，然后转换到频率，我们最终会得到和我们把f和g转换到频率然后卷积它们一样的地方。同样地，如果我们在空间中卷积f和g然后转换成频率，我们最终会得到和我们把f和g转换成频率，然后相乘一样的地方。</p>
<p><strong>傅里叶变换最后一个值得特别提及的性质是它与卷积的关系(上图)。简单地说,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135133.png" class="" title="image-20210927135133">

<p><strong>两个函数的卷积的傅里叶变换是傅里叶变换的乘积。根据我们现在熟悉的对称性，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135143.png" class="" title="image-20210927135143">

<p><strong>两个傅里叶变换的卷积就是两个函数乘积的傅里叶变换。从定义中推导出这些事实是相当简单的。</strong></p>
<p><strong>这种关系是傅里叶变换在研究采样和重构效果时有用的主要原因。我们已经看到了采样、滤波和重构是如何用卷积来表示的;现在傅里叶变换给了我们一个新的域——频域——这些运算只是乘积。</strong></p>
<h3 id="A-Gallery-of-Fourier-Transforms-傅里叶变换库"><a href="#A-Gallery-of-Fourier-Transforms-傅里叶变换库" class="headerlink" title="A Gallery of Fourier Transforms 傅里叶变换库"></a>A Gallery of Fourier Transforms 傅里叶变换库</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135350.png" class="" title="image-20210927135350">

<p>盒型、帐篷、B样条和高斯滤波器的傅里叶变换。</p>
<p><strong>现在我们有了傅里叶变换的一些事实，让我们看一些单独函数的例子。特别地，我们将看看9.3.1节中的一些过滤器，它们的傅里叶变换如上图所示。我们已经看到了盒型函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135453.png" class="" title="image-20210927135453">

<p><strong>函数sinx /x很重要，有它自己的名字，sincx。</strong></p>
<p><strong>帐篷函数是盒子与自身的卷积，所以它的傅里叶变换就是盒子函数傅里叶变换的平方</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135516.png" class="" title="image-20210927135516">

<p><strong>我们可以继续这个过程，得到B样条滤波器的傅里叶变换(见练习3):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135527.png" class="" title="image-20210927135527">

<p><strong>高斯函数有一个特别好的傅里叶变换</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135535.png" class="" title="image-20210927135535">

<p><strong>这是另一个高斯。标准差为1.0的高斯变成了标准差为1/2π的高斯。</strong></p>
<h3 id="Dirac-Impulses-in-Sampling-Theory-采样理论中的Dirac脉冲"><a href="#Dirac-Impulses-in-Sampling-Theory-采样理论中的Dirac脉冲" class="headerlink" title="Dirac Impulses in Sampling Theory 采样理论中的Dirac脉冲"></a>Dirac Impulses in Sampling Theory 采样理论中的Dirac脉冲</h3><p><strong>脉冲在抽样理论中有用的原因是我们可以用它们来讨论连续函数和傅里叶变换中的样本。我们表示一个样本，它有一个位置和一个值，用一个平移到那个位置并按那个值缩放的脉冲表示。一个位于a位置的值为b的样本用bδ(x−a)表示。这样我们可以将函数f(x)在a处的采样操作表示为f乘以δ(x−a)，结果是f(A)δ(x−a)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135843.png" class="" title="image-20210927135843">

<p>脉冲列车。一个脉冲序列的傅里叶变换是另一个脉冲序列。在空间上改变脉冲序列的周期会引起频率周期的反向变化。</p>
<p><strong>因此，在一系列等间距点上对函数进行采样可以表示为将函数乘以一系列等间距脉冲的和，称为脉冲序列(上图)。一个周期为T的脉冲序列，也就是说脉冲间隔为T</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927135851.png" class="" title="image-20210927135851">

<p><strong>s1的傅里叶变换和s1一样:所有整数频率的脉冲序列。你们可以看到为什么这是正确的通过思考当我们把脉冲序列乘以正弦信号并积分时会发生什么。我们最后把所有整数处的正弦值加起来。对于非整数频率，这个和正好抵消为零，对于整数频率，它发散为+∞。</strong></p>
<p><strong>由于傅里叶变换的膨胀性质，我们可以猜测一个周期为T的脉冲序列的傅里叶变换(就像s1的膨胀)为周期为1/T的脉冲序列。在空间域中采样越精细，脉冲在频域中的距离就越远。</strong></p>
<h3 id="Sampling-and-Aliasing-采样和走样"><a href="#Sampling-and-Aliasing-采样和走样" class="headerlink" title="Sampling and Aliasing 采样和走样"></a>Sampling and Aliasing 采样和走样</h3><p><strong>现在我们已经建立了数学机制，我们需要从频域的观点来理解采样和重构过程。引入傅里叶变换的关键优点是，它使卷积滤波对信号的影响更加清晰，并且更精确地解释了采样和重构时为什么需要滤波。</strong></p>
<p><strong>我们从原始的连续信号开始这个过程。一般来说，它的傅里叶变换可以包含任何频率的分量，尽管对于大多数类型的信号(尤其是图像)，我们预计其内容会随着频率的增加而减少。图像也倾向于在零频率有一个很大的分量——记住零频率分量，或DC，是整个图像的积分，因为图像都是正的值，这往往是一个很大的数字。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140327.png" class="" title="image-20210927140327">

<p>采样率对采样信号频谱的影响。较高的采样率会将光谱的副本分开，从而减少走样造成的问题。</p>
<p><strong>让我们看看如果不做任何特殊的滤波采样和重构，傅里叶变换会发生什么(上图)。当我们对信号进行采样时，我们将运算模型化为与脉冲序列的乘法运算;采样信号为fsT．由于乘法卷积的性质，采样后的FT</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140436.png" class="" title="image-20210927140436">

<p> <strong>回想一下，δ是卷积的恒等式。这意味着</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140446.png" class="" title="image-20210927140446">

<p><strong>脉冲序列的卷积,使得一系列的等距的副本的光谱f。一个好的直观的解释这个看似奇怪的结果是,所有这些副本只是表达一个事实(正如我们在9.1.1看到)频率不同的整数倍数采样频率是无法区分一旦采样它们将产生完全相同的设置的样本。原始谱称为基谱，复制谱称为杂谱。</strong></p>
<p><strong>如果这些信号频谱的副本重叠，问题就开始了，如果信号包含任何超过样本频率一半的重要内容，就会发生重叠。当这种情况发生时，频谱相加，不同频率的信息不可逆地混合在一起。这是可能发生走样的第一个地方，如果它发生在这里，那是因为欠采样——对信号使用过低的采样频率。</strong></p>
<p><strong>假设我们用最近邻技术重建信号。这相当于与宽度为1的方框进行卷积。(用于实现这一目的的离散-连续卷积与与表示样本的脉冲序列的连续卷积相同。)卷积乘法性质是指重构信号的频谱将是采样信号的频谱与盒子的频谱的乘积。得到的重建傅里叶变换包含了基谱(尽管在较高的频率上有些衰减)，加上所有走样谱的衰减副本。因为方框有一个相当宽的傅里叶变换，这些衰减的伪谱是重要的，它们是第二种走样形式，由于不充分的重建滤波器。这些别名组件在图像中表现为具有最近邻重建特征的正方形图案。</strong></p>
<h4 id="Preventing-Aliasing-in-Sampling-防止采样中的走样"><a href="#Preventing-Aliasing-in-Sampling-防止采样中的走样" class="headerlink" title="Preventing Aliasing in Sampling 防止采样中的走样"></a>Preventing Aliasing in Sampling 防止采样中的走样</h4><p><strong>为了实现高质量的采样和重构，我们需要选择合适的采样和重构滤波器。从频域的角度来看，采样时低通滤波的目的是限制信号的频率范围，使走样谱不与基谱重叠。下图显示了采样率对采样信号傅里叶变换的影响。较高的采样率使伪谱分离得更远，最终留下的重叠部分都无关紧要。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140830.png" class="" title="image-20210927140830">

<p>采样率对采样信号频谱的影响。较高的采样率会将光谱的副本分开，从而减少重叠造成的问题。</p>
<p><strong>关键的标准是频谱的宽度必须小于拷贝之间的距离，也就是说，信号中的最高频率必须小于样本频率的一半。这被称为奈奎斯特准则，最高允许频率被称为奈奎斯特频率或奈奎斯特极限。奈奎斯特-香农采样定理表明，一个频率不超过奈奎斯特极限的信号(或者，换句话说，一个带宽限制在奈奎斯特频率的信号)，原则上可以从样本中精确地重建。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140917.png" class="" title="image-20210927140917">

<p>应用低通(平滑)滤波器缩小信号的频谱。</p>
<p><strong>对于一个特定的信号有足够高的采样率，我们不需要使用采样滤波器。但是，如果我们遇到的是一个频率范围很广的信号(比如一幅边缘清晰的图像)，我们必须在采样之前使用一个采样滤波器来限制信号的频带。上图显示了三种低通(平滑)滤波器在频域的效果，下图显示了采样时使用这些相同滤波器的效果。即使频谱在没有滤波的情况下重叠，用低通滤波器对信号进行卷积也可以将频谱缩小到足以消除重叠，并产生滤波后信号的良好采样表示。当然，我们失去了高频信号，但总比让它们被信号干扰变成藏物强。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927140930.png" class="" title="image-20210927140930">

<p>上图中的低通滤波器如何在采样期间防止走样。低通滤波使频谱变窄，使复制的重叠更少，杂化频谱的高频对基谱的干扰更小。</p>
<h4 id="Preventing-Aliasing-in-Reconstruction-防止重建中的混叠"><a href="#Preventing-Aliasing-in-Reconstruction-防止重建中的混叠" class="headerlink" title="Preventing Aliasing in Reconstruction 防止重建中的混叠"></a>Preventing Aliasing in Reconstruction 防止重建中的混叠</h4><p><strong>从频域的角度来看，重构滤波器的工作是在保留基谱的同时去除杂谱。在之前的图中，我们可以看到，最粗糙的重构滤波器，即方框，确实会衰减走样光谱。最重要的是，它完全阻断了所有杂化光谱的直流脉冲。这是所有合理重构滤波器的一个特点:它们在采样频率的所有倍数的频率空间中都有零。这等价于空间域中的无波纹性质。</strong></p>
<p><strong>因此，一个好的重构滤波器需要是一个好的低通滤波器，同时还需要完全阻断采样频率的所有倍数。</strong></p>
<p><strong>采用与盒形滤波器不同的重构滤波器的目的是为了更彻底地消除杂频，减少高频伪影泄漏到重构信号中，同时尽可能地减少对基谱的干扰。下图显示了在重建过程中使用不同滤波器的效果。正如我们所看到的，盒子过滤器是相当“漏”的，即使取样率足够高，也会导致大量的人为因素。帐篷滤波器由于线性插值，对高频的衰减更大，产生更温和的伪影，而B样条滤波器非常平滑，有效地控制了杂散谱。它也平滑了一些基谱，这是平滑和混叠之间的权衡，我们之前看到过。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927141358.png" class="" title="image-20210927141358">

<p>不同重构滤波器在频域的影响。好的重建滤波器能有效地衰减杂频，同时保留基谱。</p>
<h4 id="Preventing-Aliasing-in-Resampling-防止重采样中的走样"><a href="#Preventing-Aliasing-in-Resampling-防止重采样中的走样" class="headerlink" title="Preventing Aliasing in Resampling 防止重采样中的走样"></a>Preventing Aliasing in Resampling 防止重采样中的走样</h4><p><strong>当重构和采样操作在重采样中结合时，同样的原理也适用，只是一个过滤器同时做重构和采样工作。下图说明了重采样滤波器必须去除走样光谱，使频谱足够窄，以新的采样率进行采样。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927141628.png" class="" title="image-20210927141628">

<p>在频域观察重采样。重采样滤波器既重建信号(去除杂频)，又限制它的带宽(减少它的宽度)以新的速率采样。</p>
<h3 id="Ideal-Filters-vs-Useful-Filters-理想过滤器VS有用过滤器"><a href="#Ideal-Filters-vs-Useful-Filters-理想过滤器VS有用过滤器" class="headerlink" title="Ideal Filters vs. Useful Filters 理想过滤器VS有用过滤器"></a>Ideal Filters vs. Useful Filters 理想过滤器VS有用过滤器</h3><p><strong>根据频域分析得出的逻辑结论，在频域中恰好是一个盒子的滤波器对于采样和重构都是理想的。这样的滤波器可以在两个阶段防止走样，而不会减少低于奈奎斯特频率的频率。</strong></p>
<p><strong>回想一下傅里叶反变换和正变换本质上是相同的，所以傅里叶变换为方框的空间域滤波器是函数sin πx/πx = sinc πx。</strong></p>
<p><strong>然而，由于sinc滤波器不切实际，而且尽管它根据频域准则是最优的，但在许多应用中它并不能产生最佳结果，因此在实际应用中，无论是采样还是重构，一般都不使用sinc滤波器。</strong></p>
<p><strong>对于采样，sinc滤波器的无限延伸，以及它相对较慢的下降速度随距离中心的距离，是一个不利因素。此外，对于某些类型的采样，负叶是有问题的。高斯滤波器是一个很好的采样滤波器，即使在输入信号中高频模式必须去除的困难情况下，因为它的傅里叶变换下降指数基本上，不要让化名泄露出去。对于不太困难的情况，一个帐篷过滤器通常就足够了。</strong></p>
<p><strong>对于重构，sinc函数的大小再次产生问题，但更重要的是，许多波纹在重构信号中产生“振铃”伪影。</strong></p>
<h1 id="10-Surface-Shading-表面着色"><a href="#10-Surface-Shading-表面着色" class="headerlink" title="10 Surface Shading 表面着色"></a>10 Surface Shading 表面着色</h1><h2 id="Diffuse-Shading-漫反射着色"><a href="#Diffuse-Shading-漫反射着色" class="headerlink" title="Diffuse Shading 漫反射着色"></a>Diffuse Shading 漫反射着色</h2><p><strong>世界上许多物体的表面外观被宽泛地描述为“哑光”，这表明该物体根本没有光泽。例如，纸张、未加工的木材和干燥、未抛光的石头。在很大程度上，这样的物体不会随着视点的变化而发生颜色变化。例如，如果你盯着一张纸上的一个特定点并移动，同时保持你的目光盯着这个点，这个点上的颜色将保持相对恒定。这样的哑光对象可以被认为具有朗伯对象的行为。本节讨论如何实现这些对象的着色。关键是，本章所有公式都应在世界坐标中求值，而不是在透视变换后的扭曲坐标中求值。否则，法线之间的角度会改变，着色将是不准确的。</strong></p>
<h3 id="Lambertian-Shading-Model-朗伯着色模型"><a href="#Lambertian-Shading-Model-朗伯着色模型" class="headerlink" title="Lambertian Shading Model 朗伯着色模型"></a>Lambertian Shading Model 朗伯着色模型</h3><p><strong>朗伯物体遵循朗伯余弦定律，即表面的颜色c与表面法线与光源方向夹角的余弦成正比(Gouraud, 1971):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142632.png" class="" title="image-20210927142632">

<p><strong>或者向量形式，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142643.png" class="" title="image-20210927142643">

<p><strong>其中n和l如下图所示。因此，表面上的颜色将根据表面法线和光线方向之间的夹角的余弦变化。注意，通常假设向量l不依赖于对象的位置。这个假设相当于假设光相对于物体的大小是“遥远的”。这种“远距离”的光通常被称为定向光，因为它的位置仅由一个方向来确定。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142730.png" class="" title="image-20210927142730">

<p>朗伯定律的几何。n和l都是单位向量。</p>
<p><strong>通过改变光源的强度或表面的反射率，表面可以变得更亮或更暗。漫反射系数c<em>r</em> 为被表面反射的光的比例。这个分数对于不同的颜色成分是不同的。例如，如果一个表面反射的红色入射光比蓝色入射光的比例更高，那么它就是红色的。如果我们假设表面颜色与从表面反射的光成正比，那么漫反射系数cr——RGB颜色也必须包括在内:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142844.png" class="" title="image-20210927142844">

<p><strong>上式右手边为RGB颜色，所有RGB分量都在[0,1]范围内。我们想要添加光强度的效果，同时保持RGB分量在[0,1]范围内。这建议添加RGB强度项cl它本身在范围[0,1]中有分量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927142852.png" class="" title="image-20210927142852">

<p><strong>这是一种非常方便的形式，但它可以产生c的RGB分量在范围[0,1]之外，因为点积可以是负的。如下图所示，当表面指向光源时，点积为负。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143030.png" class="" title="image-20210927143030">

<p>当一个表面指向远离光，它应该收不到光。这种情况可以通过检验l与n的点积是否为负来验证。</p>
<p><strong>可以在上式中加入“max”函数来检验这种情况:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143134.png" class="" title="image-20210927143134">

<p><strong>另一种处理“负面”光线的方法是使用绝对值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143142.png" class="" title="image-20210927143142">

<p><strong>虽然上式在物理上似乎不可信，但它实际上对应于上上式，即两个方向相反的光。由于这个原因，它通常被称为双面照明(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143232.png" class="" title="image-20210927143232">

<p>双面照明公式，相当于假设两个相反的光源相同的颜色。</p>
<h3 id="Ambient-Shading-环境着色"><a href="#Ambient-Shading-环境着色" class="headerlink" title="Ambient Shading 环境着色"></a>Ambient Shading 环境着色</h3><p><strong>漫反射着色的一个问题是，任何法线面远离光线的点都是黑色的。在现实生活中，光是被反射的，有些光是从各个方向入射的。此外，经常有天窗提供“环境”照明。解决这个问题的一种方法是使用多个光源。一个常见的技巧是总是在眼睛处放一个昏暗的光源，这样所有可见的点都会收到一些光。另一种方法是使用的双面照明。一种更常见的方法是添加环境光(Gouraud, 1971)。这只是添加到公式中的一个常量颜色项:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143558.png" class="" title="image-20210927143558">

<p><strong>直观地说，你可以想到环境色ca 作为场景中所有表面的平均颜色。如果您想确保计算的RGB颜色保持在[0,1]³范围内,那么ca + cl ≤(1,1,1)。否则，你的代码应该“夹紧”RGB值高于1的值为1。</strong></p>
<h3 id="Vertex-Based-Diffuse-Shading-基于顶点的漫反射着色"><a href="#Vertex-Based-Diffuse-Shading-基于顶点的漫反射着色" class="headerlink" title="Vertex-Based Diffuse Shading 基于顶点的漫反射着色"></a>Vertex-Based Diffuse Shading 基于顶点的漫反射着色</h3><p><strong>如果我们将漫反射着色方程应用于由三角形组成的物体，它通常会有一个面外观。三角形通常是光滑表面的近似值。为了避免面形的外观，我们可以将曲面法向量放置在三角形的顶点上(Phong, 1975)，并使用顶点上的法向量在每个顶点上应用公式(见下图)。这将给每个三角形顶点一个颜色，并且这个颜色可以使用8.1.2节中描述的重心插值。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927143827.png" class="" title="image-20210927143827">

<p>一个圆(左)近似于一个八边形(右)。顶点法线记录原始曲线的表面法线。</p>
<p><strong>在三角形顶点上着色的一个问题是我们需要从某处得到法线。许多模型将与正常供应。如果你绘制自己的平滑模型，你可以在创建三角形时创建法线。如果你有一个多边形模型，顶点上没有法线，你想要平滑地着色它，你可以通过各种启发式方法计算法线。最简单的方法是对共享每个顶点的三角形的法线取平均值，并在顶点处使用这个平均值。这个平均法线不会自动是单位长度，所以你应该在使用它做阴影之前将它转换成单位向量。</strong></p>
<h2 id="Phong-Shading-Phong-着色"><a href="#Phong-Shading-Phong-着色" class="headerlink" title="Phong Shading Phong 着色"></a>Phong Shading Phong 着色</h2><p><strong>有些表面本质上就像哑光表面，但它们有亮点。这种表面的例子包括抛光的瓷砖地板、有光泽的油漆和白板。高光随着视点的移动在表面上移动。这意味着我们必须在方程中加入一个朝向眼睛的单位向量e。如果你仔细观察高光部分，你会发现它们其实是光的反射;有时这些反射是模糊的。这些高光的颜色是光的颜色，表面的颜色似乎没有什么影响。这是因为反射发生在物体表面，而穿透物体表面并捕捉到物体颜色的光是漫反射的。</strong></p>
<h3 id="Phong-Lighting-Model-Phong照明模型"><a href="#Phong-Lighting-Model-Phong照明模型" class="headerlink" title="Phong Lighting Model Phong照明模型"></a>Phong Lighting Model Phong照明模型</h3><p><strong>我们想在正确的地方添加一个与光源相同颜色的模糊“光点”。点的中心应该画在e到眼睛的方向与反射的自然方向r的“线”上，如下图所示。这里“对齐”在数学上等同于“σ为零”。“我们希望高光有一些非零区域，这样眼睛就能在σ很小的地方看到一些高光。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202344.png" class="" title="image-20210927202344">

<p>Phong照明模型的几何图形。如果σ很小，眼睛应该看到一个亮点。</p>
<p><strong>给定r，我们想要一个启发式函数，当e = r时是亮的，当e远离r时逐渐下降夹角:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202508.png" class="" title="image-20210927202508">

<p><strong>使用这个方程有两个问题。第一个是点积可以是负的。这可以通过一个“if”语句来计算解决，该语句在点积为负时将颜色设置为零。更严重的问题是，这个等式产生的亮点比现实生活中看到的要广泛得多。最大值是在正确的地方，它是正确的颜色，但它就是太大了。我们可以在不减少其最大颜色的情况下缩小它:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202518.png" class="" title="image-20210927202518">

<p><strong>这里p被称为Phong指数;它是一个正实数(Phong, 1975)。改变Phong指数在高亮显示上的效果可以在下图中看到。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202608.png" class="" title="image-20210927202608">

<p>Phong指数对突出特征的影响。这将使用上式来突出显示。还有一个漫反射组件，给对象一个闪亮的非金属外观。图片由Nate Robins提供。</p>
<p><strong>为了实现上式，我们首先需要计算单位向量r。给定单位向量l和n, r是关于n的向量l，如下图所示这个向量可以被计算为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202801.png" class="" title="image-20210927202801">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202752.png" class="" title="image-20210927202752">

<p>计算向量r的几何图形。</p>
<p><strong>用点积来计算cos θ。</strong></p>
<p><strong>另一种基于上上式的启发式模型消除了检查作为指数基数的数字是否为负值的需要(Warn, 1983)。我们不计算r，而是计算l和e中间的单位向量h(下图):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202831.png" class="" title="image-20210927202831">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202940.png" class="" title="image-20210927202940">

<p>单位向量h在l和e之间。</p>
<p><strong>高亮出现在h接近n时，即。，当cos ω = h·n接近1时。这就提出了一个规则:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927202839.png" class="" title="image-20210927202839">

<p><strong>这里的指数p将具有类似于Phong照明模型方程中的指数的控制行为，但h和n之间的角度是e和r之间的角度的一半大小，所以细节将略有不同。使用n和h之间的余弦的优点是，对于平面上的眼睛和光线，余弦总是正的。缺点是需要平方根和除法来计算h。</strong></p>
<p><strong>在实践中，我们希望大多数材料除了高光外还有漫反射的外观。我们可以结合得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203119.png" class="" title="image-20210927203119">

<p><strong>如果我们想让用户调暗高光，我们可以添加一个控制项cp：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203129.png" class="" title="image-20210927203129">

<p><strong>cp是RGB颜色，它允许我们改变高光颜色。这对cp = cr，因为金属上的高光会呈现出金属的颜色。此外，使cp小于1的中性值，使颜色保持在1以下。例如，设置cp = 1−M，其中M是cr的最大分量将保持颜色低于1为一个光源和没有环境条件。</strong></p>
<h3 id="Surface-Normal-Vector-Interpolation-曲面法向量插值"><a href="#Surface-Normal-Vector-Interpolation-曲面法向量插值" class="headerlink" title="Surface Normal Vector Interpolation 曲面法向量插值"></a>Surface Normal Vector Interpolation 曲面法向量插值</h3><p><strong>与具有相同几何形状的Lambertian曲面相比，带有高光的光滑表面易于快速改变颜色。因此，在法向量上的着色可以产生干扰的伪影。</strong></p>
<p><strong>这些问题可以通过在多边形上插值法向量，然后在每个像素上应用Phong着色来减少。这可以让你得到好的图像，而不使三角形的大小极小。回想第3章，当栅格化三角形时，我们计算重心坐标(α， β， γ)来插值顶点颜色c0,c1,c2：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203458.png" class="" title="image-20210927203458">

<p><strong>我们可以用同一个方程来插值曲面法线n0,n1和n2：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203509.png" class="" title="image-20210927203509">

<p><strong>对于每个像素处计算的n，可以计算公式：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203129.png" class="" title="image-20210927203129">

<p><strong>注意，由上上式得到的n通常不是单位法线。如果在使用着色计算之前将其转换为单位向量，将获得更好的视觉效果。这种类型的法向插值通常被称为Phong法向插值(Phong, 1975)。</strong></p>
<h2 id="Artistic-Shading-艺术着色"><a href="#Artistic-Shading-艺术着色" class="headerlink" title="Artistic Shading 艺术着色"></a>Artistic Shading 艺术着色</h2><p><strong>Lambertian和Phong着色方法是基于启发式设计来模仿真实世界中物体的外观。艺术着色是为了模仿人类艺术家的绘画而设计的(Yessios, 1979;杜利和科恩，1990年;齐藤&amp;高桥，1990;l·威廉姆斯,1991)。这种底纹在许多应用中似乎有优势。例如，汽车制造商雇佣艺术家为车主手册绘制图表。这比使用更“现实”的照片要昂贵得多，所以当需要某些类型的交流时，艺术家的技术可能有一些内在的优势。在本节中，我们将展示如何制作巧妙的着色线图纸，让人想起人类绘制的图像。创建这样的图像通常被称为非真实感渲染，但我们将避免使用这个术语，因为许多非真实感技术用于提高效率，与任何艺术实践无关。</strong></p>
<h3 id="Line-Drawing-绘制线"><a href="#Line-Drawing-绘制线" class="headerlink" title="Line Drawing 绘制线"></a>Line Drawing 绘制线</h3><p><strong>我们在人类绘画中看到的最明显的东西是我们在现实生活中看不到的剪影。当我们有一组共享边的三角形时，当共享边的两个三角形中的一个面向观看者，而另一个面向远离观看者时，我们应该画一条边作为剪影。这个条件可以用两个法线n0 和n1来测试</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203931.png" class="" title="image-20210927203931">

<p><strong>这是一个从边缘到眼睛的向量。这可以是边上的任意一点也可以是三角形中的任意一个。另外,如果fi(p) = 0为两个三角形的隐式平面方程，检验可写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203941.png" class="" title="image-20210927203941">

<p><strong>我们还想绘制多边形模型的可见边缘。为了做到这一点，我们可以使用第12章中的任何一种隐面方法来绘制背景色，然后用黑色绘制每个三角形的轮廓。事实上，这也将捕捉到轮廓。不幸的是，如果多边形代表一个光滑的表面，我们真的不想画大部分的边。然而，我们可能想要画出所有的折痕，那里确实有一个角落的几何。我们可以使用启发式阈值来测试折痕:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927203951.png" class="" title="image-20210927203951">

<p><strong>这与轮廓测试相结合将给出漂亮的线条图。</strong></p>
<h3 id="Cool-to-Warm-Shading-冷暖着色"><a href="#Cool-to-Warm-Shading-冷暖着色" class="headerlink" title="Cool-to-Warm Shading 冷暖着色"></a>Cool-to-Warm Shading 冷暖着色</h3><p><strong>当艺术家在画线条时，他们经常使用低强度的着色给表面一些曲线的印象，并给物体着色(Gooch, Gooch, Shirley， &amp; Cohen, 1998)。朝一个方向的表面用冷色着色，如蓝色，朝相反方向的表面用暖色着色，如橙色。通常这些颜色不是很饱和，也不是很暗。这样，黑色的轮廓就能很好地展现出来。总的来说，这给了一个卡通般的效果。这可以通过设置一个“温暖”光的方向l和使用余弦调制颜色，其中温暖常数kw 定义在[0,1]上:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927204323.png" class="" title="image-20210927204323">

<p><strong>颜色c是冷色cc 和暖色cw的线性混合：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927204332.png" class="" title="image-20210927204332">

<p><strong>cw 和cb 将产生看起来合理的结果。猜测的一个好起点是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927204341.png" class="" title="image-20210927204341">

<p><strong>下图显示了传统的Phong照明和这种艺术着色类型的比较。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210927204353.png" class="" title="image-20210927204353">

<p>左:Phong照明图像。中:如果没有轮廓，从冷到暖的阴影是没有用的。右:冷到暖的阴影加上轮廓。图片由Amy Gooch提供。</p>
<h1 id="11-Texture-Mapping-纹理映射"><a href="#11-Texture-Mapping-纹理映射" class="headerlink" title="11 Texture Mapping 纹理映射"></a>11 Texture Mapping 纹理映射</h1><p><strong>当试图复制真实世界的外观时，人们很快就会意识到几乎没有任何表面是无特征的。木头随谷物生长;皮肤长出皱纹;布显示其编织结构;油漆显示出刷子或滚筒的痕迹。即使是光滑的塑料也有凹凸的部分，而光滑的金属则显示出加工过程的痕迹。曾经毫无特色的材料很快就会被标记、凹痕、污渍、划痕、指纹和污垢所覆盖。</strong></p>
<p><strong>在计算机图形学中，我们把所有这些现象都归到“空间变化的表面属性”的标题下——这些表面属性在不同的地方变化，但并不真正以有意义的方式改变表面的形状。允许这些影响,各种建模和渲染系统提供一些纹理映射方法:使用一个图像,称为纹理贴图,纹理图像,或只是一个纹理,存储细节,你想去在一个表面上,然后“映射”数学图像到表面上。</strong></p>
<p><strong>事实证明，一旦将图像映射到表面的机制存在，就会有许多不太明显的方法可以使用，而不仅仅是引入表面细节的基本目的。纹理可以用来制造阴影和反射，提供照明，甚至定义表面形状。在复杂的交互程序中，纹理被用来存储各种各样的数据，这些数据甚至与图片没有任何关系!</strong></p>
<p><strong>本章讨论了使用纹理来表示表面细节、阴影和反射。虽然基本思想很简单，但有几个实际问题使纹理的使用复杂化。首先，纹理很容易变形，设计将纹理映射到表面的功能是具有挑战性的。此外，纹理映射是一个重采样过程，就像缩放图像一样，正如我们在第9章中看到的，重采样很容易引入混叠现象。纹理映射和动画的结合使用很容易产生真正引人注目的混叠，纹理映射系统的许多复杂性都是由用于驯服这些伪影的抗锯齿措施造成的。</strong></p>
<h2 id="Looking-Up-Texture-Values-查找纹理值"><a href="#Looking-Up-Texture-Values-查找纹理值" class="headerlink" title="Looking Up Texture Values 查找纹理值"></a>Looking Up Texture Values 查找纹理值</h2><p><strong>首先，让我们考虑一个简单的纹理映射应用。我们有一个木地板的场景，我们希望地板的漫反射颜色由一个显示木地板纹理的图像来控制。无论我们使用光线追踪或光栅化,计算颜色的着色代码光线表面交点或片段生成的光栅化程序需要知道的颜色纹理着色点,为了使用它作为漫射颜色传感器的着色模型从第十章。</strong></p>
<p><strong>为了获得这种颜色，着色器执行纹理查找:它在纹理图像的坐标系统中找出对应于着色点的位置，并读取图像中该点的颜色，从而生成纹理样本。这种颜色随后被用于着色，由于纹理查找发生在每个看到地板的像素的纹理的不同位置，不同颜色的图案就会在图像中显示出来。代码可能是这样的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105402.png" class="" title="image-20210929105402">

<p><strong>在这段代码中，着色器询问表面在纹理中寻找的位置，而我们想要使用纹理着色的每个表面都需要能够回答这个问题。这就引出了纹理映射的第一个关键元素:我们需要一个从表面映射到纹理的函数，我们可以轻松地计算每个像素。这是纹理坐标函数(下图)，我们说它为表面上的每个点分配纹理坐标。数学上，它是从表面S到纹理域T的映射:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105550.png" class="" title="image-20210929105550">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105521.png" class="" title="image-20210929105521">

<p>就像观看投影π地图每一个点在物体表面,S,图像中的一个点,纹理坐标函数φ地图对象的表面上每一个点一个点的纹理映射,T .适当地定义这个函数φ是纹理映射的所有应用程序的基础。</p>
<p><strong>集合T，通常称为“纹理空间”，通常只是一个包含图像的矩形;常用单位平方(u, v)∈[0,1]² (在本书中，我们将使用名称u和v作为两个纹理坐标)。在很多方面，它类似于第七章讨论的视觉投影，本章称之为π，它将场景表面上的点映射到图像上的点;两者都是3d到2D的映射，并且都是渲染所需要的——一个是知道从哪里得到纹理值，一个是知道在图像中放置着色结果。但也有一些重要的区别:π几乎总是一个透视或正投影，而φ可以有多种形式;一个图像只有一个可视投影，而场景中的每个物体都可能有一个完全独立的纹理坐标函数。</strong></p>
<p><strong>当我们的目标是将纹理放到表面上时，φ是一个从表面到纹理的映射，这似乎令人惊讶，但这是我们需要的功能。</strong></p>
<p><strong>对于木地板的情况，如果地板恰好处于恒定的z轴并与x轴和y轴对齐，我们可以使用映射</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105836.png" class="" title="image-20210929105836">

<p><strong>对于一些适当选择的比例因子a和b，将纹理坐标(s, t)分配给点(x, y, z)floor，然后使用纹理像素或texel的值，最接近(u, v)的是(x, y)处的纹理值。我们用这种方法渲染下图中的图像。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929105938.png" class="" title="image-20210929105938">

<p>木地板，使用纹理坐标函数直接使用点的x和y坐标进行纹理。</p>
<p><strong>这是非常有限的，尽管:如果房间建模在x和y轴的一个角度，或者如果我们想要木材纹理在椅子的弯曲靠背上呢?我们需要一些更好的方法来计算表面上的点的纹理坐标。</strong></p>
<p><strong>从最简单的纹理映射形式中产生的另一个问题是，从一个非常接近的角度绘制一个高对比度的纹理到一个低分辨率的图像。下图显示了一个更大的平面纹理，使用了相同的方法，但使用了高对比度的网格模式和朝向地平线的视图。你可以看到，当没有使用适当的过滤器时，它包含走样的伪影(前景中的台阶，远处的波浪形和闪光图案)，类似于图像重采样(第9章)中出现的伪影。虽然这需要一个极端的情况，使这些文物如此明显地在一个微小的静止图像印在一本书，在动画中，这些模式移动，非常分散，即使他们是非常微妙的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929110016.png" class="" title="image-20210929110016">

<p>一个大的水平面，纹理与上图相同，并显示严重的走样现象。</p>
<p><strong>现在我们已经看到了基本纹理映射中的两个主要问题:</strong></p>
<p>​    <strong>定义纹理坐标函数</strong></p>
<p>​    <strong>查找纹理值而不引入太多的走样。</strong></p>
<p><strong>这两个问题是所有类型的纹理映射应用的基础，将在第11.2节和11.3节中讨论。一旦你理解了它们和它们的一些解决方案，那么你就理解了纹理映射。剩下的只是如何将基本的纹理机制应用于各种不同的目的，这将在第11.4节中讨论。</strong></p>
<h2 id="Texture-Coordinate-Functions-纹理坐标函数"><a href="#Texture-Coordinate-Functions-纹理坐标函数" class="headerlink" title="Texture Coordinate Functions 纹理坐标函数"></a>Texture Coordinate Functions 纹理坐标函数</h2><p><strong>设计好纹理坐标函数φ是获得良好纹理映射效果的关键。你可以将其视为决定如何变形一个平面的矩形图像，使其符合你想要绘制的3D表面。或者，你将表面轻轻地压平，不让它起皱、撕裂或折叠，使它平躺在图像上。有时这很简单:也许3D表面已经是一个扁平的矩形!在其他情况下则非常棘手:3D形状可能非常复杂，比如角色身体的表面。</strong></p>
<p><strong>定义纹理坐标函数的问题在计算机图形学中并不新鲜。制图师在设计时也面临着同样的问题覆盖地球表面大片区域的地图:从曲面到平面的地图不可避免地会导致区域、角度和/或距离的扭曲，这很容易使地图变得非常容易误导人。几个世纪以来，人们提出了许多地图投影，它们都是为了平衡纹理映射所面临的相同的竞争问题——在覆盖大面积连续区域的同时尽量减少各种失真。</strong></p>
<p><strong>在某些应用程序中(我们将在本章后面看到)，使用特定映射有明确的理由。但在大多数情况下，设计纹理坐标地图是一项微妙的任务，需要平衡相互冲突的关注点，熟练的建模人员为此付出了相当大的努力。</strong></p>
<p><strong>你可以用任何你能想到的方式来定义φ。但有几个相互竞争的目标需要考虑:</strong></p>
<p>​    <strong>双射性。在大多数情况下，你会希望φ是双射的(参见2.1.1节)，这样表面上的每个点都会映射到纹理空间中的不同点。如果几个点映射到同一个纹理空间点，纹理中一个点的值会影响到表面上的几个点。在你想要纹理在表面上重复的情况下(想想墙纸或地毯的重复图案)，故意引入从表面点到纹理点的多对一映射是有意义的，但你不希望这意外发生。</strong></p>
<p>​    <strong>尺寸失真。纹理的比例在整个表面上应该是近似恒定的。也就是说，表面上任何距离相同的近距离点应该映射到纹理中距离相同的点。对于函数φ来说，φ导数的大小不应变化太大。</strong></p>
<p>​    <strong>形状畸变。纹理不应该被扭曲。也就是说，绘制在表面上的一个小圆应该映射到纹理空间中的一个合理的圆形形状，而不是一个被压扁或拉长的形状。就φ而言，φ的导数在不同的方向上不应相差太大规划设计。</strong> </p>
<p>​    <strong>连续性。不应该有太多的接缝:表面上相邻的点应该映射到纹理上相邻的点。也就是说，φ应该是连续的，或有尽可能少的不连续。在大多数情况下，一些不连续是不可避免的，我们想把它们放在不显眼的地方。</strong><br><strong>由参数方程定义的表面(章节2.5.8)带有纹理坐标函数的内置选择:简单地反转函数这定义了表面，并使用表面的两个参数作为纹理坐标。这些纹理坐标可能有也可能没有理想的属性，这取决于表面，但它们确实提供了映射。</strong></p>
<p><strong>但是对于隐式定义的表面，或者仅仅由三角形网格定义的表面，我们需要一些其他的方法来定义纹理坐标，而不依赖于现有的参数化。广义地说，定义纹理坐标的两种方法是从表面点的空间坐标几何上计算纹理坐标，或者，对于网格表面，在顶点上存储纹理坐标的值并在整个表面上插入它们。让我们逐个看看这些选项。</strong></p>
<h3 id="Geometrically-Determined-Coordinates-几何确定坐标"><a href="#Geometrically-Determined-Coordinates-几何确定坐标" class="headerlink" title="Geometrically Determined Coordinates 几何确定坐标"></a>Geometrically Determined Coordinates 几何确定坐标</h3><p><strong>几何决定的纹理坐标用于简单的形状或特殊的情况，作为一个快速的解决方案，或作为设计手工调整纹理坐标地图的起点。</strong></p>
<p><strong>我们将通过将下图中的测试图像映射到表面来说明各种纹理坐标函数。图像中的数字可以让您从渲染图像中读出近似的(u, v)坐标，网格可以让您看到映射的失真程度。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929110842.png" class="" title="image-20210929110842">

<h4 id="Planar-Projection-平行投影"><a href="#Planar-Projection-平行投影" class="headerlink" title="Planar Projection 平行投影"></a>Planar Projection 平行投影</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111052.png" class="" title="image-20210929111052">

<p>平行投影，如果投影方向大致沿着整体法线选择，那么物体或物体的部分几乎是平的。</p>
<p><strong>从3D到2D最简单的映射可能是平行投影——与用于正射影的映射相同(上图)。我们已经为查看(第7.1节)开发的机制可以直接用于定义纹理坐标:正如正投影查看归结为乘以一个矩阵并丢弃z组件，通过平面投影生成纹理坐标可以通过简单的矩阵乘法来完成:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111209.png" class="" title="image-20210929111209">

<p><strong>纹理矩阵Mt 表示一个仿射变换，星号表示我们不关心最后在第三个坐标中是什么。</strong></p>
<p><strong>这对于平面表面来说非常有效，没有太多的表面法线变化，并且可以通过取平均法线找到一个好的投影方向。对于任何闭合形状，平面投影都可以不是单射的:正面和背面的点将映射到纹理空间中的同一个点(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111305.png" class="" title="image-20210929111305">

<p>在一个封闭的物体上使用平行投影总是会导致一个非单射，一对多的映射，以及在投影方向与物体相切的点附近的极端失真。</p>
<p><strong>通过简单地将透视投影替换为正投影，我们得到了投影纹理坐标(下图):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111357.png" class="" title="image-20210929111357">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111408.png" class="" title="image-20210929111408">

<p>投影纹理变换，使用向某一点投射的类似视图的转换。</p>
<p><strong>现在是4×4矩阵P<em>t</em> 表示一个投影(不一定是仿射)变换——也就是说，最后一行可能不是[0,0,0,1]。</strong></p>
<p><strong>投影纹理坐标在阴影映射技术中非常重要，将在11.4.4节中讨论。</strong></p>
<h4 id="Spherical-Coordinates-球坐标"><a href="#Spherical-Coordinates-球坐标" class="headerlink" title="Spherical Coordinates 球坐标"></a>Spherical Coordinates 球坐标</h4><p><strong>对于球体，纬度/经度参数化是熟悉的，并且被广泛使用。它在两极附近有很多失真，这可能会导致困难，但它确实覆盖了整个球体，只有沿一条纬度线的不连续。</strong></p>
<p><strong>表面球形的形状上大致可以使用一个纹理坐标参数化功能,地图上的一个点表面使用径向投影球面上的点:把一条线从球体的中心通过表面的点,并找到与球面相交。这个交点的球坐标是你开始在表面上的点的纹理坐标。</strong></p>
<p><strong>另一种说法是，用球坐标(ρ， θ， φ)表示曲面点，然后去掉ρ坐标，将θ和φ分别映射到范围[0,1]。这个公式依赖于球坐标的约定;使用第2.5.8节的约定，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111758.png" class="" title="image-20210929111758">

<p><strong>一个球坐标地图将是双射的，除了极点，如果整个表面是可见的，从中心点。它在两极附近继承了与球体上的经纬度图相同的失真。下图显示了一个球体坐标提供了合适的纹理坐标函数的对象。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111829.png" class="" title="image-20210929111829">

<p>对于这个模糊的球形物体，将每个点投影到以物体中心为中心的球体上提供了一个单射映射，这里用于放置与球体图像相同的映射纹理。注意，当表面离中心较远时，区域会被放大(表面点在纹理空间中聚集在一起)，而当表面离中心较近时，区域会收缩。</p>
<h4 id="Cylindrical-Coordinates-圆柱坐标"><a href="#Cylindrical-Coordinates-圆柱坐标" class="headerlink" title="Cylindrical Coordinates 圆柱坐标"></a>Cylindrical Coordinates 圆柱坐标</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112018.png" class="" title="image-20210929112018">

<p>一个远离球形的花瓶，球面投影产生很多失真(左)和圆柱形投影产生一个非常好的结果在外部表面。</p>
<p><strong>对于柱状而非球面的物体，从轴向外投影到圆柱体可能比从点投影到球面更好(上图)。类似于球面投影，这相当于转换为柱坐标并丢弃半径:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929111957.png" class="" title="image-20210929111957">

<h4 id="Cubemaps-立方体映射"><a href="#Cubemaps-立方体映射" class="headerlink" title="Cubemaps 立方体映射"></a>Cubemaps 立方体映射</h4><p><strong>使用球坐标参数化球形或球形形状会导致形状和极点附近区域的高度失真，这通常会导致可见的伪影，揭示有两个特殊的点纹理出了问题。一种流行的替代方案要均匀得多，但代价是有更多的不连续。这个想法是投射到一个立方体上，而不是一个球体上，然后使用六个独立的正方形纹理为立方体的六个面。6个正方形纹理的集合称为立方体贴图。这在立方体的所有边缘上都引入了不连续，但它保持了形状和面积的低失真。</strong></p>
<p><strong>计算立方地图纹理坐标也比计算球坐标便宜，因为投影到一个平面上只需要一个分割——本质上与透视投影用于观看相同。例如，对于一个投射到立方体的+z面上的点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112312.png" class="" title="image-20210929112312">

<p><strong>三次映射的一个令人困惑的方面是建立如何在六个面上定义u和v方向的约定。任何约定都可以，但是选择的约定会影响纹理的内容，所以标准化是很重要的。因为立方体映射通常用于从立方体内部观察的纹理(参见11.4.5节中的环境映射)，通常的惯例是u轴和v轴朝向，因此从内部观察u轴是顺时针方向的。OpenGL使用的约定是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112406.png" class="" title="image-20210929112406">

<p><strong>下标表示每个投影对应立方体的哪个面。例如，φ - x用于在x = +1处投影到立方体表面的点。你可以通过观察绝对值最大的坐标来判断一个点投射到哪个面:例如，如果|x| &gt; |y|和|x| &gt; |z|，这个点投射到+x面或−x面，这取决于x的符号。</strong></p>
<p><strong>用于立方体贴图的纹理有6个方形块。(参见下图)。通常它们被打包在一个图像中存储，就像立方体被打开一样。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112455.png" class="" title="image-20210929112455">

<p>被投影成立方体地图的表面。表面上的点从中心向外投射，每个点映射到六个面上的一个点上。</p>
<h3 id="Interpolated-Texture-Coordinates-插值纹理坐标"><a href="#Interpolated-Texture-Coordinates-插值纹理坐标" class="headerlink" title="Interpolated Texture Coordinates 插值纹理坐标"></a>Interpolated Texture Coordinates 插值纹理坐标</h3><p><strong>为了对三角形网格表面上的纹理坐标函数进行更细粒度的控制，您可以在每个顶点显式地存储纹理坐标，并在三角形上使用重心插值(章节8.1.2)。它的工作方式与任何其他平滑变化的数量，你可能会定义一个网格:颜色，法线，甚至3D位置本身。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112711.png" class="" title="image-20210929112711">

<p>使用线性插值纹理坐标的单个三角形。左:纹理空间中绘制的三角形;右:在3D场景中渲染的三角形。</p>
<p><strong>让我们看一个单三角形的例子。上图显示了一个三角形纹理映射到现在熟悉的测试模式的一部分。通过查看呈现在三角形上的模式，您可以推断出三个顶点的纹理坐标是(0.2,0.2)、(0.8,0.2)和(0.2,0.8)，因为这些是纹理中出现在三角形三个角上的点。就像前一节中几何决定的映射一样，我们通过给出从表面到纹理域的映射来控制纹理在表面上的位置，在本例中，我们通过指定每个顶点在纹理空间中的位置。一旦你定位了顶点，其余的就由三角形的线性(重心)插值处理了。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112800.png" class="" title="image-20210929112800">

<p>一个二十面体，它的三角形布局在纹理空间中，提供零失真，但有许多接缝。</p>
<p><strong>在上图中，我们展示了一种在整个网格上可视化纹理坐标的常见方法:简单地在纹理空间中绘制顶点位于的三角形他们的纹理坐标。这个可视化显示了哪个三角形正在使用纹理的哪个部分，它是一个方便的工具，用于评估纹理坐标和调试各种纹理映射代码。</strong></p>
<p><strong>由顶点纹理坐标定义的纹理坐标映射的质量取决于分配给顶点的坐标——也就是说，网格在纹理空间中是如何布局的。无论分配什么坐标，只要网格中的三角形共享顶点(章节12.1)，纹理坐标映射总是连续的，因为相邻三角形在共享边的点上的纹理坐标是一致的。但是上面描述的其他可取的品质并不是自动的。注入性意味着三角形在纹理空间中不重叠——如果它们重叠，就意味着纹理中的某个点会出现在表面的多个地方。</strong></p>
<p><strong>当纹理空间中的三角形面积与其三维空间中的三角形面积成比例时，尺寸失真较小。例如，如果使用连续的纹理坐标函数映射角色的脸，那么角色的鼻子就会被压缩到一个相对较小的纹理空间中，如下图所示。虽然鼻子上的三角形比脸颊上的三角形小，但在纹理空间上，大小比例更极端。结果是鼻子上的纹理被放大了，因为一小块纹理必须覆盖大面积的表面。类似地，比较前额和太阳穴，三角形在3D中大小相似，但太阳穴周围的三角形在纹理空间上更大，导致纹理在那里看起来更小。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929112912.png" class="" title="image-20210929112912">

<p>一种人脸模型，分配纹理坐标，以达到合理的低形状失真，但仍然显示适度的区域失真。</p>
<p><strong>同样地，当三角形的形状在三维和纹理空间中相似时，形状失真程度也较低。面具有相当低的形状失真。</strong></p>
<h3 id="Tiling-Wrapping-Modes-and-Texture-Transformations-平铺、包裹模式和纹理转换"><a href="#Tiling-Wrapping-Modes-and-Texture-Transformations-平铺、包裹模式和纹理转换" class="headerlink" title="Tiling, Wrapping Modes, and Texture Transformations 平铺、包裹模式和纹理转换"></a>Tiling, Wrapping Modes, and Texture Transformations 平铺、包裹模式和纹理转换</h3><p><strong>允许纹理坐标超出纹理图像的边界通常是有用的。有时这是一个细节:纹理坐标计算中的舍入误差可能会导致恰好落在纹理边界上的顶点稍微偏外，在这种情况下，纹理映射机制应该不会失败。但它也可以是一个建模工具。</strong></p>
<p><strong>如果纹理只覆盖部分表面，但纹理坐标已经设置好，将整个表面映射到单位正方形，一个选项是准备一个纹理图像，大部分是空白的内容在一个小区域。但这可能需要一个非常高分辨率的纹理图像来获得相关区域的足够细节。另一种选择是缩放所有的纹理坐标它们覆盖了一个更大的范围——[- 4.5,5.5]×[- 4.5, 5.5]，例如，将一个正方形单元置于表面中心的十分之一大小。</strong></p>
<p><strong>对于这样的情况，纹理图像所覆盖的单位平方区域之外的纹理查找应该返回一个恒定的背景颜色。一种方法是设置一个背景颜色，以便在单位方块之外的纹理查找时返回。如果已经有一个恒定的背景颜色纹理图像(例如,一个标志在白色背景),另一种方法来扩展这个背景平面安排查找外单位平方返回纹理图像的颜色最接近边缘,通过夹紧u和v坐标的范围从第一个像素的像素的图像。</strong></p>
<p><strong>有时我们想要一个重复的图案，比如棋盘、瓷砖地板或砖墙。如果模式在矩形网格上重复，那么创建包含许多相同数据副本的图像将是一种浪费。相反，我们可以使用环绕索引处理纹理图像之外的纹理查找—当查找点离开纹理图像的右边缘时，它环绕到纹理图像的左边缘。这可以非常简单地使用像素坐标上的整数余数操作来处理。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929113329.png" class="" title="image-20210929113329">

<p><strong>这两种处理越界查找的方式之间的选择是通过从包含平铺、夹紧以及这两种方式的组合或变体的列表中选择包装模式来指定的。在环绕模式下，我们可以自由地将纹理视为返回无限2D平面上任意点颜色的函数(下图)。当我们使用图像指定纹理时，这些模式描述了如何使用有限的图像数据来定义这个函数。在11.5节中，我们将看到程序纹理可以自然地扩展到无限平面，因为它们不受有限图像数据的限制。由于两者在逻辑上都是无限的，这两种类型的纹理是可以互换的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929113402.png" class="" title="image-20210929113402">

<p>通过包裹texel坐标将木地板纹理平铺在纹理空间上。</p>
<p><strong>当调整纹理的比例和位置时，它很方便地避免实际改变生成纹理坐标的函数，或存储在网格顶点的纹理坐标值，而不是应用一个矩阵变换生成纹理坐标，然后使用它们来采样纹理:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929113440.png" class="" title="image-20210929113440">

<p><strong>φmodel 模型是否有纹理坐标函数，MT 是一个3 × 3矩阵，表示2D纹理坐标使用齐次坐标的仿射或投影变换。这种转换有时仅限于缩放和/或平移，大多数使用纹理映射的渲染器都支持这种转换。</strong></p>
<h3 id="Perspective-Correct-Interpolation-透视正确插值"><a href="#Perspective-Correct-Interpolation-透视正确插值" class="headerlink" title="Perspective Correct Interpolation 透视正确插值"></a>Perspective Correct Interpolation 透视正确插值</h3><p><strong>通过在三角形上插值纹理坐标来获得正确的视角有一些微妙之处，但我们可以在栅格化阶段解决这个问题。事情不是那么简单的原因是在屏幕空间中插值纹理坐标会导致不正确的图像，如下图中的网格纹理所示。因为随着与观众距离的增加，视角中的物体会变得更小，所以在3D中间隔均匀的线条在2D图像空间中应该会被压缩。为了实现这一点，需要更仔细地插值纹理坐标。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114000.png" class="" title="image-20210929114000">

<p>左:正确的观点。右:插值到屏幕空间。</p>
<p><strong>我们可以通过插值(u, v)坐标来实现三角形上的纹理映射，修改8.1.2节的光栅化方法，但结果是这样的，在上图右侧显示的问题中。如果使用如下光栅化代码所示的屏幕空间重心坐标，三角形也会出现类似的问题:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114152.png" class="" title="image-20210929114152">

<p><strong>这段代码将生成图像，但有一个问题。为了解开这个基本问题，让我们考虑从世界空间q到齐次点r再到齐次点s的级数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114221.png" class="" title="image-20210929114221">

<p><strong>纹理坐标插值问题最简单的形式是当我们有纹理坐标(u, v)与两个点q和Q相关联时，我们需要在图像中沿着s和S之间的直线生成纹理坐标。如果世界坐标点q′在q和Q投影到屏幕空间点s′在s和S之间的直线上，那么这两个点应该有相同的纹理坐标。</strong></p>
<p><strong>上面的算法所体现的na¨ıve屏幕空间方法表示，在点s′= s+α(S - s)我们应该使用纹理坐标us +α(uS −us)和vs +α(vS −vs)．这是不对的，因为世界空间点q′它转化成s′而不是q + α(Q−q)。</strong></p>
<p><strong>然而，从第7.4节我们知道q和q之间线段上的点确实在s和s之间线段上的某个地方结束;事实上，在那部分我们已经展示过了</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114723.png" class="" title="image-20210929114723">

<p><strong>插值参数t和α是不一样的，但我们可以从另一个计算:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929114732.png" class="" title="image-20210929114732">

<p><strong>这些方程为屏幕空间插值思想提供了一个可能的解决方案。获取屏幕空间点的纹理坐标s′= s + α(S−s)，计算us′ = us +t(α)(uS −us) and vs′ = vs +t(α)(vS −vs).点q′它映射到s′，所以这是可行的。然而，评估每个片段的t(α)是缓慢的，有一个更简单的方法。</strong></p>
<p><strong>关键的观察是，因为我们知道，透视变换保留了直线和平面，所以在三角形上线性插值我们想要的任何属性是安全的，但前提是它们与点一起经过透视变换。为了得到几何直观，减小维数，得到齐次点(xr,yr,wr)和一个单独的属性u被插入。属性u应该是xr和yr的线性函数，如果我们把u画成高度场除以(xr,yr)结果是一个平面。现在，如果我们把u看做第三个空间坐标，叫它ur 强调它和其他的是一样的)并发送整个3D齐次点(xr,yr,ur,wr)，结果(xs,ys,us)仍然生成平面上的点。在平面内会有一些扭曲，但平面保持平坦。这意味着us 是(xs,ys)的线性函数，也就是说，我们可以通过基坐标(xs，ys)计算us ．</strong></p>
<p><strong>回到完整的问题，我们需要插值纹理坐标(u, v)，它是世界空间坐标(x)的线性函数(xq,yq, zq)．在将点转换到屏幕空间并添加纹理坐标之后，我们便拥有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929115503.png" class="" title="image-20210929115503">

<p><strong>上一段的实际含义是，我们可以继续并根据(x)的值插值所有这些量(xs,ys)—包括值zs，用于z缓冲区。na¨ıve方法的问题很简单，我们正在插值不一致选择的组件——只要所涉及的数量是在透视分割之前或全部之后，一切都会很好。</strong></p>
<p><strong>剩下的一个问题是(u/wr, v / wr)对于查找纹理数据不是直接有用的;我们需要(u, v)。这就解释了插入上式的额外参数的用途，它的值总是1:一旦我们有了u/wr, v/wr, 1/ wr*，我们可以很容易地通过除法得到(u, v)。</strong></p>
<p><strong>为了验证这是正确的，让我们检查一下插值1/w<em>r</em> 在屏幕空间确实产生了内插wr的倒数在世界空间。要验证这一点，请确认:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929115808.png" class="" title="image-20210929115808">

<p><strong>记住，α(t)和t由上上式联系起来。</strong></p>
<p><strong>这个能力内插1/wr 在转换的空间中，线性且没有错误的允许我们正确地纹理三角形。我们可以使用这些事实来修改三个点ti = (xi,yi, zi,wi)的扫描转换代码，它已经通过观看矩阵，但没有被均质化，完整的纹理坐标ti = (ui, vi)：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929115819.png" class="" title="image-20210929115819">

<p><strong>当然，为了提高速度，伪代码中出现的许多表达式都是在循环外部预先计算的。对于实体纹理，只要包含原始世界空间坐标xq,yq, zq就足够简单了在属性列表中，与u和v相同处理，得到正确的插值世界空间坐标，可以传递给实体纹理函数。</strong></p>
<h3 id="Continuity-and-Seams-连续性和接缝"><a href="#Continuity-and-Seams-连续性和接缝" class="headerlink" title="Continuity and Seams 连续性和接缝"></a>Continuity and Seams 连续性和接缝</h3><p><strong>虽然低失真和连续性是纹理坐标函数的优良特性，但不连续往往是不可避免的。对于任何封闭的三维曲面，没有连续的双射函数将整个曲面映射成纹理图像，这是拓扑的基本结果。有些东西必须要放弃，通过引入接缝(纹理坐标突然改变的表面曲线)，我们可以在其他地方得到低失真。上面讨论的许多几何决定的映射已经包含接缝:在球面和圆柱坐标中，接缝是由atan2计算的角度围绕从π到−π，在立方体贴图中，接缝沿着立方体边缘，在这里映射在六个正方形纹理之间切换。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210929120204.png" class="" title="image-20210929120204">

<p>多边形球体:在左侧，有所有共享的顶点，纹理坐标函数是连续的，但在穿过180度子午线的三角形上必然会有问题，因为纹理坐标是从接近180度的经度插值到接近−180度的经度。在右侧，一些顶点被复制，具有相同的3D位置，但纹理坐标在经度上有360度的差异，因此纹理坐标是在子午线上插值的，而不是在整个地图上。</p>
<p><strong>使用插值纹理坐标，接缝需要特别考虑，因为它们不会自然发生。我们前面观察到插值纹理坐标在共享顶点网格上是自动连续的——共享纹理坐标保证了这一点。但这意味着，如果一个三角形跨越一条缝，在一边有一些顶点，在另一边有一些顶点，插补机器将乐于提供一个连续的映射，但它可能会被高度扭曲或折叠，因此它不是内射的。上图在球坐标映射的球体上说明了这个问题。例如，在地球底部附近有一个三角形，它的一个顶点位于新西兰南岛的顶端，另一个顶点位于太平洋北岛东北约400公里处。一个明智的飞行员在这些点之间飞行将飞越新西兰，但路径开始在经度167◦s E(+167)和结束在179◦s W(即经度−179)，所以线性插值选择的路线，在途中跨越南美。这将导致整个地图的反向拷贝被压缩成横过180度子午线的三角形带。解决方案是用等效经度181◦s E标记第二个顶点，但这只是将问题推到下一个三角形。</strong></p>
<p><strong>创建一个干净过渡的唯一方法是避免在接缝处共享纹理坐标:穿越新西兰的三角形需要插入经度+181，而太平洋的下一个三角形需要继续从经度−179开始。为了做到这一点，我们复制顶点在接缝:对于每个顶点，我们添加一个具有相同经度的第二个顶点，不同的360◦，和三角形在接缝的相对边使用不同的顶点。这个解决方案如上图的右半部分所示，其中纹理空间最左边和最右边的顶点是重复的，具有相同的3D位置。</strong></p>
<h2 id="Antialiasing-Texture-Lookups-抗锯齿纹理查找"><a href="#Antialiasing-Texture-Lookups-抗锯齿纹理查找" class="headerlink" title="Antialiasing Texture Lookups 抗锯齿纹理查找"></a>Antialiasing Texture Lookups 抗锯齿纹理查找</h2><p><strong>纹理映射的第二个基本问题是抗锯齿。渲染纹理映射图像是一个采样过程:将纹理映射到表面，然后将表面投影到图像中，生成一个跨图像平面的2D函数，我们以像素对其进行采样。正如我们在第9章中所看到的，当图像包含细节或尖锐的边缘时，使用点样本将产生走样伪影——由于纹理的全部要点就是引入细节，它们成为走样问题的主要来源。</strong></p>
<p><strong>就像线或三角形的抗锯齿光栅化、抗锯齿射线追踪(第13.4节)或向下采样图像(第9.4节)一样，解决方案是使每个像素不是点样本，而是图像的面积平均值，面积大小与像素相似。使用相同的超级采样方法用于平滑光栅化和光线跟踪,有足够的样本,可以获得优秀的结果没有改变纹理映射机械:许多样本像素的区域内将土地在纹理映射不同的地方,和着色的平均值结果计算一个准确的方法是使用不同的纹理查找的平均颜色近似的图像像素。然而，使用详细的纹理需要很多样本才能得到好的结果，这是缓慢的。在表面纹理存在的情况下，有效地计算这一面积平均值是纹理抗锯齿的第一个关键问题。</strong></p>
<p><strong>纹理图像通常由光栅图像定义，因此也需要考虑重构问题，就像上采样图像一样(章节9.4)。纹理的解决方案是一样的:使用一个重建过滤器来插值像素。</strong></p>
<p><strong>我们将在以下各节中详细讨论这些主题。</strong></p>
<h3 id="The-Footprint-of-a-Pixel-像素占用空间"><a href="#The-Footprint-of-a-Pixel-像素占用空间" class="headerlink" title="The Footprint of a Pixel 像素占用空间"></a>The Footprint of a Pixel 像素占用空间</h3><p><strong>使抗锯齿纹理比其他类型的抗锯齿更复杂的是，渲染图像和纹理之间的关系是不断变化的。每个像素值都应该作为图像中属于该像素的区域的平均颜色进行计算，在通常情况下，该像素正在查看单个表面，这相当于对表面上的一个区域进行平均。如果表面颜色来自纹理，那么这就相当于对纹理的相应部分进行平均，即像素的纹理空间足迹。下图展示了正方形区域(在低分辨率图像中可能是像素区域)的足迹如何映射到地板纹理空间中大小和形状非常不同的区域。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930135235.png" class="" title="image-20210930135235">

<p>图像中相同大小的正方形区域纹理空间中的足迹大小和形状在整个图像中都不同。</p>
<p><strong>回想一下使用纹理进行渲染所涉及的三个空间:将3D点映射到图像的投影π和将3D点映射到纹理空间的纹理坐标函数φ。为了处理像素足迹，我们需要理解这两种映射的组成:首先跟踪π以从图像到表面，然后跟踪φ前进。ψ = φ◦π^−1构成决定了像素足迹:一个像素的足迹是该像素在ψ映射下的图像的正方形区域的图像。</strong></p>
<p><strong>纹理反走样的核心问题是计算纹理在像素占用面积上的平均值。要准确地做到这一点通常可能是一项相当复杂的工作:对于具有复杂表面形状的遥远物体，足迹可能是一个复杂的形状，覆盖了纹理空间中的大片区域，或者可能是几个不相连的区域。但在典型情况下，一个像素落在表面的光滑区域，该区域被映射到纹理中的单个区域。</strong></p>
<p><strong>由于ψ同时包含从图像到表面的映射和从表面到纹理的映射，所以占地面积的大小和形状取决于观看情况和纹理坐标函数。当表面距离相机越近，像素足迹越小;当同一表面移动得更远时，足迹就会变大。当以斜角观看表面时，表面上的像素足迹被拉长，这通常意味着它在纹理空间中也会被拉长。即使是在一个固定的视图中，纹理坐标功能也可以导致足迹的变化:如果它扭曲了区域，足迹的大小将会变化，如果它扭曲了形状，它们可以被拉长，甚至在正面的表面视图中。</strong></p>
<p><strong>然而，为了找到一个有效的算法计算抗锯齿查找，将需要一些大量的近似。当函数是平滑的，线性近似通常是有用的。在纹理反走样的情况下，这意味着将ψ从图像空间到纹理空间的映射近似为从2D到2D的线性映射:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930135422.png" class="" title="image-20210930135422">

<p><strong>其中2 × 2矩阵J是ψ导函数的近似。它有四个分量，如果我们将图像空间位置表示为x = (x, y)，纹理空间位置表示为u = (u, v)，那么</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930135434.png" class="" title="image-20210930135434">

<p><strong>当我们改变x和y时，四个导数描述了纹理点(u, v)在图像中的一点(x, y)上的变化。</strong></p>
<p><strong>这种近似的几何解释是，图像中以x为中心的单位大小的正方形像素区域将近似映射到纹理空间中以ψ(x)为中心的平行四边形，其边缘平行于向量</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930135614.png" class="" title="image-20210930135614">

<p><strong>导数矩阵J是有用的，因为它讲述了整个图像(近似的)纹理空间足迹的变化故事。较大的导数表示较大的纹理空间足迹，以及导数向量ux 和uy 之间的关系表示的形状。当他们是正交的，长度相同，足迹是正方形的，当它们变得歪斜和/或在长度上非常不同，足迹变得拉长。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930140210.png" class="" title="image-20210930140210">

<p>近似纹理空间占用的像素可以通过映射的导数(x, y) (u, v)。偏导数对x和y是平行于x和y等值线的图像(法蓝)和跨越一个近似平行四边形(橙色阴影)的弯曲形状的足迹(黑色)中概述。</p>
<p><strong>现在我们已经得到了通常被认为是“正确答案”的问题的形式:在特定图像空间位置的过滤纹理样本应该是纹理贴图在该点纹理坐标导数定义的平行四边形足迹上的平均值。这已经包含了一些假设——即，从图像到纹理的映射是平滑的——但对于优秀的图像质量来说，它是足够精确的。然而，这个平行四边形的面积平均值已经太昂贵，无法精确计算，所以使用了各种各样的近似。纹理反锯齿的方法在速度/质量上的权衡是不同的，它们在近似这个查找时做出了不同的选择。我们将在下面几节中讨论这些问题。</strong></p>
<h3 id="Reconstruction-重建"><a href="#Reconstruction-重建" class="headerlink" title="Reconstruction 重建"></a>Reconstruction 重建</h3><p><strong>当足迹小于一个texel时，我们将纹理映射到图像中。这种情况类似于对图像进行上采样，主要考虑的是在像素之间进行插值，以产生一个像素网格不明显的平滑图像。就像在图像上采样，平滑过程是由一个重建滤波器定义的，用于计算纹理空间中任意位置的纹理样本。(参见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930140445.png" class="" title="image-20210930140445">

<p>纹理过滤的主要问题随足迹大小而变化。对于小的足迹(左)，需要插值像素之间，以避免块状的伪影;对于大的足迹，挑战是有效地找到许多像素的平均值。</p>
<p><strong>这些考虑事项与图像重采样基本相同，但有一个重要的区别。在图像重采样中，任务是在规则网格上计算输出样本，而这种规则性使可分离重构滤波器的重要优化成为可能。在纹理过滤中，查找的模式不规律，需要单独计算样本。这意味着大的，高质量的重建过滤器是非常昂贵的使用，由于这个原因，最高质量的过滤器通常用于纹理是双线性插值。</strong></p>
<p><strong>双线性插值纹理样本的计算相当于用双线性插值计算上采样图像中的一个像素。首先，我们用(实值)texel坐标表示纹理空间样本点，然后读取四个相邻texel的值并将其平均。纹理通常在单位平方上参数化，texels的定位方式与任何图像中的像素相同，间隔距离为1/nu 在u方向和1/nv在v方向，用texel(0,0)从边缘定位半个texel用于对称。(详见第9章。)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930140701.png" class="" title="image-20210930140701">

<p><strong>在许多系统中，这个操作成为一个重要的性能瓶颈，主要是因为从纹理数据中获取四个texel值所涉及的内存延迟。纹理的采样点模式是不规则的，因为从图像到纹理空间的映射是任意的，但通常是连贯的，因为附近的图像点倾向于映射到可能读取相同像素的附近纹理点。因此，高性能系统有专门用于纹理采样的特殊硬件，用于处理插值和管理最近使用的纹理数据的缓存，以最小化从存储纹理数据的内存中获取缓慢数据的数量。</strong></p>
<p><strong>读完第9章后，你可能会抱怨线性插值对于某些苛刻的应用来说可能不是一个足够平滑的重建。然而，通过使用更好的过滤器将纹理重新采样到更高的分辨率，这样纹理就足够光滑，双线性插值也能很好地工作。</strong></p>
<h3 id="Mipmapping-映射"><a href="#Mipmapping-映射" class="headerlink" title="Mipmapping 映射"></a>Mipmapping 映射</h3><p><strong>做一个好的内插工作只满足于纹理被放大的情况:与texels的间距相比，像素占用很小。当一个像素覆盖许多像素时，良好的抗走样需要计算许多像素的平均值来平滑信号，以便安全采样。</strong></p>
<p><strong>一个非常精确的计算足迹上的平均纹理值的方法是找到足迹内的所有像素，并将它们相加。然而，当内存占用很大时，这可能会非常昂贵——仅一次查找就需要读取数千texel。一个更好的方法是预计算和存储不同大小和位置的不同区域纹理的平均值。</strong></p>
<p><strong>这个想法的一个非常流行的版本被称为“MIP映射”或仅仅是MIP映射。一个mipmap是一个纹理序列，所有纹理都包含相同的图像，但分辨率越来越低。原始的全分辨率纹理图像被称为mipmap的基础级别，或级别0，而级别1是通过获取该图像并在每个维度上对其进行因子2的向下采样而生成的，结果是图像有四分之一的像素。这个图像中的像素，粗略地说，是0级图像中2 × 2像素大小的正方形区域的平均值。</strong></p>
<p><em><em>这个过程可以继续定义任意多的mipmap级别:通过将k - 1级别的图像向下采样2，来计算k级别的图像。k级的像素对应一个面积为2的正方形</em>k* 2*k</em> 原始纹理中的Texels。例如，从1024 × 1024的纹理图像开始，我们可以生成一个包含11个级别的mipmap:级别0是1024 × 1024;第1级是512 × 512，如此类推，直到第10级，它只有一个像素。这种以一系列越来越低的采样率表示相同内容的图像结构被称为图像金字塔，它是基于将所有较小的图像堆叠在原始图像之上的视觉隐喻。**</p>
<h3 id="Basic-Texture-Filtering-with-Mipmaps-Mipmaps纹理过滤"><a href="#Basic-Texture-Filtering-with-Mipmaps-Mipmaps纹理过滤" class="headerlink" title="Basic Texture Filtering with Mipmaps Mipmaps纹理过滤"></a>Basic Texture Filtering with Mipmaps Mipmaps纹理过滤</h3><p><strong>有了mipmap或图像金字塔在手，纹理过滤可以比单独访问多个像素更有效地完成。当我们需要一个大面积的平均纹理值时，我们只需使用mipmap的更高级别的值，这些值已经是大面积图像的平均值了。最简单和最快的方法是从mipmap中查找单个值，选择关卡，使该关卡的像素所覆盖的大小与像素足迹的总体大小大致相同。当然，像素占用可能会在形状上与texel所代表的(总是正方形)区域有很大的不同，我们可以预期这会产生一些伪影。</strong></p>
<p><strong>暂且不考虑当像素足迹有一个细长形状时该怎么办的问题，假设足迹是宽度D的正方形，以全分辨率纹理中的像素度量。什么级别的mipmap适合采样?因为k级的像素覆盖宽度为2k的正方形，所以选择k似乎是合适的</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141221.png" class="" title="image-20210930141221">

<p><strong>让k = log₂D.当然，这在大多数情况下会给出k的非整数值，而且我们只存储了整数级别的mipmap图像。两种可能的解决方案是只查找最接近k的整数的值(有效，但在层之间的突变处会产生接缝)或查找最接近k的两个整数的值，然后线性插值这些值(工作量翻倍，但更平滑)。</strong></p>
<p><strong>在我们真正写下采样mipmap的算法之前，我们必须决定当脚印不是正方形时，我们将如何选择“宽度”D。一些可能的方法是使用面积的平方根，或者找到足迹的最长轴并将其称为宽度。一个很容易计算的实用折中方法是使用最长边的长度:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141235.png" class="" title="image-20210930141235">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141249.png" class="" title="image-20210930141249">

<p><strong>基本的mipmapping在消除走样方面做得很好，但因为它无法处理拉长的或各向异性的像素足迹，所以当以掠角观看表面时，它的表现就不太好。这是最常见的在大平面上，代表一个表面的观众是站在。地面上远处的点以非常陡峭的角度观看，导致非常各向异性的脚印，mipmapping近似于更大的正方形区域。由此产生的图像在水平方向上会出现模糊。</strong></p>
<h3 id="Anisotropic-Filtering-各向异性过滤"><a href="#Anisotropic-Filtering-各向异性过滤" class="headerlink" title="Anisotropic Filtering 各向异性过滤"></a>Anisotropic Filtering 各向异性过滤</h3><p><strong>一个mipmap可以与多个查找一起使用，以更好地近似一个延长的内存占用。其思想是根据内存占用的最短轴而不是最大轴来选择mipmap级别，然后将沿着长轴间隔的几个查找相加平均。(参见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141457.png" class="" title="image-20210930141457">

<p>抗锯齿的结果具有挑战性的测试场景(参考图像显示详细的结构，在左边)使用三种不同的策略:简单地采用最近邻插值单点样本;使用mipmap金字塔平均纹理中的每个像素的正方形区域;使用来自mipmap的几个样本来平均纹理中的各向异性区域。</p>
<h2 id="Applications-of-Texture-Mapping-纹理映射的应用"><a href="#Applications-of-Texture-Mapping-纹理映射的应用" class="headerlink" title="Applications of Texture Mapping 纹理映射的应用"></a>Applications of Texture Mapping 纹理映射的应用</h2><p><strong>一旦理解了为曲面定义纹理坐标的概念和查找纹理值的机制，这种机制就有很多用途。在本节中，我们将介绍纹理映射中的一些最重要的技术，但纹理是一种非常通用的工具，其应用仅限于程序员的想象。</strong></p>
<h3 id="Controlling-Shading-Parameters-控制着色参数"><a href="#Controlling-Shading-Parameters-控制着色参数" class="headerlink" title="Controlling Shading Parameters 控制着色参数"></a>Controlling Shading Parameters 控制着色参数</h3><p><strong>纹理映射最基本的用途是通过在着色计算中使用漫反射颜色来引入颜色的变化——无论是在光线追踪器中还是在碎片着色器中——依赖于从纹理中查找的值。一个纹理漫反射组件可以用来粘贴贴花，油漆装饰，或在表面上打印文本，它也可以模拟材料颜色的变化，例如木材或石头。</strong></p>
<p><strong>没有什么能限制我们改变，只有漫反射的颜色。任何其他参数，如镜面反射或镜面粗糙度，也可以被纹理化。例如，一个用透明胶带粘上的纸箱，可能到处都有相同的漫反射颜色，但更有光泽，镜面反射率更高在胶带所在的地方，粗糙度比其他地方要低。在许多情况下不同参数相关的地图:例如,一个光滑的白色陶瓷杯标志印在它可能是粗糙和暗印(下图),和一本书的标题印在金属油墨可能会改变在漫射颜色,镜面的颜色,和粗糙度。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930141746.png" class="" title="image-20210930141746">

<p>一个镜面粗糙度的陶瓷杯子，由漫反射颜色纹理的反向拷贝控制。</p>
<h3 id="Normal-Maps-and-Bump-Maps-法线贴图和凹凸贴图"><a href="#Normal-Maps-and-Bump-Maps-法线贴图和凹凸贴图" class="headerlink" title="Normal Maps and Bump Maps 法线贴图和凹凸贴图"></a>Normal Maps and Bump Maps 法线贴图和凹凸贴图</h3><p><strong>另一个对着色很重要的量是表面法线。通过插值法线(第8.2节)，我们知道着色法线不必与底面的几何法线相同。法线贴图利用了这一点，使着色法线依赖于从纹理贴图读取的值。最简单的方法就是在纹理中存储法线，在每个被解释的像素中存储三个数字，而不是作为颜色的三个组成部分，而是作为法向量的3D坐标。</strong></p>
<p><strong>但是，在使用法线映射之前，我们需要知道从映射中读取的法线在哪个坐标系中表示。法线直接存储在对象空间,在同一坐标系中用于代表表面几何本身是简单的:正常读取地图可用于完全由表面本身一样正常的报道:在大多数情况下,它将需要转换成世界空间照明计算,就像一个法线,几何。</strong></p>
<p><strong>然而，存储在对象空间中的法线贴图本质上与表面几何绑定在一起，即使法线贴图没有效果，要用几何法线再现结果，法线贴图的内容也必须跟踪表面的方向。此外，如果表面要变形，因此几何法线改变，对象空间法线贴图不能再使用，因为它将继续提供相同的着色法线。</strong></p>
<p><strong>解决方法是为附在曲面上的法线定义一个坐标系统。这种坐标系可以根据曲面的切空间来定义(见2.5节):选择一对切向量，用它们来定义一组标准正交基(见2.4.5节)。纹理坐标函数本身提供了一个有用的方法来选择一双切线向量:使用u和v的等值线切线方向这些切线不是一般正交的,但我们可以用程序2.4.7“广场”的标准正交基,或者它可以定义使用曲面法线和一个切向量。</strong></p>
<p><strong>当法线在这种基础上表示时，它们的变化要小得多;因为它们大多指向平滑表面的法线方向，所以它们将靠近法线贴图中的向量(0,0,1)^T。</strong></p>
<p><strong>法线贴图从何而来?它们通常是从一个更详细的模型中计算出来的，平滑表面只是一个近似;其他时候，它们可以直接从实际表面测量。它们也可以作为建模过程的一部分进行编写;在这种情况下，通常使用凹凸贴图来间接指定法线。这个想法是凹凸贴图是一个高度场:一个给出光滑表面上的细节表面的局部高度的函数。当数值高的地方(当地图看起来很亮的地方，如果你以图像的形式显示它)，表面就会突出到光滑表面的外面;在数值较低的地方(地图看起来很暗的地方)，表面在它下面后退。例如，凹凸贴图中狭窄的黑线是划痕，或者小白点是凹凸。</strong></p>
<p><strong>从凹凸贴图推导法线贴图很简单:法线贴图(在切线框架中表示)是凹凸贴图的导数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930142138.png" class="" title="image-20210930142138">

<p>一个木质地板渲染使用纹理贴图来控制阴影。(a)只有漫反射颜色是由纹理贴图调制的。(b)镜面粗糙度也由第二个纹理贴图调制。(c)表面法线被凹凸贴图修改。</p>
<p><strong>上图显示了纹理贴图被用来创建木纹颜色和模拟增加的表面粗糙度，由于表面浸透到木材更多的多孔部分，以及凹凸贴图创建一个不完美的表面和木板之间的间隙，以制作一个真实的木地板。</strong></p>
<h3 id="Displacement-Maps-置换贴图"><a href="#Displacement-Maps-置换贴图" class="headerlink" title="Displacement Maps 置换贴图"></a>Displacement Maps 置换贴图</h3><p><strong>法线贴图的一个问题是，它们实际上根本不会改变表面;它们只是一个着色技巧。当法线贴图暗示的几何图形在3D中产生明显的效果时，这就变得很明显了。在静态图像中，首先要注意的问题通常是物体的轮廓保持平滑，尽管在内部出现了凸起。在动画中，由于缺乏视差，这些凸起实际上只是“绘制”在表面上。</strong></p>
<p><strong>纹理可以用于不仅仅是着色，尽管:他们可以用来改变几何。置换贴图是这个想法最简单的版本之一。这个概念和凹凸贴图是一样的:一个标量(单通道)贴图，给出了高于“平均地形”的高度。但效果是不同的。置换贴图实际上改变了表面，沿着光滑表面的法线移动每个点到一个新的位置。法线在每种情况下大致相同，但表面是不同的。</strong></p>
<p><strong>最常用的实现置换贴图的方法是用大量的小三角形对光滑的表面进行镶嵌，然后使用置换贴图对生成网格的顶点进行置换。在图形管线中，这可以在顶点阶段使用纹理查找来完成，这对于地形特别方便。</strong></p>
<h3 id="Shadow-Maps-阴影贴图"><a href="#Shadow-Maps-阴影贴图" class="headerlink" title="Shadow Maps 阴影贴图"></a>Shadow Maps 阴影贴图</h3><p><strong>阴影是场景中物体关系的重要线索，正如我们所看到的，它们很容易包含在光线追踪的图像中。然而，在光栅化渲染中如何获得阴影并不明显，因为表面每次都是单独考虑的。阴影贴图是一种利用纹理映射机制从点光源获得阴影的技术。</strong></p>
<p><strong>阴影贴图的概念是表示由点光源照亮的空间体积。想想像聚光灯或视频投影仪这样的光源，它们从一个点向一个有限范围的方向发射光线。被照亮的体积——如果你把手放在那里，你就能看到光线的点集——是线段的联合，沿着离开那个点的每一条光线，将光源连接到最近的表面点。</strong></p>
<p><strong>有趣的是，这个体积与位于光源同一点的透视相机可见的体积相同:当且仅当从光源位置可见时，一个点被光源照亮。在这两个在这种情况下，我们需要评估场景中的点的可见度:对于可见度，我们需要知道一个片段是否对摄像机可见，是否要在图像中绘制它;对于阴影，我们需要知道一个碎片是否对光源可见，以知道它是否被光源照亮。(参见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930142458.png" class="" title="image-20210930142458">

<p>顶部:由点光源照亮的空间区域。下:那个区域用10像素宽的阴影图来近似。</p>
<p><strong>在这两种情况下，解决方案是一样的:一个深度地图，告诉距离最近的表面沿着一束射线。在可见情况下，这是z缓冲区(章节8.2.3)，对于阴影情况，它被称为阴影映射。在这两种情况下，可见性是通过比较一个新碎片的深度和存储在地图中的深度来评估的，如果表面的深度大于最近的可见表面的深度，那么它将从投影点隐藏(着色或阴影)。不同之处在于，z缓冲区用于跟踪到目前为止看到的最近的表面，并在渲染过程中更新，而阴影贴图告诉整个场景中到最近表面的距离。</strong></p>
<p><strong>阴影贴图是在单独的渲染通道中提前计算的:像往常一样简单地栅格化整个场景，并保留得到的深度贴图(不需要计算像素值)。手里拿着阴影映射,您执行一个普通的渲染,而当你需要知道源片段是可见的,您的项目的位置阴影地图(使用相同的透视投影用于渲染阴影映射首先)和比较查找值dmap 实际距离d到源。如果距离相同，碎片的点就会被照亮;如果d &gt; dmap，这意味着有一个不同的表面更接近光源，所以它是阴影。</strong></p>
<p><strong>“如果距离是相同的”这句话应该在你的脑海中引起一些危险信号:因为所有涉及的数量都是有限精度的近似，我们不能期望它们完全相同。对于可见点，d≈dmap 但有时d会大一点，有时小一点。因此，需要一个公差:如果d - dmap &lt; E，则认为一个点是亮的。这种容忍被称为“阴影偏差”。</strong></p>
<p><strong>当在阴影贴图中查找时，在地图中记录的深度值之间插入并不是很有意义。这可能会在平滑区域产生更精确的深度(需要更少的阴影偏差)，但会在阴影边界附近造成更大的问题，在那里深度值会突然改变。因此，阴影贴图中的纹理查找是使用最近邻重建来完成的。为了减少走样，可以使用多个样本，平均1或0的阴影结果(而不是深度);这被称为百分比更接近过滤。</strong></p>
<h3 id="Environment-Maps-环境贴图"><a href="#Environment-Maps-环境贴图" class="headerlink" title="Environment Maps 环境贴图"></a>Environment Maps 环境贴图</h3><p><strong>正如纹理可以方便地将细节引入到表面的着色中，而不必为模型添加更多的细节，纹理也可以用于将细节引入到照明中，而无需建模复杂的光源几何。当光线来自与视野中物体大小相比较的远处时，场景中点对点的照明变化很小。假设光照只依赖于你观察的方向，并且场景中所有点的光照都是相同的，然后使用环境地图来表示光照对方向的依赖是很方便的。</strong></p>
<p><strong>环境地图的理念是，在3D方向上定义的函数是单位球体上的函数，所以它可以使用纹理贴图来表示，就像我们在球形物体上表示颜色变化一样。我们没有使用曲面点的三维坐标来计算纹理坐标，而是使用完全相同的公式来计算单位向量的三维坐标，单位向量表示我们想要知道的光照方向。</strong></p>
<p><strong>环境地图最简单的应用是在光线追踪器中给不击中任何物体的光线着色:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930142925.png" class="" title="image-20210930142925">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930142942.png" class="" title="image-20210930142942">

<p><strong>随着光线追踪器的改变，反射其他场景物体的发光物体现在也会反射背景环境。</strong></p>
<p><strong>在光栅化上下文中也可以通过在着色计算中添加镜面反射来达到类似的效果，其计算方法与在光线追踪器中相同，但只需直接在环境地图中查找，而不考虑场景中的其他物体:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930143035.png" class="" title="image-20210930143035">

<p><strong>这种技术被称为反射映射。</strong></p>
<p><strong>环境贴图的一个更高级的应用是从环境地图中计算所有的照明，而不仅仅是镜面反射。这是环境照明，可以用Monte Carlo积分在光线追踪器中计算，也可以用点源集合来近似环境并计算许多阴影图来进行光栅化。</strong></p>
<p><strong>环境映射可以存储在任何坐标中，这些坐标可以用于映射球体。球面(经纬度)坐标是一种流行的选择，尽管在极点压缩纹理会浪费纹理分辨率，并且会在极点创建伪影。Cubemaps是一种更有效的选择，广泛用于交互式应用程序(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20210930143203.png" class="" title="image-20210930143203">

<p>圣彼得大教堂的立方体地图，六个面存储在图像上的展开的“水平十字”安排。(材质:埃米尔佩尔森)</p>
<h2 id="Procedural-3D-Textures-程序3D纹理"><a href="#Procedural-3D-Textures-程序3D纹理" class="headerlink" title="Procedural 3D Textures 程序3D纹理"></a>Procedural 3D Textures 程序3D纹理</h2><p><strong>在前面的章节中，我们使用了cr 即物体上一点的漫反射。对于一个没有纯色的对象，我们可以用函数cr(p)来替换它将3D点映射为RGB颜色(Peachey, 1985;佩林,1985)。这个函数可能只是返回包含p的对象的反射。但是对于带有纹理的对象，我们应该期望cr(p)随着p在表面上的移动而变化。</strong></p>
<p><strong>定义从3D表面映射到2D纹理域的纹理映射函数的另一种选择是创建一个3D纹理，定义的RGB值为在三维空间中的每个点。我们只对曲面上的点p调用它，但通常为所有3D点定义它比为任意曲面上可能奇怪的2D点子集更容易。3D纹理映射的好处是映射函数的定义很容易，因为曲面已经嵌入到3D空间中，从3D到纹理空间的映射没有失真。这种策略显然适用于由固体介质“雕刻”而成的表面，例如大理石雕塑。</strong></p>
<p><strong>3D纹理的缺点是将它们存储为3D光栅图像或体积会消耗大量内存。由于这个原因，三维纹理坐标最常用于程序纹理，其中纹理值是使用数学程序计算的，而不是通过从纹理图像中查找它们。在本节中，我们将介绍一些用于定义程序纹理的基本工具。这些也可以用于定义2D程序纹理，尽管在2D中更常见的是使用光栅纹理图像。</strong></p>
<h3 id="3D-Stripe-Textures-3D条纹纹理"><a href="#3D-Stripe-Textures-3D条纹纹理" class="headerlink" title="3D Stripe Textures 3D条纹纹理"></a>3D Stripe Textures 3D条纹纹理</h3><p><strong>制作条纹纹理的方法多得惊人。假设有两种颜色c0 和c1 我们想用它来制作条纹颜色。我们需要一些振荡函数在两种颜色之间切换。一个简单的是sin:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102252.png" class="" title="image-20211001102252">

<p><strong>我们还可以使条纹的宽度w可控:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102307.png" class="" title="image-20211001102307">

<p><strong>如果我们想在条纹颜色之间进行平滑插值，我们可以使用参数t来线性改变颜色:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102319.png" class="" title="image-20211001102319">

<p><strong>下图显示了这三种可能性。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102351.png" class="" title="image-20211001102351">

<p>不同的条纹纹理是在保持z不变的情况下绘制xy点的规则数组的结果。</p>
<h3 id="Solid-Noise-固体噪波"><a href="#Solid-Noise-固体噪波" class="headerlink" title="Solid Noise 固体噪波"></a>Solid Noise 固体噪波</h3><p><strong>虽然常规纹理如条纹通常是有用的，但我们希望能够制作“斑纹”纹理，如我们在鸟蛋上看到的。这通常是通过使用一种“固体噪波”来实现的，通常以它的发明者柏林噪音的名字命名，柏林噪音因其对电影工业的影响而获得了学院奖(1985)。</strong></p>
<p><strong>通过为每个点调用一个随机数来得到一个嘈杂的外观是不合适的，因为它就像电视静态中的“白噪音”。我们希望在不丢失随机质量的前提下使它更平滑。一种可能是模糊白噪声，但没有实际的实施。另一种可能是在每个点上都有一个随机数的大晶格，然后将这些随机点插值到晶格节点之间的新点上;这只是一个3D纹理数组，就像上一节描述的那样，数组中有随机数。这种技术使晶格过于明显。Perlin使用了各种技巧来改进这个基本的点阵技术，所以点阵不是那么明显。这就产生了一组巴洛克式的步骤，但本质上只是从线性插值一个随机值的3D数组的三个变化。第一个改变是使用埃尔米特插值来避免马赫带，就像可以用常规纹理做的那样。第二个变化是使用随机向量而不是数值，用点积来推导一个随机数;通过移动网格顶点的局部极小值和极大值，使得底层网格结构在视觉上不那么明显。第三个变化是使用一维数组和散列来创建一个随机向量的虚拟3D数组。这增加了计算以降低内存使用。以下是他的基本方法:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102825.png" class="" title="image-20211001102825">

<p><strong>其中(x, y, z)是x的笛卡尔坐标</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102836.png" class="" title="image-20211001102836">

<p><strong>ω(t)为三次权重函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102854.png" class="" title="image-20211001102854">

<p><strong>最后一个是Γijk 是晶格点(x, y, z) = (i, j, k)的随机单位向量。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001102906.png" class="" title="image-20211001102906">

<p><strong>其中G是一个由n个随机单位向量组成的预计算数组，φ(i) = P[i mod n]其中P是一个长度为n的数组，包含从0到n−1的整数排列。在实践中，Perlin报告说n = 256的效果很好。随机选择一个单位向量(vx, vy, vz)第一组</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103000.png" class="" title="image-20211001103000">

<p><strong>ξ,ξ′,ξ″为标准随机数(在区间[0,1]内均匀)。然后,如果(vx² + vy² + vz²) &lt; 1，使向量为单位向量。否则，继续随机设置它，直到它的长度小于1，然后使它成为一个单位向量。这是一个拒绝方法的例子，将在第14章中进一步讨论。从本质上说，“小于”测试在单位球中得到一个随机点，而原点到该点的矢量是均匀随机的。对于立方体中的随机点，这是不成立的，所以我们在测试中“去掉”了棱角。</strong></p>
<p><strong>因为固体噪声可以是正的，也可以是负的，所以在转换为颜色之前必须先进行转换。下图显示了10 × 10平方上的噪声绝对值，以及拉伸后的版本。这些版本是通过缩放噪声函数的输入点来拉伸的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103217.png" class="" title="image-20211001103217">

<p>固体噪声的绝对值，以及缩放后的x和y值的噪声。</p>
<p><strong>暗曲线是原始噪声函数由正变为负的地方。由于噪声从−1到1不等，使用(噪声+1)/2的颜色可以实现更平滑的图像。然而，由于噪声值接近1或−1是罕见的，这将是一个相当平滑的图像。更大的缩放可以增加对比度(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103304.png" class="" title="image-20211001103304">

<p>上：使用 0.5(noise+1) 强度，下：使用 0.8(noise+1) 强度。</p>
<h3 id="Turbulence-湍流"><a href="#Turbulence-湍流" class="headerlink" title="Turbulence 湍流"></a>Turbulence 湍流</h3><p><strong>许多自然纹理在同一纹理中包含不同的特征尺寸。Perlin使用伪分形“湍流”函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103732.png" class="" title="image-20211001103732">

<p><strong>如下图所示，这有效地重复添加了噪声函数的放大副本。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103756.png" class="" title="image-20211001103756">

<p>湍流函数具有(从左上到右下)1到8项求和。</p>
<p><strong>湍流可以用来扭曲条纹函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103743.png" class="" title="image-20211001103743">

<p><strong>k的不同值1 和k2 用于生成下图。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001103809.png" class="" title="image-20211001103809">

<p>不同k的湍流条纹结构1 <em>k</em>2．第一行只有湍流级数的第一项。</p>
<h1 id="12-Data-Structures-for-Graphics-图形的数据结构"><a href="#12-Data-Structures-for-Graphics-图形的数据结构" class="headerlink" title="12 Data Structures for Graphics 图形的数据结构"></a>12 Data Structures for Graphics 图形的数据结构</h1><p><strong>某些数据结构似乎在图形应用程序中反复出现，可能是因为它们解决了表面、空间和场景结构等基本的底层概念。本章讨论了一些最常见和最有用的基本和不相关的数据结构类别:网格结构、空间数据结构、场景图和平铺多维数组。</strong></p>
<p><strong>对于网格，我们讨论了用于存储静态网格和将网格传输到图形api的基本存储方案。我们还讨论了翼边数据结构(Baumgart, 1974)和相关的半边结构，这对管理镶嵌变化的模型很有用，如细分或模型简化。虽然这些方法推广到任意多边形网格，但我们在这里只关注简单的三角形网格。</strong></p>
<p><strong>然后给出了场景图数据结构。这种数据结构的各种形式在图形应用程序中无处不在，因为它们在管理对象和转换方面非常有用。所有新的图形api都是为了支持场景图形而设计的。</strong></p>
<p><strong>对于空间数据结构，我们讨论了在三维空间边界体层次结构、层次空间细分和统一空间细分中组织模型的三种方法，以及使用层次空间细分(BSP树)来去除隐藏表面。同样的方法也用于其他目的，包括几何剔除和碰撞检测。</strong></p>
<p><strong>最后，提出了平铺多维数组。这种结构最初是为了在需要从磁盘交换图形数据的应用程序中提高分页性能而开发的，但现在对于机器上的内存局部来说，不管数组是否适合主内存，这种结构都是至关重要的。</strong></p>
<h2 id="Triangle-Meshes-三角形网格"><a href="#Triangle-Meshes-三角形网格" class="headerlink" title="Triangle Meshes 三角形网格"></a>Triangle Meshes 三角形网格</h2><p><strong>大多数真实世界的模型都是由具有共享顶点的三角形组成的综合体。这些通常被称为三角形网格、三角形网格或三角形不规则网络(TINs)，有效地处理它们对许多图形程序的性能至关重要。重要的效率取决于应用程序。网格存储在磁盘和内存中，我们希望最小化所消耗的存储量。当网格跨网络传输或从CPU传输到图形系统时，它们会消耗带宽，这通常比存储更宝贵。在对网格执行操作的应用程序中，除了简单地存储和绘制它们之外(如细分、网格编辑、网格压缩或其他操作)，高效地访问邻接信息是至关重要的。</strong></p>
<p><strong>三角形网格通常用来表示曲面，所以网格不仅仅是不相关的三角形的集合，而是通过共享顶点和边相互连接的三角形网络，形成一个连续的曲面。这是一个关于网格的关键洞见:一个网格可以比一个相同数量的不相关三角形的集合更有效地处理。</strong></p>
<p><strong>三角形网格所需的最小信息是一组三角形(顶点的三组)及其顶点在三维空间中的位置。但是，许多(如果不是大多数的话)程序需要在顶点、边或面存储额外数据的能力，以支持纹理映射、着色、动画和其他操作。顶点数据是最常见的:每个顶点都可以有材质参数、纹理坐标、辐照度——任何值在表面上发生变化的参数。然后，这些参数在每个三角形上进行线性插值，从而在整个网格表面上定义一个连续的函数。然而，能够存储每个边或每个面的数据有时也很重要。</strong></p>
<h3 id="Mesh-Topology-网格拓扑"><a href="#Mesh-Topology-网格拓扑" class="headerlink" title="Mesh Topology 网格拓扑"></a>Mesh Topology 网格拓扑</h3><p><strong>网格类曲面的概念可以形式化为网格拓扑的约束——不考虑顶点位置的三角形连接方式。许多算法只能在具有可预测连接性的网格上工作，或者更容易实现。网格拓扑最简单和最严格的要求是表面是一个流形。流形网格是“水密”的——它没有缝隙，将表面内部的空间与外部的空间分隔开来。它看起来也像网格上的每个表面。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001104828.png" class="" title="image-20211001104828">

<p>非流形(左)和流形(右)在克格勃边缘。</p>
<p><strong>术语流形来自于拓扑学的数学领域:粗略地说，一个流形(特别是一个二维流形，或2-流形)是任何一点周围的一个小邻域都可以被平滑成一个平面的表面。这个想法是最清楚地解释为反例:如果一个边缘在一个网有三个三角形连接,点的小区边缘不同于附近的一个点在三角形的内部,因为它有一个额外的“鳍”伸出它(上图)。如果这条边正好有两个三角形连接在上面，那么这条边上的点就像内部的点一样，只是中间有一个折痕。类似地，如果共享一个顶点的三角形处于下图中左侧三角形的构型中，其邻域就像在中心粘在一起的两块表面，如果不将其加倍，就无法将其变平。在右边有简单邻域的顶点就可以了。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001105003.png" class="" title="image-20211001105003">

<p>非流形(左)和流形(右)在克格勃顶点。</p>
<p><strong>许多算法假设网格是流形的，如果输入的是一个畸形的网格，验证这个属性以防止崩溃或无限循环总是一个好主意。这个验证归结为检查所有的边是流形，检查所有的顶点是流形，通过验证以下条件:</strong></p>
<p>​    <strong>每条边正好由两个三角形共享。</strong></p>
<p>​    <strong>每个顶点周围都有一个完整的三角形环。</strong></p>
<p><strong>上上图说明了一条边如何因为有太多三角形而在第一次测试中失败，上图说明了一个顶点如何因为有两个独立的三角形环连接到它而在第二次测试中失败。</strong></p>
<p><strong>流形网格很方便，但有时需要允许网格有边或边界。这样的网格不是流形——边界上的一个点有一个在一边被切断的邻域。它们不一定是无懈可击的。然而，我们可以将流形网格的要求放宽到具有边界的流形，而不会对大多数网格处理算法造成问题。放宽的条件是:</strong></p>
<p>​    <strong>每条边都被一个或两个三角形使用。</strong></p>
<p>​    <strong>每个顶点连接到一个边连通的三角形集合。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001105300.png" class="" title="image-20211001105300">

<p>具有边缘条件的边界。</p>
<p><strong>上图说明了这些条件:从左到右，有一条边有一个三角形，一个顶点的相邻三角形在一个边连接的集合中，一个顶点有两个不相连的三角形集合连接在它上。</strong></p>
<p><strong>最后，在许多应用中，区分一个表面的“正面”或“外部”和“背面”或“内部”是很重要的——这被称为表面的方向。对于单个三角形，我们根据列出顶点的顺序来定义方向:前面是三角形的三个顶点逆时针排列的边。连通网格为一直面向如果它的三角形都同意哪边是正面——当且仅当每一对相邻的三角形都有一致的方向时，这个成立。</strong></p>
<p><strong>在一对一致方向的三角形中，两个共享顶点在两个三角形的顶点列表中以相反的顺序出现(下图)。重要的是方向的一致性——有些系统使用顺时针而不是逆时针来定义正面。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001105532.png" class="" title="image-20211001105532">

<p>三角形(B,A,C)和(D,C,A)是一致的，而(B,A,C)和(A,C,D)是不一致的。</p>
<p><strong>任何具有非流形边缘的网格都不能保持一致的方向。但网格也有可能是一个有效的带有边界的流形(甚至是流形)，但却没有一致的方法来确定三角形的方向——它们不是可定向的表面。如下图所示的M¨obius带就是一个例子。然而，这在实践中很少成为一个问题。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001105637.png" class="" title="image-20211001105637">

<p>一个三角形的M¨obius带，它不是可定向的。</p>
<h3 id="Indexed-Mesh-Storage-索引网格存储"><a href="#Indexed-Mesh-Storage-索引网格存储" class="headerlink" title="Indexed Mesh Storage 索引网格存储"></a>Indexed Mesh Storage 索引网格存储</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110225.png" class="" title="image-20211001110225">

<p>一个有四个顶点的三三角形网格，用分开的三角形(左)和共享的顶点(右)表示。</p>
<p><strong>一个简单的三角形网格如上图所示。你可以将这三个三角形存储为独立的实体，每一个都是这样的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110236.png" class="" title="image-20211001110236">

<p><strong>这将导致顶点b被存储3次，其他顶点各2次，共9个存储点(3个三角形中的每个三角形对应3个顶点)。或者你可以安排共享公共顶点，结果只存储四个在共享顶点网格中。逻辑上，这个数据结构有指向包含顶点数据的顶点的三角形:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110409.png" class="" title="image-20211001110409">

<p><strong>注意，v数组中的条目是指向Vertex对象的引用或指针;顶点不包含在三角形中。</strong></p>
<p><strong>在实现中，顶点和三角形通常存储在数组中，通过存储数组索引来处理三角形到顶点的引用:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110445.png" class="" title="image-20211001110445">

<p><strong>第i个三角形的第k个顶点的索引在tInd[i] [k]中找到，该顶点的位置存储在vertex数组的相应行中;参见下图中的示例。这种存储共享顶点网格的方法是索引三角形网格。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001110541.png" class="" title="image-20211001110541">

<p>一种更大的三角形网格，其部分表示为索引三角形网格。</p>
<p><strong>分开的三角形或共享的顶点都可以很好地工作。共享顶点有空间优势吗?如果我们的网格有nv 顶点和nt 三角形,如果我们假设浮点数、指针和整型数的数据都需要相同的存储空间(一个可疑的假设)，那么对空间的要求如下:</strong></p>
<p>​    <strong>三角形：每个三角形有三个向量，对于9nt 单位的存储;</strong></p>
<p>​    <strong>索引网格：每个顶点有一个向量，每个三角形有三个int值，对应3nv + 3nt 单位的存储。</strong></p>
<p><strong>相对存储要求取决于nt 到nv的比值．</strong></p>
<p><strong>根据经验法则，一个大型网格的每个顶点都与大约6个三角形相连(尽管在极端情况下可以有任意数量的三角形)。由于每个三角形连接三个顶点，这意味着在一个大网格中，三角形的数量通常是顶点的两倍:nt≈2nv．通过这个替换，我们可以得出存储需求是18nv为三角形结构和9nv为索引网格。使用共享顶点可以将存储需求减少大约1/2;这似乎适用于大多数实现。</strong></p>
<h3 id="Triangle-Strips-and-Fans-三角形带和扇"><a href="#Triangle-Strips-and-Fans-三角形带和扇" class="headerlink" title="Triangle Strips and Fans 三角形带和扇"></a>Triangle Strips and Fans 三角形带和扇</h3><p><strong>索引网格是三角形网格最常见的内存表示形式，因为它们在简单性、便捷性和紧凑性之间取得了良好的平衡。它们也通常用于在网络上以及应用程序和图形管道之间传输网格。在需要更紧凑的应用程序中，三角形顶点索引(仅在顶点处占索引网格空间的三分之二)可以使用三角形带和三角形扇形更有效地表示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001115310.png" class="" title="image-20211001115310">

<p><strong>三角形扇形如上图所示。在索引网格中，三角形数组将包含[(0,1,2)，(0,2,3)，(0,3,4)，(0,4,5)]。我们存储了12个顶点索引，尽管只有6个不同的顶点。在三角形扇形中，所有三角形共享一个共同的顶点，其他顶点生成一组三角形，就像可折叠扇形的叶片一样。图中的扇形可以用序列[0,1,2,3,4,5]来指定:第一个顶点建立中心，然后每一对相邻顶点(1-2,2-3等)组成一个三角形。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001115423.png" class="" title="image-20211001115423">

<p><strong>三角形带是一个类似的概念，但它适用于更大范围的网格。在这里，顶点在一个如上图所示的线性条的顶部和底部交替添加。图中的三角形带可以用序列[0 1 2 3 4 5 6 7]指定，三个相邻顶点(0- 1-2、1-2-3等)的子序列创建一个三角形。为了保持一致的方向，每个其他三角形都需要颠倒它的顺序。在这个例子中，结果是三角形(0,1,2)，(2,1,3)，(2,3,4)，(4,3,5)等等。对于每个进入的新顶点，最老的顶点被遗忘，剩下的两个顶点的顺序被交换。参见下图以获得更大的示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001115521.png" class="" title="image-20211001115521">

<p>两个三角形带在一个更大的网格中。请注意，这两个条带都不能扩展为包含用星号标记的三角形。</p>
<p><strong>在条形网格和扇形网格中，n + 2个顶点就足以描述n个三角形，这大大节省了标准索引网格所需的3n个顶点。如果程序是顶点限界的，长三角形带将节省大约三倍的时间。</strong></p>
<p><strong>似乎只有当三角形条很长时三角形条才有用，但即使是相对较短的三角形条也能获得大部分好处。节省的存储空间(仅针对顶点索引)如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001115607.png" class="" title="image-20211001115607">

<p><strong>因此，事实上，随着条带变长，回报会迅速递减。因此，即使对于一个非结构化的网格，也值得使用一些贪婪算法将它们聚集成短条带。</strong></p>
<h3 id="Data-Structures-for-Mesh-Connectivity-用于网格连通性的数据结构"><a href="#Data-Structures-for-Mesh-Connectivity-用于网格连通性的数据结构" class="headerlink" title="Data Structures for Mesh Connectivity 用于网格连通性的数据结构"></a>Data Structures for Mesh Connectivity 用于网格连通性的数据结构</h3><p><strong>索引网格、条形网格和扇形网格都是很好的、紧凑的静态网格表示。然而，它们不容易允许网格被修改。为了有效地编辑网格，需要更复杂的数据结构来有效地回答以下查询:</strong></p>
<p>​    <strong>给定一个三角形，三个相邻的三角形是什么?</strong></p>
<p>​    <strong>给定一条边，哪两个三角形共用一条边?</strong></p>
<p>​    <strong>给定一个顶点，哪些面共享它?</strong></p>
<p>​    <strong>给定一个顶点，哪些边共享它?</strong></p>
<p><strong>对于三角形网格、多边形网格和带孔的多边形网格，有许多数据结构。在许多应用中，网格非常大，因此有效的表示是至关重要的。</strong></p>
<p><strong>最直接(虽然臃肿)的实现是拥有三种类型:顶点、边和三角形，并直接存储所有关系:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125210.png" class="" title="image-20211001125210">

<p><strong>这让我们可以直接查找上述连接问题的答案，但由于这些信息都是相互关联的，因此存储的信息比实际需要的要多。此外，在顶点中存储连接性会产生变长数据结构(因为顶点可以有任意数量的邻居)，这通常是较低效的实现。与其承诺显式地存储所有这些关系，不如定义一个类接口来回答这些问题，这样可以隐藏更有效的数据结构。事实证明，我们只能存储部分连接，并在需要时有效地恢复其他信息。</strong></p>
<p><strong>Edge和Triangle类中的固定大小数组表明，在那里存储连接信息会更有效。事实上，对于多边形网格，多边形的边数和顶点数都是任意的，只有边具有固定大小的连通性信息，这导致许多传统的网格数据结构都是基于边的。但对于只使用三角形的网格，将连接性存储在(数量较少的)面上是很有吸引力的。</strong></p>
<p><strong>一个好的网格数据结构应该是合理紧凑的，并允许对所有邻接查询的有效回答。高效意味着固定的时间:寻找邻居的时间不应依赖于网格的大小。我们将研究网格的三种数据结构，一种基于三角形，两种基于边。</strong></p>
<h4 id="The-Triangle-Neighbor-Structure-三角形邻边结构"><a href="#The-Triangle-Neighbor-Structure-三角形邻边结构" class="headerlink" title="The Triangle-Neighbor Structure 三角形邻边结构"></a>The Triangle-Neighbor Structure 三角形邻边结构</h4><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125607.png" class="" title="image-20211001125607">

<p>三角形中三角形和顶点之间的引用邻边结构。</p>
<p><strong>我们可以创建一个基于三角形的紧凑网格数据结构，方法是使用从三角形到三个相邻三角形的指针，以及从每个顶点到一个相邻三角形的指针(不管是哪个三角形)来增加基本共享顶点网格;见上图:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125704.png" class="" title="image-20211001125704">

<p><strong>在数组Triangle.nbr，第k个入口指向相邻的三角形它共享顶点k和k + 1。我们称这种结构为三角形邻接结构。从标准的索引网格数组开始，它可以通过两个额外的数组来实现:一个存储每个三角形的三个邻居，另一个存储每个顶点的单个邻接三角形(参见下图中的例子):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125716.png" class="" title="image-20211001125716">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125810.png" class="" title="image-20211001125810">

<p>编码在数组中的三角形邻接结构，以及在遍历顶点2的相邻三角形时所遵循的顺序。</p>
<p><strong>显然，三角形的相邻三角形和顶点可以直接在数据结构中找到，但通过仔细使用这个三角形邻接信息，也可以在常数时间内回答关于顶点的连接性查询。这个想法就是从一个三角形移动到另一个三角形，只访问与相关顶点相邻的三角形。如果三角形t的第k个顶点是顶点v，那么三角形t.nbr [k]是沿顺时针方向围绕v的下一个三角形。这种观察结果导致了以下算法遍历所有与给定顶点相邻的三角形:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001125925.png" class="" title="image-20211001125925">

<p><strong>该操作以恒定的时间找到每个后续三角形——尽管需要搜索每个三角形的顶点列表中的中心顶点位置，但顶点列表的大小是恒定的，因此搜索所需的时间是恒定的。然而，这种搜索是笨拙的，需要额外的分支。</strong></p>
<p><strong>一个小的改进可以避免这些搜索。问题是，一旦我们沿着指针从一个三角形到另一个三角形，我们就不知道我们是从哪个方向来的:我们必须搜索三角形的顶点，以找到与前一个三角形相连的顶点。为了解决这个问题，我们不存储相邻三角形的指针，而是通过使用指针存储索引来存储指向这些三角形特定边的指针:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130017.png" class="" title="image-20211001130017">

<p><strong>实际上，Edge是通过从三角形索引t中借用两位存储空间来存储边索引i，因此总存储需求保持不变。</strong></p>
<p><strong>在这种结构中，三角形的邻居数组告诉我们哪些相邻三角形的边与三角形的三条边共享。有了这个额外的信息，我们总是知道在哪里找到原始三角形，这导致了数据结构的不变量:对于任意三角形t的任何第j条边，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130048.png" class="" title="image-20211001130048">

<p><strong>知道我们从哪条边进来，我们就能立即知道要从哪条边出去，以便继续绕着一个顶点走，从而产生一种流线型算法:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130059.png" class="" title="image-20211001130059">

<p><strong>三角形邻接结构非常紧凑。对于只有顶点位置的网格，我们每个顶点存储4个数字(三个坐标和一条边)，每个面存储6个数字(三个顶点索引和三条边)，总共4nv + 6nt ≈16nv 每个顶点的存储单位为9nv 用于基本索引网格。</strong></p>
<p><strong>这里展示的三角形邻居结构仅适用于流形网格，因为它依赖于返回到起始三角形来终止顶点的邻居的遍历，而这不会发生在没有完整三角形循环的边界顶点上。然而，将其推广到有边界的流形并不困难，只需为边界三角形的邻居引入一个合适的哨兵值(如−1)，并注意边界顶点指向最逆时针的邻近三角形，而不是任意三角形。</strong></p>
<h4 id="The-Winged-Edge-Structure-翼边结构"><a href="#The-Winged-Edge-Structure-翼边结构" class="headerlink" title="The Winged-Edge Structure 翼边结构"></a>The Winged-Edge Structure 翼边结构</h4><p><strong>一种广泛使用的将连接性信息存储在边缘而不是表面的网格数据结构是翼边数据结构。这个数据结构使边成为数据结构的一级成员，如下两图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130438.png" class="" title="image-20211001130438">

<p>一个翼边网格结构的例子，存储在阵列中。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130455.png" class="" title="image-20211001130455">

<p>翼边数据结构的四面体和相关元素。两张表并不是独一无二的;每个顶点和面存储与其相关联的任何一条边。</p>
<p><strong>在翼边网格中,每个边缘存储指针的两个顶点(头部和尾部顶点),两面是(左和右面)的一部分,最重要的是,下一个和以前的边缘的逆时针方向遍历左和右面(下图)。每个顶点和面还存储一个指向连接它的任意边的指针:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130809.png" class="" title="image-20211001130809">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130819.png" class="" title="image-20211001130819">

<p>从边缘到翼边结构中的相邻边、面和顶点。</p>
<p><strong>翼边数据结构支持恒时访问面或顶点的边，从这些边可以找到相邻的顶点或面:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001130914.png" class="" title="image-20211001130914">

<p><strong>这些相同的算法和数据结构同样适用于不局限于三角形的多边形网格;这是基于边缘的结构的一个重要优点。</strong></p>
<p><strong>与任何数据结构一样，翼边数据结构会做出各种时间/空间权衡。例如，我们可以消除前面的引用。这使得顺时针绕面或逆时针绕顶点遍历变得更加困难，但当我们需要知道之前的边时，我们总是可以沿着圆中的后续边，直到我们回到原来的边。这节省了空间，但使一些操作变慢了。</strong></p>
<h4 id="The-Half-Edge-Structure-半边结构"><a href="#The-Half-Edge-Structure-半边结构" class="headerlink" title="The Half-Edge Structure 半边结构"></a>The Half-Edge Structure 半边结构</h4><p><strong>翼边结构相当优雅，但它还有一个尴尬之处——在移动到下一个边缘之前，需要不断检查边缘的方向。这种检查直接类似于我们在三角形邻居结构的基本版本中看到的搜索:我们要找出我们是从头部还是从尾部进入当前边缘的。解决方案也几乎没有区别:我们不是为每条边存储数据，而是为每条半边存储数据。共享一条边的两个三角形各有一条半边，这两条半边的方向相反，每条边都与它自己的三角形一致。</strong></p>
<p><strong>通常存储在边中的数据在两个半边之间分割。每条半边都指向边一侧的面和头部的顶点，每条半边都包含面向其面的边指针。它还指向边缘另一边的邻居，从那里可以找到另一半信息。与翼边一样，半边可以包含指向其正面周围的前半边和下半边的指针，也可以只指向下半边。我们将展示使用单个指针的示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131124.png" class="" title="image-20211001131124">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131311.png" class="" title="image-20211001131311">

<p>从半边到的引用它的邻近网格组件。</p>
<p><strong>遍历一个半边结构就像遍历一个翼边结构一样，除了我们不再需要检查方向，我们跟随对指针访问相反面的边。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131157.png" class="" title="image-20211001131157">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131211.png" class="" title="image-20211001131211">

<p><strong>这里的顶点遍历是顺时针的，这是必要的，因为结构中省略了prev指针。</strong></p>
<p><strong>因为半边通常是成对分配的(至少在没有边界的网格中是这样)，许多实现都可以不使用成对指针。例如，在基于数组索引的实现中(如下图所示)，数组可以被安排为偶数的边i总是与边i + 1配对，奇数的边j总是与边j−1配对。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211001131436.png" class="" title="image-20211001131436">

<p>存储在数组中的半边网格结构的一个例子。</p>
<p><strong>除了本章所展示的简单遍历算法，这三种网格拓扑结构都可以支持各种“网格手术”操作，如分裂或折叠顶点、交换边、添加或删除三角形等。</strong></p>
<h2 id="Scene-Graphs-场景图形"><a href="#Scene-Graphs-场景图形" class="headerlink" title="Scene Graphs 场景图形"></a>Scene Graphs 场景图形</h2><p><strong>三角形网格管理构成场景中的对象的三角形集合，但图形应用程序中的另一个普遍问题是将对象安排在所需的位置。正如我们在第6章所看到的，这是通过转换完成的，但是复杂的场景可以包含大量的转换，并且组织好它们会使场景更容易操作。大多数场景都有一个层次结构，并且使用场景图可以根据这个层次结构来管理转换。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100427.png" class="" title="image-20211002100427">

<p>一个铰链的钟摆。左边是“局部”坐标中的两部分。底部件的铰链在b点，底部件的附件在其局部原点。装配对象的自由度为上铰链的角度(θ，φ)和位置p。</p>
<p><strong>为了激发场景图数据结构，我们将使用如上图所示的铰链摆。考虑一下我们怎样画钟摆的上面部分:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100624.png" class="" title="image-20211002100624">

<p><strong>底部更复杂，但我们可以利用这个事实，在局部坐标系中，它位于上摆的底部b点。首先，我们旋转下摆，使其相对于初始位置的角度为φ。然后，我们移动它，使它的顶部铰链在b点，现在它在上摆的局部坐标中的适当位置，然后它可以沿着那个坐标系移动。下摆的复合变换为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100702.png" class="" title="image-20211002100702">

<p><strong>因此，我们看到，下摆不仅生活在它自己的局部坐标系中，而且这个坐标系本身也随着上摆的坐标系运动。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100718.png" class="" title="image-20211002100718">

<p>上图铰链摆的场景图。</p>
<p><strong>我们可以在数据结构中对摆进行编码，使这些坐标系统问题的管理更容易，如上图所示。适用于一个对象的合适矩阵就是链中所有矩阵的乘积指向数据结构根的对象。例如，考虑一个轮渡模型，该轮渡有一辆可以在轮渡甲板上自由移动的汽车，每个车轮都相对于汽车移动，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002100844.png" class="" title="image-20211002100844">

<p>渡轮，渡轮上的汽车，还有汽车(仅显示两辆)存储在一个场景图中。</p>
<p><strong>和钟摆一样，每个物体都应该通过从根到物体的路径上的矩阵乘积进行变换:</strong></p>
<p>​    <strong>•利用M0进行变换；</strong></p>
<p>​    <strong>•车身变换使用M0M1；</strong></p>
<p>​    <strong>•左轮变换使用M0M1M2；</strong></p>
<p>​    <strong>•左轮变换使用M0M1M3．</strong></p>
<p><strong>一个有效的实现可以使用矩阵堆栈(许多API支持的数据结构)来实现。使用从矩阵乘积右侧添加和删除矩阵的推和弹出操作来操作矩阵堆栈。例如,调用:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101055.png" class="" title="image-20211002101055">

<p><strong>生成活动矩阵M = M0M1M2．随后调用pop()将去掉最后添加的矩阵，以便活动矩阵变为M = M0M1．将矩阵堆栈与场景图的递归遍历相结合，我们得到:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101139.png" class="" title="image-20211002101139">

<p><strong>场景图有许多变体，但都遵循上面的基本思想。</strong></p>
<h2 id="Spatial-Data-Structures-空间数据结构"><a href="#Spatial-Data-Structures-空间数据结构" class="headerlink" title="Spatial Data Structures 空间数据结构"></a>Spatial Data Structures 空间数据结构</h2><p><strong>在许多(如果不是全部)图形应用程序中，快速定位空间特定区域中的几何对象的能力是重要的。光线追踪器需要找到与光线相交的物体;在环境中导航的交互式应用程序需要找到从任何给定视角可见的对象;游戏和物理模拟需要检测物体碰撞的时间和地点。所有这些需求都可以得到支持通过各种空间数据结构来组织空间中的对象，以便有效地查找它们。</strong></p>
<p><strong>在本节中，我们将讨论三种空间数据结构的一般类型。将对象分组成层次结构的结构称为对象划分方案:对象被划分为不相连的组，但这些组最终可能在空间上重叠。将空间划分为不相交区域的结构称为空间划分方案:空间被划分为独立的分区，但一个对象可能必须与多个分区相交。空间划分方案可以是规则的，将空间划分成形状一致的小块;也可以是不规则的，将空间自适应地划分成不规则的小块，小块的地方有更多更小的物体。</strong></p>
<p><strong>在讨论这些结构时，我们将使用光线追踪作为主要动机，尽管它们也可以用于视图剔除或碰撞检测。在第4章中，所有对象在检查交叉路口时被循环。对于N个对象，这是一个O(N)线性搜索，因此在大型场景中很慢。与大多数搜索问题一样，只要我们能够创建有序的数据结构作为预处理，就可以使用“分治”技术在亚线性时间内计算出射线与目标的交集。有很多方法可以做到这一点。</strong></p>
<p><strong>本节将详细讨论其中的三种技术:包围体积层次(Rubin &amp; Whitted, 1980;Whitted,1980;Goldsmith &amp; Salmon, 1987)，统一空间划分(Cleary, wyill, Birtwistle， &amp; Vatti, 1983; Fujimoto, Tanaka, &amp; Iwata, 1986; Amanatides &amp; Woo, 1987)和二进制空间分区(Glassner, 1984; Jansen, 1986; Havran, 2000)。下图显示了前两种策略的示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101447.png" class="" title="image-20211002101447">

<p>左:空间的统一划分。右:自适应边界框层次结构。</p>
<h3 id="Bounding-Boxes-边界框"><a href="#Bounding-Boxes-边界框" class="headerlink" title="Bounding Boxes 边界框"></a>Bounding Boxes 边界框</h3><p><strong>在大多数交加速方案中，一个关键的操作是计算带有边界框的射线的交(下图)。这与传统的交叉测试不同，因为我们不需要知道光线击中盒子的位置;我们只需要知道它是否击中了盒子。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101833.png" class="" title="image-20211002101833">

<p>如果它击中了边界框，射线只检测交点。</p>
<p><strong>为了构建射线盒相交的算法，我们首先考虑一个方向向量具有正x和y分量的2D射线。我们可以把它推广到任意的3D射线。2D边界框由两条水平线和两条垂直线定义:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002101954.png" class="" title="image-20211002101954">

<p><strong>这些直线所限定的点可以用区间表示法来描述:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102004.png" class="" title="image-20211002102004">

<p><strong>如下图所示，交集测试可以用这些间隔来划分。首先，我们计算射线在x = xmin处的射线参数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102018.png" class="" title="image-20211002102018">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102218.png" class="" title="image-20211002102218">

<p>射线在x∈[x]区间内[xmin*, x*max]对于其参数空间t∈[t]中的某个区间[txmin,txmax］．对于y区间也存在类似的区间。如果射线同时在x和y区间，那么它与方框相交，即两个一维区间的交集不是空的。</p>
<p><strong>然后对t进行类似的计算txmax,tymin, tymax．当且仅当区间[txmin,txmax]和[tymin,tymax)重叠,即它们的交集是非空的。在伪代码中，这个算法是:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102450.png" class="" title="image-20211002102450">

<p><strong>if语句可能看起来不明显。要理解它的逻辑，请注意，如果第一个区间完全在第二个区间的右边或左边，那么就没有重叠。</strong></p>
<p><strong>我们首先要处理的是xd或yd是负的。如果xd 是负的，那么射线在到达xmin点之前就会击中xmax ．因此，计算txmin 和txmax 扩展:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102620.png" class="" title="image-20211002102620">

<p><strong>对于y情况，必须进行类似的代码扩展。一个主要的问题是，水平和垂直射线的yd和xd值分别为零。这将导致除以0，这可能是一个问题。然而，在直接解决这个问题之前，我们检查IEEE浮点计算是否为我们优雅地处理了这些情况。回想一下第1.5节中的除零规则:任何正实数a，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102734.png" class="" title="image-20211002102734">

<p><strong>考虑垂直射线的情况，xd = 0 且 yd&gt; 0。然后我们可以计算</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102743.png" class="" title="image-20211002102743">

<p><strong>有三种可能性:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102753.png" class="" title="image-20211002102753">

<p><strong>对于我们的第一个案例</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102804.png" class="" title="image-20211002102804">

<p><strong>这就得到了区间(txmin,txmin) =(∞，∞)。这个区间不会与任何区间重叠，因此不会出现预期的命中。对于第二个例子，我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102926.png" class="" title="image-20211002102926">

<p><strong>这就得到了区间(txmin,txmin) =(−∞，∞)，它将与所有的区间重叠，因此将产生预期的命中。第三种情况导致的区间(−∞，−∞)不产生预期的命中。因为这些案例可以按照预期工作，所以我们不需要对它们进行特别检查。通常情况下，IEEE浮点是我们的约定。然而，这种方法仍然存在一个问题。</strong></p>
<p><strong>考虑以下代码段:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102937.png" class="" title="image-20211002102937">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102946.png" class="" title="image-20211002102946">

<p><strong>当xd =−0。这可以通过检验xd的倒数来克服(A. Williams, Barrus, Morley， &amp; Shirley, 2005):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002102956.png" class="" title="image-20211002102956">

<h3 id="Hierarchical-Bounding-Boxes-层次包围框"><a href="#Hierarchical-Bounding-Boxes-层次包围框" class="headerlink" title="Hierarchical Bounding Boxes 层次包围框"></a>Hierarchical Bounding Boxes 层次包围框</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103506.png" class="" title="image-20211002103506">

<p>2D射线e + t d与2D射线进行测试边界框。</p>
<p><strong>层次包围盒的基本思想可以通过在所有对象周围放置一个轴向3D包围盒的常见策略来理解，如上图所示。击中边界框的射线实际上比强力搜索的计算成本更高，因为测试与框的交集不是免费的。不过，错过的射线盒比暴力搜索便宜。这种包围盒可以通过将对象集划分为一个盒，并在每个分区周围放置一个盒来分层，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103515.png" class="" title="image-20211002103515">

<p>包围框可以被嵌套在模型的子集周围创建框。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103706.png" class="" title="image-20211002103706">

<p>灰色方框是一个指向三个灰色的球体的树节点，而厚厚的黑盒子指向三个黑色的球体。注意，不是所有被方框包围的球体都被相应的树节点指向。</p>
<p><strong>上图中所示的层次结构的数据结构可能是一个树根上有一个大边框的树，两个较小的边框作为左右子树。这些三角形依次指向三个三角形。射线与这个硬编码树的交点是:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103900.png" class="" title="image-20211002103900">

<p><strong>与此算法相关的一些观察是，在两个子树之间没有几何顺序，没有理由射线可能不会击中两个子树。事实上，这两棵子树没有理由不重叠。</strong></p>
<p><strong>这种数据层次结构的一个关键点是，一个框保证绑定层次结构中它下面的所有对象，但它们不保证包含空间上与它重叠的所有对象，如上图所示。这使得这种几何搜索比严格有序的一维数据的传统二分搜索稍微复杂一些。读者可能会注意到有几种可能的优化。我们推迟优化，直到我们有一个完整的层次算法。</strong></p>
<p><strong>如果我们将树限制为二进制，并要求树中的每个节点都有一个边界框，那么这个遍历代码自然会扩展。此外，假设所有节点要么是树中的叶子，包含一个原语，要么是它们包含一棵或两棵子树。</strong></p>
<p><strong>bvh-node类应该是surface类型的，所以它应该实现surface::hit。它包含的数据应该是简单的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002103956.png" class="" title="image-20211002103956">

<p><strong>遍历代码然后可以以面向对象的风格递归地调用</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104016.png" class="" title="image-20211002104016">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104027.png" class="" title="image-20211002104027">

<p><strong>注意，因为左节点和右节点都指向曲面而不是bvh-node，所以我们可以让虚函数来区分内部节点和叶节点;将调用适当的hit函数。注意，如果正确构建了树，我们可以消除left为NULL的检查。如果我们想要消除对右是否为NULL的检查，可以用多余的左指针替换NULL右指针。这最终将检查两次左侧，但将消除整个树中的检查。这是否值得，将取决于树木构造的细节。</strong></p>
<p><strong>有许多方法可以为包围卷层次结构构建树。这样做很方便，可以使树为二叉树，大致平衡，并且兄弟子树的方框不会有太多重叠。实现这一点的一个启发式方法是，在将曲面划分为两个子列表之前，先沿着一个轴对它们进行排序。如果坐标轴定义为一个x = 0, y = 1, z = 2的整数，我们有:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104126.png" class="" title="image-20211002104126">

<p><strong>通过每次仔细选择AXIS，可以提高树的质量。一种方法是选择坐标轴，使两棵子树的包围盒的体积之和最小化。与通过轴旋转相比，这种变化对同位素分布的小物体构成的场景没有什么不同，但它可能对表现不佳的场景有显著帮助场景。这段代码也可以通过只进行分区而不是进行完整排序来提高效率。</strong></p>
<p><strong>另一种可能更好的构建树的方法是让子树包含大约相同数量的空间，而不是相同数量的对象。为此，我们根据空间对列表进行分区:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104158.png" class="" title="image-20211002104158">

<p><strong>尽管这会导致不平衡的树，但它允许很容易地遍历空白空间，而且构建成本更低，因为分区比排序成本更低。</strong></p>
<h3 id="Uniform-Spatial-Subdivision-统一空间划分"><a href="#Uniform-Spatial-Subdivision-统一空间划分" class="headerlink" title="Uniform Spatial Subdivision 统一空间划分"></a>Uniform Spatial Subdivision 统一空间划分</h3><p><strong>另一个减少交集测试的策略是划分空间。这从根本上不同于分层边界体积划分对象:</strong></p>
<p>​    <strong>•在层次包围体中，每个对象都属于两个兄弟节点中的一个，而空间中的一个点可能在两个兄弟节点中。</strong></p>
<p>​    <strong>•在空间细分中，空间中的每个点都只属于一个节点，而对象可能属于多个节点。</strong></p>
<p><strong>在均匀的空间细分中，场景被分割成轴向框。这些盒子的大小都是一样的，尽管它们不一定是立方体。射线穿过这些盒子，如下图所示。当命中一个对象时，遍历结束。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104424.png" class="" title="image-20211002104424">

<p>在均匀空间细分中，光线通过单元格向前追踪，直到其中一个单元格中的物体被击中。在本例中，只检查着色单元格中的对象。</p>
<p><strong>网格本身应该是surface的一个子类，并且应该实现为一个指向surface的指针的3D数组。对于空单元格，这些指针是NULL。对于只有一个对象的单元格，指针指向该对象。对于具有多个对象的单元格，指针可以指向列表、另一个网格或另一个数据结构，如边界卷层次结构。</strong></p>
<p><strong>这个遍历是以增量方式完成的。这种规律性来自于光线击中每一组平行平面的方式，如下图所示。要了解这个遍历是如何工作的，首先考虑二维情况，其中射线方向有正的x和y分量，并且从网格外开始。假设网格以点(xmin，ymin)和(xmax，ymax)．网格有nx×ny。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104636.png" class="" title="image-20211002104636">

<p>虽然单元格撞击的模式似乎是不规则的(左)，但撞击是平行的平面非常均匀。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104835.png" class="" title="image-20211002104835">

<p>来决定我们是正确前进还是向上，我们跟踪与单元格的下一个垂直和水平边界的交点。</p>
<p><strong>我们的第一项任务是求射线e + td击中的第一个单元格的索引(i, j)。然后，我们需要以适当的顺序遍历单元格。该算法的关键部分是找到初始单元格(i, j)，并决定是增加i还是j(上图)。注意，当我们检查与单元格中的对象的交集时，我们将t的范围限制在单元格内(下图)。大多数实现都是将指针指向表面的3D数组。为了改进遍历的局部性，可以像12.5节中讨论的那样平铺数组。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002104845.png" class="" title="image-20211002104845">

<p>只有在单元格内的点击应该被重新移植。否则，上述情况将导致我们报告击中对象b而不是对象a。</p>
<h3 id="Axis-Aligned-Binary-Space-Partitioning-轴对齐二进制空间分区"><a href="#Axis-Aligned-Binary-Space-Partitioning-轴对齐二进制空间分区" class="headerlink" title="Axis-Aligned Binary Space Partitioning 轴对齐二进制空间分区"></a>Axis-Aligned Binary Space Partitioning 轴对齐二进制空间分区</h3><p><strong>我们还可以在分层数据结构中对空间进行分区，例如二叉空间分区树(BSP树)。这类似于12.4节中用于可见性排序的BSP树，但最常见的是使用轴对齐的，而不是多边形对齐的，用于射线相交的切割平面。</strong></p>
<p><strong>这个结构中的一个节点包含一个切割平面和一个左右子树。每一个子树包含切割平面一侧的所有对象。通过平面的对象存储在两个子树中。假设切割平面在x = D处平行于yz平面，则节点类为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105430.png" class="" title="image-20211002105430">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105538.png" class="" title="image-20211002105538">

<p>这四种情况下射线是如何重新排列到BSP切割平面x = D的。</p>
<p><strong>我们稍后将其推广到y和z切割平面。然后可以以面向对象的方式递归地调用交集代码。代码考虑上图中所示的四种情况。对于我们的目的，这些射线的原点是参数t0处的一个点：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105439.png" class="" title="image-20211002105439">

<p><strong>这四种情况是:</strong></p>
<p>​    <strong>1.射线只与左子树相互作用，我们不需要测试它是否与切割平面相交。它发生在xp &lt; D和xb &lt; 0。</strong></p>
<p>​    <strong>2.射线针对左子树进行测试，如果没有命中，则针对右子树进行测试。我们需要找到x = D处的射线参数，这样我们就可以确保只测试子树内的交点。这种情况发生在xp &lt; D和xb &gt; 0。</strong></p>
<p>​    <strong>3.这种情况类似于情况1，并且发生在xp &gt; D和xb &gt; 0。</strong></p>
<p>​    <strong>4.这种情况类似于第二种情况，发生在xp &gt; D和xb &lt; 0。</strong></p>
<p><strong>处理这些情况的遍历代码依次为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105759.png" class="" title="image-20211002105759">

<p><strong>这是非常干净的代码。然而，为了让它开始，我们需要点击一些包含边界框的根对象，这样我们就可以初始化遍历t0 和t1．我们必须解决的一个问题是，切割平面可能沿着任何轴。我们可以向bsp-node类添加一个整数索引轴。如果允许对点使用索引操作符，将导致对上面的代码进行一些简单的修改，例如:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105821.png" class="" title="image-20211002105821">

<p><strong>将成为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211002105830.png" class="" title="image-20211002105830">

<p><strong>这将导致一些额外的数组索引，但不会生成更多的分支。</strong></p>
<p><strong>虽然处理单个bsp-node比处理bvh-node要快，但单个曲面可能存在于不止一个子树中，这意味着有更多的节点，并且可能会有更高的内存使用。构建树的“好”程度决定了哪种更快。构建树类似于构建BVH树。我们可以选择轴在一个循环中分裂，我们可以每次分裂成两半，或者我们可以尝试更复杂的分裂方式。</strong></p>
<h2 id="BSP-Trees-for-Visibility-可视性二叉树"><a href="#BSP-Trees-for-Visibility-可视性二叉树" class="headerlink" title="BSP Trees for Visibility 可视性二叉树"></a>BSP Trees for Visibility 可视性二叉树</h2><p><strong>另一个可以使用空间数据结构的几何问题是在一个视角变化的场景中确定对象的可见性顺序。</strong></p>
<p><strong>如果我们要从不同的角度制作由平面多边形组成的固定场景的许多图像——就像游戏等应用的情况一样——我们可以使用与前一节讨论的射线相交方法密切相关的二元空间划分方案。不同之处在于，对于可见性排序，我们使用非轴对齐的分裂平面，这样平面就可以与多边形重合。这就产生了一种被称为BSP树的算法，它可以从前面到后面对曲面进行排序。BSP树的关键在于它使用预处理来创建对任何视点都有用的数据结构。因此，当视点发生变化时，将使用相同的数据结构而不进行更改。</strong></p>
<h3 id="Overview-of-BSP-Tree-Algorithm-BSP树算法概述"><a href="#Overview-of-BSP-Tree-Algorithm-BSP树算法概述" class="headerlink" title="Overview of BSP Tree Algorithm BSP树算法概述"></a>Overview of BSP Tree Algorithm BSP树算法概述</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003101858.png" class="" title="image-20211003101858">

<p>画家的算法从一张空白图像开始，然后从前后依次绘制一个物体，绘制已经存在的物体。这将自动消除隐藏的表面。</p>
<p><strong>BSP树算法是画家算法的一个例子。画家的算法从后到前绘制每个对象，每个新的多边形可能会覆盖之前的多边形，如上图所示。它可以实现如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003101817.png" class="" title="image-20211003101817">

<p><strong>第一步(排序)的问题是，多个对象的相对顺序并不总是定义得很好，即使每一对对象的顺序是这样的。这个问题如图12.34所示，三个三角形组成一个循环。</strong></p>
<p><strong>BSP树算法适用于任何由多边形组成的场景，其中没有多边形穿过由其他多边形定义的平面。然后通过预处理步骤放宽这个限制。在接下来的讨论中，我们假设三角形是唯一的原始图形，但我们可以将其扩展到任意多边形。</strong></p>
<p><strong>BSP树的基本思想可以用两个三角形T1 和T2来说明．我们首先回顾(见2.5.3节)包含T1的平面的隐式平面方程f1(p) = 0。隐平面的关键性质我们想要利用的是对于所有点p+ 在平面的一边，f1(p+) &gt; 0;对于平面另一端的所有点p-，f1(p-)&lt; 0。利用这个性质，我们可以求出平面T2在哪一边。同样，这假设了T2的所有三个顶点 都在平面的同一侧。讨论,假设T2 在f1(p) &lt; 0面。然后我们可以画出T1 和T2 对于任意点e，按照正确的顺序:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102227.png" class="" title="image-20211003102227">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102512.png" class="" title="image-20211003102512">

<p>如果周期性的前后颠倒，就会发生循环顺序不可能针对一个特定的眼睛位置。</p>
<p><strong>这样做的原因是如果T2 和e在包含T1的平面的同一侧T2 是没有办法的完全或部分被T1 可以看到从e出发，所以画T1 是安全的第一。如果e和T2 在包含T1的平面的相对两边,那么T2 不能完全或部分阻塞T1，相反的绘制顺序是安全的(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102527.png" class="" title="image-20211003102527">

<p>当e和T<em>2</em> 在包含T的平面的相对两边1，那就安全了首先画T2 然后T1。如果e和T<em>2</em> 在平面的同一侧，那么先T1 然后T<em>2</em>．这是BSP树算法的核心思想。</p>
<p><strong>这种观察可以推广到许多物体，只要它们没有张成由T1定义的平面．如果我们使用带有T1 的二叉树数据结构作为根，树的负分支包含所有顶点为fi(p) &lt; 0的三角形，并且树的正分支包含所有顶点为fi(p) &gt; 0的三角形。我们可以按以下顺序画:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102808.png" class="" title="image-20211003102808">

<p><strong>这段代码的优点是它适用于任何视点e，所以树可以被预先计算。注意，如果每个子树本身是一棵树，其中根三角形将其他三角形相对于包含它的平面分成两组，代码将按原样工作。通过终止更高一级的递归调用，可以稍微提高效率，但代码仍然很简单。一个树如下图所示。如2.5.5节所述，平面上包含三个非共线点a、b、c的点p的隐式方程为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102953.png" class="" title="image-20211003102953">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003102944.png" class="" title="image-20211003102944">

<p>三个三角形和一个有效的BSP树。“肯定”和“否定”分别根据左右子树位置进行编码。</p>
<p><strong>这种形式的隐式方程的(A, B, C, D)存储起来更快</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103003.png" class="" title="image-20211003103003">

<p><strong>方程上式和上上式是等价的，当你回想一下隐式方程的梯度是三角形的法线时，这一点就很清楚了。方程上式的梯度是n = (A, B, C)这就是法向量</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103013.png" class="" title="image-20211003103013">

<p><strong>我们可以通过代入平面上的任意点来求D，例如a:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103022.png" class="" title="image-20211003103022">

<p><strong>这表明了以下形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103034.png" class="" title="image-20211003103034">

<p><strong>如果你记得n是用叉乘来计算的，它和最初的式子是一样的。使用哪种形式的平面方程以及只存储顶点(n和顶点)还是只存储n, D和顶点，这可能是一个品味问题——一个经典的时间存储折衷方案，最好通过剖面来解决。对于调试，使用最初的式子可能是最好的。</strong></p>
<p><strong>一般来说，阻碍上述代码工作的唯一问题是，不能保证一个三角形可以在平面的一边或另一边被唯一分类。它可以在平面的一边有两个顶点，在另一边有第三个顶点。或者它可以在平面上有顶点。这是通过使用平面将三角形分割成更小的三角形来实现的。</strong></p>
<h3 id="Building-the-Tree-构建树"><a href="#Building-the-Tree-构建树" class="headerlink" title="Building the Tree 构建树"></a>Building the Tree 构建树</h3><p><strong>如果数据集中没有三角形交叉，那么所有三角形都在其他三角形的一边，那么可以使用上面的代码遍历的BSP树可以使用以下算法构建:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103612.png" class="" title="image-20211003103612">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103649.png" class="" title="image-20211003103649">

<p>当一个三角形跨越一个平面时，就会有一边是一个顶点，另一边是两个顶点。</p>
<p><strong>我们需要修复的唯一一件事是三角形穿过分割平面的情况，如上图所示。为了简单起见，假设三角形在平面的一边有顶点a和顶点b，顶点c在另一边。在这种情况下，我们可以找到交点A和B，并将三角形切成三个新的带顶点的三角形</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103743.png" class="" title="image-20211003103743">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103756.png" class="" title="image-20211003103756">

<p>当一个三角形被切割时，我们把它分成三个三角形，没有一个跨越切割平面。</p>
<p><strong>如上图所示。这个顶点的顺序是很重要的，这样法线的方向就会和原来的三角形保持一致。如果我们假设f(c) &lt; 0，下面的代码可以将这三个三角形加到树中，假设正子树和负子树都不是空的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103806.png" class="" title="image-20211003103806">

<p><strong>当一个顶点非常接近分裂平面时，会出现一个会困扰简单实现的精度问题。例如,如果我们有两个顶点的一侧分裂面,另一顶点只是一个非常小的距离在另一边,我们将创建一个新的三角形几乎和旧的一样,是一片的一个三角形,三角形的大小几乎为零。最好将其作为一种特殊情况来检测，而不是分成三个新的三角形。人们可能认为这种情况很少见，但因为许多模型都有共享顶点的镶嵌平面和三角形，所以它经常发生，因此必须小心处理。以下是一些简单的操作:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103820.png" class="" title="image-20211003103820">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003103829.png" class="" title="image-20211003103829">

<p><strong>它取平面内f值为正或负的任意顶点。常数是由用户选择的一个小的正实值。上面的技术是一个罕见的例子，在这种情况下，测试浮点数相等是有用的，并且有效，因为零值是设置的，而不是计算的。用计算过的浮点值进行相等比较几乎是不可取的，但我们没有这样做。</strong></p>
<h3 id="Cutting-Triangles-裁剪三角形"><a href="#Cutting-Triangles-裁剪三角形" class="headerlink" title="Cutting Triangles 裁剪三角形"></a>Cutting Triangles 裁剪三角形</h3><p><strong>最后一种情况“将三角形切成三个三角形，并在每边相加”的细节很简单，但也很乏味。我们应该利用BSP树的构建作为一个前处理，最高的效率不是关键。相反，我们应该尝试拥有一个简洁的代码。一个很好的技巧是，通过确保c在平面的一边，而其他两个顶点在另一边，将多种情况合并到一种情况中。这很容易通过互换来实现。在最后的else语句中填充细节(为了简单起见，假设子树是非空的)会得到:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104215.png" class="" title="image-20211003104215">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104226.png" class="" title="image-20211003104226">

<p><strong>这段代码利用了这样一个事实:如果a和b有相同的符号，那么它们的乘积就是正的——因此，第一个if语句。如果交换顶点，我们必须做两次交换以保持顶点的逆时针顺序。注意，可能恰好有一个顶点位于平面上，在这种情况下，上面的代码可以工作，但生成的三角形中的一个面积为零。我们可以通过忽略这种可能性来解决这个问题，但这并不危险，因为栅格化代码必须处理屏幕空间中的零面积三角形。侧面的三角形)。您还可以添加一个不向树中添加零面积三角形的检查。最后，您可以在一个特殊的情况下，当fa, fb和fc中恰好有一个是零时，将三角形切成两个三角形。</strong></p>
<p><strong>为了计算A和B，需要一条线段和隐式平面交。例如，连接a和c的参数线为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104236.png" class="" title="image-20211003104236">

<p><strong>将p(t)代入平面方程，求出与平面n·p + D = 0的交点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104244.png" class="" title="image-20211003104244">

<p><strong>求出t:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104253.png" class="" title="image-20211003104253">

<p><strong>称这个解为t<em>A</em>，我们可以写出A的表达式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104301.png" class="" title="image-20211003104301">

<p><strong>一个类似的计算将得到B。</strong></p>
<h3 id="Optimizing-the-Tree-优化树"><a href="#Optimizing-the-Tree-优化树" class="headerlink" title="Optimizing the Tree 优化树"></a>Optimizing the Tree 优化树</h3><p><strong>与树遍历相比，树创建的效率不那么重要，因为它是一个预处理过程。遍历BSP树所花费的时间与树中节点的数量成正比。(这棵树是否平衡并不重要。)每个三角形都有一个节点，包括由于分裂而创建的三角形。这个数字取决于三角形加到树中的顺序。例如，在下图中，如果T1 是根，树中就会有两个节点，但如果T2 是根结点，就会有更多节点，因为T1 将分裂。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104605.png" class="" title="image-20211003104605">

<p>使用T1 因为BSP树的根会重构结果是一个有两个节点的树。使用T2 因为树根需要修剪，这样树就会变大。</p>
<p><strong>很难找到要加到树中的“最佳”三角形顺序。对于N个三角形，有N个!可能的顺序。所以尝试所有的顺序通常是不可行的。或者，可以从随机的排列集合中尝试一些预定数量的排序，并且最好的一个可以保留到最后的树中。</strong></p>
<p><strong>上面描述的分割算法将一个三角形分割成三个三角形。将一个三角形分割成一个三角形和一个凸四边形可能更有效。如果所有的输入模型都只有三角形，那么这样做可能不值得，但是很容易支持适应任意多边形的实现。</strong></p>
<h2 id="Tiling-Multidimensional-Arrays-平铺多维数组"><a href="#Tiling-Multidimensional-Arrays-平铺多维数组" class="headerlink" title="Tiling Multidimensional Arrays 平铺多维数组"></a>Tiling Multidimensional Arrays 平铺多维数组</h2><p><strong>有效利用内存层次结构是现代体系结构算法设计的关键。通过平铺(有时也称为砖砌)来确保多维数组具有“良好”的数据安排。传统的2D数组存储为带有索引机制的1D数组;例如，Nx ×Ny 数组存储在长度为NxNy 的一维数组中和2D索引(x, y)(从(0,0)到(Nx −1,Ny −1))对应1D索引(从0到NxNy −1)使用公式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104850.png" class="" title="image-20211003104850">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003104901.png" class="" title="image-20211003104901">

<p>未填充2D数组的内存布局Nx = 4 且 Ny = 3。</p>
<p><strong>上图显示了内存布局的示例。这种布局的一个问题是，尽管在同一行中的两个相邻数组元素在内存中是相邻的，但在同一列中的两个相邻元素将被Nx分开元素在内存中。这可能会导致Nx的内存局部性较差．这个问题的标准解决方案是使用贴图来制造内存行和列的局部性更相等。下图显示了一个使用2 × 2贴图的例子。下一节将讨论索引这样一个数组的细节。在此之后将介绍一个更复杂的例子，即在3D阵列上使用两个级别的平铺。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105125.png" class="" title="image-20211003105125">

<p>二维平铺数组的内存布局Nx = 4和Ny = 3和2 × 2平铺。注意，数组顶部的填充是需要的，因为Ny 不是贴图大小2的倍数。</p>
<p><strong>一个关键的问题是瓷砖的大小。实际上，它们应该与机器上的内存单元大小类似。例如，如果我们在一台具有128字节高速缓存线的机器上使用16位(2字节)数据值，那么8 × 8块瓷砖恰好适合高速缓存线。但是，如果使用32位浮点数，即能够将32个元素放入一条缓存线中，那么5 × 5的tiles就有点小了，6 × 6的tiles就有点大了。由于还存在较大的内存单元(如页面)，具有类似逻辑的分层平铺可能很有用。</strong></p>
<h3 id="One-Level-Tiling-for-2D-Arrays-二维数组的一级平铺"><a href="#One-Level-Tiling-for-2D-Arrays-二维数组的一级平铺" class="headerlink" title="One-Level Tiling for 2D Arrays 二维数组的一级平铺"></a>One-Level Tiling for 2D Arrays 二维数组的一级平铺</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105648.png" class="" title="image-20211003105648">

<p>由Bx ×By 每个大小为n × n的格子。</p>
<p><strong>如果我们假设一个Nx ×Ny 数组分解为正方形n×n贴图(上图)，则所需贴图的数量为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105658.png" class="" title="image-20211003105658">

<p><strong>这里，我们假设n除以Nx 和Ny 完全正确。如果不是这样，则应该填充数组。例如，如果Nx = 15, n = 4，然后Nx 应该改为16。为了计算出这样一个数组的索引公式，我们首先找到瓷砖索引(bx,by)，给出贴图的行/列(贴图本身构成一个2D数组):</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105709.png" class="" title="image-20211003105709">

<p><strong>其中÷是整数除法，例如:12 ÷ 5 = 2。如果我们按照图上上上所示的行排列贴图，那么贴图的第一个元素的索引(bx,by)是</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003105720.png" class="" title="image-20211003105720">

<p><strong>该贴图中的内存被安排成传统的2D数组，如图上上所示。部分偏移量(x′， y′)瓷砖的内部</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110119.png" class="" title="image-20211003110119">

<p><strong>其中mod是余数运算符，例如，12 mod 5 = 2。因此，平铺内部的偏移量是</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110129.png" class="" title="image-20211003110129">

<p><strong>因此，在N中找到1D索引元素(x, y)的完整公式Nx ×Ny数组的平铺n × n块为</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110139.png" class="" title="image-20211003110139">

<p><strong>这个表达式包含许多整数乘法、除法和模运算，这些运算在某些处理器上开销很大。当n是2的幂时，这些操作可以转换为位移位和按位逻辑操作。然而，如上所述，理想的大小并不总是2的幂。一些乘法运算可以转换为移位/加法运算，但除法和模数运算更成问题。索引可以增量地计算，但这需要跟踪计数器，需要进行大量比较和较差的分支预测性能。</strong><br><strong>然而，有一个简单的解决方案;注意，索引表达式可以写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110321.png" class="" title="image-20211003110321">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110333.png" class="" title="image-20211003110333">

<p><strong>我们汇总Fx 和Fy，并使用x和y查找数据数组中的索引。这些表将分别由Nx 和Ny 组成元素。即使对于非常大的数据集，表的总大小也将适合处理器的主数据缓存。</strong></p>
<h3 id="Example-Two-Level-Tiling-for-3D-Arrays-示例-用于3D数组的二级平铺"><a href="#Example-Two-Level-Tiling-for-3D-Arrays-示例-用于3D数组的二级平铺" class="headerlink" title="Example: Two-Level Tiling for 3D Arrays 示例:用于3D数组的二级平铺"></a>Example: Two-Level Tiling for 3D Arrays 示例:用于3D数组的二级平铺</h3><p><strong>有效的TLB（ lookaside buffer，是虚拟内存系统的一部分。）利用率也成为影响算法性能的关键因素。同样的技术可以用来提高TLB命中率，在3D阵列中创建m × m × m的n × n × n单元块。例如，一个40 × 20 × 19的体积可以分解成4 × 2 × 2的大砖块，由2 × 2 × 2的砖块和5 × 5 × 5的单元组成。这对应于m = 2和n = 5。因为19不能被mn = 10分解，所以需要一层填充。经验上有用的大小是m = 5对于16位数据集和m = 6对于浮点数据集。</strong></p>
<p><strong>可以使用表达式计算任意(x, y, z)三倍的数据数组的结果索引</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110729.png" class="" title="image-20211003110729">

<p><strong>其中Nx,Ny 和Nz 分别为数据集的大小。</strong></p>
<p><strong>注意，在更简单的二维单级情况下，这个表达式可以写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110739.png" class="" title="image-20211003110739">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211003110749.png" class="" title="image-20211003110749">

<h1 id="13-More-Ray-Tracing-更多的光线追踪"><a href="#13-More-Ray-Tracing-更多的光线追踪" class="headerlink" title="13 More Ray Tracing 更多的光线追踪"></a>13 More Ray Tracing 更多的光线追踪</h1><p><strong>射线追踪器是构建各种高级渲染效果的一个很好的基板。许多效果需要大量的工作来适应对象顺序栅格化框架，包括基础的阴影和反射已经在第4章中介绍，在射线追踪器中是简单和优雅的。在本章中，我们将讨论一些更炫酷的技术，这些技术可以用于光线追踪更广泛的场景，并包括更广泛的效果。一些扩展允许更通用的几何:实例化和构造实体几何(CSG)是使模型更复杂的两种方法，并将复杂性添加到程序中。其他扩展增加了我们可以处理的材料范围:通过透明材料的折射，如玻璃和水，和各种表面上的光泽反射是许多场景中的现实主义必不可少的。</strong></p>
<p><strong>本章还讨论了分布的一般框架射线跟踪(做饭,波特,和木匠,1984),一个强大的扩展基本的多维随机射线的射线跟踪的想法通过每个像素在图像产生平滑的图像边缘和简单和优雅(如果缓慢)产生广泛的影响从软阴影相机景深效果。</strong></p>
<p><strong>优雅的光线跟踪的代价是计算时间:大多数这些扩展将跟踪任何非平凡场景的大量光线。正因为如此，使用第12章中描述的方法来加速光线追踪是至关重要的。</strong></p>
<h2 id="Transparency-and-Refraction-透明度和折射"><a href="#Transparency-and-Refraction-透明度和折射" class="headerlink" title="Transparency and Refraction 透明度和折射"></a>Transparency and Refraction 透明度和折射</h2><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004145831.png" class="" title="image-20211004145831">

<p>斯涅尔定律描述了角度φ如何依赖于角度θ以及物体和周围介质的折射率。</p>
<p><strong>在第四章中，我们讨论了使用递归光线追踪来计算镜面反射。另一种类型的镜面物体是介质——一种能够折射光线的透明材料。钻石、玻璃、水和空气都是电介质。电介质也能滤光;有些玻璃滤掉的红光和蓝光多于绿光，所以玻璃呈现出绿色。当光线从折射率为n的介质进入折射率为nt的介质时,当一些光被透射时，它就会弯曲。这是nt &gt; n的表达式见上图。斯涅尔定律告诉我们</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004145936.png" class="" title="image-20211004145936">

<p><strong>计算两个向量夹角的正弦值通常不像计算余弦值那么方便，余弦值是单位向量的简单点积，就像这里。用三角恒等式sin²θ + cosθ²θ = 1时，可导出余弦的折射关系:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004145945.png" class="" title="image-20211004145945">

<p><strong>注意，如果n和nt ，则θ和φ也相同，如上图右侧所示。</strong></p>
<p><strong>为了将sin φ和cos φ转换成三维矢量，我们可以在曲面法线平面n和光线方向d上建立一个二维标准正交基。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150156.png" class="" title="image-20211004150156">

<p>向量n和b形成一个二维标准正交基平行于传输向量t。</p>
<p><strong>从上图可以看出，n和b构成了折射面的标准正交基。根据定义，我们可以描述变换的方向ray, t，根据这个基础:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150314.png" class="" title="image-20211004150314">

<p><strong>因为我们可以用相同的基底来描述d，而且d是已知的，所以我们可以解出b:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150413.png" class="" title="image-20211004150413">

<p><strong>这意味着我们可以用已知的变量解出t:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150422.png" class="" title="image-20211004150422">

<p><strong>注意，不管n和n是哪个，这个方程都成立<em>t</em> 比较大。一个直接的问题是，“如果平方根下的数字是负数，你该怎么办?”“在这种情况下，没有折射光线，所有的能量都被反射了。这被称为全反射，它是玻璃物体丰富外观的主要原因。</strong></p>
<p><strong>根据菲涅耳方程，介质的反射率随入射角的变化而变化。实现近似菲涅耳方程的一个好方法是使用Schlick近似(Schlick, 1994a)，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150506.png" class="" title="image-20211004150506">

<p><strong>在R0 为法向量入射时的反射率:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150515.png" class="" title="image-20211004150515">

<p><strong>注意，上面的cos θ项总是针对空气中的夹角(相对于法线的内角和外角较大)。</strong></p>
<p><strong>对于均匀的杂质，如在典型的有色玻璃中发现的，根据比尔定律，携带光线的强度会衰减。当射线穿过介质时，根据dI =−CI dx，它的强度会降低，其中dx是距离。因此，dI/dx =−CI。我们可以解这个方程，得到指数I = kexp(−Cx)。衰减程度用RGB衰减常数a来描述，a是一单位距离后的衰减量。引入边界条件，我们知道I(0) = I0， I(1) =aI0)。前者意味着I(x) = I0 exp(−Cx)。后者意味着I0a = I0 exp(−C), 所以 −C = ln(a)。因此，最后的公式是</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150713.png" class="" title="image-20211004150713">

<p><strong>式中，I(s)为距离界面s处的光束强度。在实践中，我们通过眼睛进行逆向工程，因为这样的数据很少容易找到。比尔定律的效果可以在下图中看到，玻璃呈现出绿色。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150744.png" class="" title="image-20211004150744">

<p>玻璃的颜色受内部全反射和比尔定律的影响。透射和反射的光量由菲涅耳方程决定。如第23章所述，使用粒子追踪来计算地平面上的复杂照明。</p>
<p><strong>为了在代码中添加透明材质，我们需要一种方法来确定光线什么时候进入一个对象。最简单的方法是假设所有物体都嵌入在空气中，其折射率非常接近1.0，并且表面法线指向“外”(朝向空气)。在这些假设下，射线和电介质的代码段是:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150831.png" class="" title="image-20211004150831">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004150841.png" class="" title="image-20211004150841">

<p><strong>上面的代码假设自然对数已经被折叠成常数(ar,ag,ab)．如果有完全的内部反射，则折射函数返回false，否则它将填充参数列表的最后一个参数。</strong></p>
<h2 id="Instancing-实例"><a href="#Instancing-实例" class="headerlink" title="Instancing 实例"></a>Instancing 实例</h2><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004151020.png" class="" title="image-20211004151020">

<p>一个由三个元素组成的圆的实例变换是一个椭圆。</p>
<p><strong>光线追踪的一个优雅的特性是它允许非常自然的实例化。实例化的基本思想是在显示对象之前通过变换矩阵扭曲对象上的所有点。例如,如果我们把单位圆由一个比例因子(2,1)在x和y,分别由45◦,然后旋转方向增加一个单位,结果是一个椭圆的离心率2和长轴沿(x =−y)方向集中在(0,1)(上图)。使这个实体成为“实例”的关键是我们存储了圆和复合变换矩阵。因此，椭圆的显式构造将留在呈现时作为后续操作。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004151219.png" class="" title="image-20211004151219">

<p>这两个空间中的射线相交问题只是彼此的简单变换。物体被指定为一个球体加上矩阵M。光线在变换的(世界)空间中由位置a和方向b指定。</p>
<p><strong>在光线追踪中实例化的优点是我们可以选择要做交集的空间。如果基对象是由一组点组成的，其中一个点是p，那么被变换的对象是由矩阵M变换的一组点组成的，其中示例点被变换为Mp。如果我们有一条射线a + tb，我们想与变换后的物体相交，我们可以用一条反变换的射线与未变换的物体相交(上图)。在未转换的空间中进行计算有两个潜在的优势(即上图右侧):</strong></p>
<p>​    <strong>1.未变换的物体可能有一个更简单的相交例程，例如，一个球体和一个椭球体。</strong></p>
<p>​    <strong>2.许多被转换的对象可以共享同一个未被转换的对象，从而减少存储，例如，汽车的交通堵塞，在这种情况下，单个汽车只是几个基本(未转换的)模型的转换。</strong></p>
<p><strong>如第6.2.2节所述，曲面法向量变换不同。记住这一点并使用上图中所示的概念，我们可以确定射线和矩阵m转换的对象的交集。如果我们创建类型为surface的实例类，我们需要创建一个hit函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004151338.png" class="" title="image-20211004151338">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211004151348.png" class="" title="image-20211004151348">

<p><strong>这个函数的一个优点是不需要更改参数rec.t，因为它在两个空间中都是相同的。还要注意，我们不需要计算或存储矩阵M。</strong></p>
<p><strong>这就引出了一个非常重要的问题:射线方向b不能被限制为单位长度的矢量，或者上面的基础结构都不起作用。因此，不将光线方向限制为单位向量是有用的。</strong></p>
<h2 id="Constructive-Solid-Geometry-构建立体几何"><a href="#Constructive-Solid-Geometry-构建立体几何" class="headerlink" title="Constructive Solid Geometry 构建立体几何"></a>Constructive Solid Geometry 构建立体几何</h2><p><strong>射线追踪的一个好处是，任何与3D线相交的几何原语都可以被无缝地添加到射线追踪器中。事实证明，在光线追踪中添加构造立体几何(CSG)也是很简单的(罗斯,1982)。CSG的基本思想是使用集合运算来组合实体形状。这些基本操作如下图所示。这些操作可以看作是设置操作。例如，我们可以考虑C是圆中所有点的集合，S是正方形中所有点的集合。交集操作C∩S是所有同时属于C和S的点的集合。其他操作是类似的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006111721.png" class="" title="image-20211006111721">

<p>基本的CSG操作在2D圆和正方形。</p>
<p><strong>尽管可以直接在模型上执行CSG，但如果只需要一个映像，则不需要显式地更改模型。相反，我们在光线与模型交互时直接执行设置操作。为了使其更自然，我们用一个模型来找到光线的所有交点，而不仅仅是最近的。例如，一条射线a + tb可能在t = 1和t = 2时击中一个球体。在CSG的背景下，我们把它看成是t∈[1,2]在球面内的射线。我们可以为所有曲面计算这些“内部间隔”，并在这些间隔上进行集合操作(回忆第2.1.2节)。如下图所示，命中间隔被处理以表明在差分对象中有两个间隔。t&gt;0的第一个点是射线的交点。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006111925.png" class="" title="image-20211006111925">

<p>间隔被处理以表示射线击中合成物体。</p>
<p><strong>在实践中，CSG交集程序必须维护一个区间列表。当第一个生命值被确定时，材质属性和表面法线与生命值相关联。此外，您必须注意精度问题，因为没有任何东西可以阻止用户使用两个相邻的对象和一个交叉的对象。这可以通过消除厚度低于一定公差的任何间隔来实现。</strong></p>
<h2 id="Distribution-Ray-Tracing-分布光线追踪"><a href="#Distribution-Ray-Tracing-分布光线追踪" class="headerlink" title="Distribution Ray Tracing 分布光线追踪"></a>Distribution Ray Tracing 分布光线追踪</h2><p><strong>对于某些应用来说，光线追踪图像太“干净”了。这种影响可以通过分布射线追踪来缓解(Cook等人，1984)。传统的光线追踪图像看起来很干净，因为一切都很清晰;阴影是完美的锐利，反射没有模糊，一切都在完美的焦点。有时我们希望阴影是柔和的(就像他们在现实生活中一样)，反射是模糊的，就像拉丝金属，图像有不同的焦距，就像在一张大光圈的照片。虽然从基本原理完成这些事情有些复杂(如第23章所述)，但我们可以通过对基本光线追踪算法进行一些相当简单的更改来获得大部分视觉效果。此外，该框架为我们提供了一种相对简单的方法来消除图像的锯齿(回忆第8.3节)。</strong></p>
<h3 id="Antialiasing-抗锯齿"><a href="#Antialiasing-抗锯齿" class="headerlink" title="Antialiasing 抗锯齿"></a>Antialiasing 抗锯齿</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112423.png" class="" title="image-20211006112423">

<p>一个简单的场景，每像素一个样本(左下半部分)和每像素九个样本(右上半部分)。</p>
<p><strong>回想一下，消除图像锯齿的一种简单方法是计算像素区域的平均颜色，而不是中心点的颜色。在光线追踪中，我们的计算原语是计算屏幕上某一点的颜色。如果我们对像素上的这些点进行平均，我们就接近了真实的平均值。如果像素边界的屏幕坐标是[i, i + 1] × [j, j + 1]，那么我们可以替换循环:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112300.png" class="" title="image-20211006112300">

<p><strong>使用在每个像素内的常规n × n样本网格上进行采样的代码:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112311.png" class="" title="image-20211006112311">

<p><strong>这通常被称为常规采样。当n = 4时，一个像素内的16个样本位置如下图所示。注意，这将产生与渲染传统光线跟踪图像相同的答案，每个像素在n处有一个样本nxn×nyn然后平均n × n像素块得到nx ×ny 的图像。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112435.png" class="" title="image-20211006112435">

<p>一个像素有16个常规样本。</p>
<p><strong>在一个像素内以规则模式采集样本的一个潜在问题是，可能会出现规则的伪影，如莫尔图案。如下图所示，通过在每个像素内随机采样，这些伪影可以变成噪声。这通常被称为随机采样，只涉及对代码的一个小更改:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112705.png" class="" title="image-20211006112705">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112715.png" class="" title="image-20211006112715">

<p>一个像素有16个随机样本。</p>
<p><strong>这里ξ是一个在[0,1)范围内返回一个均匀随机数的调用。不幸的是，除非采取许多样本，否则噪声是相当令人讨厌的。一种方法是采用一种混合策略，随机扰动规则网格:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112842.png" class="" title="image-20211006112842">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112853.png" class="" title="image-20211006112853">

<p><strong>这种方法通常称为抖动或分层采样(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006112937.png" class="" title="image-20211006112937">

<p>16个样本采样显示带有或不带有高亮箱的单个像素的调和(抖动)样本。每个箱子里都有一个随机样本。</p>
<h3 id="Soft-Shadows-软阴影"><a href="#Soft-Shadows-软阴影" class="headerlink" title="Soft Shadows 软阴影"></a>Soft Shadows 软阴影</h3><p><strong>阴影在标准光线追踪中难以处理的原因是光线是无限小的点或方向，因此要么可见，要么不可见。在现实生活中，光有非零区域，因此可以部分可见。这个想法如下图中的2D所示。光完全看不见的区域叫做本影。部分可见的区域称为半影。没有一个常用的术语来描述不在阴影中的区域，但有时它被称为反本影。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006113355.png" class="" title="image-20211006113355">

<p>从没有阴影的地方到有阴影的地方，柔和的阴影有渐变的过渡。过渡区为图中用p表示的“半影”。</p>
<p><strong>实现软阴影的关键是考虑到光线是一个区域而不是一个点。一个简单的方法是用一组分布的N个点光源来近似光源，每个点光源的强度是基础光源的1 / N。这个概念如下图的左边所示，其中使用了9个灯。你可以在标准的光线追踪器中这样做，这是在现成的渲染器中获得柔和阴影的常见技巧。这种技术有两个潜在的问题。首先，通常需要几十个点光源来达到视觉上平滑的效果，这大大减慢了程序的速度。第二个问题是阴影在半影内部有明显的过渡。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006113734.png" class="" title="image-20211006113734">

<p>左:一个区域灯可以用一些点灯来近似;9个点中的4个对p是可见的，所以它在半影中。右图:在光线上随机选择一个点作为阴影射线，它有一定的机会击中光线。</p>
<p><strong>分布射线追踪在阴影代码中引入了一个小的变化。代替离散数量的点源来表示区域光，我们将其表示为无限数量，并为每条观察射线随机选择一个。这相当于在灯上为任何表面点选择一个随机点，如上图的右侧所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006113859.png" class="" title="image-20211006113859">

<p>平行四边形光的几何形状由一个角点和两个边向量指定。</p>
<p><strong>如果光源是一个由角点c和两个边向量a和b指定的平行四边形(上图)，那么随机选择一个点r很简单:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006113949.png" class="" title="image-20211006113949">

<p><strong>其中ξ1 和ξ2 为范围[0,1)的均匀随机数。</strong></p>
<p><strong>然后我们发送一条阴影射线到这一点，如上上图中右侧所示。注意，这条射线的方向不是单位长度，这可能需要根据假设对基本射线追踪器进行一些修改。</strong></p>
<p><strong>我们真的很想在灯光上抖动点。然而，不加思考就实现它是很危险的。我们不希望总是有位于像素左上角的光线会向光线的左上角生成阴影光线。相反，我们想要打乱样本，这样像素样本和光样本各自都是抖动的，但是像素样本和光样本之间没有相关性。一个很好的方法是生成两组不同的n²抖动样本，并将样本传递到光源例程中:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006114041.png" class="" title="image-20211006114041">

<p><strong>这个shuffle例程消除了数组r和s之间的任何相干性。阴影例程只使用存储在s[p]中的2D随机点，而不调用随机数生成器。对于索引为0到N−1的数组，shuffle例程为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006114108.png" class="" title="image-20211006114108">

<h3 id="Depth-of-Field-景深"><a href="#Depth-of-Field-景深" class="headerlink" title="Depth of Field 景深"></a>Depth of Field 景深</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006131323.png" class="" title="image-20211006131323">

<p>透镜平均在一个圆锥体上击中被采样像素位置的方向。</p>
<p><strong>在大多数照片中看到的软聚焦效果可以通过在一个非零尺寸的“镜头”而不是在一个点上收集光线来模拟。这叫做景深。透镜从一个方向的圆锥体上收集光线，圆锥体的顶点在聚焦的距离处(上图)。我们可以将我们正在采样的“窗口”放置在聚焦的平面上(而不是我们之前所做的z = n平面)，并将透镜放置在眼睛上。到所有东西都在焦点上的平面的距离我们称之为焦点平面，到它的距离是由用户设置的，就像真实相机到焦点平面的距离是由用户或测距仪设置的一样。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006131336.png" class="" title="image-20211006131336">

<p>为了创造景深效果，眼睛都是从一个正方形区域中随机选取的。</p>
<p><strong>为了忠实于真正的相机，我们应该把镜头做成磁盘。然而，我们将得到非常类似的效果与一个正方形镜头(上图)。所以我们选择了镜头的边长，并在上面随机取样。视场光线的来源将是这些被扰动的位置，而不是眼睛的位置。同样，使用变换程序来防止与像素样本位置的相关性。下图显示了一个使用每像素25个样本和一个大磁盘镜头的示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006131532.png" class="" title="image-20211006131532">

<p>一个景深的例子。酒杯阴影中的焦散计算使用粒子追踪，如第23章所述。</p>
<h3 id="Glossy-Reflection-镜面反射"><a href="#Glossy-Reflection-镜面反射" class="headerlink" title="Glossy Reflection 镜面反射"></a>Glossy Reflection 镜面反射</h3><p><strong>有些表面，如拉丝金属，介于理想的镜面和漫反射表面之间。在反射中可以看到一些可辨认的图像，但它是模糊的。我们可以通过随机扰动理想镜面反射光线来模拟这个过程，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006131757.png" class="" title="image-20211006131757">

<p>反射光线被扰动到一个随机向量r′。</p>
<p><strong>只有两个细节需要解决:如何选择向量r′以及当产生的摄动光线在光线所在表面以下时该怎么做反映。后一个细节通常通过当光线低于表面时返回零颜色来解决。</strong></p>
<p><strong>选择r′，我们再次随机采样。这个正方形垂直于r，其宽度为a，用于控制模糊的程度。我们可以使用2.4.6节中的技术，通过创建w = r的标准正交基来设置正方形的方向。然后，我们在2D正方形中创建一个边长为以原点为中心的随机点。如果我们有二维样本点(ξ， ξ′)∈[0,1]²，则所要求的平方上的类比点为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006132047.png" class="" title="image-20211006132047">

<p><strong>因为我们要扰动的平方平行于u和v向量，射线r′只是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006132057.png" class="" title="image-20211006132057">

<p><strong>请注意,r′不一定是一个单位矢量，如果你的代码要求射线方向，应该标准化。</strong></p>
<h3 id="Motion-Blur-运动模糊"><a href="#Motion-Blur-运动模糊" class="headerlink" title="Motion Blur 运动模糊"></a>Motion Blur 运动模糊</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006132236.png" class="" title="image-20211006132236">

<p>右下角的球在运动，结果是模糊的外观。图片由Chad Barb提供。</p>
<p><strong>我们可以向对象添加一个模糊的外观，如上图所示。这被称为运动模糊，是图像在非零上形成的结果跨越的时间。在真正的相机中，光圈是在物体移动的一段时间内打开的。我们可以通过设置一个从T0到T1的时间变量来模拟开孔．对于每一条观察射线，我们选择一个随机的时间，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211006132331.png" class="" title="image-20211006132331">

<p><strong>我们可能还需要创建一些随着时间移动的物体。例如，我们有一个运动的球体，在时间间隔里它的中心从c0到c1运动。已知T，我们可以计算出实际的圆心并与球面做射线交点。因为每一条光线都是在不同的时间发送的，所以每一条光线都会在不同的位置遇到球体，最终的外观会变得模糊。注意，移动球体的边界框应该限定其整个路径，这样就可以在整个时间间隔内建立效率结构(Glassner, 1988)。</strong></p>
<h1 id="14-Sampling-采样"><a href="#14-Sampling-采样" class="headerlink" title="14 Sampling 采样"></a>14 Sampling 采样</h1><h2 id="Integration-混合"><a href="#Integration-混合" class="headerlink" title="Integration 混合"></a>Integration 混合</h2><p><strong>尽管“积分”和“度量”这两个词看起来很吓人，但它们与数学中一些最直观的概念有关，不应该害怕。对于我们非常不严格的目的，测度就是一个将子集映射到R+ 的函数以与我们对长度、面积和体积的直观概念相一致的方式。例如，在二维实平面R²上，我们有面积A它给平面上的一组点赋值。注意，A只是一个函数，它取了平面的一部分并返回面积。这意味着A的定义域是R²的所有可能子集，表示为幂集P(R²)．因此，我们可以用箭头表示A:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007110244.png" class="" title="image-20211007110244">

<p><strong>应用面积测度的一个例子表明，边长为1的正方形的面积为1:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007110330.png" class="" title="image-20211007110330">

<p><strong>其中(a, b)是正方形的左下角。注意，像(3,7)这样的单点是R²的有效子集面积为零:A((3,7)) = 0。x轴上S = (x, y)使得(x, y)∈R²的点S的集合也是这样y = 0，也就是A (S) = 0。这样的集称为零测度集。</strong></p>
<p><strong>要把一个函数看作测度，它必须服从某些类面积的性质。例如，我们有一个μ: P(S)→R+的函数．要使μ是一个测度，必须满足以下条件:</strong></p>
<p>​    <strong>1.空集的度数为0:μ(∅)= 0，</strong></p>
<p>​    <strong>2.两个截然不同的集合的度量是它们各自度量的总和。这个规则与可能的交集是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111139.png" class="" title="image-20211007111139">

<p><strong>其中∪是集合并算子，∩是集相交算子。</strong></p>
<p><strong>当我们实际计算度量时，我们通常使用积分。我们可以把积分看成一种符号</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111246.png" class="" title="image-20211007111246">

<p><strong>你可以把右边非正式地理解为“取区域S中的所有点x，和它们相关的微分区域。”积分通常有其他写法，包括</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111253.png" class="" title="image-20211007111253">

<p><strong>以上公式都表示“区域S的面积”。“我们将继续使用第一个，因为它过于冗长，避免了模糊性。为了用解析的方法来计算这样的积分，我们通常需要建立一些坐标系，并使用我们的微积分技巧来解这些方程。但如果这些技巧已经消失，也不用担心，因为我们通常需要数值逼近积分，而这只需要一些简单的技巧，稍后将在本章中介绍。</strong></p>
<p><strong>给定集合S上的一个测度，我们总是可以通过用非负函数w: S→R+加权来创建一个新的测度．这个最好用积分表示符号。例如，我们可以从[0,1]²上的简单面积测量开始：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111514.png" class="" title="image-20211007111514">

<p><strong>我们可以通过插入一个半径平方的加权函数来使用“径向加权”度量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111522.png" class="" title="image-20211007111522">

<p><strong>为了解析地计算它，我们可以使用dA≡dx dy的笛卡尔坐标系展开:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007111603.png" class="" title="image-20211007111603">

<p><strong>这里的关键是，如果考虑||x||² 项和dA项结合在一起，形成了一个新的测量值，我们可以称之为ν。这将允许我们写出ν(S)而不是整个积分。如果你觉得这只是一堆符号和簿记，那么你是对的。但它确实允许我们写出方程，可以是紧凑的，也可以是展开的，这取决于我们的喜好。</strong></p>
<h3 id="Measures-and-Averages-度量和平均值"><a href="#Measures-and-Averages-度量和平均值" class="headerlink" title="Measures and Averages 度量和平均值"></a>Measures and Averages 度量和平均值</h3><p><strong>当取函数的平均值时，测量才真正开始奏效。您只能对特定的度量值取平均值，并且希望为应用程序或领域选择一个“自然”的度量值。一旦选择了一个度量，函数f在一个区域S上相对于度量μ的平均值是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112008.png" class="" title="image-20211007112008">

<p><strong>例如，函数f(x, y) = x²  [0,2]²相对于面积度量的平均值是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112019.png" class="" title="image-20211007112019">

<p><strong>这种机制有助于解决看似困难的问题，其中选择度量是棘手的部分。这类问题经常出现在积分几何中，积分几何是研究几何实体(如线和面)的一个领域。例如,有人可能想知道[0,1]²的直线的平均长度。也就是说，根据定义，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112029.png" class="" title="image-20211007112029">

<p><strong>一旦我们知道了，剩下的就是为应用程序选择合适的μ。这将在下一节中对行进行处理。</strong></p>
<h3 id="Example-Measures-on-the-Lines-in-the-2D-Plane-例-在二维平面的直线上度量"><a href="#Example-Measures-on-the-Lines-in-the-2D-Plane-例-在二维平面的直线上度量" class="headerlink" title="Example: Measures on the Lines in the 2D Plane 例:在二维平面的直线上度量"></a>Example: Measures on the Lines in the 2D Plane 例:在二维平面的直线上度量</h3><p><strong>什么量度μ是“自然的”?</strong></p>
<p><strong>如果将直线参数化为y = mx + b，则可以将给定的直线视为“斜截”空间中的点(m, b)。一个容易使用的度量是dm db，但这不是一个“好的”度量，因为并不是所有大小相等的行“包”都具有相同的度量。更准确地说，度量对于坐标系统的变化将不是不变的。例如，如果你取所有通过正方形[0,1]²的直线，通过它的直线的长度与通过一个旋转45度的单位正方形的长度是不同的。我们真正想要的是一种“公平”的度量，它不会随着一组直线的旋转或平移而改变。下两图说明了这个想法。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112342.png" class="" title="image-20211007112342">

<p>这两束线应该用同样的测量方法。它们与y轴有不同的交叉长度，因此使用db将是一个差的选择衡量。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112354.png" class="" title="image-20211007112354">

<p>这两束线应该用同样的测量方法。由于它们有不同的斜率变化值，使用dm将是一个差值测量的糟糕选择。</p>
<p><strong>为了在直线上建立一个自然的度量，我们首先应该把它们看作是二元空间中的点。这是一个简单的概念:直线y = mx + b可以指定为斜截空间中的点(m, b)。这个概念如下图所示。在(φ， b)空间中进行度量更为直接。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112544.png" class="" title="image-20211007112544">

<p>在(x, y)空间中的直线y = m x + b上的点集合也可以用(m, b)空间中的一个点来表示，所以上面的线和下面的点代表同一个几何实体:一条2D线。</p>
<p><strong>其中b为y轴截距，φ为直线与x轴的夹角，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112628.png" class="" title="image-20211007112628">

<p>在角截距空间中，我们通过用角度φ∈[- π/2， π/2]代替斜率来表示直线。</p>
<p><strong>这里，微分测量dφ db几乎可以工作，但由于上上上上图所示的影响，它将不公平。为了解释恒定宽度的线束所造成的更大的跨度b，我们必须加上一个余弦因子:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112801.png" class="" title="image-20211007112801">

<p><strong>可以证明，这个度量，直到一个常数，是唯一相对于旋转和平移不变的度量。</strong></p>
<p><strong>这个测量可以转换成适合于线的其他参数化的测量。例如，(m, b)空间的合适度量是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112814.png" class="" title="image-20211007112814">

<p><strong>对于(u, v)空间中参数化的直线空间，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112843.png" class="" title="image-20211007112843">

<p><strong>适当的措施是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112856.png" class="" title="image-20211007112856">

<p><strong>对于用(a, b)， x轴截距和y轴截距参数化的直线，度量为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112905.png" class="" title="image-20211007112905">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007112959.png" class="" title="image-20211007112959">

<p>直线的法向坐标用到原点的法线距离和指定直线的角度。</p>
<p><strong>注意，这些空格都是同样有效的指定行的方法，并且哪一个是最好的取决于环境。然而，人们可能想知道是否存在这样一个坐标系，在这个坐标系中，一组直线的度量仅仅是对偶空间中的一个区域。事实上，确实有这样一个坐标系，它非常简单;它是法坐标，通过从原点到直线的法线距离和直线的法线相对于x轴的角度来指定一条直线(上图)。这类直线的隐式方程是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007113111.png" class="" title="image-20211007113111">

<p><strong>事实上，这个空间的尺度是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007113120.png" class="" title="image-20211007113120">

<p><strong>在后面的章节中，我们将使用这些方法来选择均匀随机的线。</strong></p>
<h3 id="Example-Measure-of-Lines-in-3D-例-在3D中度量直线"><a href="#Example-Measure-of-Lines-in-3D-例-在3D中度量直线" class="headerlink" title="Example: Measure of Lines in 3D 例:在3D中度量直线"></a>Example: Measure of Lines in 3D 例:在3D中度量直线</h3><p><strong>在3D中，参数化直线的方法有很多种。也许，最简单的方法是使用它们与特定平面的交点以及它们的方向。例如，我们可以画出xy平面的交点及其方向的球坐标。因此，每条线都被指定为a (x, y， θ， φ)四重体。这表明3D中的线是4D实体，即它们可以被描述为4D空间中的点。</strong></p>
<p><strong>一条线的微分量不应随(x, y)而变化，但相等截面的线束应具有相等的量。因此，一个公平的差别衡量是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007113815.png" class="" title="image-20211007113815">

<p><strong>另一种参数化直线的方法是画出两个平行平面的交点。例如,如果直线相交平面z = 0 (x = u,y = v)和平面z = 1 (x = s,y = t),然后由四线可以被描述(u, v,s,t)注意到,像前面的参数化,这个是线平行于xy平面的退化。微分测量对于这个参数化来说更加复杂，尽管它可以近似为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007113940.png" class="" title="image-20211007113940">

<p><strong>对于几乎平行于z轴的线束。这是在基于图像的渲染中经常隐含使用的度量方法。</strong></p>
<p><strong>对于与球面相交的直线集，我们可以使用直线与球面相交的两点的参数化。如果它们在球坐标下，那么这个点可以用四元(θ1,φ1,θ2,φ2)，测量值只是与每个点相关联的微分面积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114035.png" class="" title="image-20211007114035">

<p><strong>这意味着在球体上选择两个均匀的随机端点会形成一条密度均匀的直线。Mateu Sbert在他的论文(Sbert, 1997)中使用了这一观察结果来计算形状因子。</strong></p>
<p><strong>注意，有时我们想参数化有向线，有时我们想让端点的顺序无关紧要。这是一个记账细节，对于渲染应用程序来说尤其重要，因为在渲染应用程序中，沿着一条线流动的光的数量在两条线的两个方向上是不同的。</strong></p>
<h2 id="Continuous-Probability-连续概率"><a href="#Continuous-Probability-连续概率" class="headerlink" title="Continuous Probability 连续概率"></a><strong>Continuous Probability 连续概率</strong></h2><p><strong>许多图形算法利用概率构造随机样本来解决积分和平均问题。这是应用连续概率的领域，它与测度理论有基本的联系。</strong></p>
<h3 id="One-Dimensional-Continuous-Probability-Density-Functions-一维连续概率密度函数"><a href="#One-Dimensional-Continuous-Probability-Density-Functions-一维连续概率密度函数" class="headerlink" title="One-Dimensional Continuous Probability Density Functions 一维连续概率密度函数"></a>One-Dimensional Continuous Probability Density Functions 一维连续概率密度函数</h3><p><strong>非严格地说，连续随机变量x是一个标量或矢量，它“随机”从实线R =(−∞，+∞)取某个值。x的行为完全由它所取值的分布来描述。这种值的分布可以用与x相关的概率密度函数(pdf)， p(关系表示为x ~ p)。x在某一区间[a, b]中假定某一特定值的概率由以下积分给出:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114335.png" class="" title="image-20211007114335">

<p><strong>非严格地说，概率密度函数p描述了一个随机变量取某一值的相对可能性;如果p (x1)= 6.0且p(x2) = 3.0，那么密度p的随机变量在x1 附近的值的可能性是它在x2附近的两倍．密度p有两个特点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114348.png" class="" title="image-20211007114348">

<p><strong>作为一个例子，标准随机变量ξ值在0(包括)和1(不包括)之间具有一致概率(这里一致简单地意味着ξ的每个值都是相等的可能性)。这意味着概率密度函数q对于ξ为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114631.png" class="" title="image-20211007114631">

<p><strong>ξ被定义的空间仅仅是区间[0,1)。ξ在[a, b]∈[0,1)区间内取一个值的概率是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007114644.png" class="" title="image-20211007114644">

<h3 id="One-Dimensional-Expected-Value-一维期望值"><a href="#One-Dimensional-Expected-Value-一维期望值" class="headerlink" title="One-Dimensional Expected Value 一维期望值"></a>One-Dimensional Expected Value 一维期望值</h3><p><strong>一个一维随机变量的实函数f，对于底层pdf，p的平均值称为其期望值E(f(x))(有时写成Ef(x)):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007115040.png" class="" title="image-20211007115040">

<p><strong>一维随机变量的期望值可以通过设置f(x) = x来计算。期望值有一个令人惊讶而又有用的性质:</strong></p>
<p><strong>两个随机变量和的期望值为两个随机变量的期望值之和:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007115050.png" class="" title="image-20211007115050">

<p><strong>对于随机变量x和y，由于随机变量的函数本身就是随机变量，这种期望的线性也适用于它们:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007115059.png" class="" title="image-20211007115059">

<p><strong>一个显而易见的问题是，如果被求和的随机变量是相关的(不相关的变量称为独立的)，那么这个属性是否成立。事实上，无论变量是否独立，这种线性性质都是成立的!这个求和性质对于大多数蒙特卡罗应用程序是至关重要的。</strong></p>
<h3 id="Multidimensional-Random-Variables-多维随机变量"><a href="#Multidimensional-Random-Variables-多维随机变量" class="headerlink" title="Multidimensional Random Variables 多维随机变量"></a>Multidimensional Random Variables 多维随机变量</h3><p><strong>关于随机变量及其期望值的讨论自然延伸到多维空间。大多数图形问题都是在高维空间中进行的。例如，许多照明问题是在半球的表面上出现的。幸运的是，如果我们在随机变量占据的空间上定义一个μ测度，一切都与一维情况非常相似。假设空间S有μ;例如，S是球面，而μ是测量面积的。我们可以定义一个pdf p: S →R，如果x是一个具有x ~ p的随机变量，那么x将在某个区域Si ⊂S中取一个值的概率是由积分给出的</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124218.png" class="" title="image-20211007124218">

<p><strong>这里概率(事件)是事件发生的概率，所以积分是x在区域Si中取值的概率．</strong></p>
<p><strong>在图形中，S通常是一个面积(dμ = dA = dxdy)或一组方向(单位球上的点:dμ = dω = sin θ dθ dφ)。例如，一个二维随机变量α是在半径为R的圆盘上均匀分布的随机变量。这里均匀是指相对于面积均匀分布，例如，一个坏的飞镖玩家的命中率会分布在飞镖板上。因为它是均匀的，我们知道p(α)是某个常数。这个圆盘的面积是πr² 总概率是1，我们可以推导出来</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124425.png" class="" title="image-20211007124425">

<p><strong>这意味着α在某个子集S1 中的概率</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124514.png" class="" title="image-20211007124514">

<p><strong>这是非常抽象的。为了使用这个信息，我们需要一个可以计算的积分形式。假设Si 是圆盘离圆心比周长更近的部分。如果我们转换为极坐标，则α表示为(r， φ)对，S1 是r &lt; R /2的区域。注意，仅仅因为α是均匀的，并不意味着φ或r一定是均匀的(事实上，φ是均匀的，而r不均匀)。微分面积dA等于r dr dφ。因此,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124651.png" class="" title="image-20211007124651">

<p><strong>实函数期望值公式适用于多维情况:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007124715.png" class="" title="image-20211007124715">

<p><strong>其中x∈S, f: S→R, p: S →R。例如，在一个单位区域S = [0, 1] × [0, 1]且 p(x, y)=4xy,x坐标的期望值(x, y) ∼ p为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125044.png" class="" title="image-20211007125044">

<p><strong>注意这里f(x, y) = x。</strong></p>
<h3 id="Variance-方差"><a href="#Variance-方差" class="headerlink" title="Variance 方差"></a>Variance 方差</h3><p><strong>根据定义，一维随机变量的方差V (x)是x与E(x)之差的平方的期望值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125207.png" class="" title="image-20211007125207">

<p><strong>一些代数操作给出了不明显的表达式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125220.png" class="" title="image-20211007125220">

<p><strong>表达式E([x−E(x)]²)对于直观地考虑方差更有用，而代数等价表达式E(x²)−[E (x)] ²通常便于计算。随机变量和的方差是变量独立时的方差之和。这种方差的和性质是它经常被用于概率模型分析的原因之一。方差的平方根称为标准差，σ，它给出了一些与期望值的期望绝对偏差的指示。</strong></p>
<h3 id="Estimated-Means-估计方法"><a href="#Estimated-Means-估计方法" class="headerlink" title="Estimated Means 估计方法"></a>Estimated Means 估计方法</h3><p><strong>许多问题都涉及到独立随机变量x的和<em>i</em>这种变量称为独立同分布(iid)随机变量。当和除以变量数，我们得到E(x)的估计值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125438.png" class="" title="image-20211007125438">

<p><strong>随着N的增加，这个估计的方差减小。我们希望N足够大，以便我们有信心估计“足够接近”。“然而，在蒙特卡洛没有什么是确定无疑的;我们只是获得了统计上的信心，我们的估计是好的。当然，我们必须让N =∞。这种信心由大数定律表示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211007125447.png" class="" title="image-20211007125447">

<h2 id="Monte-Carlo-Integration-蒙特卡洛积分"><a href="#Monte-Carlo-Integration-蒙特卡洛积分" class="headerlink" title="Monte Carlo Integration 蒙特卡洛积分"></a>Monte Carlo Integration 蒙特卡洛积分</h2><p><strong>本节概述了定积分的基本蒙特卡罗解法。这些技术可直接应用于某些积分问题。本节的所有基本材料也涵盖在几个经典的蒙特卡洛文本。(请参阅本章末尾的注释部分。)</strong></p>
<p><strong>如前所述，给定一个函数f: S →R和一个随机变量x ~ p，我们可以通过求和来近似f(x)的期望值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008103422.png" class="" title="image-20211008103422">

<p><strong>因为期望值可以用积分表示，所以积分也可以用求和来近似。上式的形式有点尴尬;我们通常喜欢近似单个函数g的积分而不是乘积fp的积分。我们可以通过将g = fp代入被积函数来实现:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008103440.png" class="" title="image-20211008103440">

<p><strong>为了使这个公式有效，当g不为零时，p必须为正。</strong></p>
<p><strong>为了得到一个好的估计，我们需要尽可能多的样本，我们希望g/p有一个低的方差(g和p应该有一个相似的形状)。智能地选择p被称为重要抽样，因为如果p很大，而g也很大，那么在重要区域就会有更多的样本。上上式也显示了蒙特卡罗积分的基本问题:收益递减。因为估计的方差与1/N成正比，所以标准差与1/√N成正比。因为估计中的误差与标准差的行为类似，我们需要将N的四倍来将误差减半。</strong></p>
<p><strong>另一种减少方差的方法是划分S，积分的域，分为几个较小的域Si，并将积分作为积分之和进行计算越过Si。这被称为分层采样，即抖动在像素采样中使用的技术(第4章)。通常情况下，每个Si只采集一个样本与密度(pi)，在这种情况下，估计的方差为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008103949.png" class="" title="image-20211008103949">

<p><strong>可以看出，如果各层具有相同的测度，分层采样的方差永远不会高于非分层抽样:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008103959.png" class="" title="image-20211008103959">

<p><strong>图形中最常见的分层采样例子是像素采样的抖动，如第13.4节所述。</strong></p>
<p><strong>作为积分I的蒙特卡罗解的一个例子，集合g(x)等于x在区间(0,4)上的积分:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104114.png" class="" title="image-20211008104114">

<p><strong>函数p的形状对N个样本估计方差的影响见下表。注意，当p的形状与g的形状相似时，方差减小。如果p = g/I，方差降为零，但是我通常不为人所知，否则我们就不必求助于蒙特卡洛。下表所示的一个重要原则是，分层抽样通常远优于重要采样(Mitchell, 1996)。虽然对I进行分层的方差与样本数的立方成反比，但对分层下的方差行为并没有普遍的结果。分层对某些功能是没有好处的。一个例子是白噪声函数，其中所有区域的方差都是常数。另一方面，大多数函数将受益于分层采样，因为每个子单元的方差通常会小于整个域的方差。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104246.png" class="" title="image-20211008104246">

<p>∫₀⁴xdx的蒙特卡罗估计的方差。</p>
<h3 id="Quasi–Monte-Carlo-Integration-准蒙特卡罗积分"><a href="#Quasi–Monte-Carlo-Integration-准蒙特卡罗积分" class="headerlink" title="Quasi–Monte Carlo Integration 准蒙特卡罗积分"></a>Quasi–Monte Carlo Integration 准蒙特卡罗积分</h3><p><strong>常用的求积方法是用拟随机点代替蒙特卡罗积分中的随机点。这些点是确定性的，但在某种意义上是一致的。例如，在单位平方[0,1]²上，一组N个拟随机点在正方形内区域a上具有如下性质:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104552.png" class="" title="image-20211008104552">

<p><strong>例如，晶格中的一组规则样本就具有这种性质。</strong></p>
<p><strong>在许多集成应用中，准随机点可以提高性能。有时必须小心确保它们不引入走样。特别好的是，在任何应用程序中，当调用[0,1]^d中的随机或分层点时，可以在不做其他改变的情况下替换d维准随机点。</strong></p>
<p><strong>激发拟蒙特卡罗积分的关键直觉是，当估计被积函数的平均值时，任何一组样本点都可以，只要它们是“公平的”。</strong></p>
<h2 id="Choosing-Random-Points-选择随机点"><a href="#Choosing-Random-Points-选择随机点" class="headerlink" title="Choosing Random Points 选择随机点"></a>Choosing Random Points 选择随机点</h2><p><strong>我们经常想在单位平方上生成一组随机或伪随机点，用于诸如分布射线追踪的应用。有几种方法可以做到这一点，例如jittering(参见第13.4节)。这些方法在单位平方上给出了一组N个合理等分布的点[0,1]² : (u1, v1)通过(uN，vN)。</strong><br><strong>有时，我们的采样空间可能不是方形的(例如，圆形透镜)，也可能不是均匀的(例如，以像素为中心的滤波函数)。如果我们能写出一个数学变换将我们的等分布点(ui, vi)作为输入和输出的一组点在我们的期望采样空间与我们的期望密度。例如，采样一个相机镜头，变换将采取(ui, vi)和输出(ri,φi)，使新的点在透镜的圆盘上近似等分布。虽然我们可能会尝试使用转换</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104855.png" class="" title="image-20211008104855">

<p><strong>它有一个严重的问题。虽然这些点覆盖了镜头，但它们并不均匀(下图)。在这种情况下，我们需要的是一个将等面积区域转换为等面积区域的变换——一个将平方上的均匀采样分布转换为新区域上的均匀分布的变换。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008104948.png" class="" title="image-20211008104948">

<p>采用水平和的转换垂直尺寸一致为(r， φ)不保留相对面积;并不是所有的结果区域都是相同的。</p>
<p><strong>有几种方法可以在非矩形域上生成这样的非均匀点或均匀点，下面几节将介绍三种最常用的方法:函数求逆、拒绝和Metropolis。</strong></p>
<h3 id="Function-Inversion-函数求逆"><a href="#Function-Inversion-函数求逆" class="headerlink" title="Function Inversion 函数求逆"></a>Function Inversion 函数求逆</h3><p><strong>如果密度f(x)是一维的并且定义在x∈[xmin, xmax]区间内，则可以生成随机数αi 从一组均匀随机数ξi中得到密度f,ξi ∈[0,1]。为此，我们需要累积概率分布函数P(x):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008105800.png" class="" title="image-20211008105800">

<p><strong>得到αi，我们只是变换ξi值：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008105820.png" class="" title="image-20211008105820">

<p><strong>其中P−1是P的逆。如果P不是解析可逆的，那么数值方法就足够了，因为对所有有效的概率分布函数都存在逆。</strong><br><strong>注意，由于符号的关系，解析反变换函数比它应该的更容易混淆。例如，如果我们有这个函数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008105917.png" class="" title="image-20211008105917">

<p><strong>对于x &gt; 0，则逆函数表示为y作为x的函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008105926.png" class="" title="image-20211008105926">

<p><strong>当函数是解析可逆的时候，它几乎总是那么简单。然而，使用标准表示法时，情况有点不透明:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110103.png" class="" title="image-20211008110103">

<p><strong>这里x只是一个哑变量。你可能会发现使用不太标准的符号更容易:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110112.png" class="" title="image-20211008110112">

<p><strong>记住，它们是相互反函数。例如，随机选择点xi 的密度</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110122.png" class="" title="image-20211008110122">

<p><strong>在[- 1,1]上我们可以看到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110203.png" class="" title="image-20211008110203">

<p><strong>和</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110211.png" class="" title="image-20211008110211">

<p><strong>所以我们可以“扭曲”一组标准随机数(ξ1，···，ξN )到正确分布的数</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110252.png" class="" title="image-20211008110252">

<p><strong>当然，同样的翘曲函数可以用来将“均匀”抖动的样本转换成理想密度的均匀分布的样本。</strong> </p>
<p><strong>如果随机变量α = (αx,αy)的二维密度(x, y)定义在[xmin, xmax]×[ymin,ymax]，则需要二维分布函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110346.png" class="" title="image-20211008110346">

<p><strong>我们首先选择一个xi 使用边际分布F(x, ymax)，然后选择yi 根据F (xi,y)/F (xi, ymax)．如果f(x, y)是可分离的(可表示为g(x)h(y))，那么一维技术可以在每个维度上使用。</strong><br><strong>回到我们前面的例子，假设我们从半径为R的圆盘均匀采样，因此p(r， φ) = 1/(πR)²)．二维分布函数为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110541.png" class="" title="image-20211008110541">

<p><strong>这意味着正则对(ξ1,ξ2)可以转化为圆盘上的均匀随机点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110613.png" class="" title="image-20211008110613">

<p><strong>这个映射如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110626.png" class="" title="image-20211008110626">

<p>一种使用相同面积的区域的映射磁盘中面积相等的单位平方</p>
<p><strong>为了在一些真实的渲染应用中选择反射光线的方向，我们根据密度在单位半球上选择点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110740.png" class="" title="image-20211008110740">

<p><strong>其中n为类phon指数，θ为与表面法线的夹角，θ∈[0，π/2] (位于上半球)，φ为方位角(φ∈[0,2 π])。累积分布函数为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110752.png" class="" title="image-20211008110752">

<p><strong>sinθ′项的出现是因为在球面上dω = cos θdθdφ。当边际密度被发现时，p(如预期)是可分离的，并且我们发现a (ξ1,ξ2)对正则随机数可以被转换为一个方向</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110901.png" class="" title="image-20211008110901">

<p><strong>同样，这个方法的好处是单位平方上的一组抖动点可以很容易地转化为半球上的一组抖动点，它们的分布是理想的。注意，如果n被设为1，我们有一个弥散分布，这是经常需要的。</strong></p>
<p><strong>通常我们必须将球面上的点映射到一个相对于uvw基的适当方向上。要做到这一点，我们可以先把角度转换成单位向量a:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110944.png" class="" title="image-20211008110944">

<p><strong>为了提高效率，我们可以避免使用反三角函数的三角函数(如cos (arccosθ))。例如，当n = 1(扩散分布)时，向量a简化为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008110955.png" class="" title="image-20211008110955">

<h3 id="Rejection-拒绝"><a href="#Rejection-拒绝" class="headerlink" title="Rejection 拒绝"></a>Rejection 拒绝</h3><p><strong>拒绝方法根据一些简单的分布选择点，并拒绝一些在更复杂的分布中的点。有几种使用拒绝的场景，我们通过示例展示其中一些场景。</strong><br><strong>假设我们想要在单位圆内均匀随机的点。我们可以首先选择均匀随机点(x, y)∈[−1,1]² 拒绝圈外的点。如果函数r()返回一个规范随机数，则该过程</strong></p>
<p><strong>是:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008111733.png" class="" title="image-20211008111733">

<p><strong>如果我们想要一个随机数x ~ p，并且我们知道p: [a, b] →R，并且对于所有的x, p(x) &lt; m，那么我们可以在矩形[a, b] × [0, m]中生成随机的点，并在其中y &lt; p(x):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008111815.png" class="" title="image-20211008111815">

<p><strong>同样的想法也可以应用于在球面上随机取点。要随机选取方向均匀分布的单位矢量，首先在单位球中随机选取一个点，然后取相同方向的单位矢量，将该点视为方向矢量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008111827.png" class="" title="image-20211008111827">

<p><strong>拒选方法通常易于编码，但它很少与分层兼容。由于这个原因，它趋向于收敛得更慢，因此应该主要用于调试，或在特别困难的情况下。</strong></p>
<h3 id="Metropolis"><a href="#Metropolis" class="headerlink" title="Metropolis"></a>Metropolis</h3><p><strong>Metropolis方法使用随机变异产生一组所需密度的样本。这个概念在章节注释中引用的Metropolis Light Transport算法中被广泛使用。假设有一个随机的点x0 在定义域S进一步，假设对于任意点x，我们有一种方法生成随机的y ~ px。我们用边缘符号px(y)≡p(x→y)表示密度函数。现在，假设我们设x1 是S中以密度p(x0 →x1)选定的随机点．我们生成x2 与密度p (x1 →x0)等等。在极限情况下，我们生成无限个样本，可以证明样本有一个由p决定的潜在密度不管初始点x0是多少。</strong></p>
<p><strong>现在,假设我们想选择p这样底层的密度的样品我们收敛函数f (x)成正比,与域f是一个非负函数s .此外,假设我们可以评估f,但我们有很少或没有额外的知识其属性(函数是常见的图形)。同样，假设我们有能力从xi到xi+1 进行“转换”它的密度函数是t(xi →xi+1)．为了增加灵活性，进一步假设我们加上xi 转换到自身，即xi+1 = xi。我们称之为产生了一个潜在的候选者y ~ t(xi →y)和“接受”这个候选人(即xi+1 = y，其概率为a(xi →y)和拒绝它(例如:xi+1 = xi)的概率为1 - a(xi →y)x0, x1, x2，…将是一个随机集合，但在样本之间会有一些相关性。它们仍然适用于蒙特卡罗积分或密度估计，但分析这些估计的方差更具挑战性。</strong></p>
<p><strong>现在，假设我们有一个转移函数t(x→y)和一个函数f(x)我们想要模拟它的分布，我们可以用a(y→x)使点以f的形状分布吗?或者更准确地说,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008115339.png" class="" title="image-20211008115339">

<p><strong>这可以通过确保xi 在某种强烈意义上是静止的。如果你想象一个巨大的样本点x集合，你希望两点之间的“流动”在每个方向上都是相同的。如果我们假设x和y附近点的密度分别与f(x)和f(y)成正比，那么这两个方向的流动应该是相同的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008115412.png" class="" title="image-20211008115412">

<p><strong>k是一个正的常数。设置这两个流常量将对a进行约束:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008115430.png" class="" title="image-20211008115430">

<p><strong>因此，如果a(y→x)或a(x→y)已知，那么另一个已知。使它们更大可以提高被接受的机会，所以通常的技术是将较大的两个设为1。</strong></p>
<p><strong>使用Metropolis样本生成技术的一个困难是，很难估计需要多少个点才能使点集“良好”。“如果丢弃前n个点，事情就会加速，尽管明智地选择n并非易事。</strong></p>
<h3 id="Example-Choosing-Random-Lines-in-the-Square-例-在正方形中选择随机线"><a href="#Example-Choosing-Random-Lines-in-the-Square-例-在正方形中选择随机线" class="headerlink" title="Example: Choosing Random Lines in the Square 例:在正方形中选择随机线"></a>Example: Choosing Random Lines in the Square 例:在正方形中选择随机线</h3><p><strong>作为设计采样策略的整个过程的一个例子，考虑寻找与单位平方相交的随机线的问题[0,1]2。我们希望这个过程是公平的;也就是说，我们希望直线在正方形内均匀分布。直观上，我们可以看到这个问题有些微妙之处;在一个斜角上比在水平或垂直方向上有“更多”线。这是因为正方形的横截面不均匀。</strong></p>
<p><strong>我们的第一个目标是找到一个函数反转方法(如果存在的话)，然后在拒绝方法或Metropolis方法失败时返回。这是因为我们希望在行空间中有分层的样本。我们首先尝试使用法坐标，因为在正方形中选择随机直线的问题就是在(r， θ)空间中与正方形中直线对应的任意部分中找到均匀随机点的问题。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008122610.png" class="" title="image-20211008122610">

<p>最大的距离r对应于一条直线与θ∈[−π/ 2,0]的平方相接。因为这个平方的边长是1,r = cos θ。 </p>
<p><strong>考虑−π/2 &lt; θ &lt; 0的区域。r的什么值对应于与正方形相交的直线?对于这些角，r &lt; cos θ是所有与上图所示的正方形相接的直线。在其他四个象限中，类似的推理可以找到(r， θ)空间中必须采样的区域，如下图所示。区域rmax(θ)的边界方程是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008122900.png" class="" title="image-20211008122900">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008122955.png" class="" title="image-20211008122955">

<p>到达单位正方形的线的最大半径[0,1]² 作为θ的函数。</p>
<p><strong>因为rmax(θ)下的区域是一个简单函数，其下界为r = 0，我们可以根据密度函数首先选择θ对其进行采样:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123318.png" class="" title="image-20211008123318">

<p><strong>分母是4。现在，我们可以计算累积概率分布函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123726.png" class="" title="image-20211008123726">

<p><strong>我们可以通过控制ξ1 = P(θ)来求倒数化成θ = g(ξ1)．这个收益率</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123812.png" class="" title="image-20211008123812">

<p><strong>一旦有了θ， r就很简单:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123837.png" class="" title="image-20211008123837">

<p><strong>如前所述，这一行有许多参数化，每个参数都有一个相关的“公平”度量。我们也可以在这些空间中生成随机的直线。例如，在斜截空间中，到达正方形的区域如下图所示。通过与法向空间相似的推理，斜率的密度函数为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123924.png" class="" title="image-20211008123924">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123914.png" class="" title="image-20211008123914">

<p>(m,b)空间的区域，其中包含与单位平方[0,1]²相交的直线。</p>
<p><strong>关于微分测度</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123935.png" class="" title="image-20211008123935">

<p><strong>这就产生了累积分布函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008123954.png" class="" title="image-20211008123954">

<p><strong>这些可以通过解两个二次方程得到。给定使用ξ1生成的m，我们还有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211008124140.png" class="" title="image-20211008124140">

<p><strong>这并不是比使用法坐标更好的方法;这只是另一种选择。</strong></p>
<h1 id="15-Curves-曲线"><a href="#15-Curves-曲线" class="headerlink" title="15 Curves 曲线"></a><strong>15 Curves 曲线</strong></h1><h2 id="Curves-曲线"><a href="#Curves-曲线" class="headerlink" title="Curves 曲线"></a>Curves 曲线</h2><p><strong>直观地说，你可以把曲线想象成可以用钢笔画出来的东西。曲线是笔在一段时间内所画出的点的集合。虽然我们通常会想到一支笔在纸上写字(例如，在2D空间中的一条曲线)，但笔可以在3D空间中移动以生成一条空间曲线，或者你也可以想象笔在其他空间中移动。</strong></p>
<p><strong>从数学上看，曲线的定义至少有两种方式:</strong> </p>
<p>​    <strong>1.n维空间中某些区间的连续象;</strong> </p>
<p>​    <strong>2.从一维空间到n维空间的连续映射。</strong> </p>
<p><strong>这两种定义都始于间隔范围(笔在曲线上画出的时间)的概念。然而，有一个显著的区别:在第一个定义中，曲线是笔的痕迹点(图像)的集合，而在第二个定义中，曲线是时间和该集合点之间的映射。在本章中，我们使用第一个定义。</strong></p>
<p><strong>曲线是无限大的点的集合。曲线上的点都有这样的性质:任何一点都有两个邻居，除了少数几个有一个邻居的点(这些是端点)。有些曲线没有端点，要么是因为它们是无限的(像一条线)，要么是因为它们是闭合的(绕圈并连接到自己)。</strong></p>
<p><strong>因为曲线的“笔”很薄(无穷小)，很难创建填充区域。虽然空间填充曲线是可能的(通过让它们无限次地自我折叠)，我们在这里不考虑这种数学上的奇怪。一般来说，我们认为曲线是事物的轮廓，而不是“内部”。</strong></p>
<p><strong>我们需要解决的问题是如何指定曲线——给曲线一个名称或表示，以便我们能在计算机上表示它。对于某些曲线，命名问题很简单，因为它们有已知的形状:线段、圆、椭圆弧等。没有“命名”形状的一般曲线有时被称为自由形曲线。因为自由形式的曲线可以呈现任何形状，所以很难指定它们。</strong></p>
<p><strong>有三种主要的方法在数学上指定曲线:</strong></p>
<p>​    <strong>1.隐式曲线表示通过给出一个程序来定义曲线上的点集，这个程序可以测试曲线上是否有点。通常，隐式曲线表示是由这种形式的隐式函数定义的</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009110545.png" class="" title="image-20211009110545">

<p><strong>所以曲线就是这个方程成立的点的集合。请注意，隐式函数f是一个标量函数(它返回一个实数)。</strong></p>
<p>​    <strong>2.参数曲线表示提供了从自由参数到曲线上点集的映射。也就是说，这个自由参数提供了曲线上点的索引。曲线的参数形式是一个将位置赋给自由参数值的函数。直观地说，如果你认为曲线是你可以用笔在纸上画出来的东西，自由参数就是时间，从我们开始画曲线的时间到我们完成曲线的时间。这条曲线的参数函数告诉我们笔在任何时刻的位置:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009110659.png" class="" title="image-20211009110659">

<p><strong>注意，参数函数是一个向量值函数。这个例子是一个2D曲线，所以函数的输出是一个2向量;在三维中它是一个三维向量。</strong></p>
<p>​    <strong>3.生成式或程序性曲线表示提供了可以生成曲线上不属于前两类点的过程。生成曲线描述的例子包括细分方案和分形。</strong></p>
<p><strong>记住，曲线是点的集合。这些表示给了我们指定这些集合的方法。任何曲线都有许多可能的表示形式。对于这个因为，数学家通常会小心地区分曲线和它的表示。在计算机图形学中，我们常常是马虎的，因为我们通常只参考表示，而不是实际的曲线本身。所以当有人说“隐函数”的时候，他们指的要么是由隐函数表示的曲线要么是由隐函数表示的曲线。这种区别通常并不重要，除非我们需要考虑同一曲线的不同表示。我们将在本章中考虑不同的曲线表示，因此我们会更加小心。当我们使用“多项式曲线”这样的术语时，我们指的是可以用多项式表示的曲线。</strong></p>
<p><strong>根据本章开头给出的定义，曲线必须有参数表示。然而，许多曲线有其他表现形式。例如，一个圆心在原点，半径为1的二维圆可以隐式写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009110738.png" class="" title="image-20211009110738">

<p><strong>或以参数形式表示</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009110751.png" class="" title="image-20211009110751">

<p><strong>对于给定的曲线，参数形式不一定是最方便的表示形式。事实上，曲线有可能具有简单的隐式或生成表示，但很难找到参数表示。</strong></p>
<p><strong>不同的曲线表示方式各有优缺点。例如，参数曲线更容易绘制，因为我们可以对自由参数进行采样。一般来说，参数化形式是计算机图形学中最常用的形式，因为它们更容易处理。我们的重点将是曲线的参数表示。</strong></p>
<h3 id="Parameterizations-and-Reparameterizations-参数化和重新参数化"><a href="#Parameterizations-and-Reparameterizations-参数化和重新参数化" class="headerlink" title="Parameterizations and Reparameterizations 参数化和重新参数化"></a>Parameterizations and Reparameterizations 参数化和重新参数化</h3><p><strong>参数曲线是指在特定区间内由特定参数函数给出的曲线。更准确地说，参数曲线有一个给定的函数，它是参数区间的映射。让参数在从0到1的单位区间内运行通常是方便的。当自由参数在单位区间内变化时，通常用u表示。</strong></p>
<p><strong>如果我们查看参数曲线是一条直线用钢笔,我们可以考虑u = 0的时候首先放下笔在纸上和单位时间所花费的时间画出曲线(u = 1是曲线的结束)。</strong></p>
<p><strong>曲线可以通过一个将时间(在这些单位坐标中)映射到位置的函数来指定。基本上，曲线的规格是一个函数，它可以回答这样的问题，“笔在时间u时在哪里?”</strong></p>
<p><strong>如果我们已知一个函数f(t)它指定了区间[a, b]上的一条曲线，我们可以很容易地定义一个新函数f2(u)在单位区间内指定同一曲线。我们可以先定义</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111040.png" class="" title="image-20211009111040">

<p><strong>然后</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111050.png" class="" title="image-20211009111050">

<p><strong>两个函数，f和f2 两者代表同一曲线;然而，它们提供了不同的曲线参数化。为现有曲线创建新参数化的过程称为重参数化，从旧参数到新参数(本例中为g)的映射称为重参数化函数。</strong></p>
<p><strong>如果我们用某种参数化定义了一条曲线，那么就会存在无穷多的其他曲线(因为我们总是可以重新参数化)。能够有一个曲线的多个参数化是有用的，因为它允许我们创建方便的参数化。然而，它也可能是有问题的，因为它使得比较两个函数以确定它们是否代表同一条曲线变得困难。</strong></p>
<p><strong>这个问题的本质更为普遍:自由参数(或时间元素)的存在为我们的曲线表示增加了一个无形的、潜在的未知元素。当我们看到画完的曲线时，我们不一定知道时间。钢笔可能在整个时间间隔内以恒定的速度移动，或者它可能开始时很慢，然后加速。例如，虽然u = 0.5是通过参数空间的一半，但如果笔的运动开始缓慢，并在末端加速，那么它可能不是沿着曲线的一半。下面是一条非常简单的曲线:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111131.png" class="" title="image-20211009111131">

<p><strong>这三个函数在单位区间上代表同一条曲线;然而，当u不为0或1时，f(u)指的是不同的点，这取决于曲线的表示。</strong></p>
<p><strong>如果我们得到一条曲线的参数化，我们可以直接使用它作为曲线的说明，或者我们可以发展一个更方便的参数化。通常，自然参数化是以一种方便的方式创建的(或自然)来指定曲线，所以我们不需要知道沿着曲线的速度是如何变化的。</strong></p>
<p><strong>如果我们知道笔以恒定速度运动，那么自由参数的值就有更多的意义。穿过参数空间的一半就是曲线的一半。这个参数可以被认为是沿着曲线测量长度，而不是测量时间。这种参数化称为弧长参数化，因为它们通过函数定义曲线，函数从沿着曲线的距离(称为弧长)映射到位置。我们经常用变量s来表示弧长参数。</strong></p>
<p><strong>从技术上讲，如果参数化的正切(即参数化对参数的导数)的大小是常数，则参数化就是弧长参数化。用方程式表示，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111211.png" class="" title="image-20211009111211">

<p><strong>计算一条曲线的长度是很棘手的。一般来说，它是由导数的大小的积分定义的(直观地说，导数的大小是笔在曲线上移动的速度)。因此，给定参数v的值，可以计算s(沿曲线从f(0)点到f(v)点的弧长距离)为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111229.png" class="" title="image-20211009111229">

<p><strong>其中f(t)是一个用自然参数化定义曲线的函数。</strong></p>
<p><strong>使用弧长参数化要求能够解出给定s的t的上式。对于我们研究的许多类型的曲线，它不能以一种封闭的(简单的)方式来完成，而必须用数值方法来完成。</strong></p>
<p><strong>通常，我们用变量u表示单位区间内的自由参数，s表示弧长自由参数，t表示非这两个参数之一的参数。</strong></p>
<h3 id="Piecewise-Parametric-Representations-分段参数表示"><a href="#Piecewise-Parametric-Representations-分段参数表示" class="headerlink" title="Piecewise Parametric Representations 分段参数表示"></a>Piecewise Parametric Representations 分段参数表示</h3><p><strong>对于一些曲线，定义一个参数函数来表示它们的形状是很容易的。例如，线、圆和椭圆都有简单的函数，用参数定义它们所包含的点。对于许多曲线来说，找到一个指定其形状的函数是很困难的。我们创建复杂曲线的主要策略是分而治之:我们将曲线分解成许多更简单的小块，每个小块都有一个简单的描述。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111645.png" class="" title="image-20211009111645">

<p>(a)可以很容易表示为两条直线的曲线;(b)可以很容易表示为直线和圆弧的曲线;(c)一条曲线近似于(b)五条线段的曲线。</p>
<p><strong>例如，考虑上图中的曲线。前两条曲线很容易用两部分来表示。以上图(b)中的曲线为例，我们需要两种不同的部分:线段和圆。</strong></p>
<p><strong>为了创建复合曲线的参数表示(如上图(b)中的曲线)，我们需要参数函数在表示各部分的函数之间进行切换。如果我们在0≤u≤1范围内定义参数函数，则上图(a)或(b)中的曲线可以定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009111749.png" class="" title="image-20211009111749">

<p><strong>f1 是第一部分f的参数化吗2 是第二部分的参数化，这两个函数都是在单位区间内定义的。</strong></p>
<p><strong>我们需要小心定义函数f1 和f2 以确保曲线的各个部分吻合。如果f1(1)≠ f2(0)，那么我们的曲线片段将不会连接，不会形成一个单一的连续曲线。</strong></p>
<p><strong>为了表示上图(b)中的曲线，我们需要使用两种不同类型的片段:线段和圆弧。为了简单起见，我们可能更喜欢使用单一类型的块。如果我们试图用一种类型的块(线段)来表示上图(b)中的曲线，我们不能准确地重新创建曲线(除非我们使用无限数量的块)。虽然由线段组成的新曲线(如上图(c))可能与上图(b)中的形状不完全相同，但它可能足够接近我们使用。在这种情况下，我们可能更喜欢使用更简单的线段，而不是使用更准确地表示形状的曲线。</strong></p>
<p><strong>同时，注意当我们使用越来越多的块时，我们可以得到一个更好的近似。在极限情况下(使用无限个碎片)，我们可以准确地表示原始形状。</strong></p>
<p><strong>使用分段表示的一个好处是，它允许我们在两者之间进行权衡</strong></p>
<p>​    <strong>1.我们所表示的曲线与我们想要表示的真实形状的近似程度;</strong></p>
<p>​    <strong>2.我们使用的部件有多复杂;</strong></p>
<p>​    <strong>3.我们用了多少块。</strong></p>
<p><strong>因此，如果我们试图表示一个复杂的形状，我们可能会决定一个粗略的近似是可以接受的，并使用少量的简单块。为了提高近似值，我们可以选择使用更多的块和使用更复杂的块。</strong></p>
<p><strong>在计算机图形实践中，我们倾向于使用相对简单的曲线段(线段、弧段或多项式段)。</strong></p>
<h3 id="Splines-样条线"><a href="#Splines-样条线" class="headerlink" title="Splines 样条线"></a>Splines 样条线</h3><p><strong>在计算机出现之前，当绘图员想要画出光滑的曲线时，他们使用的工具是一块坚硬的金属，他们可以将其弯曲成想要的形状来描画。因为金属会弯曲，而不是折叠，它会有一个光滑的形状。这种硬度意味着金属会尽可能地弯曲以达到预期的形状。这种坚硬的金属叫做花键。</strong></p>
<p><strong>数学家们发现，他们可以用分段多项式函数来表示草图样条所产生的曲线。最初，他们用样条来表示平滑的分段多项式函数。最近，样条被用来描述任何分段多项式函数。我们更喜欢后一种定义。</strong></p>
<p><strong>对我们来说，样条是一个分段多项式函数。这样的函数对于表示曲线非常有用。</strong></p>
<h2 id="Curve-Properties-曲线的性质"><a href="#Curve-Properties-曲线的性质" class="headerlink" title="Curve Properties 曲线的性质"></a><strong>Curve Properties 曲线的性质</strong></h2><p><strong>为了描述曲线，我们需要给出关于它的性质的一些事实。对于“命名”曲线，其属性通常根据曲线的类型而定。例如，为了描述一个圆，我们可以提供它的半径和圆心的位置。对于一个椭圆，我们也可以提供它的长轴的方向和轴的长度的比率。然而，对于自由形式的曲线，我们需要一组更一般的属性来描述单个曲线。</strong></p>
<p><strong>曲线的一些性质仅归因于曲线上的一个位置，而其他性质则需要整个曲线的知识。为了直观地了解两者的区别，假设曲线是一条火车轨道。如果你在一个雾天站在轨道上，你可以分辨出轨道是直的还是弯的，以及你是否在终点。这些是局部性质。你不知道这条轨迹是不是一条闭合曲线，或者它是否与自身相交，或者它有多长。我们称这种类型的属性为全局属性。</strong></p>
<p><strong>研究几何物体(曲线和曲面)的局部性质被称为微分几何。从技术上讲，作为一个微分属性，有一些数学上的限制(粗略地说，在火车轨道的类比中，你不可能有GPS或指南针)。我们不用担心这个区别，而是使用局部性质而不是微分性质。</strong></p>
<p><strong>局部性质是描述曲线的重要工具，因为它们不需要关于整个曲线的知识。局部性质包括</strong></p>
<p>​    <strong>•连续性,</strong> </p>
<p>​    <strong>•在曲线上的特定位置，</strong> </p>
<p>​    <strong>•曲线上特定位置的方向，</strong> </p>
<p>​    <strong>•曲率(和其他导数)。</strong></p>
<p><strong>通常，我们想要指定一条曲线包含一个特定的点。如果一条曲线的一个点是曲线的一部分，那么这个点就是曲线的插值点。如果参数u的某个值f(t) = v，函数f将插值一个值v。我们称插值的位置，即t的值，即位置。</strong></p>
<h3 id="Continuity-连续性"><a href="#Continuity-连续性" class="headerlink" title="Continuity 连续性"></a>Continuity 连续性</h3><p><strong>当两个参数集合在一起时，理解曲线的局部性质是非常重要的。如果曲线是使用上方程来定义的，那么我们就需要小心如何定义各个部分。如果f1(1)≠ f2(0)，那么曲线将被“打破”——我们将不能在一个连续的笔触画曲线。我们把曲线拼接在一起的条件称为连续性条件，因为如果符合连续性条件，曲线就可以画成连续的曲线。因为我们在本章开始时对“曲线”的定义要求曲线是连续的，所以从技术上讲，“破曲线”不是曲线。</strong></p>
<p><strong>除了位置之外，我们还可以检查各个片段的衍生是否匹配正确。如果f₁′(1)≠ f₂′(0)，则组合曲线在切换点处的一阶导数发生突变;一阶导数不是连续的。一般来说，我们说曲线是C^n 连续的，如果它的所有导数在n之前都匹配。我们把位置本身表示为零阶导数，这样C⁰ 连续性条件是指曲线的位置是连续的，C¹ 连续性意味着位置和一阶导数是连续的。曲线的定义要求曲线是C⁰．</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009112822.png" class="" title="image-20211009112822">

<p>两个曲线段之间各种类型的连续性的说明。</p>
<p><strong>上图给出了一些连续性条件的说明。一阶导数的不连续(曲线为C⁰ 但不是C¹)通常是显而易见的，因为它显示了一个尖锐的角落。二阶导数的不连续有时在视觉上是显而易见的。高阶导数的不连续可能会产生影响，这取决于应用。例如，如果曲线代表一个运动，二阶导数的突变是显而易见的，因此三阶导数的连续性通常是有用的。如果曲线上有流体流过(例如，如果它是飞机机翼或船壳的形状)，四阶或五阶导数的不连续可能会导致湍流。</strong></p>
<p><strong>我们刚才介绍的连续性类型(C^n)通常被称为参数连续性，因为它依赖于两个曲线块的参数化。如果每一块的“速度”不同，那么它们就不是连续的。对于我们关心曲线的形状而不是它的参数化的情况，我们定义了几何连续性，当曲线被等效地参数化时(例如，使用弧长参数化)，要求曲线各部分的导数匹配。直观上，这意味着对应的导数必须有相同的方向，即使它们有不同的大小。</strong></p>
<p><strong>所以，如果C¹连续性条件是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009113014.png" class="" title="image-20211009113014">

<p><strong>G¹ 连续性条件为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211009113024.png" class="" title="image-20211009113024">

<p><strong>对于标量k的某个值。一般来说，几何连续性比参数连续性的限制小。一个C^n 曲线也是G^n 除了当参数导数消失时。</strong></p>
<h2 id="Polynomial-Pieces-分布多项式"><a href="#Polynomial-Pieces-分布多项式" class="headerlink" title="Polynomial Pieces 分布多项式"></a><strong>Polynomial Pieces 分</strong>布多项式</h2><p><strong>计算机图形学中最广泛使用的曲线表示方法是将多项式定义的基本元素拼接在一起，这些基本元素被称为多项式块。例如，线元素是由一个线性多项式给出的。在第15.3.1节中，我们给出了一个正式的定义，并解释了如何将多项式块组合在一起。</strong></p>
<h3 id="Polynomial-Notation-多项式符号"><a href="#Polynomial-Notation-多项式符号" class="headerlink" title="Polynomial Notation 多项式符号"></a>Polynomial Notation 多项式符号</h3><p><strong>多项式是这种形式的函数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010103600.png" class="" title="image-20211010103600">

<p><strong>ai 称为系数，n称为多项式的次数，如果an ≠ 0。上式也写成</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010103610.png" class="" title="image-20211010103610">

<p><strong>我们称它为多项式的标准形式。我们可以将规范形式推广到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010103620.png" class="" title="image-20211010103620">

<p><strong>bi(t)是多项式。我们可以为不同的应用选择这些多项式的方便形式，我们称它们为基函数或混合函数(见第15.3.5节)。在上上式中，t^i 是上上式中的bi(t)。如果基函数的集合被正确的选择，任何n + 1次的多项式都可以用一个适当的c来表示。</strong></p>
<p><strong>标准形式并不总是有方便的系数。为了实际的目的，在这一章中，我们将找到一组基函数，这些基函数的系数是控制由多项式函数表示的曲线的方便方法。</strong></p>
<p><strong>要指定二维中嵌入的曲线，可以指定t中的两个多项式一个是x随t变化的一个是y随t变化的;或者指定一个多项式，其中每个ai 是一个二维点。在n维空间中，任何曲线都存在类似的情况。</strong></p>
<h3 id="A-Line-Segment-A线段"><a href="#A-Line-Segment-A线段" class="headerlink" title="A Line Segment  A线段"></a>A Line Segment  A线段</h3><p><strong>为了介绍分段多项式曲线表示的概念，我们将讨论线段。在实践中，线段是如此简单，以至于数学推导看起来有些过分。然而，通过理解这个简单的例子，当我们继续学习更复杂的多项式时，事情会变得更简单。</strong></p>
<p><strong>考虑一个线段的连接点p0 p1．我们可以把这个线段在单位域中的参数函数写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104658.png" class="" title="image-20211010104658">

<p><strong>通过把它写成向量的形式，我们隐藏了点的维数以及我们分别处理每个维数的事实。例如，如果我们制作的是2D游戏，我们可以创建单独的方程式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104713.png" class="" title="image-20211010104713">

<p><strong>我们指定的直线是由两个端点决定的，但从现在开始，我们将坚持使用向量表示法，因为它更清晰。我们称控制参数的向量p为控制点，p的每个元素为控制点。</strong></p>
<p><strong>虽然用线段端点的位置来描述线段是很明显的，通常也是很方便的，但是还有其他的方法来描述线段。例如,</strong></p>
<p>​    <strong>1.线段的中心位置、方向、长度;</strong></p>
<p>​    <strong>2.一个端点的位置和第二点相对于第一点的位置;</strong></p>
<p>​    <strong>3.线段的中间和一个端点的位置。</strong></p>
<p><strong>显然，给定线段的一种描述，我们可以转换到另一种描述。</strong></p>
<p><strong>另一种描述线段的方法是使用多项式的标准形式(见第15.3.1节)，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104804.png" class="" title="image-20211010104804">

<p><strong>任何线段都可以通过指定a0 和a1 或者端点(p0 和p1)来表示．指定端点通常更方便，因为我们可以从端点计算其他参数。</strong></p>
<p><strong>为了将规范形式写成向量表达式，我们定义一个向量u，它是u的幂次向量:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104814.png" class="" title="image-20211010104814">

<p><strong>多项式可表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010104824.png" class="" title="image-20211010104824">

<p><strong>这种矢量表示法将使不同形式的曲线之间的转换更容易。</strong></p>
<p><strong>上面的方程用多项式的简单形式的多项式系数集描述曲线段。我们称这种表示为标准形式。我们将用a表示规范形式的参数。</strong></p>
<p><strong>虽然它在数学上很简单，但标准形式并不总是指定曲线的最方便的方法。例如，我们可能更喜欢通过线段端点的位置来指定线段。如果我们想定义p0 是段的开始(当u = 0时段是)和p1 为线段的末端(线段在u = 1处)，我们可以这样写</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105022.png" class="" title="image-20211010105022">

<p><strong>我们可以解出这些方程的a0 和a1：</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105031.png" class="" title="image-20211010105031">

<h4 id="Matrix-Form-for-Polynomials-多项式的矩阵形式"><a href="#Matrix-Form-for-Polynomials-多项式的矩阵形式" class="headerlink" title="Matrix Form for Polynomials 多项式的矩阵形式"></a>Matrix Form for Polynomials 多项式的矩阵形式</h4><p><strong>虽然第一个例子很容易解，但对于更复杂的例子，将上上式写成更容易的形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105133.png" class="" title="image-20211010105133">

<p><strong>或者，我们可以写</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105253.png" class="" title="image-20211010105253">

<p><strong>我们称之为C，约束矩阵。 如果点的向量让你感到困扰，你可以独立考虑每一个维度(所以p是[x0 x1]或[y0 y1]， a则相应处理)。</strong></p>
<p><strong>我们可以通过求C的逆矩阵来解上式。这个用B表示的逆矩阵叫做基矩阵。基矩阵是非常方便的，因为它告诉我们如何在方便的参数p和标准形式a之间转换, 因此，给了我们一个简单的方法来计算曲线</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105409.png" class="" title="image-20211010105409">

<p><strong>我们可以找到任意形式的曲线的基矩阵，只要参数的定义中没有非线性。非线性定义参数的例子包括线段的长度和角度。</strong></p>
<p><strong>现在，假设我们要参数化线段，使p0 中间点(u = 0.5)和p1 是结束点(u = 1)。为了推导这个参数化的基矩阵，我们设置</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105458.png" class="" title="image-20211010105458">

<p><strong>所以</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105507.png" class="" title="image-20211010105507">

<p><strong>因此</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105516.png" class="" title="image-20211010105516">

<h3 id="Beyond-Line-Segments-超出线段"><a href="#Beyond-Line-Segments-超出线段" class="headerlink" title="Beyond Line Segments 超出线段"></a>Beyond Line Segments 超出线段</h3><p><strong>线段是如此简单，以至于找到一个基矩阵是很简单的。然而，对于高阶曲线来说，这是一个很好的练习。首先，让我们考虑二次曲线。标准形式的优点是，它适用于这些更复杂的曲线，只是让n是一个更大的数字。</strong></p>
<p><strong>二次多项式有三个系数a0,a1和a2．这些系数不便于描述曲线的形状。然而，我们可以使用相同的基矩阵方法来设计更方便的参数。如果我们知道u的值，多项式方程在参数中成为一个线性方程，上一节的线性代数仍然有效。</strong></p>
<p><strong>假设我们想通过起始(u = 0)、中间(u = 0.5)和结束(u = 1)的位置来描述我们的曲线。在多项式中输入相应的值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105948.png" class="" title="image-20211010105948">

<p><strong>约束矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010105957.png" class="" title="image-20211010105957">

<p><strong>基矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110006.png" class="" title="image-20211010110006">

<p><strong>还有一种附加类型的约束(或参数)有时很方便指定:曲线(相对于其自由参数)在特定值处的导数。直观上，导数告诉我们曲线是如何变化的，一阶导数告诉我们曲线的方向，二阶导数告诉我们曲线的方向变化有多快，等等。我们将在后面看到为什么导数是有用的例子。</strong></p>
<p><strong>二次,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110230.png" class="" title="image-20211010110230">

<p><strong>导数很简单:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110240.png" class="" title="image-20211010110240">

<p><strong>和</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110259.png" class="" title="image-20211010110259">

<p><strong>或者,更普遍的是,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110310.png" class="" title="image-20211010110310">

<p><strong>例如，考虑一个情况，我们想要指定一个二次曲线段的位置，第一和第二导数在其中间(u = 0.5)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110321.png" class="" title="image-20211010110321">

<p><strong>约束矩阵为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110331.png" class="" title="image-20211010110331">

<p><strong>基矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110341.png" class="" title="image-20211010110341">

<h3 id="Basis-Matrices-for-Cubics-三次多项式的基矩阵"><a href="#Basis-Matrices-for-Cubics-三次多项式的基矩阵" class="headerlink" title="Basis Matrices for Cubics 三次多项式的基矩阵"></a>Basis Matrices for Cubics 三次多项式的基矩阵</h3><p><strong>三次多项式在图形中很流行(见第15.5节)。各种形式的三次方程的推导就像我们在这一节中看到的推导一样。我们将通过另一个例子来练习。</strong></p>
<p><strong>三次多项式的一种非常有用的形式是Hermite形式，我们在开始和结束处指定位置和一阶导数，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110713.png" class="" title="image-20211010110713">

<p><strong>因此，约束矩阵为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110723.png" class="" title="image-20211010110723">

<p><strong>基矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110732.png" class="" title="image-20211010110732">

<p><strong>我们将在第15.5.2节讨论Hermite三次样条。</strong></p>
<h3 id="Blending-Functions-混合函数"><a href="#Blending-Functions-混合函数" class="headerlink" title="Blending Functions 混合函数"></a>Blending Functions 混合函数</h3><p><strong>如果我们知道基矩阵B，我们可以用它乘以参数向量u，得到一个函数向量</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110840.png" class="" title="image-20211010110840">

<p><strong>注意，我们用b(u)表示这个向量，以强调其值取决于自由参数u的事实。我们称b(u)中的元素为混合函数，因为它们指定了如何将控制点向量的值混合在一起:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010110850.png" class="" title="image-20211010110850">

<p><strong>值得注意的是，对于选择的u值，上方程是一个线性方程，指定控制点的线性混合(或加权平均)。无论哪个次多项式”隐藏”在bi 函数中都是成立的。</strong></p>
<p><strong>混合函数为描述曲线提供了一个很好的抽象。任何类型的曲线都可以表示为其控制点的线性组合，其中这些权值被计算为自由参数的一些任意函数。</strong></p>
<h3 id="Interpolating-Polynomials-插值多项式"><a href="#Interpolating-Polynomials-插值多项式" class="headerlink" title="Interpolating Polynomials 插值多项式"></a>Interpolating Polynomials 插值多项式</h3><p><strong>一般来说，n次多项式可以插值n + 1个值的集合。如果已知向量p = (p0，…pn)和一个向量t = (t0，…tn)增加参数值，ti ≠ tj ，我们可以使用这些方法确定一个n + 1 × n + 1基矩阵它给出一个函数f(t)使f(ti) = pi．对于任意给定的向量t，我们需要建立并求解一个n = 1 × n + 1的线性方程组。这为我们提供了一组执行插值的n + 1基函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111129.png" class="" title="image-20211010111129">

<p><strong>这些插值基函数可以用其他方法导出。定义它们的一个特别优雅的方法是拉格朗日形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111139.png" class="" title="image-20211010111139">

<p><strong>有比拉格朗日形式更有效的计算方法来表示插值基函数(详见De Boor(1978))。</strong></p>
<p><strong>插值多项式提供了一种机制，用于定义插值一组点的曲线。下图显示了一些示例。虽然可以创建一个多项式来插值任意数量的点，但我们很少在计算机图形中使用高阶多项式来表示曲线。相反，插值样条(分段多项式函数)是首选。第15.5.3节讨论了一些原因。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111159.png" class="" title="image-20211010111159">

<p>通过多个点插值多项式。注意点之间额外的摆动和过冲。在(c)中，当加入第6点时，由于插值多项式的非局部性质，完全改变了曲线的形状。</p>
<h2 id="Putting-Pieces-Together-拼凑"><a href="#Putting-Pieces-Together-拼凑" class="headerlink" title="Putting Pieces Together 拼凑"></a>Putting Pieces Together 拼凑</h2><p><strong>现在我们已经看到了如何制作单独的多项式曲线，我们可以考虑如何将这些曲线组合在一起。</strong></p>
<h3 id="Knots-结"><a href="#Knots-结" class="headerlink" title="Knots 结"></a>Knots 结</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111612.png" class="" title="image-20211010111612">

<p>(a)两条线段连接三个点;(b)每个点的混合函数在右边作图。</p>
<p><strong>分段参数函数的基本思想是每一段仅在某个参数范围内使用。例如，如果我们想定义一个函数，它有两个连接三个点的分段线段(如上图(a)所示)，我们可以定义</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111649.png" class="" title="image-20211010111649">

<p><strong>f1 和f2 是两个线段各自的函数。注意，我们已经为每一部分重新调整了参数，以方便将它们的方程写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111658.png" class="" title="image-20211010111658">

<p><strong>对于分段函数中的每个多项式，都有一个起始和结束的位置(或参数值)。一个函数开始或结束的地方叫做结点。对于上上公式中的例子，结点的值是0、0.5和1。</strong></p>
<p><strong>我们也可以把分段多项式函数写成基函数的和，每个基函数以一个系数作比例。例如，可以将上上式中的两条线段改写为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111829.png" class="" title="image-20211010111829">

<p><strong>其中函数b1(u)定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010111846.png" class="" title="image-20211010111846">

<p><strong>和b2 和b3 类似的定义。这些函数绘制在上图(b)中。</strong></p>
<p><strong>多项式函数的结是所有用来创建它的部件的结的组合。结向量是一个以升序存储所有结值的向量。</strong></p>
<p><strong>请注意，在本节中，我们使用了两种不同的机制来组合多项式块:为不同范围的参数使用独立的多项式块，以及将分段多项式函数混合在一起。</strong></p>
<h3 id="Using-Independent-Pieces-使用独立块"><a href="#Using-Independent-Pieces-使用独立块" class="headerlink" title="Using Independent Pieces 使用独立块"></a>Using Independent Pieces 使用独立块</h3><p><strong>在第15.3节中，我们定义了单位参数范围内的多项式。如果我们想组装这些部件，我们需要从整体功能的参数转换为部件的参数值。最简单的方法是定义参数范围[0,n]内的整体曲线，其中n是段的数量。根据参数的值，我们可以将其移动到所需的范围。</strong></p>
<h3 id="Putting-Segments-Together-拼装片段"><a href="#Putting-Segments-Together-拼装片段" class="headerlink" title="Putting Segments Together 拼装片段"></a>Putting Segments Together 拼装片段</h3><p><strong>如果我们想从两个线段制作一条曲线，我们需要确保第一个线段的末端与下一个线段的起点在同一位置。有三种方法连接这两个部分(按简单程度排序):</strong></p>
<p>​    <strong>1.将线段表示为它的两个端点，然后对两个端点使用相同的点。我们称之为共享点方案。</strong> </p>
<p>​    <strong>2.当第一个段的参数发生变化时，将第一个段末尾的值复制到第二个段的开头。我们称之为依赖模式。</strong></p>
<p>​    <strong>3.为连接写一个显式方程，当其他参数改变时，通过数值方法强制执行。</strong></p>
<p><strong>虽然更简单的方案更可取，因为它们需要更少的工作，但它们也对线段的参数化方式施加了更多的限制。例如，如果我们想使用线段的中心作为参数(以便用户可以直接指定它)，我们将使用每个线段的开始和线段的中心作为它们的参数。这将迫使我们使用依赖方案。</strong></p>
<p><strong>请注意，如果我们使用共享点或依赖方案，控制点的总数小于n∗m，其中n是段的数量，m为每段控制点的个数;独立块的许多控制点将作为其他块的函数计算。请注意,如果我们使用共同点方案行(每段两端点使用它作为参数和共享内部点与邻域),或者如果我们使用依赖方案(如示例的第一个端点、中点),我们最终得到的n + 1 控制的n段曲线。</strong></p>
<p><strong>依赖计划有一个更严重的问题。曲线上一个地方的变化可以传播到整个曲线。这被称为缺乏局部性。局部性意味着如果你移动曲线上的一个点，它只会影响一个局部性区域。局部区域可能很大，但它是有限的。如果曲线的控制没有局部性，改变一个控制点可能会影响无限远的点。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211010112303.png" class="" title="image-20211010112303">

<p>具有局部控制和非局部控制的线段链。</p>
<p><strong>为了看到局部性和缺乏局部性，在行动中，考虑两链线段，如上图所示。一条链通过其端点参数化其片段，并使用点共享来保持连续性。另一种是通过端点和中点参数化片段，并使用依赖项传播将片段保持在一起。这两条线段链可以代表相同的曲线:它们都是n个连通线段的集合。但是，由于位置问题，端点共享表单可能对用户更方便。考虑改变每条链中第一个控制点的位置。对于端点共享版本，只有第一个片段会改变，而在中点版本中，所有片段都会受到影响，如上图所示。事实上，对于端点共享版本中移动的任何点，最多会有两个线段发生变化。在中点版本中，控制点移动后的所有段都将改变，即使链是无限长的。</strong></p>
<p><strong>在本例中，依赖项传播方案是没有本地控制的方案。这并不总是正确的。有不是本地的直接共享方案和本地的传播方案。</strong></p>
<p><strong>我们强调地方是一个便于控制的问题。虽然每次都改变整个曲线是不方便的，但是可以对曲线做同样的改变。它只需要同步移动几个点。</strong></p>
<h2 id="Cubics-三次曲线"><a href="#Cubics-三次曲线" class="headerlink" title="Cubics 三次曲线"></a>Cubics 三次曲线</h2><p><strong>在图形中，当我们用分段多项式来表示曲线时，我们通常用线段或三次多项式来表示这些部分。三次曲面在计算机图形学中流行的原因有很多:</strong></p>
<p>​    <strong>•分段三次多项式允许C² 连续性，通常是足以完成大多数视觉任务。二次方程提供的C¹平滑度往往不足。高阶多项式提供的更大的平滑性很少重要。</strong></p>
<p>​    <strong>•三次曲线提供了一组点的最小曲率插值。也就是说，如果你有一组n + 3个点，并定义通过它们的“最平滑”的曲线(即在其长度上曲率最小的曲线)，这条曲线可以表示为n段的分段三次曲线。</strong></p>
<p>​    <strong>•三次多项式有很好的对称性，位置和导数可以指定在开始和结束。</strong> </p>
<p>​    <strong>•三次多项式在计算中的数值问题和平滑性之间有一个很好的权衡。</strong> </p>
<p><strong>注意，我们不必使用三次方程;它们只是在平滑度和复杂性之间的一个很好的权衡。不同的应用程序可能有不同的权衡。我们关注的是曲线，因为它们是最常用的。</strong></p>
<p><strong>三次多项式的标准形式是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011104409.png" class="" title="image-20211011104409">

<p><strong>正如我们在第15.3节中讨论的，这些标准形式系数不是描述三次线段的方便方法。</strong></p>
<p><strong>我们寻求三次多项式的形式，其系数是一种方便的方式来控制由三次表示的结果曲线。便利的主要方式之一将是提供确保各部分的连接和各部分之间的连续性的方法。</strong></p>
<p><strong>每个三次多项式块需要四个系数或控制点。这意味着对于一个有n个分段的多项式，如果分段之间没有共享或没有使用依赖，我们可能需要多达4n个控制点。更常见的情况是，每个片段的某些部分要么是共享的，要么依赖于相邻的片段，因此控制点的总数要低得多。另外，请注意控制点可能是曲线的一个位置或一个导数。</strong></p>
<p><strong>不幸的是，对于分段曲线并没有单一的“最佳”表示。不可能有一个分段多项式曲线表示具有下列所有理想性质:</strong></p>
<p>​    <strong>1.曲线的每一部分都是曲线的;</strong></p>
<p>​    <strong>2.曲线插值控制点;</strong></p>
<p>​    <strong>3.曲线具有局部控制;</strong></p>
<p>​    <strong>4.曲线上有C² 连续性。</strong></p>
<p><strong>我们可以有这些性质中的任意三个，但不是全部四个;有三种形式的任意组合。在这本书中，我们将讨论三次B样条，不插值它们的控制点(但有局部控制，是C²);插值它们的控制的基数样条和Catmull-Rom样条点和提供本地控制，但不是C²;和插值的自然三次方程是C²，但没有局部控制。</strong></p>
<p><strong>三次曲线的连续性是指线段之间(结点处)的连续性。三次元本身的导数有无限的连续性(我们一直在讨论的连续性)。注意，如果你有许多控制点(或结点)，曲线可能会摇摆，这可能看起来并不“平滑”。</strong></p>
<h3 id="Natural-Cubics-自然三次曲线"><a href="#Natural-Cubics-自然三次曲线" class="headerlink" title="Natural Cubics 自然三次曲线"></a>Natural Cubics 自然三次曲线</h3><p><strong>使用分段三次曲线，可以创建C²曲线。为了做到这一点，我们需要在每一段的开始指定位置和一阶导数和二阶导数(以便我们可以确保它与前一段的末尾相同)。注意，每个曲线段从链中先前曲线的四个参数中接收三个。这些C² 三次曲线的连续链有时被称为自然三次样条。</strong></p>
<p><strong>对于自然三次曲线的一部分，我们需要通过端点的位置和起始点的一阶导数和二阶导数来参数化三次曲线。因此控制点是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011104920.png" class="" title="image-20211011104920">

<p><strong>因此约束矩阵为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011104931.png" class="" title="image-20211011104931">

<p><strong>基矩阵是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011104942.png" class="" title="image-20211011104942">

<p><strong>给定一组n个控制点，自然三次样条有n - 1个三次分段。第一段使用控制点来定义它的起始位置、结束位置以及起始处的一阶导数和二阶导数。一个依赖计划复制第一段末端的位置和第一、二阶导数，以便在第二段中使用。</strong></p>
<p><strong>自然三次样条的一个缺点是它们不是局部的。任何部分的改变都可能需要整个曲线的改变(至少是改变后的部分)。更糟糕的是，自然的三次样条往往是病态的:曲线开始的一个小变化可能导致后来的大变化。另一个问题是，我们只能控制曲线开始时的导数。曲线开始后的部分决定了它们从起始点开始的导数。</strong></p>
<h3 id="Hermite-Cubics-Hermite三次曲线"><a href="#Hermite-Cubics-Hermite三次曲线" class="headerlink" title="Hermite Cubics Hermite三次曲线"></a>Hermite Cubics Hermite三次曲线</h3><p><strong>第15.3.4节介绍了Hermite三次多项式。三次埃尔米特样条的一段允许指定其两个端点的位置和一阶导数。一段链可以连接成一个C¹ 样条的位置和导数使用相同的值为一段的结束和下一段的开始。</strong></p>
<p><strong>给定一组n个控制点，其中每一个控制点都是导数值，三次Hermite样条包含(n - 2)/2曲线段。样条插值点，如下图所示，但只能保证C¹连续性。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011105222.png" class="" title="image-20211011105222">

<p>由三段组成的埃尔米特三次样条。</p>
<p><strong>埃尔米特曲线很方便，因为它们提供了对形状的局部控制，并提供了C¹ 连续性。但是，由于用户必须同时指定位置和求导，因此必须为导数提供一个特殊的界面。一种可能是为用户提供一些点，这些点表示导数向量如果被“放置”在位置点上将会在哪里结束。</strong></p>
<h3 id="Cardinal-基数三次曲线"><a href="#Cardinal-基数三次曲线" class="headerlink" title="Cardinal 基数三次曲线"></a>Cardinal 基数三次曲线</h3><p><strong>基数三次样条是C¹ 的一种类型插值由三次多项式段组成的样条。给定一组n个控制点，用基数三次样条N - 2三次多项式段，以插值除第一个和最后一个点的所有点。</strong></p>
<p><strong>基数样条有一个称为张力的参数，它控制曲线在插值点之间的“紧”程度。张力是一个在[0,1)范围内的数字，它控制曲线如何向下一个控制点弯曲。对于t = 0的重要特殊情况，样条被称为Catmull-Rom样条。</strong></p>
<p><strong>基数样条的每一段使用四个控制点。对于线段i，使用的点是i, i + 1, i + 2和i + 3，因为线段与它们的邻居共享三个点。每个部分从第二个控制点开始，到第三个控制点结束。曲线开始处的导数由第一控制点与第三控制点之间的向量决定，曲线结束处的导数由第二控制点与第四个控制点之间的向量决定，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110152.png" class="" title="image-20211011110152">

<p>内基数三次样条的一段将其第二和第三个控制点(p2 和p3)，并利用它的其他点来确定起点和终点的导数。</p>
<p><strong>张力参数调整导数缩放的大小。具体来说，导数是(1 - t)/2。因此立方上的约束是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110255.png" class="" title="image-20211011110255">

<p><strong>求解控制点的这些方程(定义s = (1 - t)/2)得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110309.png" class="" title="image-20211011110309">

<p><strong>这就得到基数矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110320.png" class="" title="image-20211011110320">

<p><strong>由于线段i的第三个点是线段i+1的第二个点，基数样条曲线的相邻线段连接起来。类似地，同样的点被用来指定每一段的一阶导数，提供C¹连续性。</strong></p>
<p><strong>基数样条是有用的，因为它们提供了一种简单的方法来插值一组具有C¹连续性和局部控制的点。它们只是C¹，所以有时会出现“扭结”。张力参数可以控制插值点之间的变化，如下图所示通过一组点的基数样条集合显示。这些曲线使用相同的控制点，但它们使用不同的张力参数值。注意，第一个和最后一个控制点没有插入。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110449.png" class="" title="image-20211011110449">

<p>基数样条通过张力参数t的变化值的七个控制点。</p>
<p><strong>给定一组n个点进行插值，您可能会想，为什么我们可能更喜欢使用基数三次样条(即n - 2个曲线的集合)，而不是第15.3.6节中描述的单个n阶多项式。插值多项式的一些缺点是:</strong></p>
<p>​    <strong>•插值多项式趋于过冲点，如下图所示。随着分数的增加，这种超值会变得更糟。基数样条曲线趋向于在点之间表现良好。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011110636.png" class="" title="image-20211011110636">

<p>样条插值9个控制点(用小叉标记)。粗橙色的线表示一个插值多项式。这条细线表示 Catmull-Rom样条。后者是由七个曲线片段，每个显示在交替的蓝色色调。</p>
<p>​    <strong>•对插值多项式的控制不是局部的。改变样条开始的一个点会影响整个样条。基数样条是局部的:样条上的任何位置最多受四个相邻点的影响。</strong></p>
<p>​    <strong>•对插值多项式的评估不是局部的。求多项式上的一个点需要访问它的所有点。在分段曲线上计算一个点需要固定的少量计算，不管总点数有多大。</strong></p>
<p><strong>在使用插值样条时，随着点的数量增加，还有许多其他的数值和技术问题。更多信息请参阅De Boor(2001)。</strong></p>
<p><strong>基数样条有一个缺点，它不能插值第一个或最后一个点，这可以很容易地通过在序列的任何一端添加一个额外的点来固定。基数样条也不是连续的——只在结点处提供C¹连续性。</strong></p>
<h2 id="Approximating-Curves-近似曲线"><a href="#Approximating-Curves-近似曲线" class="headerlink" title="Approximating Curves 近似曲线"></a>Approximating Curves 近似曲线</h2><p><strong>控制曲线最简单的方法似乎是指定一组点来进行插值。然而，在实践中，插值方案往往有不理想的特性，因为它们的连续性较差，并且无法控制点之间发生的情况。通常首选只近似于点的曲线方案。在近似方案中，控制点影响曲线的形状，但不精确地指定它。虽然我们放弃了直接指定要通过的曲线点的能力，但我们获得了更好的曲线行为和局部控制。如果我们需要插值一组点，可以计算控制点的位置，使曲线通过这些插值点。</strong></p>
<p><strong>计算机图形学中两种最重要的近似曲线是B´ezier曲线和B样条曲线。</strong></p>
<h3 id="B´ezier-Curves-贝塞尔曲线"><a href="#B´ezier-Curves-贝塞尔曲线" class="headerlink" title="B´ezier Curves 贝塞尔曲线"></a>B´ezier Curves 贝塞尔曲线</h3><p><strong>B´ezier曲线是计算机图形学中自由曲线最常见的表现形式之一。这些曲线以Pierre B´ezier的名字命名，他是这些曲线发展的重要贡献者之一。B´ezier曲线有一个有趣的历史，它们是由几个独立的小组同时开发的。</strong></p>
<p><strong>B´ezier曲线是近似其控制点的多项式曲线。这些曲线可以是任意次的多项式。d度曲线由d + 1个控制点控制。曲线插入它的第一个和最后一个控制点，并且形状直接受到其他点的影响。</strong></p>
<p><strong>通常，复杂的形状是由一些低度B´ezier曲线连接而成的，在计算机图形学中，三次(d = 3) B´ezier曲线通常用于这一目的。许多流行的插图程序，如Adobe Illustrator和字体表示方案，如Postscript中使用的，使用二次B´ezier曲线。B´ezier曲线在计算机图形学中非常受欢迎，因为它们易于控制，有许多有用的属性，并且有非常有效的算法来处理它们。</strong></p>
<p><strong>B´ezier曲线是这样构造的:</strong></p>
<p>​    <strong>•曲线插值第一个和最后一个控制点，u分别为0和1。</strong> </p>
<p>​    <strong>•曲线开始(结束)处的一阶导数由第一个和第二个控制点(倒数第二个和倒数第二个控制点)之间的向量决定。导数是由这些点之间的向量根据曲线的度数缩放得到的。</strong></p>
<p>​    <strong>•曲线起点(终点)的高阶导数取决于曲线起点(终点)的点。n^th 导数取决于前(后)n + 1个点。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111515.png" class="" title="image-20211011111515">

<p>三次B´ezier曲线由四个点控制。它插值第一和最后，开始和最终的导数是前两个(或后两个)点之间向量的三倍。</p>
<p><strong>例如，考虑上图中3度(立方)的B´ezier曲线。曲线有四个(d + 1)控制点。它从第一个控制点(p0)，并以最后(p1)．开始时的一阶导数与第一和第二控制点(p1 −p0)．具体来说，f′(0) = 3(p1 −p0)．类似地，曲线末端的一阶导数是由f ′(1) = 3(p3 −p2)．曲线开始处的二阶导数可以由控制点p0，p1 和p2确定．</strong></p>
<p><strong>利用上一段关于B´ezier三次方程的事实，我们可以使用第15.5节的方法为它们创建一个参数函数。定义由开始和结束的插值和导数给出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111715.png" class="" title="image-20211011111715">

<p><strong>这可以用基矩阵来求解</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111725.png" class="" title="image-20211011111725">

<p><strong>然后写成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111740.png" class="" title="image-20211011111740">

<p><strong>或</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111750.png" class="" title="image-20211011111750">

<p><strong>bi,3 是3级B´ezier混合函数:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111800.png" class="" title="image-20211011111800">

<p><strong>幸运的是，B´ezier曲线的混合函数有一种特殊的形式，适用于所有程度。这些函数被称为伯恩斯坦基多项式，并具有一般形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111926.png" class="" title="image-20211011111926">

<p><strong>其中n为B´ezier曲线的阶数，k为0和n(含)之间的混合函数数。C(n, k)为二项式系数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111935.png" class="" title="image-20211011111935">

<p><strong>已知控制点pk的位置，求n阶(n + 1个控制点)B´ezier曲线的函数为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011111946.png" class="" title="image-20211011111946">

<p><strong>一些B´ezier片段如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112027.png" class="" title="image-20211011112027">

<p>2-6度的各种B´ezier片段。控制点用十字形显示，控制多边形(连接控制点的线段)也显示出来。</p>
<p><strong>B´ezier片段有几个有用的属性:</strong></p>
<p>​    <strong>•曲线以控制点的凸包为界。</strong> </p>
<p>​    <strong>•直线与曲线相交的次数不超过与控制点相连的线段集相交的次数。这叫做变分递减性质。该属性如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112134.png" class="" title="image-20211011112134">

<p>B´ezier曲线的变化递减特性意味着曲线不会比它的控制多边形更越过一条线。因此，如果控制多边形没有“摆动”，曲线上也不会有它们。B样条(第15.6.2节)也具有这个属性。</p>
<p>​    <strong>•曲线是对称的:反向控制点的顺序产生相同的曲线，具有反向的参数化。</strong></p>
<p>​    <strong>•曲线是仿射不变的。这意味着平移、缩放、旋转或倾斜控制点与在曲线上执行这些操作是相同的。</strong></p>
<p>​    <strong>•有很好的简单的算法来评估和细分B´ezier曲线到块本身是B´ezier曲线。因为细分 可以使用后面描述的算法有效地完成，分治方法可以用于创建重要任务的有效算法，如绘制B´ezier曲线，用线段逼近它们，并确定两条曲线之间的交集。</strong></p>
<p><strong>当B´ezier段连接在一起形成一个样条时，段之间的连通性通过共享端点创建。然而，导数的连续性必须通过定位其他控制点来实现。这为B´ezier样条的用户提供了平滑的控制。对于G¹连续性，第一条曲线的倒数第二点和第二条曲线的第二点必须与等值的端点共线。对于C′ 连续，点之间的距离也必须相等。如下图所示。适当地定位更多的点可以创造更高的连续性。</strong></p>
 <img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112302.png" class="" title="image-20211011112302">

<p>两个B´ezier片段连接形成C¹样条曲线，因为第一个线段的最后两点之间的向量等于第二个线段的前两点之间的向量。</p>
<h4 id="Geometric-Intuition-for-Bezier-Curves-B´ezier曲线的几何外观"><a href="#Geometric-Intuition-for-Bezier-Curves-B´ezier曲线的几何外观" class="headerlink" title="Geometric Intuition for Bezier Curves B´ezier曲线的几何外观"></a>Geometric Intuition for Bezier Curves B´ezier曲线的几何外观</h4><p><strong>B´ezier曲线可以从几何原理中得到，也可以从上面描述的代数方法中得到。我们概述了几何原理，因为它们提供了关于B´ezier曲线如何工作的直觉。</strong></p>
<p><strong>假设我们有一组控制点，我们想从这些控制点创建一条平滑的曲线。简单地用直线连接点(形成控制多边形)将导致一些非光滑的东西。它会有尖角。我们可以想象通过切掉尖锐的角来“平滑”这个多边形，生成一个更平滑的新多边形，但在数学意义上仍然不是“平滑”的(因为曲线仍然是一个多边形，因此只有C¹)。我们可以重复这个过程，每次生成一个更平滑的多边形，如下图所示。在极限情况下，也就是如果我们无限次重复这个过程，我们会得到一条C¹平滑的曲线。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112528.png" class="" title="image-20211011112528">

<p>二次B´ezier的细分过程。每条线段被分成两半，这些中点是相连的(蓝色的点和线)。内部控制点移动到新线段的中点(橙色点)。</p>
<p><strong>我们对切角所做的就是定义一个细分方案。也就是说，我们通过将简单的曲线分解成更小的部分(例如，细分它)来定义曲线。由此得到的曲线是极限曲线，它是通过无限次应用该过程而得到的。如果细分方案定义正确，结果将是一个平滑的曲线，它将有一个参数形式。</strong></p>
<p><strong>让我们考虑将切角应用于单个角落。给定三分(p0,p1,p2)，我们重复“切掉边角”，如下图所示。在每一步中，我们将每个线段分成两半，连接中点，然后将角点移动到新线段的中点。注意，在这个过程中，引入新的点，移动一次，然后在任何剩余的迭代中保持在这个位置。端点永远不会移动。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112650.png" class="" title="image-20211011112650">

<p>通过反复切割多边形的棱角，我们可以得到一条光滑的曲线。</p>
<p><strong>如果我们计算p2 的“新”位置作为中点的中点，我们得到表达式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112735.png" class="" title="image-20211011112735">

<p><strong>这种结构实际上适用于每段距离的其他比例。如果我们让u是每一段的起点和终点之间的距离也就是我们放置中点的地方，我们可以把这个表达式改写为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112745.png" class="" title="image-20211011112745">

<p><strong>重组项给出了二次B´ezier函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011112759.png" class="" title="image-20211011112759">

<h4 id="The-de-Casteljau-Algorithm-de-Casteljau算法"><a href="#The-de-Casteljau-Algorithm-de-Casteljau算法" class="headerlink" title="The de Casteljau Algorithm de Casteljau算法"></a>The de Casteljau Algorithm de Casteljau算法</h4><p><strong>B´ezier曲线的一个很好的特征是，有一个非常简单和通用的方法来计算和细分它们。这种方法被称为de Casteljau算法，使用一系列线性插值来计算沿着任意顺序的B´ezier曲线。它是前一节中描述的细分方案的推广。</strong></p>
<p><strong>de Casteljau算法首先用直线连接每一个相邻的点集，然后找到这些直线上的u插值点，给出n - 1个点集。这些点被直线连接，这些直线被插值(同样由u)，给出一组n - 2个点。这个过程不断重复，直到有一个点。下图显示了这个过程的说明。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011113445.png" class="" title="image-20211011113445">

<p>一个关于三次B´ezier的de Casteljau算法的说明。左边的图像显示了u = 0.5的构造。右边的图像显示了0.25、0.5和0.75的构造。</p>
<p><strong>计算B´ezier线段上的点的过程也提供了在该点上分割线段的方法。在de Casteljau算法中计算的中间点形成了新的更小的线段的新的控制点，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011113539.png" class="" title="image-20211011113539">

<p>采用de Casteljau算法对三次B´ezier分段进行细分。初始点(黑方块A, B, C和D)被线性插值以产生蓝色圆圈(AB, BC, CD)，线性插值以产生橙色圆圈(AC, BD)，线性插值以给出立方体AD上的点。这个过程还将控制点A,B,C,D的B´ezier段细分为两个控制点A, AB, AC, AD和AD, BD, CD, D的B´ezier段。</p>
<p><strong>B´ezier曲线分割算法的存在使分治算法成为可能。例如，当绘制B´ezier曲线时，它很容易检查曲线是否接近直线，因为它有其凸包为界。如果曲线的控制点都接近共线，则可以将曲线画成直线。否则，曲线可以被分割成更小的块，并且这个过程可以重复。类似的算法可以用来确定两条曲线的交点。由于这类算法的存在，其他曲线表示通常被转换成B´ezier形式进行处理。</strong></p>
<h3 id="B-Splines-B样条"><a href="#B-Splines-B样条" class="headerlink" title="B-Splines B样条"></a>B-Splines B样条</h3><p><strong>B样条提供了一种方法，可以用一个由d次多项式组成的曲线来近似一组n个点，从而使C^(d−1)具有连续性。与前一节的B´ezier样条不同，B样条允许生成任意连续性程度的曲线(几乎达到点的数量)。因此，B样条是指定计算机图形中非常光滑的曲线(高连续性)的首选方法。如果我们想要C² 或更高的曲线，B样条可能是正确的方法。</strong></p>
<p><strong>我们可以用B样条基函数的线性组合来表示曲线。由于这些基函数本身就是样条，所以我们简称它们为基样条或B样条。每个B样条或基函数由一组d阶的d + 1多项式组成。B样条的方法提供了定义这些函数的一般程序。</strong></p>
<p><strong>B样条是指其中一个基函数，而不是由一组b样条线性组合而成的函数。然而，这一术语在计算机图形学中的使用并不一致。通常，“B样条曲线”是指由B样条的线性组合表示的曲线。</strong></p>
<p><strong>将一个多项式表示为其他多项式的线性组合的想法已在15.3.1节和15.3.5节中讨论。将样条表示为其他样条的线性组合，见章节15.4.1。事实上，给出的例子是B样条的一个简单例子。</strong></p>
<p><strong>将一个函数表示为其他函数的线性组合的一般符号是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011114018.png" class="" title="image-20211011114018">

<p><strong>pi 是系数，bi 是基函数。如果系数是点(例如，2或3个向量)，我们将它们称为控制点。使这种方法工作的关键是定义bi 适当。B样条提供了一种非常通用的方法。</strong></p>
<p><strong>可以为若干系数n和参数值k定义一组B样条。k的值比用于制作B样条的多项式的次数多 (k = d + 1)。</strong></p>
<p><strong>B样条很重要，因为它们提供了一种非常通用的方法来创建具有许多有用属性的函数(对于表示曲线很有用)。参数值为k的B样条曲线有n个点:</strong></p>
<p>​    <strong>•是C^(k−2) 连续的;</strong> </p>
<p>​    <strong>•由k - 1次多项式构成;</strong> </p>
<p>​    <strong>•具有局部控制-曲线上的任何位置仅依赖于k个控制点;</strong> </p>
<p>​    <strong>•被点的凸包所包围;</strong> </p>
<p>​    <strong>•显示出图15.12所示的变化递减特性。</strong></p>
<p><strong>使用B样条创建的曲线不一定插值其控制点。</strong></p>
<p><strong>我们将通过先看一个具体的、简单的例子来介绍b样条的概念。然后我们将推广这些方法并说明它们为什么有趣。因为计算B样条的方法是非常普遍的，所以我们推迟引入它，直到我们展示了这些泛化是什么。</strong></p>
<h4 id="Uniform-Linear-B-Splines-统一的线性B样条"><a href="#Uniform-Linear-B-Splines-统一的线性B样条" class="headerlink" title="Uniform Linear B-Splines 统一的线性B样条"></a>Uniform Linear B-Splines 统一的线性B样条</h4><p><strong>考虑以下形式的一组基函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011114628.png" class="" title="image-20211011114628">

<p><strong>每个函数看起来都像一个小三角“帽子”在i和i+2之间，其峰值在i+ 1。每一个都是分段多项式，在i i + 1和i + 2处打结。其中两个如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011114714.png" class="" title="image-20211011114714">

<p>d = 1或k = 2的B样条。</p>
<p><strong>每个函数都是bi,2 为一阶(线性)B样条。因为我们将在后面考虑其他参数值的B样条，所以我们用下标2表示它们。</strong></p>
<p><strong>注意，我们选择将B样条的下缘(它的第一个结)放在i处。因此，第一个B样条(i = 1)的第一个结是在1处。对b样条或系数向量元素的迭代从1到n(见上上公式)。当B样条被实现时，以及在其他许多关于B样条的讨论中，它们通常从0到n−1进行编号。</strong></p>
<p><strong>我们可以使用上上式从n个控制点的集合中创建一个函数，这些函数用于bi 创建一个受系数影响的“整体函数”。如果我们使用这些(k = 2) B样条来定义整个函数，我们将定义一个线性插值系数pi 在t = k和t = n + 1之间的分段多项式函数。注意，当(k = 2) B样条插值它们的所有系数时，更高阶的B样条在某些特定条件下这样做，我们将在第15.6.3节中讨论。</strong></p>
<p><strong>B样条的一些性质可以在这个简单的例子中看到。我们将用参数k和系数或控制点的数目n写成一般形式:</strong></p>
<p><strong>•每个B样条有k + 1个结点。</strong> </p>
<p><strong>•每个B样条在第一个结之前和最后一个结之后都是零。</strong> </p>
<p><strong>•整体样条具有局部控制，因为每个系数只乘以一个B样条，并且这个B样条仅在k + 1节之间是非零的。</strong></p>
<p><strong>•整个样条有n + k个结点。</strong> </p>
<p><strong>•每个B样条为C^(k−2) 连续的，因此整个样条为C^(k−2) 连续的。</strong> </p>
<p><strong>•对于节点k和n+1之间的所有参数值，B样条和为1的集合。这个范围是有k条B样条是非零的。求和为1是很重要的，因为这意味着B样条是平移不变的:平移控制点将平移整个曲线。</strong></p>
<p><strong>•在每个结点之间，B样条是一个d = k−1次的单一多项式。因此，整体曲线(将这些加在一起)也可以表示为任意相邻结点之间的单次d多项式。</strong></p>
<p><strong>在这个例子中，我们选择了均匀间隔的结点。稍后我们将讨论非均匀间距的B样条。当结间距是均匀的，每个B样条都是相同的，除了移位。具有均匀结点间距的B样条有时称为均匀B样条或周期B样条。</strong></p>
<h4 id="Uniform-Quadratic-B-Splines-二次均匀B样条"><a href="#Uniform-Quadratic-B-Splines-二次均匀B样条" class="headerlink" title="Uniform Quadratic B-Splines 二次均匀B样条"></a>Uniform Quadratic B-Splines 二次均匀B样条</h4><p><strong>前一节中列出的B样条的性质是特意为任意n和k编写的。构造B样条的一般过程将在稍后提供，但首先，让我们考虑k = 3的另一种特殊情况。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132249.png" class="" title="image-20211011132249">

<p>均匀结点间距的B样条b2,3。</p>
<p><strong>B样条2,3 如上图所示。它是由二次块(2度)组成的，有三个。这是C¹ 连续的，并且只在它跨越的四个节内是非零的。请注意，二次B样条由三块组成，一块在结1和2之间，一块在结2和3之间，一块在结3和4之间。在第15.6.3节中，我们将看到构建这些函数的一般过程。现在，我们简单地检查以下函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132341.png" class="" title="image-20211011132341">

<p><strong>为了使表达式更简单，我们把函数的每一部分都写成在0到1的范围内。</strong></p>
<p><strong>如果我们计算由B样条之和组成的整体函数，在任何时候只有k(本例中为3)是非零的。一个在上方程的第一部分，一个在第二部分，一个在第三部分。因此，我们可以把整个函数的任何一部分看作是存在的由一个依赖于k个系数的d = k−1次多项式组成。对于k = 3的情况，我们可以这样写</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132437.png" class="" title="image-20211011132437">

<p><strong>其中u = t−i。它定义了当i≤t &lt; i+1时整个函数的一部分。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132532.png" class="" title="image-20211011132532">

<p>7条B样条的集合，k = 3，结点间距均匀[1,2,3,4,5,6,7,8,10]</p>
<p><strong>如果我们有一组n个点，我们可以用B样条来创建一条曲线。如果我们有7个点，我们需要一组7条B样条。上图显示了k = 3时的一组7条B样条。注意到有n + k(10)个结点，B样条的和在k到n + 1的范围内是1(结点3到8)。下图显示了使用这些B样条和一组点指定的曲线。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011132544.png" class="" title="image-20211011132544">

<p>由7条二次(k=3) B样条组成的曲线，使用7个控制点。</p>
<h4 id="Uniform-Cubic-B-Splines-均匀三次B样条"><a href="#Uniform-Cubic-B-Splines-均匀三次B样条" class="headerlink" title="Uniform Cubic B-Splines 均匀三次B样条"></a>Uniform Cubic B-Splines 均匀三次B样条</h4><p><strong>由于三次多项式在计算机图形学中非常流行，因此k = 4的B样条的特殊情况是非常重要的，因此我们在讨论一般情况之前考虑它。三次B样条由四个三次多项式块定义。决定这些部分的一般过程稍后描述，但结果是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133009.png" class="" title="image-20211011133009">

<p><strong>度3 B样条曲线在下图中为i = 1绘制。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133135.png" class="" title="image-20211011133135">

<p>具有均匀结的三次(k = 4) B样条。</p>
<p><strong>我们可以将节点i + 3和i + 4之间的整体曲线的函数写成参数u在0到1之间的函数以及影响它的四个控制点的函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133023.png" class="" title="image-20211011133023">

<p><strong>这可以用前面几节的矩阵表示法重写，给出三次B样条的基矩阵</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133033.png" class="" title="image-20211011133033">

<p><strong>与第15.5节中从约束中导出的矩阵不同，这个矩阵是由下一节中定义的一般B样条程序确定的多项式创建的。</strong></p>
<h3 id="Nonuniform-B-Splines-非均匀B样条"><a href="#Nonuniform-B-Splines-非均匀B样条" class="headerlink" title="Nonuniform B-Splines 非均匀B样条"></a>Nonuniform B-Splines 非均匀B样条</h3><p><strong>B样条的一个很好的特征是它们可以被定义为任何k&gt; 1。因此，如果我们需要一条更平滑的曲线，我们只需增加k的值，如图15.23所示。</strong></p>
<p><strong>到目前为止，我们已经说过B样条可推广到任何k&gt; 1和任何n≥d。在我们展示如何实际计算这些B样条之前，还要介绍最后一个推广。B样条定义为任何非递减结向量。</strong></p>
<p><strong>对于给定的n和k, B样条集合(以及由它们的线性组合创建的函数)有n + k个结点。我们可以把这些结点的值写成向量，我们用t表示。对于均匀B样条，结点向量是[1,2,3，…，n + k]。然而，对于长度为n + k的任何结点向量，只要其值是非递减的(例如，ti+1 ≥ti)．</strong></p>
<p><strong>有两个主要原因非均匀结间距是有用的:它让我们控制参数范围每个系数影响的整体功能,它允许我们重复节(例如,创建节之间没有间隔的)以创建函数不同的属性在这些点。后者将在本节稍后讨论。</strong></p>
<p><strong>为B样条指定结点值的能力类似于为插值样条曲线指定插值点的能力。它允许我们将曲线特征与参数值联系起来。通过指定非均匀结向量，我们指定B样条曲线的每个系数影响的参数范围。记住B样条i只在结点i和结点i + k之间是非零的，因此，与它相关的系数只影响这些参数值之间的曲线。</strong></p>
<p><strong>对结值的控制特别有用的一个地方是在序列开始处插入或删除结。为了说明这一点，考虑a如第15.6.2节所述，使用线性B样条(k = 2)定义的曲线。对于n = 4，均匀结向量是[1,2,3,4,5,6]。这条曲线由四个点控制，参数范围为t = 2到t = 5。曲线(t = 5)的“末端”插入最后一个控制点。如果我们在点集的中间插入一个新的点，我们将需要一个更长的结向量。B样条的局域性可以防止这种插入影响曲线端点的值。较长的曲线仍然会在其末端插入最后一个控制点。但是，如果我们选择保持均匀的结点间距，则新的结点向量为[1,2,3,4,5,6,7]。曲线的末端将在t = 6处，最后一个控制点所插入的参数值将与插入前的参数值不同。对于非均匀的结间距，我们可以使用结向量[1,2,3,3.5,4,5,6]，这样曲线的端点不受变化的影响。具有非均匀结点间距的能力使得B样条的局部性既具有代数性质，又具有几何性质。</strong></p>
<p><strong>现在我们介绍定义B样条的一般方法。给定系数n、B样条参数k和结点向量t(长度为n + k)的值，下列递归方程定义B样条:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133615.png" class="" title="image-20211011133615">

<p><strong>这个方程叫做Cox-de Boor递归式。它可以用来计算特定B样条的特定值。然而，它更常用于代数推导方程，如方程上上和上上上两式。</strong></p>
<p><strong>例如，考虑如何导出上上上式。使用一个均匀结向量[1,2,3，…]，ti = i，则上式中的k = 3得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133721.png" class="" title="image-20211011133721">

<p><strong>继续递归式，我们必须对递归表达式求值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133744.png" class="" title="image-20211011133744">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133754.png" class="" title="image-20211011133754">

<p><strong>将这些结果代入上式得到:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133843.png" class="" title="image-20211011133843">

<p>*<em>要知道这个表达式等价于15.17式，我们注意到每个(k = 1) B样条就像一个开关，只在特定的参数范围内打开。例如,乙</em>i,<em>1 在I和I + 1之间只有非零。所以，如果i≤t &lt; i + 1，表达式中只有(k = 1) b样条中的第一个是非零的，所以</em>*</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011133852.png" class="" title="image-20211011133852">

<p><strong>类似的操作给出了15.17式的其他部分。</strong></p>
<h4 id="Repeated-Knots-and-B-Spline-Interpolation-重复结点和B样条插值"><a href="#Repeated-Knots-and-B-Spline-Interpolation-重复结点和B样条插值" class="headerlink" title="Repeated Knots and B-Spline Interpolation 重复结点和B样条插值"></a>Repeated Knots and B-Spline Interpolation 重复结点和B样条插值</h4><p><strong>虽然B样条有许多很好的特性，但使用它们定义的函数通常不会插值系数。如果我们要用它们来定义一条曲线来插值一个特定的点，这可能会很不方便。我们简要介绍了如何使用B样条插值特定的点。更完整的讨论可以在章节注释中列出的书中找到。</strong></p>
<p><strong>使B样条插值其系数的一种方法是重复打结。如果一个特定b样条的所有内部结点都有相同的值，那么整个函数将插值这个B样条的系数。如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011134057.png" class="" title="image-20211011134057">

<p>由7个控制点的二次b样条(k = 3)参数化的曲线。在左边，使用均匀结向量[1,2,3,4,5,6,7,8,9,10]。右侧为非均匀结间距[1,2,3,4,4,6,7,8,8,10]重复第4和第8个结点意味着第3和第7个B样条的所有内部结点都是相等的，所以曲线插值与这些点相关的控制点。</p>
<p><strong>重复结点的插值代价很高:它消除了B样条的光滑性以及由此产生的整体函数和表示曲线。然而，在样条的开始和结束，连续性不是一个问题，结重复是有用的创建端点插值B样条。虽然第一个(或最后一个)结点的值对插补并不重要，为了简单起见，我们让第一个(或最后一个)k个结点具有相同的值来实现插补。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011134352.png" class="" title="image-20211011134352">

<p>端点插值二次(k = 3) b样条，对于n = 8。结向量是[0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 6]。前两个B样条和后两个B样条是非周期性的，而中间四个B样条(如虚线所示)是周期性的，与图15.20中的B样条相同。</p>
<p><strong>端点插值二次B样条如上图所示。前两个B样条和后两个B样条不同于均匀B样条。他们的表达,通过使用Cox-de Boor递归式可以推导出:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011134411.png" class="" title="image-20211011134411">

<h3 id="NURBS"><a href="#NURBS" class="headerlink" title="NURBS"></a>NURBS</h3><p><strong>尽管B样条提供了所有的一般性，但仍有一些函数不能用它们精确地表示。特别是b样条不能代表圆锥截面。为了表示这样的曲线，使用了两个多项式的比率。非均匀B样条被用来表示分子和分母。最普遍的形式是非均匀有理B样条，简称为NURBS。</strong></p>
<p><strong>NURBS与标量权值hi 相关联使用相同的B样条:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211011134727.png" class="" title="image-20211011134727">

<p><strong>bi,k,t 为参数k和结向量t的B样条。</strong><br><strong>在几何建模中，NURBS被广泛地用于表示曲线和曲面，因为除了B样条的有用特性外，它们还提供了惊人的通用性。</strong></p>
<h2 id="Summary-总结"><a href="#Summary-总结" class="headerlink" title="Summary 总结"></a>Summary 总结</h2><p><strong>在本章中，我们讨论了自由形式曲线的一些表示。对于计算机图形学来说，最重要的是:</strong></p>
<p>​    <strong>•基数样条使用一组立方块来插值控制点。它们通常比插值多项式更可取，因为它们是局部的，更容易计算。</strong></p>
<p>​    <strong>•B´ezier曲线近似它们的控制点，并有许多有用的属性和相关算法。由于这个原因，它们在图形应用程序中很受欢迎。</strong></p>
<p>​    <strong>•B样条曲线将曲线表示为b样条函数的线性组合。它们是一般的，有许多有用的性质，如凸包和变分递减。当需要光滑曲线时，通常使用B样条。</strong></p>
<h1 id="16-Computer-Animation-计算机动画"><a href="#16-Computer-Animation-计算机动画" class="headerlink" title="16 Computer Animation 计算机动画"></a>16 Computer Animation 计算机动画</h1><p><strong>动画来源于拉丁语anima，意为赋予生命、兴趣、精神、运动或活动的行为、过程或结果。运动是生命的定义属性，动画的真正艺术主要是关于如何通过运动来讲述故事、表现情感，甚至表达人类性格的微妙细节。计算机是实现这些目标的辅助工具——一个熟练的动画师可以使用它来帮助更快地得到他想要的结果，而不必专注于他不感兴趣的技术细节。没有电脑的动画，也就是现在经常被称为“传统”的动画，有着悠久而丰富的历史，不断被数以百计的活跃在这门艺术中的人所写。正如在任何既定领域一样，已经明确了一些经过时间考验的规则，这些规则为如何做某些事情和应避免哪些事情提供了一般的高层指导。传统动画的这些原则同样适用于计算机动画，我们将在本章讨论其中的一些。</strong></p>
<p><strong>然而，计算机不仅仅是一个工具。除了让动画师的主要任务变得不那么乏味外，计算机还添加了一些以前无法获得或很难获得的真正独特的能力。现代建模工具允许相对容易创建详细的三维模型,渲染算法可以产生一系列令人印象深刻的表象,从完全逼真到高度程式化,强大的数值模拟算法可以帮助为特别难以产生预期的基于物理运动动画对象和动作捕捉系统的能力记录和使用真实的动作。这些发展导致了计算机动画技术在电影和广告、汽车设计和建筑、医学和科学研究等许多领域的爆炸式应用。全新的领域和应用也出现了，包括全电脑动画电影，虚拟/增强现实系统，当然还有电脑游戏。</strong></p>
<p><strong>本书的其他章节更直接地涵盖了上面提到的许多发展(例如，几何建模和渲染)。在这里，我们只提供一个概述的技术和算法直接用于创建和操纵运动。特别地，我们将粗略区分并简要描述四种主要的计算机动画方法:</strong></p>
<p>​    <strong>•关键帧为动画师提供了最直接的控制，他们在某些时刻提供了必要的数据，而计算机填补了其余的时间。</strong></p>
<p>​    <strong>•程序动画涉及专门设计的，通常是经验的，数学函数和程序，其输出类似于某些特定的运动。</strong></p>
<p>​    <strong>•基于物理的技术求解运动微分方程。</strong> </p>
<p>​    <strong>•动作捕捉使用特殊的设备或技术来记录真实世界的动作，然后将这个动作转换到计算机模型中。</strong> </p>
<p><strong>我们在这里完全不涉及这个领域的艺术方面。一般来说，我们不可能在这里做更多，而仅仅是对用计算机创造运动这一迷人主题的皮毛。我们希望真正对这一主题感兴趣的读者能够在本章内容之外继续他们的旅程。</strong></p>
<h2 id="Principles-of-Animation-动画原理"><a href="#Principles-of-Animation-动画原理" class="headerlink" title="Principles of Animation 动画原理"></a>Principles of Animation 动画原理</h2><p><strong>John Lasseter在他1987年的SIGGRAPH论文(Lasseter, 1987)中提出了早在20世纪30年代由迪士尼工作室的传统动画师开发的关键原则，引起了当时刚刚起步的电脑动画社区的注意。12个原则被提及:挤压和伸展，节奏，预期，跟随和重叠动作，慢进和慢出，舞台，弧线，次级动作，直线前进和姿势对姿势的动作，夸张，扎实的绘画技巧，和吸引力。近20年过去了，这些经过时间考验的规则依然重要，它们可以将自然而有趣的动画与机械而乏味的动画区别开来。另外，对于计算机动画来说，平衡控制和灵活性的赋予是非常重要的动画师充分利用计算机的能力。虽然这些原则是众所周知的，但许多因素影响着在实践中对这些规则的重视程度。虽然制作故事片的角色动画师可能会花很多时间遵循这些建议(游戏邦注:例如调整自己的时间)，但许多游戏设计师倾向于将时间花在其他地方。</strong></p>
<h3 id="Timing-节奏"><a href="#Timing-节奏" class="headerlink" title="Timing 节奏"></a>Timing 节奏</h3><p><strong>节奏，或者说动作的速度，是任何动画的核心。事情发生的速度会影响行动的意义、情绪状态，甚至是相关物体的感知重量。同样的动作，角色的头从左向右转，取决于其速度，可以意味着任何反应，从被重物击中到缓慢地在书架上寻找一本书或伸展颈部肌肉。为手头的具体行动设定适当的时间是非常重要的。动作要占用足够的时间来引起注意，同时要避免动作过于缓慢和潜在的无聊。对于涉及录制声音的计算机动画项目，声音提供了一个自然的时间锚。事实上，在大多数制作中，演员的声音首先被记录下来，然后完整的动画被同步到这个记录中。由于大而重的物体往往比小而轻的物体移动得慢(更准确地说，加速度更小)，计时可以用来提供有关物体重量的重要信息。</strong></p>
<h3 id="Action-Layout-行动布局"><a href="#Action-Layout-行动布局" class="headerlink" title="Action Layout 行动布局"></a>Action Layout 行动布局</h3><p><strong>在动画的任何时刻，观众都应该清楚地知道所呈现的是什么想法(情感、情绪、表情)。好的阶段，或高层次的行动计划，应该引导观众的眼睛到当前重要的行动集中的地方，有效地告诉他“看看这个，现在，看看这个”，而不使用任何语言。对人类感知的一些熟悉可以帮助我们完成这项艰巨的任务。由于人类的视觉系统主要对相对变化而不是刺激的绝对值做出反应，所以在静止的环境中突然运动或在繁忙的场景中某些部分缺乏运动，自然会引起人们的注意。呈现相同的动作，所以物体的轮廓变化通常比正面的安排更引人注目(见下图(左下角))。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012122313.png" class="" title="image-20211012122313">

<p>行动的布局。左:恰当地安排动作对于引起人们对当前重要动作的注意至关重要。举起手的动作在顶部会很明显，但在底部则很难注意到。相反，在第一种情况下，鼻子长度的变化可能是完全看不见的。注意，这可能是故意隐藏的，例如，稍后突然显示出来。如果两个议案都要处理，那么这两种安排都不是特别好。中:预期的多少可以说明接下来的动作。接下来的动作(扔球)很短，但很清楚将要发生什么。角色越紧张，接下来的动作就会越快。右图:后续阶段对次要附属物(头发)尤其重要，它的运动跟随主导部分(头部)。头部的运动非常简单，但会导致头发本身的不平凡的跟随行为。在这种情况下，如果没有后续阶段和重叠动作，就不可能创建一个自然的动画。Peter Shirley和Christina Villarruel提供的数字。</p>
<p><strong>在较低的层次上，每个动作可以分为三个部分:预期(动作的准备)、动作本身和后续(动作的终止)。在许多情况下，动作本身是最短的部分，从某种意义上说，最有趣的。例如，踢足球可能需要踢球者进行大量的准备工作，对即将离开的球进行长时间的“视觉追踪”，并有足够的机会显示当时的压力、踢球者的情绪状态，甚至是对行动预期结果的反应。动作本身(腿踢球的动作)是相当简单的，在这种情况下只需要几分之一秒。</strong></p>
<p><strong>预期的目的是让观众对将要发生的事情有所准备。如果动作本身非常快，这一点就变得尤为重要重要的，或极其困难的。为这些操作创建更广泛的预期可以突出这些属性，并且在快速事件的情况下，可以确保操作不会被遗漏(参见上图(底部中间))。</strong></p>
<p><strong>在现实生活中，主要动作通常会导致一个或多个其他重叠动作。物体的不同附属物或松散部分通常拖在主要引导部分的后面，并在如上图(右下)所示的主要动作的后续部分继续移动一段时间。此外，下一个动作通常在前一个动作完全结束之前就开始了。一个球员可能会在他还在追踪他刚刚踢出的球的时候开始奔跑。忽略这种自然流动通常会被认为是动作之间有停顿，并可能导致类似机器人的机械运动。虽然重叠是保持动作自然的必要条件，但动画师通常会添加次要动作，使动作更有趣，并实现动画的现实复杂性。重要的是不要让次要动作支配主要动作。</strong></p>
<h3 id="Animation-Techniques-动画技术"><a href="#Animation-Techniques-动画技术" class="headerlink" title="Animation Techniques 动画技术"></a>Animation Techniques 动画技术</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123048.png" class="" title="image-20211012123048">

<p>应用壁球的经典例子和拉伸原理。注意，弹跳球的体积应该在整个动画中保持大致相同。</p>
<p><strong>一些特定的技术可以用来使动作看起来更自然。最重要的可能是挤压和拉伸，这意味着在移动的物体移动时，以特定的方式改变其形状。人们通常会沿着运动方向拉伸一个物体，并在施加一个力时将其压扁，如上图所示，这是一个弹跳球的经典动画。重要的是要保持总体积，因为这发生，以避免幻觉的增长或缩小的对象。运动的速度(或力)越大，施加的拉伸(或挤压)就越多。使用这种变形有几个原因。对于非常快的运动，一个物体可以在两个连续的帧之间快速移动，以至于在当前帧和前一帧之间没有重叠，这可能导致频闪(走样的一种变体)。物体在运动方向上被拉长可以确保更好的重叠，并帮助眼睛对抗这种不愉快的效果。拉伸/挤压也可以用来显示物体的灵活性，对柔韧的材料应用更多的变形。如果物体看起来是刚性的，那么当它移动时，它的形状就会故意保持不变。</strong></p>
<p><strong>自然运动很少发生在直线上，所以在动画中应该避免使用弧线。同样，在现实世界中，没有任何运动可以瞬间改变速度——这需要对物体施加无限大的力。在动画中也要避免这种情况。特别是，运动应该逐渐开始和结束(缓慢的进和出)。而手绘动画有时是通过直接的动作完成的动画师从第一帧开始，连续绘制一帧接着一帧，直到最后一帧，姿势对姿势的动作，也被称为关键帧，更适合于计算机动画。在这种技术中，动画是通过一系列相对稀疏的关键帧来精心规划的，只有在设置了关键帧之后，动画的其余部分(中间帧)才会被填充(下图)。这允许更精确的计时，并允许计算机使用下一节介绍的算法来处理过程中最乏味的部分——创建中间帧。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123150.png" class="" title="image-20211012123150">

<p>关键帧(顶部)鼓励详细行动计划，而直接的行动(下)导致一个更自发的结果。</p>
<p><strong>以上提到的几乎所有技术都可以通过适当的夸张来实现更大的艺术效果，或强调动作或角色的某些特定属性。最终目标是实现观众想要看到的东西，吸引人的东西。角色或动作的极端复杂性或过于对称往往不太吸引人。为了创造好的效果，传统的动画师需要扎实的绘画技能。类似地，一个计算机动画师当然应该理解计算机图形学，并且对他使用的工具有扎实的知识。</strong></p>
<h3 id="Animator-Control-vs-Automatic-Methods-动画控制vs-自动方法"><a href="#Animator-Control-vs-Automatic-Methods-动画控制vs-自动方法" class="headerlink" title="Animator Control vs. Automatic Methods 动画控制vs.自动方法"></a>Animator Control vs. Automatic Methods 动画控制vs.自动方法</h3><p><strong>在传统动画中，动画师完全控制制作过程的各个方面，没有什么能阻止最终产品按照计划中的每个细节制作。为这种灵活性付出的代价是，每一个框架都是手工创建的，这导致了一个极其耗时和劳动的企业。在计算机动画中,有一个明确的权衡,一方面,给一个动画师更直接的控制结果,但要求他提供更多的工作,另一方面,依靠更自动化的技术可能需要设置几个输入参数,但提供很少或没有控制结果的一些属性。一个好的算法应该提供足够的灵活性，同时只要求动画师提供直观、容易提供的信息，以及动画师自己认为是实现预期效果所必需的信息。虽然在实践中不太可能完全符合这一要求，因为它可能需要接近读心术的机器，但我们鼓励读者从提供这种平衡的角度来评估任何计算机动画技术。</strong></p>
<h2 id="Keyframing-关键帧"><a href="#Keyframing-关键帧" class="headerlink" title="Keyframing 关键帧"></a>Keyframing 关键帧</h2><p><strong>术语“关键帧”在应用于3D计算机动画时可能会产生误导，因为没有实际完成的帧(例如。例如，图像)。在任何给定时刻,一个3d场景动画是由一组数字:指定的位置的中心对象,他们的RGB颜色,扩展应用到每个对象的数量在每个轴,建模复杂对象的不同部分之间的转换,相机位置和姿态,光源强度等。为了使场景动画化，这些值的一些子集必须随着时间而改变。当然，我们可以在每一帧中直接设置这些值，但这并不是特别有效。除此之外，一些重要的时刻(关键帧tk)可以沿着动画的时间轴选择每个参数和该参数的值(关键值fk)只设置这些选定的帧。我们称之为一个组合(tkfk)的关键帧和关键值只是一个关键。对于不同的参数，关键帧不一定是相同的，但至少同时设置其中一些关键帧是合乎逻辑的。例如，为特定对象的x、y和z坐标选择的关键帧可能被设置在形成单个位置矢量键(tk,pk)的完全相同的帧。然而，这些关键帧可能与为对象的方向或颜色选择的帧完全不同。关键帧之间的距离越近，动画师对结果的控制就越强;然而，必须评估更多设置关键的工作的成本。因此，动画中相对简单的部分的键之间通常有较大的间距，将它们集中在复杂动作发生的间隔中，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123541.png" class="" title="image-20211012123541">

<p>不同模式的设置键(上面的黑色圆圈)可以同时用于相同的场景。假设在这部分之前和之后都有更多的帧。</p>
<p><strong>一旦动画师设置了关键帧(tk,fk)，系统必须计算所有其他帧的f值。虽然我们最终只对一组离散的值感兴趣，但将其视为经典插值问题是很方便的，它通过提供的一组数据点来拟合连续动画曲线f(t)(下图)。关于曲线拟合算法的广泛讨论可以在第一章中找到15分钟，这里就不重复了。因为动画器最初只提供键而不提供导数(切线)，所以直接从键计算所有必要信息的方法对于动画来说更可取。参数沿曲线变化的速度由曲线对时间的导数(df/dt)给出。因此，为了避免速度的突然跳跃，C¹ 连续性通常是必要的。动画曲线通常不需要更高程度的连续性，因为二阶导数(对应于加速度或施加的力)在现实世界中可能会经历非常突然的变化(球撞到坚实的墙壁)，而更高的导数并不直接对应于物理运动的任何参数。这些考虑使Catmull-Rom样条曲线成为初始动画曲线创建的最佳选择之一。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123552.png" class="" title="image-20211012123552">

<p>曲线f(t)是通过动画师提供的关键帧匹配的，即使只有在帧位置的值是感兴趣的。该函数的导数给出了参数变化的速度，并首先由拟合程序自动确定。</p>
<p><strong>大多数动画系统都允许动画师对初始曲线进行交互式精细编辑，包括插入更多键、调整现有键或修改自动计算的切线。另一种有助于调整曲线形状的有用技术叫做TCB控制(TCB代表张力、连续性和偏差)。这个想法是引入三个新的参数，可以用来修改曲线的形状附近的关键，通过协调调整进入和出切线在这一点。对于时间均匀间隔的键，它们之间的距离为Δt，输入Ti^in 的标准Catmull-Rom表达式和外向的Ti^out 在内部键(tk,fk)可以重写为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123912.png" class="" title="image-20211012123912">

<p><strong>TCB样条的修正切线为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012123924.png" class="" title="image-20211012123924">

<p><strong>张力参数t通过缩放进线和出线的切线来控制键附近曲线的锐度。较大的切线(较低的张力)导致键附近较平坦的曲线形状。偏置b允许动画师有选择地增加键的相邻键的权重，将曲线拉得更接近连接键与其左邻(b接近1，“超过”动作)或右邻(b接近−1，“低于”动作)的直线。连续值c的非零值使得进出的切线不同，允许动画师在曲线的键值处创建扭结。TCB参数的实际有用值通常限于区间[−1;1]，默认t = c = b = 0对应于原始的Catmull-Rom样条。下图显示了可能的曲线形状调整的例子。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012124024.png" class="" title="image-20211012124024">

<p>使用TCB控件编辑默认插值样条(中间列)。注意，所有的关键帧都保持在相同的位置。</p>
<h3 id="Motion-Controls-运动控制"><a href="#Motion-Controls-运动控制" class="headerlink" title="Motion Controls 运动控制"></a>Motion Controls 运动控制</h3><p><strong>到目前为止，我们已经描述了如何通过键定位和微调键的切线值来控制动画曲线的形状。然而，当一个人想要同时控制物体的移动方向时，这通常是不够的。它的路径，以及它沿着这条路径移动的速度。给定空间中的一组位置作为关键帧，自动曲线拟合技术可以通过它们来拟合曲线，但由此产生的运动只能通过迫使对象在相应的关键帧tk处到达指定的关键位置pk来约束，没有直接说明按键之间的移动速度。这可能会产生问题。例如，如果一个物体沿着x轴以每秒11米的速度移动1秒，然后以每秒1米的速度移动9秒，它将在10秒后到达x = 20的位置，从而满足动画师的关键帧(0,0)和(10,20)。这种不稳定的运动不太可能是真正想要的，速度为2米/秒的匀速运动可能更接近动画师设置这些键时想要的效果。虽然通常不显示这种极端行为，由标准拟合程序得出的多项式曲线确实显示出按键之间的非匀速运动，如下图所示。虽然这可以容许(在一定范围内)对一些参数的人类视觉系统不是很好确定速度不均匀性的变化(如颜色甚至旋转速度),我们必须做得更好位置p对象的速度直接对应于日常经验。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012132922.png" class="" title="image-20211012132922">

<p>所有三个运动都沿着相同的二维方向路径并满足黑色三角形尖端的键集。白色三角形的尖端以Δt = 1的间隔显示对象的位置。按键之间的匀速运动可能更接近动画师的要求，但自动装配程序可能导致其他两个动作中的任何一个。</p>
<p><strong>我们将首先区分拟合过程中使用的曲线参数化和动画中使用的曲线参数化。当一条曲线通过位置键拟合时，我们将结果写成某个参数u的函数p(u)。这将描述曲线在空间中的几何形状。弧长s是曲线的物理长度。动画师控制沿着现有曲线运动的一个自然方法是指定一个额外的函数s(t)，它对应于物体在任何给定时间沿着曲线应该走多远。为了得到空间中的实际位置，我们还需要一个辅助函数u(s)，它计算给定弧长s下的参数值u。然后将这些函数组合起来，给出给定时间t下计算物体位置的完整过程(见下图):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012133022.png" class="" title="image-20211012133022">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012133034.png" class="" title="image-20211012133034">

<p>为了获得给定时间t的空间位置，首先利用用户指定的运动控制来获得沿着曲线s(t)的距离，然后计算相应的曲线参数值u (s (t))。先前拟合的曲线P(u)现在可用来求位置P(u(s(t)))。</p>
<p><strong>可以使用几个标准函数作为距离-时间函数s(t)。其中最简单的是与恒定速度对应的线性函数:s(t) = vt, v = const。另一个常见的例子是恒定加速度a(和初始速度v0)的运动由抛物线s(t) = v0t +at²/ 2。由于速度在这里是逐渐变化的，这个函数可以帮助模拟理想的放松进入和放松退出行为。更一般地，s(t)的斜率给出了与沿曲线向后运动相对应的负斜率的运动速度。要达到最大的灵活性，就要有能力交互式编辑通常是由动画系统提供给动画师的。距离-时间函数并不是控制运动的唯一方法。在某些情况下，用户指定一个速度-时间函数v(t)或加速度-时间函数a(t)可能更方便。由于这些对应的是s(t)的一阶和二阶导数，为了使用这些类型的控制，系统首先通过对用户输入进行积分来恢复距离-时间函数(在a(t)的情况下是两次)。</strong></p>
<p><strong>曲线参数u与弧长s的关系由系统自动建立。在实践中，系统首先确定弧长与参数u(即反函数s(u))。利用这个函数，对于任意给定的S，都有可能解出方程s (u)−S = 0，而未知量u是u(S)。对于大多数曲线，函数s(u)不能用封闭解析形式表示，需要进行数值积分(见第14章)。标准的数值寻根程序(例如牛顿-拉夫森方法)可以直接用来求解方程s(u) - S = 0。</strong></p>
<p><strong>另一种方法是将曲线本身近似为点pi 之间的一组线段在一组间距足够密集的参数值ui处计算．然后创建一个近似弧长的表格</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012133656.png" class="" title="image-20211012133656">

<p><strong>由于s(u)是u的一个非递减函数，我们可以通过简单的搜索表找到包含值S的区间(见下图)。然后对区间的u值进行线性插值，最终找到u(S)。如果需要更高的精度，可以采用以这个值为起点的牛顿-拉夫森算法的几个步骤。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012133835.png" class="" title="image-20211012133835">

<p>要创建s(u)的表格版本，这条曲线可以用若干条线段来近似表示，这些线段的连接点位于曲线上的参数增量相等。在表格中查找给定S的u-interval。例如，在上面的曲线中，S = 6.5位置对应的u值位于u = 0.6和u = 0.8之间。</p>
<h3 id="Interpolating-Rotation-插值旋转"><a href="#Interpolating-Rotation-插值旋转" class="headerlink" title="Interpolating Rotation 插值旋转"></a>Interpolating Rotation 插值旋转</h3><p><strong>上面介绍的技术可以用来插入用于描述场景的大多数参数的键集。三维旋转是一种重要的运动，其插值方法和表示方法较为专门。这样做的原因是，将标准技术应用于3D旋转经常会导致严重的实际问题。旋转(物体方向的改变)是除平移外唯一能保持物体形状不变的运动。因此，它在动画刚性物体中起着特殊的作用。</strong></p>
<p><strong>有几种方法可以指定对象的方向。首先，可以使用第六章中描述的变换矩阵。不幸的是,天真的(逐元素)旋转矩阵的插值不会产生正确的结果。例如，在2D时钟和逆时针90度旋转之间的“中间”矩阵就是零矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134027.png" class="" title="image-20211012134027">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134118.png" class="" title="image-20211012134118">

<p>三个欧拉角可以通过围绕嵌入到对象中的坐标轴(Y轴总是指向锥尖)的三次旋转序列来指定对象的任意方向。注意，每个旋转都是在一个新的坐标系中给出的。固定角度表示非常类似，但它使用的坐标轴在空间中是固定的，不随对象旋转。</p>
<p><strong>当然，正确的结果是，单位矩阵对应于无旋转。第二，可以指定任意方向，作为一个围绕特定顺序选择的坐标轴进行三次旋转的序列。这些轴可以固定在空间中(固定角度表示)或嵌入到物体中，因此在每次旋转后都会发生变化(如上图所示的欧拉角表示)。这三个旋转角度可以通过标准关键帧直接动画，但一个微妙的问题称为万向节锁出现。如果在旋转过程中，三个旋转轴中的一个意外地与另一个对齐，从而减少了一个可用的自由度，如下图所示。这种效果比人们想象的要普遍得多，向右(或左)一个90度的转弯就可能把一个物体放进万向节锁中。最后，可以通过在空间中选择合适的轴和围绕该轴的旋转角度来指定任何方向。虽然在这种表现中动画是相对简单的，结合两个旋转，即找到与由轴和角表示的两个旋转序列相对应的轴和角是很重要的。一种特殊的数学装置，四元数已经被开发出来，使这种表示既适用于将几个旋转组合成一个旋转，也适用于动画。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134225.png" class="" title="image-20211012134225">

<p>在这个例子中，万向节锁发生在绕Z轴作90度旋转。现在，X轴和Y轴的旋转都是围绕同一轴进行的，导致失去一个自由度。</p>
<p><strong>给定一个三维矢量v = (x, y, z)和一个标量s，四元数q将这两个组合成一个四分量对象:q = [s x y z] = [s;v)。几个然后为四元数定义新的操作。四元数加法简单地分别和标量和向量部分:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134320.png" class="" title="image-20211012134320">

<p><strong>乘以标量a得到一个新的四元数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134338.png" class="" title="image-20211012134338">

<p><strong>更复杂的四元数乘法定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134406.png" class="" title="image-20211012134406">

<p><strong>其中×为向量叉积。很容易看出，与矩阵相似，四元数乘法是结合律，但不是交换律。我们最感兴趣的是归一化四元数——四元数范数|q| = √（s² + v²） 等于1。最后一个定义是逆函数</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134416.png" class="" title="image-20211012134416">

<p><strong>以角度φ表示绕经过原点的轴旋转，原点的方向由归一化四元数n给出</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134427.png" class="" title="image-20211012134427">

<p><strong>就形成了。要旋转点p，就把它变成四元数qp = [0;p]并计算四元数积</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134437.png" class="" title="image-20211012134437">

<p><strong>它的标量部分为0旋转后的点作为它的向量部分。复合旋转简单地由表示每个单独旋转步骤的四元数乘积给出。使用四元数动画，可以将它们视为四维空间中的点，并在这个空间中直接设置键。为了保持四元数归一化，我们应该严格地将插值过程限制在这个四维空间中的一个单位球体(一个三维物体)。然而，球面线性插值(通常称为slerp)已经导致了相当令人不快的数学运算。简单的四维线性插值，然后在单位球面上进行投影，如下图所示，这在实践中要简单得多，通常也足够了。通过重复使用de Casteljau算法的线性插值过程，可以得到更平滑的结果。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211012134754.png" class="" title="image-20211012134754">

<p>插值四元数应该在嵌入在四维空间中的三维单位球体的表面。然而，沿着4D直线(开圆)进行更简单的插值，然后再将结果投影到球体上(黑圆)通常就足够了。</p>
<h2 id="Deformations-变形"><a href="#Deformations-变形" class="headerlink" title="Deformations 变形"></a>Deformations 变形</h2><p><strong>虽然物体变形技术可能更适合作为建模工具，但传统上它们是与动画方法一起讨论的。可能改变对象形状的操作最简单的例子是不均匀缩放。更普遍地说，一些函数可以应用于指定对象的所有点的局部坐标(例如三角形网格的顶点或样条曲面的控制多边形)，重新定位这些点并创建一个新的形状:p′= f(p， γ)，其中γ为变形函数所使用的参数向量。选择不同的f(并通过一个接一个的应用组合它们)可以帮助创建非常有趣的变形。如下图所示的有用的简单函数示例包括弯曲、扭曲和锥度。在这种情况下，通过关键帧变形函数的参数，动画形状变化是非常容易的。这种技术的缺点包括难以为一些非标准变形选择数学函数，以及产生的变形是全局的，因为在某种意义上，整个对象而不仅仅是它的一部分被重塑。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013110938.png" class="" title="image-20211013110938">

<p>整体变形的流行例子。弯曲和扭曲角度，以及锥度，都可以动画实现动态形状变化。</p>
<p><strong>为了在局部变形对象的同时提供对结果的更直接的控制，可以选择单个顶点，将其移动到一个新的位置，并根据种子顶点在一些邻域内调整顶点。受变形影响的区域和物体不同部分的具体位移量是由衰减函数控制的，衰减函数随着距离(通常是在物体表面计算的)到种子顶点的距离减小。种子顶点运动可以通过关键帧产生动画形状变化。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013111208.png" class="" title="image-20211013111208">

<p>对FFD点阵进行调整，会导致失稳物体的形成。</p>
<p><strong>更一般的变形技术称为自由形式变形(FFD) (Sederberg &amp; Parry, 1986)。首先建立一个局部(在大多数情况下是直线的)坐标网格来封装要变形的对象部分，并计算所有相关点的坐标(s, t, u)相对于这个网格。然后，用户自由地将晶格点Pijk的网格重塑为一个新的扭曲晶格P′ijk (上图)。在B´ezier插值(见第15章)的三变量模拟中，使用在原始未变形网格中计算的坐标重建对象，并使用扭曲的晶格点P′Ijk在这个表达式中作为控制点的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013111310.png" class="" title="image-20211013111310">

<p><strong>式中，L, M, N为每维格点的最大指标。实际上，晶格充当了物体变形的低分辨率版本，允许任意复杂物体的平滑形状变化通过相对较少的直观调整。FFD晶格本身可以被系统视为规则对象，并可以进行转换、动画，甚至在必要时进一步变形，从而导致晶格所附着的对象发生相应的变化。例如，移动变形工具，由原始点阵和变形点阵组成，它们代表了一个跨越物体的凸起，结果是一个凸起在物体上移动。</strong></p>
<h2 id="Character-Animation-角色动画"><a href="#Character-Animation-角色动画" class="headerlink" title="Character Animation 角色动画"></a>Character Animation 角色动画</h2><p><strong>铰接图形的动画通常通过关键帧和专门的变形技术的组合来执行。动画角色模型通常包含至少两个主要层，如下图所示。观众最终将在最终产品中看到的是代表角色外壳或皮肤的高度详细的表面的运动。它下面的骨架是一个关节的层次结构(树)，它提供了图形的运动学模型，专门用于动画。在某些情况下，在骨骼和皮肤之间插入与肌肉大致对应的额外中间层。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013111912.png" class="" title="image-20211013111912">

<p>(左)关节的层次结构，一个骨架，作为角色的运动抽象;(中)重新定位骨骼使附加在它上的单独皮肤物体变形;(右)树数据结构被用来表示骨架。为了紧凑，隐藏了几个节点的内部结构(它们与对应的同级节点相同)。</p>
<p><strong>骨骼的每一个关节都是它下面的层次结构的父级。根代表整个角色，直接位于世界坐标系中。如果一个将关节与其层次结构中的父关节相关联的局部变换矩阵是可用的，那么就可以得到一个将任何关节的局部空间与世界系统相关联的变换。通过简单地沿着从根到关节的路径连接转换)。评估整个骨架(即在此基础上，对整个关节树)进行深度优先遍历。转换堆栈是帮助完成这一任务的自然数据结构。向下遍历树时，将当前的复合矩阵推入堆栈，并通过将当前矩阵与存储在节点上的矩阵相乘创建一个新的矩阵。当回溯到父分支时，这个额外的转换应该在访问另一个分支之前撤销;这很容易做到，只需弹出堆栈。尽管这种评估层次结构的通用而简单的技术在整个计算机图形中都被使用，但在动画(和机器人技术)中，它被赋予了一个特殊的名称——正向运动学(FK)。虽然可以使用所有转换的一般表示，但通常使用特定的参数集(如链接长度或关节角度)来指定骨架。为了进行正运动学动画，所有关节的旋转参数都是直接操作的。该技术还允许动画师改变关节之间的距离(链接长度)，但你应该知道，这与肢体伸展相对应，通常看起来相当不自然。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112154.png" class="" title="image-20211013112154">

<p>正运动学(上图)要求动画师将所有关节放入正确的位置。在逆运动学(下)中，一些内部关节的参数是基于期望的末端执行器运动计算的。</p>
<p><strong>正运动学需要用户为运动中涉及的所有关节设置参数(上图(上))。然而，这些关节大多属于层级的内部节点，它们的运动通常不是动画师想要担心的事情。在大多数情况下，动画师只是想让它们“自己”自然地移动，而人们更感兴趣的是指定关节链端点的行为，这通常与执行特定动作的东西相对应，如踝关节或指尖。动画师宁愿让所有内部关节的参数由系统自动从末端执行器的运动来确定。逆运动学(IK)允许我们这样做(见上图(下))。</strong></p>
<p><strong>设x为末端执行器的位置，α为指定从根到最终关节的链条上所有内部关节所需的参数向量。有时最终关节的方向也是由动画师直接设置的，在这种情况下，我们假设相应的变量包含在向量x中。然而，为了简单起见，我们将写出向量的所有具体表达式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112249.png" class="" title="image-20211013112249">

<p><strong>由于x中的每个变量都是α的函数，所以它可以写成向量方程x = F(α)。如果我们将内部关节参数改变少量δα，末端执行器位置的变化δx可以近似表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112259.png" class="" title="image-20211013112259">

<p><strong>其中∂F/∂α是偏导数矩阵称为雅可比矩阵:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112308.png" class="" title="image-20211013112308">

<p><strong>在每一个时刻，我们都知道末端执行器的期望位置(由动画师设置)，当然，也知道执行器的当前位置。两者相减，我们将得到期望的调整值δx。雅可比矩阵的元素与当特定的内部参数改变而其他参数保持不变时末端执行器坐标的变化有关(见下图)。这些元素可以使用几何关系计算任何给定的骨架配置。在(16.1)方程组中，唯一剩下的未知数是内部参数α的变化。一旦我们解决了它们，我们更新α = α+δα，这为FK程序重新定位骨骼提供了所有必要的信息。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112513.png" class="" title="image-20211013112513">

<p>部分的导数∂x/∂αknee以Δx/Δαknee的极限给出。效应器位置是在除膝盖外，所有关节都是固定。</p>
<p><strong>不幸的是，系统通常不能解析地解决，而且，在大多数情况下，它是不受约束的，即。，未知关节内部参数α的个数超过向量x中变量的个数。这意味着骨架的不同运动可以导致末端的相同运动效应。下图显示了一些示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013112856.png" class="" title="image-20211013112856">

<p>多个配置的内部关节可以导致同样的效应器，另一个帮助动画抓取位置。(上)脱节的“翻转”解决方案;(下)溶液的连续统一体。</p>
<p><strong>对于这样的系统，有许多方法可以获得特定的解决方案，包括那些考虑到现实生活中某些关节所需要的自然约束(例如，只向一个方向弯曲膝盖)。我们还应该记住，计算出来的雅可比矩阵只对一个特定的配置有效，它必须随着骨架的移动而更新。完整的IK框架如下图所示。当然，IK的根关节不必是整个层次结构的根，多个IK求解器可以应用到骨架的独立部分。例如，可以使用分开右脚和左脚的求解器和用右手，每个都有自己的根。。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013113117.png" class="" title="image-20211013113117">

<p>逆运动学算法图。</p>
<p> <strong>结合FK和IK方法通常用于制作骨骼动画。许多常见的运动(步行或跑步循环，抓握，伸手等)显示出众所周知的相互关节运动模式，使快速成为可能创建自然看起来的运动，甚至使用这样的“剪辑”库。然后动画师根据角色的物理参数调整这个通用的结果，并赋予它更多的个性。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013113328.png" class="" title="image-20211013113328">

<p>上:硬皮蒙皮顶点到一个特定的关节。属于肘关节的部分用黑色表示;软蒙皮可以混合几个关节的影响。显示肘关节的重量(重量越轻=重量越大)。注意关节附近皮肤内侧光滑的皮肤变形。</p>
<p><strong>当骨骼改变它的位置时，它作为一种特殊类型的变形器应用于角色的皮肤。通过为每个蒙皮顶点分配一个(刚性蒙皮)或多个(光滑蒙皮)关节作为驱动，运动被转移到这个表面(见上图)。在第一种情况下，蒙皮顶点被简单地冻结在相应关节的局部空间中，该关节可以是空间中最近的一个，也可以是用户直接选择的一个。顶点然后重复这个关节经历的任何运动，它在世界坐标中的位置由标准FK程序确定。尽管它很简单，但刚性蒙皮使其难以在关节附近区域获得足够光滑的蒙皮变形，也难以获得更微妙的效果，如呼吸或肌肉动作。另外一种叫做屈肌的特殊变形器也可以用于这个目的。在平滑蒙皮中，多个关节可以根据动画师分配的一些权重影响蒙皮顶点，从而对结果进行更详细的控制。位移矢量di，由影响给定皮肤顶点的不同关节提出(每个关节再次用标准FK计算)，根据它们的权重wi平均，以计算顶点d = ∑widi的最终位移。归一化权值∑wi = 1)是最常见的，但不是基本必需的。设置平滑蒙皮权重来达到预期的效果并不容易，需要动画师的重要技能。</strong></p>
<h3 id="Facial-Animation-面部表情动画"><a href="#Facial-Animation-面部表情动画" class="headerlink" title="Facial Animation 面部表情动画"></a>Facial Animation 面部表情动画</h3><p><strong>骨骼非常适合创建角色身体的大多数动作，但它们不太适合制作逼真的面部动画。原因是，人类面部的皮肤是由直接附着在其上的肌肉移动的，而身体其他部位的肌肉主要目的是移动骨骼，任何皮肤变形都是次要结果。这种面部解剖结构安排的结果是一套非常丰富的动态面部表情，人类使用它作为主要的交流工具之一。我们都受过很好的训练，能够识别这种面部变化，很容易注意到任何不自然的外观。这不仅对动画师提出了特殊的要求，而且还需要高分辨率的面部几何模型，如果想要逼真，还需要精确的皮肤反射属性和纹理。</strong></p>
<p><strong>虽然可以逐点设置人脸的关键姿态，并在它们之间插入，或使用基于物理的技术直接模拟底层肌肉结构的行为(参见第16.5节)，但更专业的方法是高级别的方法也存在。特定的静态形状的脸可以以一个相对较小的设置所谓的构象参数(总规模,距离从眼睛到前额,鼻子的长度,宽度的下巴,等等)用于变形一般的脸模型到一个个人特性。另外一组表达参数可以用来描述动画中脸部的动态形状。例如，头部的刚性旋转，眼睛的睁开程度，某些特征点从静止位置的移动，等等。这些选择是为了大多数有趣的表情可以通过一些参数调整的组合获得，因此，允许一个脸通过标准关键帧动画。为了实现更高层次的控制，可以使用表达参数创建一组与常见情绪(中性、悲伤、快乐、愤怒、惊讶等)对应的表情，然后将这些关键姿势混合，得到一张“轻微悲伤”或“愤怒惊讶”的脸。类似的技术也可以用于表演对口型动画，但这种情况下的关键姿势对应不同的音素。面部动作编码系统(FACS) (Eckman &amp; Friesen, 1978)没有使用静态表情序列来描述动态表情，而是直接将动态面部表情分解为称为动作单位(AUs)的基本动作的总和。这套动作基于广泛的心理学研究，包括抬内眉、皱鼻子、拉伸嘴唇等动作。结合 AUs可用于合成必要的表达。</strong></p>
<h3 id="Motion-Capture-动作捕捉"><a href="#Motion-Capture-动作捕捉" class="headerlink" title="Motion Capture 动作捕捉"></a>Motion Capture 动作捕捉</h3><p><strong>即使在上述技术的帮助下，从零开始创建逼真的角色动画仍然是一项艰巨的任务。因此，人们很自然地将大量注意力集中在记录演员在现实世界中的动作，然后将其应用于电脑生成的角色的技术上。运动捕捉(MC)技术主要有两类:电磁和光学。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211013113718.png" class="" title="image-20211013113718">

<p>光学运动捕捉:标记附着在表演者的身体上，骨骼运动被提取出来。图片由运动分析公司提供。</p>
<p><strong>在电磁运动捕捉中，电磁传感器直接测量其三维位置(可能还有方向)，通常实时提供捕获结果。这种技术的缺点包括昂贵的设备成本，可能来自附近金属物体的干扰，以及传感器和电池的明显尺寸，这可能会成为执行高振幅运动的障碍。在光学MC中，小的彩色标记被用来代替主动传感器，使其成为一个侵入性小得多的过程。上图显示了这样一个系统的操作。在最基本的安排中，运动被两个校准的摄像机记录下来，并使用简单的三角测量来提取标记者的三维位置。更先进的计算机视觉算法用于精确跟踪从视频中提取多个标记的计算代价很高，因此，在大多数情况下，这种处理是离线完成的。光学跟踪的鲁棒性通常不如电磁跟踪。某些帧中给定标记的遮挡、标记的可能错误识别和图像中的噪声只是必须解决的几个常见问题。引入更多的摄像机从不同的方向观察运动，提高了精确度和鲁棒性，但这种方法更昂贵，而且需要更长的时间来处理这些数据。随着可用计算能力的提高和更好的计算机视觉算法的发展，光学MC变得越来越有吸引力。由于标记的低影响特性，光学方法适用于精细的面部动作捕捉，也可以用于人类以外的对象，例如，动物，甚至是风中的树枝。</strong></p>
<p><strong>通过将几个传感器或标记连接到表演者的身体上，可以记录一些点集合的一组时间依赖的3D位置。这些跟踪位置通常选择在关节附近，但当然，它们仍然位于皮肤表面，而不是在实际的骨骼接触点。因此，需要一些额外的护理和一些额外的处理来将记录的位置转换为物理骨骼关节的位置。例如，在肘关节或踝关节的相对两侧放置两个标记点，使系统通过平均两个标记点的位置来获得更好的关节位置。如果没有额外的注意，由于关节位置偏移以及固有噪声和测量精度不足，会出现非常明显的伪影。例如，由于运动过程中的身体不准确，角色的四肢可能会在行走或抓握时失去与它们应该接触的物体的接触，骨骼可能会出现脚滑(滑冰)等问题。大多数这些问题都可以通过使用逆运动学技术来纠正，这种技术可以明确地迫使肢体的末端做出所需的行为。</strong></p>
<p><strong>恢复的关节位置现在可以直接应用到电脑生成的角色的骨架上。本程序假定角色的物理尺寸与表演者的物理尺寸相同。将记录的动作重新定位到不同的角色，更普遍地说，编辑MC数据，需要非常小心，以满足必要的约束条件(如保持脚在地面上或不允许肘部向后弯曲)，并保持修改后动作的整体自然外观。一般来说，期望的更改越多，保持结果质量的可能性就越小。解决这个问题的一种有趣的方法是记录大量的动作，并从这个库中将短片段拼接在一起，以获得所需的动作。虽然这个课题目前是一个非常活跃的研究领域，但动作捕捉技术的主要缺点之一仍然是不能根据动画师的需要来调整记录的动作。</strong></p>
<h2 id="Physics-Based-Animation-基于物理的动画"><a href="#Physics-Based-Animation-基于物理的动画" class="headerlink" title="Physics-Based Animation 基于物理的动画"></a>Physics-Based Animation 基于物理的动画</h2><p><strong>我们周围的世界是由物理定律支配的，其中许多可以被形式化为偏微分方程组，或者在一些更简单的情况下，常微分方程组。计算机最初的应用之一就是(现在仍然是)解这样的方程。因此，尝试使用过去几十年发展起来的数字技术来获得计算机动画的真实动作是很自然的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110125.png" class="" title="image-20211014110125">

<p>现实的布料模拟是经常使用基于物理的方法执行。在这个例子中，力来自碰撞和重力。</p>
<p><strong>由于其相对的复杂性和巨大的成本，基于物理的动画最常用于其他技术不可用或不能产生足够逼真的结果的情况下。主要的例子包括流体动画(其中包括许多由相同方程描述的气态现象——烟、云、火等)、布料模拟(示例如上图所示)、刚体运动和弹性物体的精确变形。在每一种情况下，控制方程和常用数值方法的细节是不同的，但许多基本思想和困难仍然适用于各个应用程序。数值求解ODEs 和 PDEs的方法很多，但详细讨论它们远远超出了本书的范围。为了让读者对基于物理的技术和涉及的一些问题有所了解，我们在这里只简要地提到有限差分方法——概念上最简单和最流行的算法系列之一，它已被应用于动画中遇到的大多数(如果不是全部)微分方程。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110324.png" class="" title="image-20211014110324">

<p>对于∂f/∂x和∂f/∂t的导数方程，有两种可能的差分格式。(左)显式方案仅通过已知值表示未知值(开圆)，当前(橙色圆圈)和可能过去(蓝色圆圈)时间;(右)隐式格式将已知值和未知值混合在单个方程中，因此必须将所有这些方程作为一个系统来求解。对于这两种方案，需要关于右边界值的信息来关闭过程。</p>
<p><strong>该方法的核心思想是将微分方程替换为离散模拟方程—差分方程。为了做到这一点，连续感兴趣的区域由有限的点集表示，在这些点上将计算出解。在最简单的情况下，这些定义在一个统一的矩形网格上，如上图所示。原始ODE或PDE中的每一个导数都被其在网格点处的函数值的逼近所取代。一种方法是用网格上相邻点的函数值减去给定点上的函数值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110344.png" class="" title="image-20211014110344">

<p><strong>当然，这些表达并不是唯一的方式。例如，可以使用f(t−Δt)而不是上面的f(t)，然后除以2Δt。对于包含时间导数的方程，现在可以通过求解未知f(t + Δt)的差分方程组(每个空间位置一个)，将未知函数的值以Δt-size步骤序列在时间上向前传播。一些最初的条件,即在t = 0时的未知函数值，是启动过程所必需的。根据特定的问题，可能还需要其他信息，例如域边界上的值。</strong></p>
<p><strong>f(t+Δt)的计算对于所谓的显式格式来说是很容易的，只要在当前时间取所有其他值，并且相应的差分方程f(t+Δt)中唯一的未知数通过这些已知值来表示。隐式方案混合了当前和未来的价值，例如,使用</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110556.png" class="" title="image-20211014110556">

<p><strong>作为近似 ∂f/∂x ．在这种情况下，每一步都要解一个代数方程组。</strong></p>
<p><strong>差分格式的选择会极大地影响算法的各个方面。其中最明显的是准确性。在Δt→0或Δx→0的极限下，上上式中这种类型的表达式是精确的，但对于有限步长，有些格式允许比其他格式更好地逼近导数。差分格式的稳定性与实际中经常出现的数值误差随时间增长的速度有关。对于稳定方案，这种增长是有界的，而对于不稳定方案，这种增长是指数级的，并且可以迅速压倒人们所寻求的解决方案(见下图)。重要的是要认识到，虽然解决方案中的一些不准确是可以容忍的(事实上，动画很少需要物理和工程中要求的精度)，但不稳定的结果是完全不需要的没有意义，应该避免使用不稳定的方案。一般来说，显式格式是不稳定的，或者在较大的步长下会变得不稳定，而隐式格式是无条件稳定的。隐式格式允许更大的步长(因此，更少的步长)，这就是为什么尽管每一步都需要解一个代数方程组，隐式格式还是很受欢迎的原因。显式格式在满足其稳定性条件的情况下，由于其简单而具有吸引力。为一个特定的问题开发一个好的差分格式和相应的算法是不容易的，对于大多数标准情况，最好使用现有的方法。有大量的文献讨论这些技术的细节。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014110707.png" class="" title="image-20211014110707">

<p>一个不稳定的解决方案可能会跟随最初是行动一，但随着时间的推移，它会任意偏离行动一。对于特定的应用程序，稳定的解决方案的准确性可能仍然不够。</p>
<p><strong>我们应该记住，在许多情况下，仅仅计算方程中所有必要的项本身就是一项困难和耗时的任务。例如，在刚体或布的模拟中，作用在系统上的大多数力是由于物体之间的碰撞。因此，在动画的每一步中，我们都必须解决一个纯粹的几何问题，但非常重要的碰撞检测问题。在这种情况下，需要对这种力量进行较少评估的方案可能会节省大量计算。</strong></p>
<p><strong>虽然求解适当的时变方程的结果给出了非常真实的运动，但这种方法有其局限性。首先，物理动画的效果很难控制。这些方程的基本数学性质表明，一旦设定了初始条件，解就是唯一的。这没有给动画师留下太多的输入空间，如果结果由于某种原因不令人满意，那么就只有几个选择了。它们大多局限于调整初始条件，改变系统的物理属性，甚至通过引入人工术语来修改方程本身，以“推动”动画师想要的方向的解决方案。做出这样的改变需要高超的技能，同时也需要理解基本的物理原理，最好还有数值方法。如果没有这些知识，基于物理的动画所提供的现实主义可能会被破坏，或者可能出现严重的数值问题。</strong></p>
<h2 id="Procedural-Techniques-程序技术"><a href="#Procedural-Techniques-程序技术" class="headerlink" title="Procedural Techniques 程序技术"></a>Procedural Techniques 程序技术</h2><p><strong>想象一下，我们可以编写(并在计算机上执行)一个数学函数，在动画师的指导下精确输出所需的运动。当所涉及的“函数”是求解特定微分方程的过程，而“指导”是初始条件和边界条件、额外方程项等的集合时，上述基于物理的技术可以作为这种方法的一个特例来处理。</strong></p>
<p><strong>然而，如果我们只关心最终结果，我们不必遵循基于物理的方法。例如,一个简单的表面恒定振幅波湖可以直接由应用函数f (x, t) = cos(ωt−kx +φ)在恒定的频率ω,波矢k和阶段φ得到2d点x在时间t的位移。这样的波浪随机集合阶段和适当选择振幅,频率和波向量会导致一个非常现实的动画的表面水没有明确解决任何流体动力学方程。事实证明，其他相当简单的数学函数也可以创建非常有趣的模式或对象。在11.5节中描述了几个这样的函数，大多数是基于晶格噪声的。在这些功能中添加时间依赖性使我们能够比基于物理的技术更容易和更便宜地动画某些复杂的现象，同时保持非常高的视觉质量的结果。如果noise(x)是基本的模式生成函数，我们可以通过在晶格中移动参数位置来创建一个随时间变化的变量。最简单的例子是匀速运动:timenoise(x, t) =noise(x + vt)，但更复杂的通过晶格的运动当然也是可能的，事实上也更常见。下图显示了这样一条路径，即螺旋。另一种方法是使用动画参数来生成噪声函数。这尤其适用于当外观随时间发生显著变化时，例如云变得更加动荡。通过这种方式，我们可以使用生成静态云的功能来动画云的动态形成过程。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014112547.png" class="" title="image-20211014112547">

<p>一个路径通过立方体定义程序noise被遍历以动画结果模式。</p>
<p><strong>对于某些程序技术来说，时间依赖是一个更重要的组成部分。最简单的元胞自动机在二维矩形网格上运行，在每个位置(元胞)存储二进制值。要创建时变模式，需要重复应用一些用户提供的修改这些值的规则。规则通常涉及当前值和单元格相邻值的一些条件集。例如，由英国数学家John Conway于1970年发明的2D生命游戏细胞自动机的规则如下:</strong></p>
<p>​    <strong>1.一个死细胞(即在给定位置的二进制值为0)，恰好有三个活动邻居成为一个活动单元(即其值设置为1)。</strong></p>
<p>​    <strong>2.一个有两三个活细胞邻居的活细胞可以存活。</strong></p>
<p>​    <strong>3.在其他情况下，细胞死亡或保持死亡。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014112903.png" class="" title="image-20211014112903">

<p>生命游戏自动机进化的几个(非连续的)阶段。活细胞用黑色表示。应用非常简单的规则可以得到稳定的物体、振荡器、运动模式和许多其他有趣的结构。图由艾伦·亨塞尔使用程序创建。</p>
<p><strong>一旦规则应用于所有网格位置，就会创建一个新的模式，并开始一个新的进化周期。活细胞分布在不同时间的三个样本快照如上图所示。更复杂的自动机同时可以在几个可能是浮点值的三维网格上操作，并可用于模拟云和其他气体现象或生物系统的动力学，这是该仪器最初为之发明的(注意术语)。仅仅几个精心选择的规则就可以产生令人惊讶的模式复杂性，但是如何编写这样的规则来创建所需的行为通常并不明显。这是程序性技术的一个常见问题:关于如何创建新的程序或甚至调整现有程序的参数的指导，如果有的话，也是有限的。因此，我们通常需要通过大量调整和反复试验(游戏邦注:即“通过经验”)来学习程序方法。</strong></p>
<p><strong>另一种最初用于描述生物物体的有趣方法是L-systems(以其最初发明者阿斯特丽德·林登迈尔的名字命名)。这种方法基于用于重写符号字符串的语法或递归规则集。有两种类型的符号:终端符号代表我们想用语法表示的元素。根据语法的含义，语法可以描述树木和灌木丛、建筑和整个城市的结构，或者编程和自然语言。在动画,L-systems是最受欢迎的代表植物几何建模和相应的终端指令系统:把一片叶子(或分支机构)在当前我们将使用@符号,画一个圆,推动当前位置,一些数量的单位(符号f),扭转当前方向60度世界z轴(符号+),pop(符号[)或推(符号])当前位置/取向,等等。辅助非终结符号(用大写字母表示)只有语义而不是任何直接意义。它们打算最终通过终端被重写。我们从特殊的非终结符开始符号S开始，并并行地对当前字符串应用语法规则，即替换当前存在的所有非终端机以获得新字符串，直到我们最终得到一个只包含终端的字符串，因此不可能有更多的替换。然后使用这串建模指令输出实际的几何图形。例如，一组规则(产品)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014113122.png" class="" title="image-20211014113122">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014113141.png" class="" title="image-20211014113141">

<p>连续的推导步骤使用符号表示L-system。大写字母表示非终结符，并说明相应的非终结符将被展开的位置。它们不是实际产出的一部分。</p>
<p><strong>可能导致如上图所示的重写步骤序列:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211014113200.png" class="" title="image-20211014113200">

<p><strong>如上所示，对于相同的非终结符，通常有许多不同的结果，允许使用相同的语法生成许多不同的对象。应用哪条规则的选择可以取决于哪些符号位于被替换的符号的旁边(上下文敏感性)，或者可以根据为每个规则分配的一些概率随机执行(随机l系统)。更复杂的规则可以建模与环境的交互，比如修剪到特定形状，参数可以与符号关联，以控制发出的几何命令。</strong></p>
<p><strong>L-systems已经捕获了工厂拓扑随时间的变化:在重写过程中获得的每个中间串都可以被解释为工厂的“年轻”版本(见上图)。对于更显著的变化，不同的产量可以在不同的时间生效，允许植物的结构随着它的生长而发生显著的变化。例如，一棵幼树会产生很多新的分枝，而一棵老树只会适度地分枝。</strong></p>
<p><strong>非常逼真的植物模型已经用l系统创建。然而，与大多数过程技术一样，需要一些经验才能有意义地应用现有的 L-systems，而编写新的语法来获得一些预期的效果当然不容易。</strong></p>
<h2 id="Groups-of-Objects-对象组"><a href="#Groups-of-Objects-对象组" class="headerlink" title="Groups of Objects 对象组"></a>Groups of Objects 对象组</h2><p><strong>当然，要制作多个对象的动画，我们可以简单地将本章所描述的标准技术应用到每个对象上。这种方法适用于中等数量的独立物体，它们的理想运动是已知的的进步。然而，在许多情况下，在动态环境中采取某种协调行动是必要的。如果只涉及少数对象，动画师可以使用基于人工智能(AI)的系统，根据一些高级目标自动确定每个对象的即时任务，计划必要的动作，并执行计划。许多现代游戏使用这种自主对象来创造聪明的怪物或玩家的合作者。</strong></p>
<p><strong>有趣的是，随着群体中物体的数量从几个增长到几十个、数百个甚至数千个，群体中的个体必须只有非常有限的“智能”，才能让整个群体表现出协调一致的目标驱动运动。事实证明，群体聚集是一种突现行为，可能是群体成员与几个最亲密的邻居有限互动的结果(Reynolds, 1987)。任何观察过一群鸟或一群鱼引人入胜的同步运动的人都应该对群集现象很熟悉。这项技术也可以用来控制一群动物在地形上移动，甚至是一群人。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211015125830.png" class="" title="image-20211015125830">

<p>(左)单个群成员(boid)可以经历几个不同重要性的冲动(由线厚表示)，这些冲动必须被协商成一个单一的速度矢量。boid只知道它有限的邻域(圆)。(右)Boid控制通常被实现为三个独立的模块。</p>
<p><strong>在任何给定的时刻，群体成员的运动，通常称为boid，应用于群时，是平衡几个经常相互矛盾的趋势的结果，每个趋势表明其自己的速度矢量(见上图16.28)。首先，有外力作用于体，如重力或风。由这些力产生的新速度可以直接通过牛顿定律计算</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211015125846.png" class="" title="image-20211015125846">

<p><strong>第二，一个boid应该对全球环境和其他群体成员的行为做出反应。避免碰撞是这种相互作用的主要结果之一。群集的关键是，每个群体成员只有有限的视野，因此只知道在其当前位置附近发生的事情。为了避免环境中的物体，最简单的策略是在每个物体周围建立一个有限范围的斥力场。这将产生第二个所需的速度矢量vnew^col - avoid，也由牛顿定律给出。与其他组成员的交互可以通过同时应用不同的转向行为来建模，从而产生几个额外的期望速度向量vnew^steer。 最常见的情况是远离邻近的动物以避免拥挤，转向同伴以确保群体凝聚力，以及调整鱼群的速度以与邻近动物的平均方向一致。最后，一些额外的期望速度矢量vnew^goal通常用于实现所需的全局目标。它们可以是沿着空间中某个路径的向量，跟随某个特定指定的鸟群领袖，或者仅仅代表鸟群成员的迁徙冲动。</strong></p>
<p><strong>一旦所有的vnew被确定，最终想要的向量将基于它们之间的优先级进行协商。避免碰撞和速度匹配通常具有更高的优先级。与其简单地平均期望的速度向量(这可能导致冲动的取消和不自然的“无处移动”行为)，不如使用加速分配策略。某些固定的总加速度是为一个boid提供的，它的一部分是按优先顺序给予每个敦促的。如果总的可用加速度耗尽，一些较低优先级的冲动将对运动产生较小的影响或被完全忽略。我们希望，一旦当前最重要的任务(在大多数情况下避免碰撞)完成，其他任务就可以在不久的将来处理。尊重真实对象的某些物理限制也很重要，例如，将过高的加速度或速度夹持到某些现实值。根据鸟群成员的内部复杂性，动画的最后阶段可能是将商定的速度矢量转换成一组特定的参数(鸟的翅膀位置，平面模型在空间中的方向，腿骨架骨骼配置)，用于控制boid的运动。上图(右)显示了系统实现群集的示意图。</strong></p>
<p><strong>一个更简单，但仍然非常有用的群体控制版本是由粒子系统实现的(Reeves, 1983)。一个系统中的粒子数量通常比一个群中的boids数量大得多，可以是数万或数十万，甚至更多。此外，在动画过程中，粒子的确切数量会随着新粒子的诞生和一些旧粒子的破坏而波动。粒子通常是完全独立于相互之间，忽略自己的邻居，只通过经历外力和与物体的碰撞与环境互动，而不是像鸟群那样通过避免碰撞。在动画过程中的每一步，系统首先用一些初始参数创建新的粒子，终止旧的粒子，然后根据牛顿定律计算必要的力，更新剩余粒子的速度和位置。</strong></p>
<p><strong>粒子系统的所有参数(粒子数量、粒子寿命、初始速度和粒子位置等)通常都在动画师的直接控制之下。粒子系统的主要应用包括建模烟花、爆炸、喷雾液体、烟雾和火灾，或其他模糊物体和没有尖锐边界的现象。为了获得真实的外观，在所有参数中引入一些随机性是很重要的，例如，在每个步骤中产生(和破坏)随机数量的粒子，它们的速度根据某些分布生成。除了设置适当的初始参数，控制粒子系统的运动通常是通过在空间中创建一个特定的力模式来实现的，例如，在粒子到达某个特定位置时将其吹向一个新的方向或添加一个吸引中心。我们应该记住，尽管粒子系统具有所有的优势，主要是实现的简单性和易于控制，但它们通常不能提供基于真实物理的相同现象模拟的真实感特征。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211015130223.png" class="" title="image-20211015130223">

<p>被定向源发射后，粒子与物体碰撞，一旦清除障碍物，就会被当地的风场吹落。</p>
<h1 id="17-Using-Graphics-Hardware-使用图形硬件"><a href="#17-Using-Graphics-Hardware-使用图形硬件" class="headerlink" title="17 Using Graphics Hardware 使用图形硬件"></a>17 Using Graphics Hardware 使用图形硬件</h1><h2 id="Hardware-Overview-硬件概述"><a href="#Hardware-Overview-硬件概述" class="headerlink" title="Hardware Overview 硬件概述"></a>Hardware Overview 硬件概述</h2><p><strong>在本书的大部分内容中，重点是计算机图形的基本原理，而不是与实现算法的API或硬件相关的任何细节。本章采取了稍微不同的路线，将使用图形硬件的细节与与硬件编程相关的一些实际问题混合在一起。这一章被设计为图形硬件的介绍性指南，可以用作一组调查图形硬件的每周实验室的基础。</strong></p>
<h2 id="What-Is-Graphics-Hardware-什么是图形硬件"><a href="#What-Is-Graphics-Hardware-什么是图形硬件" class="headerlink" title="What Is Graphics Hardware 什么是图形硬件"></a>What Is Graphics Hardware 什么是图形硬件</h2><p><strong>图形硬件描述了使用专门的基于光栅化(在某些情况下，基于射线跟踪器)的硬件架构在计算机屏幕上以像素形式快速渲染3D对象所需的硬件组件。使用术语图形硬件是为了引出执行一系列图形计算所需的物理组件的含义。换句话说，硬件就是目前显卡上的芯片组、晶体管、总线、处理器和计算核心的集合。正如您将在本章学到并最终体验到的，当前的图形硬件非常擅长处理3D对象的描述，并将这些表示转换为填充显示器的彩色像素。</strong></p>
<p><strong>在过去的十年里，图形硬件的确发生了非常迅速的变化。较新的图形硬件提供了更多的并行处理功能，以及对特殊呈现的更好支持。这种快速发展的原因之一是电子游戏行业及其经济发展势头。本质上，这意味着每一个新的图形卡提供更好的性能和处理能力。因此，电子游戏的视觉效果更加逼真。图形硬件上的处理器，通常称为GPUs或图形处理单元，是高度并行的，可以提供数千个并发线程执行。硬件是为吞吐量设计的，允许在更短的时间内处理更多的像素和顶点。所有这些并行性对图形算法来说都很好，但其他工作也得益于并行硬件。除了电子游戏，GPU还被用于加速物理计算，开发实时光线追踪代码，解决流体模拟的Navier-Stokes相关方程，以及开发理解气候的更快代码(Purcell, Buck, Mark， &amp; Hanrahan, 2002;S. G. Parker等人，2010;哈里斯,2004)。一些APIs和SDKs已经开发出来，可以提供更直接的通用计算，比如OpenCL和NVIDIA的CUDA。硬件加速光线追踪APIs也可以用来加速射线与物体的相交(S. G. Parker et al.， 2010)。类似地，用于为视频游戏的图形组件编程的标准APIs，如OpenGL和DirectX，也允许机制来利用图形硬件的并行能力。随着新硬件的开发以支持更复杂的计算，许多APIs都会发生变化。</strong></p>
<p><strong>图形硬件是可编程的。作为开发人员，您可以控制与处理几何图形、顶点和最终成为像素的片段相关的许多计算。最近的硬件变化以及APIs的持续更新，如OpenGL或DirectX，支持一个完全可编程的管线。这些变化为开发人员提供了利用GPU上可用的计算的创造性许可。在此之前，固定函数栅格化管道强制计算特定风格的顶点转换、光照和片段处理。管线的固定功能确保了基本的着色、照明和纹理可以非常快地发生。无论是可编程接口，还是固定函数计算，栅格化管线的基本计算是相似的，如下图所示。在栅格化管线中，顶点经过视图和投影变换矩阵的变换，由局部空间转换为全局空间，最终转换为屏幕坐标。与几何体顶点相关联的屏幕坐标集被栅格化为碎片。管线的最后阶段将片段处理成像素并可以应用每片段纹理查找，照明，和任何必要的混合。一般来说，流水线可以并行执行，GPU内核可以同时处理顶点和碎片。关于栅格化管道的更多细节可以在第8章中找到。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211015131612.png" class="" title="image-20211015131612">

<p>基本图形硬件流水线由几个阶段组成，这些阶段将3D数据转换为2D屏幕对象，以便通过像素处理阶段进行栅格化和着色。</p>
<h2 id="Heterogeneous-Multiprocessing-异构多处理"><a href="#Heterogeneous-Multiprocessing-异构多处理" class="headerlink" title="Heterogeneous Multiprocessing 异构多处理"></a>Heterogeneous Multiprocessing 异构多处理</h2><p><strong>在使用图形硬件时，将CPU和GPU区分为单独的计算实体是很方便的。在这个上下文中，术语host指的是CPU，包括它可用的线程和内存。术语device是指GPU或图形处理单元，以及与之相关的线程和内存。这是有意义的，因为大多数图形硬件都是由通过PCI总线连接到计算机的外部硬件组成的。硬件也可以作为一个单独的芯片组焊接到机器上。从这个意义上说，图形硬件代表了一种特殊的协处理器，因为CPU(和它的核心)都可以被编程，GPU和它的核心也可以。所有使用图形硬件的程序必须首先建立CPU和GPU内存之间的映射。这是一个相当低级的细节，是必需的，以便驻留在操作系统中的图形硬件驱动程序可以在硬件、操作系统和窗口系统软件之间进行接口。回想一下，因为主机(CPU)和设备(GPU)是独立的，必须在两个系统之间进行数据通信。更正式地说，操作系统、硬件驱动程序、硬件和窗口系统之间的映射称为图形上下文。上下文通常是通过对窗口系统的API调用建立的。关于建立上下文的细节超出了本章的范围，但是许多窗口系统开发库都有方法查询图形硬件的各种功能，并基于这些需求建立图形上下文。因为设置上下文依赖于窗口系统，这也意味着这样的代码不太可能是跨平台的代码。然而，在实践中，或者至少在开始时，不太可能需要这种低级上下文设置代码，因为存在许多高级API来帮助人们开发可移植的交互式应用程序。</strong></p>
<p><strong>许多用于开发交互式应用程序的框架都支持查询输入设备(如键盘或鼠标)。一些框架提供对网络、音频系统和其他高级系统资源的访问。在这方面，许多API是开发图形甚至游戏应用程序的首选方法。</strong></p>
<p><strong>跨平台硬件加速通常是通过OpenGL API实现的。OpenGL是一个开放的工业标准图形API，支持多种图形硬件的硬件加速。OpenGL是图形硬件编程中最常见的API之一，还有DirectX等API。虽然OpenGL可以在许多操作系统和硬件架构上使用，但DirectX只适用于基于微软的系统。在本章中，我们将使用OpenGL来介绍硬件编程的概念和示例。</strong></p>
<h3 id="Programming-with-OpenGL-使用OpenGL编程"><a href="#Programming-with-OpenGL-使用OpenGL编程" class="headerlink" title="Programming with OpenGL 使用OpenGL编程"></a>Programming with OpenGL 使用OpenGL编程</h3><p><strong>当你用OpenGL API编程时，你至少在为两个处理器编写代码:CPU(s)和GPU(s)。OpenGL是在一个C风格的API中实现的，所有的函数都带有“gl”前缀，以表示它们包含在OpenGL中。OpenGL函数调用改变图形硬件的状态，可以用来声明和定义几何体，加载顶点和碎片着色器，并确定数据通过硬件时如何进行计算。</strong></p>
<p><strong>本章介绍的OpenGL的变体是OpenGL 3.3 Core Profile版本。虽然不是OpenGL的最新版本，但OpenGL的3.3版本符合OpenGL编程的未来方向。这些版本专注于提高效率，同时也将管线的编程完全交给了开发人员。许多功能在OpenGL的早期版本中出现的调用在这些更新的API中并不存在。例如，立即模式呈现已弃用。即时模式渲染用于在每帧需要时将数据从CPU内存发送到显卡内存，通常效率非常低，特别是对于较大的模型和复杂的场景。当前的API侧重于在需要数据之前将数据存储在显卡上，并在呈现时实例化它。另一个例子是，OpenGL的矩阵栈也被弃用了，开发者只能使用第三方的矩阵库(如GLM)或他们自己的类来创建必要的矩阵来查看、投影和转换，如第7章所述。因此，OpenGL的着色器语言(GLSL)也承担了更大的角色，在着色器中执行必要的矩阵转换以及照明和着色。因为执行逐顶点转换和光照的固定函数管道不再存在，程序员必须自己开发所有的着色器。本章提供的着色示例将使用GLSL 3.3 Core Profile版本的着色器规范。本章的未来读者会想要探索当前的OpenGL和OpenGL着色语言规范，以获得这些API和语言支持的更多细节。</strong></p>
<h2 id="Graphics-Hardware-Programming-Buffers-State-and-Shaders-图形硬件编程：缓冲区、状态和着色器"><a href="#Graphics-Hardware-Programming-Buffers-State-and-Shaders-图形硬件编程：缓冲区、状态和着色器" class="headerlink" title="Graphics Hardware Programming: Buffers, State, and Shaders 图形硬件编程：缓冲区、状态和着色器"></a>Graphics Hardware Programming: Buffers, State, and Shaders 图形硬件编程：缓冲区、状态和着色器</h2><p><strong>三个概念将有助于理解当代图形硬件编程。第一个是数据缓冲区的概念，它非常简单，是设备上的内存的线性分配，可以存储GPU操作的各种数据。第二个想法是，显卡维持计算状态，决定与场景数据和着色器相关的计算如何在图形硬件上发生。此外，状态可以从主机传递到设备，甚至在着色器之间的设备内部。着色器代表了GPU上与逐顶点或逐片段处理相关的计算发生的机制。本章将专注于顶点和碎片着色器，但专门的几何和计算着色器也存在于当前版本的OpenGL中。着色器在现代图形硬件的功能中扮演着非常重要的角色。</strong></p>
<h3 id="Buffers-缓冲区"><a href="#Buffers-缓冲区" class="headerlink" title="Buffers 缓冲区"></a>Buffers 缓冲区</h3><p><strong>缓冲区是图形硬件上存储数据的主要结构。它们代表了图形硬件的内部存储器与一切相关几何、纹理和图像平面数据。对于第8章中描述的光栅化管线，与硬件加速光栅化相关的计算读写GPU上的各种缓冲区。从编程的角度来看，应用程序必须初始化GPU上应用程序所需要的缓冲区。这相当于主机对设备的复制操作。在执行的各个阶段结束时，也可以执行从设备到主机的拷贝，将数据从GPU拉到CPU内存。此外，OpenGL的API中确实存在允许设备内存映射到主机内存的机制，以便应用程序可以直接写入显卡上的缓冲区。</strong></p>
<h3 id="Display-Buffer-显示缓冲区"><a href="#Display-Buffer-显示缓冲区" class="headerlink" title="Display Buffer 显示缓冲区"></a>Display Buffer 显示缓冲区</h3><p><strong>在图形管线中，最终的一组像素颜色可以链接到显示器，也可以将它们作为PNG图像写入磁盘。与这些像素相关联的数据通常是颜色值的2D数组。数据本质上是2D的，但它在GPU上被有效地表示为一维线性阵列的内存。这个数组实现了显示缓冲区，它最终被映射到窗口。渲染图像涉及到通过图形API将更改通信到图形硬件上的显示缓冲区。在栅格化管线的最后，分片处理和混合阶段将数据写入输出显示缓冲存储器。同时，开窗系统读取显示缓冲区的内容以在监视器的窗口上产生光栅图像。</strong></p>
<h3 id="Cycle-of-Refresh-刷新周期"><a href="#Cycle-of-Refresh-刷新周期" class="headerlink" title="Cycle of Refresh 刷新周期"></a>Cycle of Refresh 刷新周期</h3><p><strong>大多数应用程序更喜欢双缓冲显示状态。这意味着有两个与图形窗口相关联的缓冲区:前缓冲区和后缓冲区。双缓冲系统的目的是，应用程序可以将更改通信到后缓冲区(从而写入该缓冲区)，而前缓冲区内存用于驱动窗口上的像素颜色。</strong></p>
<p><strong>在呈现循环的末尾，缓冲区通过指针交换进行交换。前缓冲区指针指向后缓冲区，然后后缓冲区指针被分配给前一个前缓冲区。通过这种方式，窗口系统将用最新的缓冲区刷新窗口的内容。如果缓冲区指针交换与整个显示的窗口系统刷新同步，呈现将无缝显示。否则，用户可能会观察到实际显示器上的几何图形被撕裂，因为场景的几何图形和碎片被处理(从而写入显示缓冲区)的速度比屏幕刷新的速度快。</strong></p>
<p><strong>当显示器被认为是内存缓冲区时，显示器上最简单的操作之一本质上是内存设置(或复制)操作，该操作将内存置零，或将内存清除到默认状态。对于图形程序，这可能意味着将窗口的背景清除为特定的颜色。要在OpenGL应用程序中清除背景颜色(变为黑色)，可以使用以下代码:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016122305.png" class="" title="image-20211016122305">

<p><strong>glClearColor函数的前三个参数表示在范围[0,1]内指定的红色、绿色和蓝色颜色组件。第四个参数表示不透明度，或alpha值，范围从0.0完全透明到1.0完全不透明。alpha值用于在管道的最后阶段通过各种片段混合操作确定透明度。</strong></p>
<p><strong>此操作仅清除颜色缓冲。除了颜色缓冲区,由GL COLOR BUFFER BIT允许在这种情况下清除到黑色,图形硬件还使用一个深度缓冲来表示碎片的距离相对于相机(你可能记得z-buffer算法在第8章)的讨论。清除深度缓冲z-buffer算法是必要的,以确保操作正确,并允许隐面消除发生。清除深度缓冲区可以通过或’ ‘两个位字段值一起，如下所示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016122608.png" class="" title="image-20211016122608">

<p><strong>在一个基本的交互式图形应用程序中，这个清除步骤通常是在处理任何几何图形或片段之前执行的第一个操作。</strong></p>
<h2 id="State-Machine-状态机"><a href="#State-Machine-状态机" class="headerlink" title="State Machine 状态机"></a>State Machine 状态机</h2><p><strong>通过对显示器颜色和深度缓冲区的缓冲区清除操作的说明，还介绍了图形硬件状态的思想。glClearColor函数设置在调用glClear时写入颜色缓冲区中所有像素的默认颜色值。清除调用初始化显示缓冲区的颜色组件，也可以重置深度缓冲区的值。如果清除颜色在应用程序中没有改变，那么清除颜色只需要设置一次，这通常是在OpenGL程序的初始化中完成的。每次调用glClear时，它都会使用先前设置的清除颜色状态。</strong></p>
<p><strong>还要注意，z-buffer算法状态可以根据需要启用或禁用。z-缓冲区算法在OpenGL中也被称为深度测试。通过启用它，在将任何片段颜色写入颜色缓冲区之前，片段的深度值将与当前存储在深度缓冲区中的深度值进行比较。有时，深度测试是不必要的，可能会降低应用程序的运行速度。禁用深度测试将阻止z-buffer计算并改变可执行文件的行为。使用OpenGL启用z-buffer测试如下所示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016122824.png" class="" title="image-20211016122824">

<p><strong>glEnable调用打开深度测试，而glDepthFunc调用设置如何执行深度比较的机制。在这种情况下，depth函数被设置为GL_LESS的默认值，以表明存在其他状态变量，并且可以修改。与glEnable调用相反的是glDisable调用。</strong></p>
<p><strong>OpenGL中的状态概念模仿了面向对象类中静态变量的使用。根据需要，程序员可以启用、禁用和/或设置驻留在显卡上的OpenGL变量的状态。这些状态会影响硬件上的后续计算。一般来说，高效的OpenGL程序试图最小化状态变化，启用需要的状态，同时禁用渲染不需要的状态。</strong></p>
<h2 id="Basic-OpenGL-Application-Layout-基本OpenGL应用程序布局"><a href="#Basic-OpenGL-Application-Layout-基本OpenGL应用程序布局" class="headerlink" title="Basic OpenGL Application Layout 基本OpenGL应用程序布局"></a>Basic OpenGL Application Layout 基本OpenGL应用程序布局</h2><p><strong>一个简单而基本的OpenGL应用程序的核心是一个显示循环，该循环被调用的速度要么尽可能快，要么与监视器或显示设备的刷新率相一致。下面的示例循环使用GLFW库，它支持OpenGL跨多个平台编码。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016123044.png" class="" title="image-20211016123044">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016123056.png" class="" title="image-20211016123056">

<p><strong>循环被严格限制为仅在窗口打开时操作。这个例子循环重置颜色缓冲值，也重置基于先前设置(或默认)值的图形硬件内存中的z-缓冲深度值。输入设备，如键盘、鼠标、网络或其他一些交互机制在循环结束时被处理，以改变与程序相关联的数据结构的状态。对glfwSwapBuffers的调用将图形上下文与显示刷新同步，在前缓冲区和后缓冲区之间执行指针交换，以便更新后的图形状态显示在用户屏幕上。交换缓冲区的调用发生在发出所有图形调用之后。</strong><br><strong>虽然在概念上是分开的，但深度缓冲区和颜色缓冲区通常统称为framebuffer。通过清除framebuffer的内容，应用程序可以继续执行额外的OpenGL调用，通过图形管道推送几何图形和片段。framebuffer与已经打开以包含图形上下文的窗口的大小直接相关。OpenGL需要窗口或视口的尺寸来构造Mvp 矩阵(来自第7章)的硬件。这是通过下面的代码完成的，再次使用GLFW工具包演示，它提供了查询请求窗口(或framebuffer)维度的函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016123154.png" class="" title="image-20211016123154">

<p><strong>在这个例子中，glViewport使用nx和ny为窗口的宽度和高度设置窗口维度的OpenGL状态，并指定视图从原点开始。</strong></p>
<p><strong>从技术上讲，OpenGL在栅格化几何图形和处理片段的操作中写入framebuffer内存。这些写入发生在像素显示在用户监视器上之前。</strong></p>
<h2 id="Geometry-几何学"><a href="#Geometry-几何学" class="headerlink" title="Geometry 几何学"></a>Geometry 几何学</h2><p><strong>与显示缓冲区的概念类似，几何图形也使用数组来存储顶点数据和其他顶点属性，如顶点颜色、法线或着色所需的纹理坐标。缓冲区的概念将被用于在图形硬件上分配存储空间，用于从主机向设备传输数据。</strong></p>
<h3 id="Describing-Geometry-for-the-Hardware-硬件上描述几何形状"><a href="#Describing-Geometry-for-the-Hardware-硬件上描述几何形状" class="headerlink" title="Describing Geometry for the Hardware 硬件上描述几何形状"></a>Describing Geometry for the Hardware 硬件上描述几何形状</h3><p><strong>图形硬件编程的挑战之一是管理3D数据及其在图形硬件内存中的传输。大多数图形硬件使用特定的几何原语集。不同的基元类型利用基元复杂性来提高图形硬件的处理速度。简单的原语有时可以处理得非常快。需要注意的是，原始类型需要是通用的，以便为从非常简单到非常复杂的广泛几何建模。在典型的图形硬件上，基本类型仅限于以下一种或多种:</strong></p>
<p>​    <strong>•点：用于表示点或粒子系统的单个顶点;</strong></p>
<p>​    <strong>•线：顶点对用于表示线，轮廓，或边缘突出;</strong></p>
<p>​    <strong>•三角形：三角形，三角形带，索引三角形，索引三角形带，四边形，或近似几何表面的三角形网格。</strong></p>
<p><strong>这三种基本类型构成了大多数可定义几何体的基本构建块。下图显示了一个用OpenGL渲染的三角形网格的例子。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211016123602.png" class="" title="image-20211016123602">

<p>几何图形的组织方式将影响应用程序的性能。小棉白杨峡谷地形数据集的线框图显示了数以万计的三角形组织成一个三角形网格，以实时速率运行。图像使用Ben Discoe提供的VTerrain项目地形系统进行渲染。</p>
<h2 id="A-First-Look-at-Shaders-初探着色器"><a href="#A-First-Look-at-Shaders-初探着色器" class="headerlink" title="A First Look at Shaders 初探着色器"></a>A First Look at Shaders 初探着色器</h2><p><strong>现代版本的OpenGL要求使用着色器来处理顶点和碎片。因此，如果没有至少一个顶点着色器来处理传入的原始顶点和另一个着色器来处理栅格化碎片，就不能渲染原语。高级着色器类型存在于OpenGL和OpenGL着色语言中:几何着色器和计算着色器。几何着色器被设计来处理原语，潜在地创建额外的原语，并且可以支持几何实例化操作。计算着色器是为在GPU上执行一般计算而设计的，并且可以链接到特定应用程序所需的着色器集合中。关于几何和计算着色器的更多信息，读者可以参考OpenGL规范文档和其他资源。</strong></p>
<h3 id="Vertex-Shader-Example-顶点着色器示例"><a href="#Vertex-Shader-Example-顶点着色器示例" class="headerlink" title="Vertex Shader Example 顶点着色器示例"></a>Vertex Shader Example 顶点着色器示例</h3><p><strong>顶点着色器提供了对如何转换顶点的控制，并且经常帮助准备碎片着色器中使用的数据。除了标准的转换和潜在的逐顶点光照操作，顶点着色器可以用于在GPU上执行一般的计算。例如，如果顶点代表粒子，并且粒子运动可以在顶点着色器计算中(简单地)建模，那么CPU基本上可以从执行这些计算中移除。对已经存储在图形硬件内存中的顶点执行计算的能力是一个潜在的性能增益。虽然这种方法在某些情况下是有用的，高级一般计算可能更适当地编码计算着色器。</strong></p>
<p><strong>在第7章，视口矩阵Mvp 介绍了。它将规范视图体积坐标转换为屏幕坐标。在规范视图体积内，坐标存在于[−1,1]范围内。任何超出这个范围的都将被截断。如果我们做一个初始假设，几何存在于这个范围内，z值被忽略，我们可以创建一个非常简单的顶点着色器。这个顶点着色器将顶点位置传递到栅格化阶段，在那里最终的视口转换将发生。注意，由于这种简化，没有投影、查看或模型转换将应用于传入顶点。除了非常简单的场景，这对于创建任何东西来说都是很麻烦的，但这将有助于引入着色器的概念，并允许你在屏幕上渲染一个初始三角形。通过顶点着色器如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017140002.png" class="" title="image-20211017140002">

<p><strong>这个顶点着色器只做一件事。它将进入的顶点位置作为OpenGL用于光栅化片段的gl_position传递出去。注意gl_Position是一个内置的保留变量，它表示顶点着色器所需的关键输出之一。还要注意第一行中的版本字符串。在本例中，该字符串指示GLSL编译器使用GLSL Core配置文件的3.3版本来编译着色语言。</strong></p>
<p><strong>顶点和片段着色器是SIMD操作，分别对管道中正在处理的所有顶点或片段进行操作。额外的数据可以通过使用输入、输出或统一变量从主机传递到在设备上执行的着色器。传递到着色器中的数据以关键字in作为前缀。该数据的位置，因为它与特定的顶点属性或片段输出索引也直接在着色器中指定。因此,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017140244.png" class="" title="image-20211017140244">

<p><strong>指定in_Position是类型为vec3的输入变量。该数据的来源是与几何图形关联的属性索引0。这个变量的名字是由程序员决定的，当在设备上设置顶点数据时，进入的几何体和着色器之间的连接发生。GLSL包含各种各样对图形程序有用的类型，包括vec2、vec3、vec4、mat2、mat3和mat4等等。标准类型如int或float也存在。在着色器编程中，矢量，如vec4包含4个分量，分别对应于齐次坐标的x、y、z和w分量，或者r、g、b和RGBA元组的一个分量。类型的标签可以根据需要进行交换(甚至重复)，这称为swizzling(例如，在Position.zyxa中)。此外，组件标签是重载的，可以适当地使用它来提供上下文。</strong></p>
<p><strong>所有的着色器必须有一个主函数来执行所有输入的主要计算。在这个例子中，main函数简单地将vec3类型的输入顶点位置(In_position)复制到内置的vec4类型的顶点着色输出变量中。注意，许多内置类型都有对转换有用的构造函数，比如这里展示的将进入顶点位置的vec3类型转换为gl_position的vec4类型的构造函数类型。在OpenGL中使用齐次坐标，因此1.0被指定为第四个坐标，以表示向量是一个位置。</strong></p>
<h3 id="Fragment-Shader-Example-碎片着色器示例"><a href="#Fragment-Shader-Example-碎片着色器示例" class="headerlink" title="Fragment Shader Example 碎片着色器示例"></a>Fragment Shader Example 碎片着色器示例</h3><p><strong>如果最简单的顶点着色器只是通过剪辑坐标，最简单的碎片着色器设置碎片的颜色为常量值。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017143442.png" class="" title="image-20211017143442">

<p><strong>在这个例子中，所有的片段将被设置为浅绿色。一个关键的区别是out关键字的使用。一般来说，在着色程序中的关键字In和out表示数据流入和流出着色器。当顶点着色器接收到传入的顶点并将它们输出到一个内置变量时，分段着色器声明它的输出值，并将输出值写入颜色缓冲区:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017143522.png" class="" title="image-20211017143522">

<p><strong>输出变量out_FragmentColor也是用户定义的。输出的位置是颜色缓冲区索引0。片段着色器可以输出到多个缓冲区，但这是留给读者的一个高级主题，如果研究OpenGL的framebuffer对象，将需要它。布局和位置关键字的使用使得应用程序的顶点着色器中的几何数据和片段着色器中的输出颜色缓冲之间有一个明确的连接。</strong></p>
<h3 id="Loading-Compiling-and-Using-Shaders-加载、编译和使用着色器"><a href="#Loading-Compiling-and-Using-Shaders-加载、编译和使用着色器" class="headerlink" title="Loading, Compiling, and Using Shaders 加载、编译和使用着色器"></a>Loading, Compiling, and Using Shaders 加载、编译和使用着色器</h3><p><strong>着色程序以字符串的形式转移到图形硬件上。然后必须对它们进行编译和链接。此外，着色器被耦合到着色程序中，以便顶点和片段处理以一致的方式发生。开发人员可以激活一个已经成功编译并链接到着色程序的着色器，同时也可以在不需要的时候禁用着色器。而具体的创作过程，加载，编译和链接着色程序在本章中没有提供，下面的OpenGL函数将有助于创建着色器:</strong> </p>
<p>​    <strong>•glCreateShader在硬件上创建一个shader句柄。</strong> </p>
<p>​    <strong>•glShaderSource将字符串加载到图形硬件内存中。</strong> </p>
<p>​    <strong>•glCompileShader在硬件中执行着色器的实际编译。</strong> </p>
<p><strong>上面的功能需要为每个着色器调用。因此，对于简单的直通着色器，每个函数都将被顶点着色器代码和片段着色器代码所调用。在编译阶段结束时，可以使用额外的OpenGL命令查询编译状态和任何错误。</strong></p>
<p><strong>在两个着色器代码加载和编译后，它们可以链接到着色器程序。着色程序是用来影响几何图形的渲染。</strong></p>
<p>​    <strong>•glCreateProgram创建一个程序对象，该对象将包含先前编译的着色器。</strong> </p>
<p>​    <strong>•glAttachShader将一个shader附加到shader程序对象。在这个简单的例子中，编译后的顶点着色器和编译后的碎片着色器对象都会调用这个函数。</strong></p>
<p>​    <strong>•在所有着色器被附加到程序对象之后，glLinkProgram在内部链接着色器。</strong></p>
<p>​    <strong>•glUseProgram绑定用于图形硬件的着色程序。由于需要着色器，程序句柄使用这个函数绑定。当不需要着色器时，它们可以通过使用着色程序句柄0作为这个函数的参数来解除绑定。</strong></p>
<h2 id="Vertex-Buffer-Objects-顶点缓冲区对象"><a href="#Vertex-Buffer-Objects-顶点缓冲区对象" class="headerlink" title="Vertex Buffer Objects 顶点缓冲区对象"></a>Vertex Buffer Objects 顶点缓冲区对象</h2><p><strong>顶点使用缓冲区存储在图形硬件上，称为顶点缓冲区对象。除了顶点，任何额外的顶点属性，如颜色、法向量或纹理坐标，也将使用顶点缓冲对象指定。</strong></p>
<p><strong>首先，让我们关注几何原语本身。首先在应用程序的主机内存中分配与原语关联的顶点。最常用的方法是在主机上定义一个数组来包含原语所需的顶点。例如，一个完全包含在标准体积中的三角形，可以在主机上静态定义，如下所示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017144408.png" class="" title="image-20211017144408">

<p><strong>如果这个三角形使用简单的透传着色器，那么所有的顶点都将被渲染。尽管三角形被放置在z = 0平面上，但是这个例子中的z坐标并不重要，因为它们实际上是在最终转换为屏幕坐标时被丢弃的。另一件需要注意的事情是在这些示例中使用了类型GLfloat。就像GLSL语言有专门的类型一样，OpenGL也有相关类型，这些类型通常可以与标准类型很好地混合在一起(比如float)。为了精确起见，OpenGL类型将在必要时使用。</strong></p>
<p><strong>在处理顶点之前，首先在设备上创建一个顶点缓冲区来存储顶点。然后，主机上的顶点被传输到设备。在此之后，可以根据需要引用顶点缓冲区来绘制存储在缓冲区中的顶点数组。此外，在初始顶点数据传输之后，不需要在主机上向设备总线复制额外的数据，特别是在渲染循环更新过程中几何形状保持静态的情况下。如果是动态分配的，也可以删除任何主机内存。</strong></p>
<p><strong>顶点缓冲对象，通常称为VBOs，代表了现代OpenGL在图形存储器中存储顶点和顶点属性的主要机制。为了提高效率，VBO的初始设置和顶点相关数据的传输通常发生在进入显示循环之前。例如，要为这个三角形创建一个VBO，可以使用以下代码:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017144658.png" class="" title="image-20211017144658">

<p><strong>创建和分配顶点缓冲区对象需要三个OpenGL调用。首先，glGenBuffers创建一个句柄，一旦VBO存储在设备上，就可以使用该句柄来引用它。可以在一个glGenBuffers调用中创建多个VBOs句柄(存储在数组中)，如图所示，但这里没有使用。请注意，当生成缓冲区对象时，设备上的实际空间分配尚未执行。</strong></p>
<p><strong>在OpenGL中，对象(比如顶点缓冲区对象)是计算和处理的主要目标。对象必须绑定到一个已知的OpenGL状态使用时松开，不使用时松开。OpenGL使用对象的例子包括顶点缓冲对象、framebuffer对象、纹理对象和着色程序等等。在当前的例子中，OpenGL的GL_ARRAY_BUFFER状态绑定到之前生成的三角形VBO句柄。这使得三角形VBO成为活动顶点缓冲区对象。任何跟随glBindBuffer(GL_ARRAY_BUFFER, triangleVBO[0])命令的影响顶点缓冲区的操作都将通过读数据或写数据来使用VBO中的三角形数据。</strong></p>
<p><strong>顶点数据从主机(顶点数组)复制到设备(当前绑定的GL_ARRAY_BUFFER)使用</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017144907.png" class="" title="image-20211017144907">

<p><strong>调用。参数表示目标的类型、要复制的缓冲区的字节大小、指向主机缓冲区的指针以及指示如何使用缓冲区的枚举类型。在当前的示例中，目标是GL_ARRAY_BUFFER，数据的大小是9∗sizeof(GLfloat)，最后一个参数是GL_STATIC_DRAW，指示OpenGL顶点在渲染过程中不会改变。最后，当VBO不再需要作为读写的活动目标时，它将通过glBindBuffer(GL_ARRAY_BUFFER, 0)调用解除绑定。通常，绑定任何OpenGL的对象或缓冲区来处理0，解除绑定，或禁用该缓冲区，以免影响后续功能。</strong></p>
<h2 id="Vertex-Array-Objects-顶点数组对象"><a href="#Vertex-Array-Objects-顶点数组对象" class="headerlink" title="Vertex Array Objects 顶点数组对象"></a>Vertex Array Objects 顶点数组对象</h2><p><strong>顶点缓冲区对象是顶点(和顶点属性)的存储容器，顶点数组对象代表OpenGL的机制，将顶点缓冲区捆绑在一起，形成一致的顶点状态，可以与图形硬件中的着色器通信和链接。回想一下，过去的固定函数管道不再存在，因此，每个顶点的状态，如法线或甚至顶点颜色，必须存储在硬件缓冲区中，然后使用输入变量(如in)在着色器中引用。</strong></p>
<p><strong>与顶点缓冲区对象一样，必须在绑定顶点数组对象时创建和分配顶点数组对象(或VAOs)，并设置任何必要的状态。例如，下面的代码展示了如何创建一个VAO来包含之前定义的三角形VBO:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145242.png" class="" title="image-20211017145242">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145305.png" class="" title="image-20211017145305">

<p><strong>当定义一个顶点数组对象时，特定的顶点缓冲对象可以绑定到着色器代码中的特定顶点属性(或输入)。使用</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145416.png" class="" title="image-20211017145416">

<p><strong>在直通顶点着色器中。这个语法表示着色器变量将从绑定顶点数组对象的属性索引0接收数据。在主机代码中，使用</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145432.png" class="" title="image-20211017145432">

<p><strong>调用。第一个调用启用顶点属性索引(在本例中为0)。接下来的两个调用将之前定义的保存顶点的顶点缓冲区对象连接到顶点属性本身。因为glVertexAttribPointer利用了当前绑定的VBO，所以在分配顶点属性指针之前发出glBindBuffer是很重要的。这些函数调用创建一个映射，将顶点缓冲区中的顶点绑定到顶点着色器中的in Position变量。glVertexAttribPointer调用看起来很复杂，但它基本上设置了属性索引0来保存未标准化(第四个参数)的GLfloats(第2和第3个参数)的三个组件(例如x, y, z)。第五个参数指示OpenGL用三个浮点值分隔每个顶点集的起点。换句话说，这些顶点一个接一个地紧密地封装在内存中。最后一个参数是一个指向数据的指针，但是因为在此调用之前已经绑定了一个顶点缓冲区，所以数据将与顶点缓冲区相关联。</strong></p>
<p><strong>前面初始化和构造顶点数组对象、顶点缓冲对象和着色器的步骤都应该在进入显示循环之前执行。所有来自顶点缓冲区的内存将被转移到GPU，顶点阵列对象将在数据和着色器输入变量索引之间建立连接。在显示循环中，以下调用将触发顶点数组对象的处理:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145608.png" class="" title="image-20211017145608">

<p><strong>再次注意，bind调用使顶点数组对象处于活动状态。对glDrawArrays的调用为这个几何图形启动了管线，描述了这个几何图形应该被解释为一系列从偏移量0开始的三角形原语，并且只呈现三个索引。在本例中，数组中只有三个元素，而原语是一个三角形，因此将呈现一个三角形。</strong></p>
<p><strong>结合所有这些步骤，为三角形组装的代码将类似如下，假设着色器和顶点数据加载包含在外部函数中:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145728.png" class="" title="image-20211017145728">

<p><strong>下图显示了使用着色器和顶点状态渲染规范视图体积三角形的结果。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017145741.png" class="" title="image-20211017145741">

<p>标准三角形使用简单的顶点和碎片着色器渲染。</p>
<h2 id="Transformation-Matrices-变换矩阵"><a href="#Transformation-Matrices-变换矩阵" class="headerlink" title="Transformation Matrices 变换矩阵"></a>Transformation Matrices 变换矩阵</h2><p><strong>当前版本的OpenGL已经删除了曾经用于从硬件中引用投影和模型视图矩阵的矩阵堆栈。因为这些矩阵堆栈不再存在，程序员必须编写矩阵代码，可以转移到将发生转换的顶点着色器。起初，这似乎具有挑战性。但是，已经开发了几个库和工具包来帮助OpenGL代码的跨平台开发。其中一个库，GLM，或OpenGL Mathematics，已经被开发用于密切跟踪OpenGL和GLSL规范，以便GLM和硬件之间的互操作能够无缝地工作。</strong></p>
<h3 id="GLM"><a href="#GLM" class="headerlink" title="GLM"></a>GLM</h3><p><strong>GLM提供了几种对计算机图形学有用的基本数学类型。出于我们的目的，我们将专注于少数类型和少数功能，使矩阵变换在着色器中容易使用。以下几种类型将被使用:</strong></p>
<p>​    <strong>•glm::vec3：一个由3个浮点数组成的紧凑数组，可以在着色器中使用相同的组件访问;</strong> </p>
<p>​    <strong>•glm::vec4：一个由4个浮点数组成的紧凑数组，可以在着色器中使用相同的组件访问;</strong> </p>
<p>​    <strong>•glm:: mat4：一个4 × 4矩阵存储，表示为16个浮点数。矩阵是以column-major格式存储的。</strong> </p>
<p><strong>类似地，GLM提供用于创建投影矩阵Morth 和Mp的函数，以及生成视图矩阵Mcam的函数：</strong> </p>
<p>​    <strong>•glm::ortho：创建一个4 × 4正投影矩阵。</strong></p>
<p>​    <strong>•glm::perspective：创建4 × 4透视矩阵。</strong> </p>
<p>​    <strong>•glm::lookAt：创建4 × 4的齐次变换，转换和朝向镜头。</strong></p>
<h3 id="Using-an-Orthographic-Projection-使用正投影法"><a href="#Using-an-Orthographic-Projection-使用正投影法" class="headerlink" title="Using an Orthographic Projection 使用正投影法"></a>Using an Orthographic Projection 使用正投影法</h3><p><strong>前面示例的一个简单扩展是将三角形顶点放置到一个更灵活的坐标系统中，并使用正交投影渲染场景。前一个例子中的顶点可以变成:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150409.png" class="" title="image-20211017150409">

<p><strong>使用GLM，可以很容易地在主机上创建正投影。例如,</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150430.png" class="" title="image-20211017150430">

<p><strong>然后可以将投影矩阵应用于每个顶点，将其转换为剪辑坐标。顶点着色器将被修改来执行这个操作:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150447.png" class="" title="image-20211017150447">

<p><strong>这个计算将发生在一个修改过的顶点着色器中，它使用统一变量从主机向设备传递数据。统一变量表示在着色程序执行过程中保持不变的静态数据。所有元素的数据都是相同的，并且保持静态。然而，统一的变量可以被应用程序在执行着色器之间修改。这是宿主应用程序中的数据可以与着色器计算交流变化的主要机制。统一数据通常表示与应用程序相关联的图形状态。例如，投影、视图或模型矩阵可以通过统一变量设置和访问。关于场景中的光源的信息也可以通过均匀变量来获得。</strong></p>
<p><strong>修改顶点着色器需要添加一个统一的变量来保持投影矩阵。我们可以使用GLSL的mat4类型来存储这些数据。然后可以自然地使用投影矩阵将进入的顶点转换为规范坐标系:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150530.png" class="" title="image-20211017150530">

<p><strong>应用程序代码只需要将统一变量从主机内存(GLM mat4)转移到设备的着色程序(GLSL mat4)。这很简单，但需要在着色程序被链接之后，应用程序的主机端获得一个统一变量的句柄。例如，为了获得projMatrix变量的句柄，在着色程序链接完成后，将发出下面的调用:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150603.png" class="" title="image-20211017150603">

<p><strong>第一个参数是shader程序对象句柄，第二个参数是shader中变量名的字符串。然后，这个id可以与各种OpenGL glUniform函数调用一起使用，以将主机上的内存转移到设备上。然而，着色程序必须在设置与统一变量相关的值之前被绑定。另外，由于GLM用于在主机上存储投影矩阵，因此将使用GLM助手函数来获取指向底层矩阵的指针，并允许继续复制。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211017150647.png" class="" title="image-20211017150647">

<p><strong>注意glUniform采用的形式。函数名以帮助定义如何使用它的字符结尾。在这种情况下，一个4 × 4的浮点矩阵被转移到均匀变量。v表示数组包含数据，而不是按值传递。第三个参数让OpenGL知道矩阵是否应该被转置(一个可能很方便的特性)，最后一个参数是一个指向矩阵所在内存的指针。</strong></p>
<p><strong>通过本章的这一节，你应该对着色器和顶点数据在OpenGL渲染对象中所扮演的角色有一个感觉。特别是着色器，在现代OpenGL中扮演着非常重要的角色。其余部分将进一步探讨着色器在渲染场景中的作用，尝试建立在着色器在本书中呈现的其他渲染风格中的作用。</strong></p>
<h2 id="Shading-with-Per-Vertex-Attributes-逐顶点属性着色"><a href="#Shading-with-Per-Vertex-Attributes-逐顶点属性着色" class="headerlink" title="Shading with Per-Vertex Attributes 逐顶点属性着色"></a>Shading with Per-Vertex Attributes 逐顶点属性着色</h2><p><strong>前面的示例指定了一个没有附加数据的三角形。顶点属性，如法向量、纹理坐标，甚至颜色，都可以在顶点缓冲区中与顶点数据交叉。内存布局很简单。下面，每个顶点的颜色设置在数组中的每个顶点之后。三个组件用于表示红色、绿色和蓝色通道。分配顶点缓冲区是相同的，只是数组的大小现在是18 GLfloats而不是9。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018131914.png" class="" title="image-20211018131914">

<p><strong>顶点数组对象的规范是不同的。因为颜色数据在顶点之间交错，顶点属性指针必须适当地跨数据。也必须启用第二个顶点属性索引。在前面例子的基础上，我们构造新的VAO如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018131958.png" class="" title="image-20211018131958">

<p><strong>由于顶点和颜色数据都包含在VBO中，所以在设置属性之前使用和绑定单个VBO。第一个顶点属性在索引0处启用，这将代表着色器中的顶点。注意，步幅(第5个参数)是不同的，因为顶点被6个浮点数分开(例如，顶点的x, y, z后跟颜色的r, g, b)。第二个顶点属性索引是启用的，它将表示着色器中位置1的顶点颜色属性。它有相同的步幅，但是最后一个参数现在表示第一个颜色值开始的指针偏移量。虽然在上面的示例中使用了12，但这与声明3 * sizeof(GLfloat)是相同的。换句话说，我们需要跳过代表顶点x、y、z值的三个浮点数来定位数组中的第一个color属性。</strong></p>
<p><strong>这个例子的着色器只做了轻微的修改。顶点着色器(如下所示)的主要区别是:(1)第二个属性，颜色，位于位置1;(2)vColor是在顶点着色器的主体中设置的输出变量。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132110.png" class="" title="image-20211018132110">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132123.png" class="" title="image-20211018132123">

<p><strong>回想一下，关键字in和out指的是着色器之间的数据流。如果变量名称匹配，从顶点着色器流出的数据将成为连接片段着色器中的输入数据。此外，传递给碎片着色器的输出变量是使用重心插值的碎片。可以使用额外的关键字对插值进行一些修改，但这些细节将留给读者。在这个例子中，指定了三个顶点，每个顶点都有一个特定的颜色值。在碎片着色器中，颜色将被插值到三角形的表面。</strong></p>
<p><strong>碎片着色器的改变是简单的。vColor变量被设置并传递出顶点着色器，现在变成了一个in变量。当片段被处理时，vColor vec3将根据片段在三角形中的位置包含正确的插值值。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132301.png" class="" title="image-20211018132301">

<p><strong>使用三角形数据运行这个着色器的结果如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132330.png" class="" title="image-20211018132330">

<p>在顶点着色器中设置每个顶点的颜色，并将数据传递给碎片着色器，结果是颜色的重心插值。</p>
<h3 id="Structs-of-Vertex-Data-顶点数据结构"><a href="#Structs-of-Vertex-Data-顶点数据结构" class="headerlink" title="Structs of Vertex Data 顶点数据结构"></a>Structs of Vertex Data 顶点数据结构</h3><p><strong>前面的示例演示了数组中数据的交错。顶点缓冲可以以多种方式使用，包括针对不同模型属性的单独顶点缓冲。交错数据具有优势，因为与某个顶点相关联的属性在内存中靠近该顶点，因此可以利用它在着色器中操作时的内存局部性。虽然这些交错数组的使用很简单，但以这种方式管理大型模型可能会变得很麻烦，特别是当数据结构被用于构建健壮的(和可持续的)图形软件基础结构时(见第12章)。将顶点数据存储为包含顶点和任何相关属性的结构的向量是相当简单的。当这样做时，结构只需要映射到顶点缓冲区。例如，下面的结构包含顶点位置和顶点颜色，使用GLM的vec3类型:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132540.png" class="" title="image-20211018132540">

<p><strong>STL向量将保存与模型中所有三角形相关的所有顶点。我们将继续使用与前面示例相同的三角形布局，即基本三角形带。列表中每三个顶点代表一个三角形。OpenGL还可以使用其他数据组织，第12章提供了更有效地组织数据的其他选项。</strong></p>
<p><strong>一旦数据加载到向量中，在将数据加载到顶点缓冲区对象之前使用了相同的调用:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132617.png" class="" title="image-20211018132617">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018132630.png" class="" title="image-20211018132630">

<p><strong>STL向量连续存储数据。上面使用的vertexData结构体由平面内存布局表示(它不包含指向其他数据元素的指针)，并且是连续的。然而，STL向量是一个抽象，引用底层内存的指针必须使用data()成员进行查询。该指针提供给对glBufferData的调用。顶点数组对象中的属性分配是相同的，因为顶点属性的位置保持不变。</strong></p>
<h2 id="Shading-in-the-Fragment-Processor-碎片处理器着色"><a href="#Shading-in-the-Fragment-Processor-碎片处理器着色" class="headerlink" title="Shading in the Fragment Processor 碎片处理器着色"></a>Shading in the Fragment Processor 碎片处理器着色</h2><p><strong>图形管线章节(第8章)和表面着色章节(第10章)很好地描述和说明了逐顶点和逐片段着色的效果，因为它们通常与栅格化和着色相关。在现代图形硬件中，在片段处理器中应用着色算法可以产生更好的视觉效果，更准确地逼近光照。在逐顶点基础上计算的着色通常会受到与底层几何镶嵌相关的视觉伪影的影响。特别是，基于每个顶点的着色经常不能在三角形的表面上近似适当的强度，因为光照只在每个顶点上计算。例如，当与光源的距离较小时，与被遮挡的脸的大小相比，脸上的照明就会不正确。下图说明了这种情况。三角形的中心将不会被照亮，尽管非常接近光源，因为顶点上的照明，远离光源，是用来插值整个面部的着色。当然，增加几何的镶嵌可以改善视觉效果。然而，这种解决方案在实时图形中的应用有限，因为为更精确的光照而添加的几何图形会导致渲染速度变慢。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018133310.png" class="" title="image-20211018133310">

<p>与光源的距离很小与三角形的大小有关。</p>
<p><strong>碎片着色器在顶点被转换和裁剪后从栅格化中出现的碎片上操作。一般来说，片段着色器必须输出一个写入framebuffer的值。通常，这是像素的颜色。如果启用了深度测试，则将使用片段的深度值来控制是否将颜色及其深度写入framebuffer内存。碎片着色器用于计算的数据来自不同的来源:</strong></p>
<p>​    <strong>•内置OpenGL变量：这些变量是由系统提供的。片段着色器变量的例子包括gl_FragCoord或gl_FrontFacing。这些变量可能会根据OpenGL和GLSL的修订而改变，所以建议您检查您所瞄准的OpenGL和GLSL版本的规范。</strong></p>
<p>​    <strong>•统一变量：统一变量从主机转移到设备，并可以根据用户输入或应用程序中的模拟状态的变化而根据需要进行更改。这些变量由程序员声明和定义，在顶点和片段着色器中使用。在之前的顶点着色例子中的投影矩阵是通过统一变量传达给着色器的。如果需要，相同的统一变量名称可以在顶点和碎片着色器中使用。</strong></p>
<p>​    <strong>•输入变量：输入变量是在片段着色器中用带前缀的关键字in指定的。回想一下，数据可以流入和流出着色器。顶点着色器可以使用out关键字将数据输出到下一个着色器阶段(例如，在前面的例子中，out vec3 vColor)。当下一阶段使用in关键字，后面跟着相同的类型和名称限定符时，输出被链接到输入(例如，在vec3 vColor中，在前面例子中对应的片段着色器)。</strong></p>
<p><strong>任何通过输入-输出链接机制传递到片段着色器的数据都将使用重心插值在每个片段的基础上变化。插值运算是由图形硬件在着色器之外计算的。在这个基础结构中，碎片着色器可以用来执行每个碎片着色算法，评估整个三角形表面的特定方程。顶点着色器提供了对计算的支持，转换顶点和分段的中间值将被插入片段代码。</strong></p>
<p><strong>下面的着色程序代码实现了每个片段，Blinn-Phong着色。它汇集了本章到目前为止所呈现的大部分内容，并将其绑定到第4章的着色器描述中。交错顶点缓冲区用于包含顶点位置和法向量。这些值在顶点着色器中显示为索引0和索引1的顶点数组属性。在片段着色器代码中发生的着色计算是在摄像机坐标(有时称为眼空间)中执行的。</strong></p>
<h3 id="Blinn-Phong-Shader-Program-Vertex-Shader-Blinn-Phong着色程序-顶点着色器"><a href="#Blinn-Phong-Shader-Program-Vertex-Shader-Blinn-Phong着色程序-顶点着色器" class="headerlink" title="Blinn-Phong Shader Program: Vertex Shader Blinn-Phong着色程序:顶点着色器"></a>Blinn-Phong Shader Program: Vertex Shader Blinn-Phong着色程序:顶点着色器</h3><p><strong>我们的程序的顶点着色阶段是使用Mmodel 和Mcam 矩阵来将进入的顶点转换为摄像机坐标。它也使用(M ^−1) ^T，以适当地变换入法向量属性。顶点着色器输出三个变量到片段阶段:</strong> </p>
<p><strong>•法线：将顶点的法向量转换为摄像机坐标系统。</strong> </p>
<p><strong>•h： Blinn-Phong着色所需的半矢量。</strong> </p>
<p><strong>•l：光线方向转换为摄像机坐标系统。</strong> </p>
<p><strong>在应用重心插值后，这些变量中的每一个都可以用于碎片计算。</strong></p>
<p><strong>这个着色器程序使用单点光源。光的位置和强度使用统一的变量传达给顶点和碎片着色器。light数据是使用GLSL的结构限定符声明的，它允许变量以有意义的方式分组在一起。虽然这里没有介绍，但GLSL支持数组和for循环控制结构，因此可以很容易地向本示例添加额外的光源。</strong></p>
<p><strong>所有矩阵也使用统一变量提供给顶点着色器。现在，我们将想象模型(或局部变换)矩阵将被设置为单位矩阵。在下一节中，将提供更多细节，以扩展如何使用GLM在主机上指定模型矩阵。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018133907.png" class="" title="image-20211018133907">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018133934.png" class="" title="image-20211018133934">

<p><strong>顶点着色器的主要功能首先使用vec4类型将位置和光线位置转换为摄像机坐标，以对应GLSL的mat4的4 × 4矩阵。然后我们转换法向量并将其存储在out vec4法向量变量中。然后计算视图(或眼睛)向量和光方向向量，这导致计算Blinn-Phong着色所需的半向量。最后的计算完成了计算</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134020.png" class="" title="image-20211018134020">

<p><strong>通过应用投影矩阵。然后它将顶点的标准坐标设置为内置的GLSL顶点着色器输出变量gl_Position。在此之后，顶点在剪辑坐标中，并准备光栅化。</strong></p>
<h3 id="Blinn-Phong-Shader-Program-Fragment-Shader-Blinn-Phong-着色程序-碎片着色器"><a href="#Blinn-Phong-Shader-Program-Fragment-Shader-Blinn-Phong-着色程序-碎片着色器" class="headerlink" title="Blinn-Phong Shader Program: Fragment Shader Blinn-Phong 着色程序:碎片着色器"></a>Blinn-Phong Shader Program: Fragment Shader Blinn-Phong 着色程序:碎片着色器</h3><p><strong>碎片着色器计算Blinn-Phong着色模型。它接收顶点法向量、半矢量和光方向的重心插值值。注意，当这些变量从顶点处理阶段进入时，使用in关键字指定它们。光线数据也与碎片着色器共享，使用相同的统一规范在顶点着色器中使用。矩阵不是必需的，所以没有声明统一的矩阵变量。几何模型的材料属性通过统一变量来指定ka,kd,ks,Ia和p，数据允许碎片着色器计算公式4.3:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134541.png" class="" title="image-20211018134541">

<p><strong>在每一个片段。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134612.png" class="" title="image-20211018134612">

<p><strong>碎片着色器将计算出的强度写入碎片颜色输出缓冲区。下图展示了几个例子，展示了在几何模型上不同程度的镶嵌中每个碎片着色的效果。这个片段着色器引入了结构的使用来保持一致的变量。需要注意的是，它们是用户定义的结构，在本例中，LightData类型仅保存光的位置和强度。在宿主代码中，结构中的统一变量在请求统一变量句柄时使用完全限定变量名引用，如:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134701.png" class="" title="image-20211018134701">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018134712.png" class="" title="image-20211018134712">

<p>每个碎片着色应用于增加细分球体的镶嵌。镜面高光在较低镶嵌时很明显。</p>
<h3 id="A-Normal-Shader-法线着色器"><a href="#A-Normal-Shader-法线着色器" class="headerlink" title="A Normal Shader 法线着色器"></a>A Normal Shader 法线着色器</h3><p><strong>一旦你有一个工作着色程序，如Blinn-Phong，它很容易扩展你的想法和开发新的着色器。它也可能有助于开发一套非常具体的着色器调试。一个这样的着色程序是普通的着色程序。法线着色通常有助于理解进入的几何结构是否组织正确或计算是否正确。在这个例子中，顶点着色器保持不变。只有碎片着色器改变:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135010.png" class="" title="image-20211018135010">

<p><strong>无论你开始构建哪个着色器，一定要注释!GLSL规范允许在着色器代码中包含注释，所以请留下一些细节，以便以后指导您。</strong></p>
<h2 id="Meshes-and-Instancing-网格和实例化"><a href="#Meshes-and-Instancing-网格和实例化" class="headerlink" title="Meshes and Instancing 网格和实例化"></a>Meshes and Instancing 网格和实例化</h2><p><strong>一旦基本的着色器开始工作，开始创建更复杂的场景是很有趣的。有些3D模型文件很容易加载，而有些则需要付出更多的努力。OBJ格式是一种简单的3D对象文件表示。OBJ是一种广泛使用的格式，有一些代码可以加载这些类型的文件。前面介绍的结构体数组机制可以很好地在主机上包含OBJ数据。然后可以很容易地将其转移到VBO和顶点数组对象中。</strong></p>
<p><strong>许多3D模型都是在它们自己的局部坐标系统中定义的，需要进行各种转换以使它们与OpenGL坐标系统保持一致。例如，当Stanford Dragon的OBJ文件被加载到OpenGL坐标系统时，它会显示在原点的一侧。使用GLM，我们可以创建模型转换来放置场景中的对象。对于龙模型，这意味着绕X旋转- 90度，然后转换成Y向上，有效的模型转换成为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135335.png" class="" title="image-20211018135335">

<p><strong>龙垂直放置在地平面上方，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135421.png" class="" title="image-20211018135421">

<p>从左到右描述图像。龙的默认本地方向，侧卧。绕X旋转-90度后，龙是直立的，但仍然以起源为中心。最后，在Y应用1.0的平移后，龙已经完成实例化准备了。</p>
<p><strong>为此，我们利用GLM中的几个函数来生成局部模型转换:</strong></p>
<p>​    <strong>•glm::translate创建一个平移矩阵。</strong> </p>
<p>​    <strong>•glm::rotate创建一个旋转矩阵，以特定的角度或弧度指定。</strong> </p>
<p>​    <strong>•glm::scale创建一个缩放矩阵。</strong></p>
<p><strong>我们可以应用这些函数来创建模型转换，并使用统一变量将模型矩阵传递给着色器。Blinn-Phong顶点着色器包含了将局部变换应用到传入顶点的指令。下面的代码展示了如何呈现龙模型:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135824.png" class="" title="image-20211018135824">

<h3 id="Instancing-Models-实例化模型"><a href="#Instancing-Models-实例化模型" class="headerlink" title="Instancing Models 实例化模型"></a>Instancing Models 实例化模型</h3><p><strong>使用OpenGL实例化的实现与使用射线跟踪器实例化的实现是不同的。利用光线追踪器，利用模型变换矩阵将光线反变换到物体的局部空间。在OpenGL中，实例化是通过加载对象的单个副本作为顶点数组对象(与相关的顶点缓冲对象)来执行的，然后根据需要重用几何图形。像射线跟踪器一样，只有一个对象被加载到内存中，但是很多对象都可以被渲染。</strong></p>
<p><strong>现代OpenGL很好地支持这种类型的实例化，因为顶点着色器可以(而且必须)计算必要的转换来将顶点转换为剪辑坐标。通过编写嵌入这些转换的通用着色器，如Blinn-Phong顶点着色器，模型可以用相同的底层局部几何重新着色。不同的材料类型和转换可以从更高级别的类结构中查询，以填充从主机到设备每帧传递的统一变量。动画和交互控制也很容易创建，因为模型转换可以在显示循环迭代中随时间变化。下两图使用了一条龙的内存占用，但在屏幕上呈现了三种不同的龙模型。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018135954.png" class="" title="image-20211018135954">

<p>在三只龙上运行Blinn-Phong着色程序的结果使用统一变量指定材质属性和变换。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211018140006.png" class="" title="image-20211018140006">

<p>在Blinn- Phong着色程序中设置统一变量ks =(0,0,0)产生Lambertian着色。</p>
<h2 id="Texture-Objects-纹理对象"><a href="#Texture-Objects-纹理对象" class="headerlink" title="Texture Objects 纹理对象"></a>Texture Objects 纹理对象</h2><p><strong>纹理是使用OpenGL着色器操作视觉效果的有效方法。它们与许多基于硬件的图形算法一起广泛使用，OpenGL通过纹理对象原生地支持它们。和之前的OpenGL概念一样，纹理对象必须通过将主机上的数据复制到GPU内存中并设置OpenGL状态来分配和初始化。纹理坐标通常集成到顶点缓冲对象中，并作为顶点属性传递给着色程序。片段着色器通常使用从顶点着色器传递的插值纹理坐标来执行纹理查找功能。</strong></p>
<p><strong>如果你已经有了工作着色器和顶点数组对象，纹理是相当简单的添加到你的代码中。用于在硬件上创建对象的标准OpenGL技术与纹理一起使用。然而，纹理数据的来源必须首先确定。数据可以从文件加载(例如，PNG, JPG, EXR，或HDR图像文件格式)或在主机上程序生成(甚至在GPU上)。数据加载到主机内存后，数据被复制到GPU内存中，并且可以选择设置与纹理相关的OpenGL状态。OpenGL纹理数据被加载为内存的线性缓冲区，其中包含用于纹理的数据。硬件上的纹理查询可以是1D、2D或3D查询。无论纹理维度查询是什么，数据都被加载到内存以同样的方式，使用主机上线性分配的内存。在下面的示例中，从图像文件加载数据(或程序生成数据)的过程留给读者，但是提供了与加载图像时可能出现的变量名相匹配的变量名(例如，imgData, imgWidth, imgHeight)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019124105.png" class="" title="image-20211019124105">

<p><strong>这里展示的例子强调了如何使用shader程序设置和使用基本的2D OpenGL纹理。创建OpenGL对象的过程现在应该很熟悉了。必须在设备上生成一个句柄(或ID)来引用纹理对象(例如，在本例中，texID)。然后id被绑定以允许任何后续的纹理状态操作影响纹理的状态。OpenGL存在一组相当广泛的纹理状态和参数，影响纹理坐标解释和纹理查找过滤。图形硬件中存在各种纹理目标。在这种情况下，纹理目标被指定为GL_texture_2D，并将作为纹理相关函数的第一个参数出现。对于OpenGL来说，这个特定的纹理目标意味着纹理坐标将以设备标准化的方式指定(例如:，取值范围[0,1])。此外，必须分配纹理数据，使宽度和高度尺寸为2的幂(例如，512 × 512, 1024 × 512等)。通过调用glTexParameter为当前绑定的纹理设置纹理参数。这个函数的签名根据被设置的数据类型有多种形式。在这种情况下，纹理坐标将被硬件固定到显式范围[0,1]。OpenGL纹理对象的缩小和放大过滤器被设置为在执行纹理查找时自动使用线性过滤(而不是最近邻- GL_nearest)。第11章提供了纹理的大量细节，包括纹理查找时可能发生的过滤的细节。图形硬件可以通过设置相关的纹理状态来自动执行这些操作。</strong></p>
<p><strong>最后，调用glTexImage2D执行纹理的主机设备复制。这个函数有几个参数，但总体操作是在显卡上分配三个浮点数(第7和第8个参数:GL_RGB和GL_FLOAT)的空间(例如imageWidth X imgHeight)，并将线性纹理数据复制到硬件(例如imgData指针)。剩下的参数处理设置mipmap的细节级别(第2个参数)，指定内部格式(例如，第3个参数的GL_RGB)和纹理是否有边界(第6个参数)。当学习OpenGL纹理时，保持这些为这里列出的默认纹理是安全的。然而，建议读者了解更多关于mipmaps和纹理的潜在内部格式，因为需要更高级的图形处理。</strong></p>
<p><strong>纹理对象分配和初始化在上面的代码中进行。必须对顶点缓冲和顶点数组对象进行额外的修改，以链接到正确的纹理坐标与几何描述。在前面的例子中，纹理坐标的存储是对顶点数据结构的直接修改:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019124829.png" class="" title="image-20211019124829">

<p><strong>因此，顶点缓冲对象的大小将增加，而纹理坐标的交错将需要改变顶点数组对象的顶点属性规范中的步数。下图说明了顶点缓冲区内数据的基本交错。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019124917.png" class="" title="image-20211019124917">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019124902.png" class="" title="image-20211019124902">

<p>将纹理坐标添加到顶点缓冲区后的数据布局。每个块代表一个4字节的GLfloat。位置编码为白色块，法线编码为紫色，纹理坐标编码为橙色。</p>
<p><strong>使用上面的代码片段，纹理坐标被放置在顶点属性位置2。注意纹理坐标大小的变化(例如，glVertexAttribPointer的第二个参数是2，用于纹理坐标与结构中的vec2类型一致)。此时，纹理对象的所有初始化都将完成。</strong></p>
<p><strong>纹理对象必须在使用着色器渲染顶点数组对象之前启用(或绑定)。通常，图形硬件在执行着色程序时允许使用多个纹理对象。这样，着色程序可以应用复杂的纹理和视觉效果。因此，为使用着色器绑定一个纹理，它必须关联到一个潜在的纹理单位。纹理单位表示着色器可以使用多个纹理的机制。在下面的示例中，只使用了一个纹理，因此纹理单元0将被激活并绑定到我们的纹理。</strong></p>
<p><strong>激活纹理单位的函数是glActiveTexture。它唯一的参数是要激活的纹理单元。它被设置为GL_TEXTURE0下面，但它可以是GL_TEXTURE1或GL_TEXTURE2，例如，如果在着色器中需要多个纹理。一旦一个纹理单元被激活，就可以使用glBindTexture调用将纹理对象绑定到它。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125104.png" class="" title="image-20211019125104">

<p><strong>上面的大部分代码应该是对您目前所开发的代码的逻辑扩展。注意在呈现顶点数组对象之前调用glUniform。在现代图形硬件编程中，着色器执行纹理查找和混合的工作，因此，必须有关于在着色器中使用的纹理的纹理单元的数据。活动纹理单元使用统一变量提供给着色器。在本例中，0被设置为表示纹理查找将来自纹理单元0。这将在下一节中展开。</strong></p>
<h3 id="Texture-Lookup-in-Shaders-着色器中的纹理查找"><a href="#Texture-Lookup-in-Shaders-着色器中的纹理查找" class="headerlink" title="Texture Lookup in Shaders 着色器中的纹理查找"></a>Texture Lookup in Shaders 着色器中的纹理查找</h3><p><strong>着色程序执行查找和任何可能需要的混合。大部分的计算通常进入碎片着色器，但顶点着色器经常通过传递纹理坐标到碎片着色器阶段碎片计算。通过这种方式，纹理坐标将被插值，并提供纹理数据的每个片段查找。</strong></p>
<p><strong>在shader程序中使用纹理数据需要进行简单的更改。使用之前提供的Blinn-Phong顶点着色器，只需要三个更改:</strong></p>
<p><strong>1.纹理坐标是存储在顶点数组对象中的每个顶点的属性。它们与顶点属性索引2(或位置2)相关联。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125358.png" class="" title="image-20211019125358">

<p><strong>2.碎片着色器将执行纹理查找，将需要插值纹理坐标。这个变量将作为输出变量被添加到片段着色器。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125421.png" class="" title="image-20211019125421">

<p><strong>3.将传入的顶点属性复制到main函数的输出变量中。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125455.png" class="" title="image-20211019125455">

<p><strong>碎片着色器也需要简单的改变。首先，从顶点着色器传入的插值纹理坐标必须声明。还记得统一变量应该存储纹理绑定到的纹理单元吗?这必须作为一个采样器类型传达给着色器。采样器是一种着色语言类型，允许从单个纹理对象中查找数据。在这个例子中，只需要一个采样器，但是在使用多个纹理查找的着色器中，将使用多个采样器变量。根据纹理对象的类型，也有多种采样器类型。在这里展示的例子中，GL_TEXTURE_2D类型用于创建纹理状态。碎片着色器中的相关采样器类型为sampler2D。下面两个变量声明必须添加到片段着色器中:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125540.png" class="" title="image-20211019125540">

<p><strong>最后的修改进入了片段着色器代码的主要功能。纹理使用GLSL纹理查找函数进行采样，(在本例中)，替换几何的漫反射系数。纹理的第一个参数接受采样器类型，该类型保存纹理绑定到的纹理单元。第二个参数是纹理坐标。函数返回vec4类型。在下面的代码片段中，在最终的计算中没有使用alpha值，因此生成的纹理查找值只选择RGB组件。从纹理查找中得到的漫反射系数被设置为vec3类型，用于照明方程。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125651.png" class="" title="image-20211019125651">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019125913.png" class="" title="image-20211019125913">

<p>最左边的图像显示纹理，1024 × 1024像素的图像。中间的图像显示了使用[0,1]范围内的纹理坐标应用纹理的场景，因此只有一个图像被平铺到地平面上。最右边的图像修改纹理参数，使GL_REPEAT用于GL_TEXTURE_WRAP_S和GL_TEXTURE_WRAP_T，纹理坐标范围为[0,5]。结果是一个平铺纹理在两个纹理维度重复5次。</p>
<p><strong>上图显示了使用这些着色器修改的结果。图中最右边的图像通过使用OpenGL状态启用纹理平铺扩展了示例代码。注意，这些改变只在主机代码中完成，着色器不改变。为了启用这种平铺，它允许纹理坐标超出设备规范化范围，GL_TEXTURE_WRAP_S和GL_TEXTURE_WRAP_T的纹理参数从GL_CLAMP更改为GL_REPEAT。此外，设置纹理坐标的宿主代码现在的范围是[0,5]。</strong></p>
<p><strong>作为一个附注，另一个可能对各种应用有用的纹理目标是GL纹理矩形。纹理矩形是唯一的纹理对象，它不受图像宽度和高度要求的二次幂的约束，并使用非标准化的纹理坐标。此外,他们做不允许重复瓷砖。如果使用纹理矩形，着色器必须使用特殊的采样类型:sampler2DRect来引用它们。</strong></p>
<h2 id="Object-Oriented-Design-for-Graphics-Hardware-Programming-图形硬件编程的面向对象设计"><a href="#Object-Oriented-Design-for-Graphics-Hardware-Programming-图形硬件编程的面向对象设计" class="headerlink" title="Object-Oriented Design for Graphics Hardware Programming 图形硬件编程的面向对象设计"></a>Object-Oriented Design for Graphics Hardware Programming 图形硬件编程的面向对象设计</h2><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019130140.png" class="" title="image-20211019130140">

<p>在左边，一个单一的镶嵌球体被实例化了六次，使用不同的模型转换来创建这个场景，使用每个碎片着色程序。右边的图像是使用基本的Whitted射线追踪器渲染的。注意阴影对场景感知的影响。每片段着色允许高光在两种渲染风格中是相似的。</p>
<p><strong>随着你对OpenGL熟悉程度的增加，将本章描述的大部分内容封装到类结构中变得更加明智，这些类结构可以包含特定于模型的数据，并在场景中提供各种对象的渲染。例如，在上图中，一个球体被实例化六次，以创建三个椭球体和三个球体。每个模型使用相同的基础几何结构，但有不同的材料属性和模型转换。如果您已经按照本书的要求实现了射线跟踪器(详见第4章)，那么您的实现很可能是基于可靠的面向对象设计的。这种设计可以使使用OpenGL开发图形硬件程序变得更容易。一个典型的射线跟踪软件架构将包括几个直接映射到图形硬件和软件光栅化应用程序的类。光线追踪器中代表表面、材质、灯光、着色器和相机的抽象基类可以用于初始化图形硬件状态、更新该状态，并在必要时将类数据渲染到framebuffer中。这些虚函数的接口可能需要适应您的特定实现，但扩展表面类设计的第一步可能类似于以下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019130244.png" class="" title="image-20211019130244">

<p><strong>将投影和视图矩阵传递给呈现函数提供了如何管理这些矩阵的间接方法。这些矩阵将来自摄像机类，可以通过解释键盘、鼠标或操纵杆输入操作。初始化函数(至少对于曲面导数)将包含顶点缓冲区对象、顶点数组对象分配和初始化代码。除了为任何顶点数组对象初始化绘制数组外，渲染函数还需要激活着色程序，并将必要的矩阵传递到着色器中，如前面的龙模型示例所示。当您将图像顺序和对象顺序(硬件和软件)算法集成到相同的底层数据框架中时，会出现一些软件设计挑战，主要与数据访问和组织有关。然而，这是一个非常有用的练习，可以让你熟练掌握图形编程的软件工程，并最终获得杂交渲染算法的扎实经验。</strong></p>
<h2 id="Continued-Learning-继续学习"><a href="#Continued-Learning-继续学习" class="headerlink" title="Continued Learning 继续学习"></a>Continued Learning 继续学习</h2><p><strong>本章的目的是对受OpenGL API影响的图形硬件编程提供一个介绍性的一瞥。你继续学习的方向有很多。许多主题，如framebuffer对象、渲染到纹理、环境映射、几何着色器、计算着色器和高级照明着色器都没有涉及。这些领域代表了学习图像硬件的下一个阶段，但即使在所涵盖的领域中，也有许多方向可以让你更好地理解图像硬件。图形硬件编程将继续发展和变化。感兴趣的读者应该期待这些变化，并查看OpenGL和OpenGL着色语言的规范文档，了解更多关于OpenGL能够做什么以及硬件如何与这些计算相关的细节。</strong></p>
<h1 id="18-Light-光照"><a href="#18-Light-光照" class="headerlink" title="18 Light 光照"></a>18 Light 光照</h1><p><strong>在本章中，我们讨论测量光的实际问题，通常称为辐射测量法。放射测量学中出现的术语可能一开始看起来很奇怪，术语和符号可能很难保持一致。然而，由于辐射测量学是计算机图形学的基础，所以在深入研究辐射测量学之前是值得的。本章还涵盖了光度学，它采用辐射量并将其缩放以估计有多少“有用的”光存在。例如，同样强度的绿光可能比蓝光亮两倍，因为眼睛对绿光更敏感。光度学试图量化这种差别。</strong></p>
<h2 id="Radiometry-辐射度量学"><a href="#Radiometry-辐射度量学" class="headerlink" title="Radiometry 辐射度量学"></a>Radiometry 辐射度量学</h2><p><strong>虽然我们可以在许多系统中定义辐射单位，但我们使用SI(国际单位制)单位。我们熟悉的国际单位制单位包括公制单位米(m)和克(g)。光基本上是能量的一种传播形式，所以定义国际单位制能量单位焦耳(J)是很有用的。</strong></p>
<h3 id="Photons-光子"><a href="#Photons-光子" class="headerlink" title="Photons 光子"></a>Photons 光子</h3><p><strong>为了帮助我们的直觉，我们将用大量光子的收集来描述辐射测量，这一节将确定光子在这里的含义上下文。就本章的目的而言，光子是光的量子，它具有位置、传播方向和波长λ。有些奇怪的是，波长的国际单位制单位是纳米(nm)。这主要是由于历史原因，1 nm = 10^−9 m。有时还使用另一个单位埃(angstrom)，一纳米等于十埃。光子的速度c只取决于它所通过的介质的折射率n。有时频率f = c/λ也用于光。这很方便，因为与λ和c不同，当光子折射到具有新的折射率的介质中时，f不会改变。另一个不变测度是光子携带的能量q的量，它由以下关系式给出:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019131250.png" class="" title="image-20211019131250">

<p><strong>其中h = 6.63 × 10^−34 Js为普朗克常数。尽管这些量可以用任何单位制来测量，但只要可能，我们将使用国际单位制。</strong></p>
<h3 id="Spectral-Energy-光谱能量"><a href="#Spectral-Energy-光谱能量" class="headerlink" title="Spectral Energy 光谱能量"></a>Spectral Energy 光谱能量</h3><p><strong>如果我们有大量的光子，它们的总能量Q，可以通过对每一个光子的能量qi求和来计算 。一个合理的问题是“能量是如何在波长上分布的?”回答这个问题的一个简单方法是将光子分成多个盒子，本质上是对它们进行柱状图分析。然后我们有一个与区间相关的能量。例如，我们可以计算λ = 500 nm和λ = 600 nm之间的所有能量，结果是10.2 J，这可能表示为q[500, 600] = 10.2。如果我们把波长区间分成两个50 nm的区间，我们可能会发现q[500, 550] = 5.2和q[550, 600] = 5.0。这告诉我们，在间隔[500,600]的一半的短波长中有一点多的能量。如果我们将容器分成25 nm，我们可能会发现q[500, 525] = 2.5，以此类推。这个系统的优点是它很简单。它的缺点是区间大小的选择决定了数字。</strong></p>
<p><strong>一个更常用的系统是用间隔的大小除以能量。所以q[500, 600] = 10.2，我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019131751.png" class="" title="image-20211019131751">

<p><strong>这种方法很好，因为间隔的大小对数字的总体大小的影响要小得多。一个迫在眉睫的想法是将间隔大小Δλ降为零。这可能会很尴尬，因为对于一个足够小的Δλ， Qλ 是零还是很大取决于是否有单个光子间隔中的光子。有两种思想流派来解决这个困境。第一种是假设Δλ很小，但还没有小到光的量子性质开始发挥作用。第二种是假设光是一个连续体而不是单个光子，因此一个真正的导数dQ/dλ是合适的。这两种思考方式都是恰当的，并导致相同的计算机制。在实践中，大多数测量光的人似乎更喜欢小的，但有限的间隔，因为这是他们在实验室里可以测量的。大多数做理论或计算的人喜欢无穷小的间隔，因为这让微积分的机器变得可用。</strong></p>
<p><strong>数量Qλ 被称为光谱能量，它是一个密集的量，相对于一个广泛的量，如能量、长度或质量。密集量可以被认为是密度函数，它告诉一个扩展量在无限小点的密度。例如，特定波长的能量Q可能为零，但光谱能量(能量密度)Qλ 是一个有意义的量。一个可能更熟悉的例子是，一个国家的人口可能是2500万，但在某个点上，这个国家的人口是无意义的。然而，以每平方米人口为单位的人口密度是有意义的，只要它是在足够大的区域上测量的。就像光子一样，如果我们假设我们可以把人口看作一个连续体，即使面积很小，人口密度也不会变成颗粒状，那么人口密度就会发挥最好的作用。</strong></p>
<p><strong>我们将遵循图形的惯例，光谱能量几乎总是被使用，而能量很少被使用。如果使用“proper”表示法，这将导致λ下标的扩散。相反，我们将去掉下标，使用Q表示光谱能量。当图形以外的人阅读图形论文时，这可能会导致一些混淆，所以请注意这个标准问题。想象一个带有测量光能的传感器的测量设备Δq，可能会帮助你对光谱能量的直觉。如果你在传感器前放置一个彩色滤光片，只允许在区间[λ - Δλ/2， λ + Δλ/2]内的光，那么λ处的光谱能量为Q = Δq/Δλ。</strong></p>
<h3 id="Power-功率"><a href="#Power-功率" class="headerlink" title="Power 功率"></a>Power 功率</h3><p><strong>估计光源的能量产生率是有用的。这个速率叫做功率，它的单位是瓦特，W，这是焦耳每秒的另一个名字。在稳定状态下，这是最容易理解的，但由于功率是一个密集量(随时间变化的密度)，即使当能量生产随时间变化时，它也可以被很好地定义。功率单位可能更熟悉，例如100瓦的灯泡。这种灯泡每秒大约消耗100j的能量。产生的光的功率实际上会小于100瓦，因为热量损失，等等，但我们仍然可以用这个例子来帮助理解更多关于光子的知识。例如，我们可以感受到100瓦的光每秒产生多少光子。假设产生的平均光子的能量为λ = 500 nm。这样一个光子的频率是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019132200.png" class="" title="image-20211019132200">

<p><strong>这个光子的能量是hf≈4 × 10^−19 j，这意味着一个惊人的10^20 即使灯泡的效率不是很高，每秒也会产生光子。这就解释了为什么用快速快门和直接模拟光子来模拟相机是产生图像的低效选择。</strong></p>
<p><strong>与能量一样，我们对以W(nm)^-1测量的光谱功率非常感兴趣。同样，虽然光谱功率的正式标准符号是Φλ，我们将使用Φ不带下标，以方便和与大多数图形文献一致。需要注意的是，光源的光谱功率通常比功率小。例如，如果一束光的功率为100 W，在波长为400 nm到800 nm之间均匀分布，那么光谱功率将为100 W/400 nm = 0.25 W(nm)^-1。这是值得注意的，如果为了调试目的而手动设置光源的光谱功率。</strong></p>
<p><strong>请记住最后一节中光谱能量的测量装置可以通过在以时间t为中心的时间间隔Δt打开的快门进行读数来修改。然后光谱功率将是Φ = Δq/(ΔtΔλ)。</strong></p>
<h3 id="Irradiance-辐照度"><a href="#Irradiance-辐照度" class="headerlink" title="Irradiance 辐照度"></a>Irradiance 辐照度</h3><p><strong>如果你问”有多少光到达这个点? “答案当然是“没有”，同样，我们必须使用密度函数。如果点在一个表面上，很自然地用面积来定义密度函数。我们从上一节修改了设备，使其有一个有限的ΔA面积传感器，小于被测量的光场。光谱辐照度H就是单位面积功率ΔΦ/ΔA。完全展开</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019132703.png" class="" title="image-20211019132703">

<p><strong>因此，辐照度的全单位为Jm^− 2s ^−1(nm) ^−1。注意，辐射的SI单位包括面积的反米平方和波长的反纳米。这种表面上的不一致(同时使用纳米和米)是因为面积和可见光波长的自然单位。</strong></p>
<p><strong>当光离开一个表面时，例如当它被反射时，与辐照度相同的量称为辐射出度E。对于入射光和激发光有不同的词是有用的，因为同一点有可能有不同的辐照度和辐射出度。</strong></p>
<h3 id="Radiance-辐亮度"><a href="#Radiance-辐亮度" class="headerlink" title="Radiance 辐亮度"></a>Radiance 辐亮度</h3><p><strong>虽然辐照度告诉我们有多少光到达一个点，但它几乎不能告诉我们光来自的方向。为了测量类似于我们用眼睛看到的东西，我们需要能够将“有多少光”与特定的方向联系起来。我们可以设想一个简单的装置来测量这样一个量(下图)。我们使用一个小的辐照度计，并添加一个锥形“挡板”，以限制光线击中计数器的角度范围与实心角度Δσ。探测器的响应如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133030.png" class="" title="image-20211019133030">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133041.png" class="" title="image-20211019133041">

<p>通过添加一个只显示一个小立体角Δσ到辐照度探测器，我们测量辐射度。</p>
<p><strong>这是在太空中旅行的光的光谱亮度。同样，我们将在讨论中去掉“光谱”，并假设它是隐式的。</strong></p>
<p><strong>辐射是我们通常在图形程序中计算的东西。辐亮度的一个奇妙特性是它在空间中不会沿直线变化。要知道为什么是这样，检查两个都在观察一个表面的亮度探测器如下图所示。假设探测器所观察的线足够接近，使得表面在两个被测量区域发出/反射的光“相同”。因为被采样表面的面积与距离的平方成正比，并且因为到达探测器的光与距离的平方成反比，两个探测器应该有相同的读数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133206.png" class="" title="image-20211019133206">

<p>辐射探测器接收到的信号与被测表面的距离无关。这个图假设探测器指向表面上以同样方式发光的区域。</p>
<p><strong>测量照射到表面的辐射是有用的。我们可以考虑将探测器上的锥形挡板放置在表面的某一点上，从锥内方向测量表面上的辐照度H(下图)。注意，表面“探测器”没有对准锥体。为此，我们需要在辐亮度的定义中加入余弦校正项:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133253.png" class="" title="image-20211019133253">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133304.png" class="" title="image-20211019133304">

<p>表面的辐照度被掩盖圆锥体比探测器测得的圆锥体要小，用余弦系数表示。</p>
<p><strong>就像辐照度和辐射出度一样，区分入射到表面某一点的辐射度和从该点发出的辐射度是很有用的。这些概念有时在图形文献中使用的术语是表面亮度Ls 为(留下)表面的辐亮度，场辐亮度Lf 为入射到表面的辐射度。两者都需要余弦项，因为它们都对应于上图中的配置:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133325.png" class="" title="image-20211019133325">

<h4 id="Radiance-and-Other-Radiometric-Quantities-辐亮度和其他辐射量"><a href="#Radiance-and-Other-Radiometric-Quantities-辐亮度和其他辐射量" class="headerlink" title="Radiance and Other Radiometric Quantities 辐亮度和其他辐射量"></a>Radiance and Other Radiometric Quantities 辐亮度和其他辐射量</h4><p><strong>如果我们有一个表面，它的场辐射是Lf ，然后我们可以从它推导出所有其他的辐射量。这是辐亮度被认为是“基本”辐射量的原因之一。例如，辐照度可以表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133730.png" class="" title="image-20211019133730">

<p><strong>这个公式有一些在图形中很常见的表示法约定，使得这些公式对不熟悉的读者不透明(下图)。首先，k是一个入射方向，可以认为是一个单位矢量，一个方向，或一个(θ， φ)对相对于表面法线球坐标。这个方向有一个与之相关的微分立体角dσ。每个方向的场辐射都可能不同，所以我们把它写成函数L(k)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133741.png" class="" title="image-20211019133741">

<p>方向k有一个微分立体角dσ与它相关。</p>
<p><strong>例如，我们可以计算具有恒定场辐亮度Lf 的表面的辐照度H在所有的方向。为了积分，我们使用一个经典的球坐标系，回想一下，微分立体角是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133929.png" class="" title="image-20211019133929">

<p><strong>所以辐照度是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019133939.png" class="" title="image-20211019133939">

<p><strong>这个关系向我们展示了一个潜在的令人惊讶的常数π的首次出现。π的这些因素在射线测量中经常出现，并且是我们选择测量立体角的伪因素。单位球的面积是π的倍数，而不是1的倍数。</strong></p>
<p><strong>同样地，我们可以通过对辐照度积分来求出撞击表面的功率穿过表面面积:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019134040.png" class="" title="image-20211019134040">

<p><strong>其中x是曲面上的一个点，dA是这个点的微分面积。请注意，我们没有专门的术语或符号来表示输入功率和输出功率。这种区别似乎并没有引起足够的重视。</strong></p>
<h3 id="BRDF-双向反射"><a href="#BRDF-双向反射" class="headerlink" title="BRDF 双向反射"></a>BRDF 双向反射</h3><p><strong>因为我们对表面的外观感兴趣，我们想要描述一个表面是如何反射光线的。在直观的层面上，对于任何来自ki方向的入射光，在向外方向ko附近，有一些分数以一个小的立体角分散．我们有很多方法可以将这个概念形式化，毫不奇怪，标准的方法是受建立一个简单测量装置的启发。如下图所示，其中一个小光源位于ki 方向从表面上的一点看，在ko方向放置检测器．对于每个方向对(ki,ko)，我们用探测器进行读数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019134646.png" class="" title="image-20211019134646">

<p>一种简单的方向反射率测量装置。光的位置和检测器移动到每个可能的方向对。注意两个ki 和ko 指向远离表面以允许互惠。</p>
<p><strong>现在我们只需要决定如何测量光源的强度并使反射函数独立于这个强度。例如，如果我们用一个更亮的光替换光，我们就不会想要把表面看作是反射光的不同。我们可以在这一点放一个辐射度计照明来测量光。然而，为了得到一个不依赖于探测器Δσ的准确读数，我们需要光对着一个大于Δσ的实心角度。不幸的是，我们在ko 方向上的粗纱亮度检测器所测量的也将计算来自新探测器锥外点的光。所以这看起来不像是一个实际的解决方案。</strong></p>
<p><strong>或者，我们也可以在被测表面的某一点上放置一个辐照度计。这将采取一个读数，不强烈依赖于微妙的光源几何。这表明反射率可以用比率表示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019134341.png" class="" title="image-20211019134341">

<p><strong>这个分数ρ会随着入射和激发方向ki 和ko而变化， H为光位ki的辐照度,Ls 是在ko方向上测量表面辐射．如果我们对所有方向对进行这样的测量，我们最终得到一个四维函数ρ(ki,ko）．这个函数称为双向反射分布函数(BRDF)。我们只需要知道BRDF就可以描述一个表面如何反射光的方向特性。</strong></p>
<h4 id="Directional-Hemispherical-Reflectance-定向半球形反射"><a href="#Directional-Hemispherical-Reflectance-定向半球形反射" class="headerlink" title="Directional Hemispherical Reflectance 定向半球形反射"></a>Directional Hemispherical Reflectance 定向半球形反射</h4><p><strong>对于BRDF，我们很容易问:“入射光的反射光的比例是多少?”然而，答案并非如此简单;反射光的比例取决于入射光的方向分布。由于这个原因，我们通常只设置一个固定入射方向ki反射的分数．这个分数称为定向半球反射率。这个分数,R (ki)定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019134852.png" class="" title="image-20211019134852">

<p><strong>注意，为了能量守恒，这个量在0和1之间。如果我们允许事件力量Φi 点击一个小区域ΔA，那么辐照度是Φi/ΔA。同样，入射功率的比值就是辐射出度与辐照度的比值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135013.png" class="" title="image-20211019135013">

<p><strong>根据BRDF的定义，由该功率产生的特定方向上的辐亮度为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135025.png" class="" title="image-20211019135025">

<p><strong>从辐射的定义，我们也有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135038.png" class="" title="image-20211019135038">

<p><strong>E是ko方向上小块的辐射出度．利用这两种定义，我们得到了辐亮度</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135058.png" class="" title="image-20211019135058">

<p><strong>重新排列项，我们得到</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135109.png" class="" title="image-20211019135109">

<p><strong>这只是对E/H的很小的贡献反映在特定的ko附近．求总的R(ki)，对所有向外的ko求和．积分形式是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135128.png" class="" title="image-20211019135128">

<h4 id="Ideal-Diffuse-BRDF-理想的双向反射"><a href="#Ideal-Diffuse-BRDF-理想的双向反射" class="headerlink" title="Ideal Diffuse BRDF 理想的双向反射"></a>Ideal Diffuse BRDF 理想的双向反射</h4><p><strong>理想的漫反射面称为朗伯曲面。由于热力学原因，这样的表面在自然界是不可能存在的，但从数学上讲，它们确实能保存能量。朗伯BRDF有ρ对于所有角度都是常数。这意味着表面在所有视角下都有相同的辐亮度，辐亮度与辐照度成正比。</strong></p>
<p><strong>如果我们计算R(ki)对于ρ = C的朗伯曲面，我们得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135406.png" class="" title="image-20211019135406">

<p><strong>因此，对于完全反射的朗伯曲面(R = 1)，我们有ρ = 1/π,R(ki) = r，我们有</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019135417.png" class="" title="image-20211019135417">

<p><strong>这是另一个使用立体角确定归一化常数，从而引入π因子的例子。</strong></p>
<h2 id="Transport-Equation-传播方程"><a href="#Transport-Equation-传播方程" class="headerlink" title="Transport Equation  传播方程"></a>Transport Equation  传播方程</h2><p><strong>根据BRDF的定义，我们可以用从各个不同方向入射的辐亮度来描述一个表面的辐亮度。因为在计算机图形学中，我们可以使用理想化的数学，这在实验室中可能是不切实际的，我们也可以只用亮度来写BRDF。如果我们取一小部分实心角度Δσi 与在ko 方向上“测量”反射辐亮度Li，由于这一小块光，我们可以计算BRDF(下图)。小片光的辐照度为H = Li cosθiΔσi．因此BRDF是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141322.png" class="" title="image-20211019141322">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141332.png" class="" title="image-20211019141332">

<p>定向形式的传播方程的几何形式。</p>
<p><strong>这种形式在某些情况下是有用的。重新排列这些项，我们可以写出来自ki方向的光的部分亮度：</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141418.png" class="" title="image-20211019141418">

<p><strong>如果有光从多个方向射来Li(ki)，我们可以把它们加起来。在积分形式中，用表面和场辐射的符号表示，这是</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141438.png" class="" title="image-20211019141438">

<p><strong>这通常被称为计算机图形学中的渲染方程(Immel, Cohen， &amp; Greenberg, 1986)。</strong></p>
<p><strong>有时只用表面辐射来写输运方程是有用的(Kajiya, 1986)。注意，在封闭环境中，场辐亮度Lf (ki)来自具有表面辐射度Ls(−ki) =Lf (ki)的表面(下图)。x′所对的实心角在图中是由</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141622.png" class="" title="image-20211019141622">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019141631.png" class="" title="image-20211019141631">

<p>射入一点的光来自另一个点。</p>
<p><strong>其中ΔA′是与x′有关的面积。在以下替代Δσi，ΔA′表示以下传播方程：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142032.png" class="" title="image-20211019142032">

<p><strong>注意到我们使用的是非标准化向量x−x′来表示x′方向到x，还要注意这里写的是Ls 作为位置和方向的函数。</strong></p>
<p><strong>这个新的传输方程的唯一问题是，积分的领域是棘手的。如果我们引入一个可见性函数，我们可以权衡域的复杂性和被积函数的复杂性:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142119.png" class="" title="image-20211019142119">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142129.png" class="" title="image-20211019142129">

<h2 id="Photometry-光度测定"><a href="#Photometry-光度测定" class="headerlink" title="Photometry 光度测定"></a>Photometry 光度测定</h2><p><strong>对于每一个光谱辐射量，都有一个相关的光度量，测量这个量有多少对人类观察者是“有用的”。给定光谱辐射量fr(λ)，对应的光度量fp 是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142210.png" class="" title="image-20211019142210">

<p><strong>其中y¯是人类视觉系统的发光效率函数。这个函数在上面的积分极限之外是0，所以极限可以是0,∞和fp 不会改变。发光效率函数为在第19章有更详细的讨论，但我们在这里讨论它的一般性质。首要的常数是使定义与历史上的绝对光度量相一致。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142320.png" class="" title="image-20211019142320">

<p>光效率函数随时间变化而变化波长(nm)。</p>
<p><strong>光效率函数对所有波长的灵敏度并不相同(上图)。对于波长低于380 nm(紫外线范围)的光，人类是看不见的，因此y¯的值为零。从380 nm逐渐增加到λ = 555 nm，达到峰值。这是纯绿色的光。然后逐渐减小，直到800nm处到达红外区域边界。</strong></p>
<p><strong>在图形中最常用的光度量是光度，相当于亮度的光度:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211019142428.png" class="" title="image-20211019142428">

<p><strong>表示亮度的符号Y来自比色法。大多数其他字段使用符号L;我们不会遵循这个惯例，因为用L来表示亮度和光谱辐亮度太混乱了。亮度给出了一个关于“明亮”的东西是如何独立于观察者的适应的总体概念。需要注意的是，正午阳光下的黑纸主观上比月光下亮度较低的白纸暗;过多地解读亮度是危险的，但它是一个非常有用的量，可以为相对可感知的光输出提供定量的感觉。lm单位是流明。请注意，大多数灯泡是根据它们消耗的功率(瓦特)和它们产生的有用光(流明)来评级的。更高效的灯泡在y¯大的地方产生更多的光，因此每瓦产生更多的流明。一个“完美”的光可以将所有的能量转换成555纳米的光，产生683 lumens每瓦。亮度单位为(lm/W)(W/(m²sr)) = lm/(m²sr)。每一个立体角的流明被定义为一个candela(cd)，所以亮度通常用cd/m²来描述。</strong></p>
<h1 id="19-Color-颜色"><a href="#19-Color-颜色" class="headerlink" title="19 Color 颜色"></a>19 Color 颜色</h1><p><strong>光子是光信息的载体。它们通过具有波的特性的媒体传播。在表面边界，它们与物质相互作用，表现得更像粒子。它们还可以被视网膜吸收，在那里，它们携带的信息被转换成电信号，随后由大脑处理。只有在那里，才会产生一种色彩的感觉。</strong></p>
<p><strong>因此，色彩研究涉及到几个不同的领域:光在空间中的传播的物理学，与物质相互作用的化学，以及与色彩感知和认知相关的神经科学和心理学(Reinhard et al.， 2008)。</strong></p>
<p><strong>在计算机图形学中，我们通常对光如何在空间中传播采用一种简化的观点。光子沿直线运动，直到碰到表面边界，然后根据某种反射函数反射。单个光子将携带一定的能量，用它的波长表示。因此，一个光子将只有一个波长。给出了它的波长λ和它所携带的能量(ΔE)之间的关系</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020113738.png" class="" title="image-20211020113738">

<p><strong>ΔE的单位是电子伏(eV)。</strong></p>
<p><strong>在计算机图形学中，模拟单个光子的效率不是很高;相反，同时模拟它们的大量集合。如果我们拿大量的光子，每一个都可能携带不同数量的能量，然后它们一起代表一个光谱。光谱可以看作是光子数与波长的关系图。因为同一波长的两个光子携带的能量是同一波长的单个光子的两倍，这张图也可以看作是能量与波长的关系图。下图显示了一个频谱示例。人类能感应到的波长范围大约在380 - 800纳米之间。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020113901.png" class="" title="image-20211020113901">

<p>光谱描述了在每个波长λ可获得的能量，这里用相对辐射功率来测量。这个特定的光谱代表平均日光。</p>
<p><strong>因此，在模拟光线时，就有可能追踪每一种光线都带有光谱。完成这个的渲染器通常被称为光谱渲染器。从前面的章节中，我们应该清楚的是，我们通常不会花费建造光谱渲染器的费用。相反，我们用通常使用红色、绿色和蓝色成分的表示来代替光谱。这可能与人类的视觉有关，我们将在本章后面讨论。</strong></p>
<p><strong>通过追踪光线来模拟光需要考虑光的物理特性，但是需要注意的是，光的一些特性，例如，偏振、衍射和干涉，并不是以这种方式建模的。</strong></p>
<p><strong>在表面边界，我们通常用一个反射函数来模拟光的情况。这些函数可以通过角反射仪直接测量，从而产生大量的表格数据，这些数据可以更紧凑地用各种不同的函数表示。尽管如此，这些反射函数在本质上是经验的，即当一个光子被电子吸收并重新释放时所发生的化学反应就会被吸走。因此，反射函数在计算机图形学建模中是有用的，但不是解释为什么某些波长的光会被吸收而其他波长的光会被反射。因此，我们不能用反射函数来解释为什么香蕉反射的光的光谱组成在我们看来是黄色的。为此，我们必须研究分子轨道理论，这是一个超出本书范围的话题。</strong></p>
<p><strong>最后，当光线到达视网膜时，它被转换成电信号并传播到大脑。大脑的很大一部分用于处理视觉信号，其中一部分产生了对颜色的感觉。因此，即使我们知道香蕉反射的光谱，我们仍然不知道为什么人们会把“黄色”这个词和它联系在一起。此外，正如我们将在本章剩余部分发现的那样，我们对颜色的感知远比乍一看要复杂得多。它随光照而变化，在观察者之间变化，在观察者内部随时间而变化。</strong></p>
<p><strong>换句话说，香蕉发出的光谱是在环境的背景下感知的。要预测观察者如何感知“香蕉光谱”，就需要了解包含香蕉和观察者所处环境的环境知识。在许多情况下，这两种环境是相同的。然而，当我们在监视器上显示香蕉的照片时，这两个环境将是不同的。由于人类的视觉感知依赖于观察者所处的环境，它对照片中的香蕉的感知可能与直接看着香蕉的观察者的感知不同。这对我们如何处理颜色有重大影响，并说明了与颜色相关的复杂性。</strong></p>
<p><strong>强调人类的视觉扮演的重要角色,我们只需要看颜色的定义:“色彩是视觉感知的角度,一个观察者可以区分两个structure-free字段之间的差异的看法相同的大小和形状,如可能是由于有关辐射能的光谱成分的差异观察”(Wyszecki &amp;斯泰尔斯,2000)。本质上，没有人类观察者就没有颜色。</strong></p>
<p><strong>幸运的是，我们对颜色的了解大多是可以量化的，这样我们就可以进行计算来修正人类视觉的特性，从而显示出图像，让观察者看到这些图像的设计者想要的样子。本章包含了这样做所需要的理论和数学。</strong></p>
<h2 id="Colorimetry-比色法"><a href="#Colorimetry-比色法" class="headerlink" title="Colorimetry 比色法"></a>Colorimetry 比色法</h2><p><strong>比色学是一门颜色测量和描述的科学。因为颜色最终是人类的反应，所以颜色测量应该从人类开始观察。人类视网膜中的光探测器由视杆细胞和视锥细胞组成。杆状体高度敏感，在弱光条件下发挥作用。在正常光照条件下，视锥细胞起作用，调节人类的视觉。有三种视锥细胞，它们共同负责色觉。</strong></p>
<p><strong>虽然当某些视觉刺激出现时，直接记录视锥细胞的电输出是可能的，但这样的过程可能是有创的，同时忽略了观察者之间有时存在的本质差异。此外，在这种直接记录技术出现之前，颜色的许多测量方法就已经发展起来了。</strong></p>
<p><strong>另一种方法是通过测量人类对颜色斑块的反应来测量颜色。这导致了颜色匹配实验，稍后将在本节中介绍。进行这些实验已经产生了几个标准化的观察者，这可以被认为是实际人类观察者的统计近似值。然而，首先，我们需要描述一些基于颜色匹配可能性的假设，这些假设是由格拉斯曼定律总结的。</strong></p>
<h3 id="Grassmann’s-Laws-格拉斯曼定律"><a href="#Grassmann’s-Laws-格拉斯曼定律" class="headerlink" title="Grassmann’s Laws 格拉斯曼定律"></a>Grassmann’s Laws 格拉斯曼定律</h3><p><strong>鉴于人类有三种不同的视锥类型，颜色匹配的实验法则可以总结为三色概括(Wyszecki &amp; Stiles, 2000)，即任何颜色刺激都可以通过三种适当调制的颜色源的加性混合完全匹配。这种颜色特征在实践中经常被使用，例如电视和显示器通过给每个像素添加红、绿、蓝的混合光来复制许多不同的颜色。这也是渲染器可以只用三个值来描述每种颜色的原因。</strong></p>
<p><strong>三原色泛化使我们能够在任何给定的刺激和三种其他刺激的相加混合之间进行颜色匹配。Hermann Grassmann是第一个描述颜色匹配遵循的代数规则的人。它们被称为加色配色格拉斯曼定律(Grassmann, 1853)，其内容如下:</strong></p>
<p><strong>•对称。如果颜色刺激A匹配颜色刺激B，那么B匹配A。</strong> </p>
<p><strong>•传递法。如果A匹配B, B匹配C，那么A匹配C。</strong></p>
<p><strong>•比例法。如果A匹配B，那么αA匹配αB，其中α是一个正的比例因子。</strong></p>
<p><strong>•可加性。如果A匹配B，C匹配D，A + C匹配B + D，那么，A + D匹配B + C。</strong> </p>
<p><strong>加性法则是配色和比色法的基础。</strong></p>
<h3 id="Cone-Responses-锥反应"><a href="#Cone-Responses-锥反应" class="headerlink" title="Cone Responses 锥反应"></a>Cone Responses 锥反应</h3><p><strong>每种锥型对波长范围都很敏感，涵盖了整个可见范围的大部分。然而，对波长的灵敏度不是均匀分布的，而是包含一个灵敏度最大的峰值波长。每个锥型的峰值波长的位置是不同的。这三种锥型分别为S、M和L锥，字母分别代表短、中、长，表明在可见光谱中峰值灵敏度的位置。</strong></p>
<p><strong>一个给定的圆锥的响应是它输出的电信号的大小，作为入射到圆锥上的波长的频谱的函数。每个锥型的锥响应函数是波长λ的函数，然后由L(λ)， M(λ)和S(λ)给出。它们绘制在下图中。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020130721.png" class="" title="image-20211020130721">

<p>L, M和S锥的锥响应函数。</p>
<p><strong>对给定光谱组成Φ(λ)的刺激的实际响应然后给出每个锥型的</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020130736.png" class="" title="image-20211020130736">

<p><strong>这三种综合反应被称为三刺激值。</strong></p>
<h3 id="Color-Matching-Experiments-配色实验"><a href="#Color-Matching-Experiments-配色实验" class="headerlink" title="Color Matching Experiments 配色实验"></a>Color Matching Experiments 配色实验</h3><p><strong>鉴于三刺激值是通过在可见范围内集成两个函数的乘积而产生的，很明显，人类的视觉系统并不是一个简单的波长探测器。相反，我们的光感受器起着近似线性积分器的作用。因此，有可能找到两种不同的光谱成分，比如Φ₁(λ)和Φ₂(λ)，经过整合后产生相同的响应(L, M, S)。这种现象被称为同分异构体，其例子如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020130947.png" class="" title="image-20211020130947">

<p>两个刺激Φ₁(λ)和Φ₂(λ)积分后得到相同的三刺激值。</p>
<p><strong>异色是人类视觉的关键特征，它允许构建彩色复制设备，包括这本书中的彩色图形和任何在打印机、电视和显示器上复制的东西。</strong></p>
<p><strong>配色实验也依赖于异谱原理。假设我们有三种不同颜色的光源，每个光源都有一个刻度盘来改变其亮度。我们称这三种光源为原色。我们现在应该能够调整每一种光源的强度，这样当它们相加时，得到的光谱就会整合成一个三刺激值，与第四个未知光源的感知颜色相匹配。当我们进行这样的实验时，我们基本上已经将我们的原色与一种未知的颜色进行了匹配。我们三个刻度盘的位置就代表了第四个光源的颜色。</strong></p>
<p><strong>在这样的实验中，我们使用格拉斯曼定律将我们的原色的三个光谱相加。我们还使用了异谱法，因为我们的三个初级的组合光谱几乎肯定是不同的第四个光源。然而，从这两个光谱计算的三刺激值将是相同的，产生了一种颜色匹配。</strong></p>
<p><strong>请注意，我们实际上并不需要知道锥响应函数来进行这样的实验。只要我们在相同的条件下使用相同的观察者，我们就能够匹配颜色，并记录每种颜色的刻度盘的位置。但是，每次测量颜色的时候都要做这样的实验是很不方便的。因此，我们确实想知道光谱锥响应函数，并对一组不同的观测者进行平均，以消除观测者间的变异性。</strong></p>
<h3 id="Standard-Observers-标准观察者"><a href="#Standard-Observers-标准观察者" class="headerlink" title="Standard Observers 标准观察者"></a>Standard Observers 标准观察者</h3><p><strong>如果我们对大范围的颜色进行颜色匹配实验，由一组不同的观察者进行，就有可能生成一个平均的颜色匹配数据集。如果我们专门使用单色光源来匹配我们的原色，我们可以对所有可见波长重复这个实验。得到的三刺激值称为光谱三刺激值，可以根据波长λ绘制，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020131246.png" class="" title="image-20211020131246">

<p>频谱三刺激值在许多观察者中取平均值。波长为435.8、546.1和700 nm的单色光源的原色。</p>
<p><strong>通过使用一组明确的主光源，光谱三刺激值导致三个颜色匹配函数。国际电子委员会(CIE)定义了三种这样的原色光源，分别为435.8、546.1和700 nm。用这三张单色所有其他可见波长的自动光源都可以通过添加不同数量的光来匹配。每个所需的数量匹配给定波长λ编码在颜色匹配函数，由r¯(λ)， g¯(λ)，和¯b(λ)给出，并绘制在上图。与这些颜色匹配函数相关的三刺激值被称为R、G和B。</strong></p>
<p><strong>假设我们正在添加光，而光不可能是负的，您可能已经注意到上图中的一个异常:为了创建一些波长的匹配，有必要减去光。虽然没有所谓的负光，但我们可以再次使用格拉斯曼定律，我们可以在匹配的颜色中添加相同数量的光，而不是从混合的原色中减去光。</strong></p>
<p><strong>CIE r¯(λ)， g¯(λ)，和¯b(λ)颜色匹配函数允许我们确定一个光谱分布Φ₁ 匹配第二个光谱分布Φ₂ 简单比较通过整合这些颜色匹配函数得到的三刺激值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020131505.png" class="" title="image-20211020131505">

<p><strong>当然，只有当三个三刺激值都匹配时，颜色匹配才有保证。</strong></p>
<p><strong>这些颜色匹配函数的重要性在于，我们现在能够通过三刺激值来简洁地交流和描述颜色。对于给定的光谱函数，CIE颜色匹配函数提供了一种精确的方法来计算三刺激值。只要每个人都使用相同的颜色匹配函数，就应该总是能够生成匹配。</strong></p>
<p><strong>如果不能使用相同的颜色匹配函数，则可以将一组三刺激值转换为一组适合于相应原色集的不同三刺激值。CIE定义了一种这样的转变，原因有两个。首先，在20世纪30年代，数值积分很难执行，对于既可以是正数也可以是负数的函数来说更是如此。第二，CIE已经建立了光致发光响应函数CIE V (λ)。我们希望有三个积分函数，其中V (λ)为1并且在可见范围内三个都是正的。</strong></p>
<p><strong>为了创建一组正的颜色匹配函数，有必要定义虚三原色。换句话说，为了在可见光谱中再现任何颜色，我们需要的光源不能被物理实现。颜色匹配函数被CIE确定为x¯(λ)， y¯(λ)，和z¯(λ)，如下图所示。注意，y¯(λ)等于光的亮度响应函数V (λ)，并且每个函数确实都是正的。他们被称为CIE 1931年标准观察员。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020131718.png" class="" title="image-20211020131718">

<p>CIE x¯(λ)， y¯(λ)， z¯(λ)颜色匹配函数。</p>
<p><strong>相应的三刺激值被称为X, Y，和Z，以避免与R, G，和B三刺激值混淆，这些值通常与可实现的原色相关联。从(R, G, B)三刺激值到(X, Y, Z)三刺激值的转换由一个简单的3×3变换定义:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020131813.png" class="" title="image-20211020131813">

<p><strong>为了计算三刺激值，我们通常直接将标准观察者的颜色匹配函数与感兴趣的光谱Φ(λ)积分，而不是先通过CIE r¯(λ)， g¯(λ)，和¯b(λ)颜色匹配函数，然后再进行上述变换。它允许我们计算一致的颜色尺寸，并确定两种颜色何时匹配。</strong></p>
<h3 id="Chromaticity-Coordinates-色度坐标"><a href="#Chromaticity-Coordinates-色度坐标" class="headerlink" title="Chromaticity Coordinates 色度坐标"></a>Chromaticity Coordinates 色度坐标</h3><p><strong>每一种颜色都可以用一组三刺激值(X, Y, Z)来表示。我们可以用X, Y, Z轴定义一个正交坐标系，并在生成的三维空间中绘制每一种颜色。这就是所谓的颜色空间。颜色所处的空间范围就称为色域。</strong></p>
<p><strong>在3D颜色空间中可视化颜色是相当困难的。而且，任何颜色的Y值对应于它的亮度，这是由于y¯(λ) = V (λ)这一事实。因此，我们可以将三刺激值投影到一个近似彩色信息的二维空间，即与亮度无关的信息。这种投影称为色度图，通过归一化同时去除亮度信息得到:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132121.png" class="" title="image-20211020132121">

<p><strong>给定x + y + z = 1, z值是多余的，允许我们在色度图中绘制x和y的色度。虽然x和y本身不足以完全描述一种颜色，但我们可以使用这两个色度坐标和三个三刺激值中的一个，传统上是Y，来恢复其他两个三刺激值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132207.png" class="" title="image-20211020132207">

<p><strong>通过在色度图中绘制所有的单色(光谱)颜色，我们得到了一个马蹄形曲线。这条曲线上的点称为谱轨迹。所有其他颜色将生成位于曲线内的点。1931标准观测仪的谱轨迹如下图所示。紫色的线和马蹄形两端之间不代表一种单色，而是长短波长刺激的组合。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132307.png" class="" title="image-20211020132307">

<p>CIE 1931标准观测仪的光谱轨迹。</p>
<p><strong>一个(非单色)原色可以在所有可见波长上集成，得到(X, Y, Z)三刺激值，随后得到(x,y)色度坐标，即色度图上的一个点。对两个或更多原色重复这个过程，就会在色度图上产生一组可以用直线连接的点。以这种方式跨越的体积代表了可以通过添加这些原色的混合复制的颜色范围。三主系统的例子如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132407.png" class="" title="image-20211020132407">

<p>色度边界的CIE RGB三原色在435.8,546.1和700 nm(固体)和典型的HDTV(虚线)。</p>
<p><strong>色度图提供了对加色混合物的洞察。然而，它们应该小心使用。首先，马蹄铁内部不应该着色，因为任何颜色复制系统都有自己的原色，只能复制色度图的某些部分。第二，由于CIE的颜色匹配函数不能代表人类的视锥敏感度，色度图上任何两点之间的距离并不能很好地指示这些颜色将被感知到的不同程度。</strong></p>
<p><strong>一个更均匀的色度图至少部分地解决了第二个问题。CIE u′v′色度图提供了一个感知上更均匀的间隔，因此通常优于(x, y)色度图。它由(X, Y, Z)三刺激值通过应用不同的归一化，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132524.png" class="" title="image-20211020132524">

<p><strong>也可以直接从(x, y)色度坐标计算:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132554.png" class="" title="image-20211020132554">

<p><strong>CIE u′v′色度图如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020132640.png" class="" title="image-20211020132640">

<h2 id="Color-Spaces-颜色空间"><a href="#Color-Spaces-颜色空间" class="headerlink" title="Color Spaces 颜色空间"></a>Color Spaces 颜色空间</h2><p><strong>如上所述，每种颜色都可以用三个数字来表示，例如用(X, Y, Z)三刺激值来定义。然而，它的原色是假想的，这意味着不可能制造出一个设备，它有三个光源(都是正极)，可以重现可见光谱中的所有颜色。</strong></p>
<p><strong>出于同样的原因，在图像上进行图像编码和计算可能并不实用。例如，有大量可能的XY Z值并不对应于任何物理颜色。这将导致存储可用位的低效使用，并对位深度提出更高的要求，以在图像处理后保持视觉完整性。虽然有可能构建一个具有接近CIE XY Z颜色匹配功能的原色的捕获设备，但硬件和图像处理的成本使它成为一个没有吸引力的选择。不可能建立一个对应CIE XY Z的显示。出于这些原因，有必要设计其他颜色空间:物理可实现性、有效编码、感知一致性和直观的颜色规范。</strong></p>
<p><strong>CIE XY Z颜色空间仍然被积极使用，主要用于其他颜色空间之间的转换。它可以被看作是一个与设备无关的颜色空间。</strong></p>
<p><strong>其他颜色空间可以根据它们与CIE XY Z的关系来定义，这通常是由一个特定的变换来指定的。例如，线性和加性三色显示设备可以通过一个简单的3 × 3矩阵转换成CIE XY Z。还可以指定一些非线性附加变换，例如，当数据以有限位深存储时，将感知误差降到最低，或直接在输入信号和发射光量之间存在非线性关系的设备上显示。</strong></p>
<h3 id="Constructing-a-Matrix-Transform-构造矩阵变换"><a href="#Constructing-a-Matrix-Transform-构造矩阵变换" class="headerlink" title="Constructing a Matrix Transform 构造矩阵变换"></a>Constructing a Matrix Transform 构造矩阵变换</h3><p><strong>显示设备有三个初选,说红色,绿色和蓝色,我们可以测量发射光的光谱成分通过发送颜色向量(1,0,0)(0,1,0)和(0 0 1)。这些向量代表三种情况即初选充满之一,和其他两个。从测量光谱输出,我们可以计算出相应的色度坐标(xR, yR), (xG, yG), 和 (xB, yB)。</strong></p>
<p><strong>显示器的白点定义为当颜色向量(1,1,1)被发送到显示器时所发出的光谱。其对应的色度坐标为(xW,yW )．三原色和白点描述了显示器的特征，每一个都需要在显示器的颜色空间和CIE XY Z之间构建一个变换矩阵。</strong></p>
<p><strong>这四个色度坐标可以扩展为从z = 1−x−y重建z坐标的色度三联体，得到三联体(xR,yR, zR), (xG,yG,zG), (xB,yB,zB ), (xW,yW,zW )．如果已知白点的最大亮度，就可以计算出其对应的三刺激值(XW,YW , ZW )，然后解出亮度的下列方程组</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133347.png" class="" title="image-20211020133347">

<p><strong>RGB和XYZ之间的转换是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133433.png" class="" title="image-20211020133433">

<p><strong>任何给定颜色的亮度可以通过计算矩阵的中间行来计算:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133523.png" class="" title="image-20211020133523">

<p><strong>要在给定设备的XYZ和RGB之间转换，上面的矩阵可以简单地倒转。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133619.png" class="" title="image-20211020133619">

<p>ITU-R BT.709规定的原色和白点的(x, y)色度坐标。sRGB标准也使用这些原色和白点。</p>
<p><strong>如果图像是在原色和白点未知的RGB颜色空间中表示的，那么接下来最好假设图像是在标准RGB颜色空间中编码的。一个合理的选择是假设图像是根据ITU-R BT.709指定的，这是用于HDTV编码和广播的规范。其原色和白点在上表中指定。请注意，使用相同的原色和白点来定义众所周知的sRGB颜色空间。这个RGB颜色空间和CIE XYZ之间的变换为，反之亦然</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133730.png" class="" title="image-20211020133730">

<p><strong>通过替换设备的最大RGB值，我们可以计算出白点。对于ITU-R BT.709，最大值为(RW,GW,BW =(100, 100, 100)，导致白点为(XW,YW,ZW ) =(95.05, 100.00, 108.90)。</strong></p>
<p><strong>除了线性变换外，sRGB颜色空间还具有随后的非线性变换。给出了非线性编码</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133829.png" class="" title="image-20211020133829">

<p><strong>这种非线性编码有助于减少数字应用中由于量化误差而产生的感知误差。</strong></p>
<h3 id="Device-Dependent-RGB-Spaces-设备依赖的RGB空间"><a href="#Device-Dependent-RGB-Spaces-设备依赖的RGB空间" class="headerlink" title="Device-Dependent RGB Spaces 设备依赖的RGB空间"></a>Device-Dependent RGB Spaces 设备依赖的RGB空间</h3><p><strong>由于每个设备通常都有自己的原色和白点集合，所以我们称相关的RGB颜色空间为设备相关的。需要注意的是，即使所有这些设备都在RGB空间中运行，它们的原色和白点也可能非常不同。因此，如果我们在某些RGB空间中指定了一幅图像，它对我们来说可能会非常不同，这取决于我们显示它的设备。</strong></p>
<p><strong>这显然是一种不受欢迎的情况，因为缺乏色彩管理。然而，如果图像是在已知的RGB颜色空间中指定的，那么它可以首先被转换为XYZ，这是独立于设备的，然后它可以被转换为设备的RGB空间，它将在该设备上显示。</strong></p>
<p><strong>还有其他几个明确定义的RGB颜色空间。它们都由一个线性矩阵变换和一个非线性变换组成，类似于前面提到的sRGB颜色空间。非线性变换可参数化如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020133946.png" class="" title="image-20211020133946">

<p><strong>参数s, f, t和γ，连同原色和白点，指定了在各个行业中使用的一类RGB颜色空间。下表中列出了几种常见的转换。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020134037.png" class="" title="image-20211020134037">

<p>标准RGB颜色空间的转换(在(Pascale, 2003)之后)。</p>
<h3 id="LMS-Cone-Space-LMS锥体空间"><a href="#LMS-Cone-Space-LMS锥体空间" class="headerlink" title="LMS Cone Space LMS锥体空间"></a>LMS Cone Space LMS锥体空间</h3><p><strong>上述锥信号可以用CIE XYZ颜色空间表示。给出了计算从XYZ到的LMS信号的矩阵变换</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020134323.png" class="" title="image-20211020134323">

<p><strong>这种变换被称为Hunt-Pointer-Estevez变换(Hunt, 2004)，用于彩色自适应变换以及颜色外观建模。</strong></p>
<h3 id="CIE-1976-L-a-b"><a href="#CIE-1976-L-a-b" class="headerlink" title="CIE 1976 L* a* b*"></a>CIE 1976 L* a* b*</h3><p><strong>颜色对抗空间的特征是一个表示消色差通道(亮度)的通道，以及两个编码颜色对抗的通道。这些通常是红绿色和黄蓝色通道。这些颜色对抗，因此，内尔编码沿着一个轴的两个色度，可以有正负值。例如，红绿通道将正值编码为红色，负值编码为绿色。值0编码了一个特殊情况:中和色（neutral），既不是红色也不是绿色。黄蓝通道的工作原理大致相同。</strong></p>
<p><strong>由于在两个色轴上至少编码了两种颜色，因此不可能编码红色和绿色的混合物。同时编码黄色和蓝色也是不可能的。虽然这似乎是一个缺点，但众所周知，人类视觉系统在视觉通路的早期就计算出了类似的属性。因此，人类无法同时感知红色和绿色，黄色和蓝色。我们没有看到任何类似红绿或黄蓝的东西。然而，我们能够感知黄-红(橙)或绿-蓝等颜色的混合，因为这些是通过彩色通道编码的。</strong></p>
<p><em><em>对计算机图形来说，最相关的反色系统是CIE 1976 L</em> a</em> b<em>颜色模型。它是一个感知上或多或少统一的颜色空间，在计算色差时非常有用。它也被称为CIELAB。</em>*</p>
<p><strong>CIELAB的输入是刺激(X, Y, Z)三刺激值，以及由已知光源照亮的漫反射白色表面的三刺激值(Xn,Yn, Zn)．因此，CIELAB不仅仅是一个普通的颜色空间，因为它考虑了已知光照下的一小块颜色。因此，它可以被看作是一个基本的颜色外观空间。</strong></p>
<p><em><em>CIELAB中定义的三个通道分别是L</em> 、a</em> 和 b<em>。L <em>为通道编码颜色的亮度，即具有三刺激值(X, Y, Z)的贴片的感知反射系数。a * 和 b</em>为颜色对抗通道。XYZ与CIELAB之间的变换为</em>*</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020135253.png" class="" title="image-20211020135253">

<p><strong>函数f定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020135317.png" class="" title="image-20211020135317">

<p>*<em>从这个公式可以看出，色度通道确实取决于亮度Y。尽管这在感知上是准确的，但这意味着我们不能在色度图中绘制一个a * 和 b</em>的值。亮度L <em>标准化在0到100之间是黑白的。尽管a * 和 b</em>通道没有明确限制，但它们通常在[−128,128]范围内。**</p>
<p><strong>由于CIELAB近似感知线性，因此可以将两种颜色转换为CIELAB，然后通过计算它们之间的欧氏距离来估计感知到的颜色差异。这就得到了以下色差公式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020135501.png" class="" title="image-20211020135501">

<p><strong>字母E代表感觉上的不同(德语，Empfindung)(贾德，1932)。</strong></p>
<p><strong>最后，给出了CIELAB与XYZ之间的逆变换</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020135514.png" class="" title="image-20211020135514">

<h2 id="Chromatic-Adaptation-色彩适应"><a href="#Chromatic-Adaptation-色彩适应" class="headerlink" title="Chromatic Adaptation 色彩适应"></a>Chromatic Adaptation 色彩适应</h2><p><strong>刚才描述的CIELAB颜色空间以刺激的三刺激值和白色漫反射片反射的光的三刺激值作为输入。因此，它形成了一个系统的开端，在其中查看环境被考虑在内。</strong></p>
<p><strong>我们观察物体和图像的环境对我们如何感知这些物体有很大的影响。我们在日常生活中遇到的观看环境的范围是非常大的，从阳光到星光，从烛光到荧光灯。照明条件不仅构成了一个非常大的范围内的光的数量，而且还在发射光的颜色上有很大的变化。</strong></p>
<p><strong>人类的视觉系统通过一个叫做适应的过程来适应环境中的这些变化。可以区分三种不同类型的适应，即光适应、暗适应和色适应。光适应是指当我们从一个非常黑暗的环境移动到一个非常明亮的环境时所发生的变化。当这种情况发生时，起初我们会被光线弄得眼花缭乱，但很快我们就适应了新的环境，并开始区分我们环境中的物体。暗适应指的是相反的情况，即我们从光明的环境进入黑暗的环境。一开始，我们看到的很少，但在给定的时间后，细节将开始出现。适应黑暗所需的时间通常比适应光明所需的时间要长得多。</strong></p>
<p><strong>色彩适应是指我们对光照颜色变化的适应能力。从本质上讲，彩色适应是大多数现代相机上的白平衡操作的生物等效。人类视觉系统有效地使观看条件正常化，以呈现相当一致的视觉体验。因此，我们表现出一定的颜色稳定性:物体的反射率相对稳定，尽管在照明变化。</strong></p>
<p><strong>虽然我们能够在很大程度上忽略观看环境的变化，但我们不能完全这样做。例如，颜色在晴天比在阴天显得更加丰富多彩。虽然表面发生了变化，但我们并不认为物体反射本身实际上改变了它们的物理性质。因此，我们了解到照明条件影响了整体颜色的外观。</strong></p>
<p><strong>尽管如此，色彩恒常性确实适用于彩色内容。色彩适应性允许白色物体在大量光照条件下呈现白色，如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141102.png" class="" title="image-20211020141102">

<p>在CIE u′v′色度图。一张白纸在这些光源的照射下会保持白色的外观。</p>
<p><strong>颜色适应的计算模型倾向于关注锥细胞的增益控制机制。最简单的模型之一是假设每个锥体都能独立地适应它所吸收的能量。这意味着不同类型的锥适应不同的光谱吸收的光。这种适应性可以被建模为锥体信号的自适应和独立缩放:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141202.png" class="" title="image-20211020141202">

<p><strong>其中(La, Ma, Sa)为彩色自适应圆锥信号，α、β和γ是由观察环境决定的独立增益控制。这种独立的适应也被称为von-Kries适应。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141411.png" class="" title="image-20211020141411">

<p>冯·克里斯式独立光感受器增益控制的一个例子。显示了CIE光源A的相对锥响应(实线)和相对适应锥响应(虚线)。单独的色块表示CIE光源A呈现在sRGB颜色空间中。</p>
<p><strong>自适应光照可以测量出场景中的白色表面。在理想情况下，这是朗伯曲面。在数字图像中，自适应光照也可以近似为场景的最大三刺激值。用这种方法测量或计算的光是自适应白，由(Lw,Mw,Sw)．Von Kries的适应就是简单的基于互惠的缩放适应性的白色，在锥体响应空间中进行:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141511.png" class="" title="image-20211020141511">

<p><strong>在许多情况下，我们感兴趣的是在一个光照下应该产生什么刺激来匹配不同光照下的给定颜色。例如，如果我们有一个被日光照亮的色块，我们可能会问自己应该生成什么样的三刺激值来创建一个由白炽灯照亮的匹配色块。</strong></p>
<p><strong>因此，我们感兴趣的是计算相应的颜色，这可以通过层叠两色自适应计算来实现。从本质上讲，前面提到的von Kries变换划分出了适应光源——在我们的例子中，日光照明。如果我们随后在白炽光源上乘上，我们就算出了相应的颜色。如果两种光源为(Lw,1,Mw,1,Sw,1)和(Lw,2,Mw,2,Sw,2)，对应的颜色(Lc,Mc,Sc)是由</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211020141627.png" class="" title="image-20211020141627">

<p><strong>还有一些更复杂，因此更精确的颜色适应变换(Reinhard et al.， 2008)。然而，简单的von Kries模型在建模彩色适应方面仍然非常有效，因此可以用于实现数字图像中的白色平衡。</strong></p>
<p><strong>在渲染的背景下，色彩适应的重要性在于，我们已经向考虑观察者的观看环境迈出了一步，而不必通过调整场景和重新渲染我们的图像来纠正它。相反，我们可以建模和渲染我们的场景，然后，作为一个图像后处理，纠正视觉环境的照明。然而，为了确保白平衡不会引入伪影，确保将图像呈现为浮点格式是很重要的。如果渲染到传统的8位图像格式，彩色自适应变换可能放大量化误差。</strong></p>
<h2 id="Color-Appearance-颜色外观"><a href="#Color-Appearance-颜色外观" class="headerlink" title="Color Appearance 颜色外观"></a>Color Appearance 颜色外观</h2><p><strong>虽然比色法允许我们以一种独立于设备的方式准确地指定和传达颜色，而色彩适应允许我们在照明变化中预测颜色匹配，但这些工具仍然不足以描述颜色实际看起来是什么样的。</strong></p>
<p><strong>为了预测对一个物体的实际感知，我们需要了解更多关于环境的信息，并将这些信息纳入考虑。人类的视觉系统在不断地适应环境，这意味着对颜色的感知会受到这种变化的强烈影响。颜色外观模型考虑刺激本身的测量，以及观看环境。这意味着产生的颜色描述是独立于观看条件的。</strong></p>
<p><strong>颜色外观建模的重要性可以在下面的例子中看到。假设一个图像显示在LCD屏幕上。当打印相同的图像，并在不同的背景下观看它时，通常图像看起来会明显不同。颜色外观模型可以用来预测生成准确的跨媒体颜色再现所需的变化(Fairchild, 2005)。</strong></p>
<p><strong>虽然色彩外观建模为色彩再现提供了重要的工具，但实际的实现往往相对复杂和繁琐。可以预见，这种情况可能会随着时间的推移而改变。然而，在那之前，我们把他们的描述留给更专业的教科书(Fairchild, 2005)。</strong></p>
<h1 id="20-Visual-Perception-视觉感知"><a href="#20-Visual-Perception-视觉感知" class="headerlink" title="20 Visual Perception 视觉感知"></a>20 Visual Perception 视觉感知</h1><p><strong>计算机图形学的最终目的是生成供人们观看的图像。因此，计算机图形系统的成功取决于它如何将相关信息传递给人类观察者。物理世界的内在复杂性和显示设备的局限性使它不可能向观众呈现与观察自然环境时相同的光模式。当计算机图形系统的目标是物理真实感时，我们所能期望的最好结果就是系统在感知上是有效的:显示的图像应该“看起来”如预期的那样。对于技术演示等应用程序，通常希望以视觉方式突出相关信息，而感知效果则成为明确的需求。</strong></p>
<p><strong>艺术家和插图画家已经根据经验开发了广泛的工具和技术来有效地传达视觉信息。提高计算机图形学感知有效性的方法之一是在我们的自动化系统中利用这些方法。第二种方法直接建立在人类视觉系统的知识基础上，将感知有效性作为计算机图形系统设计的优化标准。这两种方法并非完全不同。事实上，在列奥纳多·达·芬奇的笔记本中发现了视觉感知的第一个系统检验。</strong></p>
<p><strong>本章的其余部分提供了一个关于人类视觉感知的部分概述。重点是与计算机图形学最相关的人类视觉方面。人类的视觉系统在运作和结构上都是极其复杂的。像这样的一章最多只能提供一个关键点的总结，重要的是要避免从这里介绍的内容过度概括。Wandell(1995)和Palmer(1999)对视觉知觉进行了更深入的研究;Gregory(1997)和Yantis(2000)提供了更多有用的信息。一个好的计算机视觉参考，如Forsyth和Ponce(2002)也很有帮助。值得注意的是，尽管有超过150年的深入研究，我们对视力的许多方面的知识仍然非常有限和不完善。</strong></p>
<h2 id="Vision-Science-视觉科学"><a href="#Vision-Science-视觉科学" class="headerlink" title="Vision Science 视觉科学"></a>Vision Science 视觉科学</h2><p><strong>人们普遍认为视觉是人类最强大的感官。视觉比听觉、触觉、嗅觉或味觉更能提供关于世界的有用信息。这是光物理学的直接结果(下图)。照明是普遍的，特别是在白天，但在夜晚由于月光，星光和人工来源。表面反射了大量的入射照明，并且以特定材料特有的方式反射，这取决于表面的形状。光(大部分)在空气中以直线传播，这一事实使得视觉能够从遥远的地方获取信息。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021142347.png" class="" title="image-20211021142347">

<p>光的本质使视觉具有强大的意义。</p>
<p><strong>视觉研究有着悠久而丰富的历史。我们对眼睛的了解大多可以追溯到17世纪哲学家和物理学家的工作。从19世纪中期开始，知觉心理学家对视觉现象学进行了大量的研究，并提出了视觉如何工作的模型。20世纪中期是现代神经科学的开端，它既研究单个神经元的精细尺度的工作，也研究大脑和神经系统的大规模结构组织。神经科学研究的很大一部分集中在视觉上。最近，计算机科学通过提供精确描述视觉计算的假设模型的工具和允许计算机视觉程序的经验检验，对理解视觉感知做出了贡献。术语视觉科学是指视觉知觉的多学科研究，包括知觉心理学、神经科学和计算分析。</strong></p>
<p><strong>视觉科学认为视觉的目的是通过到达观察者的光的成像模式来产生关于世界上物体、位置和事件的信息。心理学家用远端刺激来指代观察下的物理世界，用近端刺激来指代视网膜图像。我们,在这个术语中，视觉的功能是产生对近端刺激的远端刺激的各个方面的描述。当产生的描述准确地反映了现实世界时，视觉感知就被称为是真实的。在实践中，孤立地考虑这些对象、位置和事件的描述是没有意义的。相反，视觉在它所服务的运动和认知功能的背景下可以更好地理解。</strong></p>
<h2 id="Visual-Sensitivity-视觉灵敏度"><a href="#Visual-Sensitivity-视觉灵敏度" class="headerlink" title="Visual Sensitivity 视觉灵敏度"></a>Visual Sensitivity 视觉灵敏度</h2><p><strong>视觉系统根据入射光照的特性创建视觉环境的描述。因此，了解人类视觉系统能够实际检测到的入射光照的特性是非常重要的。关于人类视觉系统的一个关键观察是，它主要对光的模式敏感，而不是对光能的绝对量级敏感。眼睛不能作为光度计来使用。相反，它检测视网膜上成像的光的空间、时间和光谱模式，关于这些光模式的信息构成了所有视觉感知的基础。</strong></p>
<p><strong>视觉系统对空间和时间上的光照变化的敏感性具有明显的生态效用。准确感知环境变化对我们的生存至关重要。一个测量光能变化而不是能量本身大小的系统在工程上也是有意义的，因为它使在光强大范围内更容易检测光的模式。视觉以这种方式运作对计算机图形学来说是件好事。显示设备在物理上是有限的，因为它们投射光线的功率和动态范围是典型的自然场景。如果图形显示需要产生与相应的物理世界相同的光模式，那么它们就不会有效。幸运的是，所需要的只是显示器能够产生与现实世界相似的空间和时间变化模式。</strong></p>
<h3 id="Brightness-and-Contrast-亮度和对比度"><a href="#Brightness-and-Contrast-亮度和对比度" class="headerlink" title="Brightness and Contrast 亮度和对比度"></a>Brightness and Contrast 亮度和对比度</h3><p><strong>在明亮的光线下，人类的视觉系统能够区分由高对比度平行光条和细至50-60周期/度的暗条组成的光栅。(在这种情况下，一个“循环”由一对相邻的亮条和暗条组成。)作为比较，目前最好的液晶电脑显示器，在正常的观看距离，可以显示图案的精细约20周期/度。人类视觉系统在强光下检测到的边缘处的最小对比度差约为边缘处平均亮度的1%。在大多数8位显示器中，由于从灰度级到实际显示亮度的映射特性，单个灰度级的差异通常在至少部分强度范围内是显而易见的。</strong></p>
<p><strong>描述视觉系统检测精细尺度模式(视敏度)和检测亮度变化的能力要比照相机和类似的图像采集设备复杂得多。如下图所示，人类视觉的对比度和敏锐度之间存在交互作用。在图中，图案的比例从左到右减小，而对比度从上到下增大。如果你以正常的观察距离观察图形，就会清楚地看到图案可见的最低对比度是图案空间频率的函数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021143240.png" class="" title="image-20211021143240">

<p>条纹之间的对比度从上到下以恒定的方式增加，而能见度阈值则随频率而变化。</p>
<p><strong>从世界上某一表面点到达人眼的光的强度L，照亮该表面点的光的强度I，和被观察点表面的反射率R之间存在线性关系:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021143329.png" class="" title="image-20211021143329">

<p><strong>其中α依赖于表面几何形状、入射照明模式和观察方向之间的关系。虽然眼睛只能直接测量L，但人类的视觉在估计R方面要比L好得多。要看到这个，可以在明亮的直射光下查看下图。用你的手在其中一个图案上画上阴影，让另一个直接发光。虽然两个图案反射的光会有显著的不同，但两个中心正方形的表观亮度看起来几乎是一样的。“亮度”一词通常用来描述表面的表观亮度，有别于其实际亮度。在许多情况下，亮度对光照的大变化是不变的，这种现象被称为亮度恒定。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144256.png" class="" title="image-20211021144256">

<p>亮度恒常性。用你的手在其中一个图案上投上阴影，注意到两个中心正方形的明显亮度几乎是相同的。</p>
<p><strong>人类视觉系统实现亮度恒定的机制还没有被很好地理解。如上上图所示，视觉系统对缓慢变化的光模式相对不敏感，这可能会抵消缓慢变化光照的影响。视亮度受周围区域亮度的影响(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144402.png" class="" title="image-20211021144402">

<p>(a)同时对比:中心条的表观亮度受周围区域亮度的影响;(b)相同的条，没有变量包围。</p>
<p><strong>这可以帮助不同区域照明时的亮度恒定。而这种同时产生的对比效果通常被描述为感知到的轻一个区域基于周围区域的亮度对比，它实际上要复杂得多(下两图)。关于亮度感知的更多信息，请参见(Gilchrist et al.， 1999)和(Adelson, 1999)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144516.png" class="" title="image-20211021144516">

<p>蒙克-怀特错觉显示了同时对比的复杂性。在上上图中，当周围区域变暗时，中心区域看起来更亮。在(a)中，左边的灰色条纹看起来比右边的灰色条纹浅，尽管它们几乎被白色区域包围;(b)显示没有黑线的灰色条纹。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144528.png" class="" title="image-20211021144528">

<p>对亮度的感知受到对三维结构的感知。标记(a)的两个表面具有相同的亮度，标记(b)的两个表面也是如此(Adelson(1999))。</p>
<p><strong>虽然视觉系统在很大程度上忽略了缓慢变化的强度模式，但它对由亮度不连续线组成的边缘非常敏感。成像光强中的边缘通常对应于表面边界或环境中的其他重要特征(下图)。视觉系统还可以检测运动的局部差异、立体视差、纹理等图像属性。然而，视觉系统几乎没有能力检测颜色的空间不连续，如果没有伴随这些其他特性的差异。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144713.png" class="" title="image-20211021144713">

<p>(a)原始灰度图像，(b)图像边缘，即在某一方向上空间变异性较大的线。</p>
<p><strong>对边缘的感知似乎与对形式的感知相互作用。虽然边缘为视觉系统提供了识别形状所需的信息，但如果最终的边缘创建了更完整的形式，那么缓慢变化的亮度可能会出现锐利的边缘(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144806.png" class="" title="image-20211021144806">

<p>视觉系统有时会看到“边缘”，即使在亮度上没有明显的不连续，就像这张图片中中心图案的右侧。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144852.png" class="" title="image-20211021144852">

<p>有时，视觉系统会“看到”主观轮廓，而没有任何相关的亮度变化。</p>
<p><strong>上图显示了一个主观轮廓，这是这种效果的一种极端形式，即使在实际图像中没有这样的轮廓，也可以看到一个封闭的轮廓。最后，视觉系统对边缘的敏感性似乎也是参与亮度感知的机制的一部分。注意，在上图中主观轮廓所包围的区域看起来比页面周围的区域要亮一些。下图显示了边缘和亮度之间的不同交互作用。在这种情况下，一个特定的亮度轮廓在边缘有一个戏剧性的影响表面的表观亮度的任何一边的边缘。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021144949.png" class="" title="image-20211021144949">

<p>感知的亮度更多地依赖于边缘的局部对比度，而不是表面的亮度。试着用铅笔覆盖图形中间的垂直边缘。这个图像是Craik-O ‘Brien-Cornsweet错觉的一个例子。</p>
<p><strong>如上所述，如果两个相邻区域之间的亮度差异至少是平均亮度的1%，人们就可以检测到亮度差异。这是韦伯定律的一个例子，该定律指出，在刺激的显著差异(jnd)和刺激的大小之间存在一个恒定的比例:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145046.png" class="" title="image-20211021145046">

<p><strong>I是刺激的大小，ΔI是明显差异的大小，k₁ 是刺激所特有的常数。韦伯定律于1846年提出，至今仍是许多知觉效应的有用表征。1860年提出的Fechner定律，将韦伯定律推广到一种允许描述任何感官体验强度的方式，而不仅仅是jnd:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145120.png" class="" title="image-20211021145120">

<p><strong>其中S是感官体验的感知强度，I是相应刺激的物理大小，k₂ 是特定于刺激的缩放常数。目前的做法是使用幂函数(史蒂文斯定律)来模拟刺激的感知强度和实际强度之间的联系:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145152.png" class="" title="image-20211021145152">

<p><em><em>S和I和之前一样，k₃ 是另一个缩放常数，b是特定于刺激的指数。对于涉及视觉的大量知觉量，b &lt; 1。在其他地方描述的CIE L</em> a</em> b<em>颜色空间，使用改进的史蒂文斯定律表示来表征亮度值之间的感知差异。注意,在前两个特征的知觉强度的刺激和史蒂文斯定律当b &lt; 1,刺激的变化当它有一个小的平均大小创建更大的感知效果比相同的物理刺激的变化幅度更大。</em>*</p>
<p><strong>上面描述的“法则”并不是对感知如何运作的物理约束。相反，它们是关于感知系统如何对特定的物理刺激作出反应的概括。在知觉心理学领域，定量研究物理刺激与其知觉效应之间的关系被称为心理物理学。虽然心理物理定律是由经验推导出来的观察结果，而不是机械的解释，但如此多的知觉效应被简单的权力函数很好地模拟，这一事实是惊人的，可能提供了有关机制的见解。</strong></p>
<h3 id="Color-颜色"><a href="#Color-颜色" class="headerlink" title="Color 颜色"></a>Color 颜色</h3><p><strong>1666年，艾萨克·牛顿(Isaac Newton)用棱镜表明，显然白色的阳光可以分解成光谱的颜色，这些颜色可以重新组合，产生白色的光。我们现在知道光能是由一组光子组成的，每个光子都有特定的波长。光的光谱分布是光在每个波长的平均能量的量度。对于自然照明，表面反射的光的光谱分布显著地取决于表面材料。因此，这种光谱分布的特征可以为环境中表面的性质提供视觉信息。</strong></p>
<p><strong>大多数人在看世界的时候都有一种普遍的颜色感。颜色感知取决于光的频率分布，人类的可见光谱波长从370 nm到730 nm不等(见下图)。视觉系统从光谱分布中获得色彩感的方式在1801年首次被系统地研究，并在此后的150年里一直备受争议。问题是，视觉系统对光谱分布模式的反应与亮度分布模式非常不同。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145630.png" class="" title="image-20211021145630">

<p>可见光谱。波长的单位是纳米。</p>
<p><strong>即使考虑到亮度恒常性等现象，明显不同的空间分布几乎总是看起来明显不同。更重要的是，鉴于视觉系统的目的是在给出近端刺激的情况下产生对远端刺激的描述，感知到的亮度模式至少大致对应于环境中表面的亮度模式。</strong></p>
<p><strong>而对颜色的感知却并非如此。许多不同的光的光谱分布可以产生任何特定颜色的感觉。相应地，一个表面是一种特定颜色的感觉提供的关于从该表面来的光的光谱分布的直接信息很少。例如，光谱分布由波长为700 nm和540 nm的光组合而成，并适当地选择相对强度，看起来与波长为580 nm的光没有区别。(感知上难以区分的不同光谱组成的颜色被称为超光谱。)如果我们看到“黄色”，我们就无法知道它是由这些分布中的一种或另一种产生的，还是由无穷多的其他光谱分布产生的。因此，在视觉语境中，颜色一词指的是一种纯粹的感知性质，而不是物理性质。</strong></p>
<p><strong>在人类视网膜上有两类感光细胞。视锥细胞参与颜色感知，而视杆细胞对可见范围内的光能敏感，不提供颜色信息。有三种视锥细胞，每一种都有不同的光谱灵敏度(下图)。S锥对可见光谱中蓝色范围内的短波长有反应。M锥对可见光谱的中间(绿色)区域的波长有反应。L锥对覆盖可见光谱的绿色和红色部分的较长的波长有反应。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021145802.png" class="" title="image-20211021145802">

<p>人眼视网膜中短、中、长视锥细胞的光谱敏感度</p>
<p><strong>虽然我们通常用红色、绿色和蓝色来描述三种视锥细胞，但这既不是正确的术语，也不能准确反映上图所示的视锥细胞的敏感性。L锥和M锥是广泛调谐的，这意味着它们对广泛的频率范围作出反应。三种锥型的灵敏度曲线也有很大的重叠。综上所述，这两个性质意味着不可能重建一个近似给出了三种锥型响应的原始谱分布。这与视网膜(和数码相机)的空间采样形成了对比，后者的感受器在空间灵敏度上进行了细微调整，以便能够在局部对比度下检测出细节。</strong></p>
<p><strong>人类视网膜中只有三种颜色敏感的光感受器，这一事实大大简化了在计算机显示器和其他图形显示器上显示颜色的任务。计算机显示器显示的颜色是三种固定颜色分布的加权组合。在大多数情况下，这三种颜色是明显的红色、明显的绿色和明显的蓝色。因此，在计算机图形中，颜色通常由红-绿-蓝(RGB)三色表示，代表显示特定颜色所需的红、绿、蓝三原色的强度。三种基本颜色足以显示大多数可感知颜色，因为适当选择的三种颜色的适当加权组合可以产生这些可感知颜色的度量。</strong></p>
<p><strong>RGB颜色表示至少存在两个重大问题。首先，不同的显示器的红、绿、蓝三原色有不同的光谱分布。因此，感知上正确的颜色再现需要为每个显示器重新映射RGB值。当然，这只有在原始RGB值满足某些定义良好的标准时才有可能，但通常情况并非如此。(关于这个问题的更多信息，请参阅第19章。)第二个问题是RGB值不能以一种符合主观感知的方式来定义特定的颜色。当我们看到“黄色”时，我们不会觉得它是由红光和绿光等分组成的。相反，它看起来像是一种单一的颜色，带有亮度和颜色“数量”等附加属性。将颜色表示为S锥、M锥和L锥的输出也没有帮助，因为我们没有更多的现象学意义上的颜色的特征为这些属性，而不是我们的特征为RGB显示属性。</strong></p>
<p><strong>有两种不同的方法可以更准确地反映人类的感知来描述颜色。各种CIE颜色空间的目标是“感知统一”，以便两种颜色的代表值的差异大小与感知到的颜色差异成正比(Wyszecki &amp; Stiles, 2000)。这是一个很难实现的目标，在过去的几年里CIE模式已经有了几次修改。此外，虽然CIE颜色空间的一个维度对应于感知的亮度，但其他两个指定色度的维度没有直观的意义。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021150033.png" class="" title="image-20211021150033">

<p>HSV颜色空间。色调在圆周围变化，饱和度随半径变化，值随高度变化。</p>
<p><strong>第二种以更自然的方式描述颜色的方法始于观察到有三个不同的和独立的属性支配色彩的主观感觉。亮度，即表面的表观亮度，已经讨论过了。饱和度是指颜色的纯度或鲜明度。颜色可以从完全不饱和的灰色到部分饱和的粉彩，再到完全饱和的“纯”色。第三个属性，色相，最接近“颜色”这个词的非正式含义，其特征与可见光谱中的颜色相似，从深紫色到深红色。上图显示了色调-饱和度-亮度(HSV)色彩空间图。由于亮度和亮度之间的关系既复杂又不被很好地理解，HSV颜色空间几乎总是使用亮度而不是试图估计亮度。然而，与光谱中的波长不同，色相通常以一种反映可见光谱的极端在外观上实际上是相似的方式来表示(下图)。一个特定颜色值的RGB和HSV表示之间存在简单的转换。因此，虽然HSV颜色空间是由感知考虑驱动的，但它包含的信息并不比RGB表示多。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021150120.png" class="" title="image-20211021150120">

<p>绿色和紫色，哪个颜色更接近红色?</p>
<p><strong>描述颜色的色调-饱和度-亮度方法是基于单点上的光谱分布，因此仅近似于光在空间上分布的光谱分布的感知响应。像亮度/亮度一样，颜色感知也受到类似的恒定和同时的对比度影响，这两者在RGB表示中都没有捕捉到，因此在HSV表示中也没有捕捉到。例如，在白炽灯下的室内和在阳光直射下的室外，看一张白纸。在这两种情况下，纸张看起来都是“白色”的，尽管白炽灯有明显的黄色色调，因此纸张反射的光线也会有黄色色调，而阳光的光谱颜色则要均匀得多。</strong></p>
<p><strong>CIE颜色空间或HSV编码都没有捕捉到的另一个色彩感知方面是，当我们观察连续的可见光光谱或自然出现的彩虹时，我们会看到少量独特的颜色。对大多数人来说，可见光谱似乎可以分为四到六种不同的颜色:红、黄、绿、蓝，也许再加上浅蓝色和紫色。如果考虑到非光谱颜色，英语中常用的基本颜色术语只有11个:红、绿、蓝、黄、黑、白、灰、橙、紫、棕、粉。将本质上连续的光谱分布空间划分为与定义明确的语言术语相关的相对较小的知觉类别集，似乎是知觉的基本属性，而不仅仅是文化产物(Berlin &amp; Kay, 1969)。然而，这一过程的确切性质尚不清楚。</strong></p>
<h3 id="Dynamic-Range-动态范围"><a href="#Dynamic-Range-动态范围" class="headerlink" title="Dynamic Range 动态范围"></a>Dynamic Range 动态范围</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021150444.png" class="" title="image-20211021150444">

<p>白色表面在不同照明类型下的近似亮度水平，单位为每平方米坎德拉(cd/m2)。(万德尔,1995)。</p>
<p><strong>自然光照强度的变化超过6个数量级(上图)。人类的视觉系统能够在整个亮度范围内运作。然而，在任何时间点上，视觉系统只能在更小的范围内检测到光强度的变化。由于视觉系统所暴露的平均亮度随时间而变化，因此可分辨亮度的范围也会相应发生变化。如果我们从一个明亮的室外区域快速移动到一个非常黑暗的房间，这种效果是最明显的。起初，我们能看到的很少。然而，过了一段时间，房间里的细节开始变得明显。这种对黑暗的适应涉及到眼睛的许多生理变化。显著的暗适应需要几分钟，完全的暗适应需要40分钟左右。如果我们回到明亮的光线中，不仅视野困难，实际上还会很痛苦。在它再次能够看清楚之前，光适应是必需的。光适应发生的速度比暗适应快得多，通常需要不到一分钟。</strong></p>
<p><strong>人类视网膜上的两类光感受器对不同的亮度范围都很敏感。从明亮的阳光到昏暗的室内光线，视锥细胞在大多数我们认为正常的光照条件下提供视觉信息。这种棒只在非常低的光线下有效。光视涉及到只有视锥细胞有效的强光。暗视涉及到只有杆状体有效的暗光。视锥细胞和视杆细胞在一定的强度范围内对光线变化都很敏感，这被称为中温条件(见第21章)。</strong></p>
<h3 id="Field-of-View-and-Acuity-视野和敏锐度"><a href="#Field-of-View-and-Acuity-视野和敏锐度" class="headerlink" title="Field-of-View and Acuity 视野和敏锐度"></a>Field-of-View and Acuity 视野和敏锐度</h3><p><strong>每个眼睛在人类的视觉系统有一个视野大约160◦水平135◦垂直。在双目观察中，两只眼睛的视野只有部分重叠。这导致一个更宽的整体视野(大约200◦水平◦135◦垂直)，与重叠的区域大约是120◦水平◦135◦垂直。</strong></p>
<p><strong>在正常视力或矫正视力的情况下，我们通常有一种主观体验，无论我们看什么，都能看到相对细微的细节。然而，这只是一种错觉。每只眼睛的视野中只有一小部分对细节是敏感的。要看到这一点，将一张覆盖着正常大小文本的纸放在手臂的长度处，如下图所示。盖住一只眼睛手不握纸。盯着你的拇指不动眼睛的时候，注意你拇指上方的文字是可读的，而两边的文字则不然。高灵敏度的视力局限于一个略大于你的拇指在手臂长度的视角。我们通常不会注意到这一点，因为眼睛通常会频繁地移动，使得视野的不同区域都能以高分辨率被观察到。随着时间的推移，视觉系统将这些信息整合在一起，以高分辨率产生整个视野的主观体验。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021150916.png" class="" title="image-20211021150916">

<p>如果你把一页文字拿在一臂远的地方，盯着你的拇指看，那么只有拇指附近的文字是可读的。由Peter Shirley拍摄。</p>
<p><strong>如果在整个视网膜上对图像强度进行密集采样，人类视觉皮层就没有足够的带宽来处理由此产生的信息。视网膜中密度可变的光感受器的堆积和快速眼球运动以指向感兴趣区域的机制的结合，提供了一种同时优化视力和视野的方法。其他动物进化出了不同的平衡视力和视野的方式，而不依赖于快速的眼球运动。有些人只有高的视力，但局限于狭窄的视野。有些人视野开阔，但看到细节的能力有限。</strong></p>
<p><strong>将周围环境中感兴趣的区域集中在中央凹上的眼部运动称为扫视。扫视发生得非常快。从触发刺激到完成眼球运动的时间为150-200毫秒。大部分时间花在视觉系统规划扫视。实际的移动平均需要20毫秒左右。眼睛在扫视过程中移动非常快，最大旋转速度经常超过500◦/秒。在扫视之间，眼睛指向一个感兴趣的区域(固定)，需要300毫秒左右的时间来获取详细的视觉信息。在广阔的视野中，多重固定结合在一起形成一个整体的主观细节感的机制还没有被很好地理解。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021151005.png" class="" title="image-20211021151005">

<p>人视网膜中视杆细胞和视锥细胞的密度(以Osterberg(1935)命名)。</p>
<p><strong>上图显示了人眼视网膜中视锥细胞和视杆细胞的不同堆积密度。在正常光照下负责视觉的视锥细胞最紧密地聚集在视网膜中央凹处(上图)。当眼睛固定在环境中的一个特定点时，这个点的图像就落在中央凹上。中央凹处的锥细胞堆积密度越高，成像光的采样频率就越高(见第9章)，因此采样模式的细节就越详细。中央凹视觉包含约1.7◦，这是相同的视角，你的拇指在手臂的长度。</strong></p>
<p><strong>虽然上图的一个版本出现在大多数关于人类视觉感知的介绍性文本中，但它只提供了视觉敏度的神经生理学限制的部分解释。在信息被传送之前，单个视杆细胞和视锥细胞的输出通过神经连接以不同的方式汇聚在眼睛里沿着视神经到达视觉皮层。这种汇聚过滤由入射照明模式提供的信号，其方式对可检测的光模式有重要影响。特别是，离中央凹越远，平均亮度的区域就越大。因此，远离中央凹的空间视力急剧下降。大多数显示杆状和锥状堆积密度的图像表明了视网膜盲点的位置，在这里，将光学信息从眼睛传送到大脑的神经束通过视网膜，对光线没有敏感性。总的来说，盲点对真实世界感知的唯一实际影响是它在入门感知文本中的错觉，因为正常的眼球运动弥补了暂时的信息损失。</strong></p>
<p><strong>如上图所示，在中央凹中心处，棒的堆积密度降至零。远离中央凹时，杆状细胞密度先增大后减小。这样做的一个结果是，当光照很低时，没有中央凹视觉。在没有月亮的夜晚，远离城市灯光，观察夜空，就可以证明中央凹中没有杆状细胞。有些星星非常暗淡，如果你看星星旁边的一点，就能看到它们，但如果你直接看它们，它们就会消失。这是因为当你直接观察这些特征时，这些特征的图像只落在视网膜的锥细胞上，而锥细胞对光线不够敏感，无法探测到这些特征。稍微往旁边看会使图像落在更敏感的视锥细胞上。暗视的视力也受到限制，部分原因是视网膜上的杆状细胞密度较低，部分原因是为了增加传回大脑的视觉信息的光敏度，视网膜上杆状细胞的信号池更大。</strong></p>
<h3 id="Motion-运动"><a href="#Motion-运动" class="headerlink" title="Motion 运动"></a>Motion 运动</h3><p><strong>当阅读有关视觉感知的内容和看着印刷纸张上的静态图形时，我们很容易忘记，运动在我们的视觉体验中是无处不在的。由于眼睛和身体的运动以及世界上物体的运动，落在视网膜上的光的模式不断变化。这部分介绍了我们检测视觉运动的能力。第20.3.4节描述了如何使用视觉运动来确定环境的几何信息。第20.4.3节讨论了如何使用运动来引导我们在环境中的运动。</strong></p>
<p><strong>对落在视网膜上的特定光模式运动的检测是速度、方向、模式大小和对比度的复杂功能。这个问题更加复杂，因为同时的对比效应在运动知觉中发生的方式与在亮度知觉中观察到的方式相似。在一个极端的情况下，单一的小模式移动对一个对比，均匀的背景，可感知的运动需要一个运动速率对应的0.2◦-0.3◦/秒的视角。同样的图案对纹理图案的运动以十分之一的速度可以检测到。</strong></p>
<p><strong>由于对视网膜运动的敏感性，再加上眼跳运动的频率和速度，令人惊讶的是，当我们看到这个世界时，它通常看起来是稳定和静止的。视觉系统通过三种方式实现这一点。在扫视过程中，对比敏感度降低，减少了由眼睛位置的快速变化所产生的视觉效果。在扫视之间，各种精密复杂的机制调整眼睛的位置，以补偿头部和身体的运动，以及世界上感兴趣的物体的运动。最后，视觉系统利用眼睛位置的信息，从多个固定位置将高分辨率图像的小块拼接成一个单一的、稳定的整体。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021151506.png" class="" title="image-20211021151506">

<p>孔径问题:(a)如果一条直线或边缘以一种隐藏端点的方式移动，视觉信息不足以确定这条线的实际运动。(b)如果直线上有任何角或其他明显的标记，则直线的二维运动是明确的。</p>
<p><strong>如果看不到端点或角，直线和边缘的运动是模糊的，这种现象称为孔径问题(上图)。光圈问题的出现是因为平行于线或边的运动分量不会产生任何视觉变化。现实世界的几何学是足够复杂的，这很少在实践中造成困难，除了有意的幻觉，如理发杆。然而，在一些计算机图形渲染中发现的简化几何和纹理，有可能在感知运动中引入不精确性。</strong></p>
<p><strong>实时计算机图形、电影和视频如果没有一个重要的感知现象是不可能的:不连续运动，即一系列静态图像在时间上的离散间隔是可见的，然后在空间上按离散间隔移动，几乎与连续运动没有区别。这种效果被称为表观运动，强调连续运动的出现是一种错觉。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021152758.png" class="" title="image-20211021152758">

<p>(a)连续运动。(b)具有相同平均速度的不连续运动。在某些情况下，对这两种运动模式的感知可能是相似的。</p>
<p><strong>上图说明了连续运动与视运动的区别，这是现实世界中的典型运动，而视运动是几乎所有动态图像显示设备所产生的。在上图 (b)中绘制的运动包含了一个与上图 (a)所示类似的平均运动，由一个高时空频率调制，该频率解释了一个静止模式和一个不连续移动到一个新位置之间的交替。由于视觉系统对运动的高频部分不敏感，所以出现了连续运动的表观感知。</strong></p>
<p><strong>当单个图像出现的频率超过10hz时，只要连续图像之间的位置变化不是太大，就会产生明显的运动感。然而，对于大多数图像显示设备来说，这个速度不足以产生令人满意的连续运动感。几乎所有这类设备都会在切换到下一幅图像时引入亮度变化。在光线充足的条件下，人类的视觉系统对这种高达80赫兹的变化率的亮度变化非常敏感。在低光下，可检测性高达40赫兹。当交替亮度足够高时，发生闪烁融合，变化不再可见。</strong></p>
<p><strong>因此，为了产生令人信服的视觉动感，图像显示必须满足两个单独的约束条件:</strong> </p>
<p>​    <strong>•图像必须以≥10 Hz的速率更新;</strong> </p>
<p>​    <strong>•在更新图像的过程中引入的任何闪烁必须以≥60-80 Hz的频率发生。</strong> </p>
<p><strong>一种解决方案是要求图像更新率大于或等于60-80 Hz。然而，在许多情况下，这根本是不可能的。对于计算机图形显示，帧计算时间通常大大超过12-15毫秒。旧监视器技术的传输带宽和限制限制了普通广播电视每秒25-30幅图像。(一些高清电视格式的运行速度是60图像/秒。)电影以每秒24帧的速度更新图像，这是由于曝光时间的要求和物理移动胶片的机械困难。</strong></p>
<p><strong>不同的显示技术以不同的方式解决这个问题。计算机显示器的刷新频率为~ 70 ~ 80赫兹，与图像内容的变化频率无关。术语帧速率对于这种显示来说是不明确的，因为需要两个值来描述这种显示:刷新率，表示图像重新显示的速率和帧更新率，表示生成新图像用于显示的速率。标准的非高清电视广播电视使用60hz的刷新率(NTSC，在北美和其他一些地区使用)或50hz的刷新率(PAL，在世界其他大部分地区使用)。帧更新速率为刷新率的一半。不是将每个新图像显示两次，而是通过将交替的水平图像线划分为偶数和奇数字段，并交替显示这些偶数和奇怪的领域。在电影中避免闪烁的方法是，使用机械快门在进入下一帧之前每帧闪烁三次，产生72赫兹的刷新率，同时保持24赫兹的帧更新率。</strong></p>
<p><strong>使用视运动来模拟连续运动偶尔会产生不良的伪影。其中最著名的是马车车轮错觉，在这个错觉中，旋转车轮的辐条似乎在与预期的方向相反的方向旋转，给出了车轮的平移运动。车轮错觉是时间混叠的一个例子。辐条，或旋转圆盘上的其他空间周期模式，产生一个时间周期信号，用于观察与车轮或圆盘的中心固定的位置。固定的帧更新率有在时间上采样这个时间周期信号的效果。如果采样模式的时间频率太高，欠采样结果在图像显示时出现混叠，较低的时间频率。在某些情况下，这种时间频率的失真会导致空间失真，在这种情况下，车轮似乎在向后移动。由于时间采样率较低，马车轮错觉在电影中比在视频中更容易发生。</strong></p>
<p><strong>当从一种介质转换到另一种介质时，也会出现问题。当24赫兹的电影被转换成视频时，这一点尤为重要。不仅非隔行格式需要转换为隔行格式，而且也没有直接的方法将每秒24帧转换为每秒50或60个字段。一些高端显示设备能够部分补偿电影转换成视频时产生的影响。</strong></p>
<h2 id="Spatial-Vision-空间视觉"><a href="#Spatial-Vision-空间视觉" class="headerlink" title="Spatial Vision 空间视觉"></a>Spatial Vision 空间视觉</h2><p><strong>视觉系统执行的关键操作之一是对可见环境的几何属性的估计，因为这些是确定关于对象、位置和事件的信息的核心。视觉有时被描述为逆光学，以强调视觉系统的一个功能是倒转图像形成过程，以确定在视网膜上产生特定图案的几何形状、材料和世界上的照明。视觉系统的核心问题是，可见环境的特性与视网膜上成像的光的模式混杂在一起。亮度是光照和反射率的函数，由于光传输的复杂性，它可以依赖于大区域空间的环境属性。图像位置的投影环境位置最多可以用于将该位置的位置限制为半线。因此，几乎不可能唯一地确定产生特定成像模式光的世界的性质。</strong></p>
<p><strong>确定表面布局-环境中可见表面的位置和方向被认为是人类视觉的关键步骤。大多数讨论的视觉系统提取信息布局模式的光接收表面将问题划分为一组视觉线索,与每个线索描述一个特定的视觉模式,可以用来推断表面布局的属性以及所需的推理规则。由于表面布局很少能准确和明确地确定仅从视觉，推断表面布局的过程通常需要额外的，非视觉信息。这可能来自对现实世界可能发生的事情的其他感觉或假设。</strong></p>
<p><strong>视觉线索通常被分为四类。眼动线索包括关于眼睛位置和焦点的信息。视差线索包括用两只眼睛观察同一表面点所获得的信息，而不仅仅是眼睛的位置所获得的信息。运动线索提供了关于世界的信息，这些信息来自观察者的运动或物体的运动。图像线索来自于将三维表面形状投射到落在视网膜上的2D光模式的过程。本节讨论与曲面上单个点的几何信息提取相关的视觉线索。更多的位置和形状信息的提取将在第20.4节中介绍。</strong></p>
<h3 id="Frames-of-Reference-and-Measurement-Scales-参考框架和测量量表"><a href="#Frames-of-Reference-and-Measurement-Scales-参考框架和测量量表" class="headerlink" title="Frames of Reference and Measurement Scales 参考框架和测量量表"></a>Frames of Reference and Measurement Scales 参考框架和测量量表</h3><p><strong>对可见表面上的点的位置和方向的描述必须在特定的参考框架的上下文中完成，该框架指定了用于表示几何信息的坐标系统的原点、方向和比例。人类视觉系统使用多种参考框架，部分原因是不同的视觉线索提供了不同种类的信息，部分原因是信息被放置的目的不同(Klatzky, 1998)。以自我为中心的表示是根据查看者的身体来定义的。它们可以细分为固定在眼睛、头部或身体上的坐标系统。他心表象，也叫外心表象，是根据观察者外部的事物来定义的。异向参考系可以是环境中物体的局部配置，也可以是根据不同的位置、重力或地理属性进行全局定义。</strong></p>
<p><strong>从观察者到环境中特定可见位置的距离，以自我为中心的表现方式表达，在感知文献中通常被称为深度。表面取向可以用自中心坐标表示，也可以用非自中心坐标表示。取向的自我中心表示,偏一词用来指视线之间的角点和表面正常的点,而倾斜指的方向表面正常的投影到一个平面垂直于视线。</strong></p>
<p><strong>距离和方位可以用各种测量尺度表示。绝对描述是使用不属于感知信息本身的标准来指定的。这些标准可以是文化上定义的标准(如米)，也可以是相对于观众身体的标准(如眼睛的高度、肩膀的宽度)。相对描述将一个感知到的几何属性与另一个关联起来(例如，点a的距离是点b的两倍)。顺序描述是相对度量的一种特殊情况，在这种情况下，所代表的只是符号，而不是大小。下表提供了最常考虑的视觉线索的列表，以及它们可能提供的信息种类的特征。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153401.png" class="" title="image-20211021153401">

<p>绝对深度(a)、相对深度(r)和顺序深度(o)的常见视觉信息。</p>
<h3 id="Ocularmotor-Cues-眼动信息"><a href="#Ocularmotor-Cues-眼动信息" class="headerlink" title="Ocularmotor Cues 眼动信息"></a>Ocularmotor Cues 眼动信息</h3><p><strong>有关深度的眼动信息直接来自于对眼睛的肌肉控制。有两种不同类型的眼运动信息。注视是眼睛在一定距离上光学聚焦的过程。收敛(通常称为收敛)是指在三维空间中两只眼睛指向同一点的过程。适应和融合都有可能提供关于深度的绝对信息。</strong></p>
<p><strong>从生理学上讲，人眼的聚焦是通过扭曲眼睛前部晶状体的形状来实现的。视觉系统可以从这种扭曲的程度推断深度。适应是一个相对较弱的距离线索，超过约2米无效。大多数人在超过45岁后，在一定距离范围内都有越来越多的聚焦困难。对他们来说，迁就变得更不有效。</strong></p>
<p><strong>那些不熟悉视觉感知细节的人有时会将调节的深度估计与由于眼睛有限景深而产生的模糊所产生的深度信息混淆。调节深度线索提供了与聚焦的那部分视野的距离信息。它不依赖于视野的其他部分失焦的程度，除了视觉系统使用模糊来调整焦点。景深似乎确实提供了一定程度的顺序深度信息(下图)，尽管这一效应只得到有限的研究。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153731.png" class="" title="image-20211021153731">

<p>中心正方形是出现在圆形图案的前面，还是通过圆形图案的一个方孔出现?这两幅图像的唯一区别是线条和圆形图案之间的边缘清晰度(Marshall, Burbeck, Arely, roland, and Martin(1999)，经许可使用)。</p>
<p><strong>如果两只眼睛注视空间中的同一点，可以使用三角函数来确定从观察者到被观察位置的距离(下图)。在最简单的情况下，注视点就在观众的正前方，</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153834.png" class="" title="image-20211021153834">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153845.png" class="" title="image-20211021153845">

<p>两眼的辐辏提供了关于两眼注视点的距离的信息。</p>
<p><strong>其中，z为到世界上某一点的距离，ipd为瞳间距离，表示两眼之间的距离，θ为收敛角，表示两眼相对于正前方的方向。对于小θ，也就是人眼的几何构型，当θ以弧度表示时，tan θ≈θ。因此，角的差值表示深度的差值，关系如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021153934.png" class="" title="image-20211021153934">

<p><strong>随着θ→0匀速前进，Δz逐渐变大。这意味着随着整体深度的增加，立体视觉对深度变化的敏感度降低。收敛实际上只提供了距离几米的绝对深度的信息。除此之外，距离的变化会导致收敛角的变化，但这些变化太小，无法发挥作用。</strong></p>
<p><strong>在人类视觉系统中，调节和收敛是相互作用的:调节用来帮助确定合适的收敛角，收敛角用来帮助设置焦距。正常情况下，当存在不确定性时，这有助于视觉系统设置调节或收敛。然而，立体计算机显示打破了现实世界中焦点和收敛之间的关系，导致了许多知觉困难(Wann, Rushton， &amp; Mon-Williams, 1995)。</strong></p>
<h3 id="Binocular-Disparity-双眼差异"><a href="#Binocular-Disparity-双眼差异" class="headerlink" title="Binocular Disparity 双眼差异"></a>Binocular Disparity 双眼差异</h3><p><strong>眼睛的收敛角，当固定在空间中的一个公共点上时，只是视觉系统能够从双目立体判断深度的方法之一。第二种机制涉及到视网膜图像的比较两只眼睛，不需要知道眼睛指向哪里。一个简单的例子演示了这种效果。手臂向前伸直，拇指向上。盯着你的拇指，然后闭上一只眼睛。现在，同时睁开闭着的眼睛和闭着睁开的眼睛。你的拇指看起来或多或少是静止的，而你拇指后面更远的表面看起来会从一边到另一边移动(下图)。场景中左眼和右眼之间的点在视网膜上位置的变化叫做视差。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021212243.png" class="" title="image-20211021212243">

<p>双眼差异。从左眼和右眼的视图显示了不同于注视点深度的表面点的偏移。图片由Peter Shirley提供。</p>
<p><strong>双目视差提示要求视觉系统能够将一只眼睛中世界上的点的图像与另一只眼睛中这些点的图像位置进行匹配，这个过程称为对应问题。这是一个相对复杂的过程，人们只了解部分内容。一旦建立了对应关系，世界上特定的点投射到左右视网膜上的相对位置就表明这些点是比注视点更近还是更远。交叉视差发生在相应的点相对于中央凹向外移位，表明表面点比固定点更近。当相应的点相对于中央凹向内移位时，出现不交叉视差，表明表面点比固定点更远(下图)。双目视差是一个相对深度线索，但通过收敛进行缩放，可以提供绝对深度的信息。上上式既适用于双眼视差，也适用于双眼收敛。与收敛时，双眼视差对深度变化的灵敏度随深度的增加而降低。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021212425.png" class="" title="image-20211021212425">

<p>在视线附近，距离注视点较近的表面点与距离较远的表面点在相反方向上产生差异注视点。</p>
<h3 id="Motion-Cues-运动信息"><a href="#Motion-Cues-运动信息" class="headerlink" title="Motion Cues 运动信息"></a>Motion Cues 运动信息</h3><p><strong>眼睛和可见表面之间的相对运动将在视网膜上这些表面的图像上产生变化。眼睛和表面点之间的三维相对运动产生表面点在视网膜上投影的二维运动。这种视网膜运动被称为视流。光流是几种深度线索的基础。此外，光流还可用于确定一个人在世界中如何移动以及是否即将发生碰撞的信息(章节20.4.3)。</strong></p>
<p><strong>如果一个人移动到一边，同时继续注视某些表面点，那么光流提供了类似于立体视差的深度信息。这被称为运动视差。对于其他投影到注视点附近视网膜位置的表面点，零光流表示与注视点等效的深度;流向相反方向时，头部平移表示近点，相当于交叉视差;与头部平移方向相同的流动表示更远的点，相当于没有交叉的视差(下图)。运动视差是相对深度的有力线索。原则上，如果视觉系统能够获得头部运动速度的信息，运动视差可以提供绝对深度信息。在实践中，运动视差充其量只是绝对深度的微弱线索。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021212653.png" class="" title="image-20211021212653">

<p>(a)注视延伸的地平面时向右移动所产生的运动视差。(b)同样的运动，眼球追踪注视点。</p>
<p><strong>除了由于运动视差而产生的以自我为中心的深度信息，视觉运动还可以提供相对于观察者移动的物体的三维形状信息。在知觉文献中，这被称为动力深度效应。在计算机视觉中，它被称为来自-的结构运动。动力学深度效应假定物体运动的一个分量是深度旋转，这意味着有一个围绕垂直于视线的轴旋转的分量。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021212747.png" class="" title="image-20211021212747">

<p>光流信号表面边界的不连续。在许多情况下，深度变化的符号(即顺序深度)。</p>
<p><strong>光流还可以提供关于表面边界形状和位置的信息，如上图所示。光流中的空间不连续几乎总是与深度不连续相对应或由独立的运动物体引起。光流的大小的简单比较不足以确定深度变化的标志，除非在特殊情况下，观察者移动通过一个静态的世界。然而，即使存在独立移动的物体，跨表面边界深度变化的标志通常可以通过其他方法确定。运动经常改变在表面边界可见的较远表面的部分。表面纹理的出现(增加)或消失(删除)是因为较近的、闭塞的表面逐渐显露或覆盖较远的、闭塞的表面的部分。比较表面纹理到边界任意一侧的运动也可以用来推断顺序深度，即使在没有增加或删除纹理的情况下。光流中的不连续和表面纹理的增加/删除被称为动态遮挡信息，是关于环境空间结构的另一个强大的视觉信息来源。</strong></p>
<p><strong>观察者相对于世界上各点的移动速度不能仅从视觉运动来确定(见第20.4.3节)。尽管有这样的限制，我们还是可以利用视觉信息来确定到达一个可见点所需要的时间，即使在速度无法确定的情况下。当速度恒定时，接触时间(通常被称为碰撞时间)是由观察者所移动的物体的视网膜大小除以图像大小增加的速率得出的。在生物视觉文献中，这是通常称为τ函数(Lee &amp; Reddish, 1981)。如果距离信息在世界上的结构上的碰撞时间估计是可用的，那么这可以用来确定速度。</strong></p>
<h3 id="Pictorial-Cues-图像信息"><a href="#Pictorial-Cues-图像信息" class="headerlink" title="Pictorial Cues 图像信息"></a>Pictorial Cues 图像信息</h3><p><strong>即使在没有双目立体视觉或运动的情况下，一幅图像也可以包含关于它产生的世界的空间结构的许多信息。作为证据，请注意，即使我们闭上一只眼睛，保持头部静止，环境中没有任何东西移动，世界仍然是三维的。(如第20.5节所述，对于照片和其他显示的图像，情况会更加复杂。)这种图像深度线索有三类。其中最著名的是线性透视法。即使在没有透视的情况下，也有一些咬合信息提供了关于顺序深度的信息。最后，包括阴影、阴影和相互反射的照明线索，以及空中透视也提供了关于空间布局的视觉信息。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214205.png" class="" title="image-20211021214205">

<p>经典的线性透视效果包括按距离缩放的物体大小、平行线的收敛、地平面延伸到可见的视界，以及地平面相对于视界的位置。图片由Sam Pullara提供。</p>
<p><strong>线性透视一词通常是指属性涉及对象的图像大小的图像缩放距离,平行线的收敛,地平面扩展到可见的地平线,和距离之间的关系对象在地面上飞机,这些对象的图像位置相对于地平线(上图)。更正式地说，线性透视线索是那些利用透视投影的视觉线索，世界上的点被投影到的图像位置是按比例缩放的 1/z ，其中z为从投影点到环境中某一点的距离。这种关系的直接后果是,点预计将越来越远的点接近图像的中心(平行线的收敛),世界上的图像点之间的间距减少更遥远世界点(对象大小缩放图像的距离)。世界上无限平面的象止于有限的视界，这一事实可以通过考察透视投影方程z→∞来解释。</strong></p>
<p><strong>除了第20.4.2节中描述的与尺寸相关的影响外，大多数涉及线性透视的图像深度线索依赖于与地平面接触的感兴趣的物体。实际上，这些线索估计的不是到物体的距离，而是到地平面上接触点的距离。假设观察者和目标都在一个水平地面上，那么在视图中较低的地平面位置将接近。下图定量地说明了这种影响。对于地面上的视点h以及视界和地面上一个感兴趣点之间的倾斜角θ，所讨论的点与观测者所站点的距离为d = h cot θ。赤纬角提供了任意固定视点的相对深度信息，并可以提供绝对深度，当缩放眼高(h)是可能的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214347.png" class="" title="image-20211021214347">

<p>到地平面上位置的绝对距离可以根据从地平线到眼高的赤纬角来确定。</p>
<p><strong>虽然人类的视觉系统几乎可以肯定地利用赤纬角作为深度线索，但用来获取所需信息的确切机制尚不清楚。角度θ可以相对于重力或可见视界得到。有证据表明，这两种方法都用于人类视觉。眼高可以根据姿势来判断，可以通过看脚下的地面来判断，也可以通过经验来判断，假设是恒定的。虽然许多研究人员已经调查了这个问题，但这些值是否以及如何确定尚不确定。</strong></p>
<p><strong>阴影提供了关于三维空间布局的各种类型的信息。附加的阴影表明一个物体与另一个表面相接触，通常包括地平面。分离的阴影表明物体接近某个表面，但不与该表面接触。阴影可以作为间接的深度线索，使物体出现在地平面上阴影位置的深度(Yonas, Goldsmith， &amp; Hallstrom, 1978)。当利用这个信息时，视觉系统似乎假设光是从上面直接来的(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214505.png" class="" title="image-20211021214505">

<p>通过将物体的深度与地平面上的位置联系起来，阴影可以间接地作为深度线索(Kersten, Mamassian, and Knill(1997))。</p>
<p><strong>视觉提供了关于表面方向和距离的信息。用倾斜(定义为表面法线在图像中的投影方向)和倾斜(定义为表面法线与视线之间的角度)来表示直观确定的表面方向是很方便的。</strong></p>
<p><strong>可见的表面地平线可以用来找到相对于观察者的(有效的无限)表面的方向。确定倾斜是很简单的，因为表面的倾斜是可见地平线的方向。斜度也可以恢复，因为从视点到地平线的视线定义了一个平行于表面的平面。在许多情况下，要么地表视界是不可见的，要么地表足够小，其远边缘不符合实际的视界。在这种情况下，可见纹理仍然可以用来估计方向。</strong></p>
<p><strong>在感知的语境中，纹理是指视觉模式，由在表面上复制的子模式组成。子模式及其分布可以是固定的和有规则的，就像棋盘，或者在更统计学意义上是一致的，就像在草地的视图中。当一个纹理表面从一个斜角来看，纹理的投影视图相对于表面上的实际标记是扭曲的。两种截然不同的扭曲会发生(Knill, 1998)，都受到倾斜量的影响。纹理元素的位置和大小取决于上面描述的线性透视效果。这将产生一个纹理梯度(Gibson, 1950)，因为元素大小和间距都随着距离而减小(下图(a))。两者都是个体的形象纹理元素和元素分布在斜视图下被缩短(下图(b))。这就产生了倾斜方向上的压缩。例如，一个斜视圆显示为一个椭圆，其小轴与长轴的比值等于斜度的余弦。请注意，透视本身并不是线性透视的结果，尽管在实践中线性透视和透视都提供了关于倾斜的信息</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214602.png" class="" title="image-20211021214602">

<p>纹理线索的倾斜。(a)近地表显示压缩和结构梯度;(b)远表面仅显示压缩;(c)近地表表面的变异性，具有规则的几何变异性。</p>
<p><strong>对于纹理梯度作为表面倾斜的线索，纹理元素的平均大小和间距必须在纹理表面上保持恒定。如果图像中大小和间距的空间变异性并不完全是由于投影过程，那么试图反转投影效果将产生关于表面方向的错误推断。同样地，如果纹理元素的形状不是各向同性的，则透视缩短提示失效，因为不对称纹理元素图像形状将出现在与斜视无关的情况下。为了使空间视觉线索有效，这些假设通常是必需的。这些假设在一定程度上是合理的，因为它们反映了世界普遍存在的特性。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214643.png" class="" title="image-20211021214643">

<p>从着色中恢复形状。(a)和(b)中的图像似乎有不同的3D形状，因为它们表面的亮度变化率不同。</p>
<p><strong>底纹也提供了关于表面形状的信息(上图)。表面上被观察点的亮度取决于表面反射率和表面相对于定向光源和观察点的方向。当一个物体的相对位置、观察方向和照明方向保持固定时，亮度在一个常量上变化反射面是物体表面方向变化的指示。从着色中恢复形状是指从观测到的亮度变化中恢复表面形状的过程。仅仅通过着色来恢复表面的实际方向几乎是不可能的，尽管着色经常可以与其他线索结合起来提供表面形状的有效指示。对于具有精细几何变化的表面，着色可以提供引人注目的三维外观，即使是在二维表面上渲染的图像(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021214739.png" class="" title="image-20211021214739">

<p>着色可以产生强烈的三维形状感。在这幅图中，如果你用一只眼睛从几米远的地方观看图像，效果会更强烈。如果你把一张硬纸板放在人物的前面，在上面切出一个比图片稍小的洞(见第20.5节)，它就会变得更牢固。图片由Albert Yonas提供。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215010.png" class="" title="image-20211021215010">

<p>(a)连接提供了咬合和角的凹凸性的信息。(b)平面表面物体的常见结类型。</p>
<p><strong>有许多图像线索产生了关于深度的顺序信息，而没有直接指示实际距离。在线形图中，不同类型的连接提供了对3D几何图形的约束，从而可以生成绘图(上图)。许多这样的效果也会出现在更自然的图像中。在感知上最有效的连接线索是T连接，这是一个强有力的指标，表明与T柄相对的表面封闭了至少一个远处的表面。t型连接通常产生一种模态补全的感觉，在这种感觉中，一个表面被看到在一个更近的、封闭的表面后面继续(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215020.png" class="" title="image-20211021215020">

<p>T型连接导致左侧圆盘在矩形后面继续，而右侧圆盘在矩形前面继续，可见矩形在圆盘后面继续。</p>
<p><strong>大气效应引起的视觉变化可以提供深度信息，特别是在长距离的户外。列奥纳多·达·芬奇是第一个描述空中透视(也称为大气透视)，在这种透视中，散射降低了场景中远处部分的对比度，使它们看起来比近的部分更蓝(达·芬奇，1970)(见下图)。空中透视主要是一个相对深度线索，尽管有人推测它也可能影响绝对距离的感知。虽然很多人认为由于大气的影响，更远的物体看起来更模糊，但大气散射实际上很少造成模糊。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215137.png" class="" title="image-20211021215137">

<p>在空中透视中，大气效果降低了对比度，颜色向蓝色方向移动，提供了长距离的深度信息。</p>
<h2 id="Objects-Locations-and-Events-对象、位置和事件"><a href="#Objects-Locations-and-Events-对象、位置和事件" class="headerlink" title="Objects, Locations, and Events 对象、位置和事件"></a>Objects, Locations, and Events 对象、位置和事件</h2><p><strong>虽然目前的视觉科学家普遍认为，视觉的目的是提取有关物体、地点和事件的信息，但对于提取什么信息、如何提取信息或如何使用信息执行任务的关键特征，却几乎没有共识。关于物体识别的本质以及物体识别与知觉的其他方面之间潜在的相互作用存在着重大的争议。我们对位置的了解大多涉及到低层次的空间视觉，而不是与复杂物体之间的空间关系或所需的视觉过程相关的问题在复杂的环境中导航。当人们在这个世界上移动时，我们对他们如何感知自己的速度和方向有相当的了解，但对实际事件感知的了解有限。视觉注意涉及到对物体、位置和事件的感知。虽然有很多关于视觉注意对于相对简单和控制良好的刺激的现象学数据，但我们对视觉注意如何服务于高层次的知觉目标所知甚少。</strong></p>
<h3 id="Object-Recognition-对象识别"><a href="#Object-Recognition-对象识别" class="headerlink" title="Object Recognition 对象识别"></a>Object Recognition 对象识别</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215431.png" class="" title="image-20211021215431">

<p>物体识别的复杂性。(a)我们能识别出类似车辆的物体，即使我们可能从未见过车辆的这种特殊视图。(b)快速查看图像难以识别。如果书是倒过来的，就更容易认出来了。</p>
<p><strong>物体识别包括将图像分割成与不同物理实体相对应的组成部分，并确定这些实体的身份。上图说明了与此过程相关的一些复杂性。我们不难认出左边的图像是某种交通工具，尽管我们之前从未见过这种交通工具的特殊视图，我们中的大多数人也没有把交通工具和这个背景联系起来。在页面翻转之前，右边的图像不太容易识别，这表明人类物体识别的方向偏好。</strong></p>
<p><strong>物体识别被认为包括两个截然不同的步骤。第一步将视野组织成与物体和表面相对应的组。这些分组过程是非常强大的(见下图)，尽管很少或没有意识到生成的低层次图像特征分组效应。分组是基于图像中原始结构的接近性、亮度、颜色、形状和方向的相似性、共同运动和各种更复杂的关系的复杂交互作用。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215609.png" class="" title="image-20211021215609">

<p>图像根据一套复杂的相似性和组织标准被知觉地组织成组。(a)亮度相似导致四个水平分组。(b)邻近造成三种垂直分组。</p>
<p><strong>物体识别的第二步是将分组解释为已识别的物体。一项计算分析表明，识别一个物体有许多截然不同的方法。知觉数据还不清楚究竟哪一个是人类视觉中真正使用的。物体识别要求视觉系统对每一类物体都有可用的描述足以使每个阶级区别于所有其他阶级。物体识别理论的不同之处在于描述每一类的信息的性质，以及用于将这些描述与现实世界的观点相匹配的机制。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215717.png" class="" title="image-20211021215717">

<p>模板匹配。右侧图像中的亮点表示与左侧图像中的模板的最佳匹配位置。图片由国家档案和记录管理局提供。</p>
<p><strong>可能有三种一般类型的描述。模板用每个类中对象的原型视图来表示对象类。上图显示了一个简单的示例。结构描述根据对象视图中很容易检测到的每个类的独特特征，以及关于特征之间的几何关系的信息来表示对象类。结构描述可以用2D或3D表示。对于对象类型的2D模型，必须对对象的每个明显不同的潜在视图有单独的描述。对于3D模型，两种不同形式的匹配策略是可能的。第一种方法是，在分类之前，利用任何可用的空间线索确定被观察对象的三维结构，然后将这个视图的3D描述与已知对象的3D原型相匹配。另一种可能是某些机制允许确定视图中尚未标识的对象的方向。该方向信息用于旋转和投射潜在的3D描述，以允许描述和被观察对象的2D匹配。最后，描述对象类属性的最后一个选项涉及到不变特征，它根据更通用的几何属性来描述对象类，特别是那些可能对对象的不同视图不敏感的属性。</strong></p>
<h3 id="Size-and-Distance-尺寸和距离"><a href="#Size-and-Distance-尺寸和距离" class="headerlink" title="Size and Distance 尺寸和距离"></a>Size and Distance 尺寸和距离</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021215938.png" class="" title="image-20211021215938">

<p>左:视角和熟悉的尺寸线索是一致的。右图:视角和熟悉的尺寸线索是不一致的。图片由Peter Shirley, Scott Kuhl和J. Dylan Lacewell提供。</p>
<p><strong>在缺乏关于深度的更明确信息的情况下，投射到视网膜较大区域的物体被认为比投射到视网膜较小区域的物体更近，这种效应称为相对大小。一个更有力的线索涉及熟悉的大小，它可以提供绝对距离的信息到已知尺寸的可识别物体。熟悉尺寸作为深度线索的强度可以在上图中看到，在上图中，它与地面平面、基于透视的深度线索相冲突。熟悉尺寸是尺寸-距离关系的一部分，它与物体的物理尺寸、投影到视网膜上的相同物体的光学尺寸以及物体到眼睛的距离有关(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220027.png" class="" title="image-20211021220027">

<p>尺寸-距离关系允许已知尺寸的物体之间的距离，根据物体所处的视角确定。同样，一个已知距离的物体的大小可以根据物体所处的视角来确定。</p>
<p><strong>当物体位于平坦地面上时，就可以获得额外的深度信息来源，特别是当地平线是可见的或可以从其他视角信息获得时。地面上接触点的倾斜角是一个相对深度提示，并提供了绝对的自我中心距离，当按眼睛高度缩放时，如上所示图20.27。视界比，即一个物体的总可视高度与出现在视界以下的那部分物体的可视范围相比较，可以用来确定物体的实际大小，即使距离物体的距离未知(下图)。地平线比之下的事实是，对于一个平坦的地面，地平线的视线与物体相交的位置正好是地面上一个眼睛的高度。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220133.png" class="" title="image-20211021220133">

<p>(a)地平比可以通过比较一个物体在地平以下的可见部分与该物体的垂直总可见范围来确定深度。(b)真实世界的例子。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220239.png" class="" title="image-20211021220239">

<p>(a)大小恒常性使得放置在离眼睛不同距离的手在现实世界中看起来几乎是一样的大小，尽管视网膜的大小相当不同。(b)当一只手被另一只手部分遮挡时，特别是当一只眼睛闭上时，这种效果较弱。图片由Peter Shirley和Pat Moulis提供。</p>
<p><strong>人类的视觉系统足以确定大多数被观察物体的绝对大小;我们对大小的感知受实际物理的支配CAL的大小，我们几乎没有意识到物体对应的视网膜大小。这类似于前面讨论过的亮度恒常性，因为我们的感知是由推断出的世界属性所主导的，而不是由视网膜上的光感受器实际感知到的低层次特征。Gregory(1997)描述了一个大小恒定的简单例子。将你的两只手放在你面前，一只手保持一臂的距离，另一只手保持一半的距离(上图(a))。你的两只手看起来几乎一样大，尽管视网膜的大小相差两倍。如果较近的手部分包括较远的手，尤其是当你闭上一只眼睛时(上图(b))，这种效果就弱得多。视觉系统也表现出形状的恒常性，其对几何结构的感知接近实际物体的几何形状，而不是考虑到由于透视造成的视网膜图像畸变(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220250.png" class="" title="image-20211021220250">

<p>形状不变——桌子看起来是矩形的，尽管它在图像中的形状是一个不规则的四边多边形。</p>
<h3 id="Events-事件"><a href="#Events-事件" class="headerlink" title="Events 事件"></a>Events 事件</h3><p><strong>事件感知的大多数方面超出了本章的范围，因为它们涉及复杂的非视觉认知过程。三种类型的事件感知主要是视觉的，然而，也与计算机图形清晰相关。视觉能够提供关于一个人如何在世界上运动的信息，世界上独立运动物体的存在，以及由于观察者的运动或由于物体向观察者移动而可能发生的碰撞。</strong></p>
<p><strong>视觉可以用来确定旋转和相对于环境的平移方向。最简单的例子是向垂直于视线的平面移动。假设有足够的表面纹理使光流恢复，流场将形成如下图(a)所示的对称图案。在视场中的位置，流场的扩展焦点将有相应的平移方向的视线。虽然光流可以用来直观地确定运动方向，但它并不包含足够的信息来确定速度。要理解这一点，请考虑这样一种情况:世界变得两倍大，观察者移动速度两倍快。由于距离增加一倍而导致的流量值的减小正好被速度增加一倍而导致的流量值的增加所补偿，从而形成了一个相同的流场。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220553.png" class="" title="image-20211021220553">

<p>(a)向平坦的纹理表面移动会产生一个膨胀的流场，膨胀的焦点表示与运动方向相对应的视线。(b)观察与视线垂直的平面时，绕垂直轴旋转产生的流场。(c)平行于平面纹理表面的平动所产生的流场。</p>
<p><strong>上图(b)显示了观察者(或者更准确地说，观察者的眼睛)围绕垂直轴旋转所产生的光流场。与平移运动不同的是，光流提供了足够的信息来确定旋转轴和(角速度)旋转轴。的在利用这是实际问题,纯旋转运动产生的流绕轴垂直于视线非常类似于流产生的纯翻译的方向垂直于视线和转动轴,很难在视觉上区分两种不同类型的运动(上图 (c))。下图显示了在更真实的环境中运动所产生的光流模式。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220609.png" class="" title="image-20211021220609">

<p>光流通过一个静态环境产生，提供了相对于环境的运动和到环境中点的距离的信息。在这种情况下，视野的方向从视界被压低，但正如膨胀的焦点所表明的，运动是平行于地平面的。</p>
<p><strong>如果观察者是完全静止的，那么对移动物体的视觉检测就很容易，因为这些物体将与视场中唯一的非零光流相关联。当观察者移动时，情况要复杂得多，因为视野将被非零流支配，大部分或全部这是由于观察者和静态环境之间的相对运动(Thompson &amp; Pong, 1990)。在这种情况下，视觉系统必须对光流场的模式敏感，这种模式与观察者相对于静态环境的运动相关联的流场不一致(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220707.png" class="" title="image-20211021220707">

<p>移动物体的视觉检测一个移动的观察点需要识别光流中的模式，这些模式不能与通过静态环境的运动相关联。</p>
<p><strong>第20.3.4节描述了如何使用视觉来确定与环境中的某一点接触的时间，即使在运动速度未知的情况下。假设观察者沿直线匀速运动，并且世界上没有独立运动的物体，那么在τ关系指示的时间内，在与膨胀焦点相对应的视线方向上的任何表面都会产生接触。一个独立运动的物体使确定是否会发生碰撞的问题变得复杂。水手们使用一种方法来检测潜在的碰撞，这种方法也可以应用于人类的视觉系统:对于非加速直线运动，碰撞将发生在视觉上膨胀的物体上，但在以自我为中心的参照系中，视觉上保持静止。</strong></p>
<p><strong>这里有一种更复杂的事件感知形式值得讨论，因为它在交互式计算机图形学中非常重要。人们对与人体动作相对应的动作特别敏感。当唯一可见的特征是步行者关节上的灯光时，运动就可以被识别出来(Johansson, 1973)。这种移动的灯光显示通常甚至足以识别诸如步行者的性别和负重等属性。在计算机图形渲染中，观众会注意到动画角色哪怕是很小的错误，特别是当他们试图模仿人类动作时。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211021220932.png" class="" title="image-20211021220932">

<p>在(a)和(b)中，视觉注意力很快被吸引到不同形状或颜色的项目上。在(c)中，为了找到形状和颜色都不同的一项，顺序搜索似乎是必要的。</p>
<p><strong>“视觉注意力”一词涵盖了一系列现象，从我们的眼睛指向的地方，到涉及我们在复杂场景中注意到什么以及我们如何解释我们注意到的东西的认知效果(Pashler, 1998)。上图提供了一个注意过程如何影响视觉的例子，即使是非常简单的图像。在左边两个面板，其中一个图案的形状或颜色不同于其他立即“弹出”，很容易被注意到。在右边的面板中，一个在形状和颜色上都不同的图案是很难找到的。这样做的原因是，视觉系统可以对不同属性的项目进行并行搜索，但在寻找两个不同特征同时出现的项目时，需要更多的认知和顺序搜索。基于图形的人机界面应该(但往往不是!)在设计时理解如何利用人的视觉注意过程，以便快速有效地传达重要信息。</strong></p>
<h2 id="Picture-Perception-图像感知"><a href="#Picture-Perception-图像感知" class="headerlink" title="Picture Perception 图像感知"></a>Picture Perception 图像感知</h2><p><strong>到目前为止，本章已经讨论了当世界被人眼直接成像时发生的视觉知觉。当然，当我们看到计算机图形的结果时，我们看到的是经过渲染的图像，而不是真实的世界。这有重要的知觉暗示。原则上，至少在没有物体或观察者运动的情况下，单目观看时，应该可以生成与现实世界难以区分的计算机图形。想象一下透过玻璃窗看外面的世界。现在，考虑给窗户上的每个点上色，使其与最初看到的世界的颜色完全匹配。通过这种操作，到达眼睛的光线是不变的，这意味着无论是观看彩绘玻璃还是通过窗户观看真实世界，感知应该是相同的。计算机图形学的目标可以被认为是产生彩色的窗口，而实际上没有等效的现实世界的视图。</strong></p>
<p><strong>计算机图形学和其他视觉艺术的问题是，我们实际上不能通过给平面上色来匹配真实世界的观点。现实世界中的亮度和动态范围是不可能使用任何当前的显示技术来重现的。渲染图像的分辨率通常也低于人类视觉所能感知的最精细的细节。明度和颜色恒常性在照片不太明显比在现实世界中,可能是因为视觉系统试图弥补可变性的亮度和颜色根据环境照度照明在观看环境中,而不是与渲染后的图像相关的照明。这就是为什么在照片中颜色的真实外观取决于胶片的颜色平衡，以适应拍摄时光源的性质视频中的真实色彩需要白平衡步骤。虽然我们对分辨率、亮度和动态范围的限制如何影响简单模式的可检测性已经了解很多，但对于这些显示特性如何影响空间视觉或物体识别却几乎一无所知。</strong></p>
<p><strong>我们对这个问题的其他方面有了更好的理解，心理学家称之为图像空间的知觉(S. Rogers, 1995)。观看图像和观看真实世界之间的一个区别是，适应能力、双目立体视觉、运动视差，或许还有其他深度线索，可能表明所观察的表面与它所代表的世界距离有很大的不同。在这种情况下看到的深度往往介于图像中的图像线索所表示的深度和到图像本身的距离之间。当看一张照片或电脑显示器时，这通常会导致比预期的规模更小的感觉。另一方面，在大屏幕电影院看电影比在电视上看同样的电影产生更引人注目的空间感，即使距离电视的距离是这样的，视角是相同的，因为电影屏幕更远。</strong></p>
<p><strong>使用透视投影渲染的计算机图形具有一个视点(指定为模型空间中的位置和方向)和一个视图截锥(指定水平和垂直视场以及视图变换的其他几个方面)。如果没有从正确的位置查看渲染的图像，那么图像边缘的视角将与创建图像时使用的截锥不匹配。图像中的所有视角也将被扭曲，导致基于线性透视的所有图像深度和方向线索的扭曲。在实际操作中，当观察者被放置在离照片或显示表面太近或太远的地方时，这种效果经常发生。如果观察者离得太近，深度的透视线索将被压缩，而表面倾斜的线索将表明表面比实际情况更接近于垂直于视线。如果观看者离照片或屏幕太远，情况就会相反。如果视线不穿过观察区域的中心，情况就会更加复杂，因为在各种各样的观察情况下通常都会出现这种情况。</strong></p>
<p><strong>人类的视觉系统能够部分补偿由于在错误的位置观看图像而产生的透视失真，这就是为什么我们能够坐在电影院的不同座位上，体验到类似的描绘空间的感觉。当控制观察位置特别重要时，可以使用观察管。这些是适当大小的管，安装在一个相对于显示器的固定位置，并通过观看者看到显示器。观察管将观察点限制在(希望)矩形的位置。观看管也非常有效地减少了图像中的图像线索和实际显示表面之间的深度信息冲突。他们消除了立体声和运动视差，如果存在，将对应于显示表面，而不是渲染的视图。如果它们的直径足够小，它们还会隐藏画框或显示设备的边缘，从而减少显示表面位置的其他线索。奇异的视觉沉浸式显示设备，如头戴式显示器(HMDs)，在试图隐藏显示表面位置的视觉线索，同时添加双目立体和运动视差，以符合所渲染的世界的几何形状。</strong></p>
<h1 id="21-Tone-Reproduction-色调再现"><a href="#21-Tone-Reproduction-色调再现" class="headerlink" title="21 Tone Reproduction 色调再现"></a>21 Tone Reproduction 色调再现</h1><p><strong>正如在第20章中讨论的，人类的视觉系统适应广泛的观看条件。在正常观察下，我们可以分辨出大约4至5对数单位的照明，即我们能看到细节的最亮和最暗区域的比例可能高达100,000:1。通过适应过程，我们可以适应更大范围的光照。我们称与人类视觉系统能力相匹配的图像为高动态范围。</strong></p>
<p><strong>视觉模拟通常产生具有高动态范围的图像(Ward Larson &amp; Shakespeare, 1998)。图像捕捉技术的最新发展允许多个曝光对齐并重新组合成一个单一的高动态范围图像(Debevec &amp; Malik, 1997)。多种曝光技术也可用于视频。此外，我们希望未来的硬件能够直接拍摄或拍摄高动态范围的场景。一般来说，我们可以把每个像素看作是由三个浮点数组成的三元组。</strong></p>
<p><strong>随着创建高动态范围图像变得越来越容易，显示此类数据的需求也在迅速增加。不幸的是，大多数当前的显示设备，显示器和打印机，只能显示大约2个日志单位的动态范围。我们认为这种器件具有较低的动态范围。今天存在的大多数图像都是用每个字节每个像素每个颜色的通道表示的，这个通道与当前的显示设备相匹配，而不是与它们所代表的场景相匹配。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110407.png" class="" title="image-20211023110407">

<p>在传统摄影中，场景的某些部分可能曝光不足或过度。为了形象化斯诺克球台，在左边的图像中，透过窗户的视野被烧光了。另一方面，如果这个场景的室外部分暴露得很好，斯诺克桌就会太暗。与下图相比，下图显示了使用色调复制算法准备显示的高动态范围图像。</p>
<p><strong>通常，低动态范围的图像无法在不丢失信息的情况下表示场景。一个常见的例子是一个室内房间和一个室外透过窗户可以看到门区。人们可以很容易地看到室内和室外部分的细节。传统的照片通常不能捕捉到全部的信息，摄影师必须选择是否室内或室外部分的场景正确曝光(见上图)。通过使用高动态范围成像和使用本章描述的技术(见下图)准备这些图像用于显示，可以避免这些决策。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110426.png" class="" title="image-20211023110426">

<p>一种高动态范围的图像，使用最近的色调复制操作符进行显示(Reinhard &amp; Devlin, 2005)。在这张图片中，室内部分和透过窗户的视野都被适当地暴露出来。</p>
<p><strong>有两种策略可用来显示高动态范围的图像。首先,我们可以开发一些显示设备可以直接适应高动态范围(Seetzen, Whitehead， &amp; Ward, 2003;Seetzen等人，2004)。其次，我们可以准备高动态范围的图像在低动态范围显示设备上显示(Upstill, 1985)。这是目前比较常用的方法，也是本章的主题。尽管我们预见到这么高动态范围显示设备将在(不久的)将来得到广泛的应用，对图像动态范围的压缩需求可能会减少，但不会消失。特别是，像这本书这样的印刷媒体，就其本质而言，是低动态范围的。</strong></p>
<p><strong>压缩图像的值范围以在低动态范围显示设备上显示为目的，称为音调映射或音调复制。一个简单的压缩函数是对图像进行归一化(见下图(左))。这构成了一个线性缩放，只有当图像的动态范围仅略高于显示设备的动态范围时才趋于充分。对于动态范围较大的图像，微小的强度差异将被量化为相同的显示值，从而导致可见细节丢失。在下图(中间)中，所有大于用户指定最大值的像素值都被设置为这个最大值(即它们被夹住了)。这使得归一化不那么依赖于噪声异常值，但是在这里我们丢失了图像中明亮区域的信息。为了比较，下图(右)是一个色调映射版本，在暗区和亮区都显示了细节。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110619.png" class="" title="image-20211023110619">

<p>线性缩放高动态范围图像以适应给定的显示设备可能会导致重要的细节丢失(左边和中间)。左边的图像是线性缩放的。在中间图像的高值被夹住。为了比较，右边的图像被映射了，使得明亮和黑暗区域的细节都可以看到。</p>
<p><strong>一般来说，线性缩放不适合于音色再现。色调复制的关键问题是压缩图像，同时保留图像的一个或多个属性。不同的色调再现算法关注不同的属性，如对比度、可见细节、亮度或外观。</strong></p>
<p><strong>理想情况下，在低动态范围显示设备上显示色调映射的图像将在观察者中产生与原始场景相同的视觉响应。由于显示设备的限制，这是无法实现的，尽管我们可以尽可能接近这个目标。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110831.png" class="" title="image-20211023110831">

<p>用于演示下图中色调再现目标的图像。</p>
<p><strong>作为示例，我们创建了如上图所示的高动态范围图像。然后这个图像被映射并显示在一个显示设备上。显示设备本身被放置在场景中，这样它就显示了自己的背景(下图)。在理想的情况下，显示应该是透明的。根据色调再现算子的质量以及所描述的场景的性质，这个目标可能或多或少是可以实现的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023110848.png" class="" title="image-20211023110848">

<p>在对上图中的图像进行映射并将其显示在监视器上之后，监视器被放置在场景中大约拍摄图像的位置。根据音调再现运算符的质量，结果应该看起来就像监视器是透明的。</p>
<h2 id="Classification-分类"><a href="#Classification-分类" class="headerlink" title="Classification 分类"></a>Classification 分类</h2><p><strong>虽然可以根据色调再现操作符的目标属性来分类，或者根据它们的任务来分类，但是我们根据它们的一般技术来分类算法。这将使我们能够显示大量不同操作符之间的差异和相似之处，因此，希望有助于为给定的音调复制任务选择有意义的特定操作符。</strong></p>
<p><strong>我们所遵循的主要分类方案是基于音调再现运算符是基于从各个学科获得的见解的认识。特别是，一些操作是基于人类视觉感知的知识。</strong></p>
<p><strong>人类的视觉系统利用位于视网膜上的光感受器来探测光线。光被转换成电信号，在视网膜中进行部分处理，然后传送到大脑。除了视网膜的前几层细胞外，由探测到的光产生的信号是用脉冲序列传输的。携带信息的量是这些电脉冲发生的频率。</strong></p>
<p><strong>人类视觉系统能探测到的光的范围远远大于人类大脑用来传输信息的频率范围。因此，人类视觉系统毫不费力地解决了音调再现问题——大范围的亮度转换为小范围的脉冲序列频率。因此，模仿人类视觉系统的相关方面是一种有价值的色调再现方法;这种方法将在第21.7节中进行更详细的解释。</strong></p>
<p><strong>第二类运算符是基于物理的。光在被光感受器吸收之前与表面和体积相互作用。在计算机图形学中，光的相互作用通常由绘制方程来建模。对于纯粹的漫反射表面，这个方程可以简化为入射到一个表面上的光(照度)和这个表面反射光的能力(反射率)之间的乘积(Oppenheim, Schafer， &amp; Stockham, 1968)。</strong></p>
<p><strong>由于反射是表面的一种被动特性，对于漫反射表面，根据定义，它是低动态范围——通常在0.005到1之间(Stockham, 1972)。一个表面的反射率不能大于1，因为这样它就会反射比入射更多的光。另一方面，照度可以产生任意大的值，并且只受光源的强度和接近程度的限制。</strong></p>
<p><strong>因此，图像的动态范围主要由照度分量控制。面对漫反射场景，一个可行的色调复制方法可能是分离反射和照度，压缩照度成分，然后重新组合图像。</strong></p>
<p><strong>然而，假设场景中的所有表面都是漫反射的，这通常是不正确的。许多高动态范围的图像描绘了高光和/或直接可见光源(图21.3)。镜面反射的亮度几乎和它反射的光源一样高。</strong></p>
<p><strong>目前使用的各种色调再现操作符将图像分割为高动态范围基片层和低动态范围细节层。如果所描绘的场景是完全漫反射的，这些层将代表照明和反射。对于包含直接可见光源或镜面高光的场景，分离到基础层和细节层仍然允许有效的色调再现操作符的设计，尽管对单独的层没有直接的意义。这些运算符将在第21.5节中讨论。</strong></p>
<h2 id="Dynamic-Range-动态范围-1"><a href="#Dynamic-Range-动态范围-1" class="headerlink" title="Dynamic Range 动态范围"></a>Dynamic Range 动态范围</h2><p><strong>传统的图像存储为每一个像素一个字节的红、绿、蓝分量。这种编码提供的动态范围取决于最小和最大可表示值之间的比率，以及连续值之间的步长。因此，对于低动态范围的图像，每个颜色通道只有256个不同的值。</strong></p>
<p><strong>高动态范围图像编码的可能值显著更大的集合;可表示值的最大值可能要大得多，而连续值之间的步长可能要小得多。文件大小高动态因此，范围图像通常也更大，尽管至少有一个标准(OpenEXR高动态范围文件格式(Kainz, Bogart， &amp; Hess, 2003))包括一个非常强大的压缩方案。</strong></p>
<p><strong>限制文件大小的另一种方法是对高动态数据应用色调复制操作符。然后可以将结果编码为JPEG格式。此外，输入图像可以按像素划分为色调映射图像。这种划分的结果可以被下采样，并作为少量数据存储在同一JPEG图像的头部(G. Ward &amp; Simmons, 2004)。这种子带编码图像的文件大小与传统JPEG编码图像相同。显示程序可以直接显示JPEG图像，也可以通过将色调映射的图像与头部存储的数据相乘来重建高动态范围的图像。</strong></p>
<p><strong>一般来说，最小步长和最小和最大可表示值的比值的组合决定了图像编码方案提供的动态范围。对于计算机生成的图像，图像通常在写入文件或显示在屏幕上之前存储为浮点值的三组，尽管可能有更有效的编码方案(Reinhard, Ward, Debevec， &amp; Pattanaik, 2005)。由于大多数显示设备仍然配备8位D/A转换器，我们可以将音调再现看作是浮点数到字节的映射，这样结果就可以在低动态范围显示设备上显示。</strong></p>
<p><strong>单个图像的动态范围通常较小，由场景中发现的最小和最大亮度决定。因此，一种简单的测量图像动态范围的方法可以计算图像的最大像素值和最小像素值之间的比率。忽略一小部分最暗和最亮的像素，可能会降低对异常值的敏感度。</strong></p>
<p><strong>或者，同样的比率可以表示为对数域中的差。这种方法对异常值不太敏感。本页页边空白处显示的图像是具有不同动态范围的图像示例。注意，在这种情况下，夜景的动态范围并不比白天场景小。虽然夜景中所有的值都变小了，但是最大值和最小值之间的比例却不一样。</strong></p>
<p><strong>然而，记录设备或渲染算法可能会引入噪声，从而降低有用的动态范围。因此，对图像动态范围的测量应该考虑噪声因素。因此，在信号处理中使用的信噪比(以分贝表示)是衡量动态范围的更好方法。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111213.png" class="" title="image-20211023111213">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111227.png" class="" title="image-20211023111227">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111243.png" class="" title="image-20211023111243">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111257.png" class="" title="image-20211023111257">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111309.png" class="" title="image-20211023111309">

<p>从上到下动态范围依次为2.65，3.96，4.22，5.01，6.56 log₂ 单位。</p>
<h2 id="Color-颜色-1"><a href="#Color-颜色-1" class="headerlink" title="Color 颜色"></a>Color 颜色</h2><p><strong>色调复制操作员通常压缩亮度值，而不是直接在彩色图像的红、绿、蓝组件上工作。这些亮度值被压缩为显示值Ld(x, y)之后，通过保持彩色通道之间的比率与压缩前相同(使用s = 1)，可以重建彩色图像(Schlick, 1994b):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111747.png" class="" title="image-20211023111747">

<p><strong>结果经常出现过度饱和，因为人类的颜色感知是非线性的整体亮度水平。这意味着，如果我们在昏暗的环境中通过显示器观看明亮的室外场景，我们的眼睛会适应昏暗的环境，而不是室外照明。通过保持色比不变，我们不考虑这个影响。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111828.png" class="" title="image-20211023111828">

<p>每通道的伽玛校正可能降低图像的饱和度。左边图像的饱和度为s = 0.5。右侧图像未去饱和度(s = 1)。</p>
<p><strong>另外，饱和常数s也可以选择小于1。这种每通道的伽马校正可以将结果降低到一个适当的水平，如上图所示(Fattal, Lischinski， &amp; Werman, 2002)。一个更全面的解决方案是将颜色外观建模领域的想法纳入色调复制操作(Pattanaik, Ferwerda, Fairchild， &amp; Greenberg, 1998;Fairchild &amp; Johnson, 2004;Reinhard &amp; Devlin, 2005)。</strong></p>
<p><strong>最后，如果已经有具有代表性配色方案的示例图像，则可以将该配色方案应用于新图像。这种图像之间的颜色映射可以用于微妙的颜色校正，如饱和度调整或更有创意的颜色映射。映射通过将源和目标图像转换到一个不相关的颜色空间进行。在这样的颜色空间中，每个颜色通道中的像素值可以独立处理，而不会引入太多的伪像(Reinhard, Ashikhmin, Gooch， &amp; Shirley, 2001)。</strong></p>
<p><strong>在非相关颜色空间中将颜色从一幅图像映射到另一幅图像很简单:分别计算源图像和目标图像中三个颜色通道中所有像素的平均值和标准差。然后,移动和缩放目标图像，以便每个颜色通道的目标图像的均值和标准差与源图像相同。然后，通过将非相关的颜色空间转换为RGB并将负像素固定为零，得到得到的图像。应用该算法后，图像的动态范围可能会发生变化。因此建议动态范围图像，然后应用传统的色调再现算法。一个合适的非相关颜色空间是19.2.4节中的对手空间。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111939.png" class="" title="image-20211023111939">

<p>用于演示的图像色彩转移技术。下图和21.31显示了应用该算法的结果。</p>
<p><strong>对上图中的图像应用这种颜色变换的结果如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023111951.png" class="" title="image-20211023111951">

<p>左边的图像用于调整上图中图像的颜色。结果显示在右边。</p>
<h2 id="Image-Formation-图像形成"><a href="#Image-Formation-图像形成" class="headerlink" title="Image Formation 图像形成"></a>Image Formation 图像形成</h2><p><strong>现在，我们假设光被表面漫反射的结果形成了图像。在本章的后面，我们放宽了这个限制，直接描绘光源和高光。亮度Lv 每个像素的近似值为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023112151.png" class="" title="image-20211023112151">

<p><strong>其中，r为曲面的反射率，Ev 为曲面的反射率表示照度。下标v表示我们用的是光度加权的量。或者，我们可以在对数域中写出这个表达式(Oppenheim et al.， 1968):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023112201.png" class="" title="image-20211023112201">

<p><strong>照相透明度是通过改变材料的密度来记录图像的。在传统摄影中，这种变化与亮度成对数关系。因此，与摄影中的常见做法类似，我们将使用术语密度表示(D)来表示对数亮度。当在对数域中表示时，反射率和照度是相加的。这有助于分离这两个组成部分，尽管事实上分离反射率或照度是一个不足约束的问题。在实践中，分离只在一定程度上是可能的，并取决于图像的组成。然而，色调再现可以基于图像形成的这两个组成部分的分离，如下两部分所示。</strong></p>
<h2 id="Frequency-Based-Operators-基于频率的算子"><a href="#Frequency-Based-Operators-基于频率的算子" class="headerlink" title="Frequency-Based Operators 基于频率的算子"></a>Frequency-Based Operators 基于频率的算子</h2><p><strong>对于典型的漫反射场景，由于纹理表面以及表面边缘的存在，反射分量往往表现出高空间频率。另一方面，照度在空间上是一个缓慢变化的函数。</strong></p>
<p><strong>由于反射率是低动态范围，照度是高动态范围，我们可以尝试将这两个分量分开。反射率和照度的频率依赖性提供了一个解决方案。例如，我们可以计算图像的傅里叶变换，只衰减低频。这压缩了照度分量，而保留了反射分量基本不受影响——我们所知的第一个数字音色再现操作员采用了这种方法(Oppenheim et al.， 1968)。</strong></p>
<p><strong>最近，其他算子也遵循了这一思路。特别地，双边和三边滤波器被用来将图像分割为基础和细节层(Durand &amp; Dorsey, 2002;Choudhury &amp; Tumblin, 2003)。这两个滤波器都是边缘保持平滑算子，可用于各种不同的方式。将边缘保持平滑算子应用到密度图像会得到模糊图像，其中锐利的边缘仍然存在(下图(左))。我们可以把这样一个图像看作一个基础层。如果我们将高动态范围图像按像素划分为基础层，我们得到一个包含所有高频细节的细节层(下图(右))。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023121555.png" class="" title="image-20211023121555">

<p>双边滤波消除了小细节，但保留了尖锐的梯度(左)。相关的细节层显示在右边。</p>
<p><strong>对于漫反射场景，基础和细节层类似于照度和反射率的表示。对于描绘高光和光源的图像，这种类比是站不住脚的。然而，无论图像的内容如何，将图像分离为基础层和细节层都是可能的。在重新组合为压缩密度图像之前，通过压缩基础层，可以创建低动态范围密度图像(下图)。取幂后，得到一个可显示的图像。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023121614.png" class="" title="image-20211023121614">

<p>一种使用双边滤波进行映射的图像。如上上图所示的基础层和细节层在压缩基础层后被重新组合。</p>
<p><strong>边缘保持平滑算子也可用来计算每个像素的局部自适应水平可用于空间变化或局部色调再现算子。我们在第21.7节中描述了双边和三边过滤器的使用。</strong></p>
<h2 id="Gradient-Domain-Operators-梯度域算子"><a href="#Gradient-Domain-Operators-梯度域算子" class="headerlink" title="Gradient-Domain Operators 梯度域算子"></a>Gradient-Domain Operators 梯度域算子</h2><p><strong>上一节对基于频率的算子所作的论证也适用于梯度场。假设没有直接可见的光源，在梯度场中反射分量将是一个具有尖峰的常数函数。类似地，照明组件将导致小梯度到处。</strong></p>
<p><strong>在典型场景中，人类通常能够区分光照和反射。扣除光源后对表面反射率的感知称为亮度。为了评估只描绘漫反射表面的图像的亮度，B. K. P. Horn是第一个使用梯度场分离反射和照度的人(Horn, 1974)。他使用简单的阈值去除所有小的梯度，然后集成图像，这涉及使用全多重网格法求解泊松方程(Press, Teukolsky, Vetterling， &amp; Flannery, 1992)。</strong></p>
<p><strong>其结果类似于边缘保持平滑滤波器。这与预期相符，因为Oppenheim的基于频率的算子在相同的场景反射率和图像形成假设下工作。特别是，霍恩的作品直接针对“蒙德里安的迷你世界”，这是类似于荷兰著名画家皮埃·蒙德里安的抽象派绘画的漫射场景的简化版本。</strong></p>
<p><strong>Horn的作品不能直接用作色调再现算子，因为大多数高动态范围图像描述的是光源。然而，一个相对较小的变化将使这个工作成为一个合适的色调复制运算符。如果光源或镜面在图像中被描述，那么大的梯度将与光源和高光的边缘相关联。这使得图像具有较高的动态范围。下图显示了一个例子，其中斯诺克球上的高亮部分导致了明显的梯度。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122004.png" class="" title="image-20211023122004">

<p>左边的图像(使用梯度域压缩映射)显示了一个高亮的场景。这些高亮显示为右侧的大梯度，其中梯度的大小映射为灰度(黑色是0的梯度，白色是图像中的最大梯度)。</p>
<p><strong>因此，我们可以压缩高动态范围的图像通过衰减大梯度，而不是阈值梯度场。Fattal等人采用了这种方法，他们发现通过积分压缩梯度场可以成功地压缩高动态范围图像(下图)(Fattal等人，2002)。Fat- tal的梯度域压缩并不局限于扩散场景。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122101.png" class="" title="image-20211023122101">

<p>使用梯度域压缩映射的图像。</p>
<h2 id="Spatial-Operators-空间算子"><a href="#Spatial-Operators-空间算子" class="headerlink" title="Spatial Operators 空间算子"></a>Spatial Operators 空间算子</h2><p><strong>在下面的部分中，我们将讨论色调再现运算符，它直接对像素进行压缩而不向其他域进行转换。通常，全球和本地运营商是不同的。前一类中的色调再现算子根据每个像素相同的压缩函数来改变每个像素的亮度值。术语global源于这样一个事实:许多这样的函数需要被锚定到通过分析整个图像确定的一些值上。在实践中，大多数运算符使用几何平均L¯v 为了控制压缩:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122238.png" class="" title="image-20211023122238">

<p><strong>在上式中，引入了一个小的常数δ，以防止在黑色像素存在时平均值变为零。几何平均值通常被映射到一个预定义的显示值。将几何平均值映射到不同显示值的效果如下图所示。或者，有时使用最小或最大图像亮度。全局算符的设计面临的主要挑战在于压缩函数的选择。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122323.png" class="" title="image-20211023122323">

<p>将几何平均值映射到不同的显示值(左:0.12，右:0.38)后应用空间音调映射算子。</p>
<p><strong>另一方面，局部算子根据一个特定的压缩函数来压缩每个像素，这个压缩函数是由相邻像素的选择而不是整个图像的信息调制的。其基本原理是，明亮邻域中的亮像素可能与昏暗邻域中的亮像素被感知不同。本地运营商发展中的设计挑战包括选择压缩函数，每个像素的局部邻域的大小，以及使用局部像素值的方式。通常，本地操作符比全局操作符实现了更好的压缩(下图)，尽管计算成本更高。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122426.png" class="" title="image-20211023122426">

<p>每个图像的全局色调再现算子(左)和局部色调再现算子(右)(Reinhard, Stark, Shirley， &amp; Ferwerda, 2002)。本地操作符显示更多细节;例如，右边的金属徽章对比度更好，高光更清晰。</p>
<p><strong>无论是全球的还是本地的操作者都经常受到人类视觉系统的启发。大多数操作符使用两个不同的压缩函数之一，它与局部操作符和全局操作符的区别是正交的。显示值Ld(x, y)最常由图像亮度Lv(x, y)派生乘以以下两种形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211023122539.png" class="" title="image-20211023122539">

<p><strong>在这些方程中，f(x, y)可以是一个常数，也可以是每个像素变化的函数。在前一种情况下，我们有一个全局算子，而一个空间变化的函数f(x, y)得到一个局部算子。指数n通常是一个常数，对于特定的运算符是固定的。</strong></p>
<p><strong>上上公式用从完整图像或局部邻域得到的值除以每个像素的亮度。上方程在对数线性图上有一条S形曲线，因此称为S形曲线。这种功能形式与测量不同物种光感受器对闪光的电反应所获得的数据相吻合。在下面的小节中，我们将讨论这两种函数形式。</strong></p>
<h2 id="Division-分部"><a href="#Division-分部" class="headerlink" title="Division 分部"></a>Division 分部</h2><p><strong>每个像素可以除以一个常数，使高动态范围的图像在一个可显示范围内。这种划分实质上是线性缩放，如图21.3所示。虽然图21.3显示了特设线性标度，但这种方法可以通过使用心理物理数据来提炼(21.2)式中的标度常数f(x, y) = k (G. J. Ward, 1994;Ferwerda, Pattanaik, Shirley， &amp; Greenberg, 1996)。</strong></p>
<p><strong>另外，有几种方法可以计算空间变化的除数。在这些情况下，f(x, y)是图像的模糊版本，即 f(x, y) = Lv^blur (x, y)。模糊是通过将图像与高斯滤波器卷积来实现的(Chiu et al.， 1993;Rahman, Jobson， &amp; Woodell, 1996)。此外，通过模糊图像来计算f(x, y)可能与白点的偏移相结合，以达到彩色外观建模的目的(Fairchild &amp; Johnson, 2002;通用·约翰逊&amp;费尔柴尔德，2003年;Fairchild &amp; Johnson, 2004)。</strong></p>
<p><strong>高斯滤波器的大小和权重对结果的可显示图像有深刻的影响。高斯滤波器具有选择加权局部平均的效果。色调再现就是将每个像素除以其相关的加权局部平均值。如果过滤器内核的大小被选择得太小，那么光环工件就会出现(下图(左))。光晕是本地运算符的一个常见问题，当色调映射依赖于除法时尤其明显。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024155700.png" class="" title="image-20211024155700">

<p>图像被高斯模糊版本划分映射。左边图像的滤波核大小为64像素，右边图像的滤波核大小为512像素。对于基于分割的算法，通过选择大的滤波核来最小化光晕伪影。</p>
<p><strong>通常，在这种方法中，通过使滤波器内核变大(上图(右))，晕轮工件可以最小化。通过选择至少为图像四分之一的滤波器大小，可以获得合理的结果。有时甚至需要更大的过滤器内核来最小化人为因素。注意，在这个限制下，滤镜的大小会和图像本身一样大。在这种情况下，本地操作符变成了全局操作符，而通常由本地方法提供的额外压缩就会丢失。</strong></p>
<p><strong>在相同的空间位置上，每个像素被一个高斯模糊像素分割的函数形式需要在压缩量和伪像严重程度之间进行不理想的权衡。</strong></p>
<h2 id="Sigmoids-Sigmoids-函数"><a href="#Sigmoids-Sigmoids-函数" class="headerlink" title="Sigmoids Sigmoids 函数"></a>Sigmoids Sigmoids 函数</h2><p><strong>方程(21.3)采用了与简单除法不同的函数形式，因此，在压缩量、工件的存在和计算速度之间提供了不同的权衡。</strong></p>
<p><strong>Sigmoids有几个可取的性质。对于非常小的亮度值，映射是近似线性的，因此对比度保留在图像的黑暗区域。函数的渐近线是1，这意味着输出映射总是在0和1之间有界。</strong></p>
<p><strong>在式(21.3)中，函数f(x, y)可以作为全局常数计算，也可以作为空间变化函数计算。按照电生理学的惯例，我们把f(x, y)称为半饱和常数。它的值决定了输入图像中哪些值在色调映射后是最优可见的。特别地，如果我们假设指数n等于1，那么亮度值等于半饱和常数将被映射为0.5。选择不同半饱和常数的效果如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024160854.png" class="" title="image-20211024160854">

<p>半饱和常数的选择决定了输入值的映射方式显示值。</p>
<p><strong>函数f(x, y)可以用几种不同的方法计算(Reinhard et al.， 2005)。最简单的形式是，f(x, y)设为L¯v/k，从而将几何平均映射到用户参数k(下图)(Reinhard et al.， 2002)。在这种情况下，k的初始值是0.18，尽管对于特别明亮或黑暗的场景，这个值可能会升高或降低。它的价值可以从图像本身估计(Reinhard, 2003)。式(21.3)中的指数n可设为1。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161025.png" class="" title="image-20211024161025">

<p>一个线性缩放的图像(左)和一个使用s形压缩映射的图像(右)。</p>
<p><strong>在这种方法中，半饱和常数是几何平均的函数，因此算子是全局的。这个全局算子的一个变体通过线性插值来计算半饱和常数几何平均和每个像素的亮度:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161102.png" class="" title="image-20211024161102">

<p><strong>插值由用户参数a控制，该参数可以改变可显示图像的对比度(下图)(Reinhard &amp; Devlin, 2005)。对比度越大，在明暗区域的可见细节就越少，反之亦然。这种插值可以被看作是完全全局和完全局部运算符之间的中间地带，它在两个极端之间进行插值，而不需要使用昂贵的模糊运算。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161138.png" class="" title="image-20211024161138">

<p>线性插值改变了色调映射图像的对比度。参数a在左边的图像中设置为0.0，在右边的图像中设置为1.0。</p>
<p><strong>虽然操作符通常压缩亮度值，但这个特殊的操作符可以扩展到包括一种简单形式的色适应。因此，它提供了一个机会来调整通常与色调映射相关的饱和度水平，正如本章开始所讨论的。</strong></p>
<p><strong>不是只压缩亮度通道，而是对三个颜色通道中的每一个应用sigmoidal压缩:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161242.png" class="" title="image-20211024161242">

<p><strong>对f(x, y)的计算进行了改进，可以在几何平均亮度和像素亮度之间以及每个独立颜色通道和像素亮度值之间进行双线性插值。因此我们计算几何平均亮度值L¯v，以及红、绿、蓝通道的几何平均值(I¯r,I¯g,I¯b)．从这些值，我们分别为每个像素和每个颜色通道计算f(x, y)。我们给出这个方程为红色通道(fr(x, y)):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161416.png" class="" title="image-20211024161416">

<p><strong>插值参数a和之前一样控制对比度，新的插值参数c允许一种简单的颜色校正(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161502.png" class="" title="image-20211024161502">

<p>用于颜色校正的线性插值。参数c在左边的图像中设置为0.0，在右边的图像中设置为1.0。</p>
<p><strong>到目前为止，我们还没有讨论(21.3)式中指数n的值。电生理学研究报告了n = 0.2和n = 0.9之间的值(Hood, Finkelstein， &amp; Buckingham, 1979)。虽然指数可以由用户指定，但对于各种各样的图像，我们可以从几何平均亮度L¯v估计一个合理的值和图像中的最小和最大亮度(Lmin 和Lmax)，其经验公式如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161729.png" class="" title="image-20211024161729">

<p><strong>到目前为止所展示的几种s形压缩的变体本质上都是全局的。其优点是计算速度快，非常适用于中、高动态范围的图像。对于非常高的动态范围图像，可能需要求助于局部运算符，因为这可能会带来一些额外的压缩。一种扩展s形压缩的直接方法是用一个空间变化的函数代替全局半饱和常数，这个函数可以用几种不同的方法计算。</strong></p>
<p><strong>换句话说，函数f(x, y)到目前为止被假定为常数，但也可以作为一个空间局部平均值来计算。也许实现这一点最简单的方法是再次使用高斯模糊图像。每个像素的模糊图像代表局部平均值，可以将其视为半饱和常数的合适选择。</strong></p>
<p><strong>与前一节讨论的基于除法的操作符一样，我们必须考虑晕轮工件。然而，当图像被自身的高斯模糊版本所分割时，高斯滤波器核的大小需要很大，以最小化晕。如果sigmoids与空间变量半饱和常数一起使用，则高斯滤波器核需要变得很小，以最小化伪影。这是一个显著的改进，因为少量的高斯模糊可以直接在空间域有效地计算。换句话说，没有必要求助于昂贵的傅里叶变换。在实际应用中，只有几个像素宽的滤波核足以抑制明显的伪影，同时在被映射的图像中产生更多的局部对比度。</strong></p>
<p><strong>高斯模糊的一个潜在问题是，滤镜模糊了尖锐的对比度边缘，就像它模糊了小细节一样。在实践中，如果有在嘶鸣中是否有很大的反差梯度考虑的像素的邻域，这导致高斯模糊像素与像素本身有显著的不同。这就是晕的直接原因。通过在基于分割的方法中使用一个非常大的滤波核，这样大的对比度被平均出来。</strong></p>
<p><strong>在sigmoids压缩格式中，一个小的高斯滤波器最大限度地减少重叠的机会与强烈的反差梯度。在这种情况下，光晕仍然会出现，但它们的大小通常不被注意，反而被认为是增强对比。</strong></p>
<p><strong>另一种模糊图像的方法是，在尽量减少附近大对比度步骤的负面影响的同时，避免模糊这些边缘。一种简单但计算代价昂贵的方法是，计算一个具有不同核大小的高斯模糊图像堆栈。对于每个像素，我们可以选择最大的高斯函数，它不会与显著的梯度重叠。</strong></p>
<p><strong>在一个相对均匀的邻域中，高斯模糊像素的值应该是相同的，而不管滤波器核的大小。因此，用两种不同高斯滤波器过滤的像素之间的差值应该近似为零。只有当更宽的过滤器内核重叠时，这种差异才会发生显著变化与邻域包含一个强烈的对比步长，而较小的滤波器核没有。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161855.png" class="" title="image-20211024161855">

<p>用于演示下图所示的比例选择机制的示例图像。</p>
<p><strong>因此，通过检查不同核大小下高斯函数的差异，可以找到一个像素周围不包含尖锐边缘的最大邻域。对于上图所示的图像，每个像素选择的比例如下图(左)所示。这种尺度选择机制被摄影色调复制算子(Reinhard et al.， 2002)以及Ashikhmin的算子(Ashikhmin, 2002)所采用。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024161906.png" class="" title="image-20211024161906">

<p>比例选择机制:左图为上图所示图像中每个像素所选择的比例;像素越深，刻度越小。总共使用了8种不同的尺度来计算这幅图像。右图显示的是基于邻域选择机制计算出的每个像素的局部平均值。</p>
<p><strong>一旦已知每个像素的合适邻域，高斯模糊平均Lblur 对于这个邻域(如上图右侧所示)，可以用来控制半饱和常数，例如摄影色调复制操作符所使用的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024162022.png" class="" title="image-20211024162022">

<p><strong>另一种可能更好的方法是使用边缘保持平滑算子，这种算子是专门设计用来去除小细节，同时保持鲜明的对比。一些这样的滤波器，如双边滤波器(下图)，三边滤波器，苏珊滤波器，LCIS算法和均值移位算法是合适的，尽管其中一些是昂贵的计算(Durand &amp; Dorsey, 2002;Choudhury &amp; Tumblin, 2003;Pattanaik &amp; Yee, 2002;Tumblin &amp; Turk, 1999;Comaniciu &amp; Meer, 2002)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024162100.png" class="" title="image-20211024162100">

<p>sigmoidal压缩(左)和使用双边滤波计算半饱和常数的s形压缩(右)。注意右图中天空对比度的改善。</p>
<h2 id="Other-Approaches-其他方法"><a href="#Other-Approaches-其他方法" class="headerlink" title="Other Approaches 其他方法"></a>Other Approaches 其他方法</h2><p><strong>虽然前面几节一起讨论了迄今为止的大多数色调再现操作符，但仍有一两个操作符不能直接适用于上述类型血淋淋的。其中最简单的一种是对数压缩的变体，另一种是基于直方图的方法。</strong></p>
<p><strong>动态范围缩小可以通过取对数来实现，只要这个数字大于1。任何正数都可以用下面的方程在0和1之间进行非线性缩放:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184342.png" class="" title="image-20211024184342">

<p><strong>虽然上面的对数以b为底没有指定，但任何选择的底都可以。选择对数底数的自由可以用来根据输入亮度改变底数，从而实现与被压缩图像更好匹配的运算符(Drago, Myszkowski, Annen， &amp; Chiba, 2003)。该方法采用Perlin和Hoffert的偏置函数，取用户参数p (Perlin &amp; Hoffert, 1989):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184430.png" class="" title="image-20211024184430">

<p><strong>使基数b依赖于亮度，并在2和10之间平滑地插值基数，可以细化上面的对数映射:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184507.png" class="" title="image-20211024184507">

<p><strong>对于用户参数p，初始值约为0.85往往会产生可信的结果(下图(右))。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184547.png" class="" title="image-20211024184547">

<p>使用底数为10的对数的对数压缩(左)和不同底数的对数压缩(右)。</p>
<p><strong>或者，色调再现可以基于直方图均衡化。传统的直方图均衡化的目的是使每个亮度值在输出图像中出现的概率相等。Greg Ward以保留对比的方式改进了这个方法(Ward Larson, Rushmeier， &amp; Piatko, 1997)。</strong></p>
<p><strong>首先，根据高动态范围图像的亮度计算直方图。从这个直方图中，可以计算出一个累积直方图，这样每个箱子都包含亮度值小于或等于箱子所代表的亮度值的像素数。累积直方图是一个单调递增的函数。因此，将每个箱中的值与每个箱所代表的亮度值绘制成一个函数，该函数可被视为亮度映射函数。缩放这个功能，使垂直轴跨越显示设备的范围，产生一个色调再现操作符。这种技术称为直方图均衡化。</strong></p>
<p><strong>沃德进一步完善了这个方法，确保这个函数的梯度永远不超过1。这意味着，如果累积直方图中相邻值之间的差值太大，则此差值固定为1。这避免了输入亮度的微小变化可能导致输出图像的巨大差异的问题。换句话说，通过将累积直方图的梯度限制为1，对比度永远不会被夸大。得到的算法称为直方图调整(见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024184739.png" class="" title="image-20211024184739">

<p>线性缩放图像(左)和直方图调整图像(右)。图片由佛罗里达州冬季公园的Albin Polasek博物馆许可制作。</p>
<h2 id="Night-Tonemapping-夜间色调映射"><a href="#Night-Tonemapping-夜间色调映射" class="headerlink" title="Night Tonemapping 夜间色调映射"></a>Night Tonemapping 夜间色调映射</h2><p><strong>到目前为止所讨论的色调再现算子几乎都假设图像代表了在光视条件下的场景，即就像在正常光线下看到的那样。对于暗点场景，即在非常黑暗的场景中，人类的视觉系统表现出截然不同的行为。特别是感知对比度较低，视觉敏锐度(即视力)较低。这是我们能分辨的最小细节)的颜色较低，所有的东西都有轻微的蓝色外观。</strong></p>
<p><strong>为了使这些图像能够在放置在光照明条件下的监视器上正确地观看，我们可以对图像进行预处理，使其看起来像是我们适应了一个非常黑暗的观看环境。这种预处理通常采取亮度和对比度降低、图像饱和度降低、蓝移和视觉灵敏度降低的形式(Thompson, Shirley， &amp; Ferwerda, 2002)。</strong></p>
<p><strong>一种典型的方法是将图像从RGB转换为XYZ。然后计算每个像素的暗亮度V:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024185016.png" class="" title="image-20211024185016">

<p><strong>这个单一通道的图像然后可以缩放和乘以经验选择的蓝灰色。下图显示了一个示例。如果一些像素在感光范围内通过将蓝灰色图像与输入图像线性混合，可以生成夜间图像。每个像素使用的分数取决于V。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024185058.png" class="" title="image-20211024185058">

<p>使用如图21.12所示的图像模拟夜景。</p>
<p><strong>视觉灵敏度的损失可能是通过对夜间图像的低通滤波来模拟的，尽管这可能会给人一种不正确的模糊感。一种较好的方法是采用双边滤波方法在模糊小细节的同时保留锐利的边缘(Tomasi &amp; Manduchi, 1998)。</strong></p>
<p><strong>最后，在第21.3节中概述的颜色转移技术也可以用来将白天的图像转换为夜景。这种方法的有效性取决于是否有合适的夜间图像来转换颜色。例如，将图21.12中的图像转换为下图中的夜景图像。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211024185211.png" class="" title="image-20211024185211">

<p>左边的图像是用来将图21.12的图像转换成夜景的，如图所示。</p>
<h2 id="Discussion-讨论"><a href="#Discussion-讨论" class="headerlink" title="Discussion 讨论"></a>Discussion 讨论</h2><p><strong>由于全局光照算法自然会产生高动态范围的图像，直接显示生成的图像是不可能的。不应采用线性缩放或夹紧，而应使用色调复制运算符。任何色调复制操作都比不使用色调复制好。根据应用程序的要求，几个操作符中的一个可能是合适的。</strong></p>
<p><strong>例如，实时呈现应用程序可能应该采用简单的sigmoidal压缩，因为它们的速度足够快，也可以实时运行。此外，它们的视觉质量通常也足够好。直方图调整技术(Ward Larson et al.， 1997)对于实时操作也可能足够快。</strong></p>
<p><strong>对于包含非常高动态范围的场景，使用局部操作符可以实现更好的压缩。然而，计算成本通常要高得多，这使得这些操作符只适合于非交互应用程序。由于该技术所提供的优化，最快的本地运算符是双边过滤器(Durand &amp; Dorsey, 2002)。</strong></p>
<p><strong>这个过滤器本身是一个有趣的色调复制运算符，或者它可以用来计算一个本地适应级别，以用于sigmoidal压缩函数。在任何一种情况下，过滤器都会考虑强烈的对比变化，并平滑较小的对比。这是一个重要的特性，可以帮助最小化光晕工件，这是本地操作符的一个常见问题。</strong></p>
<p><strong>另一种最小化光晕伪影的方法是在照相色调复制算子中使用的比例选择机制(Reinhard等人，2002)，尽管这种技术计算速度较慢。</strong></p>
<p><strong>总之，虽然目前有大量的音调复制操作符可用，但只有少量不同的方法存在。傅里叶域算子和梯度域算子都是基于形象的形成。空间域算子在本质上要么是空间变体(局部)，要么是全局。这些操作通常基于对人类视觉系统(以及许多其他物种的视觉系统)的研究。</strong></p>
<h1 id="22-Implicit-Modeling-隐式模型"><a href="#22-Implicit-Modeling-隐式模型" class="headerlink" title="22 Implicit Modeling 隐式模型"></a>22 Implicit Modeling 隐式模型</h1><p><strong>计算机图形学中的隐式建模(也称为隐式曲面)涉及许多不同的模型定义方法。这些包括骨架隐式建模、偏移曲面、水平集、变分曲面和代数曲面。在本章中，我们将简要介绍这些方法，并详细描述如何构建骨骼隐式模型。曲线可以用这种形式的隐式方程来定义</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025115817.png" class="" title="image-20211025115817">

<p><strong>如果考虑半径为r的封闭曲线，如圆，隐式方程为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025115914.png" class="" title="image-20211025115914">

<p><strong>f(x, y)的值可以是正的(在圆外)，负的(在圆内)，或者对于圆上的精确点是零。在三维空间中，等效的是一个围绕着一组占据给定体积或空间区域的点的封闭曲面。体积形成一个标量场，即我们可以为每个点计算一个值，可以看到，对于圆，负的值是由隐式曲线或曲面限定的。该曲面可以看作是场中的一条等值线，其连接点具有特定的值(如0)(见上式)。为了计算这样一个曲面，需要在空间中搜索以找到满足隐式方程的点;这种方法不太可能成为绘制圆的有效算法(在三维空间中更不可能)。这也许就是用参数曲线建模的算法方法的原因隐式方法前对曲面进行了研究;然而，开发隐式曲面的可视化算法有一些很好的理由。在本章中，我们将探讨从建模过程而不是从扫描仪中获取数据的含义。</strong></p>
<p><strong>尽管寻找隐式曲面的计算开销很大，但使用隐式建模技术进行设计比其他建模方法有一些优势。许多几何运算是用隐式方法简化的，包括:</strong></p>
<p>​    <strong>•混合物的定义;</strong> </p>
<p>​    <strong>•构造立体几何(CSG)的标准集运算(并、交、差等);</strong> </p>
<p>​    <strong>•与其他隐函数的函数组合(如R -函数、Barthe共混、Ricci共混和翘曲);</strong> </p>
<p>​    <strong>•内部/外部测试(例如，用于碰撞检测)。</strong></p>
<p><strong>可视化的表面可以通过使用算法直接射线追踪完成(Kalra &amp; Barr, 1989;米切尔,1990;哈特与贝克，1996年;deGroot &amp; Wyvill, 2005)或首先转换为多边形(Wyvill, McPheeters， &amp; Wyvill, 1986)。</strong></p>
<p><strong>最早的方法之一是里奇早在1973年就提出的(里奇，1973)，他也在同一篇论文中介绍了CSG。Jim Blinn在电子密度场中寻找轮廓的算法，称为Blobby分子(J. Blinn, 1982)， Nishimura的Metaballs (Nishimura et al.， 1985)和Wyvills的软物体(Wyvill et al.， 1986)都是隐式建模方法的早期例子。Jim Blinn的Blobby Man(见下图)是第一个非代数隐式模型的渲染。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025120206.png" class="" title="image-20211025120206">

<p>Blinn’s Blobby Man 1980。由吉姆模拟金属。</p>
<h2 id="Implicit-Functions-Skeletal-Primitives-and-Summation-Blending-隐式函数、基本骨架和混合求和"><a href="#Implicit-Functions-Skeletal-Primitives-and-Summation-Blending-隐式函数、基本骨架和混合求和" class="headerlink" title="Implicit Functions, Skeletal Primitives, and Summation Blending 隐式函数、基本骨架和混合求和"></a>Implicit Functions, Skeletal Primitives, and Summation Blending 隐式函数、基本骨架和混合求和</h2><p><strong>在建模的背景下，隐函数f 被定义为作用于点p∈E³的函数得到一个标量值∈R。</strong></p>
<p><strong>隐函数fi(x, y, z)可以分解为距离函数di(x, y, z)和衰减滤波函数gi(r)，其中r表示到骨架的距离，下标表示第i个骨架元素。</strong></p>
<p><strong>我们将使用以下符号:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124042.png" class="" title="image-20211025124042">

<p><strong>一个简单的例子是一个原始的点，我们用一个恒星向太空辐射热量的类比。场值(本例中的温度)可以在任意点p上测量，可以通过取p到恒星中心的距离，并将该值提供给一个类似于下图中给出的滤波函数来找到。在这些样本函数中，场在星的中心处的值为1;这个值随着距离的增大而减小。模型的曲面可以由隐函数f(x, y, z)导出为空间中的点，这些点的值等于某个期望的等值(iso);在星形的例子中，一个用于表示iso∈(0,1)值的球壳。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124144.png" class="" title="image-20211025124144">

<p>降低滤波函数 (0 ≤ r ≤ 1).(a)布林高斯函数或“Blobby”函数;(b)西村的“Metaball”功能;(c) Wyvill等人的“软对象”函数;(d) Wyvill函数。</p>
<p><strong>一般来说，过滤器函数(gi)，以便在骨架上的场值是最大的，并在一些选择的距离下降到零骨架。在得到的曲面混合在一起的简单情况下，一个物体的全局场f(x, y, z)，隐函数，可以定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124337.png" class="" title="image-20211025124337">

<p><strong>其中n个骨架元素贡献了得到的字段值。下图给出了一个例子，其中任意点(x, y, z)的场计算如上式所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124427.png" class="" title="image-20211025124427">

<p>每一列显示两个相互接近的点原语。从左到右:使用的衰减过滤器函数是Blobby, Metaball, soft objects，和Wyvill。图片由Erwin DeGroot提供。</p>
<p><strong>在本例中，两个点原语被放置在非常接近的位置。当两个点放在一起时，表面会凸出然后融合在一起。使用术语过滤函数是因为该函数使原语在一起模糊，有点类似于图像的过滤函数。求和混合是可以应用于隐式曲面的最紧凑、最有效的混合运算(见上公式)。</strong></p>
<p><strong>使用支持有限的过滤函数的一个优点是，远离p的原语贡献为零，因此不需要考虑(Wyvill et al.， 1986)。</strong></p>
<h3 id="C¹-Continuity-and-the-Gradient-C¹连续性和梯度"><a href="#C¹-Continuity-and-the-Gradient-C¹连续性和梯度" class="headerlink" title="C¹ Continuity and the Gradient  C¹连续性和梯度"></a>C¹ Continuity and the Gradient  C¹连续性和梯度</h3><p><strong>连续性最基本的形式是C⁰ 连续性，确保函数中没有“跳转”。高阶连续性定义为函数的导数(见第15章)。</strong></p>
<p><strong>在三维标量场f的情况下，一阶导数是一个向量函数，称为梯度，写∇f并定义为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025124656.png" class="" title="image-20211025124656">

<p><strong>如果:f在所有点都定义，三个一维偏导数分别为C⁰，那么f 是 C¹．非正式地,C¹ 表面连续性意味着表面法线在表面上平滑变化。曲面法向量是垂直于曲面的单位向量。例如，如果一个立方体的边缘上没有唯一的曲面法线，那么这个曲面就不是C¹．对于隐式曲面上的点，曲面法线可以通过归一化梯度向量∇f来计算。在这个圆的例子中，里面的点有一个负值，外面的点有一个正值。对于许多类型的隐式曲面，内部和外部的感觉是颠倒的，并且由于法向量必须总是指向外，它可以与梯度方向相反。</strong></p>
<p><strong>框架隐式原语是通过对无符号距离字段应用衰减滤波函数来创建的，如公式(22.2)所示。虽然距离场不是C¹ 在骨架上，这些不连续可以通过使用合适的衰减函数来去除(Akleman &amp; Chen, 1999)。如果一个算子g组合隐函数f₁ 和f₂，所有点都是C¹,那么g (f1,f2)不一定需要C¹．例如，可以使用最小和最大运算符来制作尖锐的CSG结。组合不是C¹ 因为min和max运算符没有这个属性(参见第22.5节)。</strong></p>
<p><strong>操作符的分析是复杂的，因为有时需要创建一个C¹ 不连续。只要表面需要有折痕，就会出现这种情况。例如，立方体不是C¹ 因为每条边都有切线不连续。使用C¹来创建折痕原语，则操作符必须引入C¹ 不连续性，因此不可能是C¹ 本身。</strong></p>
<h3 id="Distance-Fields-R-Functions-and-F-Reps-距离字段、R-函数和F-Reps"><a href="#Distance-Fields-R-Functions-and-F-Reps-距离字段、R-函数和F-Reps" class="headerlink" title="Distance Fields, R-Functions, and F-Reps 距离字段、R-函数和F-Reps"></a>Distance Fields, R-Functions, and F-Reps 距离字段、R-函数和F-Reps</h3><p><strong>距离场是关于某几何物体T定义的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025125320.png" class="" title="image-20211025125320">

<p><strong>直观上，F(T, p)是p到T的最短距离。因此，当p在T上时，F(T, p) = 0，隐式函数创建的曲面是对象T。在T之外，返回一个非零距离。函数T可以是嵌入在3d中的任何几何实体——点、曲线、曲面或实体。距离场的过程建模始于Ricci (Ricci, 1973);R -函数(Rvachev, 1963)在20多年后首次应用于形状建模(见(Shapiro, 1994)和(A. Pasko, Adzhiev, Sourin， &amp; Savchenko, 1995))。</strong></p>
<p><strong>R函数或Rvachev函数的符号可以改变当且仅当其中一个参数的符号改变;也就是说，它的符号完全由它的参数决定。R函数为实函数的布尔组合提供了一个健壮的理论框架，允许构造Cn CSG操作员(Shapiro, 1988)。这些CSG运算符可以用来创建混合运算符，只需在结果中添加一个固定偏移量(a . Pasko et al.， 1995)。虽然这些混合函数在技术上不再是R函数，但它们具有大多数理想的性质，可以与R函数自由混合，以创建复杂的层次模型(Shapiro, 1988)。这些基于R函数的混合和CSG操作符称为r操作符(参见第22.4节)。Hyperfun系统(Adzhiev et al.， 1999)基于F-reps(函数表示)，这是隐式曲面的另一种名称。该系统使用一种程序化的类C语言来描述许多类型的隐式曲面。</strong></p>
<h3 id="Level-Sets-水平集"><a href="#Level-Sets-水平集" class="headerlink" title="Level Sets 水平集"></a>Level Sets 水平集</h3><p><strong>通过规则网格(Barthe, Mora, Dodgson， &amp; Sabin, 2002)或自适应网格(Frisken, Perry, Rockwood， &amp; Jones, 2000)离散地表示隐式场是有用的。这正是多边形化算法在关卡集中所做的;此外，网格除了用于构建多边形外，还可以用于其他各种用途。f的离散表示通常是通过在正则区间对连续函数进行抽样得到的。例如，采样函数可以由其他体积模型表示定义(V. V. Savchenko, Pasko, Sourin， &amp; Kunii, 1998)。数据也可能是使用三维成像技术采集的实物。离散体积数据通常与水平集方法(Osher &amp; Sethian, 1988)结合使用，该方法定义了一种使用曲率相关的速度函数动态修改数据结构的方法。已经定义了基于水平集的交互建模环境(Museth, Breen, Whitaker， &amp; Barr, 2002)，尽管水平集只是采用隐式场的离散表示的一种方法。还探索了使用标准隐式曲面技术交互式定义离散表示的方法(Baerentzen &amp; Christensen, 2002)。</strong></p>
<p><strong>使用离散数据结构的一个关键优势是，它能够作为potential定义的所有不同体积模型的统一方法域(是否离散)(V. V. Savchenko et al.， 1998)。将任意连续函数转换为离散表示形式，引入了如何重建连续函数的问题，这是额外建模操作和结果势场可视化的组合目的所需要的。一个众所周知的解决这个问题的方法是使用卷积算子来应用一个滤波器g(见第9章)。滤波器的选择是根据重构的期望性质来指导的，并且已经探索了许多滤波器(Marschner &amp; Lobb, 1994)。其要点是，在所选滤波器的效率和所得到的重构的平滑性之间通常存在一个折衷;参见第22.9节。</strong></p>
<p><strong>为了实现交互性，离散系统必须限制网格的大小与可用计算能力的关系。这反过来又限制了建模器包含高频细节的能力。此外，平滑的三二次滤波器使它不可能包括尖锐的边缘，如果他们想要。这个问题的部分解决方案是使用自适应网格，尽管任何离散表示都有局限性。(Schmidt, Wyvill， &amp; Galin, 2005)使用离散网格作为表示BlobTree节点的缓存。该工作中的网格用于快速原型，并使用三线性插值的位置和较慢，更准确的三二次插值来计算梯度值，因为眼睛在观察梯度误差比位置误差更敏锐。</strong></p>
<h3 id="Variational-Implicit-Surfaces-变分隐式曲面"><a href="#Variational-Implicit-Surfaces-变分隐式曲面" class="headerlink" title="Variational Implicit Surfaces 变分隐式曲面"></a>Variational Implicit Surfaces 变分隐式曲面</h3><p><strong>通常需要将采样数据转换为隐式表示。变分隐式曲面利用全局支持基函数的加权和来插值或逼近一组点(V. Savchenko, Pasko, Okunev， &amp; Ku- nii, 1995;Turk &amp; O ‘Brien, 1999年;卡尔等人，2001年;Turk &amp; O ‘Brien, 2002)。这些径向对称基函数应用于每个样本点。这种曲面的连续性取决于基函数的选择。C² 最常用的是薄板样条(Turk &amp; O ‘Brien, 2002;卡尔等人，2001)。与Blinn的指数函数(见图22.2)一样，这个函数是无界的，得到的变分隐式曲面也是无界的。</strong></p>
<p><strong>如果场是全局的C²，则不能定义折痕;然而，各向异性基函数可以用来产生变化更快且可能出现折痕的场(Dinh, Slabaugh， &amp; Turk, 2001)。在适当的尺度下，表面仍然是光滑的。平滑场意味着自交点不会因此，卷总是定义明确的。薄板样条保证全局曲率最小(Duchon, 1977)。变分插值具有许多三维建模所需的特性;然而，控制产生的表面可能是困难的。</strong></p>
<p><strong>变分隐式曲面也可以基于紧凑支持径向基函数(CS-RBFs)，以减少变分插值技术的计算成本(Morse, Yoo, Rheingans, Chen， &amp; Subramanian, 2001)。每个CS-RBF只影响一个局部区域，因此计算f(p)只需要计算p的某个小邻域内的基函数。与全局支持的对应物一样，得到的场是C^k，不支持折痕，也不会发生自交。每个基函数的局部支持导致一个有界的全局域。正如许多研究人员所指出的那样，这也保证了其他等高线将会出现(Ohtake, Belyaev， &amp; Pasko, 2003;路透社,2003)。</strong></p>
<h3 id="Convolution-Surfaces-卷积表面"><a href="#Convolution-Surfaces-卷积表面" class="headerlink" title="Convolution Surfaces 卷积表面"></a>Convolution Surfaces 卷积表面</h3><p><strong>由Bloomenthal和Shoemake (Bloomenthal &amp; Shoemake, 1991)提出的卷积曲面是通过将几何骨架S与核函数h进行卷积得到的。因此，空间中任意位置的值由对骨架的积分来定义:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131353.png" class="" title="image-20211025131353">

<p><strong>任意有限支持函数都可以用h表示;参见(Sherstyuk, 1999)对不同内核的详细分析。</strong></p>
<p><strong>像骨架基元一样，卷积曲面也有有界域。Blinn的“斑点分子”是卷积曲面的最简单形式(J. Blinn, 1982);在这种情况下，骨架只由点组成。这个想法被Bloomenthal扩展到包括线、弧、三角形和多边形骨架(Bloomenthal &amp; Shoemake, 1991)。这些代表一维和二维原语;随后，Bloomenthal描述了3D原体(Bloomenthal, 1995)。</strong></p>
<p><strong>卷积曲面的组合是由底层几何骨架的组合来定义的，它的优点是消除了在使用添加剂混合组合多个骨架基元时容易出现的凸起。如下图所示，组合骨架的卷积得到的表面没有凸起，即使组合骨架-，场也是连续的吨是凸的。卷积曲面从骨架的凸部分偏移一个固定的距离，但沿骨架的凹部分产生一个圆角。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131425.png" class="" title="image-20211025131425">

<p>两个圆柱混合。左:加法混合;右图:褶积表面，几乎看不出凸起(Bloomenthal, 1997)。图片由Erwin DeGroot提供。</p>
<p><strong>下图显示了一个通过卷积构建复杂模型的骨架元素示例。手模型包含14个原语。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131435.png" class="" title="image-20211025131435">

<p>骨骼元素的卷积建立一个手模型。图片由Jules Bloomenthal提供。</p>
<h3 id="Defining-Skeletal-Primitives-定义骨架基元"><a href="#Defining-Skeletal-Primitives-定义骨架基元" class="headerlink" title="Defining Skeletal Primitives 定义骨架基元"></a>Defining Skeletal Primitives 定义骨架基元</h3><p><strong>正如我们将在下面的章节中看到的，渲染隐式模型需要找到大量点的场值和梯度。我们需要提供距离到方程(22.2)和梯度是有用的根寻找和照明计算。为图22.2中的下降过滤器函数提供距离是计算到骨架原语的最近距离的问题，对于点原语来说很简单，但对于更复杂的几何形状来说有点棘手。线段原语(AB)可以定义为围绕着带有半球形端盖的线的圆柱体(见下图)。点P0 位于f(P0) = iso和f(P1) = 0，因为它不在行原语的影响范围之内。到某个Pi 的距离简单地投影到直线AB上，并计算垂直距离，如|CP0*|;*这是可以发现的从AC，因为A, P0，和B，都是已知的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131854.png" class="" title="image-20211025131854">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025131904.png" class="" title="image-20211025131904">

<p>线ab，例子点p0,P1,p2表示距离计算。 </p>
<p><strong>在上图中，P的场值2 &gt; 0，因为P2 是在半球形端盖上，可以单独检查。这种想法的变体可以定义具有不同半径端点的原语，产生有趣的圆锥形状。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025132127.png" class="" title="image-20211025132127">

<p>圆柱体原语与球体的混合。</p>
<p><strong>各种各样的几何骨架已经被描述过了，而且，在原则上，它只是简单地定义从某一点p到骨架的距离以及在p点的梯度。例如，的偏移曲面可以定义一个三角形顶点的三角形和一个半径r。一个简单的方法来实现这个是使用线段原语来描述边界气缸连接顶点的距离(半径)。一个点在三角形内,不属于边界的线段返回原语的一个三角形的平面的垂直距离。其他的例子包括一个隐式磁盘,定义为一个圆和一个厚度参数,一个环面也定义为一个圆的半径和横截面(或内外圆半径),圆锥从一个磁盘和一个高度,一个立方体圆角等。(见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025132231.png" class="" title="image-20211025132231">

<p>隐式模型从各种骨骼原语。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211025132448.png" class="" title="image-20211025132448">

<p>光线追踪的恐龙模型显示隐式骨骼原语。</p>
<h2 id="Rendering-渲染"><a href="#Rendering-渲染" class="headerlink" title="Rendering 渲染"></a>Rendering 渲染</h2><p><strong>建模方法，如参数化曲面，有利于可视化，因为它很容易迭代曲面上的点，可以直接从定义方程中找到;例如(x, y) = (cos θ， sin θ)， θ∈[0,2 π]会产生一个圆。</strong></p>
<p><strong>有两种常用的技术来渲染隐式表面:光线追踪和表面平铺。在实践中，设计师希望快速可视化一个隐含的曲面模型，为了达到交互的目的而牺牲质量。原型算法一直关注于生成一个可以在现代工作站上实时渲染的多边形网格。找到最接近理想曲面的多边形网格称为多边形化或曲面平铺。对于动画或最终的可视化，质量优先于速度，光线追踪隐式表面直接不首先多边形产生优秀的结果。</strong></p>
<p><strong>如前所述，寻找隐曲面需要在空间中搜索，以找到满足f(p) = 0的点。执行这样的搜索有两种主要方法:空间分区——将空间分区到可管理的单位，如立方体，和非空间分区，如行军三角形(Hartmann, 1998;Akkouche &amp; Galin, 2001)和shrinkwrap算法(van Overveld &amp; Wyvill, 2004)。</strong></p>
<p><strong>在本章中，我们将描述原始的空间划分算法，并将其留给读者去探索更高级的方法。该算法与网格细化的后处理(见第12章)和缓存一起提供了一种在现代工作站上交互查看隐式模型的方法。</strong></p>
<h2 id="Space-Partitioning-空间分割"><a href="#Space-Partitioning-空间分割" class="headerlink" title="Space Partitioning 空间分割"></a>Space Partitioning 空间分割</h2><h3 id="Exhaustive-Search-穷举搜索"><a href="#Exhaustive-Search-穷举搜索" class="headerlink" title="Exhaustive Search 穷举搜索"></a>Exhaustive Search 穷举搜索</h3><p><strong>用于平铺隐式曲面的基本三次空间划分算法首次发表在(Wyvill et al.， 1986)和一个类似的面向体可视化的算法，称为行进立方体(Lorensen &amp; Cline, 1987)。从那时起，有许多改进和扩展。</strong></p>
<p><strong>寻找隐式曲面的第一个方法可能是将空间均匀地细分为三次单元格，并为每个顶点计算一个值。每个单元格被替换为一组多边形，这些多边形最接近包含在该单元格内的部分表面。这种方法的问题是，许多细胞将完全在体积的外部或内部;因此，许多不含表皮部分的细胞被加工。对于大型数据网格，这可能非常耗时和内存密集型。</strong></p>
<p><strong>为了避免存储整个网格，根据(Wyvill et al.， 1986)中使用的数据结构，使用哈希表只存储包含曲面的一部分的立方体。工作软件发表于Graphics Gems IV (Bloomenthal, 1990)。该算法基于数值延拓;它从一个种子立方体开始，种子立方体与部分表面相交，并根据需要构建相邻的立方体。</strong></p>
<p><strong>算法分为两部分。在第一部分中，立方体单元包含曲面，而在第二部分中，每个立方体都被三角形所取代。该算法的第一部分由一个立方体队列驱动，每个立方体队列包含曲面的一部分;算法的第二部分是表驱动的。</strong></p>
<h3 id="Algorithm-Description-算法描述"><a href="#Algorithm-Description-算法描述" class="headerlink" title="Algorithm Description 算法描述"></a>Algorithm Description 算法描述</h3><p><strong>算法的快速概述如下:</strong></p>
<p>​    <strong>•将空间划分为立方体体素;</strong> </p>
<p>​    <strong>•搜索表面，从一个骨架元素开始;</strong> </p>
<p>​    <strong>•添加体素到队列，标记它已访问;</strong> </p>
<p>​    <strong>•搜索邻居;</strong> </p>
<p>​    <strong>•当完成时，用多边形替换体素。</strong> </p>
<p><strong>首先，将空间细分为一个立方体晶格，接下来的任务是找到包含部分曲面的种子立方体。立方体顶点vi 在曲面内部有一个字段值vi &gt;= iso和曲面外的顶点将有一个字段值vi &lt; iso;因此，具有每种顶点的边将与曲面相交。我们称它为相交边。在离第一个原语最近的立方体顶点处的字段值可以根据公式(22.3)通过求和原语的贡献来计算，尽管也可以使用其他运算符，稍后将会看到。我们假设f(v0) &gt; iso，表示v₀ 在固体中。iso的值由用户选择;一个例子是iso = 0.5，当使用软下降函数，它有一些对称性的属性，导致良好的混合(见图22.3)。沿着一个轴的顶点依次计算，直到找到vi &lt; iso为止。含有相交边的立方体称为种子立方体。</strong></p>
<p><strong>检查种子立方体的邻居，并将至少包含一条相交边的种子立方体添加到等待处理的队列中。要处理一个立方体，我们要检查每个面。如果任何边界边有相反符号的顶点，曲面将通过该面，并且必须处理该面邻居。当这个过程完成了所有的面，算法的第二阶段是应用到立方体。如果曲面是封闭的，最终一个立方体将被重新访问，没有更多未标记的邻居被发现，搜索算法将终止。处理一个多维数据集包括将其标记为已处理的，并处理其未标记的邻居。对于包含相交边的图像，我们会对其进行处理，直到整个曲面被覆盖为止(见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026143933.png" class="" title="image-20211026143933">

<p>穿过立方晶格的截面。+符号表示曲面内部的顶点(f (vi≥iso)，而-位于f (vi &lt; iso)外部。</p>
<p><strong>每个立方体都由一个标识顶点索引，我们将其定义为左下角的远角(即。(x, y, z)坐标值最低的顶点(见下图)。对于表面内部的每个顶点，相应的位将被设置成8位表中的地址(参见下图和节22.3.3)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026144047.png" class="" title="image-20211026144047">

<p>顶点数字化。</p>
<p><strong>标识顶点是通过整数i, j, k来寻址的，这些整数是从立方体的(x, y, z)坐标位置计算出来的，x =side∗i，等等，其中面是立方体的大小。每个立方体的标识顶点可能会出现在多达8个其他立方体中，而重复存储这些顶点将是低效的。因此，顶点被唯一地存储在链散列表中。由于大部分空间不包含表面的任何部分，只有那些访问的立方体将被存储。当每个顶点存储在哈希表中时，隐式函数值会被找到。</strong></p>
<p><strong>由于对该表面的拓扑结构一无所知，所以搜索必须从每一个原语开始，以避免错过任何不相关的表面部分。标量可用于扩展原语的影响。如果标量可以小于零，那么可以沿着一个轴搜索而不找到一条相交边。在这种情况下，必须进行更复杂的搜索以找到种子立方体(Galin &amp; Akkouche, 1999)。</strong></p>
<h4 id="Data-Structures-数据结构"><a href="#Data-Structures-数据结构" class="headerlink" title="Data Structures 数据结构"></a>Data Structures 数据结构</h4><p><strong>哈希表项包含5个值:</strong></p>
<p>​    <strong>•标识顶点的i, j, k格指数(见上图);</strong></p>
<p>​    <strong>•f，标识顶点的隐函数值;</strong></p>
<p>​    <strong>•布尔值，用于指示该立方体是否已被访问。</strong><br><strong>哈希函数计算哈希表中的一个地址，方法是从i, j, k中选择一些位，并对它们进行算术组合。例如，五个最低有效位产生一个15位的表地址，它必须有一个长度2^15股。这样的哈希函数可以在C预处理器中实现，如下所示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026144410.png" class="" title="image-20211026144410">

<p><strong>队列(FIFO列表)被用作临时存储，用于标识邻居进行处理。算法从标记为已访问并放置在队列中的种子立方体开始。队列上的第一个多维数据集被退出队列，它所有未访问的邻居被添加到队列中。如果每个立方体包含部分曲面，则每个立方体都被处理并传递到算法的第二阶段。然后对队列进行处理，直到为空。</strong></p>
<h3 id="Polygonization-Algorithm-多边形化算法"><a href="#Polygonization-Algorithm-多边形化算法" class="headerlink" title="Polygonization Algorithm 多边形化算法"></a>Polygonization Algorithm 多边形化算法</h3><p><strong>算法的第二阶段是独立处理每个立方体。细胞被一组最符合通过细胞的部分表面形状的三角形所取代。该算法必须在给定每个顶点隐函数值的情况下决定如何将单元格多边形化。这些值可以是正的，也可以是负的。，小于或大于等值)，给出立方体的8个顶点的256个正或负顶点组合。包含256个条目的表提供了在每个三角形中使用的正确顶点(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026155317.png" class="" title="image-20211026155317">

<p>表2包含了曲面相交的边。表1指向表2中的适当条目。</p>
<p><strong>例如，条目4(00000100)指向第二个表，该表记录了约束相交边的顶点。在这个例子中,顶点2号内表面(f (V 2) &gt; = iso),因此,我们希望能画一个三角形连接相交的点表面边缘有界(V2,V0)、(V2,V3),(V2,V6)如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026155540.png" class="" title="image-20211026155540">

<p>求曲面和立方体边缘的相交。</p>
<h4 id="Finding-Cube-Surface-Intersections-找到立方体-曲面的相交"><a href="#Finding-Cube-Surface-Intersections-找到立方体-曲面的相交" class="headerlink" title="Finding Cube-Surface Intersections 找到立方体-曲面的相交"></a>Finding Cube-Surface Intersections 找到立方体-曲面的相交</h4><p><strong>上图显示了顶点为V₂的立方体是在表面内部，而其他所有顶点都在表面外部。如图所示，与曲面相交在三条边上。曲面与边V2 −V6 相交于A。最快但不准确的方法是使用线性插值:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160139.png" class="" title="image-20211026160139">

<p><strong>如果立方体边为1,f(A)的等值为0.5，则</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160214.png" class="" title="image-20211026160214">

<p><strong>这对于静态图像很有效，但在动画中帧之间的错误差异将非常明显。应采用常规法等寻根方法。这将增加计算成本，因为需要梯度来计算交点。渲染表面点也需要梯度。对于许多类型的原语，使用p附近的样本点来寻找数值近似更简单，如</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160246.png" class="" title="image-20211026160246">

<p><strong>经验发现Δ的合理值为0.01∗side，其中side是立方体边的长度。</strong></p>
<p><strong>对于制造一个网格，相对于一组独立的三角形，第二个哈希表可以维护所有相交边的列表。由于每个立方体边最多由四个邻居共享，边哈希表防止了面立方边相交计算的重复。哈希地址可以从顶点的哈希函数中派生出来(应用于边缘端点)。</strong></p>
<h3 id="Sampling-Problems-采样问题"><a href="#Sampling-Problems-采样问题" class="headerlink" title="Sampling Problems 采样问题"></a>Sampling Problems 采样问题</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160456.png" class="" title="image-20211026160456">

<p>顶点在表面内部(+)和外部(-)的例子。注意，额外的样本提供了一个线索，以避免模棱两可的情况。</p>
<p><strong>当面(或立方体)的相反角具有相同的符号，而面上的另一对顶点具有相反的符号时，就会出现歧义(参见上图)。在脸面中心采集的样本将提供线索，以确定这个立方体是代表两个表面的结合还是一个马鞍。应该清楚的是，空间网格在每个顶点上存储隐函数的一个样本。如果函数在单元格中发生了很大的变化，那么多边形表示将不会显示这种变化(参见下图)。除非对曲面的曲率有所了解，否则单靠取样是无法分辨曲面的。关于这个话题的一个很好的讨论出现在(Kalra &amp; Barr, 1989)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160511.png" class="" title="image-20211026160511">

<p>使用大的立方体来捕捉隐函数中的小的变化。</p>
<p><strong>这个模糊问题(不是欠采样问题)是通过将立方体细胞细分为四面体来避免的。这样，四面体就可以明确地变成多边形。因为每个四面体有四个顶点，所以一个包含16个条目的表将提供正确的三角形信息。缺点是将生成大约两倍数量的多边形。</strong></p>
<h4 id="Subdividing-a-Cube-细分立方体"><a href="#Subdividing-a-Cube-细分立方体" class="headerlink" title="Subdividing a Cube 细分立方体"></a>Subdividing a Cube 细分立方体</h4><p><strong>在不需要额外的单元顶点的情况下，一个立方体可以分解成5个或6个四面体，如下图6所示。这些分解在立方体表面上引入对角线，并保持立方体之间的对角线方向一致邻居，六分解更好。对角线边缘的引入产生了比直接用三角形替换每个立方体更高分辨率的表面。四面体分解和四面体替换为三角形是快速的，表格驱动的算法，产生拓扑一致的网格。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026160814.png" class="" title="image-20211026160814">

<p>把一个立方体分解成六个四面体。图片由Erwin DeGroot提供。</p>
<h3 id="Cell-Polygonization-细胞多边形化"><a href="#Cell-Polygonization-细胞多边形化" class="headerlink" title="Cell Polygonization 细胞多边形化"></a>Cell Polygonization 细胞多边形化</h3><p><strong>使用统一空间细分出现了两个明显的问题。该算法输出的三角形大小不适应曲面的曲率，需要进一步的样本来解决模糊问题，即立方体单元被多边形取代。Bloomenthal (Bloomenthal, 1988)开发了一种基于八叉树的空间细分算法，它确实适应了曲面的曲率。单元被细分为8个八进制，通过使用限制八叉树格式避免了裂缝，例如:，相邻细胞之间的差异不能超过一级的细分。这确实减少了生成的多边形数量，但只有当表面的平坦区域恰好完全落在适当的八分区内时，才能充分利用大单元格的优势。实践证明，该算法比统一体素算法慢得多，实现起来也更复杂。</strong></p>
<h2 id="More-on-Blending-更多的关于混合"><a href="#More-on-Blending-更多的关于混合" class="headerlink" title="More on Blending 更多的关于混合"></a>More on Blending 更多的关于混合</h2><p><strong>第22.1节说明了在求和字段值时可以进行混合。利玛尼在其划时代的论文(利玛尼，1973)中描述了超椭圆混合。给定两个函数FA 和FB ，之前我们简单地找到了隐式值Ftotal = FA + FB ．我们可以用A◇B.利玛尼混合被定义为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161140.png" class="" title="image-20211026161140">

<p><strong>有趣的是，指出以下属性:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161229.png" class="" title="image-20211026161229">

<p><strong>此外，这种广义的混合是结合的，即f(A◇B)◇C = fA◇(B◇C)．证明了标准混合算子+是n = 1的超椭圆混合的特殊情况。当n从1到无穷时，在混合A + B和并A∪B之间创建一组混合插值(见下图)。图22.27显示了二进制或一元的节点;事实上，使用上述公式可以很容易地将二进制节点扩展到n元节点。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161504.png" class="" title="image-20211026161504">

<p>通过改变n，里奇混合可能能够顺利地从混合过渡到联合。图片由Erwin DeGroot提供。</p>
<p><strong>里奇算子的幂是它们在所有可能隐体积的空间上的运算下是封闭的，这意味着一个算子的应用只会产生另一个标量场，定义另一个隐体积。这个新字段可以与其他字段组合，同样使用里奇运算符。上上方程总会产生两个隐式体积的精确并集，不管它们有多复杂。与在B-rep曲面上应用布尔CSG操作所涉及的困难相比，隐式体积的实体建模是非常简单的。</strong></p>
<p><strong>根据Pasko的函数表示(A. Pasko et al.， 1995)，可以定义另一个广义混合函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161621.png" class="" title="image-20211026161621">

<p><strong>当α∈[−1,1]在−1到1之间变化时，它创建了一组插值并算子和交集算子的混合算子。但是，该操作符不再具有关联性，与n元操作符的定义不兼容。</strong></p>
<h2 id="Constructive-Solid-Geometry-构建实体几何"><a href="#Constructive-Solid-Geometry-构建实体几何" class="headerlink" title="Constructive Solid Geometry 构建实体几何"></a>Constructive Solid Geometry 构建实体几何</h2><p><strong>隐式模型通常被称为隐式曲面;然而，它们本质上是体积模型，对实体建模操作很有用。里奇引入了一个构造几何学，用于从诸如并、交、差和原语混合等操作中定义复杂形状(Ricci, 1973)。曲面被认为是定义内部的f(p) &lt; 1和定义外部的f(p) &gt; 1之间的边界。这种最初的实体建模方法演变成了构造实体几何或CSG (Ricci, 1973;Requicha, 1980)。CSG通常根据二叉树自底向上评估，用低次多项式原语作为叶节点和表示布尔集操作的内部节点。这些方法适用于隐式建模，对于骨架隐式曲面，布尔集运算并∪max,交∩min 和差分\minmax 定义如下(Wyvill, Galin， &amp; Guy, 1999):</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026161931.png" class="" title="image-20211026161931">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026162031.png" class="" title="image-20211026162031">

<p>CSG的里奇算子。图片由Erwin DeGroot提供。</p>
<p><strong>上图中给出了点原语A和B的Ricci运算符。对于联合(左下角)，联合内部所有点的字段都是其中较大的fA()和fB(）.对于交点(中心)，在标记为P1的区域内的函数的值是(fA(P1), fB (P1) = 0)，因为B在其影响范围之外的贡献为零。类似地，对于标记为P2的区域(A的影响为零，即(即最小值)只留下交集区域为正值。Difference的工作原理与three中的iso-value类似显著的区域(Pi)如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026162416.png" class="" title="image-20211026162416">

<p><strong>CSG算子创建折痕，即C¹ 不连续。例如，min()操作符(上上方程)创建C¹ 在f1(p) = f2(p).当应用于两个球体时，由并算符产生的不连续会在表面上产生一个折痕，如上图所示，这是我们想要的结果。不连续很不幸地延伸到表面外的区域，这在这张图片中是不可见的。如果将混合应用到并集的结果上，则场中的C¹ -不连续平面将产生遮阳不连续(下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026162605.png" class="" title="image-20211026162605">

<p>左边的两个点原语是由利玛窦联盟连接。第三个原语被混合到结果中，在区域中产生了不想要的折痕。图片由Erwin DeGroot提供。</p>
<p><strong>这个问题在一定程度上是可以避免的(G. Pasko, Pasko, Ikeda， &amp; Kunii，</strong><br><strong>2002)，并开发了CSG算子，并且所有点有C¹，其中f1(p) = f2(p) = iso (Barthe, Dodgson, Sabin, Wyvill， &amp; Gaildrat，)2003)。</strong></p>
<h2 id="Warping-扭曲"><a href="#Warping-扭曲" class="headerlink" title="Warping 扭曲"></a>Warping 扭曲</h2><p><strong>通过扭曲周围空间来扭曲表面形状的能力是一个有用的建模工具。弯曲是一个映射R³的连续函数w(x, y, z) 在R³．Sederberg在描述自由形式变形时，为翘曲提供了一个很好的类比(Sederberg &amp; Parry, 1986)。他认为，弯曲的空间可以比作一个清晰、灵活的塑料平行六面体，要弯曲的物体就嵌在其中。通过对隐式方程简单地应用某个扭曲函数w(p)，可以定义一个扭曲元素:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163108.png" class="" title="image-20211026163108">

<p><strong>一个弯曲的元件可以由它到骨架的距离来充分表征di(x, y, z)，其衰减滤波函数gi(r)，最后是它的扭曲函数wi(x, y, z)。在隐式表面上渲染或执行操作，隐式必须找到许多点f(P)的值。首先，P被warp函数变换到某个新的点Q，并返回f(Q)代替f(P)。在下图中，不是返回某个点f(Q)的隐式值，而是返回f(P)的值。在这种情况下，返回等值，隐式曲面(2D中的曲线)通过Q而不是p，因此，圆被扭曲成椭圆。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163257.png" class="" title="image-20211026163257">

<p>点Q返回点p的字段值。</p>
<p><strong>Barr通过应用于参数曲面的扭曲、锥度和弯曲操作引入了全局和局部变形的概念(Barr, 1984)。可以对变形进行嵌套，以生成如图22.27所示的模型。从概念上讲，这些方法很容易应用到隐式曲面上，如式(22.6)所示。</strong></p>
<p><strong>注意，法线不能以类似于弯曲一个点的方式计算。这个问题类似于第13.2节中关于实例化的问题。在这种情况下，法线最容易用(22.3.3)式来近似，尽管如(Barr, 1984)所建议的，使用雅可比矩阵可以得到精确的结果。下面几节将介绍巴尔翘曲。</strong></p>
<h3 id="Twist-扭"><a href="#Twist-扭" class="headerlink" title="Twist 扭"></a>Twist 扭</h3><p><strong>在这个例子中，对于三个带有扭曲的混合隐式圆柱体，其扭曲沿z轴方向呈θ方向(见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163550.png" class="" title="image-20211026163550">

<p>三个混合隐式圆柱扭在一起。</p>
<p><strong>绕z的扭转表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163613.png" class="" title="image-20211026163613">

<h3 id="Taper-锥"><a href="#Taper-锥" class="headerlink" title="Taper 锥"></a>Taper 锥</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163910.png" class="" title="image-20211026163910">

<p>三个混合隐式圆柱先扭曲再锥化。</p>
<p><strong>锥度沿一个主轴应用。线性锥被证明是最有用的，尽管二次和立方锥很容易实现。例如，沿着y轴的线性圆锥涉及到改变x和z坐标。(参见上图)。在y之间应用一个线性比例ymax 和ymin：</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026163928.png" class="" title="image-20211026163928">

<h3 id="Bend-弯曲"><a href="#Bend-弯曲" class="headerlink" title="Bend 弯曲"></a>Bend 弯曲</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026164300.png" class="" title="image-20211026164300">

<p>三个混合隐式圆柱扭曲、锥化、弯曲。</p>
<p><strong>弯曲也适用于一个主轴。(参见上图)。对于下面的弯曲例子，弯曲速率为单位长度的弧度k，弯曲轴为(x0， 1/k)，角θ定义为(x−x0)∗k.绕z弯曲为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026164316.png" class="" title="image-20211026164316">

<h2 id="Precise-Contact-Modeling-精确接触模型"><a href="#Precise-Contact-Modeling-精确接触模型" class="headerlink" title="Precise Contact Modeling 精确接触模型"></a>Precise Contact Modeling 精确接触模型</h2><p><strong>精确接触建模(PCM)是一种隐式曲面原元在接触状态下变形的方法，同时保持与C¹ 连续性(Gascuel, 1993)。PCM之所以重要，是因为它是一种简单而自动的方式，可以显示模型如何对其环境作出反应。使用非隐式方法就不能这么容易地做到这一点(参见下图)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026164834.png" class="" title="image-20211026164834">

<p>海葵变形成暗礁。</p>
<p><strong>PCM是通过包含一个变形函数s(p)来实现的，该函数对每个点返回的字段值进行修正。对于每一对对象，首先使用边界盒测试检测碰撞。一旦确定可能发生碰撞，就应用PCM。局部几何变形项si 并加到隐函数fi．将碰撞物体的体积划分为相互穿透区域和变形区域。应用si的结果是相互穿透区域被压缩，以保持接触而不发生相互穿透(见下图)。si的影响在传播区域内衰减为零，以使两个区域外的体积不变形。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026164956.png" class="" title="image-20211026164956">

<p>通过碰撞物体的二维切片，显示不同的区域和PCM变形。图片由Erwin DeGroot提供。</p>
<p><strong>给定两个生成字段的骨架元素f1(p)和f2(p)，每一个周围的表面计算为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026165422.png" class="" title="image-20211026165422">

<p><strong>我们需要生成两个元素共同的表面(上图中的虚线)，即它们在该区域的某些p的渗透区域共享一个解决方案:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026165510.png" class="" title="image-20211026165510">

<p><strong>从直观上看，物体2在物体1中渗透得越深，物体1的隐含值就越高，因此物体2被压缩得越多。</strong></p>
<p><strong>函数,si 定义为在穿透区域的边界处产生平滑的连接点，即si = 0，但它的导数大于0。从这里到传播区域的边界si 用来将传播衰减到零。在穿透区域边界上最近的点0 是由梯度求得的。</strong></p>
<p><strong>在传播区域内si(p) = hi(r)，其中p = (x, y, z)是计算其隐式值的点，r =|| p−p0||(见下图)。ri的值，由用户设置，定义传播区域的大小;这个区域以外就不会发生变形。为了控制对象在传播区域膨胀多少，用户为参数α提供了一个值。最大hi 的值是Mi．当前最小值si 是负的，并以simin,其中Mi =−αisi min．因此，物体将在穿透区被压缩，而在传播区膨胀。hi的方程由两个三次多项式组成，设计在r = ri/2，其中斜率为0:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026170039.png" class="" title="image-20211026170039">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026170201.png" class="" title="image-20211026170201">

<p>函数hi(r)的值为变形函数wi在传播区域。</p>
<p><strong>当我们从互穿区移动到传播区时，我们希望有c¹连续性。因此,h′i(0) =上图中的k，为si的方向导数在连接处(标记为p0 在上上图)。如式(22.7)所示，si  =−fi 在相互渗透区域内，则:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026170604.png" class="" title="image-20211026170604">

<p><strong>PCM算法只是一个近似的适当变形的表面，但它是一个有吸引力的算法，因为它的简单。</strong> </p>
<h2 id="The-BlobTree-融合树"><a href="#The-BlobTree-融合树" class="headerlink" title="The BlobTree 融合树"></a>The BlobTree 融合树</h2><p><strong>BlobTree是一种使用树结构的方法，它扩展了CSG树，以包含使用骨架原语的各种混合操作(Wyvill etal .， 1999)。Hyperfun项目是一个具有类似功能的系统，它使用一种专门的语言来描述F-rep对象(Adzhiev et al.， 1999)。</strong></p>
<p><strong>在BlobTree系统中，模型是通过将隐式原语和操作符∪(union)、∩(intersection)、−(difference)、+ (blend)、◇(超椭圆混合)和w(扭曲)。BlobTree不仅是由这些表达式构建的数据结构，也是一种可视化模型结构的方法。上面列出的运算符都是二进制的，但warp是个一元运算符。一般来说，使用n进制运算符比使用二元运算符更有效。BlobTree将仿射变换合并为节点，因此它也是一个场景图，并且由叶节点组成的原语(例如骨架)。</strong></p>
<h3 id="Traversing-the-BlobTree-遍历BlobTree"><a href="#Traversing-the-BlobTree-遍历BlobTree" class="headerlink" title="Traversing the BlobTree 遍历BlobTree"></a>Traversing the BlobTree 遍历BlobTree</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171119.png" class="" title="image-20211026171119">

<p>BlobTree。螺旋楼梯是由一个中央纹理圆柱体建造而成，楼梯和栏杆被混合在一起。栏杆由一系列圆柱体和两个圆形(圆环)原体混合在一起，再与一个垂直圆柱体混合而成。BlobTree也是一个场景图，实例化节点重复由适当矩阵转换的各个部分。每个楼梯都是由一个锥形多边形原体(成为一个偏移面)制成的;十字节点和并节点将膨胀盘与楼梯连接起来。</p>
<p><strong>上图显示了一个包含Barr扭曲和CSG操作的BlobTree示例。其他节点可以包括2D纹理(Schmidt, Grimm， &amp; Wyvill, 2006)，精确接触建模，以及动画和其他属性。BlobTree的遍历本质上非常简单。通过多边形或光线追踪渲染对象所需要的就是找到任意点的隐式值(以及相应的梯度)。这可以通过遍历树来实现。多边形化和射线跟踪算法需要在空间中大量点处计算隐式场函数。函数f(N, M)返回节点N在点M处的字段值，这取决于节点的类型。值L和R表示探索树的左或右分支。下面的算法被写成(为了简单起见)，就好像树是二进制的一样:</strong></p>
<p><strong>函数f(N, M)</strong></p>
<p>​    <strong>•原始:f (M);</strong></p>
<p>​    <strong>•变形:f(L(N)， w(M));</strong> </p>
<p>​    <strong>•blend: f(L(N)， M) + f(R(N)， M));</strong></p>
<p>​    <strong>•union: max(f(L(N)， M)， f(R(N)， M));</strong> </p>
<p>​    <strong>•交集:min(f(L(N)， M)， f(R(N)， M));</strong></p>
<p>​    <strong>•差:min(f(L(N)， M)，−f(R(N)， M))。</strong></p>
<p><strong>下图显示了一个复杂的BlobTree模型，其中显示了集成的许多特性。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171321.png" class="" title="image-20211026171321">

<p>“螺旋楼梯。在Erwin DeGroot的BlobTree.net系统中创建的复杂的BlobTree隐式模型。</p>
<h2 id="Interactive-Implicit-Modeling-Systems-交互式隐式模型系统"><a href="#Interactive-Implicit-Modeling-Systems-交互式隐式模型系统" class="headerlink" title="Interactive Implicit Modeling Systems 交互式隐式模型系统"></a>Interactive Implicit Modeling Systems 交互式隐式模型系统</h2><p><strong>早期基于草图的建模系统，如Teddy (Igarashi, Matsuoka， &amp; Tanaka, 1999)，使用用户绘制的一些笔画来推断3D空间中的多边形模型。有了更好的硬件和改进的算法，基于草图的隐式建模系统现在是可能的。Shapeshop使用隐式扫描表面从2D用户笔画制造3D笔画，并保留了BlobTree的层次结构，不像早期系统生成的均质网格(Schmidt, Wyvill, Sousa， &amp; Jorge, 2005)。这使得用户能够从几个简单的笔画生成任意拓扑的复杂模型。边界图显示了一个闭合的绘制笔画(下图)膨胀为一个隐式扫描和第二个扫描(下下图)，使用CSG减去一个较小的扫描对象。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171447.png" class="" title="image-20211026171447">

<p>膨胀概述。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171502.png" class="" title="image-20211026171502">

<p>可以应用BlobTree操作，例如，CSG差分。图片由Erwin DeGroot提供。</p>
<p><strong>使之成为可能的改进之一是缓存系统，该系统在BlobTree的每个节点上使用固定的三维隐式值网格，表示通过遍历节点下的树找到的值(Schmidt, wyill， &amp; Galin, 2005)。如果在节点N需要某个点p的值，则可以返回一个值，而不需要遍历N以下的树，前提是树的一部分没有改变。相反，我们使用了一个插值方案(见第9章)来寻找p的值。这个方案加快了对复杂BlobTrees的遍历速度，并且是使系统以交互速率运行的一个因素。</strong></p>
<p><strong>下一代隐式建模系统将利用硬件和软件的进步，以交互方式处理越来越复杂的层次模型。下图显示了一个更复杂的Shapeshop示例。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211026171703.png" class="" title="image-20211026171703">

<p>“下一步。“艺术家Corien Clapwijk (Andusan)在Ryan Schmidt的Shapeshop中交互创建了一个复杂的BlobTree隐式模型。</p>
<h1 id="23-Global-Illumination-全局光照"><a href="#23-Global-Illumination-全局光照" class="headerlink" title="23 Global Illumination 全局光照"></a>23 Global Illumination 全局光照</h1><p><strong>在现实世界中，许多表面从其他反射表面接收大部分或全部的入射光。这通常被称为间接照明或相互照明。例如，大多数房间的天花板很少或没有直接从灯具(发光物体)获得照明。光照的直接分量和间接分量如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027113538.png" class="" title="image-20211027113538">

<p>在左边和中间的图像中，间接照明和直接照明分别被分离出来。右边显示了两个分量的和。全局光照算法同时考虑了直接光照和间接光照。</p>
<p><strong>虽然计算光在表面之间的相互反射是简单的，但它可能是昂贵的，因为所有的表面都可能反射任何给定的表面，导致多达O(N²) N个表面的相互作用。因为对象的整个全局数据库可以照亮任何给定的对象，间接照明通常被称为全局照明问题。</strong></p>
<p><strong>关于解决全球照明问题的文献丰富而复杂(例如，Appel, 1968;gora, Torrance, Greenberg， &amp; Battaile, 1984;库克et al .,1984;伊梅尔等人，1986;Kajiya, 1986;马利,1988)。本章以粒子跟踪和路径跟踪两种算法为例进行讨论。第一个是有用的演练应用程序，如迷宫游戏，并作为批处理渲染的组件。第二个是用于真实的批处理渲染。然后我们讨论如何分离“直接”照明，即光在灯具和相机之间只发生一次反射。</strong></p>
<h2 id="Particle-Tracing-for-Lambertian-Scenes-朗伯场景的粒子追踪"><a href="#Particle-Tracing-for-Lambertian-Scenes-朗伯场景的粒子追踪" class="headerlink" title="Particle Tracing for Lambertian Scenes 朗伯场景的粒子追踪"></a>Particle Tracing for Lambertian Scenes 朗伯场景的粒子追踪</h2><p><strong>回想一下18.2节中的传播方程:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114108.png" class="" title="image-20211027114108">

<p><strong>这个方程的几何结构如下图所示。当被照点为朗伯式时，这个方程简化为:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114122.png" class="" title="image-20211027114122">

<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114157.png" class="" title="image-20211027114157">

<p>定向形式的传播方程的几何形式。</p>
<p><strong>其中R为漫反射。近似这个方程的解的一种方法是使用有限元方法。首先，我们将场景分成N个表面，每个表面亮度Li未知,反射率Ri，发出辐亮度Ei．这就得到了N个联立线性方程组</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114254.png" class="" title="image-20211027114254">

<p><strong>kij 是与原始积分表示有关的常数。然后我们解出这组线性方程，我们可以渲染N个恒定颜色的多边形。这种有限元方法通常称为辐射度。</strong></p>
<p><strong>另一种替代辐射的方法是使用统计模拟方法，通过随机跟踪从灯具通过环境的光“粒子”。这是一种粒子追踪。有许多算法使用某种形式的粒子跟踪;我们将讨论一种粒子追踪的形式，它将光线沉积在三角形的纹理中。首先，我们回顾了一些基本的辐射关系。面积为A的朗伯曲面的辐亮度L与单位面积的入射功率成正比:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114343.png" class="" title="image-20211027114343">

<p><strong>Φ是来自地表的输出能量。请注意，在本讨论中，所有的辐射量都是光谱或RGB，这取决于实现。如果地表有发射能量Φe，事件强度Φi，反射率R，那么这个方程就变成</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114352.png" class="" title="image-20211027114352">

<p><strong>如果我们有一个模型Φe 和R指定的每个三角形，我们可以进行灯具通过灯具，火力的形式从每个灯具的粒子。我们将纹理贴图与每个三角形关联起来，以存储累积的亮度，并将所有像素初始化为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114446.png" class="" title="image-20211027114446">

<p><strong>如果一个三角形的面积是A和nt 当它被一个能量为φ的粒子击中时，该粒子的亮度就会增加</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114456.png" class="" title="image-20211027114456">

<p><strong>一旦一个粒子击中一个表面，我们增加它击中的texel的亮度，概率地决定是否反射这个粒子，如果我们反射它，我们选择一个方向并调整它的功率。</strong></p>
<p><strong>注意，我们希望粒子在某一点终止。对于每个表面，我们可以为每个表面相互作用指定一个反射概率p。一个自然的选择是让p = R就像自然界中的光一样。粒子会分散在周围环境中，在被吸收之前不会失去或获得任何能量。当粒子携带单一波长时，这种方法很有效(Walter, Hubbard, Shirley， &amp; Greenberg, 1997)。然而，当光谱或RGB三重被射线携带时，就像经常实现的那样(Jensen, 2001)，没有单一的R，应该选择一些对p值的折衷。强度φ′对于反射的粒子，应加以调整，以考虑到粒子可能消失:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114633.png" class="" title="image-20211027114633">

<p><strong>注意，p可以被设为任何小于1的正常数，并且这个常数对于每次相互作用都是不同的。当p &lt; R时，粒子会在那个波长上获得能量，当p &lt; R时，粒子会在那个波长上失去能量。当p &lt; 1时，粒子将停止散射并在某一点终止。在接下来的讨论中，我们将p设为0.5。在这样的系统中，单个粒子的路径如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114708.png" class="" title="image-20211027114708">

<p>粒子存活的概率为0.5，并在最后一个交叉点被吸收的路径。显示每个路径段的RGB功率。</p>
<p><strong>这个算法的一个关键部分是我们用适当的朗伯曲面分布来散射光。如14.4.1节所讨论的，我们可以通过变换两个标准随机数(ξ1,ξ2)来找到一个具有余弦(朗伯)分布的向量如下:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114815.png" class="" title="image-20211027114815">

<p><strong>注意，这假设法向量平行于z轴。对于三角形，我们必须建立一个w平行于法向量的标准正交基。我们可以做到以下几点:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114838.png" class="" title="image-20211027114838">

<p><strong>pi 是三角形的顶点。然后，根据定义，在适当坐标下的向量是</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114849.png" class="" title="image-20211027114849">

<p><strong>在伪代码中，p = 0.5和一个灯具的算法是:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027114900.png" class="" title="image-20211027114900">

<p><strong>这里ξi 是标准随机数。一旦这段代码运行，纹理贴图存储每个三角形的亮度，可以直接为任何视点渲染，不需要额外的计算。</strong></p>
<h2 id="Path-Tracing-路径追踪"><a href="#Path-Tracing-路径追踪" class="headerlink" title="Path Tracing 路径追踪"></a>Path Tracing 路径追踪</h2><p><strong>虽然粒子跟踪非常适合于漫射场景的亮度预计算，但对于使用一般BRDFs或包含许多对象的场景创建图像是有问题的。创建这类场景的图像最直接的方法是使用路径跟踪(Kajiya, 1986)。这是一种概率方法，从眼睛发出光线，并将它们追踪回光线。通常路径追踪只用于计算间接照明。在这里，我们将以一种捕获所有照明的方式呈现它，这可能是低效的。这有时被称为暴力路径跟踪。在第23.3节中，可以添加更有效的直接照明技术。</strong></p>
<p> <strong>在路径跟踪中，我们从完整的传输方程开始:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115310.png" class="" title="image-20211027115310">

<p><strong>我们使用蒙特卡罗积分来近似解决这个方程的每一条观察射线。回忆一下14.3节，我们可以使用随机样本来近似一个积分:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115335.png" class="" title="image-20211027115335">

<p><strong>在xi 是概率密度函数p的随机点。如果我们把这个直接应用到N = 1的传播方程中，我们得到</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115345.png" class="" title="image-20211027115345">

<p><strong>所以，如果我们有办法选择随机方向ki 有了已知的密度p，我们可以得到一个估计值。问题是Lf (ki)本身就是未知数。幸运的是，我们可以应用递归并使用Lf (ki)的统计估计，通过向那个方向发送射线来找到在那个方向看到的表面。当我们碰到一个灯具和Le 为非零(下图)。这个方法假设光线的反射率为零，否则我们将继续递归。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115555.png" class="" title="image-20211027115555">

<p>在路径跟踪中，光线从眼睛通过一个像素，并在场景中散射，直到它击中灯具。</p>
<p><strong>在lambert BRDF (ρ = R/π)的情况下，我们可以使用一个余弦密度函数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115707.png" class="" title="image-20211027115707">

<p><strong>可根据式(23.3)选择具有该密度的方向。这允许在我们的估计中抵消余弦项:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115724.png" class="" title="image-20211027115724">

<p><strong>在伪代码中，这种朗伯曲面的路径跟踪器的工作原理与第4章中描述的射线跟踪器类似，但射线颜色函数将被修改:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027115747.png" class="" title="image-20211027115747">

<p><strong>这将导致一个非常嘈杂的图像，除非使用大的光源或非常多的样本。注意，光源的颜色必须远高于一(有时数千或数万)，以使表面的最终颜色接近一，因为只有那些偶然击中光源的光线才会产生影响，而大多数光线只会产生接近零的颜色。为了生成随机方向d，我们使用与粒子追踪相同的技术(见公式(23.2))。</strong></p>
<p><strong>一般情况下，我们可能希望使用光谱颜色或更通用的BRDF。在实践中，我们应该让material类包含成员函数来计算随机方向以及与该方向相关的p。通过这种方式，材料可以透明地添加到实现中。</strong></p>
<h2 id="Accurate-Direct-Lighting-精确的直接光照"><a href="#Accurate-Direct-Lighting-精确的直接光照" class="headerlink" title="Accurate Direct Lighting 精确的直接光照"></a>Accurate Direct Lighting 精确的直接光照</h2><p><strong>本节介绍一种比第10章更基于物理的直接照明方法。这些方法将有助于提高全局光照算法的效率。关键的想法是将阴影光线发送到灯具，就像第4章中描述的那样，但是这样做是基于前一章的传输方程。全局光照算法可以调整，以确保直接分量精确计算一次。例如，在粒子追踪中，直接来自灯具的粒子不会被记录，所以粒子只会编码间接照明。这使得好看的阴影比在全局光照环境下计算直接光照更有效。</strong></p>
<h3 id="Mathematical-Framework-数学框架"><a href="#Mathematical-Framework-数学框架" class="headerlink" title="Mathematical Framework 数学框架"></a>Mathematical Framework 数学框架</h3><p><strong>为了计算从一个灯具(发光物体)到非发光表面的直接光，我们求解第18.2节中的传播方程的形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120040.png" class="" title="image-20211027120040">

<p><strong>回想一下,Le是发射源的辐射亮度，v是一个能见度函数，如果x“看到”x′，则它等于1，否则等于0，其他变量如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120213.png" class="" title="image-20211027120213">

<p>上方程的直接光照的术语。</p>
<p><strong>如果我们要用蒙特卡罗积分对上方程进行采样，我们需要随机选取一个点x′用密度函数p (所以x′~px)。只要输入(14.5)式，就可以得到一个样本</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120555.png" class="" title="image-20211027120555">

<p><strong>如果我们在灯具上随机选取一个均匀点，那么p = 1/ A，其中A是灯具的面积。这得出</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120625.png" class="" title="image-20211027120625">

<p><strong>我们可以直接使用上式对平面(如矩形)光源进行采样。我们简单地在每个灯具上随机选择一个点。</strong></p>
<p><strong>一种灯具的代码为:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120700.png" class="" title="image-20211027120700">

<p><strong>上面的代码需要一些额外的测试，如如果余弦为负，则将其锁定为零。注意||d||⁴ 来自距离平方项 还有两个余弦，例如n·d = ||d||cos θ，因为d不一定是单位向量。</strong></p>
<p><strong>下图显示了几个软阴影的例子。</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027120844.png" class="" title="image-20211027120844">

<p>带有正方形和区域光源的背光球上的各种软阴影。上图:1个样本。底部:100个样本。请注意，在决定阴影的外观时，光源的形状比它的大小更重要。</p>
<h3 id="Sampling-a-Spherical-Luminaire-球形灯具采样"><a href="#Sampling-a-Spherical-Luminaire-球形灯具采样" class="headerlink" title="Sampling a Spherical Luminaire 球形灯具采样"></a>Sampling a Spherical Luminaire 球形灯具采样</h3><p><strong>虽然可以用上方程对圆心为c、半径为R的球体进行采样，但这种采样将产生非常有噪声的图像，因为许多采样将在球体的背面，而cos θ′术语变化很大。相反，我们可以使用更复杂的p(x′)来减少噪声。</strong></p>
<p><strong>我们可以尝试的第一个非均匀密度是p(x′) ∝cos θ′。这p(x′) ∝cos θ′ / ||x′−x||²和采样一样复杂，所以我们在这里讨论这个问题。我们观察到灯具上的取样是这样的和常数密度函数q(ki) = const，定义在光源所面对的方向空间中，从x处可见。我们现在使用原点为x的坐标系，使用右手标准正交基w = (c−x)/||c−x||， v = (w × n)/||(w×n)||(见下图)。我们还定义(α， φ)为uvw坐标系下的方位角和极角。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121745.png" class="" title="image-20211027121745">

<p>球面灯具在x点直接照明的几何图形。</p>
<p><strong>包括球面灯具的最大α为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121823.png" class="" title="image-20211027121823">

<p><strong>因此，在球体所面对的方向的圆锥体内的密度(相对于立体角)是实心角2π(1 - cos αmax)的倒数由球体所包围的:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121840.png" class="" title="image-20211027121840">

<p><strong>我们得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121850.png" class="" title="image-20211027121850">

<p><strong>这给了我们方向ki．为了找到实际的点，我们需要找到球面上那个方向上的第一个点。这个方向的射线是(x + tki）， ki 是由</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027121943.png" class="" title="image-20211027121943">

<p><strong>我们还必须计算p(x′)，关于面积度量的概率密度函数(记得密度函数q是在立体角空间中定义的)。因为我们知道q是一个有效的概率密度函数使用ω测度，我们知道dΩ = dA(x′) cos θ′/ ||x′−x||²，我们可以将任意的概率密度函数q(ki)联系起来及其相关的概率密度函数p(x′)</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027122121.png" class="" title="image-20211027122121">

<p><strong>我们可以解出p(x′)</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027122132.png" class="" title="image-20211027122132">

<p><strong>下图显示了一个很好的调试案例。</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027122214.png" class="" title="image-20211027122214">

<p>一个球面Le = 1接触一个反射球体。当两个球体接触时，反射球体的L(x′) = 1。左:1个样品。中间:100个样本。右:100个样品，特写镜头。</p>
<h3 id="Nondiffuse-Luminaries-非漫反射光源"><a href="#Nondiffuse-Luminaries-非漫反射光源" class="headerlink" title="Nondiffuse Luminaries 非漫反射光源"></a>Nondiffuse Luminaries 非漫反射光源</h3><p><strong>没有理由灯具的亮度不能随方向和位置而变化。例如，如果灯具是电视机，它可以随位置而变化。它可以随汽车前照灯和其他定向源的方向变化。在我们的分析中，与前面的部分相比几乎没有什么需要改变的，除了Le(x′)必须变成Le(x′,−ki)．改变强度随方向变化的最简单方法是对法向量n′使用类似phong的图形。为了避免在总光输出的术语中使用指数，我们可以使用这种形式</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211027122508.png" class="" title="image-20211027122508">

<p><strong>E(x′)是x′点的辐射出度(单位面积的功率)， n是Phong指数。当n = 1时，你会得到一个漫射光。如果光通过其区域是不均匀的，例如电视机，那么E就不是一个常数。</strong></p>
<h1 id="24-Reflection-Models-反射模型"><a href="#24-Reflection-Models-反射模型" class="headerlink" title="24 Reflection Models 反射模型"></a>24 Reflection Models 反射模型</h1><p><strong>正如我们在第18章讨论的，表面的反射特性可以用BRDF (Nicodemus, Richmond, Hsia, Ginsberg， &amp; Limperis, 1977;库克和托伦斯，1982)。在本章中，我们将讨论材料属性在视觉上最重要的一些方面，以及一些非常简单的模型，这些模型对捕获这些属性非常有用。有许多BRDF模型在图形中使用，这里展示的模型只是给出一个无漫反射BRDF的概念。</strong></p>
<h2 id="Real-World-Materials-真实世界材质"><a href="#Real-World-Materials-真实世界材质" class="headerlink" title="Real-World Materials 真实世界材质"></a>Real-World Materials 真实世界材质</h2><p><strong>许多真实的材料在正常的观察距离下都有可见的结构。例如，大多数地毯都有很容易看到的绒毛，有助于外观。就我们的目的而言，这样的结构不是物质属性的一部分，而是几何模型的一部分。结构的细节在正常的观察距离是看不见的，但它确实决定了材料的宏观外观，是材料属性的一部分。例如，纸上的纤维在放大后会呈现出复杂的外观，但在一臂长的距离上观察时，它们会模糊在一起，呈现出均匀的外观。折叠成BRDF的微结构之间的区别是任意的，取决于人们定义的“正常”观察距离和视力，但这种区别在实践中被证明是非常有用的。</strong></p>
<p><strong>在本节中，我们将定义一些材料类别。在本章的后面，我们将介绍针对每种材料类型的反射模型。在讲义中在本章的最后，还讨论了一些可以解释更多奇异材料的模型。</strong></p>
<h3 id="Smooth-Dielectrics-and-Metals-光滑电介质和金属"><a href="#Smooth-Dielectrics-and-Metals-光滑电介质和金属" class="headerlink" title="Smooth Dielectrics and Metals 光滑电介质和金属"></a>Smooth Dielectrics and Metals 光滑电介质和金属</h3><p><strong>电介质是能够折射光线的透明材料;第四章总结了它们的基本性质。金属像电介质一样反射和折射光线，但它们吸收光线的速度非常非常快。因此，只有非常薄的金属片是透明的，例如，一些玻璃制品上的薄镀金。对于光滑的材料，只有两个重要的属性:</strong></p>
<p>​    <strong>1.每个入射角和波长反射多少光。</strong></p>
<p>​    <strong>2.在给定的距离和波长下，光通过材料时被吸收的比例是多少?</strong></p>
<p><strong>透射的光量是没有反射的(这是能量守恒的结果)。实际上，对于金属来说，我们可以假设所有的光都被立即吸收了。对于电介质，分数由第13章讨论的比尔定律中使用的常数决定。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028173242.png" class="" title="image-20211028173242">

<p>玻璃反射和透射的光量随角度的不同而变化。</p>
<p><strong>反射的光量由第4章讨论的菲涅耳方程确定。这些方程很简单，但很麻烦。菲涅耳方程的主要作用是随着入射角的增加而增加反射率，特别是在掠角附近。这种效应也适用于透射光。这些想法在上图中以图表形式显示出来。注意，光被反复反射和折射，如下图所示。通常只有一两个反射的图像是容易看到的。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028173259.png" class="" title="image-20211028173259">

<p>光线被反复反射和重新反射由玻璃破碎，能量的破碎显示。</p>
<h3 id="Rough-Surfaces-粗糙表面"><a href="#Rough-Surfaces-粗糙表面" class="headerlink" title="Rough Surfaces 粗糙表面"></a>Rough Surfaces 粗糙表面</h3><p><strong>如果金属或电介质被粗糙到很小的程度，但又没有小到产生衍射，那么我们可以将其视为带有microfacet的表面(Cook &amp; Torrance, 1982)。这样的表面在较近距离时表现为镜面，但在较远的距离观察时，似乎将光线以一种分布方式展开。对于金属来说，这种粗糙表面的一个例子可能是拉丝钢，或大多数铝箔的“浑浊”一面。</strong></p>
<p><strong>对于电介质，如一片玻璃，划痕或其他不规则的表面特征使玻璃模糊了反射和透射的图像，我们通常可以清楚地看到。如果表面划伤严重，我们称之为半透明而不是透明。这是一个有点武断的区别，但我们通常很清楚，我们是认为玻璃是半透明的还是透明的。</strong></p>
<h3 id="Diffuse-Materials-漫反射材质"><a href="#Diffuse-Materials-漫反射材质" class="headerlink" title="Diffuse Materials 漫反射材质"></a>Diffuse Materials 漫反射材质</h3><p><strong>如果一个材料是哑光的，即是漫反射的。而不是闪闪发亮的。我们看到的许多表面都是弥散的，比如大多数石头、纸张和未完成的木头。对于第一次近似，扩散表面可以近似为朗伯常数BRDF。真实的漫反射材料通常会因为掠射角度而变得有些高光。这是一种微妙的效果，但对于现实主义来说很重要。</strong></p>
<h3 id="Translucent-Materials-半透明材质"><a href="#Translucent-Materials-半透明材质" class="headerlink" title="Translucent Materials 半透明材质"></a>Translucent Materials 半透明材质</h3><p><strong>许多薄的物体，如树叶和纸，都能漫射和反射光线。出于实际目的，这些物体不会传送清晰的图像。这些表面可以增加透射光的色相变化。例如，红纸之所以是红的，是因为它滤掉了非红光，只滤掉了进入纸内较短距离的光线，然后散射回来。这种纸也能透过红色调的光，因为原理相同，但透过的光能穿透纸张。这种性质的一个含义是，在两个方向上的透射系数应该是相同的。</strong></p>
<h3 id="Layered-Materials-分层材质"><a href="#Layered-Materials-分层材质" class="headerlink" title="Layered Materials 分层材质"></a>Layered Materials 分层材质</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028173705.png" class="" title="image-20211028173705">

<p>击中分层表面的光可以被反射，或者它可以被传输，然后漫射离开基材。</p>
<p><strong>许多表面是由“层”组成的，或者是嵌入粒子的电介质，使表面具有扩散特性(Phong, 1975)。这种材料的表面镜面反射如图所示，因此遵循菲涅耳方程。被传输的光要么被吸收，要么被散射回介质表面，在那里它可能被传输，也可能不被传输。这些光线经过透射、散射，然后在相反的方向重新透射，形成了漫射“反射”成分。</strong></p>
<p><strong>请注意漫反射分量也会随着角度的增大而衰减，因为菲涅耳方程会随着角度的增大而反射回表面，如下图所示。因此，相对于一个恒定的漫反射BRDF，在掠射角附近消失的BRDF更合适。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028173723.png" class="" title="image-20211028173723">

<p>当相对于表面法线的角度增加时，被衬底散射的光越来越不可能离开表面。</p>
<h2 id="Implementing-Reflection-Models-实时反射材质"><a href="#Implementing-Reflection-Models-实时反射材质" class="headerlink" title="Implementing Reflection Models 实时反射材质"></a>Implementing Reflection Models 实时反射材质</h2><p><strong>如18.1.6节所述，BRDF模型将生成比我们从点光源和phong -like模型获得的渲染更基于物理的渲染。不幸的是，真正的brdf通常非常复杂，不能从第一原理推导出来。相反，它们必须被衡量直接从原始数据中逼近，或者它们必须以经验的方式粗略逼近。后一种经验策略是通常所做的，这种近似模型的发展仍然是一个研究领域。本节讨论这些经验模型的几个可取的性质。</strong></p>
<p><strong>首先，物理约束意味着BRDF模型的两个性质。第一个约束是节能:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174256.png" class="" title="image-20211028174256">

<p><strong>如果你从一个表面的任何方向发射一束光i，则各方向反射的光总量最多为入射量。我们期望所有BRDFs具有的第二个物理性质是互惠性:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174305.png" class="" title="image-20211028174305">

<p><strong>其次，我们想要在漫反射和镜面组件之间有一个清晰的分离。这样做的原因是，尽管对于理想的镜面分量有一个精确的脉冲函数公式，但脉冲函数必须在实际中作为特殊情况来实现。这种特殊情况只有在BRDF模型清楚地表明什么是镜面的和什么是漫反射的情况下才可行。</strong></p>
<p><strong>第三，我们想要直观的参数。例如，Phong模型如此长寿的一个原因是，它的扩散常数和指数都与表面的直观属性明确相关，即表面颜色和高光大小。</strong></p>
<p><strong>最后，我们希望BRDF函数能够接受蒙特卡罗采样。回想一下第14章，一个积分可以被N个随机点采样xi~p 其中p的定义与积分相同:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174426.png" class="" title="image-20211028174426">

<p><strong>回忆一下第18.2节中ko 方向的表面辐亮度由传输方程给出:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174439.png" class="" title="image-20211028174439">

<p><strong>如果我们用pdf p(ki)，然后我们可以用采样来近似地表辐亮度:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174449.png" class="" title="image-20211028174449">

<p><strong>这个近似对于任何非零的p是收敛的在被积函数是非零的情况下。然而，只有当被积函数相对于p不是很大时，它才会很好地收敛。理想情况下，p(k)应该近似于ρ(kj,ko)Lf (kj ) cosθj 被积函数的形状．在实践中,Lf 是复杂的，我们能做的最好的就是让p(k)形状有点像ρ(k, ko)Lf (k) cosθ。</strong></p>
<p><strong>例如，如果BRDF是朗伯常数，那么它是常数，理想p(k)与cos θ成正比。因为p的积分必须是1，我们可以推导出前导常数:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174714.png" class="" title="image-20211028174714">

<p><strong>这意味着C = 1/π，所以我们有</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174722.png" class="" title="image-20211028174722">

<p><strong>只要在被积函数非零的情况下p不变得太小，就可以得到一个可接受的有效实现。因此，常量pdf也足够了:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174732.png" class="" title="image-20211028174732">

<p><strong>这强调了对于给定的BRDF模型，许多pdfs文件是可以接受的。</strong> </p>
<h2 id="Specular-Reflection-Models-镜面反射材质"><a href="#Specular-Reflection-Models-镜面反射材质" class="headerlink" title="Specular Reflection Models 镜面反射材质"></a>Specular Reflection Models 镜面反射材质</h2><p><strong>对于金属，我们通常指定在正入射处的反射率R0(λ)。反射率应根据菲涅耳方程变化，一个很好的近似由(Schlick, 1994a)给出。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028174956.png" class="" title="image-20211028174956">

<p><strong>这种近似使我们可以通过数据或肉眼设置金属的法向反射率。</strong></p>
<p><strong>对于电介质，同样的公式也适用于反射率。但是，我们可以设置R0(λ)用折射率n(λ)表示:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028175006.png" class="" title="image-20211028175006">

<p><strong>通常，n不随波长而变化，但对于色散很重要的应用，n可以变化。通常有用的折射率包括水(n = 1.33)、玻璃(n = 1.4到n = 1.7)和钻石(n = 2.4)。</strong></p>
<h2 id="Smooth-Layered-Model-平滑分层模型"><a href="#Smooth-Layered-Model-平滑分层模型" class="headerlink" title="Smooth-Layered Model 平滑分层模型"></a>Smooth-Layered Model 平滑分层模型</h2><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028175258.png" class="" title="image-20211028175258">

<p>使用耦合模型的抛光瓷砖的渲染。这些图像是用蒙特卡罗路径示踪器产生的。扩散项的抽样分布为cos θ/π。</p>
<p><strong>在哑光/镜面材料中，如塑料或抛光木材，其表面的反射由菲涅耳方程控制，而在次表面则由散射控制。这种反射的一个例子可以在上图的渲染图中看到。注意，在镜面反射中的模糊主要是垂直的，这是由于在视图方向上的明显凹凸间距的压缩。这种效应导致了在有风的日子里在湖泊上看到的垂直条纹反射;它既可以使用显式微几何和简单的光滑表面反射模型建模，也可以使用更一般的模型来解释这种不对称。</strong></p>
<p><strong>我们可以对贴图使用传统的朗伯-高光模型，它线性混合了高光和朗伯术语。在标准的放射学术语中，这可以表示为</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028175334.png" class="" title="image-20211028175334">

<p><strong>其中Rdλ是亚光项的半球反射率,Rs是镜面反射，ρs 为归一化镜面BRDF(球面上的加权狄拉克函数)。这个方程是BRDF的简化版，其中Rs 与波长无关。波长的独立性导致了一个突出的颜色，这是灯具的颜色，所以抛光而不是金属外观将实现。Ward (G. J. Ward, 1992)建议设置Rd(λ)+ Rs ≤1，以节约能源。然而，这种模型具有常数Rs 在陡峭的视角下，无法显示高光度的增加。这是关键点:在现实世界中，亚光和镜面的相对比例会随着视角的变化而变化。</strong></p>
<p><strong>一种模拟亚光外观变化的方法是显式抑制Rd(λ)作为Rs 增加(雪莉,1991):</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028175549.png" class="" title="image-20211028175549">

<p><strong>其中Rf (θ)为polish-air界面的菲涅耳反射率。这个方程的问题是它不是互反的，这可以通过交换θ和θ′看出;这改变了哑光阻尼因子的值，因为乘以(1−R)f (θ))。镜面项，一个缩放的狄拉克函数，是互易的，但这并不能弥补物质项的非互易性。尽管这个BRDF工作得很好，但它缺乏互易性可能会导致一些呈现方法有定义不清的解决方案。</strong></p>
<p><strong>我们现在提出一个模型，产生亚光/镜面权衡，同时保持互惠和能量守恒。由于新模型的关键特征是它耦合了哑光和高光的比例系数，因此它被称为耦合模型(Shirley, Smits, Hu， &amp; Lafortune, 1997)。</strong></p>
<p><strong>表面有光泽的表面通常是透明的介质，如聚氨酯或油，有一些次表面结构。反射的镜面成分是由光滑的介质表面引起的，与该表面下的结构无关。这个镜面项的大小由菲涅耳方程决定。</strong></p>
<p><strong>没有在表面反射的光通过表面透射。在那里，它要么被底面吸收，要么被颜料或底面反射，然后通过抛光液的表面传送回来。透射光形成反射的哑光部分。由于哑光组件只能包含透射的光，它将自然地减少总幅度增加的角度。</strong></p>
<p><strong>为了避免在物理上合理的模型和在一系列入射角范围内具有良好定性行为的模型之间进行选择，请注意解释镜面项的菲涅尔方程，Rf (θ)是直接从介质-空气界面的物理性质推导出来的。因此，问题一定存在于整体上。我们可以使用一个全面的地下散射模拟来实现，但是这种技术既昂贵又需要地下结构的详细知识，而这通常既不知道也不容易测量。相反，我们可以修改matte项，使之成为一个简单的近似，捕获图24.4中所示的重要的定性角度行为。</strong></p>
<p><strong>我们假设马特项不是朗伯函数，而是某个只与θ，θ′和λ有关的函数:ρm(θ,θ′,λ)。我们抛弃了依赖于φ的行为或者φ′为了简单起见。我们尽量让公式保持合理的简单因为亚光项的物理是复杂的有时需要未知的参数。我们期望亚光项接近于常数，并且大致旋转对称(He et al.， 1992)。</strong></p>
<p><strong>一个明显的候选物质的物质组分ρm(θ,θ′,λ)它的倒数是可分离形式kRm(λ)f(θ)f(θ′)。我们可以合并k和Rm(λ)变成了一个单独的项，但是我们选择把它们分开，因为这样更直观地设置Rmλ 所有波长必须在0和1之间。可分离BRDFs已被证明有几个计算优势，因此我们使用可分离模型:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180047.png" class="" title="image-20211028180047">

<p><strong>我们知道哑光组分只能包含没有在表面(镜面)组分中反射的能量。这意味着对于Rm(λ) = 1时，入射能量和反射能量相等，这说明对于每个入射θ和λ， BRDF有以下约束:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180111.png" class="" title="image-20211028180111">

<p><strong>我们可以看出f(θ)一定与(1−Rf (θ))成正比。如果我们假设吸收一些能量的哑光组分与这个理想具有相同的方向模式，我们就得到了这种形式的BRDF</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180159.png" class="" title="image-20211028180159">

<p><strong>我们现在可以插入菲涅耳方程的完整形式来得到Rf (θ)，然后使用能量守恒来求解对k的约束。相反，我们将使用24.1.1节讨论的近似</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180248.png" class="" title="image-20211028180248">

<p><strong>应用方程(24.1)得到</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180256.png" class="" title="image-20211028180256">

<p><strong>则为全耦合BRDF</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180305.png" class="" title="image-20211028180305">

<p><strong>运行耦合模型的结果如图24.5所示。请注意，对于高视点，镜面反射几乎是不可见的，但它在低角度的照片图像中是清晰可见的，那里的亚光行为是不明显的。</strong></p>
<p><strong>对于折射率的合理值，R0 的范围大约为0.03到0.06(值R0 = 0.05用于图24.5)。Rs 在传统的Phong模型中更难选择，因为它通常必须为静态图像的视点进行调整，并为动画的特定相机序列进行调整。因此，耦合模型在“不干涉”模式下更容易使用。</strong></p>
<h2 id="Rough-Layered-Model-粗糙分层模型"><a href="#Rough-Layered-Model-粗糙分层模型" class="headerlink" title="Rough-Layered Model 粗糙分层模型"></a>Rough-Layered Model 粗糙分层模型</h2><p><strong>之前的模型如果表面光滑就可以了。然而，如果表面不是理想的，则需要在镜面组件中进行一些扩展。本文将耦合模型扩展到这种情况(Ashikhmin &amp; Shirley, 2000)。在表面上的一个给定点上，BRDF是两个方向的函数，一个是朝向光的方向，另一个是朝向观众的方向。我们希望有一个BRDF模型，适用于“普通”表面，如金属和塑料，并具有以下特点:</strong></p>
<p>​    <strong>1.似是而非的(Plausible)。正如Lewis (R. R. Lewis, 1994)所定义的，这是指BRDF服从能量守恒和互易性。</strong></p>
<p>​    <strong>2.各向异性(Anisotropy)。该材料应模拟简单的各向异性，如在拉丝金属上看到的。</strong></p>
<p>​    <strong>3.直观的参数(Intuitive parameters)。对于材料，如塑料，应该有参数Rd 和Rs 对于法向镜面反射以及两个粗糙度参数nu 和nv．</strong></p>
<p>​    <strong>4.菲涅耳的行为(Fresnel behavior)。当入射角减小时，高光度会增大。</strong></p>
<p>​    <strong>5.Non-Lambertian扩散项(Non-Lambertian diffuse term)。材料应该允许扩散项，但成分应该是非朗伯的，以确保存在菲涅耳行为的能量守恒。</strong></p>
<p>​    <strong>6.蒙特卡罗友好(Monte Carlo friendliness)。应该有一些合理的概率密度函数，允许直接的蒙特卡罗样本生成BRDF。</strong></p>
<p><strong>具有这些性质的BRDF是一个各向异性的菲涅耳加权phong型余弦波瓣模型。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180828.png" class="" title="image-20211028180828">

<p>几何形状的反射。注意k1,k2和h共享一个平面，这个平面通常不包括n。</p>
<p><strong>我们再次将BRDF分解为一个镜面组件和一个漫反射组件(上图)。因此，我们将BRDF写成两部分的经典和:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028180748.png" class="" title="image-20211028180748">

<p><strong>其中第一项解释了镜面反射(这将在下一节介绍)。而可以用朗伯BRDF来表示弥散项ρd(k1,k2)，我们将在第24.5.2节讨论更好的解决方案，并在第24.5.3节讨论如何实现该模型。只想实现模型的读者应该跳过该部分。</strong></p>
<h3 id="Anisotropic-Specular-BRDF-各向异性高光BRDF"><a href="#Anisotropic-Specular-BRDF-各向异性高光BRDF" class="headerlink" title="Anisotropic Specular BRDF 各向异性高光BRDF"></a>Anisotropic Specular BRDF 各向异性高光BRDF</h3><p><strong>为了模拟镜面的行为，我们使用了冯氏风格的镜面波瓣，但使这个波瓣各向异性，并纳入菲涅耳行为，同时试图保持初始模式的简单性。这个BRDF是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181031.png" class="" title="image-20211028181031">

<p><strong>我们再次使用了菲涅耳方程的Schlick近似:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181041.png" class="" title="image-20211028181041">

<p><strong>其中Rs 为材料在正入射时的反射率。因为ki ·h = ko ·h，这种形式是倒数。我们有一个经验模型，它的项是选择执行能源节约和互惠。Ashikhmin在论文中给出了对这些术语的充分理性化，列在章节注释中。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181253.png" class="" title="image-20211028181253">

<p>指数为10、100、1000和10000的金属球，从左到右和从上到下均递增。</p>
<p><strong>上上式的镜面BRDF对于表示反射的漫反射分量非常小的金属表面是有用的。上图显示了纹理映射的lambert平面上的一组金属球体。参数nu 和nv 变化时，球体的外观从粗糙的金属转变为几乎完美的镜面，从高度各向异性转变为更熟悉的Phong-like行为。</strong></p>
<h3 id="Diffuse-Term-for-the-Anisotropic-Phong-Model-各向异性Phong模型的扩散项"><a href="#Diffuse-Term-for-the-Anisotropic-Phong-Model-各向异性Phong模型的扩散项" class="headerlink" title="Diffuse Term for the Anisotropic Phong Model 各向异性Phong模型的扩散项"></a>Diffuse Term for the Anisotropic Phong Model 各向异性Phong模型的扩散项</h3><p><strong>可以将朗伯BRDF与各向异性镜面项结合使用;大多数模型都是这样做的，但这并不一定能节约能源。一个更好的方法是采用一种简单的依赖于角度的漫射分量形式，这种形式可以解释这样一个事实:漫射散射可用的能量量由于反射率项的全反射对入射角的依赖而变化。特别是，表面的漫反射颜色在掠射角附近消失，因为总镜面反射率接近1。这个众所周知的效应不能用朗伯扩散项来再现，因此大多数反射模型都忽略了它。</strong></p>
<p><strong>采用与耦合模型类似的方法，我们可以找到一种与各向异性Phong波瓣相容的漫射项形式:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181436.png" class="" title="image-20211028181436">

<p><strong>这里Rd 为正入射的漫反射系数，Rs 为冯瓣系数。下图显示了使用该模型的示例。</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028181447.png" class="" title="image-20211028181447">

<p>三个视图nu = nv = 400和扩散衬底。注意镜面反射强度的变化。</p>
<h3 id="Implementing-the-Model-实现模型"><a href="#Implementing-the-Model-实现模型" class="headerlink" title="Implementing the Model 实现模型"></a>Implementing the Model 实现模型</h3><p><strong>回想一下，BRDF是漫反射和镜面的组合:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028191754.png" class="" title="image-20211028191754">

<p><strong>漫反射分量如式(24.7)所示;镜面分量如式(24.5)所示。没有必要调用三角函数计算指数，则镜面BRDF可以写成:</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028191834.png" class="" title="image-20211028191834">

<p><strong>在蒙特卡罗环境中，我们对下列问题感兴趣给定k1，生成k2 的样本其分布形状与余弦加权BRDF相似。注意，被积函数的大值严重欠采样是一个严重的误差，而小值严重过采样在实践中是可以接受的。读者可以验证下面建议的密度具有这种性质。</strong></p>
<p><strong>构建一个用于采样的pdf的合适方法是考虑产生BRDF的半向量的分布。这样的函数是</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028191914.png" class="" title="image-20211028191914">

<p><strong>这里选择的常量是为了确保它是一个有效的pdf。</strong></p>
<p><strong>我们可以用概率密度函数ph(h)来生成一个随机的h。然而，为了计算渲染方程，我们同时需要一个反射向量ko 概率密度函数p(ko）．重要的是要注意，如果根据h生成ph(h)然后转化为结果ko:</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028192238.png" class="" title="image-20211028192238">

<p><strong>生成的k的密度o 不是ph(ko）．这是因为h和ko的测量值不同．所以实际密度p(ko)是</strong> </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028192250.png" class="" title="image-20211028192250">

<p><strong>注意，在已知BRDF是这个模型的实现中，渲染方程的估计非常简单，因为许多项抵消了。</strong></p>
<p><strong>可以生成一个h向量，其对应的向量是ko 将指向表面内部，即cosθo &lt; 0。这种样本的权重应设为零。这种情况对应的是视界以下的镜面波瓣，是模型中能量损失的主要来源。显然，随着nu,nv 变得更大。</strong></p>
<p><strong>现在唯一剩下的事情是描述如何用(24.10)式的pdf生成h向量。我们首先生成h的球角在(θ， φ)∈[0，π/2 ]×[0, π/2 ］.注意，这只是半球的第一象限。给定两个随机数(ξ1,ξ2)均匀分布于[0,1]，我们可以选择</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028192451.png" class="" title="image-20211028192451">

<p><strong>然后根据φ的值得到θ</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211028192517.png" class="" title="image-20211028192517">

<p><strong>为了采样整个半球，我们在ξ1 处使用标准操作根据它是否在[0,0.25)，[0.25,0.5)，[0.5,0.75)，或[0.75,1.0)，被映射到四种可能的函数之一。例如，ξ1∈[0.25,0.5)，求φ(1−4(0.5−ξ1)，然后绕φ = π/2轴“翻转”。这确保了全面覆盖和分层。</strong></p>
<p><strong>对于扩散项，使用一种更简单的方法，根据余弦分布生成样本。这足够接近完全扩散BRDF，从而大大减少了蒙特卡罗估计的方差。</strong></p>
<h1 id="25-Computer-Graphics-in-Games-游戏中的计算机图形"><a href="#25-Computer-Graphics-in-Games-游戏中的计算机图形" class="headerlink" title="25 Computer Graphics in Games 游戏中的计算机图形"></a>25 Computer Graphics in Games 游戏中的计算机图形</h1><p><strong>在计算机图形学的所有应用中，计算机和视频游戏是最吸引人的也许是最受关注的。为给定的游戏选择的图形方法，不仅会对游戏引擎代码产生深远影响，还会对美术资产产生深远影响，甚至是游戏玩法或核心游戏机制。</strong><br><strong>虽然游戏图像依赖于前一章的所有材质，其中，有两章尤为相关。游戏需要高效使用图形硬件，所以理解在第十七章在材质是重要的。</strong></p>
<p>  <strong>在本章中，我将详细介绍适用于图形的具体考虑游戏开发中的图形，从游戏运行的平台到游戏生产过程。</strong>  </p>
<h2 id="Platforms-平台"><a href="#Platforms-平台" class="headerlink" title="Platforms 平台"></a>Platforms 平台</h2><p><strong>在这里，我使用平台这个术语来指代特定的硬件组合和API(应用程序编程接口)为其中的游戏设计。游戏运行在各种平台上，包括虚拟平台机器用于浏览器为基础的游戏到专用的游戏控制台使用专业的硬件和API。</strong></p>
<p>  <strong>在过去，面向单一平台设计游戏是很常见的。随着游戏开发成本的增加，这种情况变越来越罕见;多平台游戏现在发展是常态。开发成本的增量增加支持多个平台的回报是潜在的两倍或三倍客户基础。</strong>  </p>
<p><strong>有些平台的定义相当松散。例如，当开发一个针对Windows PC平台的游戏，开发商必须占非常大的份额各种可能的硬件配置。游戏甚至被期望运行（运行良好）在游戏开发时不存在的PC配置上！这是唯一可能的，因为API提供了抽象定义Windows平台。</strong></p>
<p><strong>开发人员解释图形性能差异的一种方法是通过缩放调整图形质量响应系统的能力。这可以确保低端系统的合理性能，同时在高性能系统上实现有竞争力的视觉效果。这种调整是有时通过分析系统性能自动完成，但更多的这个控制是留给用户的，他们可以最好地判断自己的个人对质量和速度的偏好。显示分辨率是最容易调整的，伴随着抗锯齿质量降低。提供多种质量也是相当普遍的级别的视觉效果，如阴影和运动模糊，包括选项完全关闭效果。</strong></p>
<p>  <strong>图形性能的差异可能非常大，以至于一些机器可能不能以可玩的帧率运行游戏，即使是在最低质量设置下;  因为这个原因，PC游戏开发者发行了最低和推荐的机器配置为每个游戏。</strong>  </p>
<p><strong>作为平台，游戏主机有着严格的定义。在开发游戏时例如，对于任天堂的Wii主机，开发者清楚地知道它的硬件是什么游戏将继续进行。如果平台的硬件实现发生了变化(经常发生为了降低制造成本)，控制台制造商必须确保新实现的行为与前一个完全相同，包括计时和性能。这并不是说主机开发者的任务很简单;共同唯一的API往往更抽象，更接近底层硬件。这给主机开发带来了一系列困难。在某种意义上，多平台开发(通常至少包括两个不同的控制台，通常还有Windows)是最困难的，因为它是多平台的游戏开发者既没有固定平台的保证，也没有便利性一个高级API。</strong></p>
<p><strong>基于浏览器的虚拟机(如Adobe Flash)是一个有趣的类的游戏平台。虽然这样的虚拟机运行在一个广泛的硬类软件从个人电脑到手机，抽象程度高提供了一个稳定统一的虚拟机开发平台的形式。这些平台的相对容易的开发和巨大的池对游戏开发者来说，潜在用户的吸引力越来越大。然而，这些平台是由最小公分母定义的支持的硬件，和虚拟机的性能低于本地任何给定平台上的代码。由于这些原因，此类平台最适合对图像要求不高的游戏。</strong></p>
<p><strong>平台的特点还包括对开发的开放性是商业或法律上的区别，而不是技术上的区别。例如,Windows是开放的，因为开发工具是广泛可用的，而且没有把关人控制着进入Windows游戏市场。Apple的iPhone在某种程度上是一个受限的平台，因为所有应用程序都需要它通过认证程序和某些类别的申请是禁止的正确的。主机是最严格的游戏平台，对开发工具的访问受到严格控制。这在某种程度上是开放的引入更开放的在线游戏机游戏市场。一个最有趣的例子就是微软的Xbox LIVE社区游戏服务，其中开发工具是免费可用的，并且“把关”主要由同行评审来完成。通过此服务分发的游戏为了安全起见，必须使用Microsoft提供的虚拟机平台。</strong></p>
<p><strong>游戏平台决定了游戏体验的许多元素。为例如，PC游戏玩家使用键盘和鼠标，而主机游戏玩家使用特殊的游戏控制器。许多主机游戏都支持多人游戏主机，要么共享一个屏幕，要么为每个玩家提供一个窗口。由于很难共享键盘和鼠标，这种类型的游戏在PC上是找不到的。比触摸屏电话等一个手持游戏系统将有一个不同的控制方案。</strong></p>
<p><strong>尽管游戏平台千差万别，但还是有一些共同的趋势。大多数平台都有多个处理内核，分为通用内核(CPU)和图形专用(GPU)。随着时间的推移，性能的提高是主要原因增加核心数;个别核心业绩的增长幅度不大。像GPU内核在通用性上不断增长，GPU和CPU内核之间的界线越来越模糊。存储容量的增长速度往往比处理速度慢功率和通信带宽（核心之间以及每个核心与存储之间）的增长速度仍然较慢。</strong></p>
<h2 id="Limited-Resources-有限资源"><a href="#Limited-Resources-有限资源" class="headerlink" title="Limited Resources 有限资源"></a>Limited Resources 有限资源</h2><p>  <strong>游戏图形的主要挑战之一是需要管理多个图形有限的资源池。每个平台都对硬件资源（如处理时间、存储和内存带宽）施加了自己的限制。至少更高层次的发展资源也需要管理；有一个固定的尺寸由程序员、艺术家和游戏设计师组成的团队，完成时间有限这场比赛，希望没有太多的加班！这需要采取行动在决定采用哪种图形技术时要考虑到这一点。</strong></p>
<h3 id="Processing-Time-处理时间"><a href="#Processing-Time-处理时间" class="headerlink" title="Processing Time 处理时间"></a>Processing Time 处理时间</h3><p>  <strong>早期的游戏开发者只需要担心单个处理器的预算。  当前的游戏平台包含多个CPU和GPU内核。这些处理器,  为了避免死锁或过度，需要小心地同步处理。</strong>  </p>
<p>  <strong>由于单个呈现命令所消耗的时间是高度可变的，图形处理器通过命令与系统的其他部分解耦缓冲区。这个缓冲区充当一个队列;命令存储在一端，GPU从另一个GPU读取渲染命令。增加这个的缓冲大小降低GPU资源不足的可能性。这在游戏中是很常见的，缓冲整个帧的渲染命令值，然后将它们发送到GPU;这保证了GPU不会出现资源不足的情况。然而，这种方法需要为两个完整帧的命令预留足够的存储空间  (GPU在其中一个上工作，而CPU在另一个上存放命令)。它也增加了用户输入和显示之间的延迟，这对于快节奏的游戏来说是个问题。</strong></p>
<p><strong>处理预算由帧速率(即频率)，帧缓冲区会被场景的新渲染图刷新。固定平台(如主机)，用户体验到的帧率基本上是游戏开发者也看到了同样的情况，所以帧率限制是相当严格的实施。大多数游戏的帧率都是30帧每秒(fps);在游戏中在响应延迟特别重要的地方，目标通常是60帧/秒。在高度可变的平台(如pc)，帧速率预算（根据需要）定义更加宽松。</strong> </p>
<p>  <strong>所需的帧率给图形程序员一个固定的预算框架工作。在30fps的情况下，CPU核心有33毫秒时间来收集输入，处理游戏逻辑，执行任何物理模拟，遍历场景描述，并向图形硬件发送渲染命令。同时，其他任务，如音频和网络处理必须处理，有自己所需的响应时间。当这一切发生的时候，GPU通常会执行在上一阶段提交的图形命令框架。</strong>  </p>
<p>  **在大多数情况下，CPU核是一个同质资源;所有的核心都是一样的，它们中的任何一种都同样适合给定的工作量(有一些 例外情况，如索尼PLAYSTATION 3游戏机中使用的Cell处理器)。  **</p>
<p><strong>相反，GPU包含异构的资源组合，每一种都是特殊的变成了一套特定的任务。其中一些资源由固定功能组成硬件(用于三角形栅格化、alpha混合和纹理采样)  有些是可编程核心。在较老的GPU上，可编程核心更进一步区分为顶点和像素处理核;更新的GPU设计有统一着色器核心，可以执行任何可编程着色器类型。</strong></p>
<p><strong>这些异构资源是单独预算的。通常，在任何时候，只有一种资源类型会成为瓶颈，其他的资源类型会过剩。一方面，这是好事，因为这种能力可以被利用在不降低性能的情况下提高视觉质量。另一方面，使它更难提高性能，因为减少使用任何非瓶颈资源将没有影响。即使减少瓶颈资源的使用，也只能略微提高性能，具体取决于“下一个瓶颈”的利用率。</strong>  </p>
<h3 id="Storage-存储"><a href="#Storage-存储" class="headerlink" title="Storage 存储"></a>Storage 存储</h3><p>  <strong>游戏平台，像任何现代计算系统一样，拥有多级存储层次结构，顶部的内存类型更小、更快，而更大、更慢储存在底部。这种安排完全是出于工程需要尽管这让开发商的生活变得更加复杂。大多数平台包括光学磁盘存储，速度极慢，主要用于传输。在Windows等平台上，一次移动需要执行一个漫长的安装过程， 所有的数据从光盘到硬盘驱动器，速度明显加快。光盘将不再使用(除非作为反盗版措施)。在控制台平台，这是不常见的，尽管硬盘保证存在，就像在索尼的PLAYSTATION 3游戏机上一样。  更常见的情况是，硬盘驱动器（如果有）仅用作光盘驱动器的缓存圆盘。</strong>  </p>
<p>  <strong>内存层次结构的下一步是RAM，它在许多平台上都是分为一般系统RAM和VRAM(视频RAM)，得益于图形硬件的高速接口。在RAM中，游戏级别可能太大，在这种情况下，游戏开发人员需要管理移动数据根据需要进出RAM。在Windows等平台上，虚拟内存常用于此。在控制台平台上，自定义数据流和缓存系统通常被采用。</strong>  </p>
<p>  <strong>最后，CPU和GPU都拥有各种各样的片上内存和缓存。这些都是非常小和快速的，通常由图形API管理。</strong>  </p>
<p>  <strong>图形资源占用大量的内存，所以它们是游戏开发中的存储预算主要的焦点。纹理通常是最好的记忆消费者，其次是几何图形(顶点数据)，最后是其他类型的图形数据，如动画。并不是所有的内存都可以用于图形，音频也占用相当多的空间，游戏逻辑可能会使用相当大的数据结构。在这种情况下  在处理时间方面，预算在Windows上比较宽松，因为用户系统中存在的内存的确切数量是未知的和虚拟的，记忆能掩盖许多罪孽。相反，主机上的内存预算平台是非常严格的——通常主程序员会跟踪内存，电子表格和程序员需要更多的内存，因为他们的系统需要向别人乞讨、借或偷。</strong>  </p>
<p>  <strong>内存层次结构的不同层次不仅在大小上不同，而且在访问速度上也不同。这有两个独立的维度:延迟和带宽。</strong>  </p>
<p>  <strong>延迟是存储访问请求和最终请求之间所经过的时间满足。 这从几个时钟周期(对于芯片缓存)到数百万个时钟周期不等时钟周期(用于光盘上的数据)。 延迟通常是读取的问题访问(尽管如果需要读取结果，写延迟也可能是一个问题很快从记忆中恢复)。 在某些情况下，读请求是阻塞的意味着提交读操作的处理器核心不能做其他任何事情，直到请求履行。 在其他情况下，读取是非阻塞的; 处理核心是否可以提交读请求，做其他类型的处理，然后使用结果在它到达之后。 GPU访问纹理就是一个例子非阻塞读取; GPU设计的一个重要方面是找到“隐藏”的方法纹理读取时执行不相关的计算导致纹理读取延迟被实现了。</strong></p>
<p><strong>为了这个延迟隐藏工作，必须有足够的计算量相对于纹理访问。这是着色器的一个重要考虑事项;计算和纹理访问的最佳组合一直在变化（有利于更多的计算），因为内存无法跟上处理量的增加强度。</strong>  </p>
<p>  <strong>带宽是指与存储器之间的最大传输速率。它是通常以每秒十亿字节计算。</strong>  </p>
<h3 id="Development-Resources-开发资源"><a href="#Development-Resources-开发资源" class="headerlink" title="Development Resources 开发资源"></a>Development Resources 开发资源</h3><p>  <strong>除处理能力、存储空间等硬件资源外，存储系统还提供了硬件资源，游戏图像程序员还必须应对另一种限制资源——队友的时间!在选择图形技术时，实施每一项技术所需要的工程资源必须考虑到交流中以及计算输入数据所需的任何工具(在许多情况下，工具可能比实现技术本身花费更多的时间)。也许最重要的是，对艺术家生产力的影响必须考虑到计数。大多数图像技术使用的是由游戏美术人员创造的资产这是现代游戏团队中最大的组成部分。图形程序员必须培养艺术家的生产力和创造力，这将最终决定游戏的视觉质量。</strong>  </p>
<h2 id="Optimization-Techniques-优化技术"><a href="#Optimization-Techniques-优化技术" class="headerlink" title="Optimization Techniques 优化技术"></a>Optimization Techniques 优化技术</h2><p>  <strong>明智地使用这些有限的资源是游戏图形程序员的主要挑战。为此，各种优化技术是常见的。</strong>  </p>
<p>  <strong>在许多游戏中，像素着色器处理是主要的瓶颈。大多数GPU包含分层深度剔除硬件，可避免执行像素遮蔽表面上的着色器。为了更好地利用这种硬件，不透明的对象  可以颠倒过来。或者，最佳的深度筛选使用是通过执行深度预压实现，即将所有不透明对象呈现为渲染前的深度缓冲(没有任何颜色输出或像素着色器)  正常的场景。这确实会引起一些开销(由于需要渲染每个  对象两次)，但在许多情况下，性能增益是值得的。</strong>  </p>
<p>  <strong>渲染对象的最快方法是根本不渲染它;因此,任何方法早期识别物体被遮挡是有用的。这节省了除了像素处理，还有顶点处理，甚至是CPU将对象提交给图形API的时间。视图截锥剔除(见  章节8.4.1)是普遍使用的，但在许多游戏中这是不够的。利用数据结构，经常使用高级遮挡剔除算法例如PVS(潜在可见集)或BSP(二进制空间分区)树迅速缩小潜在可见物体的范围。</strong>  </p>
<p>  <strong>即使一个物体是可见的，它的大部分细节也可能因为距离太远而无法看到可以去除而没有明显的效果。LOD(细节层次)算法渲染基于距离(或其他因素，例如屏幕覆盖率或重要性)。这可以节省大量的处理，尤其是顶点处理。示例如下图所示。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029163858.png" class="" title="image-20211029163858">

<p>  这是两个具有不同细节级别的游戏对象的例子。小插图说明可以使用简化模型的相对尺寸。  </p>
<p>  <strong>在许多情况下，处理可以在游戏开始之前执行。这种预处理的结果可以存储和使用在每一帧，从而提高速度的游戏。最常用的是照明，在全局照明算法被用来计算整个场景的照明和存储在光照贴图和其他数据结构中，以供以后使用。</strong>  </p>
<h2 id="Game-Types-游戏类型"><a href="#Game-Types-游戏类型" class="headerlink" title="Game Types 游戏类型"></a>Game Types 游戏类型</h2><p>  <strong>由于游戏的要求千差万别，所以图像技术的选择也是如此受所开发游戏类型的驱动。</strong>  </p>
<p>  <strong>处理时间的分配很大程度上取决于帧速率。最近，大多数主机游戏的目标是每秒30帧，因为这使得游戏有更高的图像质量。然而，某些游戏类型具有快速的玩法需要非常低的延迟，这种游戏通常以60帧每秒的速度渲染。</strong>  </p>
<p>  <strong>这包括像《吉他英雄》这样的音乐游戏和第一人称射击游戏《使命召唤》。</strong>  </p>
<p>  <strong>帧率决定了渲染场景的可用时间。混合涂料,  场景本身的位置也因游戏而异。大多数游戏背景几何(风景，大多是静态的)和前景之间的一种划分几何学(人物和动态对象)。处理方式不同渲染引擎。例如，背景几何通常有光照贴图包含预计算的光照，这对前景对象是不可行的。预先计算的光照通常通过某种类型应用于前景对象体积表示，可以考虑每个位置的变化随着时间的推移对象。</strong>  </p>
<p>  <strong>有些游戏有相对封闭的环境，其中摄像机基本上是已经固定的。最纯粹的例子就是《华尔街》之类的格斗游戏《Fighter》系列，但在某种程度上这也适用于《Devil May Cry》和《战神》等游戏。这些游戏有摄像机，不受直接的玩家控制，游戏往往从一个封闭的环境移动到另一个封闭的环境，在每款游戏中投入大量时间。这允许游戏开发人员浪费大量资源(处理、存储和美工时间)  在每个房间或封闭的环境中，产生非常高水平的图形。</strong>  </p>
<p>  <strong>其他游戏拥有非常大的世界，玩家可以在其中自由移动。对于《侠盗猎车手》系列等“沙盒游戏”来说更是如此以及《魔兽世界》等在线角色扮演游戏。这样的游戏对图形开发人员是巨大的挑战，因为资源分配是非常困难的，因为在每一帧中，玩家都能看到广阔的世界。更复杂的事情是，玩家可以自由地去一些以前遥远的部分并近距离观察它。这类游戏通常有变化的时间这使得预先计算光照是不可能，也是非常困难的。</strong>  </p>
<p>  <strong>大多数游戏，如第一人称射击游戏，介于两者之间。玩家可以在每一帧中看到相当数量的场景，但移动除外整个游戏世界都是受限的。许多游戏也有固定的每个游戏关卡的一天时间，以方便照明预计算。</strong>  </p>
<p>  <strong>渲染的前景对象的数量在不同的游戏中也有很大的不同类型。实时策略游戏，如《命令与征服》系列在屏幕上有几十个，甚至上百个单位。其他类型的在格斗游戏中，可见角色的数量较为有限。另一个极端，只有两个角色可见，每个都呈现非常详细。必须区分角色在任何时间可见(影响处理时间的预算)和在短时间内可能可见的唯一角色的数量(这会影响存储预算)。</strong>  </p>
<p>  <strong>游戏的类型或类型也决定了观众对图形的期望。例如，第一人称射击游戏在历史上就拥有非常高的关卡图像保真度，这一期望推动着图像设计的发展这类型的新游戏;参见下图。另一方面，益智游戏拥有通常都有相对简单的图像，所以大多数游戏开发者不会在这类游戏的图像投入大量的编程或艺术资源来开发逼真的照片。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029165909.png" class="" title="image-20211029165909">

<p>  《孤岛危机》体现了第一人称射击游戏所期望的逼真和详细的图像。  图片由Crytek。  </p>
<p>  <strong>虽然大多数游戏的目标都是逼真的外观，但也有少数游戏做了更多尝试程式化的呈现。一个有趣的例子是《Okami》  如下图所示。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029170006.png" class="" title="image-20211029170006">

<p>  一个来自游戏《Okami》的高度风格化、非真实感渲染的例子。  图片由Capcom娱乐公司提供。  </p>
<p>  <strong>开发资源的管理也因游戏类型而异。大多数游戏的开发周期是1 - 2年，之后就结束了  游戏的发售。最近，可下载内容变得很普遍  (DLC)，可以在游戏发售后购买，因此需要为此保留一些开发资源。持久世界的网络游戏是一个永远不会结束不断生成新内容的开发过程，至少只要游戏具有经济可行性(这可能是几十年)。</strong>  </p>
<p>  <strong>创造性开发的具体要求和限制特定游戏是熟练的游戏图像程序员的特征。《小小大星球》便是一个例子，它拥有一个“2.5维”空间。游戏世界包含少量的二维层，以及一个非交互的背景。这款游戏的图像质量很好，通过使用专门针对此类环境的特殊渲染技术驱动;参见下图。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029170618.png" class="" title="image-20211029170618">

<p>  《小小大星球》的开发者仔细选择了适合游戏的技术限制条件，将它们以不同寻常的方式结合在一起，以达到惊人的效果。小小大星球©2007索尼电脑娱乐欧洲。由Media Molecule开发。小小大星球是一个商标索尼电脑娱乐欧洲。  </p>
<h2 id="The-Game-Production-Process-游戏制作流程"><a href="#The-Game-Production-Process-游戏制作流程" class="headerlink" title="The Game Production Process 游戏制作流程"></a>The Game Production Process 游戏制作流程</h2><p>  <strong>游戏制作过程始于基本的游戏设计或概念。在某些情况下(如续作)，基本玩法和视觉设计是清晰的，只有渐进式的改变。对于新游戏类型来说，需要大量的原型来决定游戏玩法和设计的必要元素。大多数情况下在中间的什么地方，其中有一些新的游戏元素，视觉设计有些开放。在这一步之后，可能会有一个绿灯阶段，将一些早期的演示版本或概念呈现给游戏发行商以获得批准（和资金！）。</strong>  </p>
<p>  <strong>下一步通常是预制作。而其他团队正在工作在完成最后一款游戏时，一个小型核心团队负责制作任何需要的内容改变游戏引擎和制作工具链，以及解决任何新玩法元素的粗略细节。这个核心团队是在严格的期限。在现有的游戏发行和团队的其他成员回来之后，从一个应得的假期，整个工具链和引擎必须准备好。如果核心团队错过了这一期限，可能会有几十名开发人员无所事事——一个极其昂贵的提议!</strong>  </p>
<p>  <strong>下一步是完整的制作，与整个团队创造美术资产，设计关卡，调整游戏玩法，并进一步改变游戏引擎。在一个完美的世界里，在这个过程中所做的一切都将被用于这是最终的游戏，但实际上游戏开发具有迭代性质这将导致一些工作被丢弃和重做。我们的目标是通过仔细的规划和原型设计将其最小化。</strong>  </p>
<p>  <strong>当游戏功能完成时，最后一个阶段就开始了。Alpha版本通常是指标志着扩展开始的版本内部测试，beta版的发布标志着外部扩展的开始测试，从黄金版到最终版提交给主机制造商，但不同的公司对这些术语的定义略有不同。无论如何案例、测试或质量保证（QA）是该阶段的重要组成部分，并且包括游戏开发工作室、发行商和控制台的测试人员制造商，可能还有外部QA承包商。这些不同的回合测试结果的错误报告将提交给游戏开发者一直工作到下一个版本。</strong>  </p>
<p>  <strong>游戏发行后，大多数开发者会去度假，但是一个小团队可能不得不留下来开发补丁或可下载内容。与此同时，一个小型核心团队正在为下一款游戏进行前期制作。</strong>  </p>
<p>  <strong>美术资产创造是游戏制作的一个重要方面到图形开发，所以将详细介绍。</strong> </p>
<h3 id="Asset-Creation-资产创造"><a href="#Asset-Creation-资产创造" class="headerlink" title="Asset Creation 资产创造"></a>Asset Creation 资产创造</h3><p>  <strong>虽然美术资产创造的确切过程因游戏而异，但其轮廓却不尽相同，我在这里给的都是相当有代表性的。在过去，一个艺术家可以创造整个资产从开始到结束，但这个过程现在更加专业化了，让拥有不同技能的人在不同的时间处理不同的资产。有些阶段有明显的依赖性(例如，角色就不能被删除，需要有动画它才能被操纵，它被建模之前不能被操纵)。大多数游戏  开发者有明确的审批流程，其中包括艺术总监或主管美工在每个阶段签字，才将资产发送到下一个阶段。理想情况下一个资产在每个阶段只进行一次，但在实践中可能会发生变化要求重新提交。</strong>  </p>
<h4 id="Initial-Modeling-最初的建模"><a href="#Initial-Modeling-最初的建模" class="headerlink" title="Initial Modeling   最初的建模"></a>Initial Modeling   最初的建模</h4><p>  <strong>通常情况下，美术资产创建过程是从对象几何建模开始的。这一步是在通用建模包中执行的，例如Maya， MAX或Softimage。建模的几何图形将直接传递给游戏引擎，因此，在保持良好的轮廓的同时，最小化顶点数是很重要的。角色网格也必须被构建，以便制作动画。</strong>  </p>
<p>  <strong>在此阶段，通常会创建纹理的二维曲面参数化。这一参数化必须高度连续，因为<br>不连续性要求顶点重复，并可能导致过滤瑕疵。网格及其相关纹理参数化示例如下图所示。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029183652.png" class="" title="image-20211029183652">

<p>一个网格模型在Maya，与相关的纹理参数化。</p>
<h3 id="Texturing-纹理"><a href="#Texturing-纹理" class="headerlink" title="Texturing  纹理"></a>Texturing  纹理</h3><p>  <strong>在过去，纹理通常是在Photoshop中绘制彩色纹理的简单过程。现在，专门的细节建模包，如ZBrush或Mudbox通常用于雕刻精细的表面细节。下两图和展示这个过程的一个例子。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184059.png" class="" title="image-20211029184059">

<p>  上图中的网格被引入ZBrush中进行细节建模。  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184120.png" class="" title="image-20211029184120">

<p>  上图中的网格，在ZBrush中添加了精细的细节。 </p>
<p>  <strong>如果这个额外的细节用实际的几何学来表示，需要几百万三角形。相反，细节通常“烘培”成法线贴图被应用到原始的粗网格上，如下两图。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184455.png" class="" title="image-20211029184455">

<p>  一个可视化(在ZBrush)的网格从上上图，渲染法线源自上图中的详细网格。图的底部显示了为ZBrush的“Zmapper”工具，用于导出法线贴图。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184508.png" class="" title="image-20211029184508">

<p> 上图中使用的法线贴图。在这张图片中，红色、绿色和蓝色的通道的纹理包含表面法线的X, Y和Z坐标。</p>
<p>  <strong>除了法线贴图，还有多个纹理包含表面属性，如漫反射颜色、镜面颜色和平滑度(镜面强度)也被创建。这些要么是直接绘制在表面上的细节建模应用程序，或者在二维应用程序，如Photoshop。所有这些纹理贴图使用在初始建模阶段定义的表面参数化。当肌理是在二维绘画中应用的，艺术家必须频繁地在绘画应用和其他应用之间切换，可以显示物体的三维渲染与应用纹理。这个迭代过程如下列一系列图所示。</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029184955.png" class="" title="image-20211029184955">

<p>  上上图中网格的漫反射颜色纹理的早期版本，如图所示Photoshop。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029185010.png" class="" title="image-20211029185010">

<p>  一个渲染(在ZBrush)的网格法线贴图和早期漫反射颜色纹理  (由上图)适用。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029185024.png" class="" title="image-20211029185024">

<p>  颜色纹理的最终版本来自上上图。</p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029185037.png" class="" title="image-20211029185037">

<p>  使用法线贴图和最终颜色纹理渲染网格(来自上图)  应用。</p>
<h4 id="Shading-着色-1"><a href="#Shading-着色-1" class="headerlink" title="Shading 着色"></a>Shading 着色</h4><p>  <strong>着色器通常应用于与初始建模相同的应用程序中。在这个过程中，将应用着色器（来自为该游戏定义的着色器集）到网格。细节建模阶段产生的各种纹理如下所示：使用在过程中定义的曲面参数化作为该着色器的输入应用初始建模。通过视觉实验设置各种其他着色器输入（“调整”）；见下图</strong>  </p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029185551.png" class="" title="image-20211029185551">

<p>  Maya中的着色器配置。右边的界面用来选择着色器，将纹理分配给着色器输入，并设置非纹理着色器输入的值(例如“Specular”颜色”和“Specular Power”滑块)。左边的呈现是动态更新的修改，可以立即获得视觉反馈。</p>
<h4 id="Lighting-照明"><a href="#Lighting-照明" class="headerlink" title="Lighting 照明"></a>Lighting 照明</h4><p><strong>在背景场景中，在完成建模、纹理和着色后，灯光艺术家通常会开始他们的工作。光源是在预处理步骤中放置并计算其效果。此过程的结果存储在光照贴图中，供渲染引擎稍后使用。</strong></p>
<h4 id="Animation-动画"><a href="#Animation-动画" class="headerlink" title="Animation 动画"></a>Animation 动画</h4><p><strong>角色网格将经历与动画相关的几个附加步骤。用于设置游戏角色动画的主要方法是蒙皮。这需要一个rig，由附加到角色的变换节点的层次结构组成，该过程称为装配。将绘制每个变换节点的效果区域在网格顶点的子集上。最后，动画师创建移动的动画，旋转并缩放这些变换节点，“拖动”它们后面的网格。</strong></p>
<p><strong>一个典型的游戏角色将有几十个动画，对应于不同的运动模式（行走、跑步、转弯）以及不同的动作攻击等行为。对于主要角色，动画的数量可能有几百个。不同动画之间的过渡也需要进行调整定义。</strong><br><strong>对于面部动画，另一种称为“变形目标”的技术有时会被使用。在该技术中，直接操纵网格顶点以使其变形网格。存储变形网格的不同副本（例如，对于不同的面部表情），并在运行时由游戏引擎组合。创造变形目标如下图所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029190132.png" class="" title="image-20211029190132">

<p>  Maya中的变形目标界面。底行显示四个不同的变形目标，顶部的模型显示了将多个变形目标组合在一起的效果。接口左上角用于控制应用每个变形目标的程度。</p>
<h1 id="26-Visualization-可视化"><a href="#26-Visualization-可视化" class="headerlink" title="26 Visualization 可视化"></a>26 Visualization 可视化</h1><p><strong>计算机图形学的一个主要应用领域是可视化，其中计算机生成的图像被用来帮助人们理解空间和非空间数据。当目标是在问题定义不充分、计算机无法通过算法处理的情况下增强人类的能力时，就会使用可视化。如果一个完全自动化的解决方案可以完全取代人类的判断，那么可视化通常就不需要了。可视化可以用于在探索完全不熟悉的数据集时生成新的假设，在部分理解的数据集中确认现有假设，或者向其他观众展示已知数据集的信息。</strong></p>
<p><strong>视觉化让人们把认知卸给感知系统，使用精心设计的图像作为外部记忆的一种形式。人类的视觉系统是通往大脑的一个非常高带宽的通道，有大量的处理是在前意识水平平行发生的。因此，我们可以用外部图像来代替对自己头脑中事物的追踪。举个例子，让我们考虑一下理解《G¨model, Escher, Bach: the Eternal Golden Braid》(Hofstadter, 1979)一书中一些主题子集之间的关系;参见下图。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029235929.png" class="" title="image-20211029235929">

<p>使用文本列表来记录主题之间的关系是很困难的。</p>
<p><strong>当我们把数据集看作一个文本列表时，在低水平时，我们必须阅读单词，并将它们与之前阅读的单词的记忆进行比较。仅凭认知和记忆很难追踪这十几个主题，更不用说整本书中的数百个主题了。更高层次的识别社区的问题，例如找到所有距离目标主题悖论两步远的主题，是非常困难的。</strong></p>
<p><strong>下图以节点链接图的形式显示了相同数据集的外部可视化表示，其中每个主题都是一个节点，两个主题之间的链接直接用一条线显示。通过在图像周围移动我们的眼睛来跟随线条是一种快速、低水平的操作，具有最小的认知负荷，因此更高层次的邻居发现成为可能。节点的位置和它们之间的链接路径是由点图绘制程序自动创建的(Gansner, Koutsofois, North， &amp; Vo, 1993)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211029235951.png" class="" title="image-20211029235951">

<p>用感知代替认知和记忆，我们就能理解关系快速在书的主题之间切换。</p>
<p><strong>我们将数据集属性到可视化表示的映射称为可视化编码。可视化的核心问题之一是从可能的视觉表示的巨大空间中选择合适的编码，同时考虑到人类感知系统的特征、存在问题的数据集和手头的任务。</strong></p>
<h2 id="Background-背景"><a href="#Background-背景" class="headerlink" title="Background 背景"></a>Background 背景</h2><h3 id="History-历史"><a href="#History-历史" class="headerlink" title="History 历史"></a>History 历史</h3><p><strong>人们通过静态图像传达意义的历史悠久，可以追溯到3万多年前已知的最古老的洞穴壁画。今天，我们继续以各种方式进行视觉交流，从餐巾背面的草图到光滑的广告平面设计。几千年来，制图师们一直在研究如何绘制能代表我们周围世界某些方面的地图。18世纪，William Playfair (Friendly, 2008)首次创造了抽象、非空间数据集的视觉表示。</strong></p>
<p><strong>尽管我们已经有能力创建动态图像超过150年，交互式创建动态图像是最近的发展，只有在过去几十年快速计算机图形硬件和算法的广泛可用性才成为可能。微小数据集的静态可视化可以手工创建，但计算机图形使大数据集的交互式可视化成为可能。</strong></p>
<h3 id="Resource-Limitations-资源限制"><a href="#Resource-Limitations-资源限制" class="headerlink" title="Resource Limitations 资源限制"></a>Resource Limitations 资源限制</h3><p><strong>在设计可视化系统时，我们必须考虑三种不同的限制:计算能力、人类感知和认知能力以及显示能力。</strong></p>
<p><strong>与任何计算机图形的应用程序一样，计算机时间和内存是有限的资源，我们经常有硬约束。如果可视化系统需要提供交互式响应，那么它必须使用能够在几分之一秒而不是几分钟或几小时内运行的算法。</strong></p>
<p><strong>在人类方面，记忆和注意力必须被认为是有限的资源。众所周知，人类的记忆是有限的，无论是长期回忆还是短期工作记忆。在本章的后面，我们将讨论一些低水平视觉注意机制的能力和局限性，这些机制执行了大量的视野平行处理。令人惊讶的是，我们在视觉工作记忆中内部存储的信息很少，这让我们很容易发生变化盲视(change blindness)，这种现象是，如果我们在关注我们认为的其他事情，即使是非常大的变化也不会被注意到(Simons, 2000)。此外，警惕也是一种非常有限的资源;我们执行视觉搜索任务的能力迅速下降，几个小时后的结果比最初几分钟的结果差得多(Ware, 2000)。</strong></p>
<p><strong>显示能力是要考虑的第三种限制。可视化设计人员经常“用光像素”，因为屏幕的分辨率不够大，无法同时显示所有所需信息。特定帧的信息密度是编码的信息量与未使用空间的比值。同时显示尽可能多的内容(以最小化导航和探索的需求)和同时显示过多内容(用户会被视觉混乱所淹没)的成本之间存在权衡。</strong></p>
<h2 id="Data-Types-数据类型"><a href="#Data-Types-数据类型" class="headerlink" title="Data Types 数据类型"></a>Data Types 数据类型</h2><p><strong>可视化设计的许多方面是由我们需要查看的数据类型驱动的。例如，它是一个数字表，还是一组项目之间的关系，或固有的空间数据，如地球表面的位置或文档的集合?</strong></p>
<p><strong>我们首先考虑一个数据表。我们称行为数据项，列为维度，也称为属性。例如，行可能表示人，列可能是姓名、年龄、身高、衬衫尺寸和喜欢的水果。</strong></p>
<p><strong>我们区分了三种类型的维度:定量的、有序的和分类的。数量数据，如年龄或身高，是数值的，我们可以对其进行计算。例如，68英寸减去42英寸等于26英寸。对于有序的数据，比如衬衫尺寸，我们无法进行完整的运算，但有一个明确定义的顺序。例如，大减去中不是一个有意义的概念，但我们知道中介于小和大之间。分类数据，比如喜欢的水果或名字，没有隐式的排序。我们只能区分两个东西是相同的(苹果)还是不同的(苹果vs香蕉)。</strong></p>
<p><strong>关系数据或图形是另一种数据类型，其中节点通过链接连接。一种特定的图是树状图，它通常用于分层数据。节点和边都可以有关联的属性。不幸的是，单词图在可视化方面超载了。我们在这里讨论的节点-链接图，按照图论和图绘制的术语，也可以称为网络。在统计图形领域，graph常用于chart，如图26.10所示的时间序列数据折线图。</strong></p>
<p><strong>有些数据本质上是空间的，比如地理位置或三维空间的测量场，如医生用来查看人体内部结构的MRI或CT扫描。的信息,与空间中的每个点相关联的可能是标量、索引向量或张量的无序集合。相反，非空间数据可以使用空间位置进行可视化编码，但是这种编码是由设计人员选择的，而不是在数据集本身的语义中隐式给出的。这个选择是可视化设计中最核心和最困难的问题之一。</strong></p>
<h3 id="Dimension-and-Item-Count-尺寸和项目计数"><a href="#Dimension-and-Item-Count-尺寸和项目计数" class="headerlink" title="Dimension and Item Count 尺寸和项目计数"></a>Dimension and Item Count 尺寸和项目计数</h3><p><strong>需要可视化编码的数据维的数量是可视化设计问题的最基本方面之一。适用于只有几个列的低维数据集的技术，在具有几十或数百列的非常高维数据集上通常会失败。数据维可能具有层次结构，例如时间序列数据集在多个时间尺度上有有趣的模式。</strong></p>
<p><strong>数据项的数量也很重要:对于几百项表现良好的可视化通常不能扩展到数百万项。在某些情况下，难度纯粹是算法上的，计算时间太长;在另一些情况下，这是一个更深层次的感知问题，即使是瞬时算法也无法解决，即视觉混乱会让人无法使用表征。维度中可能值的范围也可能是相关的。</strong></p>
<h3 id="Data-Transformation-and-Derived-Dimensions-数据转换和派生维度"><a href="#Data-Transformation-and-Derived-Dimensions-数据转换和派生维度" class="headerlink" title="Data Transformation and Derived Dimensions 数据转换和派生维度"></a>Data Transformation and Derived Dimensions 数据转换和派生维度</h3><p><strong>作为解决领域问题的可视化管线的一部分，数据经常从一种类型转换为另一种类型。例如，原始数据维可能由定量数据组成:表示温度的浮点数。对于某些任务，比如寻找当地天气模式的异常，原始数据可能会被直接使用。对于另一个任务，比如决定淋浴的水温是否合适，数据可能被转换为一个有序的维度:热、暖或冷。在此转换中，大部分细节都被聚合。在第三个例子中，当烤面包时，一个更有损的转换到分类维度可能就足够了:烤焦或不烤焦。</strong></p>
<p><strong>将数据转换为派生维的原则，而不是简单地以原始形式可视化地编码数据，是一个强大的想法。在图26.10中，原始数据是时间序列曲线的有序集合。这种转换是对数据进行聚类，减少信息量，将其可视化编码为一些高度有意义的曲线。</strong></p>
<h2 id="Human-Centered-Design-Process-以人为本的设计过程"><a href="#Human-Centered-Design-Process-以人为本的设计过程" class="headerlink" title="Human-Centered Design Process 以人为本的设计过程"></a>Human-Centered Design Process 以人为本的设计过程</h2><p><strong>可视化设计过程可以分解为层叠的层集，如下图所示。这些层都是相互依赖的;上面一层的输出被输入到下面一层。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105033.png" class="" title="image-20211030105033">

<p>用于可视化的四个嵌套验证层。</p>
<h3 id="Task-Characterization-任务描述"><a href="#Task-Characterization-任务描述" class="headerlink" title="Task Characterization 任务描述"></a>Task Characterization 任务描述</h3><p><strong>一个给定的数据集有许多可能的可视编码。选择使用哪种视觉编码可以根据某些预期用户的特定需求进行指导。不同的问题或任务需要不同的视觉编码。例如，考虑软件工程领域。图26.11所示的Tarantula接口很好地支持理解测试套件覆盖率的任务。然而，在重构代码的同时理解软件的模块化分解的任务可能会通过更直接地以节点链接图的形式显示其层次结构来更好地完成。</strong></p>
<p><strong>理解某些目标受众的需求是一个棘手的问题。在以人为中心的设计方法中，可视化设计师随着时间的推移与一组目标用户一起工作(C. Lewis &amp; Rieman, 1993)。在大多数情况下，用户知道他们需要以某种方式查看他们的数据，但不能直接将他们的需求作为对数据类型操作的明确任务。迭代设计过程包括通过采访和观察目标用户的工作，从他们那里收集关于问题的信息，创建原型，并观察用户如何与这些原型进行交互，以了解所提议的解决方案实际工作情况。需求分析的软件工程方法论也很有用(Kovitz, 1999)。</strong></p>
<h3 id="Abstraction-抽象"><a href="#Abstraction-抽象" class="headerlink" title="Abstraction 抽象"></a>Abstraction 抽象</h3><p><strong>在第一层中确定特定领域问题之后，下一层需要将其抽象为更通用的表示，作为操作上一节讨论的数据类型。来自非常不同领域的问题可以映射到相同的可视化抽象。这些通用操作包括排序、过滤、特征趋势和分布、发现异常和异常值以及发现相关性(Amar, Eagan， &amp; Stasko, 2005)。它们还包括特定于特定数据类型的操作，例如以图或树的形式跟踪关系数据的路径。</strong></p>
<p><strong>这个抽象步骤通常涉及到从原始数据到派生维的数据转换。这些派生维的类型通常与原始数据不同:图可以转换为树，表格数据可以通过使用阈值来决定是否应该基于字段值存在链接，从而转换为图，等等。</strong></p>
<h3 id="Technique-and-Algorithm-Design-技术与算法设计"><a href="#Technique-and-Algorithm-Design-技术与算法设计" class="headerlink" title="Technique and Algorithm Design 技术与算法设计"></a>Technique and Algorithm Design 技术与算法设计</h3><p><strong>一旦选择了抽象，下一层就是设计适当的视觉编码和交互技术。第26.4节介绍了视觉编码的原则，我们将在第26.5节讨论交互原则。我们将在26.6和26.7节介绍考虑这些原则的技术。</strong></p>
<p><strong>不幸的是，可视化算法的详细讨论超出了本章的范围。</strong></p>
<h3 id="Validation-验证"><a href="#Validation-验证" class="headerlink" title="Validation 验证"></a>Validation 验证</h3><p><strong>这四层中的每一层都有不同的验证需求。</strong></p>
<p><strong>第一层被设计用来确定问题是否被正确的字符化:是否真的有目标受众在执行特定的任务，从而从所建议的工具中获益?测试假设和猜想的一个直接方法是观察或采访目标受众，以确保可视化设计师完全理解他们的任务。在构建和部署工具之前，无法进行的度量是监视其在社区中的采用率，当然，除了效用之外，还有许多其他因素会影响采用率。</strong></p>
<p><strong>下一层用于确定从域问题抽象到特定数据类型的操作是否真正解决了所需的问题。在原型或成品工具部署完成后，可以进行实地研究，以观察其目标用户是否以及如何使用它。此外，该系统产生的图像可以进行定性和定量分析。</strong></p>
<p><strong>第三层的目的是验证设计师所选择的视觉编码和交互技术是否能够有效地传达所选择的内容抽象到用户。一个直接的测试是证明个人的设计选择没有违反已知的感知和认知原则。这样的理由是必要的，但不是充分的，因为可视化设计涉及交互选择之间的许多权衡。系统建成后，可以通过正式的实验室研究对其进行测试。在实验室研究中，许多人被要求完成分配的任务，这样就可以对他们完成任务所需的时间和错误率进行统计分析。</strong></p>
<p><strong>第四层用于验证设计用于进行编码和交互选择的算法比以前的算法更快或占用更少的内存。一个直接的测试是分析所提出算法的计算复杂度。实现后，可以直接测量系统的实际时间性能和内存使用情况。</strong></p>
<h2 id="Visual-Encoding-Principles-视觉编码原理"><a href="#Visual-Encoding-Principles-视觉编码原理" class="headerlink" title="Visual Encoding Principles 视觉编码原理"></a>Visual Encoding Principles 视觉编码原理</h2><p><strong>我们可以将视觉编码描述为图形元素，称为标记，通过视觉渠道传递信息。一个零维度的标记是一个点，一个一维的标记是一条线，一个二维的标记是一个区域，一个三维的标记是一个体积。许多视觉通道可以编码信息，包括空间位置、颜色、大小、形状、方向和运动方向。可以使用多个视觉通道同时编码不同的数据维度;例如，下图显示了如何使用水平和垂直空间位置、颜色和大小来显示四个数据维度。可以使用多个通道对相同的维度进行冗余编码，这样可以显示更少的信息，但显示得更清楚。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105453.png" class="" title="image-20211030105453">

<p>水平和垂直空间位置、颜色和大小这四个视觉通道被用于在散点图图中编码信息。</p>
<h3 id="Visual-Channel-Characteristics-视觉通道特征"><a href="#Visual-Channel-Characteristics-视觉通道特征" class="headerlink" title="Visual Channel Characteristics 视觉通道特征"></a>Visual Channel Characteristics 视觉通道特征</h3><p><strong>视觉通道的重要特征是可区分性、可分离性和弹出性。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105754.png" class="" title="image-20211030105754">

<p>我们感知由视觉通道编码的信息的能力取决于所使用的数据类型，从最准确的顶部到最不准确的底部。</p>
<p><strong>通道并非都是同样可分辨的。人们已经进行了许多心理物理实验，以测量人们对不同视觉通道编码的信息进行精确区分的能力。我们的能力取决于数据类型是定量的、有序的还是分类的。上图显示了这三种数据类型的可视通道的排名。下图显示了Tableau/Polaris系统中可视通道的一些默认映射，其中考虑了数据类型。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105807.png" class="" title="image-20211030105807">

<p>根据数据类型，Tableau/Polaris系统默认映射四个可视通道。</p>
<p><strong>空间位置是三种数据最精确的视觉通道，它主导着我们对视觉编码的感知。因此，两个最重要的数据维度通常映射到水平和垂直空间位置。</strong></p>
<p><strong>然而，其他通道在不同类型之间有很大差异。长度和角度的通道对定量数据的识别能力强，而对有序和分类数据的识别能力差;对比色度对分类数据的识别能力强，对定量数据的识别能力差。</strong></p>
<p><strong>我们必须始终考虑显示数据维所需的动态范围和通道中可用的动态范围之间是否存在良好的匹配。例如，线宽编码使用一维标记和尺寸通道。有宽度有限数量的步骤,我们可以可靠地使用视觉编码信息:至少瘦实施一个像素的屏幕分辨率(忽略反锯齿简化讨论),还有一个最大厚度超过这个对象将被视为一个多边形而不是一条直线。行宽可以很好地在一个数据维中显示3或4个不同的值，但对于数十或数百个值来说，它将是一个糟糕的选择。</strong></p>
<p><strong>有些视觉通道是完整的，在前意识水平上融合在一起的，所以它们不是对不同数据维度进行视觉编码的好选择。另一些是可分离的，在视觉处理过程中它们之间没有交互，可以安全地用于编码多个维度。下图显示了两个通道对。颜色和位置是高度可分的。我们可以看到，水平尺寸和垂直尺寸并不容易区分，因为我们的视觉系统会自动将它们整合到一个统一的区域感知中。大小与许多通道相互作用:随着对象的大小变得更小，它变得更难以区分其形状或颜色。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030105906.png" class="" title="image-20211030105906">

<p>颜色和位置是可分离的通道，非常适合编码不同的数据维，但水平大小和垂直大小的通道会自动融合到区域的集成感知中。</p>
<p><strong>我们可以有选择地关注一个通道，这样特定类型的项目就可以直观地“弹出”，如第20.4.3节所述。视觉弹出的一个例子是，当我们立即在蓝色物品的海洋中发现红色物品，或区分圆圈和正方形。可视化弹出窗口功能强大且可扩展，因为它是并行出现的，不需要逐个处理条目。许多视觉通道都有这种弹出属性，不仅包括上面的列表，还包括曲率、闪烁、立体深度，甚至照明方向。然而，通常情况下，我们一次只能在一个频道上使用弹出窗口。例如，白色圆圈不会从一组可以是白色或黑色的圆圈和方形中弹出，如图20.46所示。当我们需要同时搜索多个通道时，找到目标对象所需的时间与场景中目标的数量成线性关系。</strong></p>
<h3 id="Color-颜色-2"><a href="#Color-颜色-2" class="headerlink" title="Color 颜色"></a>Color 颜色</h3><p><strong>色彩可以是一个非常强大的通道，但许多人不了解它的属性，并使用不当。正如在第20.2.2节中讨论的，我们可以从三个独立的视觉通道来考虑颜色:色相、饱和度和亮度。区域的大小强烈影响我们对颜色的感知能力。小区域的颜色相对难以感知，设计师应该使用明亮、高度饱和的颜色，以确保颜色编码的可识别性。相反的情况是真实的彩色区域是大的，如在背景，低饱和度蜡笔颜色应该使用，以避免观众眼花。</strong></p>
<p><strong>Hue是对分类数据进行编码的有力线索。然而，可用的动态范围是非常有限的。当彩色区域很小且分散在显示器周围时，人们可以可靠地分辨出大约十几个色调。色彩编码的一个很好的指导原则是，类别的数量不要超过8个，记住背景和中性物体的颜色也要算在内。</strong></p>
<p><strong>对于有序数据，亮度和饱和度是有效的，因为它们有一种隐含的感知顺序。人们可以可靠地根据亮度排序，总是把灰色置于黑白之间。在饱和度方面，人们肯定会把不太饱和的粉色放在完全饱和的红色和零饱和的白色之间。然而，色调并不是有序数据的好通道，因为它没有隐含的感知顺序。当被要求对红色、蓝色、绿色和黄色进行排序时，人们并没有给出相同的答案。人们可以也确实学会了惯例，比如交通灯的黄绿红，或者彩虹的颜色顺序，但这些构建都处于一个高于纯粹感知的层次上。有序数据通常用一组离散的颜色值显示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030110331.png" class="" title="image-20211030110331">

<p>标准的彩虹色图有两个缺陷:它使用色相来表示顺序，并且它在感知上不是等线性的。图片由Bernice Rogowitz提供。</p>
<p><strong>定量数据用颜色图显示，颜色值的范围可以是连续的或离散的。在许多软件包中，一个非常不幸的默认值是rainbow彩图，如上图所示。标准的彩虹刻度存在三个问题。首先，色调用来表示秩序。更好的选择是使用亮度，因为它有一种隐含的感知顺序。更重要的是，人眼对亮度的反应最为强烈。第二，这个尺度在感知上不是线性的:在连续范围内的相等步数并不被我们的眼睛感知为相等步数。上图显示了一个示例，其中彩虹色图模糊了数据。从−2000到−1000的范围有三种不同的颜色(青色、绿色和黄色)，而从−1000到0的相同大小的范围看起来完全是黄色的。右边的图表显示，感知价值与亮度紧密相关，亮度在这个尺度上甚至不是单调增加的。</strong></p>
<p><strong>相比之下，下图显示了相同的数据，但使用了更合适的颜色图，亮度单调地增加。Hue用于创建语义上有意义的分类:查看器可以讨论数据集中的结构，如深蓝色的海、青色的大陆架、绿色的低地和白色的山脉。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030110428.png" class="" title="image-20211030110428">

<p>同样的数据集的结构是更加清晰的彩色地图，单调增加的亮度是用来显示秩序，而色调是用来分割分类区域。图片由Bernice Rogowitz提供。</p>
<p><strong>在离散和连续的情况下，颜色图应该考虑数据是连续的还是发散的。ColorBrewer应用程序(<a target="_blank" rel="noopener" href="http://www.colorbrewer.org)是构建颜色图的优秀资源/">www.colorbrewer.org)是构建颜色图的优秀资源</a>(Brewer, 1999)。</strong></p>
<p><strong>用颜色编码的另一个重要问题是，相当一部分人，大约10%的男性，存在红绿颜色缺陷。如果由于目标域中的约定而选择了使用红色和绿色的编码，请重新除了色调之外，用冗余编码亮度或饱和度是明智的。对于色觉有缺陷的人来说，应该使用像<a target="_blank" rel="noopener" href="http://www.vischeck.com这样的工具来检查配色方案是否容易被识别./">http://www.vischeck.com这样的工具来检查配色方案是否容易被识别。</a></strong></p>
<h3 id="2D-vs-3D-Spatial-Layouts-2D-VS-3D空间布局"><a href="#2D-vs-3D-Spatial-Layouts-2D-VS-3D空间布局" class="headerlink" title="2D vs. 3D Spatial Layouts 2D VS 3D空间布局"></a>2D vs. 3D Spatial Layouts 2D VS 3D空间布局</h3><p><strong>空间定位是采用二通道还是三通道的问题已经得到了广泛的研究。20世纪80年代末，当基于计算机的可视化开始时，交互式3D图形是一种新的能力，人们对3D表示有很大的热情。随着该领域的成熟，研究人员开始理解用于抽象数据集的3D方法的成本(Ware, 2001)。</strong></p>
<p><strong>遮挡，即数据集的一些部分隐藏在其他部分后面，是3D的一个主要问题。虽然隐藏的表面去除算法，如z缓冲区和BSP树，允许快速计算正确的二维图像，人们仍然必须将许多这些图像合成到一个内部的心理地图。当人们看到由熟悉的物体制成的真实场景时，通常他们能很快理解所看到的东西。然而，当他们看到一个不熟悉的数据集时，选择的视觉编码将抽象维度映射到空间位置，理解其3D结构的细节可能是具有挑战性的，即使他们可以使用交互式导航控件来改变他们的3D视图。原因再次是人类工作记忆的有限容量(Plumlee &amp; Ware, 2006)。</strong></p>
<p><strong>3D的另一个问题是透视失真。虽然现实世界中的物体在离我们的眼睛较远的时候确实显得更小，但透视缩短使得直接比较物体的高度变得困难(Tory, Kirkpatrick, Atkins， &amp; M¨oller, 2006)。再次强调，尽管我们经常可以根据过去的经验判断现实世界中熟悉的物体的高度，但我们不一定可以用具有视觉编码的完全抽象的数据来判断高度。例如，在3D条形图中判断条形高度比在多个水平对齐的2D条形图中更难。</strong></p>
<p><strong>无约束3D表示的另一个问题是，在3D空间中任意方向的文本比在2D图像平面中对齐的文本更难阅读(Grossman, Wigdor， &amp; Balakrishnan, 2007)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030110927.png" class="" title="image-20211030110927">

<p>上图:这个时间序列数据集的3D表示引入了遮挡和透视失真的问题。底部:派生的聚合曲线和日历的链接2D视图允许直接比较，并显示更细粒度的模式。图片由Jarke van Wijk (van Wijk &amp; van Selow, 1999)提供，©1999 IEEE。</p>
<p><strong>上图说明了精心选择的抽象数据集的2D视图如何避免3D视图中固有的遮挡和透视失真问题。俯视图显示了直接从原始时间序列数据创建的3D表示，其中每个横截面是一个2D时间序列曲线，显示一天的功耗，沿着挤压的第三轴，一年中的每一天都有一条曲线。虽然这种表现方式很容易创建，但我们只能看到大规模的模式，如工作时间的更高消费和冬季和夏季之间的季节性变化。为了在底部创建2D链接视图，曲线是分层聚集的，在同一个2D框架中只绘制代表顶部集群的聚合曲线。直接比较曲线高度在一天的所有时间是很容易的，因为没有透视失真或遮挡。在日历视图中使用了相同的颜色编码，这对于理解时间模式非常有效。</strong></p>
<p><strong>相反,如果一个数据集本质上包括三维空间数据,如显示流体在飞机机翼或医学影像数据集从核磁共振扫描,然后一个3D视图的成本超出了它的好处,帮助用户建立一个有用的心智模型的数据结构。</strong></p>
<h3 id="Text-Labels-文本标签"><a href="#Text-Labels-文本标签" class="headerlink" title="Text Labels 文本标签"></a>Text Labels 文本标签</h3><p><strong>标签和图例形式的文本是创建可视化的一个非常重要的因素，它是有用的，而不仅仅是漂亮的。坐标轴和刻度线应该被标记。图例应表明颜色的意义，无论是作为离散的斑块或连续的颜色坡道使用。数据集中的各个项通常都有与之关联的有意义的文本标签。在许多情况下，始终显示所有标签会导致太多的视觉混乱，因此可以使用标签定位算法显示项目的一个子集的标签，该算法在期望的位置显示标签在避免重叠的同时保持密度(Luboschik, Schumann， &amp; cord, 2008)。一种简单的方法是基于标签重要性的度量使用贪婪算法来选择最优的标签来表示一组项目，但是基于组的特征来合成一个新的标签仍然是一个困难的问题。更以交互为中心的方法是根据用户的交互指示只显示单个项目的标签。</strong></p>
<h2 id="Interaction-Principles-交互原则"><a href="#Interaction-Principles-交互原则" class="headerlink" title="Interaction Principles 交互原则"></a>Interaction Principles 交互原则</h2><p><strong>在设计可视化时，交互的几个原则是重要的。低延迟视觉反馈允许用户更流畅地探索，例如，当光标简单地悬停在一个对象上而不是要求用户显式地单击时，可以显示更多的细节。在与大型数据集交互时，选择项是一项基本操作，因为它可以用高亮显示所选的数据集。颜色编码是突出显示的一种常见形式，但也可以使用其他途径。</strong></p>
<p><strong>许多交互形式都可以根据它们改变了显示的哪个方面来考虑。导航可以被认为是视口的改变。排序是对空间排序的一种改变;也就是说，改变数据映射到空间位置视觉通道的方式。整个视觉编码也可以改变。</strong></p>
<h3 id="Overview-First-Zoom-and-Filter-Details-on-Demand-首先概述，缩放和筛选，按需提供详细信息"><a href="#Overview-First-Zoom-and-Filter-Details-on-Demand-首先概述，缩放和筛选，按需提供详细信息" class="headerlink" title="Overview First, Zoom and Filter, Details on Demand 首先概述，缩放和筛选，按需提供详细信息"></a>Overview First, Zoom and Filter, Details on Demand 首先概述，缩放和筛选，按需提供详细信息</h3><p><strong>有影响力的咒语“首先概述，缩放和过滤，细节随需应变”(Shneiderman, 1996)阐明了交互和导航在可视化设计中的作用。通过空间导航或过滤，概览可以帮助用户注意到可能会产生进一步调查的区域。正如我们下面所讨论的，细节可以通过多种方式呈现:通过点击或光标悬停弹出窗口，在单独的窗口中，通过动态更改布局来腾出空间来显示额外的信息。</strong></p>
<h3 id="Interactivity-Costs-交互性成本"><a href="#Interactivity-Costs-交互性成本" class="headerlink" title="Interactivity Costs 交互性成本"></a>Interactivity Costs 交互性成本</h3><p><strong>交互性既有力量又有成本。交互的好处在于，人们可以探索比单一静态图像所能理解的更大的信息空间。然而，交互的代价是它需要人类的时间和注意力。如果用户必须彻底检查每一种可能性，则使用可视化系统可能会沦为人工搜索。对可视化设计人员来说，通过视觉编码自动检测感兴趣的特征，明确地引起用户的注意是一个有用的目标。然而，如果手头的任务可以通过自动手段完全解决，那么首先就不需要可视化。因此，在寻找可自动化的方面和依赖循环中的人来检测模式之间总是存在权衡。</strong></p>
<h3 id="Animation-动画-1"><a href="#Animation-动画-1" class="headerlink" title="Animation 动画"></a>Animation 动画</h3><p><strong>动画显示使用时间的变化。我们将连续帧只能播放、暂停或停止的动画与真正的交互控制区分开来。有相当多的证据表明，通过帮助人们跟踪物体位置或摄像机视角的变化，动画过渡可能比跳跃剪切更有效(Heer &amp; Robertson, 2007)。尽管动画在叙述和讲故事中非常有效，但它在可视化环境中经常被低效地使用。通过使用动画(一种随时间变化的视觉模式)来显示随时间变化的数据似乎是显而易见的。然而，当人们看到由许多帧组成的动画时，他们很难在不连续的单独帧之间进行具体的比较。人类视觉记忆的能力非常有限，这意味着我们比较过去见过的事物的记忆要比比较当前视野中的事物差得多。对于需要在多达几十帧之间进行比较的任务，并排比较通常比动画更有效。此外，如果在帧间改变的对象数量很大，人们将很难跟踪发生的所有事情(Robertson et al.， 2008)。叙事动画是精心设计的，以避免同时发生太多动作，而可视化的数据集则没有这种限制。对于只有有限变化的两帧的特殊情况，非常简单的在两帧之间来回翻转的动画可以是识别两者差异的有用方法。</strong> </p>
<h2 id="Composite-and-Adjacent-Views-合成视图和相邻视图"><a href="#Composite-and-Adjacent-Views-合成视图和相邻视图" class="headerlink" title="Composite and Adjacent Views 合成视图和相邻视图"></a>Composite and Adjacent Views 合成视图和相邻视图</h2><p><strong>一个非常基本的视觉编码选择是，是使用单个复合视图在同一帧或窗口中显示所有内容，还是使用多个相邻视图。</strong></p>
<h3 id="Single-Drawing-单图"><a href="#Single-Drawing-单图" class="headerlink" title="Single Drawing 单图"></a>Single Drawing 单图</h3><p><strong>当只有一个或两个数据维度进行编码时，水平和垂直空间位置是最明显的视觉通道，因为我们对它们的感知最准确，位置对我们对数据集的内部心理模型的影响最大。传统的统计图形显示的折线图、柱状图和散点图都使用符号的空间排序来编码信息。这些显示可以通过附加的视觉通道进行增强，如颜色、大小和形状，如图26.4所示。</strong></p>
<p><strong>最简单的标记是单个像素。在面向像素的显示中，目标是提供尽可能多的项目的概述。这些方法使用了高信息密度的空间位置和颜色通道，但排除了大小和形状通道的使用。下图显示了Tarantula软件可视化工具(Jones et al.， 2002)，其中大部分屏幕都用于使用一个像素的高线概述源代码(Eick, Steffen， &amp; Sumner, 1992)。当执行一套测试用例时，每一行的颜色和亮度显示它是否通过、失败或有混合结果。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030111550.png" class="" title="image-20211030111550">

<p>Tarantula通过软件测试套件的执行状态，用一个像素线颜色编码的源代码概述。图片由John Stasko提供(Jones, harrod， &amp; Stasko, 2002)。</p>
<h3 id="Superimposing-and-Layering-叠加和分层"><a href="#Superimposing-and-Layering-叠加和分层" class="headerlink" title="Superimposing and Layering 叠加和分层"></a>Superimposing and Layering 叠加和分层</h3><p><strong>当多个项目的空间位置兼容时，可以在同一帧中叠加。当坐标轴在所有项目上共享时，可以在同一折线图中显示几条线，在同一散点图中显示许多点。单一共享观点的一个好处是，比较不同项目的位置非常容易。如果数据集中的项数量有限，那么一个视图通常就足够了。当有足够多的项目时，视觉混乱会成为一个问题，可视化分层可以扩展单个视图的有用性。下图显示了当用户将光标移动到一个单词块上时，大小、饱和度和亮度通道的冗余组合如何用于区分前景层和背景层。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030111743.png" class="" title="image-20211030111743">

<p>星座系统中大小、饱和度和亮度的视觉分层(Munzner, 2000)。</p>
<h3 id="Glyphs-符号"><a href="#Glyphs-符号" class="headerlink" title="Glyphs 符号"></a>Glyphs 符号</h3><p><strong>我们已经讨论了使用简单标记进行视觉编码的想法，其中单个标记对于所使用的每个视觉通道只能有一个值。对于更复杂的标记(我们称之为符号)，有一个内部结构，其中子区域具有不同的视觉通道编码。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030111922.png" class="" title="image-20211030111922">

<p>复杂的标记(我们称之为符号)有一些子部分，它们在视觉上对不同的数据维进行编码。图片由Matt Ward (m.o. Ward, 2002)提供。</p>
<p><strong>设计适当的字形与设计可视编码具有相同的挑战。上图显示了各种各样的字形，包括Chernoff最初提出的臭名昭著的脸。使用面孔来显示抽象数据维度的危险在于，我们对不同面部特征的感知和情绪反应是高度非线性的，这种非线性还没有被完全理解，但这种可变性比我们目前讨论过的视觉通道之间的可变性更大。相对于鼻子大小或脸型等其他特征，我们可能更倾向于眉毛方向等反映情感状态的特征。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112010.png" class="" title="image-20211030112010">

<p>复杂的符号需要显著的显示区域，这样编码信息才能被读取。图片由Matt Ward提供，使用SpiralGlyphics软件创建(M. O. Ward, 2002)。</p>
<p><strong>复杂的符号需要每个符号有显著的显示区域，如上图所示，其中小型条形图显示了沿着螺旋路径的许多点的四个不同维度的值。可以使用更简单的符号来创建全局视觉纹理，该符号的大小非常小，以至于不缩放就无法读出单个值，但可以从概述级别识别区域边界。下图显示了使用上上图中右上方那种简笔图的示例。符号可以按一定的间隔放置，或者使用原始或派生数据维放置在数据驱动的空间位置。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112112.png" class="" title="image-20211030112112">

<p>一组密集的简单符号。图片由Georges Grinstein (S. Smith, Grinstein， &amp; Bergeron, 1991)提供，©1991 IEEE。</p>
<h3 id="Multiple-Views-多个视图"><a href="#Multiple-Views-多个视图" class="headerlink" title="Multiple Views 多个视图"></a>Multiple Views 多个视图</h3><p><strong>我们现在从只使用单一帧的方法转向那些使用多个链接在一起的视图的方法。链接最常见的形式是链接高亮显示，在一个视图中选中的项在其他视图中高亮显示。在链接导航中，一个视图中的移动会触发其他视图中的移动。</strong></p>
<p><strong>有许多种多视图方法。在通常称为多视图的方法中，相同的数据在多个视图中显示，每个视图具有不同的视觉编码，最清楚地显示数据集的某些方面。跨多个可视编码的链接高亮显示功能的强大之处在于，在一个视图中位于相邻区域的项在其他视图中的分布往往非常不同。在小倍数方法中，每个视图对不同的数据集具有相同的视觉编码，通常帧之间共享轴，以便于它们之间的空间位置比较有意义。小倍数的并排比较可以替代在同一视图中叠加所有数据的视觉混乱，也可以替代人类记忆的局限性，即记住之前在动画中看到的帧，而动画会随着时间的推移而变化。</strong></p>
<p><strong>概览和详细方法是在两个视图中具有相同的数据和相同的视觉编码，它们之间的唯一区别是缩放级别。在大多数情况下，概览使用的显示空间要比详细视图少得多。概览和细节视图的组合在可视化之外的许多工具(从地图软件到照片编辑)中很常见。使用按需详细说明的方法，另一个视图可以显示有关选定项的更多信息，可以是光标附近的弹出窗口，也可以是显示的另一部分中的永久窗口。</strong></p>
<p><strong>确定视图本身相对于其他视图最合适的空间位置，可能与确定单个视图中标记的空间位置一样是一个重要的问题。在某些系统中，视图的位置是任意的，由窗口系统或用户决定。对齐视图允许它们之间进行精确的比较，可以是垂直的、水平的，也可以是两个方向的数组。就像项目可以在视图中排序一样，视图也可以在显示中排序，通常是根据衡量整个视图某些方面的派生变量，而不是其中的单个项目。</strong></p>
<p><strong>下图显示了使用多种视图的人口普查数据的可视化。除了地理信息，每个县的人口信息还包括人口、密度、性别、中位年龄、1990年以来的变化百分比和主要民族的比例。使用的视觉编码包括地理、散点图、平行坐标、表格和矩阵视图。所有视图都使用相同的颜色编码，在底部中间有一个图例。散点图矩阵在所有视图中显示了链接的高亮显示，其中蓝色项目在一些视图中靠近，而在其他视图中分散。左上角的地图是中央的大细节地图的概述。表格视图允许在感兴趣的维度中直接排序和选择。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112632.png" class="" title="image-20211030112632">

<p>我们使用了Improvise工具包来创建这个多视图可视化。</p>
<h2 id="Data-Reduction-数据简化"><a href="#Data-Reduction-数据简化" class="headerlink" title="Data Reduction 数据简化"></a>Data Reduction 数据简化</h2><p><strong>到目前为止，我们所讨论的可视化编码技术显示了数据集中的所有项。然而，许多数据集是如此之大，以至于同时显示所有内容将导致如此多的视觉混乱，以至于视觉表示将很难或不可能让观众理解。减少显示的数据量的主要策略是概述和聚合、过滤和导航、焦点+上下文技术和降维。</strong></p>
<h3 id="Overviews-and-Aggregation-简介和聚合"><a href="#Overviews-and-Aggregation-简介和聚合" class="headerlink" title="Overviews and Aggregation 简介和聚合"></a>Overviews and Aggregation 简介和聚合</h3><p><strong>使用微小的数据集，可视化编码可以很容易地显示所有项目的所有数据维。对于中等大小的数据集，可以通过减少显示每个项的详细信息来构建显示所有项信息的概述。许多数据集在多个尺度上具有内部或可派生的结构。在这些情况下，多尺度可视化表示可以提供多个级别的概述，而不仅仅是一个级别的水平。概览通常用作起点，为用户提供线索，让他们知道在哪里深入检查更详细的内容。</strong></p>
<p><strong>对于较大的数据集，创建概览需要某种形式的可视化摘要。数据简化的一种方法是使用聚合表示，其中概述中的单个可视标记显式地表示许多项。</strong></p>
<p><strong>聚合的难点在于在摘要过程中要避免消除数据集中感兴趣的信号。在地图文献中，在保留重要区别特征的同时，以地图综合的名义，广泛研究了在不同尺度上创建地图的问题(Slocum, McMaster, Kessler， &amp; Howard, 2008)。</strong></p>
<h3 id="Filtering-and-Navigation-过滤和导航"><a href="#Filtering-and-Navigation-过滤和导航" class="headerlink" title="Filtering and Navigation 过滤和导航"></a>Filtering and Navigation 过滤和导航</h3><p><strong>数据缩减的另一种方法是过滤数据，只显示项的一个子集。过滤通常通过直接选择一个或多个数据维中感兴趣的范围来执行。</strong></p>
<p><strong>导航是一种基于空间位置的特殊过滤，改变视点会改变可见的项目集。几何变焦和非几何变焦均可用于可视化。通过几何缩放，摄像机在2D或3D空间中的位置可以用标准的计算机图形控件改变。在现实场景中，项目的大小应该取决于它们与摄像机的距离，只有它们的表面大小会根据距离变化。然而，在抽象空间的视觉编码中，非几何缩放可能是有用的。在语义缩放中，对象的视觉外观会根据绘制它的可用像素的数量发生显著变化。例如，文本文件的抽象视觉表示可以从一个没有标签的彩色编码小框变成一个中等大小的框，其中只包含文件名作为文本标签，然后变成一个包含文件内容的多行摘要的大矩形。在现实场景中，距离相机足够远的物体在图像中是不可见的，例如，当它们所处的屏幕面积小于一个像素时。在保证可见性的情况下，原始或派生数据维中的一个被用作重要性的度量，足够重要的对象必须在图像平面中始终具有某种可见的表示。</strong></p>
<h3 id="Focus-Context-焦点-上下文"><a href="#Focus-Context-焦点-上下文" class="headerlink" title="Focus+Context 焦点+上下文"></a>Focus+Context 焦点+上下文</h3><p><strong>焦点+上下文技术是另一种数据简化方法。用户以交互方式选择数据集项的子集作为焦点并绘制在细节。可视编码还包括关于为上下文显示的部分或所有其余数据集的信息，集成到显示焦点项的相同视图中。许多这些技术使用精心选择的失真，将放大的焦点区域和缩小的上下文区域组合成一个统一的视图。</strong></p>
<p><strong>一个常见的互动隐喻是可移动的鱼眼镜头。双曲几何学为影响视图中所有物体的单个径向透镜提供了一个优雅的数学框架。另一个交互隐喻是使用不同形状和放大级别的多个透镜，只影响局部区域。拉伸和挤压导航使用橡胶薄片的交互隐喻，拉伸一个区域会挤压其他区域，如下图所示。工作表的边界保持固定，以便所有项目都在视口内，尽管许多项目可能被压缩到亚像素大小。鱼眼隐喻并不局限于空间布局后使用的几何透镜;它可以直接用于结构化数据，例如一些部分折叠而其他部分展开的分层文档。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112924.png" class="" title="image-20211030112924">

<p>TreeJuxtaposer系统具有拉伸和挤压导航功能，并保证用颜色标记的区域的可见性(Munzner, Guimbreti’ere, Tasiran, Zhang， &amp; Zhou, 2003)。</p>
<p><strong>这些基于扭曲的方法是与非几何缩放具有相同精神的非文字导航的另一个例子。当导航在一个大的和不熟悉的数据集与现实的相机运动，用户可能会失去知觉当他们只能看到一个小的局部区域时，在高变焦水平上被设置。这些方法的设计目的是提供更多的背景信息，而不是单一的未经扭曲的视图，希望人们可以在地标仍然可识别的情况下保持方向。然而，这些失真仍然会让用户感到困惑或难以理解。与多种观点或单一现实观点相比，扭曲的成本和收益尚未得到充分理解。标准3D透视是一种非常常见的扭曲，在早期的可视化工作中被明确地用作焦点+背景的一种形式。然而，随着第26.4节中讨论的3D空间布局成本变得更容易理解，这种方法变得不那么受欢迎了。</strong></p>
<p><strong>其他围绕焦点项目提供上下文的方法不需要失真。例如，下图所示的SpaceTree系统省略了树中的大多数节点，显示了交互选择的焦点节点和树的根之间的路径。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030112955.png" class="" title="image-20211030112955">

<p>SpaceTree系统显示了根与交互选择的焦点节点之间的路径，以提供上下文(Grosjean, Plaisant， &amp; Bederson, 2002)。</p>
<h3 id="Dimensionality-Reduction-降维"><a href="#Dimensionality-Reduction-降维" class="headerlink" title="Dimensionality Reduction 降维"></a>Dimensionality Reduction 降维</h3><p><strong>到目前为止所介绍的数据简化方法减少了要绘制的项目数量。当数据维数很多时，降维也很有效。</strong></p>
<p><strong>通过切片，从要消除的维度中选择一个值，然后只提取与该维度值匹配的项，将其包含在低维切片中。对于3D空间数据，切片尤其有用，例如，当通过CT扫描检查沿着头骨不同高度的人类头部切片时。切片可用于一次性消除多个维度。</strong></p>
<p><strong>对于投影，消除的尺寸信息不会被保留;这些维度的值被简单地删除，所有项仍然显示出来。一种常见的投影形式是标准的图形透视转换，它从3D投影到2D，在此过程中会丢失有关深度的信息。在数学可视化中，高维几何物体的结构可以通过在标准投影之前从4D投影到3D投影到图像平面，并使用颜色对投影外维的信息进行编码来表示。当用于非空间数据时，这种技术有时被称为维度过滤。</strong></p>
<p><strong>在一些数据集中，在比原始数据维数低得多的空间中可能存在有趣的隐藏结构。例如，有时直接测量自变量的兴趣是困难的或这是不可能的，但有大量的因变量或间接变量是可用的。目标是找到一小组能够忠实地表示数据集中的大部分结构或方差的维。这些维度可能是原始维度，也可能是合成的新维度，是原始维度的线性或非线性组合。主成分分析是一种快速、应用广泛的线性方法。许多非线性方法已经被提出，包括多维尺度(MDS)。这些方法通常用于确定数据集中是否存在大规模聚类;低维图中的细粒度结构通常不可靠，因为在还原过程中会丢失信息。下图显示了单个散点图中的文档收集。当数据集的真实维数远高于2时，可能需要一个散点图矩阵来显示成对的合成维数。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030121341.png" class="" title="image-20211030121341">

<p>微光多维尺度方法的降维显示文档数据集中的簇(Ingram, Munzner， &amp; Olano, 2009)，©2009 IEEE。</p>
<h2 id="Examples-示例"><a href="#Examples-示例" class="headerlink" title="Examples 示例"></a>Examples 示例</h2><p><strong>我们用几个使用上面讨论的技术可视化特定类型数据的例子来结束本章。</strong></p>
<h3 id="Tables-表"><a href="#Tables-表" class="headerlink" title="Tables 表"></a>Tables 表</h3><img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030123651.png" class="" title="image-20211030123651">

<p>Table Lens提供了与表格数据的焦点+上下文交互，可以立即按每个维度列中的值重新排序。图片由Stuart Card提供(Rao &amp; Card, 1994)，©1994 ACM, Inc。包括在这里的许可。</p>
<p><strong>所有电子表格用户都知道，表格数据是非常常见的。可视化的目标是通过容易感知的视觉渠道对信息进行编码，而不是强迫人们以数字和文本的形式阅读信息。上图显示了Table Lens，这是一种聚焦+上下文的方法，其中定量值被编码为上下文区域中的一个像素高线的长度，并在焦点区域中显示为数字。数据集的每个维度都显示为一列，只需单击标题，就可以根据列中的值访问项目行。</strong></p>
<p><strong>散点图的传统笛卡尔方法，即项目相对于垂直轴以点的形式绘制，仅适用于二维和三维数据。许多表包含的数据远不止三个维度，而且可以使用其他可视通道编码的额外维度的数量是有限的。平行坐标是一种利用空间位置一次性可视化更多维度的方法，其中坐标轴是平行的而不是垂直的，n维项目以折线的形式显示出来，这条折线与每个n轴相交一次(Inselberg &amp; Dimsdale, 1990;维根曼,1990)。下图显示了一个包含23万项的8维数据集，它位于多个细节级别(Fua, Ward， &amp; Rundensteiner, 1999)，从顶部的高级视图到更精细的细节在底部。使用分层平行坐标，项目被聚类，整个项目聚类由不同宽度和不透明度的频带表示，平均值在中间，每个轴的宽度取决于该维度中集群中项目的值。每个波段的着色是基于基于相似性度量的聚类之间的接近度。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030123706.png" class="" title="image-20211030123706">

<p>分层并行坐标在多个细节层次上显示高维数据。图片由Matt Ward (Fua等人，1999)提供，©1999 IEEE。</p>
<h3 id="Graphs-图形"><a href="#Graphs-图形" class="headerlink" title="Graphs 图形"></a>Graphs 图形</h3><p><strong>图绘制的领域是在二维或三维空间中为图中的节点找到一个空间位置，并在这些节点之间路由边(Di Battista, Eades, Tamassia， &amp; Tollis, 1999)。在许多情况下，边路由问题可以通过只使用直边或只允许正交布局类的直角弯曲来简化，但有些方法处理真曲线。如果图具有有向边，则可以使用分层方法通过节点的水平或垂直空间排序来显示层次结构，如图26.2所示。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124114.png" class="" title="image-20211030124114">

<p>图形布局美学标准。上:应尽量减少交叉边。中:Angular的分辨率应该最大化。下:对称性在左侧最大化，而交叉在右侧最小化，这显示了个别np硬标准之间的冲突。</p>
<p><strong>一套美学标准将人类对可读图形的判断作为可在拟议布局上计算的度量标准来操作(Ware, Purchase, Colpys， &amp; McGill, 2002)。上图显示了一些示例。有些参数应该最小化，比如交叉边的数量，布局的总面积，以及直角弯曲或曲线的数量。其他的应该最大化，如角分辨率或对称性。问题是困难的，因为这些标准中的大多数都是单独的NP-hard，而且它们是相互不相容的(Brandenburg, 1988)。</strong></p>
<p><strong>许多绘制节点-链接图的方法都使用力指向放置，其动机是直观的物理隐喻，即边缘的弹簧力将节点上的排斥粒子拉到一起。虽然朴素的方法具有很高的时间复杂度，而且容易陷入局部极小值，但许多工作已经投入到开发更复杂的算法中，如GEM (Frick, Ludwig， &amp; Mehldau, 1994)或ipsepo - cola (Dwyer, Koren， &amp; Marriott, 2006)。下图显示了一个使用r-PolyLog能量模型的交互式系统，其中聚类图的焦点+上下文视图是用几何和语义鱼眼创建的(van Ham &amp; van Wijk, 2004)。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124125.png" class="" title="image-20211030124125">

<p>力向放置显示了具有几何和语义鱼眼的聚类图。图片由Jarke van Wijk提供(van Ham &amp; van Wijk, 2004)，©2004 IEEE。</p>
<p><strong>图也可以通过显示邻接矩阵来进行可视化编码，其中所有顶点沿每个轴放置，如果两个顶点之间有一条边，则两个顶点之间的单元格会着色。MatrixExplorer系统使用链接的多个视图来帮助社会科学研究人员通过矩阵和节点链接表示直观地分析社会网络(Henry &amp; Fekete, 2006)。下图显示了在这两个视图中由相同的图形结构创建的不同视觉模式:A表示连接多个社区的参与者;B是一个社区;C是一个团，或者完全子图。矩阵视图不会受到杂乱的边缘交叉的影响，但是使用这种方法，包括路径跟踪在内的许多任务更加困难。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124136.png" class="" title="image-20211030124136">

<p>图可以用矩阵视图或节点链接视图显示。图片由Jean- Daniel Fekete提供(Henry &amp; Fekete, 2006)，©2006 IEEE。</p>
<h3 id="Trees-树"><a href="#Trees-树" class="headerlink" title="Trees 树"></a>Trees 树</h3><p><strong>树是一种很常见的图的特殊情况，因此大量的可视化研究都致力于它们。在二维平面上布局树的简单算法对小树很有效(Reingold &amp; Tilford, 1981)，而更复杂但可扩展的方法在线性时间内运行(Buchheim, J¨unger， &amp; Leipert, 2002)。图26.17和26.18还显示了具有不同空间布局方法的树，但这四种方法都通过绘制连接父节点和子节点的链接，在视觉上编码了它们之间的关系。</strong></p>
<p><strong>树映射使用包含而不是连接来显示树中父节点和子节点之间的层次关系(B. Johnson &amp; Shneiderman, 1991)。也就是说，树映射显示嵌套在父节点轮廓中的子节点。下图显示了一个包含近100万个文件的分级文件系统，其中文件大小按矩形大小编码，文件类型按颜色编码(Fekete &amp; Plaisant, 2002)。树的叶子节点的大小可以编码一个额外的数据维，但内部节点的大小并不显示该维的值;这是由后代的累积体型决定的。尽管使用树映射比使用节点链接方法更难理解树的拓扑结构或通过树跟踪路径等任务，但涉及理解与叶节点绑定的属性的任务得到了很好的支持。树映射是一种空间填充表示，通常比节点链接方法更紧凑。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124412.png" class="" title="image-20211030124412">

<p>Treemap显示了将近100万个文件的文件系统。图片由Jean- Daniel Fekete (Fekete &amp; Plaisant, 2002)提供，©2002 IEEE。</p>
<h3 id="Geographic-地理"><a href="#Geographic-地理" class="headerlink" title="Geographic 地理"></a>Geographic 地理</h3><p><strong>许多类型的分析，如流行病学，需要理解地理和非空间数据。下图显示了一个用于可视化分析癌症人口统计数据集的工具，该数据集结合了本章中描述的许多观点(MacEachren, Dai, Hardisty, Guo， &amp; Lengerich, 2003)。链接视图的顶部矩阵具有三种视觉编码的小倍数:左下角显示阿巴拉契亚县的地理地图，矩阵对角线的直方图，以及右上方的散点图。底部的2 × 2矩阵将散点图与地图连接起来，包含了两者的颜色图例。离散二元序列色图对两个互补色系中的每个色系都有依次增加的亮度，对色觉不足的人有效。</strong></p>
<img src="/2023/05/05/Fundamentals%20Of%20Computer%20Graphics%204th/image-20211030124540.png" class="" title="image-20211030124540">

<p>显示癌症人口统计数据的两个关联小倍数矩阵(MacEachren等人，2003)，©2003 IEEE。</p>
<h3 id="Spatial-Fields-空间领域"><a href="#Spatial-Fields-空间领域" class="headerlink" title="Spatial Fields 空间领域"></a>Spatial Fields 空间领域</h3><p><strong>大多数非地理空间数据被建模为一个字段，其中有一个或多个值与2D或3D空间中的每个点相关联。标量场，例如CT或MRI医学成像扫描，通常通过寻找等值面或使用直接体积绘制来实现可视化。例如，矢量场，在水或空气中的流动，通常使用箭头、流线(McLouglin, Laramee, Peikert, Post， &amp; Chen, 2009)和线积分卷积(LIC) (Laramee et al.， 2004)来可视化。张量场，例如那些描述分子在人脑中的各向异性扩散的张量场，特别具有挑战性(Kindlmann, Weinstein， &amp; Hart, 2000)。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/05/Real-Time%20Rendering%204th%20edition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/05/Real-Time%20Rendering%204th%20edition/" class="post-title-link" itemprop="url">Real-Time Rendering 4th edition</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-05 14:15:51" itemprop="dateCreated datePublished" datetime="2023-05-05T14:15:51+08:00">2023-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-21 17:52:18" itemprop="dateModified" datetime="2023-05-21T17:52:18+08:00">2023-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Introduction-介绍"><a href="#1-Introduction-介绍" class="headerlink" title="1 Introduction 介绍"></a>1 Introduction 介绍</h1><h2 id="Contents-Overview-内容概述"><a href="#Contents-Overview-内容概述" class="headerlink" title="Contents Overview 内容概述"></a>Contents Overview 内容概述</h2><h2 id="Notation-and-Definitions-符号和定义"><a href="#Notation-and-Definitions-符号和定义" class="headerlink" title="Notation and Definitions 符号和定义"></a>Notation and Definitions 符号和定义</h2><h1 id="2-The-Graphics-Rendering-Pipeline-图形渲染管线"><a href="#2-The-Graphics-Rendering-Pipeline-图形渲染管线" class="headerlink" title="2 The Graphics Rendering Pipeline 图形渲染管线"></a>2 The Graphics Rendering Pipeline 图形渲染管线</h1><h2 id="Architecture-体系结构"><a href="#Architecture-体系结构" class="headerlink" title="Architecture 体系结构"></a>Architecture 体系结构</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210906115237.png" class="" title="image-20210906115237">

<p><strong>实时渲染管线粗略划分为四个主要阶段:应用程序、几何处理、光栅化和像素处理。每一个阶段本身通常是一个管线，这意味着它由几个子阶段组成。我们区分这里显示的功能阶段和它们的实现结构。函数阶段有特定的任务要执行，但是没有指定任务在管道中执行的方式。一个给定的实现可以将两个功能阶段合并成一个单元或使用可编程核心执行，而将另一个更耗时的功能阶段划分为几个硬件单元。</strong></p>
<p><strong>绘制速度可以用每秒帧数(FPS)表示，即每秒绘制的图像数量。它也可以用赫兹(Hz)表示，这只是1/秒的符号，即更新频率。还可用毫秒(ms)表示渲染图像所需的时间。生成图像的时间通常是不同的，这取决于每一帧所执行的计算的复杂性。每秒帧数用来表示特定帧的速率，或者表示某一段使用时间内的平均性能。赫兹用于硬件，如显示器，它通常被设置为一个固定的速率。</strong></p>
<p><strong>光栅化和像素处理阶段也完全在GPU上处理。</strong></p>
<h2 id="The-Application-Stage-应用程序"><a href="#The-Application-Stage-应用程序" class="headerlink" title="The Application Stage 应用程序"></a>The Application Stage 应用程序</h2><p><strong>开发人员完全控制在应用程序阶段发生的事情，因为它通常是在CPU上执行的。因此，开发人员可以完全确定实现，并在以后修改它以提高性能。这里的更改也会影响后续阶段的性能。这些cpu通常包括能够并行处理多个执行线程的多个核。这使得cpu能够有效地运行应用程序阶段负责的各种任务。一些传统上在CPU上执行的任务包括碰撞检测、全局加速算法、动画、物理模拟和许多其他任务，这取决于应用程序的类型。加速算法，比如特定的剔除算法，以及其他管道的其他部分无法处理的算法，也在这里实现。</strong></p>
<p><strong>在应用阶段的最后，要渲染的几何图形被输入到几何图形处理阶段。这些是呈现元素，即，点、线和三角形。这是应用阶段最重要的任务。</strong></p>
<p><strong>基于软件实现这一阶段的结果是，它不像几何处理、光栅化和像素处理阶段那样被划分为子阶段。然而，为了提高性能，这一阶段通常在多个处理器核心上并行执行。在CPU设计中，这被称为超标量构造，因为它能够在同一阶段同时执行多个进程。</strong></p>
<h2 id="Geometry-Processing-几何处理"><a href="#Geometry-Processing-几何处理" class="headerlink" title="Geometry Processing 几何处理"></a>Geometry Processing 几何处理</h2><p><strong>它处理变换、投影和所有其他类型的几何处理。这个阶段计算要画什么，应该怎么画，应该在哪里画。几何阶段通常在图形处理单元(GPU)上执行，该单元包含许多可编程核心和固定操作硬件。</strong></p>
<p><strong>GPU上的几何处理阶段负责大部分的三角形和顶点操作。这个阶段进一步分为以下功能阶段:顶点着色、投影、裁剪和屏幕映射。</strong><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210907091653.png" class="" title="image-20210907091653"></p>
<h3 id="Vertex-Shading-顶点着色"><a href="#Vertex-Shading-顶点着色" class="headerlink" title="Vertex Shading 顶点着色"></a>Vertex Shading 顶点着色</h3><p><strong>顶点着色有两个主要的任务，即，计算顶点的位置和计算程序员可能喜欢的任何顶点输出数据，如法线和纹理坐标。传统上，对象的大部分着色是通过对每个顶点的位置和法线应用光照，并仅存储在顶点的结果颜色来计算的。然后这些颜色被插值到三角形中。因此，这个可编程顶点处理单元被命名为顶点着色器。顶点的位置和法线可以用程序员喜欢的任何方式计算。</strong></p>
<h3 id="Projection-投影"><a href="#Projection-投影" class="headerlink" title="Projection 投影"></a>Projection 投影</h3><p><strong>在GPU上它是由顶点着色器完成的。常用的投影方法有两种，即正投影法(也称平行投影法，事实上，正投影只是平行投影的一种。)和透视投影。</strong><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210907095409.png" class="" title="image-20210907095409"></p>
<p><strong>正射视图的视图体积通常是一个矩形框，而正射投影将此视图体积转换为单元立方体。正射影的主要特点是平行线在变换后仍然保持平行。这种转换是平移和缩放的结合。</strong></p>
<p><strong>透视投影稍微复杂一点。在这种类型的投影中，一个物体离相机越远，它在投影后显得越小。此外，平行线可能会聚于地平处。因此，透视变换模仿了我们感知物体大小的方式。几何上，视图体称为截锥，是一个带有矩形基础的截断金字塔。截锥变形了也进入了单元多维数据集。（将视图体积转换为一个单元立方体，其极值点为(−1,1,1)和(1,1,1)。可以使用定义相同体积的不同范围，例如0≤z≤1。单位多维数据集称为规范视图体积。）</strong></p>
<h3 id="Optional-Vertex-Processing-可选顶点处理"><a href="#Optional-Vertex-Processing-可选顶点处理" class="headerlink" title="Optional Vertex Processing 可选顶点处理"></a>Optional Vertex Processing 可选顶点处理</h3><p><strong>每个管线都有刚才描述的顶点处理。一旦这个处理完成了，就可以在GPU上进行一些可选的步骤，按照这个顺序:镶嵌、几何着色和流输出。它们的使用既取决于硬件的能力(并非所有GPU都有)，也取决于程序员的需求。它们彼此独立，通常不常用。</strong></p>
<h4 id="Tessellation-镶嵌细分"><a href="#Tessellation-镶嵌细分" class="headerlink" title="Tessellation 镶嵌细分"></a>Tessellation 镶嵌细分</h4><p><strong>顶点可以用来描述一个曲面，比如一个球。这样的曲面可以由一组补丁（patch）指定，每个补丁由一组顶点组成。细分着色器由多个着色器组成——外壳着色器、细分单元和域着色器——这将这些补丁顶点集转换成(通常)更大的顶点集，然后用来创建新的三角形集。场景中的摄像机可以用来确定生成了多少个三角形:当补丁接近时，生成的三角形很多，当补丁距离较远时，生成的三角形很少。</strong></p>
<h4 id="Geometry-Shader-几何着色器"><a href="#Geometry-Shader-几何着色器" class="headerlink" title="Geometry Shader 几何着色器"></a>Geometry Shader 几何着色器</h4><p><strong>这个着色器比镶嵌着色器更早，所以在GPU上更常见。它就像镶嵌着色器，它通过各种各样的元素，并可以产生新的顶点。这是一个简单得多的阶段，因为创建的范围有限，输出元素的类型也非常有限。几何着色器有几种用途，其中最流行的是粒子生成。想象一下模拟烟花爆炸。每个火球都可以用一个点来表示，一个单一的顶点。几何着色器可以把每个点变成一个正方形(由两个三角形组成)，面向观众，覆盖几个像素，所以为我们提供了一个更有可靠的原始着色。</strong></p>
<h4 id="Stream-Output-流推送"><a href="#Stream-Output-流推送" class="headerlink" title="Stream Output 流推送"></a>Stream Output 流推送</h4><p><strong>这个阶段让我们使用GPU作为几何引擎。此时，我们可以选择性地将这些处理过的顶点输出到数组中以供进一步处理，而不是将处理过的顶点发送到管线的其余部分以呈现到屏幕上。这些数据可以在以后的过程中被CPU或GPU使用。这个阶段通常用于粒子模拟，例如我们的焰火示例。</strong></p>
<p><strong>不管使用的是哪个操作，如果我们继续沿着管线走下去，我们就会有一组具有齐次坐标的顶点，我们将检查摄像机是否会查看它们。</strong></p>
<h3 id="Clipping-裁剪"><a href="#Clipping-裁剪" class="headerlink" title="Clipping 裁剪"></a>Clipping 裁剪</h3><p><strong>只有视图体中全部或部分的元素需要被传递到光栅化阶段(以及随后的像素处理阶段)，然后在屏幕上绘制它们。完全位于视图体内部的元素将按原样传递到下一阶段。完全在视图体之外的元素不会被进一步传递，因为它们不会被渲染。需要裁剪的是部分位于视图体积内的元素。使用投影矩阵意味着转换后的元素被裁剪到单位立方体上。在裁剪之前执行视图转换和投影的优点是它使裁剪问题保持一致;元素总是被剪切到单元立方体上。</strong></p>
<p><strong>裁剪步骤使用由投影产生的四值齐次坐标来执行。值通常不会在透视空间中的三角形上进行线性插值。第四个坐标是必需的，以便在使用透视投影时适当地插值和裁剪数据。最后进行透视划分，将得到的三角形位置放入三维标准化的设备坐标中。正如前面提到的，这个视图体积的范围从(−1, −1, −1) 到 (1, 1, 1)。</strong></p>
<h3 id="Screen-Mapping-屏幕映射"><a href="#Screen-Mapping-屏幕映射" class="headerlink" title="Screen Mapping 屏幕映射"></a>Screen Mapping 屏幕映射</h3><p><strong>当进入这个阶段时，坐标仍然是三维的。每个元素的x和y坐标被转换成屏幕坐标。屏幕坐标和z坐标也称为窗口坐标。假设场景应该被渲染成一个最小角为 (x1, y1))和最大角 (x2, y2),其中x1 &lt; x2 和y1 &lt; y2。屏幕映射是一个转换，然后是缩放操作。新的x和y坐标称为屏幕坐标。z坐标(OpenGL的([−1, +1]和DirectX的 [0, 1])也被映射到 [z1, z2]与z1 = 0 和 z2 = 1作为默认值。但是，这些可以通过API进行更改。</strong></p>
<p><strong>如何将整数和浮点值与像素(和纹理坐标)相关。给定一个水平像素数组并使用笛卡尔坐标，最左边像素的左边缘在浮点坐标中为0.0。OpenGL一直使用这个方案，directx10及往后版本也使用它。这个像素的中心是0.5。因此，像素范围[0,9]涵盖了从[0.0,10.0)到[0.0,10.0]的范围。转换很简单。</strong></p>
<p><strong>d = floor(c),</strong> </p>
<p><strong>c = d + 0.5,</strong></p>
<p><strong>其中d是像素的离散(整数)索引，c是像素内的连续(浮点)值。</strong></p>
<p><strong>虽然所有api的像素位置值从左到右递增，但在OpenGL和DirectX之间，顶部和底部边缘的位置0在某些情况下是不一致的。OpenGL始终支持笛卡尔系统，将左下角视为最低值的元素，而DirectX有时会根据上下文将左上角定义为这个元素。每一个问题都有一个逻辑，它们不同的地方没有正确的答案。例如，(0,0)在OpenGL中位于图像的左下角，而在DirectX中位于左上角。在从一个API迁移到另一个API时，要考虑到这种差异。</strong></p>
<h2 id="Rasterization-光栅化"><a href="#Rasterization-光栅化" class="headerlink" title="Rasterization 光栅化"></a>Rasterization 光栅化</h2><p><strong>给定转换和投影的顶点及其相关的着色数据(都来自几何学处理)，下一阶段的目标是找到原始图(例如，一个三角形)中所有的像素。我们称这个过程为光栅化，它被分为两个功能子阶段:三角形设置(也称为原始装配)和三角形遍历。注意，这些也可以处理点和线，但由于三角形是最常见的，子阶段的名称中有“三角形”。光栅化，也称为扫描转换，是将屏幕空间中的二维顶点(每个顶点都有一个z值(深度值)和与每个顶点相关的各种着色信息)转换为屏幕上的像素。光栅化也可以被认为是几何处理和像素处理之间的同步点，因为在这里三角形由三个顶点组成，并最终被发送到像素处理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210907105939.png" class="" title="image-20210907105939">

<p><strong>三角形是否被认为是重叠的像素取决于你如何设置GPU的管道。例如，您可以使用点抽样来确定，最简单的情况是在每个像素的中心使用一个单点样本，所以如果中心点在三角形内，那么相应的像素也被认为在三角形内。您也可以使用超采样或多次采样反锯齿技术，每个像素使用多个样本。另一种方法是使用保守光栅化，其定义是，如果一个像素至少有一部分与三角形重叠，那么该像素就在三角形的“内部”。</strong></p>
<h4 id="Triangle-Setup-三角形设置"><a href="#Triangle-Setup-三角形设置" class="headerlink" title="Triangle Setup 三角形设置"></a>Triangle Setup 三角形设置</h4><p><strong>在这一阶段，计算三角形的微分、边方程和其他数据。这些数据可用于三角遍历，以及由几何阶段产生的各种着色数据的插值。固定功能硬件被用于此操作。</strong></p>
<h4 id="Triangle-Traversal-三角形遍历"><a href="#Triangle-Traversal-三角形遍历" class="headerlink" title="Triangle Traversal 三角形遍历"></a>Triangle Traversal 三角形遍历</h4><p><strong>在这里，每个像素的中心(或样本)被三角形覆盖，并生成一个碎片部分的像素重叠的三角形。找出哪些样本或像素位于三角形内通常称为三角形遍历。每个三角形片段的属性是通过在三个三角形顶点之间插值数据生成的。这些属性包括片段的深度，以及任何来自几何阶段的着色数据。也是在这里，对三角形进行透视校正插值。然后将元素中的所有像素或样本发送到像素处理阶段。</strong></p>
<h2 id="Pixel-Processing-像素处理"><a href="#Pixel-Processing-像素处理" class="headerlink" title="Pixel Processing 像素处理"></a>Pixel Processing 像素处理</h2><p><strong>像素处理阶段分为像素着色和像素合并。像素处理是对原语内部的像素或样本执行逐像素或逐样本计算和操作的阶段。</strong></p>
<h3 id="Pixel-Shading-像素着色器"><a href="#Pixel-Shading-像素着色器" class="headerlink" title="Pixel Shading 像素着色器"></a>Pixel Shading 像素着色器</h3><p><strong>任何逐像素着色计算都在这里执行，使用插值着色数据作为输入。最终的结果是一个或多个颜色被传递到下一个阶段。不同于三角形设置和遍历阶段，它们通常由专用的、硬线连接的硅执行，像素着色阶段是由可编程的GPU核心执行的。为此，程序员为像素着色器(或片段着色器，在OpenGL中它是已知的)提供一个程序，它可以包含任何所需的计算。这里可以使用各种各样的技术，其中最重要的是纹理。简单地说，纹理一个对象意味着“粘合”一个或多个图像到该对象，以实现各种目的。图像可能是一，二，或三维，其中二维图像是最常见的。最简单的是，最终生成是每个片段的颜色值，这些将被传递到下一个子阶段。</strong></p>
<h3 id="Merging-像素合并"><a href="#Merging-像素合并" class="headerlink" title="Merging 像素合并"></a>Merging 像素合并</h3><p><strong>每个像素的信息存储在颜色缓冲区中，颜色缓冲区是由颜色组成的矩形数组(每种颜色由红色、绿色和蓝色组成)。合并阶段负责将像素着色阶段产生的碎片颜色与当前存储在缓冲区中的颜色相结合。这个阶段也被称为ROP，代表“光栅操作(管线)”或“渲染输出单元”，具体取决于您问的是谁。与着色阶段不同，执行此阶段的GPU子单元通常不是完全可编程的。但是，它是高度可配置的，支持各种效果。</strong></p>
<p><strong>这个阶段还负责解决可见性问题。这意味着当整个场景被渲染时，颜色缓冲应该包含场景中从相机角度可见的元素的颜色。对于大多数甚至所有的图形硬件，这是通过z缓冲区(也称为深度缓冲区)算法来实现的。z缓冲区的大小和形状与颜色缓冲区相同，对于每个像素，它存储当前最近的元素的z值。这意味着当一个元素被渲染到某个像素时，该元素在该像素处的z值将被计算并与相同像素处的z缓冲区的内容进行比较。如果新的z值小于z缓冲区中的z值，那么正在渲染的元素将比之前在该像素处最接近摄像机的元素更接近摄像机。因此，该像素的z值和颜色将更新为所绘制的元素的z值和颜色。如果计算的z值大于z缓冲区中的z值，则颜色缓冲区和z缓冲区将保持不变。z缓冲区算法很简单，有O(n)收敛性(n是被渲染的元素数量)，并且适用于任何可以为每个(相关)像素计算z值的绘制元素。还要注意，该算法允许以任何顺序呈现大多数元素，这是它流行的另一个原因。然而，z缓冲区仅在屏幕上的每个点存储单个深度，因此它不能用于半透明的元素。这些元素必须在所有不透明元素之后呈现，并且按照前后顺序呈现，或者使用独立于顺序的算法。透明度是基本z缓冲区的主要弱点之一。</strong></p>
<p><strong>我们已经提到，颜色缓冲区用于存储颜色，而z缓冲区用于存储每个像素的z值。然而，还有其他通道和缓冲区可以用来过滤和捕获片段信息。alpha通道与颜色缓冲相关联，并为每个像素存储相关的不透明度值。在较早的API中，alpha通道也被用来通过alpha测试特性选择性地丢弃像素。现在，丢弃操作可以被插入到像素着色程序中，任何类型的计算都可以用来触发丢弃。这种类型的测试可以用来确保完全透明的片段不会影响z缓冲区。</strong></p>
<p><strong>模板缓冲区是一个屏幕外缓冲区，用于记录所呈现元素的位置。它通常包含每像素8位。元素可以使用各种函数呈现到模板缓冲区中，然后可以使用缓冲区的内容控制渲染到颜色缓冲和z缓冲。模板缓冲区是生成一些特殊效果的强大工具。管线末尾的所有这些函数都称为光栅操作(ROP)或混合操作。可以将颜色缓冲中当前的颜色与三角形中正在处理的像素的颜色混合。这可以实现诸如透明度或颜色样本积累等效果。如前所述，混合通常是使用API配置的，而不是完全可编程的。然而，一些API支持光栅顺序视图，也称为像素着色顺序，它支持可编程混合功能。</strong></p>
<p><strong>绘图缓冲区通常由系统上的所有缓冲区组成。</strong></p>
<p><strong>当元素达到并通过光栅化阶段时，那些从相机角度可见的元素就显示在屏幕上。屏幕显示颜色缓冲的内容。为了避免让显示器看到被光栅化并发送到屏幕的元素，使用了双重缓冲。这意味着场景的呈现发生在屏幕之外的后台缓冲区中。在后台缓冲区中渲染场景后，后台缓冲区的内容将与之前显示在屏幕上的前台缓冲区的内容交换。交换通常发生在垂直回描期间，此时这样做是安全的。</strong></p>
<h2 id="Through-the-Pipeline-完成管线"><a href="#Through-the-Pipeline-完成管线" class="headerlink" title="Through the Pipeline 完成管线"></a>Through the Pipeline 完成管线</h2><p><strong>点、线和三角形是用来构建模型或对象的渲染原语。假设该应用程序是一个交互式计算机辅助设计(CAD)应用程序，用户正在检查华夫饼机的设计。在这里，我们将遵循这个模型完成整个图形渲染流水线，包括四个主要阶段:应用程序、几何、光栅化和像素处理。场景以透视图呈现在屏幕上的一个窗口中。</strong></p>
<h3 id="Application-应用程序"><a href="#Application-应用程序" class="headerlink" title="Application 应用程序"></a>Application 应用程序</h3><p><strong>CAD应用程序允许用户选择和移动模型的部分。对于要渲染的每一帧，应用程序阶段将摄像机位置、照明和模型的原语提供给管道中的下一个主要阶段——几何阶段。</strong></p>
<h3 id="Geometry-Processing-几何处理-1"><a href="#Geometry-Processing-几何处理-1" class="headerlink" title="Geometry Processing 几何处理"></a>Geometry Processing 几何处理</h3><p><strong>对于透视图，我们假设应用程序已经提供了一个投影矩阵。此外，对于每个对象，应用程序已经计算了一个矩阵，该矩阵描述了视图转换以及对象本身的位置和方向。在几何阶段，对象的顶点和法线用这个矩阵进行变换，将对象放入视图空间。然后使用材质和光源属性计算顶点的着色或其他计算。然后使用一个单独的用户提供的投影矩阵来执行投影，将对象转换为表示人眼所看到的单位立方体空间。立方体之外的所有元素都将被丢弃。所有与这个单元立方体相交的元素都被剪切到立方体上，以获得一组完全位于该单元立方体内部的原语。然后这些顶点被映射到屏幕上的窗口中。在所有这些每个三角形和每个顶点的操作完成之后，得到的数据被传递到光栅化阶段。</strong></p>
<h3 id="Rasterization-光栅化-1"><a href="#Rasterization-光栅化-1" class="headerlink" title="Rasterization 光栅化"></a>Rasterization 光栅化</h3><p><strong>在前一阶段裁剪下来的所有元素都被光栅化，这意味着元素中的所有像素都被找到，并通过管道进一步发送到像素处理。</strong></p>
<h3 id="Pixel-Processing-像素处理-1"><a href="#Pixel-Processing-像素处理-1" class="headerlink" title="Pixel Processing 像素处理"></a>Pixel Processing 像素处理</h3><p><strong>这里的目标是计算每个可见元素的每个像素的颜色。那些与任何纹理(图像)相关联的三角形将根据需要使用这些图像进行渲染。可见性通过z缓冲区算法解决，以及可选的丢弃和模板测试。每个对象都被依次处理，最后的图像就会显示在屏幕上。</strong></p>
<h3 id="Conclusion-总结"><a href="#Conclusion-总结" class="headerlink" title="Conclusion 总结"></a>Conclusion 总结</h3><p><strong>这个管道是几十年来针对实时渲染应用程序的API和图形硬件发展的结果。需要注意的是，这并不是唯一可能的渲染管线;离线渲染管线经历了不同的进化路径。电影制作中的渲染通常是用微多边形管线完成的，但光线追踪和路径追踪最近开始流行。</strong></p>
<p><strong>多年来，应用程序开发人员使用这里描述的过程的唯一方法是通过正在使用的图形API定义的固定函数管线。固定函数管线之所以如此命名，是因为实现它的图形硬件由无法以灵活方式编程的元素组成。上一个大型固定功能游戏机的例子是任天堂(Nintendo)于2006年推出的Wii游戏机。另一方面，可编程GPU可以精确地确定在整个管线的各个子阶段中应用了哪些操作。</strong></p>
<h1 id="3-The-Graphics-Processing-Unit-图形处理单元"><a href="#3-The-Graphics-Processing-Unit-图形处理单元" class="headerlink" title="3 The Graphics Processing Unit 图形处理单元"></a>3 The Graphics Processing Unit 图形处理单元</h1><h2 id="Data-Parallel-Architectures-数据并行架构"><a href="#Data-Parallel-Architectures-数据并行架构" class="headerlink" title="Data-Parallel Architectures 数据并行架构"></a>Data-Parallel Architectures 数据并行架构</h2><p><strong>不同的处理器体系结构使用不同的策略来避免停顿。CPU被优化以处理各种各样的数据结构和大型代码库。CPU可以有多个处理器，但每个处理器主要以串行方式运行代码，限制SIMD向量处理是一个次要的异常。为了最小化延迟的影响，CPU的大部分芯片由快速本地缓存组成，内存中充满了可能需要的数据。CPU还通过使用分支预测、指令重排序、寄存器重命名和缓存预取等技术来避免停顿。</strong></p>
<p><strong>GPU采用不同的方法。GPU的大部分芯片区域都是专门用于一组大型处理器，称为着色器核心，通常有数千个。GPU是一种流处理器，它依次处理相似数据的有序集。由于这种相似性(例如一组顶点或像素)，GPU可以以大规模并行方式处理这些数据。另一个重要的因素是，这些调用尽可能独立，这样它们就不需要从相邻的调用获取信息，也不共享可写内存位置。这条规则有时会被打破，以允许新的和有用的功能，但这种异常的代价是潜在的延迟，因为一个处理器可能会等待另一个处理器完成它的工作。</strong></p>
<p><strong>GPU为吞吐量进行了优化，吞吐量定义为数据可处理的最大速率。然而，这种快速处理是有代价的。由于专用于高速缓存内存和控制逻辑的芯片面积更少，每个着色器核心的延迟通常比CPU处理器遇到的要高得多。</strong></p>
<p><strong>假设一个网格被光栅化了，需要处理两千个像素碎片;一个像素着色程序将被调用2000次。假设是世界上最弱的GPU，只有一个着色器处理器。它开始为2000的第一个片段执行着色程序。着色处理器对寄存器中的值执行一些算术操作。注册是本地的和快速的进入，所以不会发生失速。然后，着色器处理器进入一个指令，例如，对于给定的表面位置，程序需要知道应用到网格上的图像的像素颜色。纹理是一个完全独立的资源，而不是像素程序本地内存的一部分，并且纹理访问可能会涉及一些内容。一次内存获取可能需要数百到数千个时钟周期，在此期间GPU处理器不做任何事情。此时，着色器处理器将暂停，等待纹理的颜色值返回。</strong></p>
<p><strong>为了让这个GPU变得更好，我们需要为每个片段提供一些存储空间用于其本地寄存器。现在，着色处理器可以切换并执行另一个片段，2000中的第2个片段，而不是在获取纹理时停滞不前。这个切换非常快，除了注意哪个指令在第一个指令上执行之外，第一个或第二个片段中没有任何影响。现在执行第二个片段。与第一个相同，执行一些算术函数，然后再次遇到纹理获取。着色器核心现在切换到另一个片段，三号。最终，所有2000个片段都以这种方式处理。此时，着色器处理器返回到片段1。此时纹理颜色已经被获取，可以使用，所以着色程序可以继续执行。处理器以同样的方式继续执行，直到遇到另一条已知会导致执行暂停的指令，或者程序完成。一个单独的片段将花费比如果着色处理器关注它更长的时间来执行，但整体上片段的整体执行时间大大减少。</strong></p>
<p><strong>在这个架构中，通过切换到另一个片段让GPU保持忙碌，可以隐藏延迟。GPU通过将指令执行逻辑与数据分离，将这种设计向前推进了一步。被称为单指令多数据(SIMD)，这种安排在固定数量的着色程序上以锁步的方式执行相同的命令。SIMD的优点是，与使用单独的逻辑和调度单元来运行每个程序相比，用于处理数据和切换的硅(和功率)要少得多。把我们的2000个碎片的例子转换成现代的GPU术语，每个碎片的像素着色器调用被称为线程。这种类型的线程不像CPU线程。它包含一些内存，用于给着色器输入值，以及着色器执行所需的任何寄存器空间。使用相同着色程序的线程被捆绑成组，NVIDIA称之为“warps”，AMD称之为“wavefronts”。warp/wavefront被安排由一些数字GPU着色核执行，从8到64，使用SIMD处理。每个线程都映射到一个SIMD通道。</strong></p>
<p><strong>假设我们有两千个线程要执行。NVIDIA GPU上的warps包含32个线程。这就产生了2000/32 = 62.5条warps，这意味着分配了63条warps，其中一条warp是半空的。warp的执行类似于我们的单一GPU处理器的例子。着色程序在所有32个处理器上执行。当遇到内存获取时，所有线程都同时遇到它，因为对所有线程执行相同的指令。信号表明这个扭曲的线程将停止，所有线程都在等待它们的(不同的)结果。而不是拖延，warp被替换为32个线程的不同warp，然后由32个内核执行。这种交换就像我们的单处理器系统一样快，因为当warp被交换时，每个线程内的数据都不会被接触。每个线程都有自己的寄存器，每个warp跟踪它正在执行的指令。在一个新的warp中，交换只是将一组核心指向另一组要执行的线程;没有其他费用。执行或换出warps，直到全部完成。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210909104537.png" class="" title="image-20210909104537">

<p>简化的着色器执行示例。三角形的碎片，也就是所谓的线程，被聚拢成warps。每条warp显示为四根线程，但实际上有32根线程。要执行的着色程序有5个指令长。四个GPU着色处理器的集合执行这些指令，直到“txr”命令检测到一个暂停条件，这需要时间来获取它的数据。第二个warp被调换，着色程序的前三个指令被应用到它，直到再次检测到失速。在第三次跃迁被交换并停止后，执行继续通过交换第一次跃迁并继续执行。如果此时它的“txr”命令的数据还没有返回，那么执行将真正停止，直到这些数据可用为止。每条warp依次整理。</p>
<p><strong>在我们的简单示例中，为纹理获取内存的延迟可能会导致warp的交换。在现实中，由于交换的成本很低，可以用更短的延迟来交换warp。还有其他一些技术用于优化执行，但warp交换是所有GPU使用的主要延迟隐藏机制。这一过程的工作效率涉及到几个因素。例如，如果线程很少，那么创建很少的warp，从而造成延迟隐藏的问题。</strong></p>
<p><strong>着色程序的结构是影响效率的一个重要特征。一个主要因素是每个线程的寄存器使用量。在我们的例子中，我们假设两千个线程可以同时驻留在GPU上。与每个线程关联的着色程序需要的寄存器越多，驻留在GPU中的线程就越少，因此warp也就越少。缺乏warp可能意味着失速不能通过交换来缓解。常驻的warp被称为“in flight”，这个数字被称为占用率。高占用率意味着有许多可处理的warp，因此空闲处理器的可能性较小。占用率低往往会导致性能不佳。内存获取的频率也会影响需要多少延迟隐藏。</strong></p>
<p><strong>另一个影响整体效率的因素是由“if”语句和循环引起的动态分支。假设在着色程序中遇到了一个“if”语句。如果所有的线程都计算并使用同一个分支，那么warp就可以继续运行而不需要考虑其他分支。然而，如果一些线程，甚至是一个线程，采用了替代路径，那么warp必须执行两个分支，抛弃每个特定线程不需要的结果。这个问题被称为线程发散，在这种情况下，一些线程可能需要执行一个循环迭代或执行一个“if”路径，而在warp中其他线程不需要，这使得它们在这段时间内处于空闲状态。</strong></p>
<p><strong>所有GPU都实现了这些架构思想，导致系统受到严格的限制，但每瓦特的计算能力却是巨大的。了解这个系统是如何运行的，将有助于作为程序员的您更有效地利用它提供的功能。</strong></p>
<h2 id="GPU-Pipeline-Overview-GPU管线概述"><a href="#GPU-Pipeline-Overview-GPU管线概述" class="headerlink" title="GPU Pipeline Overview GPU管线概述"></a>GPU Pipeline Overview GPU管线概述</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210909104608.png" class="" title="image-20210909104608">

<p>GPU实现的渲染管线。这些阶段根据用户对其操作的控制程度用颜色编码。绿色阶段是完全可编程的。虚线表示可选阶段。黄色阶段是可配置的，但不能编程。蓝色阶段的功能是完全固定的。</p>
<p><strong>这里描述的是GPU的逻辑模型，作为程序员的你可以通过API看到它。这个逻辑管道(物理模型)的实现取决于硬件供应商。通过向相邻的可编程阶段添加命令，可以在GPU上执行逻辑模型中具有固定功能的阶段。管道中的单个程序可以被分割成由单独的子单元执行的元素，也可以完全由单独的传递执行。逻辑模型可以帮助你推断什么会影响性能，但它不应该被误解为GPU实际实现管道的方式。</strong></p>
<p><strong>顶点着色器是一个完全可编程的阶段，用于实现几何处理阶段。</strong></p>
<p><strong>几何着色器是一个完全可编程的阶段，操作的顶点的一个基本(点，线，或三角形)。它可以用来执行每个元素的着色操作，销毁元素，或者创建新的元素。</strong></p>
<p><strong>曲面细分阶段和几何着色器都是可选的，并不是所有的GPU都支持它们，特别是在移动设备上。</strong></p>
<p><strong>裁剪、三角形设置和三角形遍历阶段由固定功能的硬件实现。</strong></p>
<p><strong>屏幕映射受窗口和视口设置的影响，在内部形成一个简单的比例和重新定位。</strong></p>
<p><strong>像素着色器阶段是完全可编程的。虽然合并阶段不是可编程的，但它是高度可配置的，可以设置以执行各种各样的操作。它实现了“合并”功能阶段，负责修改颜色、z缓冲区、混合、模板和任何其他输出相关的缓冲区。</strong></p>
<p><strong>随着时间的推移，GPU流水线已经从硬编码操作发展到越来越灵活和控制。可编程着色器阶段的引入是这个发展过程中最重要的一步。</strong></p>
<h2 id="The-Programmable-Shader-Stage-可编程着色器平台"><a href="#The-Programmable-Shader-Stage-可编程着色器平台" class="headerlink" title="The Programmable Shader Stage 可编程着色器平台"></a>The Programmable Shader Stage 可编程着色器平台</h2><p><strong>现代着色程序使用统一的着色器设计。这意味着顶点、像素、几何和细分相关的着色器共享一个共同的编程模型。它们在内部具有相同的指令集体系结构(ISA)。实现这个模型的处理器被称为DirectX中的common-shader core，具有这种内核的GPU被称为具有统一的着色器架构。这种架构背后的想法是，着色处理器可以用于多种角色，GPU可以根据需要分配。拥有独立的顶点和像素着色器核池的GPU意味着保持所有核繁忙的理想工作分布是严格预定的。使用统一的着色器内核，GPU可以决定如何平衡这种负载。</strong></p>
<p><strong>着色器使用类似C的着色语言编程，如DirectX的高级着色语言(HLSL)和OpenGL着色语言(GLSL)。DirectX的HLSL可以编译为虚拟机字节码，也称为中间语言(IL或dxie)，以提供硬件独立性。中间表示法也可以让着色程序离线编译和存储。该中间语言被驱动程序转换为特定GPU的ISA。控制台编程通常避免中间语言步骤，因为那时系统只有一个ISA。</strong></p>
<p><strong>基本的数据类型是32位单精度浮点标量和向量，尽管向量只是着色器代码的一部分，并且在上面概述的硬件中不支持。在现代GPU上，本地也支持32位整数和64位浮点数。浮点向量通常包含位置(xyzw)、法线、矩阵行、颜色(rgba)或纹理坐标(uvwq)等数据。整数最常用于表示计数器、索引或位掩码。还支持聚合数据类型，如结构、数组和矩阵。</strong></p>
<p><strong>一个绘制调用调用图形API来绘制一组元素，以此让图形管线执行和运行它的着色器。每个可编程着色器阶段有两种类型的输入:统一的输入，在整个绘制调用中保持不变的值(但可以在绘制调用之间改变)，和不同的输入，来自三角形顶点或光栅化的数据。纹理是一种特殊的统一输入，它曾经是应用于表面的彩色图像，但现在它可以被认为是任何大的数据数组。</strong></p>
<p><strong>底层虚拟机为不同类型的输入和输出提供了特殊的寄存器。统一虚拟机中可用的常数寄存器的数量要比用于不同输入或输出的寄存器多得多。这是因为不同的输入和输出需要分别存储在每个顶点上或像素，所以需要的数量是有自然限制的。统一输入存储一次，并在draw调用中的所有顶点或像素中重用。虚拟机还有通用的临时寄存器，用于临时存储空间。所有类型的寄存器都可以在临时寄存器中使用整数值进行数组索引</strong>。</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210910125455.png" class="" title="image-20210910125455">

<p>统一的虚拟机架构和注册布局，在Shader Model 4.0下。最大可用数量在每个资源旁边指示。用斜杠分隔的三个数字表示顶点、几何和像素着色器的限制(从左到右)。</p>
<p><strong>图形计算中常见的操作可以在现代GPU上高效地执行。着色器语言通过操作符*和+暴露了这些最常见的操作(如加法和乘法)。其余的通过内在函数暴露，例如，atan()， sqrt()， log()和许多其他的，为GPU优化。函数也存在更复杂的运算，如向量的标准化和反射，叉积，矩阵转置和行列式计算。</strong></p>
<p><strong>术语流控制指的是使用分支指令来更改代码执行流。与流控制相关的指令用于实现高级语言结构，如“if”和“case”语句，以及各种类型的循环。着色器支持两种类型的流量控制。静态流量控制分支基于统一输入的值。这意味着代码流在draw调用中是不变的。静态流量控制的主要好处是允许相同的着色器在不同的情况下使用(例如，不同数量的灯光)。没有线程分歧，因为所有调用都采用相同的代码路径。动态流控制是基于不同的输入值，这意味着每个片段可以以不同的方式执行代码。这比静态流控制更强大，但会降低性能，特别是当代码流在着色器调用之间变化不稳定时。</strong></p>
<h2 id="The-Evolution-of-Programmable-Shading-and-APIs-可编程着色器和API的演变"><a href="#The-Evolution-of-Programmable-Shading-and-APIs-可编程着色器和API的演变" class="headerlink" title="The Evolution of Programmable Shading and APIs 可编程着色器和API的演变"></a>The Evolution of Programmable Shading and APIs 可编程着色器和API的演变</h2><p>可编程着色器框架的想法可以追溯到1984年Cook的着色树。RenderMan着色语言是在20世纪80年代后期从这个想法发展而来的。它今天仍然被用于电影制作渲染，以及其他不断发展的规范，如开放着色语言(OSL)项目。<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210910132418.png" class="" title="image-20210910132418"></p>
<p>着色树是一个简单的镜面着色器。</p>
<p><strong>1996年10月1日，3dfx Interactive首次成功地推出了消费者级图形硬件。他们的Voodoo显卡能够渲染游戏《雷神之锤》的高质量和性能，这使得它很快被采用。这个硬件实现了一个固定功能的管线。在GPU原生支持可编程着色器之前，通过多个渲染通道实现可编程着色操作的尝试很多。1999年《雷神之锤3:竞技场》的脚本语言最先被广泛使用，并取得了商业上的成功。NVIDIA的GeForce256是第一个被称为GPU的硬件，但它不是可编程的。然而，它是可配置的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210910132709.png" class="" title="image-20210910132709">

<p>一些API和图形硬件发布的时间表。</p>
<p><strong>在2001年初，NVIDIA的GeForce 3是第一个支持可编程顶点着色器的GPU，通过DirectX 8.0和OpenGL扩展。这些着色器是用一种类似汇编语言的语言编写的，驱动程序会在运行时将其转换成微码。DirectX 8.0中也包含了像素着色器，但像素着色器缺乏实际的可编程性——受支持的有限的“程序”被驱动程序转换成纹理混合状态，然后将硬件“寄存器组合器”连接在一起。这些“程序”不仅长度有限(12条或更少)，而且缺乏重要的功能。Peercy等人通过对RenderMan的研究发现，依赖纹理读取和浮点数据对真正的可编程性至关重要。</strong></p>
<p><strong>当时的着色器不允许流控制(分支)，所以条件必须通过计算术语和选择或插值结果来模拟。DirectX定义了着色器模型(SM)的概念，以区分具有不同着色器功能的硬件。2002年，DirectX 9.0发布了，其中包括Shader Model 2.0，它以可编程的顶点和像素着色器为特色。OpenGL使用各种扩展也暴露了类似的功能。增加了对任意依赖纹理读取和存储16位浮点值的支持，最终完成了Peercy等人确定的需求集。对材质资源(如指令、纹理和寄存器)的限制增加了，所以材质能够产生更复杂的效果。还添加了对流量控制的支持。着色器不断增长的长度和复杂性使得汇编编程模型越来越麻烦。幸运的是,DirectX 9.0还包括HLSL。这种着色语言是由微软与NVIDIA合作开发的。大约在同一时间，OpenGL ARB(架构审查委员会)发布了GLSL，一种与OpenGL相当相似的语言。这些语言深受C编程语言的语法和设计哲学的影响，并包含了来自RenderMan着色语言的元素。</strong></p>
<p><strong>Shader Model 3.0于2004年推出，并添加了动态流控制，使Shader变得更加强大。它还将可选功能转变为需求，进一步增加了资源限制，并添加了有限的顶点着色器纹理读取支持。2005年末，当新一代游戏机(Mi- crosoft的Xbox 360)和2006年末(索尼电脑娱乐(Sony Computer Entertainment)的PLAYSTATION 3系统)推出时，它们都配备了Shader Model 3.0级GPU。任天堂的Wii游戏机是最后一批引人注目的固定功能GPU之一，最初是在2006年底发布的。纯固定函数的管线早已不复存在。着色器语言已经发展到一个点，各种工具被用来创建和管理它们。</strong></p>
<p><strong>可编程性的下一个大进步也在2006年底出现。Shader Model 4.0，包含在DirectX 10.0中，引入了几个主要功能，如几何着色器和流输出。着色器模型4.0包括一个统一编程模型的所有着色器(顶点，像素，和几何)。资源限制进一步增加，并增加了对整数数据类型(包括位操作)的支持。OpenGL 3.3中引入的GLSL 3.30提供了一个类似的着色器模型。</strong></p>
<p><strong>在2009年DirectX 11和Shader Model 5.0发布，添加了细分着色器和计算着色器，也称为DirectCompute。该版本还关注于更有效地支持CPU多处理。OpenGL在4.0版增加了细分，在4.3版增加了计算着色器。DirectX和OpenGL的发展是不同的。两者都为特定版本版本设置了所需的特定级别的硬件支持。微软控制DirectX API，因此直接与独立硬件供应商(IHVs)，如AMD、NVIDIA和英特尔，以及游戏开发者和计算机辅助设计软件公司合作，以确定要公开哪些特性。OpenGL由一个硬件和软件供应商联盟开发，由非营利组织Khronos Group管理。由于涉及的公司很多，API特性OpenGL的发布版通常会在DirectX之后。然而，OpenGL允许扩展，供应商特定的或更一般的，允许最新的GPU功能在官方支持之前在发布。</strong></p>
<p><strong>API的下一个重大变化是由AMD在2013年引入的Mantle API。《Mantle》是与电子游戏开发商DICE合作开发的，其理念是剥离大部分图像驱动程序的开销，将控制权直接交给开发者。除了重构之外，还进一步支持有效的CPU多处理。这类新的API主要关注于极大地减少CPU在驱动程序中花费的时间，以及更有效的CPU多处理器支持。在Mantle中首创的想法被微软采纳，并于2015年发布为DirectX 12。请注意，DirectX 12并不专注于暴露新的GPU功能——DirectX 11.3暴露了相同的硬件特性。这两个API都可以用来向Oculus Rift和HTC Vive等虚拟现实系统发送图像。然而，DirectX 12是一个彻底的重新设计的API，一个更好地映射到现代GPU的架构。低开销驱动对于CPU驱动成本造成瓶颈的应用程序很有用，或者使用更多的CPU处理器来处理图形可以提高性能。从早期的API移植可能会很困难，而且简单的实现可能会导致较低的性能。</strong></p>
<p><strong>苹果在2014年发布了自己的低开销API Metal。iPhone 5S和iPad Air等移动设备首先可以使用Metal功能，一年后，新版麦金塔电脑也可以通过OS X El Capitan接入。除了效率，降低CPU的使用还可以节省电力，这是移动设备的一个重要因素。这个API有自己的着色语言，适用于图形和GPU计算程序。</strong></p>
<p><strong>AMD将其Mantle工作捐赠给了Khronos集团，后者在2016年初发布了自己的新API Vulkan。与OpenGL一样，Vulkan可以在多种操作系统上运行。Vulkan使用一种新的高级中间语言SPIR- V，它既用于着色器表示，也用于一般的GPU计算。预编译着色器是可移植的，所以可以在任何支持的GPU上使用需要的功能。Vulkan也可以用于非图形GPU计算，因为它不需要显示窗口。Vulkan与其他低功耗驱动程序的一个显著区别是，它适用于从工作站到移动设备的各种系统。</strong></p>
<p><strong>在移动设备上，标准是使用OpenGL ES。“ES”代表嵌入式系统，因为这个API是为移动设备开发的。当时的标准OpenGL在一些调用结构上相当笨重和缓慢，并且需要对很少使用的功能的支持。发布于2003年的OpenGL ES 1.0是OpenGL 1.3的精简版，描述了一个固定功能的管线。虽然DirectX的发布与支持它们的图形硬件同步，但开发移动设备的图形支持并没有以同样的方式进行。例如，2010年发布的第一代iPad就实现了OpenGL ES 1.1。2007年，OpenGL ES 2.0规范发布，提供可编程着色器。它基于OpenGL 2.0，但没有固定功能组件，因此不向后兼容OpenGL ES 1.1。OpenGL ES 3.0于2012年发布，提供了多种渲染目标、纹理压缩、变换反馈、实例化以及更广泛的纹理格式和模式，以及着色器语言的改进。OpenGL ES 3.1增加了计算着色器，3.2增加了几何和镶嵌着色器等功能。</strong></p>
<p><strong>OpenGL ES的一个分支是基于浏览器的API WebGL，通过JavaScript调用。这个API的第一个版本发布于2011年，可以在大多数移动设备上使用，因为它在功能上相当于OpenGL ES 2.0。与OpenGL一样，扩展提供了更高级的GPU特性。WebGL 2假定支持OpenGL ES 3.0。</strong></p>
<p><strong>WebGL特别适合实验功能或在课堂上使用:</strong></p>
<pre><code>**它是跨平台的，可以在所有个人电脑和几乎所有移动设备上运行。**

**驱动程序审批由浏览器处理。即使一个浏览器不支持特定的GPU或扩展，也会有另一个浏览器支持。**

**代码是解释的，而不是编译的，开发只需要一个文本编辑器。**

**大多数浏览器都内置了调试器，可以检查在任何网站上运行的代码。**

**程序可以通过上传到网站或Github来部署。**
</code></pre>
<p><strong>更高级的场景图和效果库，如three.js，可以方便地访问各种更复杂的效果的代码，如阴影算法、后期处理效果、基于物理的着色和延迟渲染。</strong></p>
<h2 id="The-Vertex-Shader-顶点着色器"><a href="#The-Vertex-Shader-顶点着色器" class="headerlink" title="The Vertex Shader 顶点着色器"></a>The Vertex Shader 顶点着色器</h2><p><strong>顶点着色器是函数函数管线中的第一阶段。虽然这是直接由程序员控制的第一阶段，但值得注意的是，在此阶段之前发生了一些数据操作。在DirectX调用的输入汇编器中，几个数据流可以编织在一起，形成沿管线发送的顶点和原语集。输入汇编器将通过创建带有位置和颜色的顶点来创建对象的三角形(或线或点)。第二个对象可以使用相同的位置数组(以及不同的模型转换矩阵)和不同的颜色数组来表示它。在输入汇编程序中也支持执行实例化。这允许一个对象用每个实例的一些变化的数据绘制多次，所有这些都只用一个绘制调用。</strong></p>
<p><strong>三角形网格由一组顶点表示，每个顶点都与模型表面上的特定位置相关联。除了位置之外，每个顶点还有其他可选属性，比如颜色或纹理坐标。表面法线也定义在网格顶点，这似乎是一个奇怪的选择。数学上，每个三角形都有一个明确定义的表面法线，它可能更有意义使用三角形的法线直接进行着色。然而，在渲染时，三角形网格通常被用来表示一个底层曲面，顶点法线被用来表示曲面的方向，而不是三角形网格本身的方向。下图显示了两个代表曲面的三角形网格的侧视图，一个平滑，一个有尖锐的折痕。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210911111517.png" class="" title="image-20210911111517">

<p>三角形网格的侧视图(黑色，顶点法线)表示曲面(红色)。在左边平滑的顶点法线被用来表示平滑的表面。在右边，中间顶点被复制，并给出两条法线，表示一条折痕。</p>
<p><strong>顶点着色器是处理三角形网格的第一阶段。顶点着色器无法获得描述三角形形成的数据。顾名思义，它只处理传入的顶点。顶点着色器提供了一种方法修改、创建或忽略与每个三角形顶点相关的值，如其颜色、法线、纹理坐标和位置。通常顶点着色程序将顶点从模型空间转换到均匀裁剪空间。至少，顶点着色器必须始终输出这个位置。</strong></p>
<p><strong>顶点着色器与前面描述的统一着色器非常相似。每个传入的顶点都由顶点着色程序处理，然后输出一些值，这些值被插入到三角形或直线上。顶点着色器既不能创建也不能销毁顶点，一个顶点生成的结果不能传递到另一个顶点。因为每个顶点都是独立处理的，所以GPU上的任意数量的着色器处理器都可以并行应用于传入的顶点流。</strong></p>
<p><strong>输入装配通常是在执行顶点着色器之前出现的一个过程。在这个例子中，物理模型经常与逻辑模型不同。物理上，获取数据来创建顶点可能会发生在顶点着色器中，驱动程序会悄悄地为每个着色器添加适当的指令，而程序员是看不见的。</strong></p>
<p><strong>顶点着色器的其他用途包括:</strong></p>
<pre><code>**对象生成，只创建一个网格，并让它被顶点着色器变形。**

**使用蒙皮和变形技术制作动画角色的身体和脸。**

**程序变形，如旗帜、布料或水的移动。**

**粒子创建，发送简化(无区域)网格给管线和有这些需要的区域。**

**通过使用整个帧缓冲区的内容作为纹理在屏幕对齐的网格上进行程序变形，镜头失真、热雾、水波纹、页面卷曲和其他效果。**

**使用顶点纹理获取来应用地形高度域。**
</code></pre>
<p><strong>顶点着色器的输出可以用几种不同的方式来使用。通常的路径是每个实例的原语，例如，三角形，然后被生成和栅格化，产生的单个像素碎片被发送到像素着色程序继续处理。在一些GPU上，数据也可以发送到细分阶段或几何着色器或存储在内存中。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210911112605.png" class="" title="image-20210911112605">

<p>左边是一个普通的茶壶。一个简单的剪切操作执行顶点着色程序产生中间的图像。在右边，一个噪声函数创建了一个扭曲模型的场。(图片由FX Composer 2制作，NVIDIA公司提供。)</p>
<h2 id="The-Tessellation-Stage-镶嵌细分阶段"><a href="#The-Tessellation-Stage-镶嵌细分阶段" class="headerlink" title="The Tessellation Stage 镶嵌细分阶段"></a>The Tessellation Stage 镶嵌细分阶段</h2><p><strong>镶嵌细分阶段允许我们渲染曲面。GPU的任务是获取每个表面描述，并将其转换成一组具有代表性的三角形。这个阶段是一个可选的GPU特性，它首先在DirectX 11中可用(并且是必需的)。OpenGL 4.0和OpenGL ES 3.2也支持它。</strong></p>
<p><strong>使用镶嵌细分有几个优点。曲面的描述往往比提供相应的三角形本身更紧凑。除了节省内存，这一特性还可以避免CPU和GPU之间的总线成为动画角色或每帧形状都在变化的对象的瓶颈。通过为给定的视图生成适当数量的三角形，可以有效地渲染表面。例如，如果一个球离相机很远，那么只需要几个三角形。近距离观察，它可能用数千个三角形表现得最好。这种控制细节级别的能力也允许应用程序控制其性能，例如，使用较弱的GPU上的较低质量的网格来维持帧率。通常由平面表示的模型可以转换为三角形细网格，然后根据需要进行弯曲，或者可以对模型进行镶嵌，以减少昂贵的着色计算。</strong></p>
<p><strong>镶嵌细分通常由三个要素组成。使用DirectX的术语，这些是外壳着色器，镶嵌器和域着色器。在OpenGL中，外壳着色器是镶嵌控制着色器，域着色器是镶嵌评估着色器。固定函数tesselator在OpenGL中被称为原始生成器。</strong></p>
<p><strong>首先，外壳着色器的输入是一个特殊的补丁原语。它由几个控制点组成，定义细分曲面、贝塞尔贴片或其他类型的曲面元素。外壳着色器有两个功能。首先，它告诉镶嵌器应该生成多少个三角形，以及在什么配置中。其次，它对每个控制点执行处理。此外，可选的，外壳着色器可以修改传入补丁描述，根据需要添加或删除控制点。船体着色器输出它的控制点集，连同镶嵌控制数据，到域着色器。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210911130526.png" class="" title="image-20210911130526">

<p>镶嵌细分阶段。外壳着色器采用了一个由控制点定义的补丁。它将镶嵌因子(TFs)和类型发送给固定功能镶嵌器。控制点集被转换为所需的外壳着色器，连同TFs和相关的补丁常量，发送到域着色器。镶嵌器创建顶点集及其重心坐标。然后这些被域着色器处理，产生三角形网格(控制点显示为参考)。</p>
<p><strong>镶嵌器是管线中的一个固定功能阶段，只与镶嵌着色器一起使用。它的任务是为域着色器添加几个新的顶点来处理。外壳着色器向镶嵌器发送关于需要哪种类型的镶嵌表面的信息:三角形、四边形或等值线（等值线是一组线条，有时用于头发渲染）。船体着色器发送的其他重要值是镶嵌因子(OpenGL中的镶嵌级别)。这些有两种类型:内边缘和外边缘。这两个内部因素决定了多少镶嵌发生在三角形或四边形内部。外部因素决定每条外部边被分割的程度。通过允许单独的控制，我们可以让相邻曲面的边缘在镶嵌中匹配，而不管内部是如何镶嵌的。匹配的边缘避免了裂缝或其他着色的地方的斑块。顶点被赋以重心坐标，这些值指定了所需曲面上每个点的相对位置。</strong></p>
<p><strong>外壳着色器总是输出一个补丁，一组控制点位置。但是，它可以通过向镶嵌器发送0或更小的外部镶嵌级别(或非数字，NaN)来表示要丢弃补丁。否则，镶嵌器生成一个网格并将其发送到域着色器。曲面的控制点来自于外壳着色器，用于每次调用域着色器来计算每个顶点的输出值。域着色器有一个类似于顶点着色器的数据流模式，每个来自镶嵌器的输入顶点都被处理并生成相应的输出顶点。然后形成的三角形沿着管线传递下去。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210911131217.png" class="" title="image-20210911131217">

<p>改变镶嵌因素的影响。The Utah teapot由32块面片组成。内、外镶嵌因子从左到右分别为1、2、4、8。(图片由Rideout和Van Gelder的演示生成。)</p>
<p><strong>虽然这个系统听起来很复杂，但它的结构是这样的效率，每个着色器都可以相当简单。进入外壳着色器的补丁通常很少或没有修改。这个着色器也可以使用补丁的估计距离或屏幕大小来实时计算镶嵌因子，如地形渲染。另外，外壳着色器可以简单地传递应用程序计算和提供的所有补丁的一组固定值。镶嵌器执行一个复杂但功能固定的过程，生成顶点，给出它们的位置，并指定它们形成的三角形或直线。为了提高计算效率，数据放大步骤在着色器之外执行。域着色器获取每个点生成的重心坐标，并在补丁的评估方程中使用这些坐标来生成位置、法线、纹理坐标和其他所需的顶点信息。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210911132016.png" class="" title="image-20210911132016">

<p>左边是由6000个三角形组成的网格。在右侧，每个三角形使用PN三角形细分进行镶嵌和位移。(图片来自NVIDIA SDK 11样本，由NVIDIA公司提供，模型来自4A Games的Metro 2033。)</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210911132058.png" class="" title="image-20210911132058">

<p>几何着色程序的几何着色输入是一些单一类型:点，线段，三角形。最右边的两个原语包括与直线和三角形对象相邻的顶点。更复杂的补丁类型也是可能的。</p>
<h2 id="The-Geometry-Shader-几何着色器"><a href="#The-Geometry-Shader-几何着色器" class="headerlink" title="The Geometry Shader 几何着色器"></a>The Geometry Shader 几何着色器</h2><p><strong>几何着色器可以将元素转换成其他元素，这是镶嵌阶段做不到的。例如，一个三角形网格可以通过每个三角形创建线边来转换成线框视图。另外，这些线也可以用面向观众的四边形代替，这样就可以制作出边缘较厚的线框图。几何着色器在2006年末的DirectX 10发布时被添加到硬件加速的图形管线中。它位于管线中的镶嵌着色器之后，它的使用是可选的。虽然是Shader Model 4.0的必要部分，但在早期的Shader模型中没有使用。OpenGL 3.2和OpenGL ES 3.2也支持这种类型的着色器。</strong></p>
<p><strong>几何着色器的输入是一个单一的对象及其相关的顶点。物体通常由条状、线段或简单点上的三角形组成。扩展基元可以定义和处理几何着色器。特别地，三角形外的三个额外顶点可以被传递进来，折线上的两个相邻顶点也可以被使用。使用DirectX 11和Shader Model 5.0，你可以通过更复杂的补丁，多达32个控制点。也就是说，镶嵌阶段对生成补丁更有效。</strong></p>
<p><strong>几何着色器处理这个元素并输出零个或多个顶点，这些顶点被视为点、折线或三角形条。注意，任何输出都不能由几何着色器生成。因此，可以通过编辑顶点、添加新元素和删除其他元素来选择性地修改网格。</strong></p>
<p><strong>几何着色器设计用于修改传入数据或制作有限数量的副本。例如，一个用途是生成6个经过转换的数据副本，以同时呈现立方体映射的6个面;它还可以用于高效地创建级联阴影贴图，以生成高质量的阴影。其他利用几何着色器的算法包括从点数据创建可变大小的粒子，沿着轮廓挤压鳍用于皮毛渲染，以及为阴影算法寻找物体边缘。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210912125037.png" class="" title="image-20210912125037">

<p>一些几何着色器(GS)的使用。在左侧，使用GS在飞行中进行元等值面镶嵌。在中间，利用GS完成线段的分形细分并流出，由GS生成广告牌以显示闪电。在右侧，布料模拟是通过使用顶点和几何着色器来完成的。(图片来自NVIDIA SDK 10[1300]样本，由NVIDIA公司提供。)</p>
<p><strong>DirectX 11增加了几何着色器使用实例化的能力，其中几何着色器可以运行在任何给定的原始设定的次数。在OpenGL 4.0使用调用计数来指定。几何着色器也可以输出多达四个流。一个流可以通过呈现管线发送下去进行进一步处理。所有这些流可以被选择性地发送到流输出渲染目标。</strong></p>
<p><strong>几何着色器保证从元素中输出与输入顺序相同的结果。这影响性能，因为如果几个着色器内核并行运行，结果必须保存和顺序。这和其他因素的工作，避免几何着色器在一个单一调用被用于复制或创建大量的几何。</strong></p>
<p><strong>在绘制调用发出后，管线中只有三个地方可以在GPU上创建工作:光栅化、镶嵌阶段和几何着色器。其中，几何着色器的行为是最不可预测的，考虑到资源和内存需要，因为它是完全可编程的。在实践中，几何着色器通常很少使用，因为它不能很好地映射到GPU的优势。在一些移动设备上，它是在软件中实现的，所以在那里它不建议使用。</strong></p>
<h3 id="Stream-Output-流输出"><a href="#Stream-Output-流输出" class="headerlink" title="Stream Output 流输出"></a>Stream Output 流输出</h3><p><strong>GPU管线的标准用法是通过顶点着色器发送数据，然后栅格化生成的三角形，并在像素着色器中处理这些数据。过去，数据总是通过管线传递，中间结果无法访问。在Shader Model 4.0中引入了流输出的思想。顶点着色器(以及可选的镶嵌和几何着色器)处理完顶点后，这些可以在流中输出，例如，一个有序数组，除了被发送到栅格化阶段。栅格化实际上可以完全关闭，然后管线将纯粹用作非图形化流处理器。以这种方式处理的数据可以通过管线发送回来，从而允许迭代处理。这种类型的操作可以用于模拟流动的水或其他粒子效应。它还可以用于模型的皮肤，然后让这些顶点可以重用。</strong></p>
<p><strong>流输出仅以浮点数的形式返回数据，因此它可能有显著的内存消耗。流输出在元素上工作，而不是直接在顶点上工作。如果网格沿着管线发送，每个三角形都会生成自己的一组输出顶点。在原始网格中共享的任何顶点都将丢失。出于这个原因，更典型的用法是将顶点作为点集元素通过管线发送。在OpenGL中，流输出阶段被称为转换反馈，因为它的主要用途是转换顶点并返回它们以进行进一步处理。元素保证按照它们被输入的顺序被发送到流输出目标，这意味着顶点顺序将被保持。</strong></p>
<h2 id="The-Pixel-Shader-像素着色器"><a href="#The-Pixel-Shader-像素着色器" class="headerlink" title="The Pixel Shader 像素着色器"></a>The Pixel Shader 像素着色器</h2><p><strong>在顶点、镶嵌和几何着色器执行它们的操作后，元素被剪切并设置为光栅化。管线的这一部分相对固定在其处理步骤中，即不是可编程的，但可以配置。每个三角形都被遍历以确定它覆盖了哪些像素。栅格化器还可以粗略计算三角形覆盖每个像素的单元面积。这个三角形部分或完全重叠像素的部分称为碎片。</strong></p>
<p><strong>三角形顶点上的值，包括z缓冲区中使用的z值，将为每个像素在三角形的表面上进行插值。这些值被传递给像素着色器，然后处理片段。在OpenGL中，像素着色器被称为碎片着色器，这可能是一个更好的名字。沿着管线发送的点和线元素也会为所覆盖的像素创建碎片。</strong></p>
<p><strong>在三角形上执行的插值类型由像素着色程序指定。通常情况下，我们使用透视校正插值，这样当物体后退时，像素表面位置之间的世界空间距离就会增加。一个例子是渲染延伸到地平线的铁轨。铁轨越远的地方，枕木间距越近，因为每一个接近视界的连续像素所走过的距离就越远。其他插值选项也可用，如屏幕空间插值，其中不考虑透视投影。DirectX 11进一步控制了插值的时间和方式。</strong></p>
<p><strong>在编程方面，顶点着色程序的输出，通过插入三角形(或线)，有效地成为像素着色程序的输入。随着GPU的发展，其他的输入也被暴露出来。例如，在shader Model 3.0或更高版本中，片段的屏幕位置对像素着色器可用。同时,三角形的哪边是可见的是一个输入标志。这个知识对于渲染每个三角形的正面和背面的不同材质是很重要的。</strong></p>
<p><strong>有了输入，像素着色器通常会计算并输出片段的颜色。它也可能产生一个不透明度值和可选地修改它的z深度。在合并期间，这些值用于修改存储在像素上的内容。光栅化阶段产生的深度值也可以通过像素着色器进行修改。模板缓冲区值通常是不可修改的，但它会被传递到合并阶段。DirectX 11.3允许着色器改变这个值。在SM 4.0中，雾计算和alpha测试等操作已经从合并操作转变为像素着色器计算。</strong></p>
<p><strong>像素着色器也有独特的能力来丢弃一个进入的碎片，不产生输出。裁剪平面功能过去是固定功能管线中的一个可配置元素，后来在顶点着色器中指定。随着碎片丢弃可用，这个功能可以在像素着色器中以任何方式实现，如决定裁剪体积是否应该和或在一起。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210912130749.png" class="" title="image-20210912130749">

<p>用户定义的切割面。在左侧，一个水平剪切平面将对象切片。在中间，嵌套的球体被三个平面裁剪。在右边，只有当球体的表面在三个剪切平面之外时，球体的表面才会被剪切。(来自三个.js例子webgl clipping和webgl clipping intersection。)</p>
<p><strong>最初，像素着色器只能输出到合并阶段，以便最终显示。随着时间的推移，像素着色器可以执行的指令数量已经显著增加。这种增加产生了多渲染目标(MRT)的想法。不是将像素着色程序的结果发送到颜色和z缓冲区，而是可以为每个片段生成多个值集，并保存到不同的缓冲区，每个缓冲区称为渲染目标。渲染目标通常具有相同的x和y维度;有些API允许不同的大小，但是渲染区域是最小的。有些架构要求每个渲染目标具有相同的位深，甚至可能具有相同的数据格式。根据GPU，可用的渲染目标数量是4或8个。</strong></p>
<p><strong>即使有这些限制，MRT功能在更有效地执行渲染算法方面是一个强大的帮助。一次渲染可以在一个目标上生成彩色图像，在另一个目标上生成目标标识符，在第三个目标上生成世界空间距离。这种能力也产生了一种不同类型的渲染管道，称为延迟渲染，其中可见性和着色是在单独的通道中完成的。第一个通道存储关于对象的位置和每个像素的材质的数据。连续的通道可以有效地应用照明和其他效果。</strong></p>
<p><strong>像素着色器的限制是，它通常只能在片段位置写入渲染目标，而不能从相邻像素读取当前结果。也就是说，当一个像素着色程序执行时，它不能将其输出直接发送到邻近的像素，也不能访问其他人最近的更改。相反，它计算的结果只影响它自己的像素。然而，这种限制并不像听起来那么严重。在一个通道中创建的输出图像可以在以后的通道中由像素着色器访问其任何数据。相邻像素可以使用图像处理技术进行处理。</strong></p>
<p><strong>对于像素着色器不能知道或影响相邻像素的这一规则，也有例外。一个是在梯度或导数信息的计算过程中，像素着色器可以立即访问相邻碎片的信息(尽管是间接的)。像素着色器提供了沿着x和y屏幕轴每个像素的任何插值值变化的数量。这些值对于各种计算和纹理寻址都很有用。这些梯度对于纹理过滤，在这些操作中，我们想知道图像覆盖了多少像素。所有的现代GPU都是通过2 × 2的分组(称为quad)来实现这一功能的。当像素着色器请求一个梯度值时，将返回相邻片段之间的差异。一个统一的核心有能力访问相邻的数据——保持在同一扭曲的不同线程中——因此可以计算用于像素着色器的梯度。这个实现要求渐变信息不能在受动态流控制影响的部分着色器中访问。一个“if”语句或具有可变迭代次数的循环。一组中的所有片段必须使用同一套指令进行处理，以便所有四个像素的结果对计算梯度都有意义。这是即使在离线渲染系统中也存在的一个基本限制。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210912131427.png" class="" title="image-20210912131427">

<p>在左边，一个三角形被栅格化成2 × 2像素的四边形。然后在右边显示用黑点标记的像素的梯度计算。v的值显示在四元组中的四个像素位置。注意三个像素是如何没有被三角形覆盖的，但它们仍然被GPU处理，以便能够找到梯度。通过使用左下角像素的两个四边形邻居来计算屏幕x和y方向的梯度。</p>
<p><strong>DirectX 11引入了一种缓冲区类型，允许对任何位置的写访问，即无序访问视图(UAV)。最初仅用于像素和计算着色器，在DirectX 11.1中对UAVs扩展到所有着色器。OpenGL 4.3将其称为着色器存储缓冲区对象(SSBO)。这两个名字都有自己的描述性。像素着色器以任意顺序并行运行，并且存储缓冲区在它们之间共享。</strong></p>
<p><strong>通常需要一些机制来避免数据竞争条件(也称为数据危险)，在这种情况下，两个着色程序可能“竞争”影响相同的值导致随机的结果。例如，如果对一个像素着色器的两次调用试图在大约相同的时间添加相同的检索值，就可能发生错误。这两个调用都将检索原始值，都将在本地修改它，但无论最后哪个调用写入其结果，都会删除另一个调用的贡献——只会发生一个添加。GPU通过使用着色器可以访问的专用原子单位来避免这个问题。然而，原子意味着一些着色器可能会暂停，因为他们等待访问的内存位置正在被另一个着色器读/修改/写。</strong></p>
<p><strong>虽然原子可以避免数据危险，但许多算法需要特定的执行顺序。例如，您可能想在用红色透明三角形覆盖它之前绘制一个更远的透明蓝色三角形，将红色混合在蓝色之上。一个像素有可能对一个像素有两个像素着色器调用，每个三角形都有一个，执行的方式是红色三角形的着色器在蓝色三角形之前完成。在标准管线中，片段结果在被处理之前在合并阶段进行排序。在DirectX 11.3中引入了光栅化顺序视图(ROV)来强制执行顺序。这些就像UAVs;它们可以被着色器以同样的方式读取和写入。关键的区别在于，ROV可以保证数据以正确的顺序被访问。这大大增加了这些着色器可访问缓冲区的用处。例如，ROV使像素着色器可以编写自己的混合方法，因为它可以直接访问和写入ROV中的任何位置，因此不需要合并阶段。代价是，如果检测到无序访问，像素着色器调用可能会暂停，直到之前绘制的三角形被处理完成。</strong></p>
<h2 id="The-Merging-Stage-合并阶段"><a href="#The-Merging-Stage-合并阶段" class="headerlink" title="The Merging Stage 合并阶段"></a>The Merging Stage 合并阶段</h2><p><strong>合并阶段是单个片段(在像素着色器中生成)的深度和颜色与帧缓冲相结合的阶段。DirectX将这个阶段称为输出合并;OpenGL将其称为每样例操作。在大多数传统的管线图(包括我们自己的)中，这个阶段是模板缓冲区和z缓冲区操作发生的地方。如果片段是可见的，在这个阶段发生的另一个操作是颜色混合。对于不透明的表面，不涉及真正的混合，因为片段的颜色只是替换先前存储的颜色。片段和存储颜色的实际混合通常用于透明度和合成操作。</strong></p>
<p><strong>假设光栅化生成的片段通过像素着色器运行，然后当z缓冲区被应用时，发现被先前渲染的片段隐藏了。所有在像素着色器中完成的处理都是不必要的。为了避免这种浪费，许多GPU在像素着色器执行之前执行一些合并测试。片段的z深度(以及其他任何正在使用的东西，如模板缓冲或裁剪)用于测试可见性。如果隐藏，碎片将被剔除。这种功能被称为early-z。像素着色器有能力改变碎片的z深度或完全丢弃碎片。如果发现在像素着色程序中存在任何一种类型的操作，early-z通常不能被使用，并被关闭，这通常会降低管线的效率。DirectX 11和OpenGL 4.2允许像素着色器强制启动early-z测试，尽管有一些限制。</strong></p>
<p><strong>合并阶段占据了固定功能阶段之间的中间地带，如三角形设置，和完全可编程的着色阶段。虽然它不是可编程的，但它的操作是高度可配置的。特别是颜色混合，可以进行大量不同的操作。最常见的是涉及颜色和alpha值的乘法、加法和减法的组合，但也可以进行其他操作，如最小和最大值，以及按位逻辑操作。DirectX 10增加了将像素着色器中的两种颜色与帧缓冲区颜色混合的功能。这个功能被称为双源颜色混合，不能与多个渲染目标一起使用。除此之外，MRT支持混合，DirectX 10.1引入了在每个单独的缓冲区上执行不同的混合操作的能力。</strong></p>
<p><strong>正如上一节末尾所提到的，DirectX 11.3提供了一种通过ROVs使混合可编程的方法，尽管在性能上付出了代价。ROVs和合并阶段都保证了绘制顺序，也就是输出不变性。不管像素着色器结果生成的顺序是什么，API要求结果一个对象一个对象，一个三角形一个三角形，按照输入的顺序进行排序并发送到合并阶段。</strong></p>
<h2 id="The-Compute-Shader-计算着色器"><a href="#The-Compute-Shader-计算着色器" class="headerlink" title="The Compute Shader 计算着色器"></a>The Compute Shader 计算着色器</h2><p><strong>GPU不仅可以用于实现传统的图形管线。从计算股票期权的估值到为深度学习训练神经网络，在各个领域都有许多非图形化的应用。以这种方式使用硬件被称为GPU计算。像CUDA和OpenCL这样的平台被用来控制GPU作为一个巨大的并行处理器，不需要或访问图形特定的功能。这些框架通常使用C或C++等带有扩展的语言，以及为GPU制作的库。</strong></p>
<p><strong>在DirectX 11中引入的，计算着色器是GPU计算的一种形式，因为它是一个不锁定在图形管线中的位置的着色器。它与呈现过程紧密相关，因为它是由图形API调用的。它与顶点、像素和其他着色器一起使用。它利用了与管道中使用的相同的统一着色处理器池。它是一个像其他着色器一样的着色器，因为它有一些输入数据集，可以访问缓冲区(如纹理)的输入和输出。Warps和线程在计算着色器中更明显。例如，每次调用都会获得一个可以访问的线程索引。还有一个线程组的概念，在DirectX 11中由1到1024个线程组成。这些线程组由x-， y-和z-坐标指定，主要是为了在着色器代码中简单使用。每个线程组都有少量在线程之间共享的内存。在DirectX 11中，这相当于32 kB。计算着色器是由线程组执行的，因此线程组中的所有线程都保证并发运行。</strong></p>
<p><strong>计算着色器的一个重要优势是它们可以访问在GPU上生成的数据。将数据从GPU发送到CPU会有一定的延迟，因此如果处理和结果能够保留在GPU上，则可以提高性能。后期处理，即以某种方式修改已渲染的图像，是计算着色器的常用用途。共享内存意味着来自采样图像像素的中间结果可以与相邻线程共享。例如，使用计算着色器来确定图像的分布或平均亮度，其运行速度是在像素着色器上执行此操作的两倍。</strong></p>
<p><strong>计算着色器也适用于粒子系统、网格处理，如面部动画、剔除、图像滤波、提高深度精度、阴影、景深，以及任何其他可以使用GPU处理器的任务。Wihlidal讨论了计算着色器如何比镶嵌外壳着色器更有效。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210913125601.png" class="" title="image-20210913125601">

<p>计算着色器的应用。在左边，一个计算着色器用来模拟受风影响的头发，头发本身使用镶嵌阶段渲染。在中间，一个计算着色器执行快速模糊操作。右边是模拟的海浪。(图片来自NVIDIA SDK 11[1301]样本，由NVIDIA公司提供。)</p>
<h1 id="4-Transforms-变换"><a href="#4-Transforms-变换" class="headerlink" title="4 Transforms 变换"></a>4 Transforms 变换</h1><p><strong>变换是一种操作，它采用点、向量或颜色等实体，并以某种方式对它们进行转换。对于计算机图形的实践者来说，掌握变换是极其重要的。使用它们，您可以定位、重塑和动画对象、灯光和相机。您还可以确保所有计算都在相同的坐标系中执行，并以不同的方式将对象投影到一个平面上。</strong></p>
<p><strong>线性变换是保持向量加法和标量乘法的变换。具体地说,</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914093641.png" class="" title="image-20210914093641">

<p><strong>结合线性变换和平移可以使用仿射变换来完成，通常存储为4 × 4矩阵。仿射变换是先执行线性变换再执行平移的变换。为了表示四个元素的向量，我们使用齐次符号，以同样的方式表示点和方向(使用黑体小写字母)。方向向量表示为v = (vx  vy  vz  0）^T 点v = (vx  vy  vz  1）^T。</strong></p>
<p><strong>所有的平移、旋转、缩放、反射和剪切矩阵都是仿射矩阵。仿射矩阵的主要特征是保持直线的平行性，但不一定保持长度和角度。仿射变换也可以是单个仿射变换的串联序列。</strong></p>
<h2 id="Basic-Transforms-基本变换"><a href="#Basic-Transforms-基本变换" class="headerlink" title="Basic Transforms 基本变换"></a>Basic Transforms 基本变换</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914094447.png" class="" title="image-20210914094447">

<p>大多数变换及其表示法、函数和性质，其中正交矩阵的逆矩阵是转置矩阵。</p>
<h3 id="Translation-平移"><a href="#Translation-平移" class="headerlink" title="Translation 平移"></a>Translation 平移</h3><p><strong>从一个位置到另一个位置的变化用一个平移矩阵T来表示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914094917.png" class="" title="image-20210914094917">

<h3 id="Rotation-旋转"><a href="#Rotation-旋转" class="headerlink" title="Rotation 旋转"></a>Rotation 旋转</h3><p><strong>在二维空间中，假设我们有一个向量v = (vx, vy)，我们将其参数化为v = （vx, vy）= （rcos θ， rsin θ）。如果逆时针旋转φ弧度，就得到u = （rcos (θ + φ)，rsin (θ + φ)）这个可以写成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914100616.png" class="" title="image-20210914100616">

<p><strong>在三维空间有，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914101051.png" class="" title="image-20210914101051">

<h3 id="Scaling-缩放"><a href="#Scaling-缩放" class="headerlink" title="Scaling 缩放"></a>Scaling 缩放</h3><p><strong>缩放变换表示为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914101507.png" class="" title="image-20210914101507">

<p><strong>在s的一个或三个分量上取负值，就得到一种反射矩阵，也称为反射矩阵。如果只有两个比例因子为−1，则旋转π弧度。需要注意的是，与反射矩阵连接的旋转矩阵也是反射矩阵。因此，反射矩阵如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914101722.png" class="" title="image-20210914101722">

<p><strong>一个顶点按逆时针顺序排列的三角形，经过反射矩阵变换后将得到顺时针顺序。这个顺序的改变会导致不正确的光照和背面剔除。为了检测给定的矩阵是否以某种方式反映，计算左上方3 × 3元素的行列式。如果该值为负，则矩阵为反射矩阵。</strong></p>
<p><strong>如果需要在其他方向进行缩放，则需要进行复合变换。假设应该沿着标准正交的、右向的向量f x、f y和f z的轴进行缩放。首先，构造矩阵f，以改变基底，如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914101930.png" class="" title="image-20210914101930">

<p><strong>其思想是使三个坐标轴给出的坐标系统与标准坐标轴重合，然后使用标准缩放矩阵，然后再转换回来。第一步是与转置矩阵相乘，即F。然后进行实际的缩放，然后进行回变换。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914101940.png" class="" title="image-20210914101940">

<h3 id="Shearing-裁剪"><a href="#Shearing-裁剪" class="headerlink" title="Shearing 裁剪"></a>Shearing 裁剪</h3><p><strong>另一类变换是剪切矩阵的集合。例如，在游戏中，这些元素可以用来扭曲整个场景以创造迷幻效果或扭曲模型的外观。有六种基本的剪切矩阵，用Hxy(s), Hxz(s), Hyx(s), Hyz(s), Hzx(s), Hzy(s)表示。第一个下标表示被剪切矩阵改变的坐标，第二个下标表示进行剪切的坐标。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914102429.png" class="" title="image-20210914102429">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914102441.png" class="" title="image-20210914102441">

<h3 id="Concatenation-of-Transforms-变换的连接"><a href="#Concatenation-of-Transforms-变换的连接" class="headerlink" title="Concatenation of Transforms 变换的连接"></a>Concatenation of Transforms 变换的连接</h3><p><strong>由于矩阵乘法运算的非交换性，矩阵发生的顺序很重要。因此变换的连接被称为顺序相关的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914103301.png" class="" title="image-20210914103301">

<p>这说明了矩阵相乘时的顺序依赖关系。</p>
<p><strong>将一个矩阵序列连接成一个矩阵序列的明显原因是为了获得效率。例如，假设你有一个拥有数百万个顶点的游戏场景，场景中的所有对象都必须缩放、旋转并最终转换。现在，不是将所有顶点与这三个矩阵中的每一个相乘，而是将这三个矩阵连接成一个矩阵。这个矩阵被应用到顶点上。这个复合矩阵是C = TRS。注意这里的顺序。缩放矩阵S，应该首先应用到顶点上，因此在复合中出现在右边。这个顺序意味着TRSp = (T(R(Sp))，其中p是一个要变换的点。顺便提一下，TRS是场景图系统常用的阶数。</strong></p>
<p><strong>值得注意的是，虽然矩阵连接是顺序相关的，但矩阵可以按需要分组。例如，假设使用TRSp，您希望计算一次刚体运动变换TR。将这两个矩阵组合在一起(TR)(Sp)，并用中间结果替换是有效的。因此，矩阵连接是结合的。</strong></p>
<h3 id="The-Rigid-Body-Transform-刚体变换"><a href="#The-Rigid-Body-Transform-刚体变换" class="headerlink" title="The Rigid-Body Transform 刚体变换"></a>The Rigid-Body Transform 刚体变换</h3><p><strong>当一个人从桌子上拿起一个固体物体，比如一支笔，并把它移到另一个地方，比如衬衫口袋里，只有物体的方向和位置会改变，而物体的形状一般不会受到影响。这种只由平移和旋转串联而成的变换称为刚体变换。它具有保持长度、角度和旋向的特点。</strong></p>
<p><strong>任意刚体矩阵X可表示为平移矩阵T(t)和旋转矩阵r的串联，则X为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914103913.png" class="" title="image-20210914103913">

<p><strong>X的逆为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914104005.png" class="" title="image-20210914104005">

<p><strong>为了计算逆矩阵，将左上3 × 3的R矩阵转置，使T的平移值改变符号。这两个新矩阵以相反的方式乘在一起以得到其逆矩阵。另一种计算X逆的方法是考虑R(使R以3 × 3矩阵的形式出现)和X的表示法</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914104216.png" class="" title="image-20210914104216">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914104255.png" class="" title="image-20210914104255">

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>在图形学中，一个常见的任务是确定相机的方向，使它看到一个特定的位置。在这里，我们将展示gluLookAt()(来自OpenGL实用程序库，简称GLU)的功能。尽管现在这个函数调用本身并不常用，但这个任务仍然很常见。假设相机位于c，我们想让相机注视目标l，相机给定的方向是u ‘。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914104728.png" class="" title="image-20210914104728">

<p><strong>我们要计算一个由三个向量组成的基，{r, u, v}。我们首先计算视图向量v = (c−l)/||c−l||，即从目标到摄像机位置的归一化向量。向右看的向量可以计算为r =−(v × u ‘)/||v × u ‘ ||。u ‘向量通常不能保证是精确的向上，所以最后的向上向量是另一个叉积，u = v × r，它被保证是标准化的，因为v和r都是标准化的，而且通过构造是垂直的。在相机变换矩阵,M,我们将构建,我们的想法是先变换一切所以相机的位置是在原点,(0,0,0),然后修改基础,以便r是符合(1,0,0),u(0,1,0)和v(0 0 1)。这是通过</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914104938.png" class="" title="image-20210914104938">

<h3 id="Normal-Transform-法线变换"><a href="#Normal-Transform-法线变换" class="headerlink" title="Normal Transform 法线变换"></a>Normal Transform 法线变换</h3><p><strong>一个矩阵可以用来一致地转换点、线、三角形和其他几何图形。同样的矩阵也可以变换沿这些直线或三角形表面的切向量。然而，这个矩阵不能总是用来转换一个重要的几何属性，表面法线(和顶点光照法线)。下图显示了如果使用相同的矩阵会发生什么。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914105523.png" class="" title="image-20210914105523">

<p><strong>正确的方法不是乘矩阵本身，而是用矩阵的伴随矩阵的转置。伴随矩阵总是保证存在的。法线在转换后不能保证为单位长度，因此通常需要标准化。</strong></p>
<p><strong>传统的法线变换方法是计算逆矩阵的转置。这种方法通常是有效的。然而，完全的逆并不是必需的，有时也不能创建。它的逆是伴随矩阵除以原始矩阵的行列式。如果这个行列式为零，则矩阵是奇异的，其逆矩阵不存在。</strong></p>
<p><strong>即使只是计算一个完整的4 × 4矩阵的伴随矩阵也很昂贵，而且通常是不必要的。因为法线是一个矢量，所以平移不会影响它。此外，大多数建模转换都是仿射的。它们不会改变传入的齐次坐标的w分量，也就是说。它们不执行投影。在这些(常见的)情况下，所有的正规变换所需要的是计算左上3 × 3分量的伴随矩阵。</strong></p>
<p><strong>通常，甚至这种伴随矩阵的计算也是不需要的。假设我们知道变换矩阵完全由平移、旋转和统一缩放操作(没有拉伸或挤压)的串联组成。变换不影响法线。均匀比例因子只是改变法线的长度。剩下的就是一系列的旋转，它总是产生某种净旋转，仅此而已。</strong></p>
<p><strong>逆矩阵的转置可以用来变换法线。旋转矩阵的定义是它的转置是它的逆。代入得到法变换，两次转置(或两次逆)就得到原来的旋转矩阵。把所有这些放在一起，原始变换本身也可以在这些情况下直接用于变换法线。</strong></p>
<p><strong>最后，使法线完全重正化并不总是必要的。如果只是平移和旋转连接在一起，那么法线在矩阵变换时不会改变长度，因此不需要重正化。如果统一缩放也被连接起来，整体缩放因子可以用来直接对产生的法线进行归一化。例如，如果我们知道应用了一系列缩放使对象变大5.2倍，那么直接由这个矩阵转换的法线将被重归一化，方法是将它们除以5.2。或者，为了创建一个正规的变换矩阵来产生标准化的结果，原始矩阵的3×3左上角可以被这个比例因子除一次。</strong></p>
<p><strong>注意，法线变换不是一个问题，在变换之后，曲面法线由三角形导出(例如，使用三角形的边的叉积)。切向量在本质上不同于法向量，通常是由原矩阵直接变换的。</strong></p>
<h3 id="Computation-of-Inverses-逆变换"><a href="#Computation-of-Inverses-逆变换" class="headerlink" title="Computation of Inverses 逆变换"></a>Computation of Inverses 逆变换</h3><p><strong>在许多情况下都需要逆，例如，在坐标系之间来回变换时。根据有关变换的可用信息，可以使用下列三种计算矩阵逆的方法:</strong></p>
<pre><code>**如果矩阵是给定参数的单个变换或一系列简单变换，那么通过“反参数”和矩阵顺序可以很容易地计算出矩阵。例如,如果M = T (t) R(φ),那么M^−1 = R(−φ)T(−t)。这很简单，并且保持了变换的准确性，这在渲染巨大的世界时是很重要的。**

**如果已知矩阵是正交的，则M^−1 = M^T，即转置就是逆。任何旋转序列都是旋转，所以是正交的。**

**如果什么都不知道，那么可以使用伴随方法、克拉默规则、LU分解或高斯消去法来计算逆。克拉默规则和伴随法具有较少的分支运算，一般较好;在现代架构中，最好避免“if”测试。**
</code></pre>
<p><strong>逆向计算的目的也可以考虑到优化。例如，如果逆矩阵用于变换向量，那么通常只需要对矩阵左上方的3 × 3部分进行逆矩阵(参见前面的内容)</strong></p>
<h2 id="Special-Matrix-Transforms-and-Operations-特殊矩阵变换和运算"><a href="#Special-Matrix-Transforms-and-Operations-特殊矩阵变换和运算" class="headerlink" title="Special Matrix Transforms and Operations 特殊矩阵变换和运算"></a>Special Matrix Transforms and Operations 特殊矩阵变换和运算</h2><h3 id="The-Euler-Transform-欧拉变换"><a href="#The-Euler-Transform-欧拉变换" class="headerlink" title="The Euler Transform 欧拉变换"></a>The Euler Transform 欧拉变换</h3><p><strong>这种转换是一种直观的方法来构建一个矩阵来定位你自己(如相机)或任何其他实体在某个方向上。它的名字来自伟大的瑞士数学家莱昂哈德·欧拉(1707-1783)。</strong></p>
<p><strong>首先，必须建立某种默认的视图方向。大多数情况下，它位于负z轴，头部沿y轴方向，如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914115003.png" class="" title="image-20210914115003">

<p><strong>欧拉变换是三个矩阵的乘积，即图中所示的旋转。更正式地说，变换E为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914115823.png" class="" title="image-20210914115823">

<p><strong>矩阵的顺序可以用24种不同的方式选择;我们提出这个词是因为它很常用。由于E是旋转的串联，它显然也是正交的。因此它的逆可以表示为E^−1 = ET = (RzRxRy）^T ，当然，直接用E的转置更容易。</strong></p>
<p><strong>欧拉角h, p和r表示 head，pitch和 roll应该围绕各自的轴旋转多少。有时角度都被称为“rolls”，例如，我们的“head”是“y-roll”，我们的“pitch”是“x-roll”。此外，“head”有时也被称为“yaw”，比如在飞行模拟中。</strong></p>
<p><strong>这种转换是直观的，因此很容易用外行人的语言来讨论。例如，改变头部角度会让观众摇头表示“不”，改变色调会让观众点头，而滚动则会让观众歪着头。我们讨论的不是围绕x、y和z轴的旋转，而是改变头部、俯仰和滚动。注意，这个变换不仅可以定位相机，还可以定位任何物体或实体。这些变换可以使用世界空间的全局轴或相对于局部参照系来执行。</strong></p>
<p><strong>值得注意的是，一些欧拉角的表示给出了z轴作为初始向上方向。这种差异纯粹是符号上的变化，尽管可能会令人困惑。在计算机图形学中，如何看待世界以及内容如何形成是有区别的:y-向上或 z-向上。大多数制造过程，包括3D打印，认为z方向是向上的世界空间;航空和海上交通工具认为−z向上。建筑和GIS通常使用z-向上，因为建筑平面图或地图是二维的，x和y。与媒体相关的建模系统通常认为y方向在世界坐标中是向上的，这与我们在计算机图形学中描述摄像机屏幕向上的方向相匹配。区别这两个世界上的向量选择只是90◦旋转(可能是一个反射)，但不知道向上方向可能导致问题。除非另有说明，我们使用y-向上世界方向。</strong></p>
<p><strong>我们还想指出，摄像机在其视图空间中的向上方向与世界的向上方向没有特别的关系。转动你的头，视野就会倾斜，它的世界空间向上的方向与世界的方向不同。再举一个例子，假设这个世界使用y-向上，我们的相机直接向下看下面的地形，鸟瞰。这个方向意味着相机已经倾斜90◦向前，所以它在世界空间的向上方向是(0,0,1)。在这个方向中，摄像机没有y分量，而是认为−z在世界空间中是向上的，但是根据定义，“y是向上的”在视图空间中仍然是正确的。</strong></p>
<p><strong>虽然欧拉角对于小角度的变化或观众的方向很有用，但它也有一些其他严重的局限性。两组欧拉角的组合运算是很困难的。例如，在一个集合和另一个集合之间的插值不是一个简单的插值每个角度的问题。事实上，两组不同的欧拉角可以给出相同的方向，所以任何插值都不应该使物体旋转。</strong></p>
<h3 id="Extracting-Parameters-from-the-Euler-Transform-从欧拉变换提取参数"><a href="#Extracting-Parameters-from-the-Euler-Transform-从欧拉变换提取参数" class="headerlink" title="Extracting Parameters from the Euler Transform 从欧拉变换提取参数"></a>Extracting Parameters from the Euler Transform 从欧拉变换提取参数</h3><p><strong>在某些情况下，从正交矩阵中提取欧拉参数h、p和r是有用的。这个过程如公式所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914122252.png" class="" title="image-20210914122252">

<p><strong>这里我们放弃了4 × 4矩阵，改用3 × 3矩阵，因为后者提供了旋转矩阵的所有必要信息。也就是说，等价的4 × 4矩阵的其余部分总是包含0和右下角的1。</strong></p>
<p><strong>将上式中的三个旋转矩阵连接起来得到</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914122843.png" class="" title="image-20210914122843">

<p><strong>由此可见，pitch参数由sin p = e21．同时,将e01除e11，类似地e20除e22，得到的head 和 roll参数提取方程如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914123150.png" class="" title="image-20210914123150">

<p><strong>因此，利用函数atan2(y,x)从矩阵E中提取欧拉参数h(head)、p(pitch)和r(roll)，如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914123336.png" class="" title="image-20210914123336">

<p><strong>但是，有一个特殊情况我们需要处理。如果cos p = 0，我们有万向节锁，旋转角度r和h将围绕同一轴旋转(虽然可能是不同的方向，取决于p旋转角度是−π/2还是π/2)，所以只需要导出一个角度。如果任意设h = 0，得到</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914123530.png" class="" title="image-20210914123530">

<p><strong>因为p不影响第一列的值，当cos p = 0时，我们可以用sin r/ cos r = tan r = e10/ e00，得到r = atan2(e10，e00)。</strong></p>
<p><strong>注意，根据arcsin的定义，−π/2≤p≤π/2，即如果E的值在这个区间外，则无法提取原始参数。h, p，和r不是唯一的，这意味着可以使用不止一组欧拉参数来产生相同的变换。关于欧拉角转换的更多信息可以在Shoemake 1994年的文章中找到。上面概述的简单方法可能会导致数值不稳定的问题，这是可以避免的，但要付出一定的速度代价。</strong></p>
<p><strong>当您使用欧拉变换时，可能会出现万向节锁。当旋转使一个自由度失去时，就会发生这种情况。例如，变换的顺序是x/y/z。假设绕y轴旋转π/2，这是第二次旋转。这样做会旋转局部的z轴，使其与原始的x轴对齐，从而使绕z的最后旋转是多余的。</strong></p>
<p><strong>数学上，我们已经见过万向节锁，其中我们假设cos p = 0，即 p =±π/2 + 2πk，其中k是整数。有了这样的p值，我们就失去了一个自由度，因为矩阵只依赖于一个角度，r + h或r - h(但不能同时同时依赖两个角度)。</strong></p>
<p><strong>在建模系统中，欧拉角通常表现为x/y/z顺序，绕每个局部轴旋转，其他顺序都是可行的。例如，z/x/y在动画中使用，z/x/z在动画和物理中都使用。所有这些都是指定三个独立旋转的有效方法。最后一种顺序，z/x/z，对于某些应用程序可能更优越，因为只有当围绕x旋转π弧度(半旋转)时，万向节锁才会发生。没有一个完美的顺序可以避免万向节锁。尽管如此，欧拉角还是经常被使用，因为动画师更喜欢使用曲线编辑器来指定角度如何随时间变化。</strong></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><strong>约束转换。想象你正握着一个(虚拟的)扳手，它正在抓住一个螺栓。要把螺栓装到位，你必须绕x轴转动扳手。现在，假设你的输入设备(鼠标、VR手套、太空球等)给你一个旋转矩阵，即旋转，用于扳手的运动。问题是，将这个变换应用到扳手上很可能是错误的，它应该只围绕x轴旋转。要将输入变换(称为P)限制为绕x轴旋转，只需使用本节描述的方法提取欧拉角h、P和r，然后创建一个新的矩阵Rx(p)。这是将绕x轴旋转扳手(如果p现在包含这样一个运动)目标的变换。</strong></p>
<h3 id="Matrix-Decomposition-矩阵分解"><a href="#Matrix-Decomposition-矩阵分解" class="headerlink" title="Matrix Decomposition 矩阵分解"></a>Matrix Decomposition 矩阵分解</h3><p><strong>到目前为止，我们一直在假设我们知道我们所使用的变换矩阵的起源和历史的前提下工作。事实往往并非如此。</strong></p>
<p><strong>例如，除了一个连接的矩阵之外，没有什么可以与某个变换对象相关联。从一个连接的矩阵中检索各种变换的任务称为矩阵分解。</strong></p>
<p><strong>检索一组变换的原因有很多。用途包括:</strong></p>
<pre><code>**提取对象的比例因子。**

**寻找特定系统所需的变换。(例如，有些系统可能不允许使用任意的4 × 4矩阵。)**

**确定模型是否只经历了刚体变换。**

**在动画的关键帧之间插入，只有对象的矩阵可用。**

**从旋转矩阵中移除剪切器。**
</code></pre>
<p><strong>我们已经给出了两种分解，一种是推导刚体变换的平移和旋转矩阵，另一种是从正交矩阵推导欧拉角。</strong></p>
<p><strong>正如我们所看到的，检索平移矩阵是很简单的，因为我们只需要4 × 4矩阵的最后一列中的元素。我们还可以通过检查矩阵的行列式是否为负来确定是否发生了反射。将旋转、缩放和剪切分离出来需要更多的努力。</strong></p>
<h3 id="Rotation-about-an-Arbitrary-Axis-绕任意轴旋转"><a href="#Rotation-about-an-Arbitrary-Axis-绕任意轴旋转" class="headerlink" title="Rotation about an Arbitrary Axis 绕任意轴旋转"></a>Rotation about an Arbitrary Axis 绕任意轴旋转</h3><p><strong>有时，使一个实体围绕任意轴旋转一些角度。假设旋转轴r是标准化的，并且应该创建一个围绕r旋转α弧度的变换。</strong></p>
<p><strong>为了做到这一点，我们首先转换到一个空间，在这个空间中，我们想围绕它旋转的轴是x轴。这是通过一个名为M的旋转矩阵完成的，然后执行实际的旋转，我们使用M^−1进行回变换。这个过程如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914131231.png" class="" title="image-20210914131231">

<p>绕任意轴r旋转是通过找到由r, s和t组成的标准正交基来完成的。然后我们将这个基与标准基对齐，使r与x轴对齐。绕x轴旋转是在这里进行的，最后我们变换回来。</p>
<p><strong>为了计算M，我们需要找到两个与r和彼此正交的轴。我们专注于寻找第二轴,s,然后知道第三轴,t,将第一和第二轴的外积,t = r×s。一个数值稳定的方法是找到最小的组件(绝对值)r,并将其设置为0。交换剩下的两个组件，然后对第一个组件求反(事实上，任何一个非零分量都可以被求反)。数学上，这表示为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914131526.png" class="" title="image-20210914131526">

<p><strong>这就保证了¯s正交于r，并且(r, s, t)是一组标准正交基。这三个向量都用于创建旋转矩阵:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914131724.png" class="" title="image-20210914131724">

<p><strong>这个矩阵把向量r变换成x轴，s变换成y轴，t变换成z轴。因此，围绕标准化向量r旋转α弧度的最终变换是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914131846.png" class="" title="image-20210914131846">

<p><strong>换句话说，这意味着首先我们变换使r变成x轴(使用M)，然后我们围绕x轴旋转α弧度(使用(Rx(α))，然后我们用M的逆（在这里就是M^T 因为M正交）进行变换。</strong></p>
<p><strong>Goldman提出了另一种以φ弧度绕任意归一化轴r旋转的方法。这里，我们简单介绍一下他的变换:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914132110.png" class="" title="image-20210914132110">

<h2 id="Quaternions-四元法"><a href="#Quaternions-四元法" class="headerlink" title="Quaternions 四元法"></a>Quaternions 四元法</h2><p><strong>尽管1843年威廉·罗文·汉密尔顿爵士发明了四元数，作为复数的扩展，但直到1985年，shomake才将四元数引入计算机图形领域。四元数用于表示旋转和方向。它们在许多方面优于欧拉角和矩阵。任何三维方向都可以表示为围绕某一特定轴的单个旋转。考虑到这个轴和角度的表示，转换到四元数是直接的，而在任何方向上的欧拉角转换都是较困难的。四元数可以用于稳定和恒定的方向插值，这是用欧拉角做不好的。</strong></p>
<p><strong>复数有实部和虚部。每一个用两个实数表示，第二个实数乘以√−1。类似地，四元数有四个部分。前三个值与旋转轴密切相关，旋转角度影响所有四个部分。每个四元数由四个实数表示，每个实数与不同的部分相关联。由于四元数有四个分量，我们选择用向量来表示它们，但为了区分它们，我们给它们加了一个帽子:qˆ。我们从四元数的一些数学背景开始，然后用它来构造各种有用的变换。</strong></p>
<h3 id="Mathematical-Background-数学背景"><a href="#Mathematical-Background-数学背景" class="headerlink" title="Mathematical Background 数学背景"></a>Mathematical Background 数学背景</h3><p><strong>四元数qˆ可以用下列方法定义，都是等价的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915111223.png" class="" title="image-20210915111223">

<p><strong>变量qw称为四元数的实部。虚部是qv，i、j、k称为虚数单位。</strong></p>
<p><strong>对于虚部qv，我们可以使用所有的法向量运算，如加法、缩放、点积、叉积等。利用四元数的定义，导出了两个四元数qˆ和ˆr之间的乘法运算如下所示。注意虚单位的乘法是非交换的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915111530.png" class="" title="image-20210915111530">

<p><strong>从这个方程可以看出，我们同时使用叉乘和点乘来计算两个四元数的乘法。</strong></p>
<p><strong>除了四元数的定义外，还需要定义addition, conjugate, norm, identity:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915111839.png" class="" title="image-20210915111839">

<p><strong>当n(ˆq) =√qˆqˆ∗被简化(结果如上所示)时，虚部抵消掉，只剩下实部。norm有时记为||ˆq|| = n(ˆq)。上面的结果是一个乘法的逆，表示为qˆ−1，可以导出。方程qˆ−1qˆ=qˆqˆ−1 = 1对逆必须成立(这是乘法逆的常见情况)。我们从规范的定义推导出一个公式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112116.png" class="" title="image-20210915112116">

<p><strong>这给出了乘法逆矩阵如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112127.png" class="" title="image-20210915112127">

<p><strong>反函数的公式使用了标量乘法，这是由定义中所见的乘法导出：sqˆ = (0, s)(qv, qw) = (sqv, sqw), 且 qˆs = (qv, qw)(0, s) = (sqv, sqw), 这意味着标量乘法是: sqˆ = qˆs = (sqv, sqw)。</strong></p>
<p><strong>下面的规则很容易从定义中推导出来:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112506.png" class="" title="image-20210915112506">

<p><strong>单位四元数，qˆ= (qv,qw)，使n(ˆq) = 1。由此可以得出qˆ可以写成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112601.png" class="" title="image-20210915112601">

<p><strong>对于三维向量uq，使||uq|| = 1，因为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112615.png" class="" title="image-20210915112615">

<p><strong>当且仅当uq ·uq = 1 = ||uq||²。</strong></p>
<p><strong>对于复数，一个二维单位向量可以写成cos φ + isin φ = e^iφ．四元数的等价式是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112717.png" class="" title="image-20210915112717">

<p><strong>单位四元数的对数和幂函数如公式所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112731.png" class="" title="image-20210915112731">

<h3 id="Quaternion-Transforms-四元数变换"><a href="#Quaternion-Transforms-四元数变换" class="headerlink" title="Quaternion Transforms 四元数变换"></a>Quaternion Transforms 四元数变换</h3><p><strong>现在我们将研究四元数集的一个子类，即单位长度，称为单位四元数。关于单位四元数最重要的是它们可以表示任何三维旋转，而且这种表示是非常紧凑和简单的。</strong></p>
<p><strong>现在我们将描述为何使用单位四元数对旋转和方向如此有用。首先，将一个点或向量p = (px py pz pw）^T ，假设我们有一个单位四元数qˆ= (sin φuq, cosφ)。我们可以证明</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915114358.png" class="" title="image-20210915114358">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915113040.png" class="" title="image-20210915113040">

<p>用单位四元数表示的旋转变换，qˆ= (sin φuq , cosφ)。变换围绕uq轴旋转2φ弧度 。</p>
<p><strong>绕uq轴旋转pˆ(即p点)2φ。请注意，由于ˆq是一个单位四元数，qˆ−1 = qˆ∗。</strong></p>
<p><strong>qˆ的任意非零实倍数也表示相同的变换，即qˆ和−ˆq表示相同的旋转。也就是求坐标轴uq和实部qw，创建一个与原始四元数完全相同的旋转四元数。它还意味着从矩阵中提取四元数可以返回qˆ或−ˆq。</strong></p>
<p><strong>给定两个单位四元数qˆ和ˆr，将qˆ和ˆr串联到四元数pˆ(可以解释为点p)，由式得出:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915114811.png" class="" title="image-20210915114811">
<p> <strong>这里，cˆ=ˆrqˆ是单位四元数，表示单位四元数qˆ和ˆr的连接。</strong></p>
<h4 id="Matrix-Conversion-矩阵变换"><a href="#Matrix-Conversion-矩阵变换" class="headerlink" title="Matrix Conversion 矩阵变换"></a><strong>Matrix Conversion 矩阵变换</strong></h4><p><strong>由于经常需要组合几个不同的变换，而且大多数变换都是矩阵形式，因此需要一种方法将方程</strong></p>
<p><strong><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915114358.png" class="" title="image-20210915114358"></strong></p>
<p><strong>转换为一个矩阵。一个四元数ˆq，可转换为矩阵M^q，如式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915115049.png" class="" title="image-20210915115049">

<p><strong>这里标量 s = 2/(n(qˆ))² ，对于单位四元数，可简化为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915115101.png" class="" title="image-20210915115101">

<p><strong>一旦构建了四元数，就不需要计算三角函数了，因此转换过程在实践中是高效的。</strong></p>
<p><strong>从正交矩阵Mq到单位四元数ˆq的反向转换稍微复杂一些。这个过程的关键是，从上式的矩阵中得到:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915131412.png" class="" title="image-20210915131412">

<p><strong>这些方程的含义是，如果已知qw ，向量vq的值可以计算，从而得到qˆ。M^q的跟踪</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915131551.png" class="" title="image-20210915131551">

<p><strong>这个结果对单位四元数产生以下转换:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915131624.png" class="" title="image-20210915131624">

<p><strong>为了有一个数值稳定的程序，应该避免用小数进行除法。因此，首先设t = qw²−qx²−qy²−qz²，由此可得</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915131645.png" class="" title="image-20210915131645">

<p><strong>这又意味着m00,m11,m22中最大的， u决定qx，qy,qz,qw 中最大的。如果qw ，则使用</strong></p>
<p><img src="C:\Users\86010\AppData\Roaming\Typora\typora-user-images\image-20210915132051014.png" alt="image-20210915132051014"></p>
<p><strong>导出四元数。因此，我们注意到以下成立:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915132104.png" class="" title="image-20210915132104">

<p><strong>然后用上面这些的合适的方程来计算qx,qy,qz的最大值，用</strong></p>
<p><strong><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915131412.png" class="" title="image-20210915131412"></strong></p>
<p><strong>计算qˆ的剩余分量。Sch¨uler提出了一种变体，它没有分枝，但使用了四个平方根。</strong></p>
<h4 id="Spherical-Linear-Interpolation-球形线性插值"><a href="#Spherical-Linear-Interpolation-球形线性插值" class="headerlink" title="Spherical Linear Interpolation 球形线性插值"></a>Spherical Linear Interpolation 球形线性插值</h4><p><strong>球面线性插值是给定两个单位四元数qˆ和ˆr，以及参数t∈[0,1]，计算一个插值四元数的运算。</strong></p>
<p><strong>该运算的代数形式用复合四元数ˆs表示，如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915132448.png" class="" title="image-20210915132448">

<p><strong>然而，对于软件实现来说，下面的形式更合适，其中slerp代表球面线性插值:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915132523.png" class="" title="image-20210915132523">

<p><strong>为了计算公式中所需要的φ，可以用:cos φ = qxrx +qyry +qzrz +qwrw。t∈[0,1],slerp函数,把(unique)四元数插值,共同构成的最短弧四维单位球面上qˆ(t = 0)到ˆr (t = 1)。位于弧圆之间形成的平面qˆ，ˆr,原点,四维单位球体。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915132804.png" class="" title="image-20210915132804">

<p>单位四元数表示为单位球面上的点。利用函数slerp在四元数之间进行插值，插值路径是球面上的一条大圆弧。注意，从qˆ1插值 qˆ2， 从qˆ1插值 qˆ3 ，从qˆ3插值qˆ2 是不一样的，即使它们到达相同的方向。</p>
<p><strong>所计算的旋转四元数以恒定速度绕固定轴旋转。这样的曲线具有恒定的速度，因此加速度为零，称为测地线曲线。球面上的大圆是平面通过原点与球面相交而形成的，这个圆的一部分称为大圆弧。</strong></p>
<p><strong>slerp函数非常适合在两个方向之间插入，并且它表现得很好(固定轴，恒定速度)。这不是用几个欧拉角插值。在实践中，直接计算slerp是一项昂贵的操作，涉及调用三角函数。Malyshau讨论了将四元数集成到渲染管线中。他注意到三角形的方向误差是90度角有最大4度，而不是使用slerp，只是简单地在像素着色器中归一化四元数。在栅格化三角形时，这个错误率是可以接受的。Li提供了更快的增量方法来计算slerps，而且不牺牲任何精度。Eberly提出了一种只用加法和乘法计算slerps的快速技术。</strong></p>
<p><strong>当超过两个方向时，qˆ0qˆ1，…qˆn−1是可得的，我们想从qˆ0插值qˆ1 qˆ2，以此类推，直到qˆn−1，slerp可以直接使用。现在，当我们接近qˆi，我们用qˆi−1 和qˆi 作为已知进行slerp。这将导致方向插补出现突然的抖动。这类似于点是线性插值的情况。</strong></p>
<p><strong>更好的插值方法是使用样条曲线。我们引入四元数ˆai 和aˆi+1 在qˆi 和qˆi+1间。球面三次插值可以定义在四元数集qˆi,aˆi ,aˆi+1,qˆi+1。这些额外的四元数的计算方法如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915133859.png" class="" title="image-20210915133859">

<p><strong>qˆi和aˆi 将使用光滑的三次样条球插值四元数，如公式所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915133950.png" class="" title="image-20210915133950">

<p><strong>如上所述，squad函数是由重复球面插值使用slerp构造而成的。插值将通过初始方向qˆi， I∈[0，…， n - 1]，但不是通过aˆi这些用于指示初始方向的切线方向。</strong></p>
<h4 id="Rotation-from-One-Vector-to-Another-从一个向量到另一个向量的旋转"><a href="#Rotation-from-One-Vector-to-Another-从一个向量到另一个向量的旋转" class="headerlink" title="Rotation from One Vector to Another 从一个向量到另一个向量的旋转"></a>Rotation from One Vector to Another 从一个向量到另一个向量的旋转</h4><p><strong>一个常见的操作是从一个方向s到另一个方向t通过最短路径。四元数的数学大大简化了这一过程，并显示了四元数与这种表示的密切关系。首先对s和t进行归一化，然后计算单位旋转轴u，即u = (s × t)/||s × t||。e = s·t = cos(2φ)， ||s × t|| = sin(2φ)，其中2φ为s与t之间的夹角，则表示s到t旋转的四元数qˆ= (sin φu, cos φ)。实际上，将qˆ= ( sin φ/sin 2φ(s × t)， cos φ)，利用半角关系和三角恒等式，得到</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915141021.png" class="" title="image-20210915141021">

<p><strong>以这种方式直接生成四元数(相对于对叉乘s × t进行归一化)可以避免s和t指向几乎相同方向时的数值不稳定性。当s和t指向相反的方向时，两种方法都会出现稳定性问题，因为会出现除零的情况。当检测到这种特殊情况时，可以使用垂直于s的任意旋转轴来旋转到t。</strong></p>
<p><strong>有时我们需要从s到t的旋转矩阵表示。对</strong></p>
<p><img src="C:\Users\86010\AppData\Roaming\Typora\typora-user-images\image-20210915141155051.png" alt="image-20210915141155051"></p>
<p><strong>进行代数和三角化简后，旋转矩阵为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915141212.png" class="" title="image-20210915141212">

<p><strong>在这个方程中，我们使用了以下中间计算：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915141222.png" class="" title="image-20210915141222">

<p><strong>可以看出，由于化简，所有的平方根和三角函数都消失了，所以这是创建矩阵的一种有效方法。</strong></p>
<p><strong>注意，当s和t平行或接近平行时，必须小心，因为||s × t||≈0。如果φ≈0，则返回单位矩阵。而如果2φ≈π， π弧度就可以绕任意轴旋转。这个轴可以被发现为s与任何其他不平行于s的向量之间的叉积。</strong></p>
<h2 id="Vertex-Blending-顶点混合"><a href="#Vertex-Blending-顶点混合" class="headerlink" title="Vertex Blending 顶点混合"></a>Vertex Blending 顶点混合</h2><p><strong>想象一个数字角色的手臂使用了两个部分，前臂和上臂，如图左边所示。这个模型可以使用刚体转换动画。然而，这两个部分之间的关节将不像一个真正的肘关节。这是因为使用了两个独立的物体，因此，关节由这两个独立物体的重叠部分组成。显然，只使用一个对象会更好。然而，静态模型零件并没有解决使关节灵活的问题。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915142412.png" class="" title="image-20210915142412">

<p>由前臂和上臂组成的手臂使用两个分离的物体的刚体变换到左边动画。肘部看起来不太真实。在右侧，顶点混合用于单个对象。最右边的手臂说明了当简单的皮肤直接连接两部分来覆盖肘部时发生了什么。最右边的手臂说明了使用顶点混合时发生的情况，一些顶点使用不同的权重进行混合:(2/3,1/3)意味着顶点对来自上臂的变换权重为2/3，来自前臂的变换权重为1/3。该图还显示了最右边的插图顶点混合的缺点。这里可以看到肘部内侧的折叠。更多的骨骼和更仔细选择的重量可以达到更好的效果。</p>
<p><strong>顶点混合是解决这个问题的一个常用的方法。这种技术还有其他几个名字，如线性混合蒙皮、包络或骨架子空间变形。定义骨骼和皮肤对变化的反应在计算机动画中是一个古老的概念。在最简单的形式中，前臂和上臂像之前一样是分开活动的，但在关节处，这两个部分通过一个有弹性的“皮肤”连接起来。“所以，这个弹性部分将有一组顶点由前臂矩阵转换，另一组顶点由上臂矩阵转换。这导致三角形的顶点可以由不同的矩阵转换，而不是每个三角形使用一个矩阵。</strong></p>
<p><strong>更进一步，我们可以允许单个顶点由几个不同的矩阵进行变换，得到的位置加权并混合在一起。这是通过为动画对象设置骨骼骨架来实现的，其中每个骨骼的变换可以通过用户定义的权重影响每个顶点。因为整个手臂可能是“有弹性的”，也就是说，所有的顶点可能会受到不止一个矩阵的影响，整个网格通常被称为皮肤(骨头上)。许多商业建模系统都有类似的骨架建模功能。尽管名字叫骨头，但骨头并不一定是坚硬的。例如，Mohr和Gleicher提出了增加额外关节的想法，以实现肌肉膨胀等效果。James和Twigg讨论了使用可以挤压和拉伸的骨骼制作动画皮肤。</strong></p>
<p><strong>数学上，如式所示，其中p为原顶点，u(t)为变换后的顶点，其位置与时间t有关:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915142955.png" class="" title="image-20210915142955">

<p><strong>有n个骨头影响p的位置，p用世界坐标表示。wi的值是顶点p的骨i的权值，矩阵Mi 从初始的骨骼坐标系统转换到世界坐标。一般来说，骨骼的控制关节位于其坐标系的原点。例如，前臂骨将移动它的肘关节到原点，通过一个动画旋转矩阵将手臂的这部分围绕关节移动。Bi(t)矩阵是第i个骨的世界变换，它随时间变化以动画对象，并且通常是几个矩阵的连接，如先前骨变换的层次结构和局部动画矩阵。</strong></p>
<p><strong>维护和更新Bi(t)的一种方法 Woodland深入讨论了矩阵动画函数。每根骨头将一个顶点转换为相对于它自己的参考系的一个位置，并且最终的位置是从计算点集合中插值出来的。矩阵Mi 在一些关于剥皮的讨论中没有明确显示，而是被认为是Bi(t).我们在这里提出它，因为它是一个有用的矩阵，几乎总是矩阵连接过程的一部分。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915142820.png" class="" title="image-20210915142820">

<p>一个真实的顶点混合的例子。左上方的图像显示了手臂的两个骨头，在一个伸展的位置。在右上角，网格被显示出来，用颜色表示哪个骨骼拥有每个顶点。下:手臂的阴影网格在一个稍微不同的位置。(图片由Jeff Lander提供。)</p>
<p><strong>实际上，矩阵Bi(t)和Mi ^−1为每一帧动画的每一个骨骼连接，每个结果矩阵用于转换顶点。顶点p由不同骨骼的连接矩阵进行变换，然后混合使用权重wi这就是顶点混合的名字。权值是非负的，和是1，所以发生的是，顶点被转换到几个位置，然后在它们之间插入。因此，变换后的点u将位于点Bi(t)Mi ^−1P，对于所有I = 0…n−1(固定t)。法线通常也可以使用上式进行转换。根据所使用的变换(例如，如果骨头被拉伸或压扁相当大)，Bi(t)M^−1 i的逆的转置可能需要。</strong></p>
<p><strong>顶点混合非常适合在GPU上使用。网格中的顶点集可以放置在一个静态缓冲区中，该缓冲区发送给GPU一次并重复使用。在每一帧中，只有骨骼矩阵改变，顶点着色器计算它们对存储网格的影响。通过这种方式，CPU处理和传输的数据量被最小化，允许GPU有效地渲染网格。如果模型的整套骨基质可以一起使用，这是最简单的;否则，模型就必须被拆分，复制一些骨头。另外，骨头变换可以存储在顶点访问的纹理中，这避免了达到寄存器存储限制。通过使用四元数表示旋转，每个变换可以存储在两个纹理中。如果可用，无序访问视图存储允许重用蒙皮结果。</strong></p>
<p><strong>可以指定超出范围[0,1]或总和不为1的权值集。然而，这只有在使用其他混合算法(如morph目标)时才有意义。</strong></p>
<p><strong>基本顶点混合的一个缺点是可能会出现不必要的折叠、扭曲和自交。一个更好的解决方案是使用对偶四元数。这种剥皮技术有助于保持原始变形的刚性，从而避免四肢像糖果包装纸一样扭曲。计算量小于线性蒙皮混合成本的1.5倍，且结果良好，这使得该技术迅速被采用。然而，对偶四元数蒙皮会导致肿胀效应，Le和Hodgins提出旋转中心蒙皮是一种更好的选择。它们依赖于局部变换应该是刚体和具有相似权值的顶点wi，应该有类似的转换。每个顶点的旋转中心都是预先计算好的，而正交(刚体)约束则是为了防止弯头坍塌和包裹扭曲。在运行时，该算法类似于线性混合蒙皮，因为GPU实现在旋转中心执行线性混合蒙皮，然后执行四元数混合步骤。</strong></p>
<h2 id="Morphing-变形"><a href="#Morphing-变形" class="headerlink" title="Morphing 变形"></a>Morphing 变形</h2><p><strong>在执行动画时，从一个三维模型到另一个模型的变形是很有用的。假设一个模型在t0时刻显示,我们希望它在时间t1时变成另一个模型。对于t之间的所有时间t0和t1，利用某种插值方法得到了一个连续的“混合”模型。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210916115814.png" class="" title="image-20210916115814">

<p>顶点变形。每个顶点定义两个位置和法线。在每一帧中，中间位置和法线是由顶点着色器线性插值的。(图片由NVIDIA公司提供。)</p>
<p><strong>变形涉及解决两个主要问题，即顶点对应问题和插值问题。给定两个任意模型，它们可能具有不同的拓扑结构、不同的顶点数量和不同的网格连通性，通常必须首先建立这些顶点对应关系。这是一个难题这一领域已经有了大量的研究。我们向感兴趣的读者推荐Alexa的调查。</strong></p>
<p><strong>然而，如果两个模型之间已经存在一对一的顶点对应关系，那么就可以在每个顶点的基础上进行插值。也就是说，对于第一个模型中的每个顶点，在第二个模型中必须只存在一个顶点，反之亦然。这使得插值变得很容易。例如，线性插值可以直接在顶点上使用。来计算时间t∈[t0, t1]的变形顶点，我们首先计算s = (t−t0) / (t1 −t0)，然后是线性顶点混合，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210916120120.png" class="" title="image-20210916120120">

<p><strong>p0 和p1 对应于同一个顶点，但时间不同，t0 和t1．</strong></p>
<p><strong>变形的一种变体，其中用户有更直观的控制被称为变形目标或混合形状。</strong><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210916123531.png" class="" title="image-20210916123531"></p>
<p>给定两个嘴的姿态，计算一组差分向量来控制插补，甚至外推。在变形目标中，差异向量被用来“添加”运动到中立的面部。如果差分向量的权值为正，我们会得到一个微笑的嘴巴，而负权值则会产生相反的效果。</p>
<p><strong>我们从一个中性模型开始，在这个例子中是一张脸。我们用n表示这个模型。此外，我们还有一组不同的面部姿势。在示例插图中，只有一个姿势，那就是微笑的脸。一般情况下，我们允许k≥1个不同的位姿，表示为Pi, i∈[1，…k)。作为预处理，“差面”计算为:Di = Pi −N,即从每个姿势中减去中性模型。</strong></p>
<p><strong>在这一点上，我们有一个中立模型，N，和一组不同的姿势，Di．则可得到变形模型M，公式如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210916123847.png" class="" title="image-20210916123847">

<p><strong>这是中性模型，在此基础上，我们根据需要添加不同姿势的特征，使用重量wi．在图4.15中，设置w1 = 1给出的正是插图中间的笑脸。使用w1 = 0.5给我们一个半微笑的脸，以此类推。也可以使用负权重和大于1的权重。</strong></p>
<p><strong>对于这个简单的脸部模型，我们可以添加另一张有“悲伤”眉毛的脸。使用负重量的眉毛可以创建“快乐”眉毛。由于位移是附加的，这个眉毛姿势可以与微笑的嘴的姿势一起使用。</strong></p>
<p><strong>变形目标是一种强大的技术，它为动画师提供了大量的控制，因为模型的不同特性可以独立于其他特性进行操作。Lewis等人引入了位姿空间变形，它结合了顶点混合和变形目标。Senior使用预先计算的顶点纹理来存储和检索目标姿态之间的位移。支持流输出的硬件和每个顶点的ID允许在一个模型中使用更多的目标，并且只在GPU上计算效果。使用一个低分辨率的网格，然后通过镶嵌阶段和位移映射生成一个高分辨率的网格，避免了在一个高度详细的模型中蒙皮每个顶点的代价。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210916124022.png" class="" title="image-20210916124022">

<p>在《FAMOUS Second Son》中，Delsin角色的脸是用混合形状制作的。所有这些照片都使用相同的静止姿势脸，然后修改不同的权重，使脸看起来不同。(图片来源:Naughty Dog LLC. inFAMOUS Second Son c 2014索尼互动娱乐有限公司。inFAMOUS Second Son是索尼互动娱乐有限公司的商标，由Sucker Punch Productions LLC开发。)</p>
<p><strong>图显示了一个使用蒙皮和变形的真实示例。Weronko和Andreason在1886年的The Order中使用了剥皮和变形。</strong></p>
<h2 id="Geometry-Cache-Playback-几何缓存回放"><a href="#Geometry-Cache-Playback-几何缓存回放" class="headerlink" title="Geometry Cache Playback 几何缓存回放"></a><strong>Geometry Cache Pl</strong>ayback 几何缓存回放</h2><p><strong>在过场动画中，可能需要使用高质量的动画，例如，对于无法使用上述任何方法表现的动作。一种简单的方法是存储所有帧的所有顶点，从磁盘读取它们并更新网格。然而，对于一个包含30000个顶点的简单模型，在一个简短的动画中，这可能高达50 MB/s。Gneiting提出了几种将存储成本降低到10%左右的方法。</strong></p>
<p><strong>首先，使用量子化。例如，对于每个坐标，位置和纹理坐标使用16位整数存储。这个步骤是有损的，因为在执行压缩后不能恢复原始数据。为了进一步减少数据，进行了空间和时间预测，并对差异进行了编码。对于空间压缩，可以使用平行四边形预测。对于三角形带，下一个顶点的预测位置仅仅是当前三角形在当前三角形边周围的平面上的反映，形成一个平行四边形。然后对这个新位置的差异进行编码。有了良好的预测，大多数值将接近于零，这对许多常用的压缩方案来说是理想的。类似于MPEG压缩，预测也在时间维度。即每n帧进行空间压缩。在这两者之间，预测是在时间维度上完成的，例如，如果某个顶点以delta向量从帧n−1移动到帧n，那么它很可能以与帧n + 1相似的数量移动。这些技术大大减少了存储空间，因此该系统可以用于实时流数据。</strong></p>
<h2 id="Projections-投影"><a href="#Projections-投影" class="headerlink" title="Projections 投影"></a>Projections 投影</h2><p><strong>在真正渲染一个场景之前，场景中所有相关的物体都必须投影到某种平面上或某种简单的体积上。之后，执行裁剪和渲染。</strong></p>
<p><strong>本章到目前为止看到的转换没有影响第四个坐标w分量。也就是说，点和向量在转换后保留了它们的类型。此外，4×4矩阵的底部行一直是(0 0 0 1)。透视投影矩阵是这两种性质的例外:底部行包含向量和点操作数，并且经常需要均匀化过程。也就是说，w通常不是1，所以需要除以w才能得到非齐次点。正投影是一种比较简单的投影，也是常用的投影方法。它不影响w分量。</strong></p>
<p><strong>在本节中，假设观察者沿着相机的负z轴看，y轴向上，x轴向右。这是一个右手坐标系。一些文本和软件，例如DirectX，使用了一个左手系统，在这个系统中，观看者沿着相机的正z轴观看。这两种制度都是同样有效的，最终达到了同样的效果。</strong></p>
<h3 id="Orthographic-Projection-正投影"><a href="#Orthographic-Projection-正投影" class="headerlink" title="Orthographic Projection 正投影"></a>Orthographic Projection 正投影</h3><p><strong>正投影的一个特点是平行线在投影后仍然保持平行。当使用正投影来观察一个场景时，无论距离相机的距离如何，物体都保持相同的大小。矩阵Po，是一个简单的正交投影矩阵，它保持点的x和y分量不变，而将z分量设为零，即它正射向平面z = 0:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917151543.png" class="" title="image-20210917151543">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917151436.png" class="" title="image-20210917151436">

<p><strong>这种投影的效果如图所示。很明显,Po不可逆,因为它的行列式|Po| = 0。换句话说，转换从3维下降到2维，并且没有办法检索下降的维。使用这种直角投影进行观察的一个问题是，它将z值正的点和z值负的点投影到投影平面上。将z值(以及x和y值)限制在一定的区间内通常是有用的，比如从n(近平面)到f(远平面)。这是下一个转换的目的。</strong></p>
<p><strong>执行正投影的一个更常见的矩阵是用六元组表示的(l, r, b, t, n, f)，表示左、右、底、顶、近、远平面。这个矩阵缩放并转换轴向边界框(AABB;(参见第22.2节的定义)由这些平面组成一个轴对齐的立方体，围绕原点。AABB的最小角是(l, b, n)，最大角是(r, t, f)。重要的是要认识到n&gt;f，因为我们是在这个空间的负z轴下看。我们的常识告诉我们，接近值应该比远值低，所以我们可以让用户提供接近值，然后在内部取消它们。</strong></p>
<p><strong>在OpenGL中，轴向立方体的最小角为(−1，−1，−1)，最大角为(1,1,1);在DirectX的边界是(−1，−1,0)到(1,1,1)。这个立方体被称为规范视图体积，这个体积中的坐标被称为标准化设备坐标。转换过程如图所示。转换为规范视图体积的原因是在那里执行裁剪更有效。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917152005.png" class="" title="image-20210917152005">

<p>在规范视图卷上转换轴对齐的框。左边的方框首先被平移，使其中心与原点重合。然后将其缩放以得到规范视图体积的大小。</p>
<p><strong>在转换到规范视图体之后，要渲染的几何体的顶点被剪切到这个立方体上。立方体之外的几何图形最终通过将剩余的单元正方形映射到屏幕来呈现。正投影变换如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917152135.png" class="" title="image-20210917152135">

<p><strong>根据这个方程，Po 可以写成平移矩阵T(t)和缩放矩阵S(s)的串联，其中S = (2/(r - l)， 2/(T - b)， 2/(f - n))且t = (−(r + l)/2, −(t + b)/2, −(f + n)/2)。这个矩阵是可逆的（当且仅当≠ f, l ≠r, t ≠b;否则，不存在逆。），即P^−1 o = T(−t)S((r − l)/2,(t − b)/2,(f − n)/2).</strong></p>
<p><strong>在计算机图形学中，在投影后最常使用的是左坐标系。对于视口，x轴向右，y轴向上，z轴进入视口。由于远值小于我们定义AABB的方法的近值，正射影变换总是包含镜像变换。为了看到这一点，假设原始的AABB与目标，规范视图体积相同。那么AABB的(l, b, n)是(−1，−1,1)且(r, t, f)是(1,1，−1)</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917152611.png" class="" title="image-20210917152611">

<p><strong>这是一个镜像矩阵。正是这种镜像将从右手坐标系(向下看负z轴)转换为左手坐标系。</strong></p>
<p><strong>DirectX将z-depth映射到范围[0,1]，而不是OpenGL的[−1,1]。这可以通过在正字法矩阵之后应用一个简单的缩放和平移矩阵来实现，即，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917152732.png" class="" title="image-20210917152732">

<p><strong>所以，在DirectX中使用的正交矩阵是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917152754.png" class="" title="image-20210917152754">

<p><strong>它通常以转置形式表示，因为DirectX使用行格式来写矩阵。</strong></p>
<h3 id="Perspective-Projection-透视投影"><a href="#Perspective-Projection-透视投影" class="headerlink" title="Perspective Projection 透视投影"></a>Perspective Projection 透视投影</h3><p><strong>透视投影是一种比正投影更复杂的变换，它在大多数计算机图形应用中都很常用。在这里，平行线投影后一般不平行;相反，它们可能会聚到一个极端点。视角与我们感知世界的方式更接近，越远的物体越小。</strong></p>
<p><strong>首先，我们将给出一个投影到平面z =−d, d &gt; 0上的透视投影矩阵的有启发性的推导。我们通过世界空间来简化对世界到视野转换过程的理解。这个推导之后是更传统的矩阵，例如，OpenGL。</strong></p>
<p><strong>假设摄像机(视点)位于原点，我们想将一个点p投影到平面z =−d, d &gt; 0上，产生一个新的点q = (qx,qy，−d)。这个场景如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917153135.png" class="" title="image-20210917153135">

<p>用于推导透视投影矩阵的符号。点p被投影到平面z =−d, d &gt; 0上，得到投影点q。这个投影是从相机的位置的角度进行的，在这个例子中，相机的位置就是原点。在推导过程中使用的类似三角形显示了右边的x分量。</p>
<p><strong>由图中所示的相似三角形，q的x分量可推导为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917153553.png" class="" title="image-20210917153553">

<p><strong>q的其他分量的表达式是qy =−dpy/ pz (类似于qx),qz =−d。加上上面的公式，我们得到了透视投影矩阵Pp，如图所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917153604.png" class="" title="image-20210917153604">

<p><strong>这个矩阵产生正确的透视投影是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917153711.png" class="" title="image-20210917153711">

<p><strong>最后一步是，整个向量除以w分量(在这种情况下，为−pz/d)，在最后的位置得到1。结果的z值总是- d，因为我们投影到这个平面上。</strong></p>
<p><strong>直观上，很容易理解齐次坐标为什么允许投影。对均匀化过程的一种几何解释是，它投射出点(px，py，pz)在w = 1的平面上。</strong></p>
<p><strong>与正投影变换一样，也有透视变换，而不是实际投影到一个平面上(这是不可逆转的)，将视锥体转换为前面描述的标准视图体。这里假设视图平截头体从z = n开始和结束在z = f,且 0 &gt; n &gt; f。矩形在z = n最小的角(b,l,n)和最大的角(r,t,n)。如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917154012.png" class="" title="image-20210917154012">

<p>矩阵Pp 将视图截锥转换为单元立方体，称为规范视图体积。</p>
<p><strong>参数(l, r, b, t, n, f)确定摄像机的视锥。水平视场由截锥的左面和右面(由l和r决定)之间的角度决定。同样，垂直视场由上下平面之间的角度决定(由t和b决定)。视场越大，相机看到的就越多。不对称的视锥体可以由r≠-l或t≠−b创建。例如，不对称视锥用于立体视觉和虚拟现实(章节21.2.3)。</strong></p>
<p><strong>视野是提供场景感的一个重要因素。与电脑屏幕相比，眼睛本身有一个物理视野。这种关系是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917154251.png" class="" title="image-20210917154251">

<p><strong>其中φ为视场，w为物体垂直于视线的宽度，d为到物体的距离。例如，25英寸的显示器大约是22英寸宽。在12英寸外，水平视野是85度;20英寸时，是58度;30英寸，40度。同样的公式可以用于从相机镜头大小转换到视场，例如，一个标准的50mm镜头对一个35mm相机(有一个36mm宽的帧大小)φ = 2 arctan(36/(2.50)) = 39.6度。</strong></p>
<p><strong>与物理设置相比，使用更窄的视野会减少透视效果，因为观察者会被放大到场景中。设置一个更宽的视野会使物体看起来扭曲(像使用广角相机镜头)，特别是靠近屏幕边缘，并会夸大附近物体的比例。然而，更广阔的视野给观众一种物体更大、更令人印象深刻的感觉，并具有给用户更多关于周围环境的信息的优势。</strong></p>
<p><strong>将截锥转换为单位立方体的透视变换矩阵如式所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917154427.png" class="" title="image-20210917154427">

<p><strong>对一个点应用这个变换后，我们会得到另一个点q = (qx,qy,qz,qw）^T ．w分量qw，这个点的值(大多数情况下)是非零且不等于1。为了得到投影点p，我们需要除以qw,也就是说,</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917154607.png" class="" title="image-20210917154607">

<p><strong>矩阵Pp z = f映射到+1,z = n映射到−1。</strong></p>
<p><strong>远平面之外的物体将被裁剪，因此不会出现在场景中。透视投影可以处理远平面的无限大，得方程</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917154710.png" class="" title="image-20210917154710">

<p><strong>综上所述，透视变换(任何形式)，Pp，然后是剪切和均质化(除以w)，结果是标准化的坐标系。</strong></p>
<p><strong>为了得到OpenGL中使用的透视变换，首先与S(1,1，−1,1)相乘，原因与直角变换相同。这只是对Pp第三列中的值求反。在应用了这个镜像变换之后，近距离值和远距离值被输入为正值，0 &lt; n ‘ &lt; f ‘，就像传统上显示给用户的那样。然而，它们仍然表示沿着世界负z轴的距离，这是视图的方向。为了便于参考，下面是OpenGL方程:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917155250.png" class="" title="image-20210917155250">

<p><strong>一个简单的设置是只提供垂直视场，φ，长宽比a = w/h(其中w × h是屏幕分辨率)，n ‘和f ‘。这将导致</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917155353.png" class="" title="image-20210917155353">

<p><strong>式中c = 1.0/ tan(φ/2)。这个矩阵所做的正是旧的gluPerspective()所做的，它是OpenGL实用程序库(GLU)的一部分。</strong></p>
<p><strong>一些API(例如DirectX)将近平面映射为z = 0(而不是z =−1)和远平面映射为z = 1。此外，DirectX使用左手坐标系来定义它的投影矩阵。这意味着DirectX沿着正z轴，并将近值和远值表示为正数。下面是DirectX的等式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917160844.png" class="" title="image-20210917160844">

<p><strong>DirectX在其文档中使用行格式，所以这个矩阵通常以转置形式表示。</strong></p>
<p><strong>使用透视变换的一个效果是，计算的深度值不会随输入线性变化pz 值。使用方程中的任何一个与点p相乘，我们可以得到</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917161152.png" class="" title="image-20210917161152">

<p><strong>省略了vx 和vy ，常数d和f取决于所选的矩阵。那么d = - (f ‘ +n ‘)/(f ‘−n ‘)， e = - 2f ‘ n ‘ /(f ‘−n ‘)，和vx=−pz．为了获得归一化设备坐标(NDC)中的深度，我们需要除以w分量，结果是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917161410.png" class="" title="image-20210917161410">

<p><strong>在zNDC ∈[−1，+1]表示OpenGL投影。可以看出，输出深度为zNDC 与输入深度pz．</strong></p>
<p><strong>例如，如果n′ = 10和f ′ = 110(使用OpenGL)，当pz 是负z轴下60单位(即。归一化的设备坐标深度值为0.833，而不是0。下图显示了改变近平面距离原点的影响。近平面和远平面的位置会影响z缓冲区的精度。这个影响将在第23.7节进一步讨论。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917161546.png" class="" title="image-20210917161546">

<p>改变近平面到原点的距离所产生的影响。距离f ‘−n ‘保持在100。当近平面变得更接近原点时，离远平面更近的点使用更小的归一化设备坐标(NDC)深度空间。这使得z缓冲区在更远的距离上不那么精确。</p>
<p><strong>有几种方法可以提高深度精度。一个常见的方法，我们称之为反向z，是存储1.0−zNDC 可以是浮点深度，也可以是整数。对比下图所示。Reed用模拟来展示使用带反转z的浮点缓冲区提供了最好的精度，这也是整数深度缓冲区(通常每个深度有24位)的首选方法。对于标准映射(即未反向z）Upchurch和Des- brun提出，在变换中分离投影矩阵可以降低错误率。例如，使用P(Mp)可能比使用Tp更好，其中T = PM。此外，在[0.5,1.0]范围内，fp32和int24在精度上非常相似，因为fp32有一个23位尾数。有z的原因NDC 比例为1 / pz 它使硬件更简单，深度压缩更成功，这将在23.7节详细讨论。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917161747.png" class="" title="image-20210917161747">

<p>使用DirectX变换设置深度缓冲区的不同方法，例如:, zNDC ∈(0,+ 1)。左上:标准整数深度缓冲区，这里显示为4位精度(因此y轴上有16个标记)。右上:远平面设置为∞，两个轴上的小移动表明这样做并不会损失太多的精度。左下:有3个指数位和3个尾数位用于浮点深度。注意y轴上的分布是非线性的，这使得x轴上的分布更糟糕。右下:反向浮点深度，即1 - zNDC，结果是更好的分布。(插图由Nathan Reed提供。)</p>
<p><strong>Lloyd建议使用深度值的对数来提高阴影地图的精度。Lauritzen等人使用前一帧的z缓冲区来确定近平面的最大值和远平面的最小值。对于屏幕空间深度，Kemen建议使用以下每个顶点的重映射:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917162211.png" class="" title="image-20210917162211">

<p><strong>其中w是投影矩阵后的顶点的w值，z是顶点着色器的输出z。固定的fc为fc = 2/ log2(f + 1)其中f是远平面。当这个变换只应用于顶点着色器时，深度仍然会被GPU线性插值在顶点的非线性变换深度之间。因为对数是单调的只要分段线性插值和精确的非线性转换深度值之间的差异很小，函数、遮挡剔除硬件和深度压缩技术仍然有效。这对于大多数有足够几何镶嵌的情况是正确的。然而，也可以对每个片段应用转换。这是通过输出每个顶点的值e = 1 + w来完成的，然后由GPU在三角形上插值。像素着色器然后修改片段深度为log2 (ei)fc/2, ei 是e的插值值。当GPU中没有浮点深度以及使用大的深度距离渲染时，这种方法是一个很好的选择。</strong></p>
<p><strong>Cozzi提出使用多个视锥体，这可以有效地提高精度到任何期望的速率。视锥在深度方向上被划分为若干个不重叠的较小次视锥，次视锥的结合就是视锥。子视锥按前后顺序呈现。首先，颜色和深度缓冲都被清除，所有要渲染的对象都被分类到它们重叠的每个子视锥中。对于每个子视锥，它的投影矩阵被建立，深度缓冲区被清除，然后重叠的对象被渲染。</strong></p>
<h1 id="5-Shading-Basics-基本着色器"><a href="#5-Shading-Basics-基本着色器" class="headerlink" title="5 Shading Basics 基本着色器"></a>5 Shading Basics 基本着色器</h1><h2 id="Shading-Models-着色模型"><a href="#Shading-Models-着色模型" class="headerlink" title="Shading Models 着色模型"></a>Shading Models 着色模型</h2><p><strong>决定渲染对象外观的第一步是选择一个着色模型来描述对象的颜色应该如何根据表面方向、视图方向和照明等因素变化。</strong></p>
<p><strong>作为一个例子，我们将使用Gooch着色模型的一个变体。这是一种非写实的渲染形式，也是第15章的主题。Gooch着色模型的设计是为了增加技术插图细节的易读性。</strong></p>
<p><strong>Gooch着色的基本思想是比较表面法线和光的位置。如果法线指向光，则使用暖色调给表面上色;如果它指向远处，则使用较冷的色调。在这些色调之间插入角度，这是基于用户提供的表面颜色。在这个例子中，我们添加了一个程式化的“高亮”效果给模型表面一个闪亮的外观。如图显示了运行中的着色模型。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917164408.png" class="" title="image-20210917164408">

<p>一个程式化的底纹模型结合Gooch着色和高光效果。上面的图像显示了一个表面颜色为中性的复杂物体。下面的图片显示了不同表面颜色的球体。(Chinese Dragon mesh摘自Computer Graphics Archive， original model摘自Stanford 3D Scanning Repository)</p>
<p><strong>着色模型通常有用于控制外观变化的属性。设置这些属性的值是确定对象外观的下一步。我们的示例模型只有一个属性，即表面颜色，如上图底图所示。</strong></p>
<p><strong>像大多数着色模型一样，受相对于视图和光照方向的表面方向的影响。为了遮光，这些方向通常表示为标准化(单位长度)向量，如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917164719.png" class="" title="image-20210917164719">

<p>单位长度矢量输入的着色模型(和大多数其他):表面法线n，视图矢量v，和光方向l。</p>
<p><strong>现在我们已经定义了着色模型的所有输入，我们可以看看模型本身的数学定义:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917165222.png" class="" title="image-20210917165222">

<p><strong>在这个方程中，我们使用了以下中间计算:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917165240.png" class="" title="image-20210917165240">

<p><strong>这个定义中的几个数学表达式经常在其它的定义中找到还有着色模型。clamp操作，典型的clamp到0或clamp在0和1之间，在着色中很常见。这里我们使用1.2节介绍的x+-符号，来表示计算高亮混合因子s时使用的0和1之间的夹紧。点积运算符出现了三次，每次出现在两个单位长度向量之间;这是一种非常常见的模式。两个向量的点积是它们的长度和夹角的余弦值的乘积。所以，两个单位长度向量的点积就是余弦，这是两个向量对齐程度的一个有用度量。在着色模型中，由余弦组成的简单函数通常是描述两个方向(如光方向和表面法线)之间关系的准确的数学表达式。</strong></p>
<p><strong>另一个常见的着色操作是基于0到1之间的标量值在两种颜色之间进行线性插值。该操作的形式为tca + (1 - t)cb 它在c之间插入ca 和cb 当t的值分别在1和0之间移动时。这个模式在这个着色模型中出现了两次，第一次是在cwarm 和ccool 然后在前面的插值结果和c之间进行插值highlight．线性插值经常出现在着色器中，它是一个内置函数，称为lerp或mix，在我们所见过的每一种着色语言中。</strong></p>
<p><strong>行“r = 2 (n·l)n−l”计算反射光矢量，反射l大约n。虽然不像前两种操作那么常见，但对于大多数着色语言来说，这是足够常见的，因此也有一个内置的反射函数。</strong></p>
<p><strong>通过将这些操作以不同的方式与各种数学表达式和着色参数相结合，可以为各种程式化和逼真的外观定义着色模型。</strong></p>
<h2 id="Light-Sources-光源"><a href="#Light-Sources-光源" class="headerlink" title="Light Sources 光源"></a>Light Sources 光源</h2><p><strong>光照对我们例子中的着色模型的影响非常简单;它为着色提供了一个主要方向。当然，现实世界中的照明可能相当复杂。可以有多个光源，每个光源都有自己的大小、形状、颜色，和强度;间接照明增加了更多的变化。正如我们将在第9章中看到的，基于物理的、逼真的着色模型需要考虑所有这些参数。</strong></p>
<p><strong>相比之下，程式化的着色模型可以根据应用程序和视觉风格的需要，以许多不同的方式使用照明。一些高度程式化的模型可能根本没有光照的概念，或者(像我们Gooch着色的例子)可能只使用它来提供一些简单的方向性。</strong></p>
<p><strong>光照复杂性的下一步是让着色模型以二进制的方式对光线的存在或不存在做出反应。一个被这样的模型着色的表面在被光照时将会有一个外观，而在不受光照影响时则会有不同的外观。这意味着一些区分这两种情况的标准:与光源的距离，阴影(将在第7章中讨论)，表面是否面对光源(即表面法线n和光线向量l之间的角度大于90◦)，或这些因素的某种组合。</strong></p>
<p><strong>从光的二元存在或缺失到光强度的连续尺度只有一小步。这可以表示为缺失和完全存在之间的简单插值，这意味着强度的有界范围，可能是0到1，或作为一个以其他方式影响着色的无界量。对于后者，一个常见的选择是将着色模型分解为有光和没有光的部分，光强度为klight 线性缩放被照亮的部分:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918134527.png" class="" title="image-20210918134527">

<p><strong>这很容易扩展到RGB浅色clight，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918134538.png" class="" title="image-20210918134538">

<p><strong>对于多种光源，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918134552.png" class="" title="image-20210918134552">

<p><strong>未点亮的部分funlit(n, v)对应于视光为二进制的着色模型的“不受光线影响时的外观”。它可以有各种形式，取决于所需的视觉风格和应用程序的需要。例如,funlit() =(0,0,0)将使任何不受光源影响的表面变成纯黑色。另一方面，未照明的部分可以表达某种形式的程式化外观，为未照明的物体，类似于Gooch模型的冷颜色面向远离光的表面。通常，这部分的着色模型表达了一些形式的照明，不是直接来自明确放置的光源，如来自天空的光或从周围物体反弹的光。这些其他形式的照明将在第10章和第11章中讨论。</strong></p>
<p><strong>我们前面提到过，如果光源方向l大于90◦ ，则光源不影响表面点从表面法线n，实际上来自在表面。这可以被认为是光的方向，相对于表面，和它对着色的影响之间更普遍关系的一个特殊情况。尽管这种关系是基于物理的，但它可以从简单的几何原理中推导出来，并且对于许多类型的非物理的、程式化的着色模型也很有用。</strong></p>
<p><strong>光照在表面上的效果可以被看作是一组光线，光线的密度与光照强度相对应，以达到表面着色的目的。如图所示，它显示了被照亮表面的横截面。击中表面间距光线沿横截面成反比夹角的余弦值l和n。所以,光线击中的整体密度表面夹角的余弦成正比l和n,这正如我们前面看到的,等于这两个单位长度向量的点积。在这里我们看到了为什么定义光矢量l与光的运动方向相反的;否则我们必须在做点积之前对它进行无效化。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918135025.png" class="" title="image-20210918135025">

<p>图的上一行显示了光在表面上的横截面视图。在左边，光线直直地照射在表面上，在中间，光线以一个角度照射在表面上，在右边，我们看到了向量点积来计算角度余弦。下面的图显示了横截面平面(包括光线和视图向量)与整个表面的关系。</p>
<p><strong>更准确地说，当点积为正时，光线密度(以及光线对着色的影响)与点积成正比。负值对应的是从表面后面来的光线，没有影响。所以，在用光的着色乘以光的点积之前，我们需要先clamp点积为0。使用1.2节中介绍的x+符号，这意味着将负数clamp为零，我们有</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918135453.png" class="" title="image-20210918135453">

<p><strong>支持多个光源的着色模型通常会使用方程</strong></p>
<p><strong><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918134552.png" class="" title="image-20210918134552"></strong></p>
<p><strong>中的一个结构，这是更一般的，或者方程</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918135453.png" class="" title="image-20210918135453">

<p><strong>这是物理模型所需要的。它对程式化的模型也很有好处，因为它有助于确保照明的整体一致性，特别是面对光线或阴影的表面。然而，有些模型并不适合这种结构;这些模型将使用</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918134552.png" class="" title="image-20210918134552">

<p><strong>函数flit()的最简单的选择是使它成为一种恒定的颜色，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918135900.png" class="" title="image-20210918135900">

<p><strong>得到如下着色模型:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918135913.png" class="" title="image-20210918135913">

<p><strong>这个模型中被照亮的部分对应于Lambertian着色模型，以约翰·海因里希·兰伯特命名，他在1760年发表了这个模型。该模型适用于理想的漫反射表面，即完全哑光的表面。我们在这里对Lambert模型作了一些简化的解释，这将在第9章中详细讨论。Lambertian模型本身可以用于简单的着色，它是许多着色模型的关键组成部分。</strong></p>
<p><strong>由上面的式子可知，光源通过两个参数与着色模型相互作用:指向光源的向量l和光源颜色clight．有各种不同类型的光源，主要区别于这两个参数在场景中的变化。</strong></p>
<p><strong>接下来我们将讨论几种常有的类型的光源,有一个共同点:在给定表面位置,每个表面的照明光源,只从一个方向l。换句话说,光源,从表面着色的位置,是一个无限小的点。这对现实世界的光来说并不完全正确，但大多数光源相对于它们与被照表面的距离来说都很小，这是一个合理的近似。在第7.1.2节和10.1节中，我们将讨论从一定范围的方向照亮一个表面位置的光源，即“区域灯”。</strong></p>
<h3 id="Directional-Lights-定向光源"><a href="#Directional-Lights-定向光源" class="headerlink" title="Directional Lights 定向光源"></a>Directional Lights 定向光源</h3><p><strong>定向光是光源的最简单模型。l和clight 都是常数，除了clight 可因阴影而减弱。定向光没有位置。当然，实际的光源在空间中有特定的位置。方向性光源是抽象的，当与光源的距离相对于场景大小较大时，它工作得很好。例如，一个20英尺外的泛光灯照亮一个小的桌面立体模型，可以表示为一个方向灯。另一个例子是任何被太阳照亮的场景，除非这个场景是像太阳系的内行星这样的东西。</strong></p>
<p><strong>方向性光的概念可以扩展到允许改变clight 而光的方向l保持不变。这通常是为了将光线的效果限定在场景的特定部分，以达到表演或创作的目的。例如，一个区域可以定义为两个嵌套的(一个在另一个里面)盒形体，其中clight 等于(0,0,0)(纯黑)在外面的盒子里，等于某个常数在里面的盒子里，然后平滑地在两个盒子之间的区域内插值。</strong></p>
<h3 id="Punctual-Lights-守时的光源"><a href="#Punctual-Lights-守时的光源" class="headerlink" title="Punctual Lights 守时的光源"></a>Punctual Lights 守时的光源</h3><p><strong>守时灯不是指准时赴约的灯，而是指有位置的灯，不像定向光。这种灯也没有尺寸，没有形状或大小，不像现实世界的光源。我们使用“准时”这个词，这个词来自拉丁语“punctus”，意思是“点”，指的是由来自一个单一的、局部的位置的所有照明来源组成的一类。我们用“点光”这个术语来表示一种特定的发射器，它向各个方向均匀地发光。所以，点和聚光灯是两种不同形式的准时照明。光方向向量l的变化取决于当前着色表面点p0 相对于点灯的位置plight：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918141138.png" class="" title="image-20210918141138">

<p><strong>这个等式是向量规范化的一个例子:将一个向量除以它的长度，得到一个指向相同方向的单位长度向量。这是另一个常见的着色操作，就像我们在上一节看到的着色操作一样，它是大多数着色语言中的内置函数。然而，有时需要这个操作的中间结果，这需要在多个步骤中使用更基本的操作显式地执行规范化。将此应用于准时光方向计算得到以下结果:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918141148.png" class="" title="image-20210918141148">

<p><strong>因为两个向量的点积等于两个向量的长度与夹角的余弦值的乘积，以及0◦的余弦值的乘积点积是1一个向量与它自身的平方。为了求任意向量的长度，我们只需要将它与自身作点积然后取结果的平方根。</strong></p>
<p><strong>我们需要的中间值是r，即点状光源和当前着色点之间的距离。除了用于光矢量的归一化，r的值还需要计算光色clight的衰减(变暗)作为距离的函数。这将在下一节中进一步讨论。</strong></p>
<h4 id="Point-Omni-Lights-点光源-泛光灯"><a href="#Point-Omni-Lights-点光源-泛光灯" class="headerlink" title="Point/Omni Lights 点光源/泛光灯"></a>Point/Omni Lights 点光源/泛光灯</h4><p><strong>向各个方向均匀发出光的准时灯被称为点灯光源或泛光灯。对于点光源，clight 变化是距离r的函数，变化的唯一来源是上面提到的距离衰减。下图展示了为什么会出现这种变暗，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918141912.png" class="" title="image-20210918141912">

<p>从点光源发出的光线之间的间距与距离r成比例地增加。由于间距的增加发生在二维空间中，光线密度(和光强度)与1/r成比例地减少2．</p>
<p><strong>使用类似于的余弦因子的几何推理。在给定的表面上，点光源发出的光线之间的间距与从表面到光线的距离成正比。与之前的余弦因子不同，这种间距的增加发生在表面的两个维度上，因此射线密度(以及浅色clight)与距离的平方反比1/r²．这使我们能够指定clight中的空间变异有一个单一的光属性，clight0 ，定义为clight在固定参考距离r0处的值：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918142530.png" class="" title="image-20210918142530">

<p><strong>上式常称为反平方光衰减。虽然从技术上讲，点光源的正确距离衰减，有一些问题使这个方程不太理想的物理着色使用。</strong></p>
<p><strong>第一个问题发生在相对较小的距离。当r的值趋于0时，clight 将以无界的方式增长。当r达到0时，我们有一个除以0的奇点。为了解决这个问题，一个常见的修改是在分母上加一个小值E:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918142650.png" class="" title="image-20210918142650">

<p><strong>E使用的确切值取决于应用程序;例如， Unreal Engine使用E = 1厘米。</strong></p>
<p><strong>在CryEngine和Frostbite游戏引擎中使用的另一种修改是将r clamp到最小值rmin：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918142928.png" class="" title="image-20210918142928">

<p><strong>与前面方法中使用的有点任意的E值不同，rmin 有一个物理解释:发出光的物理物体的半径。r小于rmin 对应于被着色的表面穿透到物理光源内部，这是不可能的。</strong></p>
<p><strong>相反，平方反衰减的第二个问题发生在相对较大的距离上。问题不在于视觉效果，而在于性能。尽管光强随距离不断减小，但它从不趋于0。为了有效的渲染，光在一定距离达到0强度是可取的(第20章)。有许多不同的方法可以修改平方反比方程来达到这个目的。理想情况下，修改应该引入尽可能少的更改。为了避免在光线影响的边界处出现尖锐的截止，修改后的函数的导数和值在相同的距离处达到0也是更好的。一种解决方法是将平方反比方程乘以一个窗函数所需的属性。其中一个功能被Unreal Engine和Frostbite游戏引擎使用:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918173026.png" class="" title="image-20210918173026">

<p><strong>+2的意思是，如果值是负数，则在平方它之前clamp到0。下图显示了一个反平方曲线，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918173146.png" class="" title="image-20210918173146">

<p>这个图显示了一条反平方曲线(使用E方法来避免奇点，E值为1)，方程中描述的窗口函数(rmax 设置为3)，窗口曲线。</p>
<p><strong>方程中的窗口函数，以及两者相乘的结果。</strong></p>
<p><strong>应用要求将影响使用方法的选择。例如，rmax 处的导数为0当距离衰减函数以相对较低的空间频率采样时(例如，在光照贴图或逐顶点)，这一点尤为重要。CryEngine不使用光照贴图或顶点光照，所以它采用了一个更简单的调整，在0.8rmax和rmax之间切换到线性衰减。</strong></p>
<p><strong>对于一些应用程序，匹配反平方曲线不是优先考虑的，所以完全使用其他一些函数。这有效地将上方一系列方程推广为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918173539.png" class="" title="image-20210918173539">

<p><strong>fdist(r)是距离的函数。这样的函数称为距离衰减函数。在某些情况下，非反平方衰减函数的使用是由性能约束驱动的。例如，在《Just Cause 2》中，灯光的计算成本非常低。这要求了一个易于计算的衰减函数，同时也足够平滑，以避免逐顶点光照伪影:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918173619.png" class="" title="image-20210918173619">

<p><strong>在其他情况下，衰减函数的选择可能是由创造性考虑驱动的。例如，虚幻引擎，用于现实和风格游戏，有两种模式的光衰减:反平方模式和指数衰减模式，可以调整以创建各种衰减曲线。《古墓丽影》(2013)的开发者使用样条编辑工具来绘制衰减曲线，从而更好地控制曲线形状。</strong></p>
<h4 id="Spotlights-聚光灯"><a href="#Spotlights-聚光灯" class="headerlink" title="Spotlights 聚光灯"></a>Spotlights 聚光灯</h4><p><strong>与点光源不同，现实世界中几乎所有光源的照明都因方向和距离而变化。这种变化可以表示为一个方向衰减函数fdir(l)，结合距离衰减函数来定义光强的整体空间变化:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918173746.png" class="" title="image-20210918173746">

<p><strong>不同的fdir(l)能产生各种灯光效果。其中一种重要的效应是聚光灯，它将光线投射成一个圆锥体。聚焦方向衰减函数围绕聚焦方向矢量s具有旋转对称性，因此可以表示为角度θs在s和反方向的光矢量−l之间。光矢量需要反转，因为我们在表面定义l指向光，而这里我们需要向量指向光。</strong></p>
<p><strong>大多数聚焦函数使用由θs的余弦函数表达，它(正如我们之前看到的)是着色中最常见的角度形式。聚光灯通常有一个本影角θu，它限制了光线，使所有θs ≥θu，fdir(l)=0．这个角度在类似于最大衰减距离rmax 见过。聚光灯有一个半影角θp也是很常见的，它定义了一个内锥，在那里光线达到最大强度。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918174300.png" class="" title="image-20210918174300">

<p>一个焦点:θs 为从光定义的方向s到向量- l(指向表面的方向)的角度;θp 显示了模糊;和θu 显示为光定义的本影角度。</p>
<p><strong>聚光灯使用了各种方向衰减函数，但它们往往是大致相似的。例如函数fdirF (l)用于Frostbite游戏引擎，函数fdirT (l)用于three.js浏览器图形库:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918174509.png" class="" title="image-20210918174509">

<p><strong>回想一下，x+-是在0和1之间 clamp x的符号，在第1.2节中介绍过。平滑步进函数是一个三次多项式，经常用于光滑插值着色。它是大多数着色语言中的内置函数。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918174628.png" class="" title="image-20210918174628">

<p>此图显示了到目前为止我们已经讨论过的一些类型的光。从左到右:定向光、没有衰减的点光源、有平稳过渡的聚光灯。注意，点光源向边缘变暗是因为光源和表面之间的角度变化。</p>
<h4 id="Other-Punctual-Lights-其他守时的灯"><a href="#Other-Punctual-Lights-其他守时的灯" class="headerlink" title="Other Punctual Lights 其他守时的灯"></a>Other Punctual Lights 其他守时的灯</h4><p><strong>clight 的值可以变化。</strong></p>
<p><strong>fdir(l)函数不局限于上面讨论的简单聚光灯衰减函数;它可以代表任何类型的方向变化，包括从真实世界的光源测量的复杂的表格模式。照明工程协会(IES)已经为这种测量定义了标准文件格式。IES简介可从许多照明制造商，并已用于游戏Killzone: Shadow Fall，以及Unreal和Frostbite游戏引擎等。拉加德很好地总结了与解析和使用该文件格式有关的问题。</strong></p>
<p><strong>《古墓丽影》(2013)中有一种准时光，它适用于x, y和z世界轴上的距离独立衰减函数。在《古墓丽影》中，曲线也可以用来改变光照强度，例如，产生闪烁的手电筒。</strong></p>
<p><strong>在第6.9节中，我们将讨论如何通过使用纹理来改变光的强度和颜色。</strong></p>
<h3 id="Other-Light-Types-其他光源"><a href="#Other-Light-Types-其他光源" class="headerlink" title="Other Light Types 其他光源"></a>Other Light Types 其他光源</h3><p><strong>定向光和守时光的主要特征是如何计算光的方向l。不同类型的光可以通过使用其他方法来计算光的方向来定义。例如，除了前面提到的灯光类型，《古墓丽影》还使用线段作为光源的胶囊灯，而不是点。对于每个着色像素，以线段上最近点的方向作为光方向l。</strong></p>
<p><strong>只要着色器有l和clight 值用于估计着色方程，任何方法都可以用来计算这些值。</strong></p>
<p><strong>到目前为止所讨论的光的类型都是抽象的。在现实中，光源有大小和形状，它们从多个方向照亮表面点。在渲染中，这样的灯被称为区域灯，它们在实时应用中的使用正在稳步增加。区域光渲染技术分为两类:模拟区域光部分闭塞导致阴影边缘的软化(第7.1.2节)和模拟区域光对表面着色的影响(第10.1节)。对于光滑的镜面表面来说，第二种类型的照明是最明显的，在这种表面上，光的形状和大小可以从它的反射中清楚地辨别出来。定向光和守时光不太可能被废弃，尽管它们不再像过去那样无处不在。计算光的面积的近似方法已经开发出来了，实现起来相对简单，因此得到了更广泛的应用。提高的GPU性能也允许比过去更精细的技术。</strong></p>
<h2 id="Implementing-Shading-Models-实现着色模型"><a href="#Implementing-Shading-Models-实现着色模型" class="headerlink" title="Implementing Shading Models 实现着色模型"></a>Implementing Shading Models 实现着色模型</h2><p><strong>为了有用，这些着色和光照方程当然必须在代码中实现。在本节中，我们将讨论设计和编写此类实现时的一些关键考虑因素。我们还将浏览一个简单的实现示例。</strong></p>
<h3 id="Frequency-of-Evaluation-评估频率"><a href="#Frequency-of-Evaluation-评估频率" class="headerlink" title="Frequency of Evaluation 评估频率"></a>Frequency of Evaluation 评估频率</h3><p><strong>当设计一个着色实现时，需要根据计算的频率进行划分。首先，确定给定计算的结果在整个draw调用中是否始终是常量。在这种情况下，计算可以由应用程序执行，通常在CPU上，尽管GPU计算着色器可以用于特别昂贵的计算。结果通过统一的着色器输入传递给图形API。</strong></p>
<p><strong>即使在这个类别中，评估的可能频率也有很大的范围，从“once ever”开始。最简单的例子是着色方程中的常量子表达式，但这可以应用于基于很少变化的因素的任何计算，如硬件配置和安装选项。这样的着色计算可能会在编译着色器时解决，在这种情况下甚至不需要设置一个统一的着色器输入。或者，计算可以在离线预计算过程中执行，在安装时执行，或者在加载应用程序时执行。</strong></p>
<p><strong>另一种情况是，当着色计算的结果在应用程序运行过程中发生变化，但速度很慢，没有必要每一帧都更新它。例如，在虚拟游戏世界中，光照因素取决于一天中的时间。如果计算是昂贵的，它可能是值得摊销在多个帧。</strong></p>
<p><strong>其他情况包括每帧执行一次的计算，如连接视图和透视矩阵;或者每个模型一次，例如更新依赖于位置的模型照明参数;或者每次绘制调用一次，例如，更新模型中每个材质的参数。根据评估频率对统一的着色器输入进行分组有助于提高应用效率，并通过最小化不断更新来帮助GPU提升性能。</strong></p>
<p><strong>如果一个着色计算的结果在绘制调用中发生了变化，它不能通过一个统一的着色器输入传递给着色器。相反，它必须由第3章中描述的可编程着色器阶段之一计算，如果需要，通过不同的着色器输入传递到其他阶段。理论上，着色计算可以在任何可编程阶段执行，每个阶段对应不同的评估频率:</strong></p>
<pre><code>**顶点着色：评估每个预镶嵌细分顶点。**

**外壳着色器：评估每个表面补丁。**

**域着色器：评估每个后镶嵌细分顶点。**

**几何着色器：每个原始元素评估。**

**像素着色器：每像素评估。**
</code></pre>
<p><strong>在实践中，大多数着色计算是按像素执行的。虽然这些通常是在像素着色器中实现的，但计算着色器的实现越来越普遍;一些例子将在第20章中讨论。其他阶段主要用于几何操作，如变换和变形。为了理解为什么会出现这种情况，我们将比较逐顶点和逐像素着色计算的结果。在较早的文献中，它们有时被分别称为Gouraud着色和Phong着色，尽管这些术语现在不常使用。这个比较使用了一个类似于公式</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917165222.png" class="" title="image-20210917165222">

<p><strong>的着色模型，但是修改了它来处理多个光源。完整的模型将在稍后详细介绍示例实现时给出。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918192859.png" class="" title="image-20210918192859">

<p>对比着色模型的逐像素和逐顶点计算，显示了三个不同顶点密度的模型。左边的列显示逐像素计算的结果，中间的列显示逐顶点计算的结果，右边的列显示每个模型的线框渲染图，以显示顶点密度。(Chinese Dragon mesh摘自Computer Graphics Archive，original model摘自Stanford 3D Scanning Repository)</p>
<p><strong>上图显示了在大范围的顶点密度模型上逐像素和逐顶点着色的结果。对于龙来说，网格非常密，两者之间的差别很小。但在茶壶上，顶点着色评估会导致可见的错误，如在两个三角形平面上出现角形高光，显然是不正确的。造成这些错误的原因是部分着色方程，特别是高光，有非线性变化的值网格曲面。这使得它们不适合顶点着色器，其结果在被提供给像素着色器之前在三角形上进行线性插值。</strong></p>
<p><strong>原则上，在像素着色器中只计算着色模型的高光部分，而可能在顶点着色器中计算其余部分。这可能不会产生视觉伪影，而且理论上可以节省一些计算。在实践中，这种混合实现往往不是最佳的。着色模型的线性变化部分的计算成本最低，并且以这种方式分割着色计算可能会增加开销，例如重复计算和额外的变化输入，从而超过好处。</strong></p>
<p><strong>正如我们之前提到的，在大多数实现中，顶点着色器负责非着色操作，如几何变换和变形。生成的几何表面属性，转换成适当的坐标系统，由顶点着色器写出来，在三角形上进行线性插值，并作为不同的着色器输入传递到像素着色器。这些属性通常包括表面的位置，表面法线，可选的表面切向量，法线映射。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918193802.png" class="" title="image-20210918193802">

<p>在左边，我们看到单位法线在曲面上的线性插值结果是长度小于1的插值向量。在右边，我们看到长度显著不同的法线的线性插值导致插值方向向两个法线的较长的方向倾斜。</p>
<p><strong>注意，即使顶点着色器总是生成单位长度的表面法线，插值也可以改变它们的长度。如图左侧所示。由于这个原因，法线需要在像素着色器重新标准化(缩放到长度1)。然而，顶点着色器生成的法线长度仍然很重要。如果顶点之间的法向长度变化显著，例如，作为顶点混合的副作用，这将使插值偏斜。这可以在图的右侧看到。由于这两种效果，经常在插值前后对插值向量进行归一化，即在顶点和像素着色器。</strong></p>
<p><strong>与表面法线不同的是，指向特定位置的向量，如视图向量和守时灯向量，通常不会被插值。相反，插值的表面位置用于计算像素着色器中的这些向量。除了归一化(我们已经看到在任何情况下都需要在像素着色器中执行)，每个向量都是通过向量减法计算的，这是非常快速的。如果出于某种原因，有必要插入这些向量，不要预先归一化它们。这将产生不正确的结果，如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918194249.png" class="" title="image-20210918194249">

<p>两个光矢量之间的插值。在左边，插值前的归一化导致插值后的方向不正确。在右边，插值非归一化向量得到正确的结果。</p>
<p><strong>之前我们提到过顶点着色器将表面几何转换为“适当的坐标系统”。摄像机和光线的位置，通过统一变量传递给像素着色器，通常由应用程序转换到相同的坐标系统。这将最小化像素着色器所做的工作，以将所有着色模型向量带入相同的坐标空间。但是哪个坐标系才是“合适”的呢？可能包括全局世界空间以及相机的局部坐标系统，或者当前渲染模型的坐标系统。基于系统的考虑(如性能、灵活性和简单性)，通常会对整个渲染系统做出选择。例如，如果渲染场景需要包含大量的光，则可以选择世界空间，以避免改变光的位置。另外，相机空间可能是首选，以更好地优化与视图向量相关的像素着色器操作，并可能提高精度(章节16.6)。</strong></p>
<p><strong>尽管大多数着色器实现，包括我们将要讨论的示例实现，遵循上面描述的一般大纲，当然也有例外。例如，一些应用程序出于风格上的原因选择每个原始底纹评价的面外观。这种风格通常被称为平面着色。下图显示了两个例子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918194718.png" class="" title="image-20210918194718">

<p>两款使用平面着色作为风格选择的游戏:《Kentucky Route Zero》(顶部)和《that Dragon》(底部)。(上图来自Cardboard Computer，下图来自Numinous Games。)</p>
<p><strong>原则上，平面着色可以在几何着色器中执行，但目前的实现通常使用顶点着色器。这是通过将每个元素的属性与其第一个顶点关联并禁用顶点值插值来实现的。禁用插值(可以分别对每个顶点值执行)会导致第一个顶点的值被传递给元素中的所有像素。</strong></p>
<h3 id="Implementation-Example-实现示例"><a href="#Implementation-Example-实现示例" class="headerlink" title="Implementation Example 实现示例"></a>Implementation Example 实现示例</h3><p><strong>现在我们将展示一个着色模型实现的例子。如前所述，我们实现的着色模型类似于Gooch模型的扩展公式，但修改为适用于多个光源。它被描述为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918194934.png" class="" title="image-20210918194934">

<p><strong>中间计算如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918195003.png" class="" title="image-20210918195003">

<p><strong>这个公式适用于之前公式中的多光结构，为了方便起见，这里重复一下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918195046.png" class="" title="image-20210918195046">

<p><strong>这里（光）亮的和未亮的是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918195145.png" class="" title="image-20210918195145">

<p><strong>通过调整冷色的未亮贡献，使结果看起来更像原来的方程。</strong></p>
<p><strong>在大多数典型的渲染应用程序中，改变材质属性的值，如csurface 将存储在顶点数据中，或者，存储在纹理中(第六章)，当然，surface 在整个模型中是恒定的。</strong></p>
<p><strong>这个实现将使用着色器的动态分支功能来循环所有光源。虽然这种直接的方法可以很好地在简单的场景工作，但它不能很好地扩展到大型和几何复杂的场景，有许多光源。渲染技术有效地处理大计数的光将在第20章中介绍。另外，为了简单起见，我们只支持一种光源:点光源。尽管实现非常简单，但它遵循前面介绍的最佳实践。</strong></p>
<p><strong>着色模型不是孤立实现的，而是在一个更大的渲染框架的上下文中实现的。这个例子是在一个简单的WebGL 2应用程序中实现的，它是由Tarek Sherif修改的“phong -着色立方体”WebGL 2示例，但同样的原则也适用于更复杂的框架。</strong></p>
<p><strong>我们将讨论应用程序中GLSL着色器代码和JavaScript WebGL调用的一些示例。目的不是教WebGL API的细节，而是展示一般的实现原则。我们将按照“由内到外”的顺序来执行，从像素着色器开始，然后是顶点着色器，最后是应用程序端图形API调用。</strong></p>
<p><strong>在着色器代码正确之前，着色器源代码包括着色器输入和输出的定义。如3.3节所述，使用GLSL术语，着色器输入分为两类。一个是统一输入的集合，它具有应用程序设置的值，并且在调用draw时保持不变。第二种类型由不同的输入组成，它的值可以在着色器调用(像素或顶点)之间改变。在这里我们看到像素着色器的不同输入的定义，在GLSL中被标记，以及它的输出:</strong></p>
<p><img src="C:\Users\86010\AppData\Roaming\Typora\typora-user-images\image-20210918195829339.png" alt="image-20210918195829339"></p>
<p><strong>这个像素着色器有一个单一的输出，即最终的着色颜色。像素着色器输入与顶点着色器输出相匹配，顶点着色器输出在输入像素着色器之前被插值在三角形上。这个像素着色器有两个不同的输入:表面位置和表面法线，两者都在应用程序的世界空间坐标系统中。均匀输入的数量要大得多，因此为了简洁起见，我们只给出两个定义，它们都与光源有关:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918200146.png" class="" title="image-20210918200146">

<p><strong>因为这些都是点光源，所以每个点光源的定义都包括一个位置和颜色。它们被定义为vec4而不是vec3，以符合GLSL std140数据布局标准的限制。尽管在本例中，std140布局可能会导致一些空间浪费，但它简化了确保CPU和GPU之间数据布局一致的任务，这就是我们在本示例中使用它的原因。Light结构的数组在一个命名的统一块中定义，这是一个GLSL特性，用于将一组统一变量绑定到一个缓冲区对象，以实现更快的数据传输。数组的长度被定义为等于应用程序在一次绘制调用中允许的最大灯数。正如我们稍后将看到的，在着色器编译之前，应用程序用正确的值(在本例中是10)替换着色器源中的MAXLIGHTS字符串。统一整数uLightCount是抽取调用中实际活动的灯数。</strong></p>
<p><strong>接下来，我们将看看像素着色器代码:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918200717.png" class="" title="image-20210918200717">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918200736.png" class="" title="image-20210918200736">

<p><strong>我们有一个lit术语的函数定义，由main()函数调用。总的来说，这是上述方程的一个简单的GLSL实现。注意funlit()和cwarm 作为统一变量传入。由于这些值在整个绘制调用中都是常数，应用程序可以计算这些值，节省一些GPU周期。</strong></p>
<p><strong>这个像素着色器使用了几个内置的GLSL函数。reflect()函数反射一个向量，在本例中是光向量，平面定义第二个向量上，在本例中是表面法线。因为我们想要光线矢量和反射矢量都指向远离表面，所以我们需要在将其传递到reflect()之前剔除前者。clamp()函数有三个输入。其中两个定义了第三个输入所限定的范围。在大多数GPU上，clamp到0和1之间(对应于HLSL saturate()函数)的特殊情况是快速的，通常是有效的免费的。这就是我们在这里使用它的原因，尽管我们只需要将值clamp为0，因为我们知道它不会超过1。mix()函数也有三个输入，并在其中两个输入之间进行线性插值，在本例中是暖色和高亮色，基于第三个输入的值，即介于0和1之间的混合参数。在HLSL中，这个函数被称为lerp()，表示“线性插值”。最后，normalize()将向量除以其长度，将其缩放为1。</strong></p>
<p><strong>现在让我们看看顶点着色器。我们不会展示它的任何统一定义，因为我们已经看到了一些像素着色器的统一定义的例子，但不同的输入和输出定义值得研究:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918224437.png" class="" title="image-20210918224437">

<p><strong>注意，如前所述，顶点着色器输出匹配像素着色器的不同输入。输入包括指定数据如何在顶点数组中布局的指令。接下来是顶点着色器代码:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918224527.png" class="" title="image-20210918224527">

<p><strong>这些是顶点着色器的常见操作。着色器将表面位置和法线转换到世界空间，并将它们传递给像素着色器用于着色。最后，表面位置被转换到裁剪空间，并传递到gl-position，光栅化器使用的一个特殊的系统定义变量。gl-Position变量是任何顶点着色器都需要输出的变量。</strong></p>
<p><strong>注意，在顶点着色器中法向量不是标准化的。它们不需要被标准化，因为它们在原始网格数据中的长度为1，并且这个应用程序不执行任何操作，例如顶点混合或非均匀缩放，这些操作可能会不均匀地改变它们的长度。模型矩阵可以有一个统一的比例因子，但这将按比例改变所有法线的长度，从而不会导致之前图中右侧所示的问题。</strong></p>
<p><strong>该应用程序使用WebGL API进行各种渲染和着色设置。每个可编程着色器阶段都是单独设置的，然后它们都被绑定到一个程序对象。这里是像素着色器设置代码：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918233123.png" class="" title="image-20210918233123">

<p><strong>注意“碎片着色器”的引用。这个术语被WebGL(以及它所基于的OpenGL)所使用。正如本书前面提到的，虽然“像素着色器”在某些方面不太精确，但它是更常见的用法，我们在本书中遵循。这段代码也是将MAXLIGHTS字符串替换为适当数值的地方。大多数渲染框架执行类似的预编译着色器操作。</strong></p>
<p><strong>有更多的应用程序端代码用于设置制服、初始化顶点数组、清除、绘图等等，您可以在程序中查看这些代码，并可以通过大量API指南进行解释。我们的目标是让大家知道着色器是如何被当作独立的处理器，拥有自己的编程环境。因此，我们的演练到此结束。</strong></p>
<h3 id="Material-Systems-材质系统"><a href="#Material-Systems-材质系统" class="headerlink" title="Material Systems 材质系统"></a>Material Systems 材质系统</h3><p><strong>渲染框架很少只实现一个着色器，就像在我们的简单例子中那样。通常，需要一个专门的系统来处理应用程序使用的各种材质、着色模型和着色器。</strong></p>
<p><strong>正如前面章节所解释的，着色器是GPU可编程着色器阶段之一的程序。因此，它是一个低级的图形API资源，而不是与艺术家直接交互的东西。相反，材质是一个表面视觉外观的艺术家封装。材质有时也描述非视觉方面，如碰撞特性，我们将不再进一步讨论，因为它们超出了本书的范围。</strong></p>
<p><strong>虽然材质是通过着色器实现的，但这并不是简单的一对一对应。在不同的渲染情况下，相同的材质可能使用不同的着色器。一个着色器也可以被多个材质共享。最常见的情况是参数化材料。在最简单的形式中，材质参数化需要两种类型的材料实体:材料模板和材料实例。每个材质模板描述了一类材质，并有一组参数，这些参数可以根据参数类型分配数值、颜色或纹理值。每个材质实例对应于一个材质模板加上一组特定的参数值。一些渲染框架，如Unreal Engine，允许更复杂的层次结构，材质模板从其他模板在多个层次派生。</strong></p>
<p><strong>参数可以在运行时通过向着色程序传递统一的输入来解析，或者在编译时通过在着色程序编译之前替换值来解析。编译时参数的一种常见类型是一个布尔开关，它控制给定材质特性的激活。这可以由艺术家通过材质用户界面的一个复选框设置，或者由材质系统程序设置，例如，在功能的视觉效果可以忽略不计的遥远物体上减少着色器成本。</strong></p>
<p><strong>虽然材质参数可能与材质模型的参数一一对应，但情况并非总是如此。材质可以将给定的着色模型参数的值固定到一个常量，例如表面颜色。另外，一个着色模型参数可以作为一个复杂的操作的结果，采用多个材质参数，以及插值的顶点或纹理值，作为输入。在某些情况下，参数，如表面位置，表面方向，甚至时间也可以考虑到计算。基于表面位置和方向的着色在地形材料中特别常见。例如，高度和表面法线可以用来控制雪的效果，在高海拔水平和几乎水平的表面上混合白色表面颜色。基于时间的着色在动画材质中很常见，比如闪烁的霓虹灯标识。</strong></p>
<p><strong>材质系统最重要的任务之一是将不同的着色器功能划分为不同的元素，并控制它们如何组合。在许多情况下，这种类型的组合是有用的，包括以下情况:</strong></p>
<pre><code>**使用几何处理合成表面着色，如刚性变换，顶点混合，变形，镶嵌细分，实例化和剪切。这些功能是独立变化的:表面着色取决于材质，几何处理取决于网格。因此，可以方便地单独编写它们，并根据需要由材质系统组成。**

**使用诸如像素丢弃和混合等合成操作来合成表面着色。这与移动GPU尤其相关，在那里混合通常是在像素着色器中执行的。通常需要选择这些操作独立于用于表面着色的材质。**

**将用于计算着色模型参数的操作与着色模型本身的计算结合起来。这允许编写着色模型一次实现，并将其与计算着色模型参数的各种不同方法结合使用。**

**组合各自可选择的材质特性，选择逻辑和着色器的其余部分。这样就可以分别编写每个特性的实现。**

**组成着色模型并计算其参数与光源评估:计算clight l在每个光源的着色点。延迟呈现(将在第20章讨论)等技术改变了该组合的结构。在支持多种技术的呈现框架中，这又增加了一层复杂性。**
</code></pre>
<p><strong>如果图形API提供这种类型的着色器代码模块化作为核心特性，那将是很方便的。遗憾的是，不像CPU代码，GPU着色器不允许代码片段的后编译链接。每个着色器阶段的程序被编译为一个单元。着色器阶段之间的分离确实提供了一些有限的模块化，这在某种程度上符合我们列表中的第一项:组成表面着色(通常在像素着色器中执行)与几何处理(通常在其他着色器阶段执行)。但是这种匹配并不完美，因为每个着色器都执行其他操作，其他类型的合成仍然需要处理。考虑到这些限制，材质系统能够实现所有这些组合类型的唯一方法是在源代码级别。这主要涉及字符串操作，如连接和替换，通常通过C风格的预处理指令执行，如#include、#if和#define。</strong></p>
<p><strong>早期的渲染系统有相对较少的着色器变体，并且通常每个都是手工编写的。这有一些好处。例如，每个变体都可以在充分了解最终着色程序的情况下进行优化。然而，随着变量数量的增加，这种方法很快变得不切实际。当考虑到所有不同的部分和选项时，可能的不同着色变体的数量是巨大的。这就是模块化和可组合性如此重要的原因。</strong></p>
<p><strong>当设计处理着色变体的系统时，需要解决的第一个问题是，不同选项之间的选择是在运行时通过动态分支执行，还是在编译时通过条件预处理执行。在较旧的硬件上，动态分支通常是不可能的，或者非常慢，因此不能选择运行时。然后在编译时处理所有变体，包括不同light类型计数的所有可能组合。</strong></p>
<p><strong>相比之下，当前GPU处理动态分支相当好，特别是当分支对draw调用中的所有像素行为相同时。如今，许多功能的变化，比如灯的数量，都是在运行时处理的。然而，为着色器添加大量的功能变化会产生不同的成本:增加寄存器数量和相应的占用减少，从而降低性能。</strong></p>
<p><strong>有关更多细节，请参阅18.4.5节。因此，编译时变化仍然很有价值。它避免了包含永远不会被执行的复杂逻辑。</strong></p>
<p><strong>作为一个例子，让我们想象一个支持三种不同类型光源的应用程序。有两种光类型很简单:点光源和定向光源。第三种类型是广义聚光灯，它支持表格照明模式和其他复杂的功能，需要大量的着色器代码来实现。然而，广义聚光灯的使用相对较少，应用程序中只有不到5%的灯是这种类型的。在过去，一个单独的着色器变体将被编译为三种光类型的每一个可能的计数组合，以避免动态分支。虽然这在今天是不需要的，但编译两个独立的变体仍然是有益的，一个用于通用聚光灯的计数等于或大于1的情况，一个用于这种灯的计数正好为0的情况。由于其代码更简单，第二种变体(最常用的)可能占用寄存器更低，因此性能更高。</strong></p>
<p><strong>现代材质系统同时使用运行时和编译时的材质变化。即使全部的负担不再只在编译时处理，总体的复杂性和变化的数量不断增加，所以大量的着色器变体仍然需要编译。例如，在游戏《Destiny: the Taken King》的某些区域中，在单个帧中使用了超过9000种编译过的着色器变体。可能的变化的数量可以更大，例如，Unity渲染系统的着色器有接近1000亿个可能的变化。只有实际使用的变体才会被编译，但是着色器编译系统必须重新设计以处理大量可能的变体。</strong></p>
<p><strong>材料系统设计师采用不同的策略来实现这些设计目标。尽管这些策略有时被描述为相互排斥的系统架构，但这些策略可以——而且通常是在同一个系统中组合的。这些策略包括:</strong></p>
<pre><code>**代码重用：在共享文件中实现函数，使用#include预处理器指令从任何需要它们的着色器访问这些函数。**

**减法：一个着色器，通常被称为一个u¨bershader或supershader，它聚集了大量的功能，使用编译时预处理器条件和动态分支的组合来删除不使用的部分，并在互斥的选项之间切换。**

**加法：各种功能被定义为具有输入和输出连接器的节点，这些节点被组合在一起。这类似于代码重用策略，但是更加结构化。节点的组成可以通过文本或可视化图形编辑器来完成。后者旨在使非工程师(如技术艺术家)更容易创建新的材料模板。通常只有部分着色器是可访问的可视化图形创作。例如，在Unreal Engine中，图形编辑器只能影响着色模型输入的计算。**
</code></pre>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918234943.png" class="" title="image-20210918234943">

<p>虚幻引擎材质编辑器。注意节点图右侧的高节点。这个节点的输入连接器对应于渲染引擎使用的各种着色输入，包括所有着色模型参数。(Material sample courtesy of Epic Games。)</p>
<pre><code>**基于模板的接口定义，只要符合该接口，就可以将不同的实现插入其中。这比添加策略更正式一点，通常用于更大的功能块。这种界面的一个常见例子是着色模型参数的计算和着色模型本身的计算之间的分离。Unreal Engine有不同的“材质域”，包括计算着色模型参数的表面域和计算调制clight的功能域对于给定的光源。类似的“表面着色器”结构也存在于Unity中。注意，延迟着色技术(在第20章中讨论)强制执行一个类似的结构，G缓冲区作为接口。**
</code></pre>
<p><strong>关于更具体的例子，WebGL Insights中有几章讨论了各种引擎如何控制它们的着色器管线。除了合成，现代材质系统还有其他几个重要的设计考虑因素，例如需要以最小的复制着色器代码来支持多个平台。这包括考虑到平台、着色语言和API之间的性能和能力差异的功能变化。命运着色器系统是这类问题的一个典型解决方案。它使用专有的预处理器层，采用自定义着色语言方言编写的着色器。这允许编写平台无关的材质，并自动翻译到不同的着色语言和实现。Unreal Engine和Unity也有类似的系统。</strong></p>
<p><strong>材质系统也需要保证良好的性能。除了特殊的材质变体编译外，材质系统还可以执行一些其他常见的优化。命运着色器系统和Unreal Engine自动检测计算是常数的绘制调用(如暖色和冷色计算在早期的实现示例)，并将其移出着色器。另一个例子是《Destiny》中使用的范围系统，用于区分以不同频率更新的常量(例如，每帧更新一次，每灯更新一次，每对象更新一次)，并在适当的时间更新每一组常量以减少API开销。</strong></p>
<p><strong>正如我们所看到的，实现着色方程是一个决定哪些部分可以简化的问题，计算各种表达式的频率，以及用户如何能够修改和控制外观。渲染管线的最终输出是颜色和混合值。关于反锯齿、透明度和图像显示的其余部分详细介绍了这些值是如何组合和修改的。</strong></p>
<h2 id="Aliasing-and-Antialiasing-走样和抗锯齿"><a href="#Aliasing-and-Antialiasing-走样和抗锯齿" class="headerlink" title="Aliasing and Antialiasing 走样和抗锯齿"></a>Aliasing and Antialiasing 走样和抗锯齿</h2><p><strong>想象一个大的黑色三角形在白色背景上缓慢移动。当一个屏幕网格单元格被三角形覆盖时，表示该单元格的像素值应该平滑地降低强度。在所有类型的基本渲染器中，通常发生的情况是，当网格单元格的中心被覆盖时，像素颜色立即从白色变成黑色。标准GPU渲染也不例外。如图最左边一列所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919154057.png" class="" title="image-20210919154057">

<p>上面一行显示了三个图像，其中一个三角形、一条直线和一些点具有不同的反锯齿级别。下排图像是上排图像的放大倍数。最左边的一列每个像素只使用一个样本，这意味着没有使用反锯齿。中间一列的图像使用每像素4个样本(在网格模式中)，右边一列使用每像素8个样本(在4 × 4的棋盘中，取样了一半的方块)。</p>
<p><strong>三角形在像素中要么在，要么不在。画出的线也有类似的问题。由于这个原因，边缘看起来呈锯齿状，所以这种视觉人造物被称为“锯齿”，当动画时，它会变成“爬虫”。更正式地说，这个问题被称为走样，努力避免它被称为反走样技术。</strong></p>
<p><strong>采样理论和数字滤波的课题大到足以出一本书。由于这是绘制的一个关键领域，本文将介绍采样和滤波的基本理论。然后，我们将重点关注当前可以实时做些什么来缓解走样现象。</strong></p>
<h3 id="Sampling-and-Filtering-Theory-采样滤波理论"><a href="#Sampling-and-Filtering-Theory-采样滤波理论" class="headerlink" title="Sampling and Filtering Theory 采样滤波理论"></a>Sampling and Filtering Theory 采样滤波理论</h3><p><strong>渲染图像的过程本质上是一个采样任务。这是因为图像的生成是对三维场景进行采样的过程，以获得图像(一个离散像素数组)中每个像素的颜色值。为了使用纹理映射(第6章)，像素必须重新采样，以在不同的条件下获得良好的结果。为了在动画中生成图像序列，动画通常以均匀的时间间隔进行采样。本节介绍采样、重构和滤波的主题。为了简单起见，大多数材质都会以一维形式呈现。这些概念也可以自然地扩展到二维，因此可以在处理二维图像时使用。</strong></p>
<p><strong>下图显示了连续信号是如何在均匀间隔采样的，即离散化。这个采样过程的目标是用数字表示信息。这样做，信息量就减少了。然而，采样后的信号需要进行重构以恢复原始信号。这是通过对采样信号进行滤波来实现的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919155519.png" class="" title="image-20210919155519">

<p>对连续信号(左)进行采样(中)，然后通过重构(右)恢复原始信号。</p>
<p><strong>无论何时进行采样，都可能发生走样。这是一个不必要的人工制品，我们需要减小走样，以生成令人满意的图像。在老西部片中看到的一个走样的经典例子是电影摄像机拍摄的一个旋转的马车轮子。因为辐条的移动速度比相机记录的图像快得多，轮子可能看起来在缓慢地旋转(向后或向前)，甚至可能看起来根本就不旋转。如图所示。由于车轮的图像是在一系列的时间步骤中拍摄的，这种效果被称为时间走样。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919155940.png" class="" title="image-20210919155940">

<p>上面一行显示了一个旋转的轮子(原始信号)。第二行是不充分的采样，使它似乎在相反的方向移动。这是一个由于采样率过低而造成走样的例子。在第三行，采样率恰好是每转两个样本，我们不能确定轮子在哪个方向旋转。这是奈奎斯特极限。在第4行，采样率高于每转2个样本，我们突然可以看到轮子朝着正确的方向旋转。</p>
<p><strong>在计算机图形中，走样的常见例子有光栅化线或三角形边缘的“锯齿”，被称为“萤火虫”的闪烁的高光，以及当带有格子图案的纹理被缩小时(章节6.2.2)。</strong></p>
<p><strong>当以过低的频率采样时，就会发生走样。采样后的信号似乎是比原始信号频率更低的信号。下图所示。对于要适当采样的信号(这样就可以从样本中重构出原始信号)，即采样频率必须大于被采样信号的最大频率的两倍。这通常被称为采样定理，采样频率被称为奈奎斯特速率或奈奎斯特极限，以瑞典科学家哈里·奈奎斯特(1889-1976)命名，他在1928年发现了这一理论。奈奎斯特极限也上图所示。这个定理使用了“最大频率”这个术语，这意味着信号必须是有带宽限制的，也就是说没有任何频率超过某个限制。换句话说，相对于相邻样本的间隔，信号必须足够平滑。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919160619.png" class="" title="image-20210919160619">

<p>蓝实线为原始信号，红圆为等间距采样点，绿虚线为重构信号。上面的数字表明抽样率过低。因此，重构信号的频率较低，即原始信号走样。下面显示的采样率恰好是原始信号频率的两倍，重构信号在这里是一条水平线。可以证明，只要采样率稍微提高一点，就有可能实现完美的重构。</p>
<p><strong>当使用点样本渲染时，三维场景通常不会受到带宽限制。三角形边缘、着色边界和其他现象产生的信号是不连续的，因此产生的频率是无限的。此外，无论采样包裹得多么紧密，对象仍然可能足够小，以至于根本无法进行采样。因此，在使用点采样渲染场景时，完全避免走样问题是不可能的，我们几乎总是使用点采样。然而，有时是可以知道一个信号是频带有限的。一个例子是当一个纹理被应用到一个表面。与像素的采样率相比，可以计算纹理采样的频率。如果该频率低于奈奎斯特极限，则不需要采取任何特殊行动来正确采样纹理。如果频率过高，则使用各种算法对纹理进行带限(章节6.2.2)。</strong></p>
<h4 id="Reconstruction-重构"><a href="#Reconstruction-重构" class="headerlink" title="Reconstruction 重构"></a>Reconstruction 重构</h4><p><strong>给定一个带限采样信号，我们现在将讨论如何从采样信号重构原始信号。要做到这一点，必须使用过滤器。三种常用的过滤器如图所示。请注意，滤波器的面积应该始终为1，否则重建信号可能会出现增大或缩小。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919161515.png" class="" title="image-20210919161515">

<p>左上方显示框式过滤器，右上方显示帐篷式过滤器。下面显示的是sinc滤波器(在这里被 clamp在x轴上)。</p>
<p><strong>在下图中，盒状滤波器(最近邻)被用来重构采样信号。这是最糟糕的滤波器使用，因为产生的信号是一个不连续的楼梯情况。然而，由于它的简单性，它经常被用于计算机图形学。从图中可以看出，盒子过滤器被放置在每个样本点上，然后缩放，使过滤器的最上面的点与样本点重合。所有这些缩放和转换的方框函数的和就是在右边显示的重构信号。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919161621.png" class="" title="image-20210919161621">

<p>采样信号(左)用盒状滤波器重构。这是通过将盒子过滤器放置在每个样本点上，并在y方向上缩放它，使过滤器的高度与样本点相同。求和就是重构信号(右)。</p>
<p><strong>盒式过滤器可更换为任何其他过滤器。在下图中，帐篷滤波器，也称为三角形滤波器，是用来重构一个采样信号。请注意,这滤波器实现了相邻采样点之间的线性插值，因此比盒状滤波器更好，因为现在重构信号是连续的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919161812.png" class="" title="image-20210919161812">

<p>采样后的信号(左)用帐篷滤波器重构。重建后的信号显示在右边。</p>
<p><strong>但帐篷滤波器重构信号的平滑性较差;在样本点有突然的斜率变化。这与帐篷过滤器并不是一个完美的重建过滤器有关。为了得到完美的重构，必须使用理想的低通滤波器。信号的频率分量是一个正弦波:sin(2πf)，其中f是该分量的频率。鉴于此，低通滤波器去除所有频率高于滤波器定义的特定频率的频率成分。直观上，低通滤波器去除信号的尖锐特征，即滤镜会使它模糊。理想的低通滤波器是sinc滤波器:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919162022.png" class="" title="image-20210919162022">

<p><strong>傅里叶分析理论解释了为什么sinc滤波器是理想的低通滤波器。简单地说，理想的低通滤波器是频域的盒状滤波器，当它与信号相乘时，它会去除滤波器宽度以上的所有频率。将盒子滤波器从频域变换到空间域得到一个sinc函数。同时，乘法运算被转换成卷积函数，这就是我们在这一节中使用的，没有实际描述这个术语。</strong></p>
<p><strong>使用sinc滤波器重构信号得到一个更平滑的结果，下图所示。采样过程会在信号中引入高频成分(突变)，而低通滤波器的任务就是去除这些成分。事实上，sinc滤波器消除了所有频率高于采样率1/2的正弦波。如上式所示，sinc函数是采样频率为1.0时的完美重构滤波器。（采样的最大频率信号必须小于1/2)。更一般地，假设采样频率是fs，即相邻样本的间隔为1/fs．对于这种情况，完美重构滤波器为sinc(fsX)，并消除所有高于fs／2的频率.这在重新采样信号时很有用(下一节)。然而，sinc滤波器的宽度是无限的，在某些区域是负的，所以它在实际中很少有用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919162237.png" class="" title="image-20210919162237">

<p>左边是采样信号和重构信号。在右侧，重构信号以两倍的采样率进行了重采样，即进行了放大。</p>
<p><strong>在低质量的盒子和帐篷过滤器和不切实际的sinc过滤器之间有一个有用的中间地带。最广泛使用的滤波函数介于这些极端之间。所有这些滤波函数都有一些近似的sinc函数，但它们影响的像素有一个限制。最接近sinc函数的滤波器在其定义域的一部分有负值。对于负滤波器值不适用实际的应用，通常使用无负瓣的滤波器(通常称为高斯滤波器，因为它们要么来自于高斯曲线，要么类似于高斯曲线)。第12.1节更详细地讨论了过滤器函数及其使用。</strong></p>
<p><strong>在使用任何滤波器后，得到一个连续的信号。然而，在计算机图形学中，我们不能直接显示连续信号，但我们可以使用它们将连续信号重新采样到另一个大小，即要么放大信号，要么缩小信号。下面将讨论这个话题。</strong></p>
<h4 id="Resampling-重采样"><a href="#Resampling-重采样" class="headerlink" title="Resampling 重采样"></a>Resampling 重采样</h4><p><strong>重采样用于放大或缩小采样信号。假设原始采样点位于整数坐标(0,1,2，…)，样本之间的间隔是单位的。此外，假设重新采样后，我们希望新样本点在样本间间隔为a的情况下均匀定位。对于a&gt; 1，缩小(下采样)发生，而对于a&lt; 1，放大(上采样)发生。</strong></p>
<p><strong>放大是两种情况中比较简单的一种，所以让我们从放大开始。假设采样信号如前一节所示被重构。直观地说，由于信号现在是完美的重建和连续的，所有需要的是在期望的间隔重新采样重建信号。上图所示。</strong></p>
<p><strong>然而，当最小化发生时，这种技术就不起作用了。原始信号的频率过高，使采样率无法避免走样。取而代之的是，使用sinc(x/a)的滤波器，用来从采样的信号中创建一个连续的信号。在此之后，可以按所需的间隔进行重新采样。换句话说，通过使用sinc(x/a)作为滤波器，低通滤波器的宽度是增加的，因此更多的信号的高频内容被删除。如图所示，滤波器宽度(单个sinc的)增加了一倍，从而使重采样率降低到原始采样率的一半。与数字图像相关，这类似于先模糊它(去除高频)，然后以较低的分辨率重新采样图像。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919163248.png" class="" title="image-20210919163248">

<p>左边是采样信号和重构信号。在右边，为了使样本之间的间隔加倍，滤光片的宽度加倍，即发生了缩小。</p>
<h3 id="Screen-Based-Antialiasing-基于屏幕的抗锯齿"><a href="#Screen-Based-Antialiasing-基于屏幕的抗锯齿" class="headerlink" title="Screen-Based Antialiasing 基于屏幕的抗锯齿"></a>Screen-Based Antialiasing 基于屏幕的抗锯齿</h3><p><strong>如果没有很好的采样和过滤，三角形的边缘会产生明显的伪影。阴影边界、高光和其他颜色变化迅速的现象也会导致类似的问题。本节讨论的算法有助于提高这些情况下的渲染质量。它们有一个共同的主线，即它们是基于屏幕的。它们只对管线的输出样本进行操作。没有一种最佳的反锯齿技术，因为每种技术在质量、捕捉清晰细节或其他现象的能力、移动过程中的外观、内存成本、GPU要求和速度方面都有不同的优势。</strong></p>
<p><strong>在黑色三角形例子中，有一个问题是采样率低。一个样本是在每个像素的网格单元的中心，所以这是最多的关于单元格的已知信息是，中心是否被三角形覆盖。通过在每个屏幕网格单元格中使用更多的样本并以某种方式混合这些样本，可以计算出更好的像素颜色。如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919164009.png" class="" title="image-20210919164009">

<p>在左边，一个红色的三角形被渲染为像素中心的一个样本。由于三角形没有覆盖样本，像素将是白色的，即使像素的大部分被红色三角形覆盖。在右边，每个像素使用4个样本，如图所示，其中两个样本被红色三角形覆盖，结果是粉色像素颜色。</p>
<p><strong>基于屏幕的反走样方案的一般策略是对屏幕使用一个采样模式，然后对样本进行加权和求和，以产生一个像素颜色，p:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919164442.png" class="" title="image-20210919164442">

<p><strong>其中n是一个像素的采样数。函数c(i, x, y)是样本颜色，wi是一个权重，在[0,1]范围内，该样本将对整个像素颜色做出贡献。样品位置是基于它在序列中的哪个样品1，…， n，并且该函数还可选地使用像素位置(x, y)的整数部分。换句话说，对于每个样本，在屏幕网格上采集的样本是不同的，而且可选地采样模式可以因像素而异。在实时渲染系统(以及大多数其他渲染系统)中，样本通常是点样本。所以，函数c可以被认为是两个函数。首先，函数f(i, n)检索浮点数(xf，yf )在屏幕上需要采样的位置。然后对屏幕上的这个位置进行采样，即此时的颜色就会恢复。选择采样方案，并配置渲染管线来计算特定亚像素位置的采样，通常基于每帧(或每应用程序)设置。</strong></p>
<p><strong>反采样的另一个变量是wi，即每个样本的权重。这些权重之和为1。在实时绘制系统中使用的大多数方法都给它们的样本一个统一的权重，例如。wi＝1/n．图形硬件的默认模式是在像素中心的单个样本，这是上面反采样方程的最简单的情况。只有一项，这一项的权重为1，采样函数f总是返回被采样像素的中心。</strong></p>
<p><strong>计算每个像素一个以上完整样本的抗锯齿算法被称为超采样(或过采样)方法。概念上最简单的全场景反走样(FSAA)，也被称为“超采样反走样”(SSAA)，渲染然后过滤邻近的样本来创建图像。例如，需要1280 × 1024像素的图像。如果在屏幕外渲染2560×2048的图像，然后对屏幕上的每个2×2像素区域求平均值，那么将生成每个像素有四个样本的所需图像，并使用框过滤器进行过滤。注意，这对应于下图中的2 × 2网格采样。这种方法代价很高，因为所有的子样本必须完全着色和填充，每个样本必须有z缓冲深度。FSAA的主要优点是简单。这种方法的其他低质量版本只在一个屏幕轴上以两倍的速率采样，因此称为1 × 2或2 × 1超采样。通常，为简便起见，使用2的幂次分辨率和盒状滤波器。NVIDIA的动态超分辨率特性是一种更精细的超采样形式，场景以更高的分辨率渲染，使用13个样本的高斯滤波器生成显示图像。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919165844.png" class="" title="image-20210919165844">

<p>比较了一些像素采样方案，每个像素从最少到最多的采样。Quincunx共享拐角样本，并将其中心样本权重为像素最终颜色的一半。旋转的2 × 2网格比笔直的2 × 2网格捕捉到的接近水平边缘的灰度级别更多。类似地，尽管使用了更少的样本，8 rooks模式比4 × 4网格捕获了更多的灰色层次。</p>
<p><strong>一种与超采样相关的采样方法是基于累积缓冲器的思想。这种方法不是使用一个大的屏幕外缓冲器，而是使用一个与所需图像具有相同分辨率的缓冲器，但每个通道具有更多的彩色位元。为了获得一个场景的2 × 2采样，将生成4幅图像，并根据需要将视图在屏幕x或y方向上移动半个像素。生成的每个图像都是基于网格单元格内不同的样本位置。每帧需要重新渲染几次场景，并将结果复制到屏幕上，这使得这种算法对实时渲染系统来说成本很高。当性能不是关键的时候，它对于生成高质量的图像很有用，因为任意数量的样本放置在任何地方，每个像素都可以使用。累积缓冲器过去是一个单独的硬件。OpenGL API直接支持它，但在3.0版本中已弃用。在现代GPU上，通过使用更高精度的颜色格式作为输出缓冲区，可以在像素着色器中实现累加缓冲区的概念。</strong></p>
<p><strong>当物体边缘、高光和阴影等出现突然的颜色变化时，需要额外的样本。阴影通常可以做得更柔和，高光更平滑，以避免走样。特定对象类型可以在尺寸上增加，如电线，这样它们就可以保证在其长度上的每个位置至少覆盖一个像素。物体边缘的走样仍然是一个主要的采样问题。可以使用分析方法，在绘制过程中检测物体边缘，并考虑到它们的影响，但这些方法通常比简单地获取更多样本更昂贵，更不可靠。然而，GPU特性，如保守光栅化和光栅化顺序视图，开辟了新的可能性。</strong></p>
<p><strong>超采样和累积缓冲等技术通过生成完全指定的样本，分别计算着色和深度。总体增益相对较低，成本较高，因为每个样本必须通过一个像素着色器。</strong></p>
<p><strong>多重采样抗锯齿(MSAA)通过每像素计算一次表面的着色，并在样本之间共享这个结果，减少了高计算成本。像素每个片段可能有四个(x, y)样本位置，每个位置都有自己的位置颜色和z深度，但是像素着色器只对每个应用到像素的对象碎片进行一次评估。如果碎片覆盖了所有的MSAA位置样本，则在像素的中心评估着色样本。如果碎片覆盖的位置样本更少，则着色样本的位置可以移动，以更好地表示覆盖的位置。这样做可以避免纹理边缘的着色采样。这种位置调整被称为质心采样或质心插值，如果启用，则由GPU自动完成。质心采样避免了三角问题，但会导致导数计算返回不正确的值。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919171043.png" class="" title="image-20210919171043">

<p>在中间，一个像素与两个物体重叠。红色的物体覆盖了三个样本，蓝色的只有一个。像素着色器评估位置显示为绿色。因为红色三角形覆盖了像素的中心，这个位置用于着色器评估。蓝色物体的像素着色器在样本的位置进行评估。对于MSAA，单独的颜色和深度存储在所有四个位置。在右侧显示了EQAA的2f4x模式。这四个示例现在有四个ID值，索引了存储的两种颜色和深度的表。</p>
<p><strong>MSAA比纯超采样方案更快，因为碎片只有一次着色。它专注于以更高的速率采样碎片的像素覆盖率，并共享计算出的着色。通过进一步分离采样和覆盖可以节省更多的内存，这反过来可以使抗锯齿速度更快——触及的内存越少，渲染就越快。NVIDIA在2006年引入了覆盖采样抗锯齿(CSAA)， AMD紧随其后，采用了增强质量抗锯齿(EQAA)。这些技术的工作原理是仅以较高的采样率存储片段的覆盖率。例如，EQAA的“2f4x”模式存储了两个颜色和深度值，在四个样本位置之间共享。颜色和深度不再存储在特定的位置，而是保存在一个表中。然后，四个样本中的每一个只需要一个位来指定两个存储值中的哪个与它的位置相关联。如上图所示。覆盖样本指定每个片段对最终像素颜色的贡献。如果超过存储的颜色数量，存储的颜色将被收回，其样品被标记为未知。这些样品对最终的颜色没有影响。对于大多数场景来说，相对较少的像素包含三个或更多的可见不透明碎片，这些碎片在着色上完全不同，因此该方案在实践中表现良好。为了获得最高质量，《极限竞速2》采用了4× MSAA，尽管《极限竞速2》具有性能优势。</strong></p>
<p><strong>一旦所有的几何图形都被渲染到一个多样本缓冲区，然后执行一个解析操作。这个程序对样本颜色进行平均，以确定像素的颜色。值得注意的是，当使用具有高动态范围颜色值的多次采样时，可能会出现问题。在这种情况下，为了避免伪影，通常需要在解析之前对值进行色调映射。这可能会很昂贵，所以可以使用色调映射函数或其他方法的更简单的近似方法。</strong></p>
<p><strong>默认情况下，MSAA是用方框过滤器解析的。2007年，ATI引入了自定义滤波器反锯齿(CFAA)，具有使用窄和宽帐篷滤波器的能力，可以略微扩展到其他像素单元。这种模式已经被EQAA支持所取代。在现代GPU上，像素或计算着色器可以访问MSAA样本，并使用所需的任何重建过滤器，包括从周围像素的样本中取样的过滤器。更宽的滤波器可以减少走样，尽管会损失清晰的细节。Pettineo发现滤波器宽度为2或3像素的三次平滑步长和B样条滤波器总体上得到的结果最好。这也有性能成本，因为即使模拟默认的框过滤器解析也会用自定义着色器花费更长的时间，更宽的过滤器内核意味着增加样本访问成本。</strong></p>
<p><strong>NVIDIA内置的TXAA支持类似地使用了比单个像素更宽的区域更好的重建过滤器，以提供更好的结果。它和较新的MFAA(多帧反锯齿)方案都使用时间反锯齿(TAA)，这是一种使用前一帧的结果来改善图像的一般技术。在某种程度上，这些技术之所以成为可能，是因为程序员可以设置每帧的MSAA采样模式。这样的技术可以解决像纺车轮这样的走样问题，还可以提高边缘绘制的质量。</strong></p>
<p><strong>想象一下，通过“手动”生成一系列图像来执行采样模式，在这些图像中，每个渲染使用采样像素中的不同位置。这种偏移是通过在投影矩阵上附加一个微小的平移来完成的。生成的图像越多，并将它们平均在一起，结果就越好。这种利用多偏移图像的概念被用于时间反走样算法。生成单个图像，可能使用MSAA或其他方法，并将之前的图像混合在一起。通常只使用2到4帧。旧图像的权重可能会呈指数级降低，尽管如果观看者和场景没有移动，这可能会产生帧闪烁的效果，所以通常最后一帧和当前帧的权重是相等的。每一帧的样本在不同的亚像素位置，这些样本的加权和给出了比单一帧更好的边缘覆盖率评估。因此，一个系统使用最新的两帧平均在一起可以给出一个更好的结果。每帧都不需要额外的样本，这就是这种方法如此吸引人的原因。甚至可以使用时间采样来生成低分辨率的图像，并将其放大到显示器的分辨率。此外，光照方法或其他需要很多样本才能得到好的结果的技术可以在每帧中使用较少的样本，因为结果将在几帧中混合。</strong></p>
<p><strong>在不增加采样代价的情况下为静态场景提供了反走样，但这种算法在用于时间反走样时存在一些问题。如果帧的权重不相等，静态场景中的物体会显示出微光。快速移动的物体或相机的快速移动可能导致重影，即由于先前帧的贡献而在物体后面留下的痕迹。重影的一种解决方案是只对缓慢移动的物体执行这种抗锯齿。另一个重要的方法是使用重投影(章节12.2)来更好地关联先前帧和当前帧的对象。在这种方案中，对象生成的运动矢量存储在一个单独的“速度缓冲区”中(第12.5节)。这些向量用于将前一帧与当前帧关联起来，即从当前像素位置减去向量，以找到该物体表面位置的前一帧的颜色像素。在当前框架中不太可能是表面一部分的样本被丢弃。由于时间反走样算法不需要额外的样本，因此需要的额外工作相对较少，近年来这类算法受到了广泛的关注和采用。这种关注的部分原因是延迟渲染技术(章节20.1)与MSAA和其他多次采样支持不兼容。方法各不相同，根据应用程序的内容和目标，已经开发了一系列避免工件和提高质量的技术。例如，Wihlidal的报告展示了应用于棋盘取样模式的EQAA、时间反锯齿和各种过滤技术如何结合在一起，在降低像素着色器调用数量的同时保持质量。iglesias - gutian等人总结了之前的工作，并提出了使用像素历史和预测来最小化滤波伪影的方案。Patney等人扩展了Karis和Lottes在Unreal Engine 4实现的TAA工作，用于虚拟现实应用程序，增加了可变大小的采样以及眼动补偿(章节21.3.2)。</strong></p>
<h4 id="Sampling-Patterns-采样模式"><a href="#Sampling-Patterns-采样模式" class="headerlink" title="Sampling Patterns 采样模式"></a>Sampling Patterns 采样模式</h4><p><strong>有效的采样模式是减少走样、时间和其他方面的关键因素。Naiman指出，人类最容易受到近水平和近垂直边缘的走样干扰。坡度接近45度的边缘是下一个最令人不安的。旋转网格超采样(RGSS)使用一个旋转的正方形模式，在像素内提供更多的垂直和水平分辨率。</strong></p>
<p><strong>RGSS模式是拉丁超立方或n -rooks抽样的一种形式，n个样本放置在n×n网格中，每行和每列都有一个样本。在RGSS中，4个样本分别位于4 × 4亚像素网格的一行和一列。与常规的2 × 2采样模式相比，这种模式特别适合于捕捉接近水平和垂直的边缘，因为常规的2 × 2抽样模式的边缘可能覆盖偶数个样本，因此提供的有效层次更少。</strong></p>
<p><strong>N-rooks是创建良好采样模式的开始，但它还不够。例如，样本可能都位于亚像素网格的对角线上，因此对于与这个对角线几乎平行的边，结果很差。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919173911.png" class="" title="image-20210919173911">

<p>N-rooks采样。左边是一个合法的N-rooks模式，但它在捕捉沿其直线对角线的三角形边时表现很差，因为当这个三角形移动时，所有的样本位置要么在三角形内部，要么在三角形外部。右边的图案可以更有效地捕捉这条边和其他边。</p>
<p><strong>为了更好的采样，我们希望避免两个样本挨得太近。我们还需要均匀分布，将样本均匀分布在区域内。为了形成这样的模式，将分层采样技术(如拉丁超立方抽样)与抖动、Halton序列和泊松盘采样等其他方法相结合。</strong></p>
<p><strong>在实践中，GPU制造商通常将这样的采样模式硬线连接到他们的硬件中，以进行多次采样反走样。下图显示了实践中使用的一些MSAA模式。对于时间反走样，覆盖模式是程序员想要的，因为样本位置可以在每帧中改变。例如，Karis发现一个基本的Halton序列比GPU提供的任何MSAA模式都要好。Halton序列产生的样本在空间上看起来是随机的，但差异很小，即它们在空间上分布很好，没有一个是集群的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919174117.png" class="" title="image-20210919174117">

<p>AMD和NVIDIA图形加速器的MSAA采样模式。绿色的正方形是着色样本的位置，红色的正方形是计算和保存的位置样本。从左到右:2×， 4×， 6× (AMD)， 8× (NVIDIA)采样。(由D3D FSAA查看器生成。)</p>
<p><strong>虽然亚像素网格模式可以更好地逼近每个三角形如何覆盖网格单元，但它并不理想。场景可以由任意物体构成屏幕上很小，意味着没有采样率可以完美地捕捉它们。如果这些微小的物体或特征形成一个图案，以恒定的间隔进行采样可以产生莫尔纹和其他干涉图案。在超抽样中使用的网格图案特别容易产生走样。</strong></p>
<p><strong>一种解决方案是使用随机采样，它提供了一个更随机的模式。如上图所示的模式当然符合条件。想象一下，在远处有一个细齿梳子，每个像素上覆盖着几颗齿。一个规则的模式可能会出现严重的伪影，因为采样模式进入和与齿频率的相位不一致。有一个不太有序的抽样模式可以打破这些模式。随机化倾向于用噪声替代重复的走样效果，而人类视觉系统对噪声的容忍度要高得多。结构更少的模式会有所帮助，但当像素重复时仍然会出现走样。一种解决方案是在每个像素上使用不同的采样模式，或者随时间改变每个采样位置。交错采样和索引采样，交错，即集合中的每个像素都有不同的采样模式，在过去的几十年里偶尔在硬件中得到支持。例如，ATI的SMOOTHVISION允许每像素最多16个样本，最多16个不同的用户自定义采样模式，可以混合在重复的模式中(例如，在4 × 4像素的贴图中)。Molnar以及Keller和Heidrich发现，当对每个像素使用相同的模式时，使用交错随机采样可以最小化产生的走样伪影。</strong></p>
<p><strong>其他一些GPU支持的算法值得注意。一个让样本影响一个以上像素的实时抗锯齿方案是NVIDIA较早的Quincunx方法。“Quincunx（五角形）”是指五个物体的排列，四个在一个正方形中，第五个在中心，例如六个骰子上的五个点的图案。Quintunx多重采样反走样使用这个模式，将四个外部样本放在像素的角落。参见下图。每个角落的样本值分布到它的四个相邻像素。中心样本的权重为12，角落样本的权重为18，而不是像大多数其他实时方案那样对每个样本平均加权。由于这种共享，平均每个像素只需要两个样本，结果大大优于双样本FSAA方法。这个模式近似于一个二维的帐篷式过滤器，正如上一节所讨论的，它优于盒式过滤器。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919165844.png" class="" title="image-20210919165844">

<p><strong>五次采样也可以应用于时间反走样，每像素使用一个样本。每一帧在每个轴上与前一帧偏移半像素，偏移方向在帧之间交替。前一帧提供像素角样本，使用双线性插值快速计算每个像素的贡献。结果被当前帧平均。每个帧的相同权重意味着静态视图中没有闪烁的伪影。对齐移动对象的问题仍然存在，但方案本身易于编码，并且在每帧每个像素只使用一个样本的情况下提供了更好的外观。</strong></p>
<p><strong>当在单一帧中使用时，Quincunx通过在像素边界共享样本，只有两个样本的成本很低。RGSS模式更擅长于捕捉更多的近水平和垂直边缘的梯度。最初为移动平台开发FLIPQUAD模式结合了这两种理想的功能。它的优点是每像素成本仅为两个样本，质量与RGSS(每像素成本4个样本)相似。这种采样模式如下图所示。Hasselgren等人研究了其他利用样本共享的廉价采样模式。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919175533.png" class="" title="image-20210919175533">

<p>左边显示了RGSS采样模式。这需要每像素4个样本。通过将这些位置移到像素边缘，可以跨边缘实现样本共享。然而，为了解决这个问题，每个其他像素必须有一个反射的样本模式，如图所示。生成的样本模式称为FLIPQUAD，每像素需要两个样本。</p>
<p><strong>像Quincunx一样，双样本FLIPQUAD模式也可以用于时间抗锯齿和扩展到两帧。Drobot在他的混合重建抗锯齿(HRAA)工作中解决了哪一个双样本模式是最好的问题。他探索了不同的时间反锯齿采样模式，发现FLIPQUAD模式是五种测试中最好的。棋盘图案也可以用于时间抗锯齿。El Mansouri讨论了使用双样本MSAA来创建棋盘渲染，以减少着色器成本，同时解决走样问题。Jimenez使用了SMAA、时间反走样和各种其他技术来提供一种解决方案，在这种方案中，反走样质量可以根据渲染引擎负载而改变。Carpentier和Ishiyama对边缘进行采样，将采样网格旋转45◦．他们将这种时间反走样方案与FXAA(稍后讨论)相结合，以在更高分辨率的显示器上有效渲染。</strong></p>
<h4 id="Morphological-Methods-形态学方法"><a href="#Morphological-Methods-形态学方法" class="headerlink" title="Morphological Methods 形态学方法"></a>Morphological Methods 形态学方法</h4><p><strong>走样通常是由边缘造成的，例如由几何形状、锐利的阴影或明亮的高光形成的边缘。利用走样具有与之相关的结构的知识，可以得到更好的反走样结果。2009年，Reshetov提出了一种沿着这些方向的算法，称之为形态反锯齿(MLAA)。“Morpho- logical”是指“与结构或形状有关的”。“早在1983年，Bloomenthal就在这一领域做过早期工作。Reshetov的论文重新激发了对多重采样方法替代方法的研究，强调了搜索和重建边缘。</strong></p>
<p><strong>这种形式的抗锯齿是作为后处理执行的。也就是说，呈现是按照通常的方式完成的，然后将结果提供给生成平滑的结果。自2009年以来，已经开发了一系列广泛的技术。那些依赖于额外缓冲区，如深度和法线可以提供更好的结果，如亚像素重建反锯齿(SRAA)，但随后仅适用于几何边缘的抗锯齿。解析方法，如几何缓冲反走样(GBAA)和距离到边缘反走样(DEAA)，让渲染器计算关于三角形边缘位置的额外信息，例如，边缘离像素中心有多远。</strong></p>
<p><strong>最通用的方案只需要颜色缓冲，这意味着它们也可以从阴影、高光或各种以前应用的后处理技术，如剪影边缘渲染(第15.2.3节)改善边缘。例如，定向局部抗锯齿(DLAA)是基于这样的观察:一个接近垂直的边缘应该在水平方向上被模糊，同样，接近水平的边缘应该在垂直方向上与其相邻的边缘一起被模糊。</strong></p>
<p><strong>更精细的边缘检测是试图找到可能包含任何角度边缘的像素，并确定其覆盖范围。检查潜在边缘周围的邻域，目标是尽可能重建原始边缘所在的位置。边缘对像素的影响可以用来混合相邻像素的颜色。请参见下图了解流程的概念视图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919180125.png" class="" title="image-20210919180125">

<p>形态学抗锯齿。左边是走样图像。目标是确定形成它的边缘可能的方向。在中间，算法通过检查邻居来记录边缘的可能性。给定样本，显示两个可能的边缘位置。在右侧，根据估计的覆盖范围，使用最佳猜测的边缘将邻近的颜色混合到中心像素中。这个过程对图像中的每个像素重复。</p>
<p><strong>Iourcha等人通过以像素为单位检查MSAA样本来改进边缘查找，从而计算出更好的结果。需要注意的是，与基于样本的算法相比，边缘预测和混合可以给出更高的精度结果。例如，一项每像素使用4个样本的技术只能为对象的边缘提供5个层次的混合:没有样本覆盖、1个覆盖、2个、3个和4个。估计的边缘位置可以有更多的位置，从而提供更好的结果。</strong></p>
<p><strong>基于图像的算法有几种误区。首先，如果两个目标之间的颜色差异低于算法的阈值，边缘可能不会被检测到。有三个或更多不同表面重叠的像素是很难解释的。表面有高对比度或高频元素，其中颜色在像素间快速变化，会导致算法缺失边缘。特别是，当应用形态抗锯齿时，文本质量通常会受到影响。物体的角可能是一个挑战，一些算法给它们一个圆形的外观。曲线也会受到边是直的假设的不利影响。单个像素的变化会导致边缘重建的巨大变化，这可能会在帧与帧之间产生明显的伪影。改善这一问题的一种方法是使用MSAA覆盖掩码来改进边缘确定。</strong></p>
<p><strong>形态抗锯齿方案只使用提供的信息。例如，一个宽度比像素细的物体，比如电线或绳子，如果它没有覆盖像素的中心位置，屏幕上就会有缝隙。在这种情况下，多采样可以提高质量;仅仅基于图像的抗锯齿是不行的。此外，执行时间可能取决于所查看的内容。例如，一幅草地的抗锯齿效果需要的时间是一幅天空的三倍。</strong></p>
<p><strong>综上所述，基于图像的方法可以以较低的内存和处理成本提供抗锯齿支持，因此它们被用于许多应用程序。只有颜色的版本也从渲染管线中分离，使它们易于修改或禁用，甚至可以作为GPU驱动程序选项公开。两种最流行的算法是快速近似抗锯齿(FXAA)和亚像素形态抗锯齿(SMAA)，部分原因是这两种算法都为各种机器提供了可靠的(和免费的)源代码实现。这两种算法都使用颜色输入，其中SMAA具有能够访问MSAA样本的优点。每个版本都有自己的设置，在速度和质量之间进行权衡。成本通常在每帧1 - 2毫秒之间，主要是因为电子游戏愿意花这个时间。最后，两种算法都可以利用时间抗锯齿。Jimenez提出了一种改进的SMAA实现，比FXAA更快，并描述了一种时间抗走样方案。最后，我们建议读者阅读Reshetov和Jimenez对形态学技术及其在电子游戏中的使用进行的广泛综述。</strong></p>
<h2 id="Transparency-Alpha-and-Compositing-透明度、Alpha和合成"><a href="#Transparency-Alpha-and-Compositing-透明度、Alpha和合成" class="headerlink" title="Transparency, Alpha, and Compositing 透明度、Alpha和合成"></a>Transparency, Alpha, and Compositing 透明度、Alpha和合成</h2><p><strong>半透明物体有很多不同的方式让光线穿过它们。对于渲染算法，这些可以大致分为基于光线和基于视图的效果。基于光的效果是指物体使光线衰减或偏移，导致场景中的其他物体被照亮并呈现不同的效果。基于视图的效果是指半透明对象本身被渲染的效果。</strong></p>
<p><strong>在这一节中，我们将处理基于视图的透明的最简单形式，其中半透明的物体作为它后面物体的颜色衰减器。更精细的视图和基于光的效果，如磨砂玻璃，弯曲光(折射)，光的衰减由于透明物体的厚度，以及反射率和透射变化由于观察角度的讨论在后面的章节。</strong></p>
<p><strong>一种产生透明错觉的方法叫做屏风透明。这个想法是用像素对齐的棋盘填充模式渲染透明三角形。也就是说，三角形的每一个其他像素都被渲染，从而使物体部分可见。通常，屏幕上的像素靠得很近，棋盘图案本身是看不见的。这种方法的一个主要缺点是，通常只能在屏幕的一个区域上令人信服地呈现一个透明对象。例如，如果一个透明的红色物体和透明的绿色物体被呈现在一个蓝色物体上，那么这三种颜色中只有两种会出现在棋盘图案上。另外，50%的棋盘是有限的。其他更大的像素掩模可以用来给出其他百分比，但这些往往会产生可检测的模式。</strong></p>
<p><strong>也就是说，这种技术的一个优点是简单。透明对象可以在任何时间以任何顺序呈现，不需要特殊的硬件。通过使所有对象在它们所覆盖的像素处都不透明，透明度问题就解决了。同样的想法也用于裁剪纹理的抗锯齿边缘，但在亚像素级别，使用一个称为alpha的特性覆盖(章节6.6)。</strong></p>
<p><strong>由Enderton等提出的随机透明技术是将亚像素掩模与随机采样相结合。一个合理的，尽管有噪声，图像是通过使用随机点画模式来表示片段的alpha覆盖。参见下图。为了使结果看起来合理，每个像素需要大量的样本，以及为所有亚像素样本提供相当大的内存。但是，不需要混合，抗锯齿、透明度和任何其他现象，创建部分覆盖像素是由单一机制覆盖。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919212839.png" class="" title="image-20210919212839">

<p>随机透明度。产生的噪声显示在放大的区域。(图片来自NVIDIA SDK 11样本，由NVIDIA公司提供。)</p>
<p><strong>大多数透明算法将透明物体的颜色与它后面物体的颜色混合。为此，需要alpha混合的概念。当一个对象在屏幕上呈现时，每个像素都与RGB颜色和z缓冲区深度相关联。另一个分量称为α (α)，也可以为对象覆盖的每个像素定义。Alpha是一个值，描述一个给定像素的对象片段的不透明度和覆盖程度。alpha值为1.0意味着该对象是不透明的，并且完全覆盖了该像素感兴趣的区域;0.0表示像素完全没有被遮挡，即该片段是完全透明的。</strong></p>
<p><strong>根据具体情况，一个像素的alpha可以表示不透明度、覆盖率或两者兼有。例如，一个肥皂泡的边缘可能会覆盖四分之三的像素，0.75，并且可能几乎是透明的，让十分之九的光通过眼睛，所以它是十分之一的不透明，0.1。那么它的alpha将是0.75 × 0.1 = 0.075。然而，如果我们使用MSAA或类似的抗锯齿方案，覆盖率将由样本本身考虑。四分之三的样本会受到肥皂泡的影响。在这些样本中，我们将使用0.1的不透明度值作为alpha。</strong></p>
<h3 id="Blending-Order-混合顺序"><a href="#Blending-Order-混合顺序" class="headerlink" title="Blending Order 混合顺序"></a>Blending Order 混合顺序</h3><p><strong>为了让一个物体看起来透明，它被渲染在现有场景的顶部，alpha值小于1.0。被对象覆盖的每个像素将从像素着色器接收到生成的RGBA α(也称为RGBA)。将这个片段的值与原始像素颜色混合通常使用over操作符，如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919213306.png" class="" title="image-20210919213306">

<p><strong>其中cs 透明物体(称为光源)的颜色，αs 是物体的alpha，cd是混合前的像素颜色(称为目标)，co 是由于将透明物体置于现有场景之上而产生的颜色。在渲染管道发送cs 和αs，即像素的原始颜色cd 被替换为co．如果输入的RGBα实际上是不透明的(αs = 1.0)，等式简化为将像素的颜色完全替换为对象的颜色。</strong></p>
<p><strong>列子</strong></p>
<p><strong>混合。一个红色半透明物体被渲染到蓝色背景上。假设在某个像素处，物体的RGB着色为(0.9,0.2,0.1)，背景为(0.1,0.1,0.9)，物体的不透明度设置为0.6。然后是这两种颜色的混合</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919213653.png" class="" title="image-20210919213653">

<p><strong>它的颜色是(0.58,0.16,0.42)。</strong></p>
<p><strong>over运算符给被渲染的对象一个半透明的外观。这样做的透明度是有效的，在某种意义上，当我们可以透过它看到后面的物体时，我们就认为它是透明的。在模拟使用薄纱织物的真实世界效果。织物后面的物体的视图是部分模糊的——织物的线是不透明的。在实践中，松散织物的alpha覆盖范围随角度的变化而变化。我们这里的观点是，alpha模拟了材质覆盖像素的程度。</strong></p>
<p><strong>在模拟其他透明效果时，过度操作就不那么令人信服了，尤其是通过彩色玻璃或塑料观看。在现实世界中，蓝色物体前面的红色滤镜通常会使蓝色物体看起来很暗，因为这个物体反射的光很少，而红色滤镜可以通过。参见下图。当over用于混合，结果是一部分红色和蓝色加在一起。最好是将两种颜色相乘，以及添加透明物体本身的反射。这种类型的物理透射率将在14.5.1和14.5.2节中讨论。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919213844.png" class="" title="image-20210919213844">

<p>红色方形薄纱织物和红色塑料过滤器，产生不同的透明效果。注意阴影也是不同的。(照片由Morgan McGuire提供。)</p>
<p><strong>在基本的混合阶段操作符中，over是通常用于透明效果的操作符。另一种有一定用途的操作是加法混合，即简单地对像素值求和。也就是说,</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919214008.png" class="" title="image-20210919214008">

<p><strong>这种混合模式可以很好地工作于发光效果，如闪电或火花，不衰减后面的像素，而只是使它们更亮。然而，这个透明度看起来不正确，因为不透明的表面不会出现过滤。对于多层半透明表面，如烟雾或火焰，加法混合具有使现象颜色饱和的效果。</strong></p>
<p><strong>为了正确地渲染透明对象，我们需要在不透明对象之后绘制它们。先渲染所有不透明的对象，然后渲染所有透明对象。从理论上讲，我们总是可以使用over，因为1.0的不透明alpha会给出源颜色并隐藏目标颜色，但这样做的代价更大，没有实际的收益。</strong></p>
<p><strong>z缓冲区的一个限制是每个像素只能存储一个对象。如果几个透明对象重叠在同一个像素上，z缓冲区不能单独保存并在稍后解析所有可见对象的效果。当使用在任何给定像素的透明表面上时，通常需要按照前后顺序渲染。不这样做可能会给出错误的知觉线索。实现这种排序的一种方法是根据各个对象的质心沿视图方向的距离来排序。这种粗略的排序有相当好的效果，但在各种情况下存在许多问题。首先，顺序只是一个近似值，所以被分类为较远的物体可能在被认为较近的物体的前面。穿透的物体不可能以每个网格为基础来解析所有视角，除非将每个网格分割成单独的部分。如下图中的左图所示。即使是一个带有凹洞的网格，当它在屏幕上重叠时，也会显示视图方向的排序问题。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919214823.png" class="" title="image-20210919214823">

<p>在左侧，模型使用z-buffer进行透明渲染。以任意顺序渲染网格会产生严重的错误。在右侧，深度剥离提供了正确的外观，以额外的通道为代价。(图片由NVIDIA公司提供。)</p>
<p><strong>尽管如此，由于它的简单和速度，以及不需要额外的内存或特殊的GPU支持，执行一个粗略的透明度排序仍然是常用的。如果实现了，通常最好关闭z-depth用替换当执行的透明度。也就是说，z缓冲区仍然正常测试，但幸存的表面不会改变存储的z深度;最近的不透明表面的深度保持不变。通过这种方式，所有透明对象将至少以某种形式出现，而不是在摄像机旋转改变排序顺序时突然出现或消失。其他技术也可以帮助改善外观，如绘制每个透明网格两次，首先绘制背面，然后绘制正面。</strong></p>
<p><strong>也可以修改over方程，使前后混合得到相同的结果。这种混合模式被称为under操作符:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919215546.png" class="" title="image-20210919215546">

<p><strong>注意，under要求目标维护alpha值，over则不需要。换句话说，目标——被混合的更近的透明表面——不是不透明的，因此需要有一个alpha值。“未完成”的表述就像“结束”一样，只是源和目标互换了。另外，请注意计算alpha的公式是顺序无关的，因为源和目标alpha可以交换，最终的alpha是相同的结果。</strong></p>
<p><strong>alpha的公式来自考虑片段的alpha作为覆盖。Porter和Duff注意到，由于我们不知道每个片段的覆盖区域的形状，我们假设每个片段按其alpha的比例覆盖另一个片段。例如，如果是αs = 0.7，像素以某种方式被分成两个区域，0.7被源碎片覆盖，0.3没有覆盖。排除任何其他知识，目标片段覆盖，比如说，αd = 0.6将被源片段按比例重叠。这个公式有一个几何解释，如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919220503.png" class="" title="image-20210919220503">

<p>一个像素和两个片段，s和d。它们是不相关的。这两个片段所覆盖的面积相当于下面输出的alpha值αs −αsαd +αd．这转换为将两个区域相加，然后减去它们重叠的区域。</p>
<h3 id="Order-Independent-Transparency-Order-Independent透明度"><a href="#Order-Independent-Transparency-Order-Independent透明度" class="headerlink" title="Order-Independent Transparency Order-Independent透明度"></a>Order-Independent Transparency Order-Independent透明度</h3><p><strong>under方程用于将所有透明对象绘制到一个单独的颜色缓冲，然后使用over将这个颜色缓冲合并到场景的不透明视图之上。under操作符的另一个用途是执行一种称为深度剥离(depth peeling)的顺序独立透明(OIT)算法。顺序独立意味着应用程序不需要执行排序。深度剥离背后的想法是使用两个z缓冲区和多个通道。首先，一个渲染通道使得所有表面的z深度，包括透明表面，都在第一个z缓冲区中。在第二次传递中，所有透明对象都被渲染。如果对象的z-depth与第一个z-buffer中的值匹配，我们就知道这是最接近的透明对象，并将其RGBα保存到单独的颜色缓冲区中。我们也通过保存超过第一个z-depth且距离最近的透明对象的z-depth来“剥离”这个层。这个z-depth是第二近的透明物体的距离。连续通过继续剥离和添加透明层使用下。我们在经过一些通道后停止，然后混合透明图像顶部的不透明图像。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919220825.png" class="" title="image-20210919220825">

<p>每个深度剥离通道绘制一个透明层。在左边是第一个通道，显示层直接可见的眼睛。在中间显示的第二层，在每个像素上显示第二最近的透明表面，在本例中是对象的背面。第三层，在右边，是最近的一组透明表面。(图片由Louis Bavoil提供。)</p>
<p><strong>这种方案的几种变体已经开发出来了。例如，Thibieroz给出了一种反向工作的算法，其优点是能够立即混合透明值，这意味着不需要单独的alpha通道。深度剥离的一个问题是知道有多少通道足够捕获所有透明层。一个硬件解决方案是提供一个像素绘制计数器，它告诉在渲染过程中有多少像素被写入;当一个通道没有渲染像素时，渲染就完成了。使用under的优点是最重要的透明层——那些眼睛最先看到的层——在早期就呈现出来了。每个透明表面总是增加它所覆盖的像素的alpha值。如果当一个像素的Alpha值接近1.0时，混合的贡献使得该像素几乎不透明，因此更远的物体的影响可以忽略不计。当一个通道渲染的像素数量低于某个最小值时，或者可以指定一个固定的通道数量时，可以缩短前到后的剥离。这在前后剥离时效果不太好，因为最近的(通常是最重要的)层是最后绘制的，因此可能会因为提前终止而丢失。</strong></p>
<p><strong>虽然深度剥离是有效的，但它可能是缓慢的，因为每一层剥离都是所有透明对象的单独渲染通道。Bavoil和Myers提出了双重深度剥离，即每一遍剥离距离最近和最远的两层深度剥离层，从而将渲染通道的数量减半。Liu等人探索了一种桶排序方法，它可以在一次传递中捕获多达32层。这种方法的一个缺点是它需要相当大的内存来保持所有层的排序顺序。通过MSAA或类似的抗锯齿将大大增加成本。</strong></p>
<p><strong>以交互速率将透明物体正确地混合在一起的问题并不是我们缺少的算法，而是一个有效地将这些算法映射到GPU的问题。1984年Carpenter提出了A-buffer，这是另一种多重采样形式。在a缓冲区中，每个渲染的三角形为它完全或部分覆盖的每个屏幕网格单元创建覆盖掩码。每个像素存储所有相关片段的列表。不透明的片段可以剔除它们后面的片段，类似于z-buffer。所有的碎片都储存在透明的表面上。一旦形成了所有列表，就会遍历片段并解析每个示例，从而生成最终结果。</strong></p>
<p><strong>通过DirectX 11中暴露的新功能，在GPU上创建片段链表的想法成为可能。所使用的特性包括无序访问视图(UAVs)和原子操作，见章节3.8。通过MSAA抗锯齿是通过访问覆盖掩模和在每个样本评估像素着色器的能力来实现的。该算法的工作原理是对每个透明表面进行光栅化，并将生成的碎片插入到一个长数组中。除了颜色和深度，还会生成一个单独的指针结构，将每个片段链接到为像素存储的前一个片段。然后执行一个单独的通道，其中一个屏幕填充四边形被渲染，以便像素着色器在每个像素被评估。这个着色器根据链接检索每个像素上的所有透明片段。检索到的每个片段与前面的片段依次排序。然后将这个排序列表混合到前面，以给出最终的像素颜色。因为混合是由像素着色器执行的，如果需要，可以为每个像素指定不同的混合模式。GPU和API的持续发展通过降低使用原子操作符的成本提高了性能。</strong></p>
<p><strong>a缓冲区的优点是只分配每个像素所需的片段，就像在GPU上的链表实现一样。从某种意义上说，这也可能是一个缺点，因为在开始渲染帧之前，所需的存储量是未知的。一个有头发、烟雾或其他物体的场景可能会产生许多重叠的透明表面，从而产生大量的碎片。</strong></p>
<p><strong>Andersson指出，对于复杂的游戏场景，多达50个透明的物体网格(如树叶)和多达200个半透明粒子可能会重叠。</strong></p>
<p><strong>GPU通常有预先分配的缓冲区和数组等内存资源，链表方法也不例外。用户需要决定多少内存是足够的，而内存耗尽会导致明显的伪影。Salvi和Vaidyanathan提出了一种解决这个问题的方法，即多层alpha混合，使用 Intel引入的一种称为像素同步的GPU特性。参见下图。此功能提供了比原子更少开销的可编程混合。他们的方法是重新规划存储和混合，以便在内存耗尽时降级。粗略的排序顺序对他们的方案有利。DirectX 11.3引入了光栅化顺序视图(章节3.8)，这是一种允许透明方法在任何支持该特性的GPU上实现的缓冲区。移动设备有一种类似的技术，称为tile本地存储，允许它们实现多层alpha混合。然而，这种机制有性能成本，因此这种类型的算法可能是昂贵的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919222028.png" class="" title="image-20210919222028">

<p>在左上角，执行传统的前后alpha混合，导致由于错误的排序顺序而导致渲染错误。在右上角，a缓冲区被用来给出一个完美的，非交互的结果。左下角呈现的是多层alpha混合渲染。右下角为a缓冲区与多层图像的差异，能见度乘以4。(图片由英特尔公司的Marco Salvi和Karthik Vaidyanathan提供)。</p>
<p><strong>这种方法建立在Bavoil等人提出的k-buffer的思想之上，在k-buffer中，前几个可见层被尽可能地保存和排序，较深的层被尽可能地丢弃和合并。Maule等人使用k-buffer，并通过加权平均来解释这些较远的深层层。加权求和和加权平均透明技术是顺序无关的，是单通道的，并运行在几乎每一个GPU。问题是它们没有考虑到对象的顺序。参见下图。因此，使用alpha来表示覆盖范围，薄纱红色围巾在薄纱蓝色围巾上给出一个紫罗兰色，而正确地看到红色围巾中有一点蓝色。虽然几乎不透明的物体效果不佳，但这类算法对于可视化是有用的，对于高度透明的表面和粒子也很有效。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919222322.png" class="" title="image-20210919222322">

<p>随着不透明度的增加，对象的顺序变得更加重要。</p>
<p><strong>在加权和透明度的公式是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919222439.png" class="" title="image-20210919222439">

<p><strong>其中n是透明表面的数量，ci 和αi 表示透明度值的集合，cd是场景中不透明部分的颜色。这两个和被累积并作为透明表面被渲染而单独存储，并且在透明通道的末尾，在每个像素处计算方程。这种方法的问题是第一个和饱和，即生成大于(1.0,1.0,1.0)的颜色值，并且背景颜色可能有负面影响，因为alpha的总和可以超过1.0。</strong></p>
<p><strong>加权平均方程通常被采用，因为它避免了这些问题</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919222623.png" class="" title="image-20210919222623">

<p><strong>第一行表示透明性呈现期间生成的两个独立缓冲区中的结果。每个对csum 有贡献的曲面是否给予权重的影响其α;几乎不透明的表面对颜色的影响更大，而几乎透明的表面对颜色的影响很小。csum除以αsum我们得到一个加权平均透明度颜色。αavg是所有值的平均值。值u是对n个透明表面应用n次平均alpha后的目标(不透明场景)的估计能见度。最后一行实际上是over运算符，(1−u)表示源的alpha。</strong></p>
<p><strong>加权平均的一个限制是，对于相同的alpha，它将所有颜色均匀地混合在一起，不管顺序如何。McGuire和Bavoil引入了加权混合顺序无关透明度，以得到更令人信服的结果。在他们的公式中，到表面的距离也影响权重，更近的表面给予更大的影响。此外，u不是平均的，而是通过乘项(1−αi)来计算的，并从其中减去一个，给出真正的alpha覆盖的表面集合。这种方法产生的结果在视觉上更有说服力，如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919222933.png" class="" title="image-20210919222933">

<p>两个不同的摄像机位置查看相同的引擎模型，都使用加权混合顺序无关透明度渲染。通过距离加权可以帮助确定哪些表面离观察者更近。(图片由Morgan McGuire提供。)</p>
<p><strong>缺点是，在一个大的环境中，彼此靠近的物体从距离看可能具有几乎相等的权重，使得结果与加权平均值相差无几。此外，随着相机到透明物体的距离改变，深度权重可能会发生变化，但这种变化是渐进的。</strong></p>
<p><strong>McGuire和Mara扩展了这种方法，使其包含了一种似是而非的透射色效应。如前所述，本节讨论的所有透明度算法混合各种颜色，而不是过滤它们，模拟像素覆盖。为了获得颜色过滤效果，像素着色器读取不透明场景，每个透明表面将其覆盖的像素乘以其颜色，将结果保存到第三个缓冲区。在这个缓冲区中，不透明的对象现在被透明的对象着色，然后在解析时用来代替不透明冲区。这种方法是可行的，因为不同于由于覆盖而产生的透明度，彩色透射是顺序无关的。</strong></p>
<p><strong>还有其他一些算法使用了本文中介绍的几种技术中的元素。例如，Wyman根据内存需求、插入和合并方法、是否使用alpha或几何覆盖以及如何处理丢弃的片段对以前的工作进行了分类。他提出了两种新方法，通过寻找以前研究的漏洞而发现。他的随机分层alpha混合方法使用k缓冲、加权平均和随机透明度。他的另一个算法是Salvi和Vaidyanathan方法的变体，使用覆盖掩码而不是alpha。</strong></p>
<p><strong>考虑到透明内容、渲染方法和GPU能力的广泛类型，渲染透明对象没有完美的解决方案。我们向感兴趣的读者推荐Wyman的论文和Maule等人对交互透明性算法的更详细的调查。McGuire的报告提供了一个更广阔的视野，通过其他相关现象，如体积照明、彩色透射和折射，这些将在本书后面进行更深入的讨论。</strong></p>
<h3 id="Premultiplied-Alphas-and-Compositing-预乘alpha和合成"><a href="#Premultiplied-Alphas-and-Compositing-预乘alpha和合成" class="headerlink" title="Premultiplied Alphas and Compositing 预乘alpha和合成"></a>Premultiplied Alphas and Compositing 预乘alpha和合成</h3><p><strong>过运算符也用于混合照片或物体的合成渲染。这个过程叫做合成。在这种情况下，每个像素的alpha值与对象的RGB颜色值一起存储。由alpha通道形成的图像有时被称为哑光。它显示了物体的轮廓形状。</strong></p>
<p><strong>使用合成RGBα数据的一种方法是使用预乘α(也称为关联α)。也就是说，RGB值在使用之前要乘以alpha值。这使得合成方程更有效:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919223613.png" class="" title="image-20210919223613">

<p><strong>其中cs′ 是前置源信道代替之前方程中的αscs 。预乘alpha也使得在不改变混合状态的情况下使用over和加法混合成为可能，因为在混合过程中添加了源颜色。请注意，使用预乘的RGBα值，RGB组件通常不会大于alpha值，尽管它们可以被制作成特别明亮的半透明值。</strong></p>
<p><strong>渲染合成图像与预乘alpha自然吻合。在黑色背景上渲染的抗锯齿不透明对象默认提供预乘值。假设一个白色(1,1,1)三角形沿其边缘覆盖了某个像素的40%。使用(非常精确的)抗锯齿，像素值将被设置为0.4的灰度，即将为这个像素保存为颜色(0.4,0.4,0.4)，如果也会是0.4，因为这是三角形覆盖的面积。RGBα值将是(0.4,0.4,0.4,0.4)，这是一个预乘值。</strong></p>
<p><strong>图像存储的另一种方式是不相乘的，也称为不关联的，甚至是令人费解的术语非预相乘的。一个未乘的alpha值就是它所说的:RGB值没有乘以alpha值。对于白色三角形的例子，未相乘的颜色是(1,1,1,0.4)。这种表示的优点是存储三角形的原始颜色，但是在显示之前，这个颜色总是需要乘以存储的alpha。当进行滤波和混合时，最好使用预乘数据，因为使用未乘的alpha时，如线性插值等操作不能正确工作。像物体边缘周围的黑色条纹这样的伪影可能会产生。请参阅第6.6节的末尾进行进一步的讨论。前乘阿尔法也允许更干净的理论处理。</strong></p>
<p><strong>对于图像处理应用程序，不相关的alpha用于屏蔽照片而不影响底层图像的原始数据。此外，不相关的alpha意味着可以使用颜色通道的全精度范围。也就是说，必须小心地将未乘的RGBα值与用于计算机图形计算的线性空间进行适当的转换。例如，没有浏览器能正确地做到这一点，它们也不可能这样做，因为现在预期会出现错误行为。支持alpha的图像文件格式包括PNG(只支持不关联的alpha)、OpenEXR(只支持关联的)和TIFF(两种alpha类型)。</strong></p>
<p><strong>与alpha通道相关的一个概念是色度键控。这是一个来自视频制作的术语，在视频制作中，演员在绿色或蓝色的屏幕上拍摄，并与背景混合。在电影工业中，这个过程被称为绿幕或蓝幕。这里的想法是，特定的色调(电影作品)或精确的值(计算机图形)被指定为透明;当它被检测到时，背景就会显示出来。这允许图像通过使用RGB颜色得到轮廓形状;不需要存储alpha。这种方案的一个缺点是，对象在任何像素上要么完全不透明，要么完全透明。alpha实际上只有1.0或0.0。例如，GIF格式允许一种颜色被指定为透明。</strong></p>
<h2 id="Display-Encoding-显示编码"><a href="#Display-Encoding-显示编码" class="headerlink" title="Display Encoding 显示编码"></a>Display Encoding 显示编码</h2><p><strong>当我们计算光照、纹理或其他操作的效果时，使用的值被假定为线性的。非正式地说，这意味着加法和乘法按预期工作。然而，为了避免各种视觉伪影，显示缓冲和纹理使用了我们必须考虑的非线性编码。简短而草率的答案如下:在[0,1]范围内取着色器输出的颜色，并将其提高1/2.2的次方，执行所谓的伽马校正。对传入的纹理和颜色做相反的操作。在大多数情况下，你可以让GPU为你做这些事情。本节将解释如何以及为什么进行快速总结。</strong></p>
<p><strong>我们从阴极射线管(CRT)开始。在数字成像技术的早期，CRT显示器是主流。这些器件在输入电压和显示亮度之间呈现幂律关系。当应用到一个像素上的能量水平增加时，发出的辐亮度不是线性增长，而是与该水平成比例增长，其幂次大于1。例如，假设幂是2。一个像素被设置为50%将发射四分之一的光，0.52 = 0.25，作为一个像素被设置为1.0。尽管液晶显示器和其他显示技术与CRT有不同的内在特殊响应曲线，但它们是用转换电路制造的，从而使它们模仿CRT响应。</strong></p>
<p><strong>这个幂函数几乎与人类视觉的亮度灵敏度的倒数相匹配。这种幸运巧合的结果是，编码在感知上是大致一致的。也就是说，在可显示范围内，一对编码值N和N +1之间的感知差异大致是恒定的。通过测量阈值对比度，我们可以在广泛的条件下检测到大约1%的亮度差异。当颜色存储在有限精度的显示缓冲器中时，这种接近最优的值分布最小化了条带伪影(章节23.6)。同样的好处也适用于纹理，它们通常使用相同的编码。</strong></p>
<p><strong>显示传递函数描述显示缓冲器中的数字值与显示发出的亮度水平之间的关系。因此，它也被称为电光传递函数(EOTF)。显示传输功能是硬件的一部分，计算机显示器、电视和电影放映机有不同的标准。对于该过程的另一端，即图像和视频捕捉设备，也有一个标准的传递函数，称为光电传递函数(OETF)。</strong></p>
<p><strong>当编码用于显示的线性颜色值时，我们的目标是抵消显示传递函数的影响，因此无论我们计算出什么值，都会发射出相应的亮度水平。例如，如果我们的计算值增加了一倍，我们希望输出亮度增加一倍。为了保持这种联系，我们应用显示传递函数的逆来抵消它的非线性影响。这个使显示器的响应曲线无效的过程也称为伽马校正，原因很快就会清楚。当解码纹理值时，我们需要应用显示传递函数来生成用于着色的线性值。下图展示了解码和编码在显示过程中的使用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920145139.png" class="" title="image-20210920145139">

<p>在左边，一个PNG颜色纹理被GPU着色器访问，它的非线性编码值被转换(蓝色)为线性值。在底纹和色调映射(章节8.2.2)之后，最终计算的值被编码(绿色)并存储在帧缓冲区中。这个值和显示传递函数决定发射的辐射量(红色)。绿色函数和红色函数的组合消去了，所以发射的辐亮度与线性计算值成比例。</p>
<p><strong>个人电脑显示器的标准传递函数是由称为sRGB的颜色空间规范定义的。大多数API控制GPU可以设置为自动应用适当的sRGB转换时，从纹理或写入颜色缓冲区。正如在第6.2.2节中讨论的，mipmap生成也将考虑sRGB编码。在纹理值之间的双线性插值将正确工作，首先转换为线性值，然后执行插值。通过将存储的值解码回线性值，混合新值，然后对结果进行编码，可以正确地实现Alpha混合。</strong></p>
<p><strong>重要的是在呈现的最后阶段应用转换，此时值被写入帧缓冲区以进行显示。如果后期处理后应用显示编码，这样的影响将计算在非线性值，这通常是不正确的，并将经常导致伪影。显示编码可以被认为是一种压缩形式，它最好地保留了值的感知效果。考虑这个区域的一个好方法是线性值,我们使用执行物理计算,每当我们想要显示结果或访问可显示的图像如颜色纹理,我们需要移动数据或从其显示编码形式,使用适当的编码或解码转换。</strong></p>
<p><strong>如果您确实需要手动应用sRGB，有一个标准的转换方程或几个简化版本可以使用。在实际应用中，显示器由每个颜色通道的若干位控制，例如，8位用于用户显示器，给出一组范围为[0,255]的电平。这里我们将显示编码级别表示为范围[0.0,1.0]，忽略比特数。线性值也在[0.0,1.0]范围内，表示浮点数。我们用x表示这些线性值，用y表示存储在帧缓冲区中的非线性编码值。为了将线性值转换为sRGB非线性编码值，我们应用sRGB显示传递函数的逆函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920145812.png" class="" title="image-20210920145812">

<p><strong>x表示线性RGB中的一个通道。等式应用于每个通道，这三个生成的值驱动显示。你要小心手动应用转换函数。一个错误的来源是使用编码颜色而不是它的线性形式，另一个来源是解码或编码颜色两次。</strong></p>
<p><strong>两个变换表达式的底部是一个简单的乘法，这是由于数字硬件需要使变换完全可逆。上面的表达式将值提高到某次幂，几乎适用于输入值x的整个范围[0.0,1.0]。考虑到偏移量和比例，该函数近似于一个更简单的公式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150010.png" class="" title="image-20210920150010">

<p><strong>其中γ = 2.2。</strong></p>
<p><strong>正如必须对计算值进行编码以便显示一样，静态或视频摄像机捕获的图像在用于计算之前必须转换为线性值。你在显示器或电视上看到的任何颜色都有一些显示编码的RGB三联体，你可以从屏幕捕获或颜色选择器获得。这些值是以PNG、JPEG和GIF等文件格式存储的，这些格式可以直接发送到帧缓冲区以在屏幕上显示，而不需要进行转换。换句话说，无论您在屏幕上看到什么，根据定义都是显示编码的数据。在使用这些颜色进行底纹计算之前，我们必须将这种编码形式转换回线性值。我们需要从显示编码到线性编码的sRGB转换</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150155.png" class="" title="image-20210920150155">

<p><strong>用y表示规范化显示的通道值，即存储在图像或帧缓冲区中的内容，表示为范围[0.0,1.0]的值。这个解码函数与我们以前的sRGB公式相反。这意味着如果一个纹理被一个着色器访问并且输出没有改变，它将显示与被处理之前一样，正如预期的那样。解码函数与显示传递函数相同，因为存储在纹理中的值已经过编码以正确显示。我们不是转换为给出线性响应显示，而是转换为给出线性值。</strong></p>
<p><strong>更简单的gamma显示传递函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150324.png" class="" title="image-20210920150324">

<p><strong>有时你会看到一个更简单的转换组合，特别是在移动和浏览器应用程序:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150334.png" class="" title="image-20210920150334">

<p><strong>也就是说，取线性值的平方根，然后将其与自身相乘得到逆函数。虽然这是一个粗略的估计，但这种转换总比完全忽略这个问题要好。</strong></p>
<p><strong>如果我们不注意伽马值，较低的线性值会在屏幕上显得太暗。一个相关的错误是，如果不进行伽玛校正，某些颜色的色调会发生变化。假设γ = 2.2。我们希望从显示的像素发射出与线性计算值成比例的辐亮度，这意味着我们必须将线性值提高到(1/2.2)次方。线性值0.1给出0.351,0.2给出0.481,0.5给出0.730。如果未对这些值进行编码，则按原样使用这些值将导致显示器发出比所需更少的亮度。注意0.0和1.0在任何这些转换中都是不变的。在使用伽马校正之前，暗色的表面颜色通常会被建模场景的人人为地增强，在反显示变换中折叠。</strong></p>
<p><strong>忽略gamma校正的另一个问题是，对物理线性辐射值正确的着色计算是在非线性值上执行的。如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150548.png" class="" title="image-20210920150548">

<p>两个重叠的聚光灯照亮一个平面。在左边的图像中，添加光值0.6和0.4后没有进行gamma校正。该加法可以有效地对非线性值进行运算，从而产生误差。注意左边的光看起来要比右边的亮得多，而且重叠看起来亮得不现实。在右边的图像中，这些值在相加后进行了gamma校正。光本身按比例更亮，它们在重叠的地方恰当地结合在一起。</p>
<p><strong>忽略伽马校正也会影响抗锯齿边缘的质量。例如，假设一个三角形边缘覆盖四个屏幕网格单元格(下图)。三角形的归一化亮度为1(白色);背景是0(黑色)。从左到右，细胞被覆盖1/8、3/8、5/8和7/8。因此，如果我们使用盒形滤波器，我们想要将像素的归一化线性亮度表示为0.125、0.375、0.625和0.875。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150711.png" class="" title="image-20210920150711">

<p>在左边，四个像素被一个白色三角形的边缘覆盖在一个黑色(显示为灰色)的背景上，真实的区域覆盖显示。如果伽玛校正不执行，中音变暗将导致边缘感知被扭曲，如右图所示。</p>
<p><strong>正确的方法是对线性值执行反走样，对四个结果值应用编码函数。如果不这样做，像素所代表的辐亮度将会太暗，导致在图的右侧看到的边缘变形。这种人为效果被称为绳索，因为它的边缘看起来有点像一根扭曲的绳子。下图显示了这个效果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150954.png" class="" title="image-20210920150954">

<p>在左侧，抗锯齿线集被伽马校正;中间部分是部分修正;在右边，没有伽马校正。(图片由Scott R. Nelson提供。)</p>
<p><strong>sRGB标准创建于1996年，已经成为大多数计算机显示器的标准。然而，从那时起，显示技术已经发生了变化。人们已经开发出了更明亮、能显示更多种颜色的显示器。第8.1.3节讨论了彩色显示和亮度，第8.2.1节介绍了高动态范围显示的显示编码。Hart的文章提供了关于先进显示器的更多信息。</strong></p>
<h1 id="6-Texturing-纹理"><a href="#6-Texturing-纹理" class="headerlink" title="6 Texturing 纹理"></a>6 Texturing 纹理</h1><p><strong>表面纹理就是外观和感觉——想想油画的纹理就知道了。在计算机图形学中，纹理是一个过程，它获取一个表面，并使用一些图像、功能或其他数据源在每个位置修改它的外观。例如，不精确地表示砖墙的几何形状，而是将砖墙的彩色图像应用于由两个三角形组成的矩形。当查看矩形时，彩色图像出现在矩形所在的位置。除非观众靠近墙壁，否则缺乏几何细节是不会被注意到的。</strong></p>
<p><strong>然而，一些有纹理的砖墙除了缺乏几何学之外，还可能无法令人信服。例如，如果砂浆是哑光的，而砖块是光滑的，观众会注意到这两种材料的粗糙度是相同的。为了产生更令人信服的体验，第二个图像纹理可以应用到表面。这种纹理不是改变表面的颜色，而是根据表面的位置改变墙壁的粗糙度。现在砖块和砂浆的颜色来自图像纹理，粗糙度值来自这个新的纹理。</strong></p>
<p><strong>观众可以看到，现在所有的砖都是光滑的，而砂浆不是，但注意到每个砖面似乎是完美的平面。这看起来不太对，因为砖块的表面通常有一些不规则。通过应用凹凸贴图，砖块的着色法线可能会有所变化，所以当它们被渲染时，它们不会看起来非常光滑。为了计算光照，这种纹理会抖动矩形的原始表面法线的方向。</strong></p>
<p><strong>从一个小角度来看，这种凹凸不平的错觉可能会被打破。砖块应该突出在灰泥之上，遮住视线。即使从直观的角度看，砖块的影子也会投射到灰泥上。视差贴图在渲染平面时使用纹理使其变形，视差遮挡贴图将光线投射到高度场纹理上以提高真实感。位移映射通过修改形成模型的三角形高度来真实地置换表面。下图显示了一个使用颜色纹理和凹凸贴图的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920151615.png" class="" title="image-20210920151615">

<p><strong>这些都是用纹理解决的问题的例子，使用越来越复杂的算法。在本章中，纹理技术将被详细介绍。首先，提出了一个纹理加工的总体框架。接下来，我们着重于使用图像纹理表面，因为这是实时工作中最流行的纹理形式。简要讨论了程序纹理，然后解释了一些常见的纹理影响表面的方法。</strong></p>
<h2 id="The-Texturing-Pipeline-纹理管线"><a href="#The-Texturing-Pipeline-纹理管线" class="headerlink" title="The Texturing Pipeline 纹理管线"></a>The Texturing Pipeline 纹理管线</h2><p><strong>纹理是一种有效地在表面的材质和完成的变化建模技术。考虑纹理的一种方法是考虑单个着色像素的情况。正如在前一章所看到的，着色是通过考虑材质的颜色和光线，以及其他因素来计算的。如果存在，透明度也会影响样本。纹理通过修改在着色方程中使用的值来工作。改变这些值的方式通常是基于表面上的位置。因此，对于砖墙的例子，基于表面位置，表面上任何一点的颜色都被砖墙图像中相应的颜色所替换。图像纹理中的像素通常被称为texels，以与屏幕上的像素区分开来。粗糙度纹理修改了粗糙度值，凹凸纹理改变了着色法线的方向，所以每一个都改变了着色方程的结果。</strong></p>
<p><strong>纹理可以用广义纹理管线来描述。</strong></p>
<p><strong>空间中的位置是纹理过程的起点。这个位置可以在世界空间中，但更多的是在模型的参考框架中，所以当模型移动时，纹理也会随之移动。使用Kershaw的术语，空间中的这个点有一个投影函数，用于获得一组被称为纹理坐标的数字，这些数字将用于访问纹理。这个过程称为映射，这引出了纹理映射。有时纹理图像本身被称为纹理映射，尽管严格上来说这是不正确的。</strong></p>
<p><strong>在使用这些新值访问纹理之前，可以使用一个或多个对应函数将纹理坐标转换为纹理空间。这些纹理空间位置用于从纹理中获取值，例如，它们可以是数组索引到图像纹理中以检索像素。检索到的值被一个值转换函数再次潜在地转换，最后这些新值被用来修改表面的一些属性，如材质或着色法线。下图详细展示了单个纹理的应用过程。管线之所以如此复杂，是因为每一步都为用户提供了一个有用的控件。应该注意的是，并非所有步骤都需要在任何时候被激活。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920153341.png" class="" title="image-20210920153341">

<p>一个单一纹理的广义纹理管线。</p>
<p><strong>使用这个管线，当一个三角形有一个砖墙纹理，并且在它的表面生成一个样本时，就会发生这样的情况(参见下图)。在物体的局部参照系中找到(x, y, z)位置;即(−2.3,7.1,88.2)。然后将一个投影仪功能应用到这个位置。就像一幅世界地图是一个三维物体的二维投影,投影函数通常改变(x, y, z)向量成双元素向量(u, v)。本例中使用的投影仪功能相当于一个正射投影(2.3.1节),作用类似幻灯机闪亮的砖墙上三角形的表面形象。为了返回到壁面，可以将壁面上的一个点转换为一对0到1之间的值。假设得到的值是(0.32,0.29)。这些纹理坐标用于查找图像在这个位置的颜色。砖块纹理的分辨率是256 × 256，所以对应函数将(u, v)分别乘以256，得到(81.92,74.24)。去掉分数，在砖墙图像中找到像素(81,74)，为彩色(0.9,0.8,0.7)。纹理颜色在sRGB颜色空间中，所以如果颜色用于着色方程，它被转换为线性空间，给出(0.787,0.604,0.448)(章节5.6)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920153621.png" class="" title="image-20210920153621">

<p>一堵砖墙的管线。</p>
<h3 id="The-Projector-Function-投影函数"><a href="#The-Projector-Function-投影函数" class="headerlink" title="The Projector Function 投影函数"></a>The Projector Function 投影函数</h3><p><strong>纹理处理的第一步是获取表面的位置并将其投影到纹理坐标空间，通常是二维(u, v)空间。建模包通常允许艺术家定义每个顶点的(u, v)坐标。这些可以从投影仪函数或网格展开算法初始化。艺术家可以用编辑顶点位置的方式编辑(u, v)坐标。投影的功能通常是将空间中的三维点转换为纹理坐标。建模程序中常用的函数包括球面、圆柱和平面投影。</strong></p>
<p><strong>其他输入可用于投影函数。例如，表面法线可以用来选择用于表面的六个平面投影方向中的哪个。纹理匹配的问题发生在面相遇的接缝处;Geiss讨论了一种混合它们的技巧。Tarini等人描述了聚立方体映射，其中模型映射到一组立方体投影，不同的空间体积映射到不同的立方体。</strong></p>
<p><strong>其他投影函数根本不是投影，而是曲面创建和镶嵌的一个隐式部分。例如，参数曲面具有(u, v)值的自然集作为其定义的一部分。参见下图。纹理坐标也可以由各种不同的参数生成，如视图方向、表面温度或其他任何可以想象的参数。投影函数的目标是生成纹理坐标。把这些作为位置的函数来推导只是一种方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920154218.png" class="" title="image-20210920154218">

<p>不同贴图投影。从左到右分别显示球面、圆柱、平面和自然(u, v)投影。下面一行显示了应用于单个对象(没有自然投影)的每个投影。</p>
<p><strong>非交互式渲染器通常将这些投影函数作为渲染过程本身的一部分。单一的投影函数可能足以满足整个模型，但艺术家经常不得不使用工具来细分模型，并分别应用各种投影函数。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920154524.png" class="" title="image-20210920154524">

<p>如何在一个模型上使用不同的纹理投影。箱形映射由六个平面映射组成，每个箱形面一个平面映射。(图片由Tito Pag´an提供。)</p>
<p><strong>在实时工作中，通常在建模阶段应用投影函数，并将投影结果存储在顶点上。情况并非总是如此;有时，在顶点或像素着色器中应用投影函数是有利的。这样做可以提高精度，并帮助启用各种效果，包括动画(第6.4节)。一些呈现方法，如环境映射(第10.4节)，有自己的专门的投影函数，按像素计算。</strong></p>
<p><strong>球面投影将点投射到一个以某一点为中心的虚拟球体上。这个投影与Blinn和Newell的环境映射方案(第10.4.1节)中使用的相同。这种投影方法也会遇到与上一节中描述的顶点插值相同的问题。</strong></p>
<p><strong>圆柱投影计算的纹理坐标u与球面投影相同，纹理坐标v计算的是沿着圆柱轴的距离。这种投影对于具有自然轴的物体是有用的，例如旋转表面。当表面与圆柱体的轴线接近垂直时，就会发生变形。</strong></p>
<p><strong>平面投影就像一束x射线，沿着一个方向平行投影，并将纹理应用到所有的表面。它使用正投影(第4.7.1节)。这种类型的投影对于贴花很有用，例如(第20.2节)。</strong></p>
<p><strong>由于在投影方向上的表面会有严重的扭曲，艺术家经常必须手工将模型分解成近平面的部分。还有一些工具可以通过展开网格来帮助最小化扭曲，或者创建一组接近最优的平面投影，或者其他帮助这个过程的工具。我们的目标是让每个多边形在纹理区域中拥有更公平的份额，同时保持尽可能多的网格连接。连接性是很重要的，因为采样伪影可以沿着纹理的不同部分的边缘出现。一个网格良好的展开也能使艺术家的工作更轻松。第16.2.1节讨论了纹理失真如何对渲染产生不利影响。下图显示了用于创建雕像的工作区。这种展开过程是网格参数化这一更大的研究领域的一个方面。感兴趣的读者可参考Hormann等人的SIGGRAPH课程笔记。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920155042.png" class="" title="image-20210920155042">

<p>雕像模型的几个较小的纹理，保存在两个较大的纹理中。右图显示了三角形网格是如何展开的，并显示在纹理上，以帮助创建。(图片由Tito Pag´an提供。)</p>
<p><strong>纹理坐标空间并不总是一个二维平面;有时它是一个三维的体积。在这种情况下，纹理坐标被呈现为一个三元素向量(u, v, w)， w是沿着投影方向的深度。其他系统最多使用四个坐标，通常指定为(s, t, r, q);Q被用作齐次坐标中的第四个值。它就像一部电影或幻灯片放映机，投影纹理的大小随着距离的增加而增加。例如，在舞台或其他表面上投射一种被称为“gobo”的装饰性聚光灯图案是很有用的。</strong></p>
<p><strong>纹理坐标空间的另一种重要类型是方向性，其中空间中的每个点都可以通过输入方向访问。一种可视化这样一个空间的方法是作为一个单位球体上的点，每个点的法线代表了用于访问该位置纹理的方向。使用方向性参数化的纹理最常见的类型是立方体映射(章节6.2.4)。</strong></p>
<p><strong>同样值得注意的是，一维纹理图像和功能有其用途。例如，在一个地形模型上，颜色可以由海拔高度决定，例如，低地是绿色的;山峰是白色的。线条也可以被纹理化;它的一个用途是将雨渲染成一组带有半透明纹理的长线。这样的纹理对于从一个值转换到另一个值也很有用。例如，作为查找表。</strong></p>
<p><strong>因为多个纹理可以应用到一个表面上，所以可能需要定义多个纹理坐标集。然而，应用坐标值的思路是相同的:这些纹理坐标被插值到整个表面并用于检索纹理值。然而，在插值之前，这些纹理坐标是通过对应函数进行变换的。</strong></p>
<h3 id="The-Corresponder-Function-匹配函数"><a href="#The-Corresponder-Function-匹配函数" class="headerlink" title="The Corresponder Function 匹配函数"></a>The Corresponder Function 匹配函数</h3><p><strong>匹配函数将纹理坐标转换为纹理空间位置。它们提供了在表面上应用纹理的灵活性。匹配函数的一个例子是使用API来选择现有纹理的一部分进行显示;后续操作中只会使用该子图像。</strong></p>
<p><strong>另一种类型的匹配是矩阵变换，它可以应用于顶点或像素着色器。这可以在表面上平移、旋转、缩放、剪切或投影纹理。如第4.1.5节所述，转换的顺序很重要。纹理转换的顺序必须与人们所期望的顺序相反。这是因为纹理变换实际上影响了决定图像在哪里看到的空间。图像本身不是一个被转换的物体;定义图像位置的空间正在被更改。</strong></p>
<p><strong>另一类对应函数控制应用图像的方式。我们知道图像将出现在(u, v)在[0,1]范围内的表面上。但是在这个范围之外会发生什么呢?匹配函数可以决定这个行为。在OpenGL中，这种类型的通信器函数被称为“包装模式”;在DirectX中，它被称为“纹理寻址模式”。”这类匹配的常见功能有:</strong></p>
<pre><code>**wrap (DirectX)， repeat (OpenGL)或tile：图像在表面上重复自身;算法上，纹理坐标的整数部分被删除。这个函数对于让一个材质的图像重复覆盖一个表面很有用，并且通常是默认的。**

**镜像：图像在整个表面上重复，但每重复一次就会被镜像(翻转)。例如，图像从0到1正常显示，然后在1和2之间反向显示，然后在2和3之间正常显示，然后反向显示，以此类推。这就为纹理的边缘提供了一些连续性。**

**clamp (DirectX)或clamp to edge (OpenGL)：超出范围[0,1]的值被clamp到这个范围。这导致图像纹理边缘的重复。该函数有助于避免在纹理边缘附近发生双线性插值时意外地从纹理的相反边缘获取样本。**

**border (DirectX)或clamp to border (OpenGL)：纹理坐标在[0,1]外使用单独定义的边框颜色进行渲染。这个函数可以在单色表面上很好的渲染贴花，例如，纹理的边缘将与边框颜色平滑地融合。**
</code></pre>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920160130.png" class="" title="image-20210920160130">

<p><strong>参见上图。这些匹配函数可以为每个纹理轴分配不同的值，例如，纹理可以沿着u轴重复，并被固定在v轴上。在DirectX中也有一个镜像一次模式，它沿着纹理坐标的零值一次镜像纹理，然后clamp，这对对称贴花很有用。</strong></p>
<p><strong>重复平铺纹理是一种为场景添加更多视觉细节的廉价方法。然而，当眼睛看出图案时，这种技术在重复三次纹理后往往看起来不令人信服。避免这种周期性问题的一个常见解决方案是将纹理值与另一个非平铺的纹理相结合。这种方法可以得到相当大的扩展，正如Andersson所描述的商业地形渲染系统所示。在这个系统中，根据地形类型、海拔高度、坡度等因素组合多种纹理。纹理图像也与场景中放置的几何模型有关，比如灌木丛和岩石。</strong></p>
<p><strong>避免周期性的另一个选择是使用着色程序来实现专门的对应函数，随机重新组合纹理模式或细分。Wang tiles 就是这种方法的一个例子。Wang tiles 是一组边缘相匹配的正方形瓦组。贴图是在贴图过程中随机选择的。Lefebvre和Neyret使用依赖纹理读取和表实现了类似类型的匹配函数，以避免模式重复。</strong></p>
<p><strong>最后应用的对应函数是隐式的，由图像的大小导出。纹理通常在u和v的[0,1]范围内应用。如砖墙的例子所示，通过将这个范围内的纹理坐标乘以图像的分辨率，就可以得到像素的位置。能够在[0,1]范围内指定(u, v)值的好处是，不同分辨率的图像纹理可以交换，而不必更改存储在模型顶点的值。</strong></p>
<h3 id="Texture-Values-纹理值"><a href="#Texture-Values-纹理值" class="headerlink" title="Texture Values 纹理值"></a>Texture Values 纹理值</h3><p><strong>在匹配函数生成纹理空间坐标后，利用坐标获取纹理值。对于图像纹理，这是由访问纹理从图像中检索texel信息。这一过程将在第6.2节中详细讨论。图像纹理构成了实时工作中纹理使用的绝大部分，但过程函数也可以使用。在过程纹理的情况下，从纹理空间位置获取纹理值的过程不涉及内存查找，而是函数的计算。过程纹理将在章节6.3中进一步描述。</strong></p>
<p><strong>最直接的纹理值是RGB三元组，用于替换或修改表面颜色;类似地，可以返回单个灰度值。另一种要返回的数据类型是RGBα，如第5.5节所述。α (alpha)值通常是颜色的不透明度，它决定了颜色可能影响像素的程度。也就是说，任何其他值都可以存储，比如表面粗糙度。还有许多其他类型的数据可以存储在图像纹理中，这将在凹凸贴图的详细讨论中看到(章节6.7)。</strong></p>
<p><strong>从纹理返回的值在使用前可选地转换。这些转换可以在着色器程序中执行。一个常见的例子是将数据从无符号范围(0.0，1.0)映射到有符号范围(−1.0，1.0)，这用于在颜色纹理中存储着色法线。</strong></p>
<h2 id="Image-Texturing-图像纹理"><a href="#Image-Texturing-图像纹理" class="headerlink" title="Image Texturing 图像纹理"></a>Image Texturing 图像纹理</h2><p><strong>在图像纹理化中，一个二维图像有效地粘在一个或多个三角形的表面上。我们已经走过了计算纹理空间位置的过程;现在，我们将讨论从给定位置的图像纹理中获取纹理值的问题和算法。在本章的其余部分，图像纹理将被简单地称为纹理。此外，当我们在这里提到一个像素的单元格时，我们指的是围绕该像素的屏幕网格单元格。正如在第5.4.1节中讨论的，像素实际上是显示的颜色值，它可以(为了更好的质量)受到其相关网格单元之外的样本的影响。</strong></p>
<p><strong>在本节中，我们特别关注快速采样和过滤纹理图像的方法。第5.4.2节讨论了走样问题，特别是渲染对象的边缘。纹理也可能有采样问题，但它们发生在被渲染的三角形内部。</strong></p>
<p><strong>像素着色器通过将纹理坐标值传递给一个调用(如texture2D)来访问纹理。这些值是(u, v)纹理坐标，由匹配函数映射到范围[0.0,1.0]。GPU负责将这个值转换为texel坐标。不同API中的纹理坐标系统有两个主要的区别。在DirectX中，纹理的左上角是(0,0)，右下角是(1,1)。这与存储数据的图像类型的数量相匹配，顶部的行是文件中的第一行。在OpenGL中，texel(0,0)位于左下角，与DirectX的y轴翻转。Texels有整数坐标，但是我们经常想要访问Texels之间的位置并混合它们。这就引出了一个问题，即像素中心的浮点坐标是什么。Heckbert讨论了如何有两种可能的系统:截断和舍入。DirectX 9定义每个中心在(0.0,0.0)：这使用舍入。这个系统有点混乱，因为在DirectX的原点，左上角像素的左上角，然后有值(−0.5，−0.5)。DirectX 10进一步改变了OpenGL的系统，texel的中心有分数值(0.5,0.5)：截断，或者更准确地说，flooring，丢弃分数。flooring是一个更自然的系统，可以很好地映射到语言，例如，在像素(5,9)中，u坐标的范围从5.0到6.0,v坐标的范围从9.0到10.0。</strong></p>
<p><strong>在这一点上一个值得解释的术语是依赖纹理读取，它有两种定义。第一种尤其适用于移动设备。当通过texture2D或类似方法访问纹理时，当像素着色器计算纹理坐标而不是使用从顶点着色器传入的未经修改的纹理坐标时，就会发生依赖纹理读取。注意，这意味着对传入纹理坐标的任何更改，甚至是交换u和v值这样的简单操作。旧的移动GPU，那些不支持OpenGL ES 3.0的，当着色器没有依赖的纹理读取时运行得更高效，因为texel数据可以被预取。这个术语的另一个较早的定义对于早期的桌面GPU尤其重要。在这种情况下，当一个纹理的坐标依赖于一些先前纹理值的结果时，就会发生依赖性纹理读取。例如，一个纹理可能会改变着色法线，这反过来又会改变用于访问立方体映射的坐标。这种功能在早期的GPU上是有限的，甚至不存在。如今，此类读取可能会对性能产生影响，这取决于批处理中计算的像素数量以及其他因素。有关更多信息，请参阅23.8节。</strong></p>
<p><strong>GPU中使用的纹理图像大小通常为2^m ×2^n texels，其中m和n是非负整数。这些被称为2的幂次(POT)纹理。现代GPU可以处理任意大小的非2幂次(NPOT)纹理，这允许生成的图像被当作纹理处理。然而，一些旧的移动GPU可能不支持NPOT纹理的mipmapping(章节6.2.2)。图形加速器在纹理大小上有不同的上限。例如，DirectX 12允许最大16384²像素。</strong></p>
<p><strong>假设我们有一个大小为256 × 256像素的纹理，我们想把它用作一个正方形的纹理。只要投影在屏幕上的方块与纹理的大小大致相同，方块上的纹理看起来就几乎和原始图像一样。但是，如果投影的正方形所覆盖的像素是原始图像的10倍(称为放大)，或者投影的正方形只覆盖屏幕的一小部分(称为缩小)，会发生什么呢?答案是，这取决于您决定对这两种不同的情况使用哪种抽样和过滤方法。</strong></p>
<p><strong>本章讨论的图像采样和滤波方法应用于从每个纹理读取的值。然而，理想的结果是在最终渲染的图像中防止走样，这在理论上需要对最终像素的颜色进行采样和过滤。这里的区别是过滤着色方程的输入，还是过滤输出。只要输入和输出是线性相关的(这是真的对于输入，如颜色)，然后过滤个别纹理值相当于过滤最终的颜色。然而，许多着色器输入值存储在纹理中，如表面法线和粗糙度值，与输出有非线性关系。标准的纹理过滤方法可能不能很好地处理这些纹理，导致走样。改进的纹理过滤方法将在9.13节中讨论。</strong></p>
<h3 id="Magnification-放大"><a href="#Magnification-放大" class="headerlink" title="Magnification 放大"></a>Magnification 放大</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920211152.png" class="" title="image-20210920211152">

<p>将48 × 48的图像纹理放大到320 × 320像素。左:最近的邻域过滤，其中最近的像素被选择。中:使用4个最接近像素的加权平均的双线性滤波。右图:使用5 × 5最接近像素的加权平均值进行立方滤波。</p>
<p><strong>在上图中，一个大小为48 × 48 texels的纹理被纹理到一个正方形上，并且这个正方形相对于纹理大小被观察得相当近，所以底层的图形系统必须放大纹理。最常见的放大滤波技术是最近邻滤波(实际的滤波器称为框式滤波器，见第5.4.1节)和双线性插值。还有立方卷积，它使用4 × 4或5 × 5像素数组的加权和。这使得更高的放大质量成为可能。虽然原生硬件支持三次卷积(也称为双三次插值)目前并不普遍，但它可以在一个着色程序中执行。</strong></p>
<p><strong>在图的左边部分，使用了最近邻法。这种放大技术的一个特点是，单个像素可能变得明显。这种效果被称为像素化，因为该方法在放大时取离每个像素中心最近的像素值，从而产生块状外观。虽然这种方法的质量有时很差，但它只需要为每个像素取一个像素。</strong></p>
<p><strong>在同一图形的中间图像中，使用了双线性插值(有时称为线性插值)。对于每个像素，这种滤波找到四个相邻的像素，并在二维线性插值，以找到像素的混合值。结果变得更加模糊，使用最近邻法产生的许多锯齿都消失了。作为一个实验，试着看看左边的图像当你眯眼的时候，这和低通滤镜的效果差不多，会让你的脸看起来更明显一些。</strong></p>
<p><strong>之前的砖块纹理示例:在不删除碎片的情况下，我们得到了(pu,pv) =(81.92, 74.24)。我们在这里使用OpenGL的左下角原点texel坐标系统，因为它匹配标准笛卡尔坐标系。我们的目标是在四个最接近的像素之间插入，使用它们的像素中心定义一个像素大小的坐标系统。参见下图。为了找到4个最近的像素，我们从样本位置中减去像素中心分数(0.5,0.5)，得到(81.42,73.74)。去掉分数，最接近的四个像素的范围从(x, y) =(81,73)到(x+1, y+1) =(82,74)。在我们的例子中，小数部分(0.42,0.74)是样品相对于由四个texel中心组成的坐标系的位置。我们把这个位置表示为(u′, v′)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920211533.png" class="" title="image-20210920211533">

<p>双线性插值。所涉及的四个像素由左边的四个正方形表示，像素中心为蓝色。右边是由四个像素的中心组成的坐标系。</p>
<p><strong>定义纹理访问函数为t(x, y)，其中x和y是整数，并返回texel的颜色。任何位置(u’,v’)的双线性插值颜色可以通过两步计算。首先,texel底部,t (x, y)和t (x + 1, y),将被内插水平(使用u ‘),同样的最上面的两个texel t (x,y+1)和t (x+1,y+1)。texel底部,我们获得(1−u ‘) t (x, y) + u′(x + 1, y)(上图中下方绿色圆圈),顶部,(1−u ‘) t (x, y + 1) + u′(x + 1, + 1)(顶部绿色圆圈)。然后垂直插入这两个值(使用v′)，因此双线性插值颜色b在(pu,pv)是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920212007.png" class="" title="image-20210920212007">

<p><strong>直观地说，离样本位置越近的texel对最终值的影响越大。这就是我们在这个方程中看到的。右上角的texel (x+1, y +1)有u ‘ v ‘的影响。注意它的对称性:右上角的影响等于左下角和样本点形成的矩形的面积。回到我们的例子，这意味着从texel中获取的值将乘以0.42 × 0.74，具体来说是0.3108。顺时针方向上，其他乘数分别为0.42 × 0.26、0.58 × 0.26和0.58 × 0.74，这四个权重之和为1.0。</strong></p>
<p><strong>一种常见的解决方法是使用细节纹理。这些纹理代表了细微的表面细节，从手机上的划痕到地形上的灌木丛。这样的细节以不同的比例叠加在放大的纹理上作为一个单独的纹理。细节纹理的高频重复图案，结合低频放大纹理，具有类似于使用单一高分辨率纹理的视觉效果。</strong></p>
<p><strong>双线性插值在两个方向上进行线性插值。然而，线性插值是不需要的。假设一个纹理由棋盘图案中的黑色和白色像素组成。使用双线性插值在纹理上给出不同的灰度样本。通过重新映射，例如，所有低于0.4的灰色都是黑色的，所有高于0.6的灰色都是白色的，而那些介于两者之间的灰色被拉伸以填补空白，纹理看起来更像一个棋盘，同时也在像素之间提供了一些混合。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920212226.png" class="" title="image-20210920212226">

<p>最近邻，双线性插值，以及通过重映射的部分方法，使用相同的2 × 2棋盘格纹理。请注意，由于纹理和图像网格不完全匹配，最近邻采样给出的正方形大小略有不同。</p>
<p><strong>使用更高分辨率的纹理也会有类似的效果。例如，想象每个方格由4 × 4像素组成，而不是1 × 1像素。在每个格子的中心，插值的颜色将是全黑或全白。</strong></p>
<p><strong>在本节开头图片的右边，使用了一个双三次滤波器，剩余的块性被很大程度上去除了。需要注意的是，双三次滤波器比双线性滤波器更昂贵。然而，许多高阶滤波器可以表示为重复线性插值(另见第17.1.1节)。因此，纹理单元中用于线性插值的GPU硬件可以通过多次查找来开发。</strong></p>
<p><strong>如果认为双三次滤波器太昂贵，Qu´ılez提出了一种简单的技术，使用平滑曲线在一组2 × 2像素之间进行插值。我们先描述曲线，然后操作。两种常用的曲线是平滑曲线和五次曲线:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920212549.png" class="" title="image-20210920212549">

<p><strong>这对于想要从一个值到另一个值平滑地插入。平滑曲线具有性质s′(0) =s′(1)，且在0和1之间平滑。五次曲线具有相同的性质，但也有q“(0)= q”(1)= 0，即二阶导数在曲线的起点和终点也是0。如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920212817.png" class="" title="image-20210920212817">

<p>平滑曲线s(x)(左)和五次曲线q(x)(右)。</p>
<p><strong>该技术首先计算(u’，v’)，方法是先将样本乘以纹理尺寸并添加0.5。整数部分留待以后使用，分数存储在u ‘和v ‘中，其取值范围为[0,1]。(u′, v′)变换为(tu,tv) = (q (u′),q(v′)，仍然在[0,1]的范围内。最后，减去0.5并将整数部分加回去;然后得到的u坐标除以纹理宽度，v也是如此。在这一点上，新的纹理坐标与GPU提供的双线性插值查找一起使用。注意，这种方法将在每个像素上给出一个平台，这意味着如果像素位于RGB空间的一个平面上，那么这种类型的插值将给出一个平滑的，但仍然是阶梯状的外观，这可能并不总是想要的。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920213045.png" class="" title="image-20210920213045">

<p>四种不同的方法来放大一维纹理。橙色的圆圈表示像素的中心以及像素值(高度)。从左到右:最近邻，线性，使用五次曲线之间的每对相邻像素，并使用三次插值。</p>
<h3 id="Minification-缩小"><a href="#Minification-缩小" class="headerlink" title="Minification 缩小"></a>Minification 缩小</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920213227.png" class="" title="image-20210920213227">

<p>缩小:通过一排像素单元查看棋盘纹理的正方形，大致显示像素数量如何影响每个像素。</p>
<p><strong>当一个纹理被最小化时，几个像素可能会覆盖一个像素的单元格，如上图所示。要为每个像素获得正确的颜色值，您应该集成影响像素的像素的效果。然而，很难精确地确定特定像素附近所有像素的确切影响，而且实际上不可能在实时中完美地做到这一点。</strong></p>
<p><strong>由于这个限制，GPU上使用了几种不同的方法。一种方法是使用最近邻，它的工作原理与相应的放大滤波器完全一样，即它选择在像素单元格中心可见的像素。这个过滤器可能会导致严重的走样问题。在下图中，最上面的图使用了最近邻。朝向视界时，会出现伪影，因为影响一个像素的众多像素中只有一个被选择来代表表面。当表面相对于观察者移动时，这样的伪影更加明显，并且是所谓的时间走样的一种表现。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920213348.png" class="" title="image-20210920213348">

<p>顶部图像采用点采样(最近邻)，中心采用mipmapping，底部采用求和区域表。</p>
<p><strong>另一种常用的滤波器是双线性插值，它的工作原理与放大滤波器完全相同。在缩小方面，这个过滤器只比最近邻方法稍好一点。它混合了四个像素而不是仅仅使用一个，但当一个像素受到超过四个像素的影响时，过滤器很快就会失效并产生走样。</strong></p>
<p><strong>更好的解决方案是存在的。如第5.4.1节所述，走样问题可以通过采样和滤波技术来解决。纹理的信号频率取决于其像素在屏幕上的间距。由于奈奎斯特限制，我们需要确保纹理的信号频率不大于样本频率的一半。例如，假设一幅图像由交替的黑白线条组成，间隔一个像素。波长是两个像素宽(从黑线到黑线)，所以频率是1/2 ．为了在屏幕上正确地显示纹理，频率必须至少为2×1/2,即每像素至少一个像素。所以，对于一般的纹理，每个像素最多应该有一个像素，以避免走样。</strong></p>
<p><strong>为了实现这一目标，要么像素的采样频率必须增加，要么纹理频率必须降低。前面讨论的抗锯齿方法第三章给出了提高像素采样率的方法。然而，这些方法只增加了有限的采样频率。为了更全面地解决这个问题，人们开发了各种纹理缩小算法。</strong></p>
<p><strong>所有纹理抗锯齿算法背后的基本思想都是一样的:对纹理进行预处理，并创建数据结构，以帮助计算一组像素对一个像素的影响的快速近似。对于实时性工作，这些算法具有使用固定的时间和资源执行的特点。通过这种方式，每个像素采集固定数量的样本，并结合起来计算(可能是巨大的)像素数量的效果。</strong></p>
<h4 id="Mipmapping-映射"><a href="#Mipmapping-映射" class="headerlink" title="Mipmapping 映射"></a>Mipmapping 映射</h4><p><strong>最通用的纹理反走样方法叫做mipmapping。它以某种形式在所有图形加速器上实现。“Mip”代表parvo中的multum，拉丁语的意思是“小地方的许多东西”——这个名字很好地描述了一种将原始纹理反复过滤成更小图像的过程。</strong></p>
<p><strong>当使用mipmapping最小化过滤器时，在实际渲染之前，原始纹理会被一组更小的纹理增强的地方。纹理(在0级)被向下采样到原始区域的四分之一，每个新的像素值通常被计算为原始纹理中四个相邻像素的平均值。新的一级纹理有时被称为原始纹理的子纹理。缩减是递归执行，直到纹理的一个或两个维度等于一个texel。这个过程如图所示。整个图像集通常称为mipmap链。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920213940.png" class="" title="image-20210920213940">

<p>mipmap是通过取金字塔底部的原始图像(第0层)，并在下一层将每个2 × 2区域平均为一个texel值而形成的。垂直轴是第三个纹理坐标d。在图中，d不是线性的;它是一个样本用于插值的两个纹理级别的度量。</p>
<p><strong>形成高质量mipmap的两个重要因素是良好的滤波和伽马校正。形成一个mipmap级别的常见方法是取每个2 × 2像素集，并将它们平均得到mip像素值。使用的过滤器是盒状过滤器，可能是最糟糕的过滤器之一。这可能会导致质量差，因为它会不必要地模糊低频，同时保留一些导致走样的高频。最好使用Gaussian, Lanczos, Kaiser或类似的滤波器;该任务有快速、免费的源代码，一些API支持GPU本身更好的过滤。在纹理的边缘附近，在过滤时必须注意纹理是重复的还是单个副本。</strong></p>
<p><strong>对于编码在非线性空间中的纹理(如大多数颜色纹理)，在滤波时忽略gamma校正将修改感知到的mipmap水平亮度。当你离物体越远，使用未校正的mipmaps时，物体整体看起来越暗，对比度和细节也会受到影响。出于这个原因，将这些纹理从sRGB转换为线性空间(章节5.6)是很重要的，在该空间中执行所有的mipmap过滤，并转换结果返回到sRGB颜色空间进行存储。大多数API都支持sRGB纹理，因此可以在线性空间中正确生成mipmaps，并将结果存储在sRGB中。当sRGB纹理被访问时，它们的值首先被转换为线性空间，以便正确地执行放大和缩小。</strong></p>
<p><strong>正如前面提到的，一些纹理与最终的着色颜色具有基本的非线性关系。虽然这通常会给过滤带来问题，但mipmap生成对这个问题特别敏感，因为要过滤成百上千个像素。为了获得最好的结果，通常需要专门的mipmap生成方法。这些方法的详细内容见章节9.13。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920214236.png" class="" title="image-20210920214236">

<p>左边是一个方形像素单元格及其纹理视图。右边是像素单元到纹理本身的投影。</p>
<p><strong>使用纹理的基本过程很简单。屏幕像素包含纹理本身的一个区域。当像素的区域被投影到纹理上时(上图)，它包含一个或多个像素。使用像素的单元格边界并不严格正确，但在这里是用来简化表示的。单元格外的像素会影响像素的颜色;5.4.1之前看到的部分。目标是粗略地确定纹理对像素的影响程度。有两个常用的度量方法用于计算d (OpenGL调用λ，它也被称为纹理细节级别)。一种是利用像素单元形成的四边形的长边来近似像素的覆盖范围;另一种方法是使用∂u/∂x、∂v/∂x、∂u/∂y和∂v/∂y的四个微分的最大绝对值。每个差异都是相对于屏幕轴的纹理坐标变化量的度量。例如，∂u/∂x是沿着x屏幕轴的一个像素的u纹理值的变化量。有关这些方程的更多信息，请参阅Williams的原始文章或Flavell或Pharr的文章。McCormack等人讨论了通过最大绝对值法引入走样，并提出了一个替代公式。Ewins等人分析了几种质量相当的算法的硬件成本。</strong></p>
<p><strong>这些渐变值可用于使用shader Model 3.0或更新版本的像素着色程序。由于它们是基于相邻像素值之间的差异，它们不能在受动态流控制影响的像素着色部分中访问(章节3.8)。对于要在这样一个部分中执行纹理读取(例如，在循环中)，导数必须提前计算。注意，由于顶点着色器不能访问梯度信息，所以梯度或细节级别需要在顶点着色器本身中计算，并在使用顶点纹理时提供给GPU。</strong></p>
<p><strong>计算坐标d的目的是确定沿着mipmap的金字塔轴在哪里取样。目标是像素与像素的比例至少为1:1，以达到奈奎斯特速率。这里的重要原则是，当像素单元包含更多的像素和d增加时，就会访问一个更小、更模糊的纹理版本。(u, v, d)三元组用于访问mipmap。值d类似于纹理级别，但d不是整数值，而是级别之间距离的小数值。对d位置上方和下方的纹理层进行采样。(u, v)位置用于从这两个纹理级别中检索双线性插值样本。然后，根据每个纹理级别到d的距离，对得到的样本进行线性插值。整个过程称为三线性插值，并按每个像素执行。</strong></p>
<p><strong>一个用户对d坐标的控制是详细程度偏差(LOD偏差)。这是d的附加值，因此它会影响纹理的相对感知锐度。如果我们继续向上移动金字塔开始(增加d)，纹理看起来会更模糊。对于任何给定的纹理，一个好的LOD偏差将随图像类型和使用方式而变化。例如，一开始有些模糊的图像可以使用负面偏见，而用于纹理处理的糟糕过滤(别名)合成图像可以使用正面偏见。偏差可以为整个纹理指定，或者在像素着色器中按像素指定。为了更好地控制，用户可以提供d坐标或用于计算它的导数。</strong></p>
<p><strong>mipmapping的好处是，它不是试图将影响一个像素的所有像素相加，而是访问并插值预组合的像素集。这个过程需要固定数量的时间，无论缩小的数量是多少。然而，mipmapping存在一些缺陷。一个主要的问题是过度模糊。假设一个像素单元在u方向上覆盖大量像素，而在v方向上只覆盖少量像素。这种情况通常发生在观察者沿着纹理表面几乎是边对边看的时候。事实上，可能需要沿着纹理的一个轴缩小，沿着纹理的另一个轴放大。访问mipmap的效果是检索纹理上的正方形区域;无法检索矩形区域。为了避免走样，我们选择像素单元在纹理上近似覆盖的最大度量。这导致检索到的样本往往相对模糊。</strong></p>
<h4 id="Summed-Area-Table-求和区域表"><a href="#Summed-Area-Table-求和区域表" class="headerlink" title="Summed-Area Table 求和区域表"></a>Summed-Area Table 求和区域表</h4><p><strong>另一种避免过度模糊的方法是求和面积表(SAT)。要使用此方法，首先创建一个数组，该数组是纹理的大小，但包含存储颜色的更多精度位(例如，红色、绿色和蓝色，每个颜色精度为16位或更多)。在这个数组中的每个位置，必须计算并存储由这个位置和texel(0,0)(原点)组成的矩形中所有对应纹理的texel之和。在纹理过程中，像素单元在纹理上的投影被一个矩形绑定。然后访问求和区域表以确定该矩形的平均颜色，该颜色作为像素的纹理颜色传回。使用如图所示的矩形纹理坐标计算平均值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920214817.png" class="" title="image-20210920214817">

<p>像素单元被反向投影到纹理上，由矩形绑定;矩形的四个角用于访问求和区域表。</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920214909.png" class="" title="image-20210920214909">

<p><strong>这里，x和y是矩形的texel坐标，s[x, y]是该texel的面积之和。这个方程是这样的:取从右上角到原点的整个面积的和，然后减去相邻角的贡献，减去面积A和面积B。面积C被减去了两次，所以它被左下角加了回去。请注意,(xll,yll)是C区的右上角，即(xll + 1, yll + 1)是边界框的左下角。</strong></p>
<p><strong>使用求和区域表的结果如节首图最下所示。往地平线的线在右边边缘附近更尖锐，但中间的对角线仍然过模糊。问题是，当沿着其对角线观看纹理时，会生成一个大的矩形，其中许多像素位于被计算的像素附近。例如，在上图中，想象一个长而细的矩形，表示像素单元的反向投影对角地横过整个纹理。将返回整个纹理矩形的平均值，而不仅仅是像素单元格内的平均值。</strong></p>
<p><strong>求和面积表是所谓各向异性滤波算法的一个例子。这种算法在非正方形区域上检索texel值。然而，SAT能够在水平和垂直方向上最有效地做到这一点的方向。还需要注意的是，对于大小为16 × 16或更小的纹理，求和区域表至少需要两倍的内存，对于更大的纹理，则需要更高的精度。</strong></p>
<p><strong>求和区域表以合理的总体内存成本提供更高的质量，可以在现代GPU上实现。改进的过滤对高级渲染技术的质量是至关重要的。例如，Hensley等人提供了一种有效的实现，并展示了汇总区域采样如何改善光泽反射。其他采用面积采样的算法，如景深、阴影图、模糊反射等，都可以通过SAT进行改进。</strong></p>
<h4 id="Unconstrained-Anisotropic-Filtering-无约束各向异性过滤"><a href="#Unconstrained-Anisotropic-Filtering-无约束各向异性过滤" class="headerlink" title="Unconstrained Anisotropic Filtering 无约束各向异性过滤"></a>Unconstrained Anisotropic Filtering 无约束各向异性过滤</h4><p><strong>对于当前的图形硬件，进一步改进纹理过滤最常用的方法是重用现有的mipmap硬件。其基本思想是像素单元被反向投影，然后对纹理上的这个四边形进行多次采样，并将这些采样进行组合。如上所述，每个mipmap样本都有一个位置和与之相关联的正方形区域。该算法不是使用单一的mipmap样本来近似这个四边形的覆盖范围，而是使用几个正方形来覆盖这个四边形。短边的四边形可以用来确定d(不像在mipmapping，在那里较长的边经常使用);这使得每个mipmap样本的平均面积更小(也更不模糊)。四边形的较长边用来创建一条平行于较长边并穿过四边形中间的各向异性线。当各向异性量在1:1到2:1之间时，沿这条线取两个样品(见下图)。在较高的各向异性比率下，沿轴取的样品越多。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920215307.png" class="" title="image-20210920215307">

<p>各向异性过滤。像素单元格的反向投影创建一个四边形。在较长的边之间形成了一条各向异性线。</p>
<p><strong>该方案允许各向异性线向任何方向运行，因此没有求和面积表的限制。它也不需要比mipmap更多的纹理内存，因为它使用mipmap算法来进行采样。下图是一个各向异性滤波的例子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920215441.png" class="" title="image-20210920215441">

<p>Mipmap与各向异性滤波。在左边做了三线性mipmapping，在右边做了16:1各向异性滤波。向视界方向，各向异性滤波提供了更清晰的结果，并具有最小的走样。(图片来自three.js示例webgl材质纹理各向异性[218]。)</p>
<p><strong>沿轴采样的想法最早是由Schilling等人通过他们的Texram动态存储设备提出的。Barkans描述了该算法在Talisman系统中的使用。McCormack等人提出了一个名为“Feline”的类似系统。Texram的原始配方是沿各向异性轴(也称为探针)给予相同权重的样品。Talisman给予轴两端相对的两个探头一半的重量。Feline使用高斯滤波器核来加权探测器集。这些算法接近高质量的软件采样算法，如椭圆加权平均(EWA)滤波器，它将像素的影响区域转换为纹理上的椭圆，并通过滤波核对椭圆内的像素进行加权。Mavridis和Papaioannou提出了几种使用着色器代码在GPU上实现EWA滤波的方法。</strong></p>
<h3 id="Volume-Textures-体积纹理"><a href="#Volume-Textures-体积纹理" class="headerlink" title="Volume Textures 体积纹理"></a>Volume Textures 体积纹理</h3><p><strong>图像纹理的直接扩展是通过(u, v, w)(或(s, t, r)值)访问的三维图像数据。例如，医学影像数据可以生成为三维网格;通过在网格中移动一个多边形，可以看到这些数据的二维切片。一个相关的想法是用这种形式来表示体积光。在一个表面上的一个点上的照明是通过找到它在这个体积内的位置的值，结合光的方向来找到的。</strong></p>
<p><strong>大多数GPU支持mipmapping的卷纹理。由于在体积纹理的单个mipmap级别内的过滤涉及三线性插值，在mipmap级别之间的过滤需要四线性插值。由于这涉及到平均16像素的结果，可能会导致精度问题，这可以通过使用更高精度的体积纹理来解决。Sigg和Hadwiger讨论了这个问题以及与体积纹理相关的其他问题，并提供了执行过滤和其他操作的有效方法。</strong></p>
<p><strong>尽管体积纹理有更高的存储要求和更昂贵的过滤，他们确实有一些独特的优势。由于三维位置可以直接用作纹理坐标，因此可以跳过为三维网格寻找良好的二维参数化的复杂过程。这避免了在二维参数化中经常出现的变形和接缝问题。体积纹理也可以用来表示木材或大理石等材料的体积结构。一个带有这种纹理的模型看起来就像是用这种材料雕刻出来的。</strong></p>
<p><strong>使用体积纹理的表面纹理是非常低效的，因为绝大多数的样本没有被使用。Benson and Davis和DeBry等讨论了用八叉树结构存储纹理数据。这个方案很适合交互式三维绘画系统，因为表面在创建时不需要明确的纹理坐标，并且八叉树可以将纹理细节保存到所需的任何级别。Lefebvre等人讨论了在现代GPU上实现八叉树纹理的细节。Lefebvre和Hoppe讨论了一种将稀疏的体积数据打包到一个明显更小的纹理中的方法。</strong></p>
<h3 id="Cube-Maps-立方体映射"><a href="#Cube-Maps-立方体映射" class="headerlink" title="Cube Maps 立方体映射"></a>Cube Maps 立方体映射</h3><p><strong>另一种类型的纹理是立方体纹理或立方体贴图，它有6个正方形纹理，每一个都与立方体的一个面相关联。一个立方体地图是通过一个三分量的纹理坐标向量来访问的，它指定了从立方体中心向外的射线方向。射线与立方体的交点如下所示。最大的纹理坐标选择相应的面(例如，向量(−3.2,5.1，−8.4)选择−z面)。其余两个坐标除以最大幅值坐标的绝对值，即8.4。它们现在的范围从−1到1，并简单地重新映射到[0,1]以计算纹理坐标。例如,坐标(−3.2,5.1)映射到((−3.2/8.4 + 1)/ 2,(5.1/8.4 + 1)/ 2)≈(0.31,0.80)。立方体映射对于表示方向函数的值是有用的;它们最常用于环境映射(章节10.4.3)。</strong></p>
<h3 id="Texture-Representation-纹理表示"><a href="#Texture-Representation-纹理表示" class="headerlink" title="Texture Representation 纹理表示"></a>Texture Representation 纹理表示</h3><p><strong>在应用程序中处理许多纹理时，有几种方法可以提高性能。纹理压缩在第6.2.6节中进行了描述，而本节的重点是纹理图集、纹理数组和无绑定纹理，所有这些都旨在避免在渲染时更改纹理的成本。在19.10.1和19.10.2节中，描述了纹理流和转码。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920220049.png" class="" title="image-20210920220049">

<p>左:一个纹理图集，其中九个较小的图像被合成成一个单一的大纹理。右图:更现代的方法是将较小的图像设置为纹理数组，这是在大多数API中发现的概念。</p>
<p><strong>为了能够为GPU批量处理尽可能多的工作，通常最好是尽可能少地改变状态(章节18.4.2)。为此，可以将几张图像放入一个更大的纹理中，称为纹理图集。这在上图的左边进行了说明。注意，子纹理的形状可以是任意的。子纹理布局图集的优化由N¨oll和Stricker描述。还需要注意mipmap的生成和访问，因为mipmap的上层可能包含几个独立的、不相关的形状。Manson和Schaefer提出了一种优化mipmap创建的方法，该方法考虑了表面的参数化，可以产生明显更好的结果。Burley和Lacewell提出了一个名为Ptex的系统，在这个系统中，细分表面上的每个四元组都有自己的小纹理。这样做的好处是避免了在网格上分配独特的纹理坐标，并且在纹理图集的断开部分的接缝上没有工件。为了能够过滤四元组，Ptex使用邻接数据结构。虽然最初的目标是生产渲染，Hillesland提出了包装的Ptex，它将每个人脸的子纹理放入纹理图集，并使用相邻人脸的填充来避免过滤时的间接。Yuksel提出了网格颜色纹理，改进了Ptex。Toth为ptex类系统提供高质量的面部过滤，通过实现一种方法，如果过滤超出[0,1]²的范围就会被丢弃。</strong></p>
<p><strong>使用图集的一个困难是包裹/重复和镜像模式，这将不会正确地影响子纹理，而只是作为一个整体的纹理。在为图集生成mipmaps时可能会出现另一个问题，其中一个子纹理可能会相互渗透。然而，可以通过为每个子纹理分别生成mipmap层次结构，然后将它们放入一个大型纹理图集中，并对子纹理使用2次幂分辨率来避免这一问题。</strong></p>
<p><strong>对于这些问题，一个更简单的解决方案是使用一个称为纹理数组的API构造，它完全避免了与mipmapping和重复模式有关的任何问题。如上图的右侧所示。纹理数组中的所有子纹理都需要有相同的尺寸、格式、mipmap层次结构和MSAA设置。像纹理图集一样，纹理数组的设置只做一次，然后任何数组元素都可以使用着色器中的索引访问。这比绑定每个子纹理快5倍。</strong></p>
<p><strong>API支持无绑定纹理也是一个有助于避免状态更改成本的特性。如果没有绑定纹理，则使用API将纹理绑定到特定的纹理单元。一个问题是纹理单元的上限，这使程序员的工作变得复杂。驱动程序确保纹理驻留在GPU一侧。对于无绑定纹理，没有纹理数量的上限，因为每个纹理仅通过64位指针(有时称为句柄)关联到其数据结构。这些句柄可以通过许多不同的方式访问，例如，通过制服，通过不同的数据，从其他纹理，或从一个着色器存储缓冲对象(SSBO)。应用程序需要确保纹理驻留在GPU一侧。无绑定纹理避免了驱动程序中任何类型的绑定成本，这使得渲染速度更快。</strong></p>
<h3 id="Texture-Compression-纹理压缩"><a href="#Texture-Compression-纹理压缩" class="headerlink" title="Texture Compression 纹理压缩"></a>Texture Compression 纹理压缩</h3><p><strong>一种直接解决内存、带宽和缓存问题的解决方案是固定速率的纹理压缩。通过让GPU快速解码压缩纹理，纹理可以占用更少的纹理内存，从而增加有效缓存的大小。至少同样重要的是，这样的纹理使用起来更有效，因为它们在访问时消耗的内存带宽更少。一个相关但不同的用例是添加压缩以提供更大的纹理。例如，在5122分辨率下，使用每像素3字节的非压缩纹理将占用768 kB。使用压缩比为6:1的纹理压缩，10242个纹理只占用512kb。</strong></p>
<p><strong>图像文件格式(如JPEG和PNG)中使用了多种图像压缩方法，但在硬件中实现这些方法的解码代价很高(关于纹理转码的信息，请参见19.10.1节)。S3开发了一个名为S3纹理压缩(S3TC)的方案，被选为DirectX的标准，称为DXTC，在DirectX 10中称为BC(块压缩)。此外，它是OpenGL上的标准，因为几乎所有的GPU都支持它。它的优点是创建大小固定的压缩图像，具有独立的编码片段，而且解码简单(因此也快速)。图像的每个压缩部分都可以独立于其他部分进行处理。没有共享的查询表或其他依赖项，这简化了解码。</strong></p>
<p><strong>DXTC/BC压缩方案有7种变体，它们有一些共同的属性。编码是在4 × 4像素块上完成的，也称为tiles。每个块被单独编码。编码是基于插值的。对于每个编码量，存储两个参考值(例如，颜色)。一个插值因子被保存为每个16像素块。它沿着两个参考值之间的线选择一个值，例如，等于或从存储的两个值中插入一个颜色。这种压缩来自于只存储两种颜色以及每个像素的短索引值。</strong></p>
<p><strong>这七个变量之间的确切编码是不同的，下表对其进行了总结。注意，“DXT”表示DirectX 9中的名称，“BC”表示DirectX 10及以上的名称。从表中可以看出，BC1有两个16位参考RGB值(5位红色，6位绿色，5位蓝色)，每个texel有一个2位插值因子从一个参考值或两个中间值中选择。这表示纹理压缩比为6:1，与未压缩的24位RGB纹理相比。BC2以与BC1相同的方式编码颜色，但为量化(原始)alpha增加了每像素4位(bpt)。对于BC3，每个块都有与DXT1块相同的方式编码的RGB数据。此外，alpha数据使用两个8位参考值和一个每像素3位插值因子进行编码。每个texel可以选择一个参考alpha值或六个中间值中的一个。BC4只有一个通道，在BC3中被编码为alpha。BC5包含两个通道，每个通道按照BC3中的编码方式进行编码。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920221009.png" class="" title="image-20210920221009">

<p>纹理压缩格式。所有这些压缩块都是4 × 4像素。存储列显示每个块的字节数(B)和每个texel的比特数(bpt)。参考颜色的表示法首先是通道，然后是每个通道的位数。例如，RGB565表示红色和蓝色为5位，绿色通道为6位。</p>
<p><strong>BC6H适用于高动态范围(HDR)纹理，其中每个像素最初有每个R, G和B通道的16位浮点值。这种模式使用16字节，结果是8个bpt。它对一行有一种模式(类似于上面的技术)，对两行有另一种模式，其中每个块可以从一组小的分区中进行选择。两种参考颜色也可以进行增量编码以获得更好的精度，并且根据使用的模式也可以具有不同的精度。在BC7中，每个块可以有1到3行，并存储8个bpt。目标是8位RGB和RGBA纹理的高质量纹理压缩。它与BC6H共享许多属性，但它是LDR纹理的格式，而BC6H是HDR的格式。注意，在OpenGL中，BC6H和BC7分别称为BPTC FLOAT和BPTC。这些压缩技术可以应用于立方体或体积纹理，以及二维纹理。</strong></p>
<p><strong>这些压缩方案的主要缺点是有损。也就是说，通常无法从压缩版本中检索到原始图像。在BC1-BC5的情况下，仅使用4或8个插值值来表示16个像素。如果一个贴图中有更多不同的值，就会有一些损失。在实践中，如果使用得当，这些压缩方案通常能提供可接受的图像保真度。</strong></p>
<p><strong>BC1-BC5的一个问题是，用于块的所有颜色都位于RGB空间的一条直线上。例如，红色、绿色和蓝色不能在单个块中表示。BC6H和BC7支持更多的线路，可以提供更高的质量。</strong></p>
<p><strong>对于OpenGL ES, API中选择了另一种名为Ericsson纹理压缩(ETC)的压缩算法。该方案具有与S3TC相同的特点，即快速解码、随机访问、无间接查找、固定速率。它将一个4 × 4像素的块编码为64位，即每像素使用4位。基本思想如下图所示。每个2 × 4块(或4 × 2，取决于哪种颜色的质量最好)存储一个基本颜色。每个块也从一个小型静态查找表中选择一组4个常量，并且块中的每个texel可以选择在该表中添加一个值。这将修改每个像素的亮度。图像质量与DXTC相当。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920221235.png" class="" title="image-20210920221235">

<p>ETC (Ericsson纹理压缩)编码像素块的颜色，然后修改每个像素的亮度来创建最终的texel颜色。(Jacob Str¨om)</p>
<p><strong>在OpenGL ES 3.0中包含的ETC2中，使用未使用的位组合来为原始ETC算法添加更多模式。未使用的位组合是压缩表示(例如64位)，它解压成与另一个压缩表示相同的图像。例如，在BC1中，将两个参考颜色设置为相同是没有用的，因为这将指示一个恒定色块，而只要有一个参考颜色包含该恒定色块，就可以获得该恒定色块。在ETC中，一种颜色也可以用带符号的数字对第一种颜色进行增量编码，因此计算可能会溢出或溢出。这些病例被用于其他压缩模式的信号。ETC2增加了两种新的模式，每种模式有四种不同的颜色，最后一种模式是RGB空间中的平面，旨在处理平滑过渡。Ericsson alpha压缩(EAC)压缩图像的一个分量(如alpha)。这种压缩类似于基本的ETC压缩，但只针对一个组件，生成的图像每像素存储4位。它可以是选择性的结合ETC2，另外两个EAC通道可以用来压缩法线(下面有更多关于这个主题的内容)。所有的ETC1、ETC2和EAC都是OpenGL 4.0核心配置文件、OpenGL ES 3.0、Vulkan和Metal的一部分。</strong></p>
<p><strong>法线映射的压缩(在第6.7.2节中讨论)需要一些注意。为RGB颜色设计的压缩格式通常不适用于普通的xyz数据。大多数方法都利用了法线是单位长度这一事实，并进一步假设其z分量是正的(对于切空间法线来说这是一个合理的假设)。这只允许存储法线的x和y分量。z分量被推导为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920221936.png" class="" title="image-20210920221936">

<p><strong>这本身会导致适度的压缩，因为只存储两个组件，而不是三个。因为大多数gpu本身不支持三组件纹理，这也避免了浪费一个组件的可能性(或者不得不在第四个组件中打包另一个数量)。进一步的压缩通常是通过将x和y分量存储在BC5/3Dc-格式纹理中来实现的。参见下图。由于每个块的参考值划分了x分量和y分量的最大值和最小值，因此可以将它们视为在xy平面上定义了一个边界框。三位插值因子允许在每个轴上选择8个值，因此包围框被划分为8 × 8的可能的法线网格。另外，可以使用两个EAC通道(用于x和y)，然后按照上面的定义计算z。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920222041.png" class="" title="image-20210920222041">

<p>左:球上的单位法线只需要编码x和y分量。右图:对于BC4/3Dc, xy平面上有一个方框，里面有8 × 8条法线可以用来表示4 × 4块法线(为了清晰起见，这里只显示4 × 4条法线)。</p>
<p><strong>在不支持BC5/3Dc或EAC格式的硬件上，一种常见的方法是使用 DXT5格式纹理并将这两个组件存储在绿色和alpha组件中(因为它们存储的精度最高)。其他两个组件未使用。</strong></p>
<p><strong>PVRTC是一种名为PowerVR的纹理压缩格式，可在Imagination Technolo- gies的硬件上使用，它最广泛的应用是在iphone和ipad上。它提供了2位和4位每像素的方案，并压缩4 × 4像素的块。该方法的核心思想是提供图像的两个低频(平滑)信号，这些信号由相邻的texel数据块和插值得到。然后1或2位每像素使用插值之间的两个信号的图像。</strong></p>
<p><strong>自适应可伸缩纹理压缩(Adaptive scalable texture compression, ASTC)的不同之处在于它将一个n × m像素的块压缩为128位。块大小范围从4 × 4到12 × 12，这导致了不同的比特率，从0.89比特每像素到8比特每像素。ASTC使用了许多紧凑索引表示的技巧，可以为每个块选择行数和端点编码。此外，ASTC可以处理每个纹理的1-4个通道以及LDR和HDR纹理。ASTC是OpenGL ES 3.2及更高版本的一部分。</strong></p>
<p><strong>以上提出的所有纹理压缩方案都是有损的，当压缩一个纹理时，可以在这个过程中花费不同的时间。在压缩上花费几秒钟甚至几分钟，你就可以获得更高的质量;因此，这通常是作为脱机预处理完成的，并被存储起来供以后使用。或者，你可以只花几毫秒的时间，结果是质量较低，但纹理可以接近实时压缩并立即使用。一个例子是天空盒(第13.3节)，当云可能轻微移动时，它大约每隔一秒再生一次。解压缩非常快，因为它是使用固定功能的硬件完成的。这种差异被称为数据压缩不对称，在这种情况下，压缩可能并且确实要比解压缩花费相当长的时间。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920230355.png" class="" title="image-20210920230355">

<p>纹理压缩时每个组件使用16位而不是8位的效果。从左到右:原始纹理，DXT1从每个组件8位压缩，DXT1从每个组件16位压缩，并在着色器中完成重正化。为了更清楚地显示效果，纹理被渲染为强光照。(图片由Anton Kaplanyan提供。)</p>
<p><strong>Kaplanyan提出了几种可以提高压缩纹理质量的方法。对于包含颜色和法线贴图的纹理，建议每个组件使用16位绘制贴图。对于颜色纹理，然后执行一个直方图重正化(对这些16位)，其效果随后在着色器中使用一个比例和偏差常数(每个纹理)。直方图归一化是一种将图像中使用的值扩展到整个范围的技术，这是一种有效的对比度增强。每个组件使用16位确保在重正化后直方图中没有未使用的槽，这减少了许多纹理压缩方案可能引入的带伪。如上图所示。此外，Kaplanyan建议，如果75%的像素高于116/255，则使用线性颜色空间纹理，否则将纹理存储在sRGB中。对于法线映射，他还注意到BC5/3Dc通常会独立于y压缩x，这意味着并不总是能找到最好的法线。相反，他建议使用以下误差度量法:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920230457.png" class="" title="image-20210920230457">

<p><strong>n是原始法线，nc 是相同的正常压缩，然后解压缩。</strong></p>
<p><strong>需要注意的是，也可以压缩不同颜色空间中的纹理，这可以用来加速纹理压缩。常用的变换是RGB→YCoCg :</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920230543.png" class="" title="image-20210920230543">

<p><strong>Y是亮度项，Co 和Cg 是色度的条款。逆变换也很简单:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920230556.png" class="" title="image-20210920230556">

<p><strong>也就是增加了一些。这两个变换是线性的，从公式是矩阵向量乘法可以看出，其本身也是线性的。这一点很重要，因为它可以存储YCoCg而不是RGB;纹理硬件仍然可以在YCoCg空间中执行过滤，然后像素着色器可以根据需要转换回RGB。需要注意的是，这个变换本身是有损的，这可能有也可能没有关系。</strong></p>
<p><strong>还有一种可逆的RGB→YCoCg变换，总结为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920230751.png" class="" title="image-20210920230751">

<p><strong>这意味着它可以在24位RGB颜色和相应的YCoCg表示之间来回转换任何损失。应该注意的是，如果RGB中的每个分量都有n位，那么Co 和Cg 每个有n + 1位来保证一个可逆的变换;Y只需要n位。Van Waveren和Casta ~ no使用有损YCoCg变换在CPU或GPU上实现对DXT5/BC3的快速压缩。他们将Y存储在alpha通道中(因为它具有最高的精确度)，而Co 和Cg 存储在RGB的前两个组件中。由于Y是分开存储和压缩的，所以压缩速度很快。对于Co——和Cg-组件时，他们找到一个二维边界框，并选择产生最佳结果的对角线框。注意，对于在CPU上动态创建的纹理，最好也压缩CPU上的纹理。当纹理通过GPU渲染创建时，通常最好也压缩GPU上的纹理。图像压缩通常使用YCoCg变换和其他亮度-色度变换，其中色度分量平均超过2 × 2像素。这减少了50%的存储空间，并且通常工作得很好，因为色度往往变化得很慢。Lee-Steere和Harmon[1015]进一步将其转换为色调-饱和度值(HSV)，在x和y上将色调和饱和度降低4倍，并将值存储为单个通道DXT1纹理。Van Waveren和Casta ~ no也描述了法线映射的快速压缩方法。</strong></p>
<p><strong>Griffin和Olano的一项研究表明，当将几种纹理应用到带有复杂着色模型的几何模型时，纹理的质量往往很低，没有任何可感知的差异。因此，根据用例，降低质量是可以接受的。Fauconneau[463]提出了DirectX 11纹理压缩格式的SIMD实现。</strong></p>
<h2 id="Procedural-Texturing-程序化纹理"><a href="#Procedural-Texturing-程序化纹理" class="headerlink" title="Procedural Texturing 程序化纹理"></a>Procedural Texturing 程序化纹理</h2><p><strong>给定一个纹理空间位置，执行图像查找是生成纹理值的一种方法。另一种方法是计算一个函数，从而定义一个过程纹理。</strong></p>
<p><strong>虽然过程纹理通常用于离线渲染应用程序，但图像纹理在实时渲染中更为常见。这是由于现代GPU中图像纹理硬件的极高效率，它可以在一秒钟内执行数十亿次纹理访问。然而，GPU架构正在朝着更便宜的计算和(相对)更昂贵的内存访问的方向发展。这些趋势使得过程纹理在实时应用程序中得到了更大的应用。</strong></p>
<p><strong>由于体积图像纹理的高存储成本，体积纹理是一个特别有吸引力的程序纹理应用程序。这种纹理可以用各种技术合成。最常见的一种方法是使用一个或多个噪声函数生成值。参见下图。噪声函数通常按连续的两个频率的幂进行采样，称为八度。每个音阶都有一个权重，通常随着频率的增加而下降，这些权重样本的总和称为湍流函数。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920231027.png" class="" title="image-20210920231027">

<p>两个使用体积纹理的实时过程纹理的例子。左边的大理石是一个半透明的体纹理，使用光线行进渲染。在右侧，物体是一个合成图像，由一个复杂的程序木着色器生成，并在真实世界的环境上合成。(左图来自shadertoy“Playing marble”，由St´ephane Guillitte提供。右图由Autodesk, Inc. Nicolas Savva提供)</p>
<p><strong>由于估计噪声函数的代价，三维阵列中的晶格点通常是预先计算的，并用于插值纹理值。有各种方法可以使用颜色缓冲混合来快速生成这些数组。Perlin提出了一种快速、实用的噪声函数采样方法，并展示了一些用途。Olano提供了噪声生成算法，允许在存储纹理和执行计算之间进行权衡。McEwan等人开发了在着色器中计算经典噪声和单纯噪声的方法，无需任何查找，源代码可用。Parberry使用动态规划将计算摊销到几个像素上，以加速噪声计算。Green给出了一种更高质量的方法，但这种方法更适合于接近交互的应用程序，因为它使用50像素的着色器指令进行一次查找。可以对Perlin提出的原始噪声函数进行改进。Cook和DeRose提出了一种称为小波噪声的替代表示，它避免了走样问题，但只增加了很小的评估成本。Liu等人使用各种噪声函数来模拟不同的木材纹理和表面处理。我们也推荐Lagae等人关于这个主题的最新报告。</strong></p>
<p><strong>其他程序性方法也是可能的。例如，细胞纹理是通过测量从每个位置到一组分散在空间中的“特征点”的距离而形成的。用不同的方法映射产生的最近距离，例如，改变颜色或着色法线，创建看起来像细胞、石板、蜥蜴皮肤和其他自然纹理的模式。Griffiths讨论了如何在GPU上高效地找到最近的邻居并生成细胞纹理。</strong></p>
<p><strong>另一种类型的程序纹理是物理模拟或其他交互过程的结果，如水波纹或扩展裂缝。在这种情况下，程序纹理可以在动态条件下产生有效的无限可变性。</strong></p>
<p><strong>在生成过程二维纹理时，参数化问题可能会比创作纹理更困难，在创作纹理时，拉伸或接缝工件可以手工润色或处理。一个解决方案是通过在表面上直接合成纹理来完全避免参数化。在复杂的表面上执行这种操作在技术上是具有挑战性的，也是一个活跃的研究领域。见Wei等人对这一领域的概述。</strong></p>
<p><strong>抗锯齿程序纹理比抗锯齿图像纹理既困难又容易。一方面，像mipmapping这样的预计算方法是不可用的，这给程序员带来了负担。另一方面，程序纹理作者拥有关于纹理内容的“内部信息”，因此可以调整它以避免走样。这对于通过叠加多个噪声函数创建的程序纹理来说尤其正确。每个噪声函数的频率都是已知的，因此任何可能导致走样的频率都可以被丢弃，实际上降低了计算成本。对于其他类型的程序纹理有各种各样的抗锯齿技术。Dorn等人讨论了以前的工作，并提出了一些重新构造纹理函数以避免高频的过程，即限制波段。</strong></p>
<h2 id="Texture-Animation-纹理动画"><a href="#Texture-Animation-纹理动画" class="headerlink" title="Texture Animation 纹理动画"></a>Texture Animation 纹理动画</h2><p><strong>应用于表面的图像不一定是静态的。例如，视频源可以用作帧与帧之间变化的纹理。</strong></p>
<p><strong>纹理坐标也不需要是静态的。应用程序设计者可以从一帧到另一帧明确地改变纹理坐标，无论是在网格数据本身，还是通过应用在顶点或像素着色器中的函数。想象一个瀑布已经被建模，并且它已经被纹理图像看起来像瀑布。假设v坐标是流动的方向。要使水移动，必须从每一帧的v坐标中减去一个量。从纹理坐标中减去纹理会使纹理本身看起来向前移动。</strong></p>
<p><strong>更精细的效果可以通过对纹理坐标应用一个矩阵来创建。除了平移，它还支持线性变换，如缩放、旋转和剪切、图像扭曲和变形变换和广义投影。许多更复杂的效果可以通过在CPU或着色器中应用函数来创建。</strong></p>
<p><strong>通过使用纹理混合技术，可以实现其他动画效果。例如，从大理石纹理开始，然后淡入皮肤纹理，就可以让雕像活过来。</strong></p>
<h2 id="Material-Mapping-材质贴图"><a href="#Material-Mapping-材质贴图" class="headerlink" title="Material Mapping 材质贴图"></a>Material Mapping 材质贴图</h2><p><strong>纹理的一个常见用法是修改材质属性，影响材质的着色方程。现实世界中的物体通常在其表面上具有不同的物质属性。为了模拟这样的物体，像素着色器可以从纹理中读取值，并在评估着色方程之前使用它们来修改材质参数。最常被纹理修改的参数是表面颜色。这种纹理被称为反照率色贴图或漫反射色贴图。然而，任何参数都可以被纹理修改:替换它，乘它，或者以其他方式改变它。例如，在下图中，三个不同的纹理被应用到一个表面，替换常量值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210922105629.png" class="" title="image-20210922105629">

<p>金属砖和灰泥。在右边是表面颜色的纹理，粗糙度(越轻越粗糙)，和凹凸贴图高度(越轻越高)。(来自three.js示例webgl tonemapping。)</p>
<p><strong>材质中纹理的使用可以更进一步。与修改等式中的参数不同，纹理可以用来控制像素着色器本身的流和功能。两个或更多的材质与不同的着色方程和参数可以应用到一个表面，通过一个纹理指定表面的哪些区域有哪些材质，导致不同的代码被执行。例如，带有一些生锈区域的金属表面可以使用纹理来指示生锈的位置，有条件地执行基于纹理查找的着色器生锈部分，或者执行闪亮的金属着色器(章节9.5.2)。</strong></p>
<p><strong>材质模型输入，如表面颜色，与材质输出的最终颜色有线性关系。因此，包含这些输入的纹理可以用标准技术过滤，并避免走样。包含非线性着色输入的纹理，如粗糙度或凹凸贴图(章节6.7)，需要更多的注意以避免走样。考虑到着色方程的过滤技术可以改善这种纹理的结果。这些技术将在9.13节中讨论。</strong></p>
<h2 id="Alpha-Mapping-Alpha贴图"><a href="#Alpha-Mapping-Alpha贴图" class="headerlink" title="Alpha Mapping Alpha贴图"></a>Alpha Mapping Alpha贴图</h2><p><strong>alpha值可以用于使用alpha混合或alpha测试的许多效果，如有效渲染树叶、爆炸和远处的物体，等等。本节讨论alpha纹理的使用，注意各种限制和解决方案。</strong></p>
<p><strong>一种与纹理相关的效果是贴花。例如，你想在茶壶上放一幅花的图片。你想要的不是整个画面，而是花存在的部分。通过给texel赋0的alpha值，你使它透明，所以它没有效果。因此，通过正确设置贴花纹理的alpha，你可以用贴花替换或混合底层表面。典型地，对应功能是使用一个透明的边界应用一个贴花的单一副本(相对于重复纹理)的表面。下图显示了如何实现贴花的示例。有关贴花的更多信息，请参阅第20.2节。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923132202.png" class="" title="image-20210923132202">

<p>一种实现贴花的方法。帧缓冲区首先用场景渲染，然后渲染一个框，对于框内的所有点，贴花纹理被投影到帧缓冲区中。最左边的texel是完全透明的，所以它不会影响帧缓冲区。黄色texel是不可见的，因为它会被投射到表面的隐藏部分。</p>
<p><strong>alpha的一个类似应用是在切割中。假设你制作了一个灌木的贴花图像，并将其应用到场景中的矩形上。原理与贴花相同，除了灌木将被绘制在它后面的任何几何图形的顶部，而不是与一个潜在的表面齐平。通过这种方式，使用单个矩形可以渲染一个具有复杂轮廓的对象。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923132629.png" class="" title="image-20210923132629">

<p>在左边，灌木纹理贴图和它下面的1位alpha通道贴图。在右边，灌木被渲染成一个矩形;通过添加第二个旋转90度的矩形副本，我们形成了一个简易的三维灌木。</p>
<p><strong>在灌木的情况下，如果你旋转观察者围绕它，效果不好，因为灌木没有厚度。一个解决方法是复制这个灌木矩形并沿着树干旋转90度。这两个矩形形成了一种简易的三维灌木，有时被称为“十字树”，从地面上看，这种效果相当有效。参见上图。Pelzer讨论了一个类似的配置，使用三个切口来代表草。在第13.6节中，我们将讨论一个名为billboarding的方法，该方法用于将这种渲染减少为一个矩形。如果观察者移动到地面以上，这种错觉就会消失，因为从上面可以看到灌木两个图样。参见下图。为了解决这个问题，可以以不同的方式添加更多的切割——切片、分支、层——以提供更有说服力的模型。第13.6.5节讨论了生成此类模型的一种方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923132806.png" class="" title="image-20210923132806">

<p>从离地面稍远的地方看“交叉树”灌木，然后再往上看，错觉就消失了。</p>
<p><strong>结合alpha贴图和纹理动画可以产生令人信服的特殊效果，如闪烁的火炬、植物生长、爆炸和大气效果。</strong></p>
<p><strong>用alpha地图渲染对象有几个选项。Alpha混合(章节5.5)允许部分透明度值，这使物体边缘和部分透明物体的抗锯齿。然而，alpha混合需要在不透明的三角形之后渲染混合的三角形，并且按照前后顺序。一个简单的交叉树是两个裁剪纹理的例子，其中没有正确的渲染顺序，因为每个四边形都在另一个四边形的前面。即使理论上可以进行排序并得到正确的顺序，但这样做通常效率很低。例如，一块土地可能有数以万计的草叶图样。每个网格对象可能由许多单独的叶片组成。显式地对每个叶片进行排序是非常不切实际的。</strong></p>
<p><strong>这个问题可以在渲染时通过几种不同的方法来改善。一种方法是使用alpha测试，即在像素着色器中有条件地丢弃alpha值低于给定阈值的片段。这是这样做的</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923133054.png" class="" title="image-20210923133054">

<p><strong>texture.a是纹理查找中的alpha值，参数alphaThreshold是用户提供的阈值，决定哪些片段将被丢弃。这个二进制可见性测试允许以任何顺序渲染三角形，因为透明的片段会被丢弃。我们通常希望对alpha为0.0的任何片段进行此操作。丢弃完全透明的片段有额外的好处，可以节省进一步的着色器处理和合并成本，并避免在z-buffer中错误地标记像素为可见的。对于切割，我们经常设置阈值高于0.0，比如，0.5或更高，然后采取进一步的步骤，然后完全忽略alpha值，不使用它来混合。这样做可以避免无序的工件。然而，质量很低，因为只有两种透明度(完全不透明和完全透明)可用。另一种解决方案是对每个模型执行两道工序——一道工序用于实心切割，它被写入z缓冲区，另一道工序用于半透明样品，它不被写入z缓冲区。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923133332.png" class="" title="image-20210923133332">

<p>上图:没有任何修正的mipmapping的alpha测试。下图:alpha测试，根据覆盖率调整alpha值。(图片来自“The Witness”，伊格纳西奥·卡斯塔。)</p>
<p><strong>alpha测试还有另外两个问题，即过度放大和过度缩小。当alpha测试与mipmapping一起使用时，如果不进行不同的处理，其效果可能无法令人信服。上图的顶部显示了一个示例，其中树的叶子变得比预期的更透明。这可以用一个例子来解释。假设我们有一个一维纹理，有四个alpha值，即(0.0,1.0,1.0,0.0)。通过平均，下一个mipmap级别变成(0.5,0.5)，然后顶层是(0.5)。现在，假设我们用αt = 0.75。当访问0级mipmap时，可以显示4个像素中的1.5像素将通过丢弃测试。然而，当访问下两个级别时，将丢弃自0.5 &lt; 0.75以来的所有内容。另一个示例请参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923133526.png" class="" title="image-20210923133526">

<p>顶部是叶子模式混合的不同mipmap级别，更高的级别缩放以提高能见度。在底部的mipmap显示它将被处理的alpha测试0.5，显示对象如何有更少的像素，因为它后退。(图片由Ben Golus提供。)</p>
<p><strong>Casta~no提供了一个在mipmap创建过程中完成的简单解决方案，该方案运行良好。对于mipmap级别k，覆盖范围ck 被定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923133648.png" class="" title="image-20210923133648">

<p><strong>其中nk 是mipmap级别k的像素数，α(k, i)是mipmap级别k在像素i处的alpha值，αt 为用户提供的alpha阈值。在这里，我们假设α(k, i) &gt; αt的结果为1，否则为0。注意，k = 0表示最低的mipmap级别，即原始图像。对于每个mipmap级别，我们找到一个新的mipmap阈值αk，而不是使用αt，例如:ck 等于c0 (或尽可能接近)。这可以使用二进制文件来完成搜索。最后，将mipmap level k中所有像素的alpha值按αt/αk比例缩放．这个方法在mipmapping的alpha测试图的底部部分使用过，在NVIDIA的纹理工具中也支持这种方法。Golus给出了一个变体，其中mipmap没有被修改，而是alpha在着色器中随着mipmap级别的增加而缩放。</strong></p>
<p><strong>Wyman和McGuire提出了一个不同的解决方案，其中之前那行代码在理论上被替换为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923134219.png" class="" title="image-20210923134219">

<p><strong>这个随机函数返回一个在[0,1]中的统一值，这意味着平均而言它将得到正确的结果。例如，如果纹理查找的alpha值是0.3，碎片将有30%的几率被丢弃。这是每像素只有一个样本的随机透明形式。在实际应用中，用哈希函数代替随机函数，以避免时空高频噪声:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923134230.png" class="" title="image-20210923134230">

<p><strong>三维哈希是通过对上述函数的嵌套调用形成的，即float hash3D(x,y,z) {return hash2D(hash2D(x,y)，z);}，它返回[0,1)中的一个数字。哈希的输入是对象空间坐标除以对象空间坐标的最大屏幕空间导数(x和y)，然后是clamp。为了获得z方向运动的稳定性，需要进一步的关注，该方法最好与时间抗锯齿技术相结合。这种技术会随着距离的增加而逐渐减弱，所以当我们靠近时，我们根本不会得到任何随机效应。该方法的优点是平均每个片段都是正确的，而Casta ~ no的方法只创建一个αk 对于每个mipmap级别。然而，这个值可能在每个mipmap级别上都不同，这可能会降低质量，并需要艺术家的干预。</strong></p>
<p><strong>Alpha测试显示放大后的纹波伪象，这可以通过预先计算Alpha图作为距离域来避免。</strong></p>
<p><strong>Alpha到覆盖，和类似的特性透明度自适应抗锯齿，取片段的透明度值，并将其转换为一个像素内覆盖的样本数量。这个想法就像5.5节中描述的screen-door透明度，但是是亚像素级的。假设每个像素有4个样本位置，一个片段覆盖了一个像素，但是由于裁剪纹理，它是25%透明(75%不透明)的。alpha到覆盖模式使碎片变得完全不透明，但它只覆盖四个样本中的三个。这个模式对于纹理重叠的草叶是有用的。由于绘制的每个样本都是完全不透明的，最近的叶子将沿着其边缘以一致的方式隐藏物体。不需要排序来正确混合半透明边缘像素，因为alpha混合是关闭的。</strong></p>
<p><strong>Alpha到覆盖范围对于抗锯齿Alpha测试是很好的，但是当Alpha混合时可以显示伪影。例如，两个具有相同alpha覆盖百分比的alpha混合片段将使用相同的亚像素模式，这意味着一个片段将完全覆盖另一个片段，而不是与它混合。Golus讨论了使用fwidth()着色器指令给内容一个清晰的边缘。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923134608.png" class="" title="image-20210923134608">

<p>不同的渲染技术的叶子纹理与部分alpha覆盖的边缘。从左到右:alpha test, alpha blend, alpha到coverage, alpha到锐化边缘覆盖。(图片由Ben Golus提供。)</p>
<p><strong>对于alpha映射的任何使用，了解双线性插值如何影响颜色值是很重要的。想象两个相邻的像素:rgbα =(255,0,0,255)是实心红色，它的邻居rgbα =(0,0,0,2)是黑色的，几乎完全透明。在两个像素之间的位置的rgbα值是多少?简单的插值给出(127,0,0,128)，结果rgb值单独是一个“调光”红色。然而，这个结果实际上并没有变暗，它是一个全红色，已经乘以了它的alpha。如果你插入alpha值，为了正确的插补，你需要确保被插补的颜色在插补之前已经被alpha预乘。例如，假设这个几乎透明的邻居被设置为rgba α =(0,255,0,2)，给出一个微小的绿色色调。这个颜色不是预先乘以alpha，当插值时，会给出结果(127,127,0,128)——微小的绿色色调突然将结果变成(预先乘以的)黄色样本。这个邻居texel的预乘版本是(0,2,0,2)，它给出了(127,1,0,128)的正确预乘结果。这个结果更有意义，因为结果的前倍增色大部分是红色，带有难以察觉的绿色色调。</strong></p>
<p><strong>忽略双线性插值的结果给出了一个预乘的结果，可能会导致贴花和裁剪对象周围的黑色边缘。“变暗”的红色结果被管线的其余部分视为未乘以的颜色，边缘变为黑色。即使使用alpha测试，这种效果也是可见的。最好的策略是在双线性插值完成之前预乘。WebGL API支持这一点，因为合成对网页很重要。然而，双线性插值通常是由GPU执行的，在执行此操作之前，着色器不能对texel值进行操作。图像不会在PNG等文件格式中预先相乘，因为这样做会失去色彩精度。当使用alpha映射时，这两个因素会导致默认的黑色边缘。一个常见的解决方法是对裁剪图像进行预处理，将透明的“黑色”像素涂上来自附近不透明像素的颜色。所有透明区域经常需要以这种方式重新绘制，手工或自动绘制，这样mipmap级别也可以避免边缘问题。同样值得注意的是，当使用alpha值形成mipmaps时应该使用预乘的值。</strong></p>
<h2 id="Bump-Mapping-凹凸贴图"><a href="#Bump-Mapping-凹凸贴图" class="headerlink" title="Bump Mapping 凹凸贴图"></a>Bump Mapping 凹凸贴图</h2><p><strong>本节描述了一大类我们统称为凹凸映射的小规模细节表示技术。所有这些方法都是通过修改逐像素着色例程来实现的。它们提供了一个比纹理映射更三维的外观，但没有添加任何额外的几何。</strong></p>
<p><strong>物体的细节可以分为三种尺度:覆盖许多像素的宏观特征，跨越几个像素的中观特征，以及实质上小于一个像素的微观特征。这些类别在某种程度上是流动的，因为在动画或互动过程中，观众可以在许多距离上观察同一物体。</strong></p>
<p><strong>宏观几何学是由顶点和三角形或其他几何原语来表示的。当创建一个三维角色时，四肢和头部通常是在宏观尺度上建模的。微几何被封装在着色模型中，它通常在像素着色器中实现，并使用纹理贴图作为参数。使用的着色模型模拟了表面的微观几何的交互作用，例如，发光的物体在微观上是光滑的，而扩散的表面在微观上是粗糙的。角色的皮肤和衣服似乎有不同的材质，因为它们使用不同的着色器，或者至少在这些着色器中使用不同的参数。</strong></p>
<p><strong>微观几何学描述了这两种尺度之间的一切。它包含的细节过于复杂，无法有效地使用单个三角形进行渲染，但它足够大，足以让观看者在几个像素上区分表面曲率的单个变化。角色脸上的皱纹、肌肉细节、衣服上的褶皱和接缝都是中尺度的。一组被统称为凹凸贴图技术的方法通常用于中尺度建模。这些调整的着色参数在像素水平，这样的方式，观众感觉小远离基本几何的扰动，它实际上保持平坦。不同类型的凹凸贴图之间的主要区别是它们如何表示细节特征。变量包括细节特性的现实性和复杂性。例如，数字艺术家通常会将细节雕刻成模型，然后使用软件将这些几何元素转换成一个或多个纹理，如凹凸纹理或裂隙暗化纹理。</strong></p>
<p><strong>1978年，Blinn提出了在纹理中编码中尺度细节的想法。他观察到，如果在着色过程中，我们用一个轻微扰动的表面法线代替真实的表面，表面似乎有小规模的细节。他将描述表面法线扰动的数据存储在阵列中。</strong></p>
<p><strong>关键的想法是，我们使用纹理来修改表面法线，而不是使用纹理来改变光照方程中的颜色成分。表面的几何法线保持不变;我们只是修改了正常使用的渲染方程。这种操作没有物理上的对等物;我们在表面法线上执行改变，但表面本身在几何意义上保持平滑。就像每个顶点的法线会给人一种表面在三角形之间是平滑的错觉一样，修改每个像素的法线会改变对三角形表面本身的感知，而不会修改它的几何形状。</strong></p>
<p><strong>对于凹凸贴图，法线必须改变方向相对于一些参考系。为此，一个切坐标系，也称为切空间基，存储在每个顶点上。这个参考系用于将光线转换到表面位置的空间(或者反之)，以计算扰乱法线的效果。对于一个具有法线映射的多边形表面，除了顶点法线外，我们还存储了所谓的切线和双切线向量。双切线向量也被错误地称为副法向量。</strong></p>
<p><strong>切线和双切线向量表示物体空间中法线贴图本身的轴，因为目标是转换光线，使其相对于贴图。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923140224.png" class="" title="image-20210923140224">

<p>一个球面三角形显示，其切线框架显示在每个角。像球体和环面这样的形状有一个自然的切线空间基础，就像环面上的经纬度线所显示的那样。</p>
<p><strong>这三个向量，法向量n，切向量t，和双切线b，构成一个基矩阵:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923140316.png" class="" title="image-20210923140316">

<p><strong>这个矩阵，有时缩写为TBN，将光的方向(对于给定的顶点)从世界空间转换到切线空间。这些向量不需要相互垂直，因为法线贴图本身可能会被扭曲以适应表面。然而，非正交基引入了纹理的倾斜，这可能意味着需要更多的存储，也可能有性能影响，即矩阵不能用简单的转置求逆。一种节省内存的方法是只存储顶点的切线和双切线，然后用它们的叉乘来计算法线。然而，这种方法只有在惯用手的情况下才有效的矩阵总是相同的。通常一个模型是对称的:一个平面、一个人、一个文件柜和许多其他物体。因为纹理消耗大量内存，所以它们经常被镜像到对称模型上。因此，只存储对象纹理的一侧，但纹理映射将其放置到模型的两侧。在这种情况下，切空间的利手性在两边是不同的，不能被假设。在这种情况下，如果在每个顶点存储一个额外的比特信息来表示左右手方向，仍然有可能避免存储法线。如果设置此位，则使用此位对正切和双切线的叉积求反，以产生正确的法线。如果切线帧是正交的，也可以将基存储为四元数(章节4.3)，这既可以节省更多的空间，也可以节省每像素的一些计算。质量上的小损失是可能的，尽管在实践中很少发生。</strong></p>
<p><strong>切空间的思想对其他算法也很重要。正如在下一章中讨论的，许多着色方程只依赖于表面的法向量。然而，拉丝铝或丝绒等材料也需要知道观察者的相对方向和与表面相比的照明。切线框架对于定义材质在表面上的方向是有用的。Lengyel和Mittring的文章对这一领域进行了广泛的报道。Sch¨uler提出了一种在像素着色器中计算切线空间基础的方法，不需要存储每个顶点预先计算的切线帧。Mikkelsen改进了这一技术，推导出一种不需要任何参数化，而是使用表面位置导数和高度场导数来计算扰动法线的方法。然而，与使用标准的切线空间映射相比，这种技术可能导致显示的细节少得多，而且可能会造成美术工作流程问题。</strong></p>
<h3 id="Blinn’s-Methods-Blinn’s-模型"><a href="#Blinn’s-Methods-Blinn’s-模型" class="headerlink" title="Blinn’s Methods Blinn’s 模型"></a>Blinn’s Methods Blinn’s 模型</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923140746.png" class="" title="image-20210923140746">

<p>在左边，法向量n在u和v方向上被分成(bu，bv )，给出n ‘(未归一化)。在右边，一个高度场和它对着色法线的影响显示。这些法线可以被插值在高度之间，以获得更平滑的外观。</p>
<p><strong>Blinn原来的凹凸映射方法存储两个有符号的值bu 和bv，在纹理的每个texel。这两个值对应于沿u和v图像轴改变法线的量。也就是说，这些纹理值，通常是双线性插值，用于缩放两个垂直于法线的向量。这两个向量相加改变法线方向。两个值bu 和bv 描述曲面在该点的方向。参见上图。这种类型的凹凸贴图纹理被称为偏移矢量凹凸贴图或偏移贴图。</strong></p>
<p><strong>另一种表示凸起的方法是使用高度场来修改表面法线的方向。每个单色纹理值代表一个高度，所以在纹理中，白色是高区域，黑色是低区域(反之亦然)。参见下图中的示例。这是第一次创建或扫描凹凸贴图时使用的一种常见格式，它也是由Blinn在1978年引入的。高度场用于导出与第一种方法中使用的类似的u和v符号值。这是通过计算相邻列之间的差来得到u的斜率，以及v的相邻行之间的斜率来完成的。一种变体是使用Sobel过滤器，它给直接相邻的领域赋予更大的权重。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923140905.png" class="" title="image-20210923140905">

<p>一种波状高度场凹凸图像及其在球体上的使用。</p>
<h3 id="Normal-Mapping-法线贴图"><a href="#Normal-Mapping-法线贴图" class="headerlink" title="Normal Mapping 法线贴图"></a>Normal Mapping 法线贴图</h3><p><strong>凹凸贴图的一个常见方法是直接存储法线贴图。算法和结果与Blinn方法在数学上一致;只有存储格式和像素着色器计算改变。</strong></p>
<p><strong>法线映射编码(x, y, z)映射到[−1,1]，例如，对于一个8位纹理，x轴值0代表−1.0和255代表1.0。下图显示了一个示例。颜色[128,128,255]为浅蓝色，表示所示颜色映射的平面，即一个[0,0,1]的正常值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923141127.png" class="" title="image-20210923141127">

<p>凹凸贴图与法线贴图。每个颜色通道实际上是一个表面的法线坐标。红色通道表示x偏移;红色越多，法线越向右。绿色是y偏移，蓝色是z偏移，右边是使用法线贴图生成的图像。注意立方体顶部的扁平外观。(图片由Manuel M. Oliveira和Fabio Policarpo提供。)</p>
<p><strong>法线贴图最初是作为世界空间法线地图引入的，在实践中很少使用。对于这种类型的映射，干扰是直接的:在每个像素处，从映射和检索法线直接使用它，加上光的方向，来计算表面上那个位置的着色。法线贴图也可以在对象空间中定义，这样模型可以旋转，法线仍然有效。然而，世界空间和对象空间表示都将纹理绑定到特定方向的特定几何图形上，这限制了纹理的重用。</strong></p>
<p><strong>相反，扰动法线通常在切线空间中恢复，即相对于表面本身。这允许表面的变形，以及最大限度地重用正常纹理。切空间法线映射也可以很好地压缩，因为z分量(与未受扰动的表面法线对齐的分量)的符号通常可以假定为正的。</strong></p>
<p><strong>法线映射可以很好地提高真实感，见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923141353.png" class="" title="image-20210923141353">

<p>一个在游戏场景中使用的法线贴图凹凸贴图的例子。左上:两个法线映射到右边没有应用。左下:法线贴图应用。右图:法线贴图。(3D模型和法线贴图由Dulce Isis Segarra L´opez提供。)</p>
<p><strong>与过滤颜色纹理相比，过滤法线贴图是一个困难的问题。一般来说，法线和着色之间的关系不是线性的，所以标准的滤波方法可能会导致令人讨厌的走样。想象一下，看着由闪亮的白色大理石块组成的楼梯。在某些角度，楼梯的顶部或侧面捕捉光线，并反射出明亮的镜面高光。然而，楼梯的平均正常角度是45度;它将从完全不同的方向捕捉亮点，而不是原来的楼梯。当带有高光高光的凹凸贴图在没有正确过滤的情况下渲染时，一个分散的闪光效果可能会发生在高光闪烁的地方，这是由于走样。</strong></p>
<p><strong>Lambertian曲面是一种特殊情况，法线贴图在着色上几乎是线性的。朗伯着色几乎完全是一个点积，这是一个线性运算。对一组法线求平均值并对结果进行点积相当于对单个法线点积求平均值:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923141651.png" class="" title="image-20210923141651">

<p><strong>注意，平均向量在使用前没有被标准化。由上式可知，对于朗伯曲面，标准滤波和mipmaps几乎都能产生正确的结果。因为Lambertian着色方程不是点积，所以结果不是很正确;它是一个夹紧点积：max(l·n, 0)。夹紧操作使其非线性。这将过度暗的表面反光的方向，但在实践中，这通常是不反对的。需要注意的是，一些通常用于法线贴图的纹理压缩方法(例如从其他两个贴图重建z分量)不支持非单位长度的法线，因此使用非标准化法线贴图可能会造成压缩困难。</strong></p>
<p><strong>在非朗伯曲面的情况下，通过将输入作为一组过滤到着色方程中，而不是单独过滤法线映射，可以产生更好的结果。这样做的技术将在第9.13节中讨论。</strong></p>
<p><strong>最后，从高度图h(x, y)推导法线图可能是有用的。如下所示。首先，在x和y方向上的导数的近似值是用中心差值来计算的</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923141944.png" class="" title="image-20210923141944">

<p><strong>则在texel (x, y)处的非标准化法线为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923141957.png" class="" title="image-20210923141957">

<p><strong>必须注意纹理的边界。</strong></p>
<p><strong>地平线贴图可以用来进一步增强法线贴图，让凹凸点能够将着色投射到它们自己的表面上。这是通过预计算额外的纹理来完成的，每个纹理沿着表面的平面与一个方向相关联，并为每个texel存储在那个方向上的视界角度。有关更多信息，请参阅11.4节。</strong></p>
<h2 id="Parallax-Mapping-视差贴图"><a href="#Parallax-Mapping-视差贴图" class="headerlink" title="Parallax Mapping 视差贴图"></a>Parallax Mapping 视差贴图</h2><p><strong>凹凸贴图和法线贴图的一个问题是，凹凸贴图不会随着视角改变位置，也不会相互遮挡。例如，如果你沿着一堵真正的砖墙，从某个角度看，你不会看到砖块之间的灰泥。一个肿块墙壁的地图将永远不会显示这种类型的遮挡，因为它仅仅是变化的法线。最好让凹凸点实际影响在每个像素上渲染的表面位置。</strong></p>
<p><strong>视差映射的思想由Kaneko在2001年提出，由Welsh对其进行了改进和推广。视差是指物体的位置随着观察者的移动而相对于另一个物体的移动。当观察者移动时，凸起应该有高度。视差贴图的关键思想是，通过检查已发现的可见像素的高度，对一个像素中应该看到什么进行有根据的猜测。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924105412.png" class="" title="image-20210924105412">

<p>左边是目标:从视图向量穿过高度场的位置找到表面上的实际位置。视差映射做了一个一阶近似，取矩形上位置的高度并用它来找到一个新的位置padj．(After Welsh)。</p>
<p><strong>对于视差贴图，凸起被存储在一个高度场纹理中。当在给定像素处查看表面时，高度场值在该位置被检索，并用于移动纹理坐标来检索表面的不同部分。移动的数量是基于检索的高度和眼睛到表面的角度。参见上图。高度场值要么存储在一个单独的纹理中，要么打包在一些其他纹理的未使用的颜色或alpha通道中(打包不相关的纹理时必须小心，因为这会对压缩质量产生负面影响)。在用于移动坐标之前，高度场值被缩放并有偏差。比例尺决定了高度场在地表之上或之下延伸的高度，而偏差给出了“海平面”高度，在这个高度上不会发生移动。给定一个纹理坐标位置p，一个调整后的高度场高度h，和一个高度值为v的标准化视图向量vz 水平分量vxy，新的视差调整纹理坐标padj 是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924105602.png" class="" title="image-20210924105602">

<p><strong>注意，不同于大多数着色方程，这里执行计算的空间很重要——视图向量需要在切线空间中。</strong></p>
<p><strong>虽然这是一个简单的近似，但如果碰撞高度变化相对缓慢，这种移动在实践中工作得相当好。邻近的texels有相同的高度，所以使用原始位置的高度作为估计的想法新地点的高度是合理的。然而，这种方法在浅层视角下是行不通的。当视图向量接近表面的地平线时，一个小的高度变化会导致一个大的纹理坐标移动。这种近似是不适用的，因为新获取的位置与原始地表位置几乎没有高度相关性。</strong></p>
<p><strong>为了改善这个问题，Welsh引入了偏移限制的思想。这样做的目的是限制移动的数量，使其永远不大于取回的高度。方程是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924105737.png" class="" title="image-20210924105737">

<p><strong>注意，这个方程的计算速度比原来的要快。几何上的解释是，高度定义了一个半径，超过这个半径，位置就不能移动。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924105815.png" class="" title="image-20210924105815">

<p>在视差偏移限制中，偏移移动的最多距离原始位置的高度，以虚线圆弧显示。灰色偏移表示原始结果，黑色偏移表示有限结果。右边是用这种技术渲染的一堵墙。(图片由Terry Welsh提供。)</p>
<p><strong>在陡角(面朝上)时，这个方程几乎与原方程相同，因为vz 几乎是1。在浅角度时，偏移的效果会受到限制。从视觉上看，这可以在浅角度上减少凹凸不平，但这比纹理的随机采样要好得多。随着视图的变化，纹理会发生变化，或者在立体渲染中，观察者同时感知到两个视点，必须给出一致的深度提示。即使有这些缺点，带有偏移限制的视差映射只需要花费一些额外的像素着色程序指令，并比基本的法线映射提供了相当大的图像质量改善。Shishkovtsov通过在凹凸贴图法线方向移动估计位置来改善视差遮挡的阴影。</strong></p>
<h3 id="Parallax-Occlusion-Mapping-视差遮挡映射"><a href="#Parallax-Occlusion-Mapping-视差遮挡映射" class="headerlink" title="Parallax Occlusion Mapping 视差遮挡映射"></a>Parallax Occlusion Mapping 视差遮挡映射</h3><p><strong>凹凸贴图不会根据高度场修改纹理坐标;它只在一个位置上改变正常的着色。视差映射提供了高度场效应的一个简单近似，它假定一个像素的高度与其相邻像素的高度大致相同。这种假设可以很快地分解。凸起也不会相互遮挡，也不会投下阴影。我们想要的是在像素处可见的东西。视角向量与高度场相交。</strong></p>
<p><strong>为了更好地解决这个问题，一些研究人员提出使用光线沿着视图向量行进，直到找到一个(近似的)交点。这个工作可以在像素着色器中完成，高度数据可以作为纹理访问。我们把这些方法的研究集中到一个视差映射技术子集中，以这样或那样的方式利用光线行进。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924110149.png" class="" title="image-20210924110149">

<p>绿色的眼球射线投射到平面上，平面以规则的间隔采样(紫点)，并获得高度。该算法求出眼球射线与近似曲线高度场的黑线段的第一个交点。</p>
<p><strong>这些类型的算法被称为视差遮挡映射(POM)或地形映射方法，以及其他名称。其关键思想是首先沿着投影向量测试固定数量的高度场纹理样本。对于掠射角度的视图射线，通常会生成更多的样本，这样就不会错过最近的交点。沿着射线的每个三维位置都被检索，转化为纹理空间，并进行处理，以确定它是高于还是低于高度场。一旦找到高度场以下的样本，则使用高度场以下的样本数量和高度场以上的样本数量来寻找交集位置。参见上图。然后使用附加的法线贴图、颜色贴图和任何其他纹理，使用位置来给表面着色。多层高度场可以用来产生悬垂，独立的重叠表面，和双面浮雕映射的视点替用特效;参见13.7节。高度场追踪方法也可以用来让凹凸不平的表面投射阴影到自身，无论是硬的还是软的。参见下图进行比较。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924110307.png" class="" title="image-20210924110307">

<p>与光线行进(右)相比，没有光线行进(左)的视差映射。当不使用光线行进时，立方体的顶部会被压扁。在光线行进时，也会产生自阴影效果。(图片由Manuel M. Oliveira和Fabio Policarpo提供。)</p>
<p><strong>关于这个话题有大量的文献。虽然所有这些方法都是沿着一条射线前进的，但也有几个不同之处。可以使用简单的纹理来检索高度，但也可以使用更高级的数据结构和更高级的根查找方法。一些技术可能涉及着色器丢弃像素或写入到深度缓冲区，这会影响性能。下面我们总结了大量的方法，但请记住，随着GPU的发展，最好的方法也在发展。这种“最佳”方法取决于内容和在射线行进过程中完成的步数。</strong></p>
<p><strong>确定两个正则样本之间的实际交点的问题是一个寻根问题。在实践中，高度场更多地被视为深度场，矩形平面定义了表面的上限。这样，平面上的起始点就在高度场的上方。在求出高度场表面上的最后一个点和下面的第一个点之后，Tatarchuk使用割线法的单步求出一个近似解。Policarpo等人使用在两个点之间的二分搜索来寻找更近的交叉点。Risser等人使用割线法迭代速度收敛。这样做的代价是，常规采样可以并行进行，而迭代方法需要更少的整体纹理访问，但必须等待结果，并执行较慢的依赖纹理获取。蛮力方法总体上表现很好。</strong></p>
<p><strong>对高度场进行足够频繁的采样是至关重要的。McGuire和McGuire提出对mipmap查找进行偏性，并使用各向异性mipmap来确保对高频高度场(如代表尖峰或头发的高度场)的正确采样。我们也可以用比法线贴图更高的分辨率来存储高程贴图。最后，一些渲染系统甚至不存储法线贴图，而是使用交叉过滤器从高度场动态导出法线。</strong></p>
<p><strong>另一种提高性能和采样精度的方法是，不要在一开始就定期采样高度场，而是尝试跳过中间的空白区域。Donnelly将高度场预处理为一组体素，在每个体素中存储距离高度场表面的距离。在这个通过这种方式，可以快速跳过中间的空间，代价是每个高度场的存储空间更高。Wang等人使用五维位移映射方案来保持从各个方向和位置到表面的距离。这使得复杂曲面、自阴影和其他效果得以实现，但代价是消耗相当大的内存。Mehra和Kumar也出于类似的目的使用方向距离地图。Dummer介绍了圆锥步进映射的思想，polpolo和Oliveira对其进行了改进。这里的概念是为每个高度场位置存储一个锥半径。这个半径定义了射线上与高度场最多有一个交点的区间。这个特性允许沿着射线快速跳过，而不会错过任何可能的交叉，尽管代价是需要依赖结构读取。另一个缺点是创建圆锥步进图需要预先计算，这使得该方法不能用于动态变化的高度场。Schroders和Gulik提出了四叉树地形映射，这是一种在遍历过程中跳过体积的分层方法。Tevs等人使用“最大mipmaps”来允许跳过，同时最小化预计算成本。Drobot也使用了mipmaps中存储的四叉树结构来加快穿越速度，并提出了一种混合不同高度场的方法，其中一种地形类型转换为另一种地形类型。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924110559.png" class="" title="image-20210924110559">

<p>法线测绘和地形测绘。正常映射时不会发生自闭塞。地形映射在重复纹理的轮廓上有问题，因为矩形更多的是对高度场的视图，而不是真正的边界定义。(图片由NVIDIA公司提供。)</p>
<p><strong>上述所有方法的一个问题是，错觉沿着物体的轮廓边缘消失，这将显示出原始表面的光滑轮廓。参见上图。关键的想法是，渲染的三角形定义了像素着色程序应该评估哪些像素，而不是表面实际位于哪里。此外，对于曲面，轮廓的问题变得更加复杂。其中一种方法是由Oliveira和Policarpo描述和开发的，它使用二次轮廓近似技术。Jeschke等人和Dachsbacher等人都给出了一种更普遍、更健壮的方法(并回顾了以前的工作)来正确处理轮廓和曲面。首先由Hirche探索，一般的想法是将网格中的每个三角形向外挤压，形成一个棱镜。渲染这个棱柱力评估所有可能出现高度场的像素。这种类型的方法被称为外壳映射，因为扩展的网格在原始模型上形成一个单独的外壳。当棱镜与光线相交时，通过保持棱镜的非线性特性，可以实现无人工渲染的高度场，尽管计算费用昂贵。下图显示了这种技术的一个令人印象深刻的应用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924110725.png" class="" title="image-20210924110725">

<p>视差闭塞贴图，也称为浮雕贴图，用于路径上，使石头看起来更真实。地面实际上是一组简单的三角形，并应用了高度场。(图片来自Crytek公司的《孤岛危机》)</p>
<h2 id="Textured-Lights-灯光纹理"><a href="#Textured-Lights-灯光纹理" class="headerlink" title="Textured Lights 灯光纹理"></a>Textured Lights 灯光纹理</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924110847.png" class="" title="image-20210924110847">

<p>投影变形。纹理被投射到茶壶和地平面上，用于调节光线在投影截锥内的贡献(在截锥外它被设置为0)。(图片由英伟达公司提供。)</p>
<p><strong>纹理也可以用来添加视觉丰富的光源，并允许复杂的强度分布或聚光灯功能。对于所有照明限制在一个圆锥体或锥面上的光，投射纹理可以用来调节光的强度。这允许有形状的聚光灯，图案灯，甚至“幻灯机”效果(上图)。这些灯通常被称为戈博灯或饼干灯，以专业剧院和电影照明中使用的剪纸的术语命名。请参阅第7.2节，以类似的方式使用投影映射来投射阴影。</strong></p>
<p><strong>对于不局限于视锥的光线，而是照亮所有方向的光线，立方体贴图可以用来调节强度，而不是二维投影纹理。一维纹理可以用来定义任意距离衰减函数。结合二维角衰减图，这可以考虑复杂的体积照明模式。一种更普遍的可能性是使用三维(体积)纹理来控制光的衰减。这允许任意体积的效应，包括光束。这种技术是内存密集型的(就像所有的卷纹理一样)。如果光的效应体积沿三个轴对称，通过将数据镜像到每个八分仪，内存占用可以减少八倍。</strong></p>
<p><strong>纹理可以添加到任何灯光类型，以实现额外的视觉效果。有纹理的灯光允许艺术家很容易地控制照明，他们可以简单地编辑使用的纹理。</strong></p>
<h1 id="7-Shadows-阴影"><a href="#7-Shadows-阴影" class="headerlink" title="7 Shadows 阴影"></a>7 Shadows 阴影</h1><p><strong>阴影对于创建逼真的图像和为用户提供有关物体放置的视觉线索非常重要。本章重点介绍计算阴影的基本原理，并描述最重要和流行的实时算法。我们还简要讨论了一些不太流行但包含重要原则的方法。我们没有花时间在这一章中涵盖所有的选择和方法，因为有两本全面的书深入研究了阴影领域。相反，我们专注于调查自发表以来出现的文章和报告，偏向于经过实战检验的技术。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925145054.png" class="" title="image-20210925145054">

<p>阴影术语:光源、遮挡器、接收器、阴影、本影和半影。</p>
<p><strong>本章所用的术语如上图所示，occlers（遮挡器）是指在 receivers（接收器）上投射阴影的物体。准时光源，即那些没有面积的区域，只产生完全阴影区域，有时称为硬阴影。如果使用面积或体积光源，然后产生柔和的阴影。每个阴影可以有一个完全阴影区域，称为本影，和一个部分阴影区域，称为半影。通过模糊阴影边缘识别软阴影。然而，需要注意的是，它们通常不能通过低通过滤器模糊硬阴影的边缘来正确渲染。如下图所示，正确的软阴影越靠近接收器，阴影投射的几何形状就越清晰。软阴影的本影区并不等同于由准时光源产生的硬阴影。相反，软阴影的本影区域会随着光源的增大而减小，如果光源足够大，接收器距离遮挡器足够远，它甚至可能会消失。柔和的阴影通常是可取的，因为半影边缘让观众知道阴影确实是阴影。硬边阴影通常看起来不那么真实，有时会被误解为实际的几何特征，如表面的折痕。然而，硬阴影比软阴影渲染更快。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925145417.png" class="" title="image-20210925145417">

<p>硬阴影和软阴影的混合。板条箱的阴影是尖锐的，因为遮挡器靠近接收器。人的阴影是尖锐的接触点，软化的距离，以遮挡增加。远处的树枝投下柔和的阴影。(图片来自育碧的《Tom Clancy’s The Division》。)</p>
<p><strong>比有半影更重要的是有阴影。如果没有一些阴影作为视觉线索，场景往往难以令人信服，更难以感知。正如Wanger所展示的，通常有一个不准确的影子比没有好，因为眼睛对影子的形状是相当宽容的。例如，在地板上使用模糊的黑色圆圈作为纹理，可以将角色固定在地面上。</strong></p>
<p><strong>在接下来的部分中，我们将超越这些简单的模型阴影，并提出从场景中的遮挡器自动实时计算阴影的方法。第一部分处理在平面上投射阴影的特殊情况，第二部分涵盖了更通用的阴影算法，即将阴影投射到任意表面上。硬阴影和软阴影都将被覆盖。最后，提出了一些适用于各种阴影算法的优化技术。</strong></p>
<h2 id="Planar-Shadows-平面阴影"><a href="#Planar-Shadows-平面阴影" class="headerlink" title="Planar Shadows 平面阴影"></a>Planar Shadows 平面阴影</h2><p><strong>当物体在一个平面上投射阴影时，就会发生一个简单的阴影情况。本节将介绍几种平面阴影的算法，每一种算法都在阴影的柔软性和真实感方面有所变化。</strong></p>
<h3 id="Projection-Shadows-投射阴影"><a href="#Projection-Shadows-投射阴影" class="headerlink" title="Projection Shadows 投射阴影"></a>Projection Shadows 投射阴影</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925153347.png" class="" title="image-20210925153347">

<p>左:位于l的光源在平面y = 0上投下阴影。顶点v投影到平面上。投影点称为p。相似三角形用于推导投影矩阵。右图:阴影投射到一个平面上，π: n·x + d = 0。</p>
<p><strong>在这种方案中，三维物体被再次渲染以产生阴影。一个矩阵可以被导出，它将一个物体的顶点投射到一个平面上。考虑上图中的情况下,光源位于l的顶点投影是v,和预计的顶点是p。我们将推导出投影矩阵的特殊情况跟踪平面y = 0,然后这个结果会与任何平面推广工作。</strong></p>
<p><strong>我们从求x坐标的投影开始。从上图左侧的相似三角形中，我们得到</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925153521.png" class="" title="image-20210925153521">

<p><strong>z坐标用同样的方法得到:pz = (lyvz −lzvy) /(ly −vy)，而y坐标为零。现在这些方程可以转化为投影矩阵M:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925153531.png" class="" title="image-20210925153531">

<p><strong>证明Mv = p很简单，这意味着M确实是投影矩阵。</strong></p>
<p><strong>在一般情况下，投射阴影的平面不是y = 0平面，而是π: n·x + d = 0平面。上图的右侧部分描述了这种情况。我们的目标还是要找到一个能将v投影到p的矩阵。为了达到这个目的，从l发出的射线，经过v，与平面π相交。这就得到了投影点p:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925153710.png" class="" title="image-20210925153710">

<p><strong>这个方程也可以转化为一个投影矩阵，如式所示，满足Mv = p:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925153721.png" class="" title="image-20210925153721">

<p><strong>如预期的那样，如果平面为y = 0，即n = (0,1,0) and d = 0，则该矩阵变为之前方程中的矩阵。</strong></p>
<p><strong>要渲染阴影，只需将这个矩阵应用到应该在平面π上投射阴影的对象上，并将这个投影对象渲染为没有照明的深色。在实践中，您必须采取措施，以避免允许投影的三角形被渲染在接收它们的表面之下。一种方法是在我们投射的平面上添加一些偏差，这样阴影三角形总是呈现在表面的前面。</strong></p>
<p><strong>一个更安全的方法是先画出地平面，然后画出带有z缓冲的投影三角形，然后像往常一样渲染其余的几何图形。预计三角形总是画在地平面的顶部，因为没有深度比较。</strong></p>
<p><strong>如果地平面有一个限制，例如，它是一个矩形，投射的阴影可能会落在它的外面，打破错觉。要解决这个问题，我们可以使用模板缓冲区。首先，将接收器绘制到屏幕和模板缓冲区。然后，关闭z缓冲区，只在接收器绘制的地方绘制投影三角形，然后正常渲染场景的其余部分。</strong></p>
<p><strong>另一种阴影算法是将三角形渲染成纹理，然后应用到地面上。这个纹理是一种光贴图，是一种调制底层表面强度的纹理(章节11.5.1)。正如我们所看到的，这种将阴影投影到纹理上的想法也允许在曲面上产生半影和阴影。这种技术的一个缺点是，纹理可能被放大，一个像素覆盖多个像素，破坏了错觉。</strong></p>
<p><strong>如果阴影情况在帧与帧之间没有变化，即光源和阴影投射器不相对移动，这个纹理可以重复使用。如果没有发生变化，大多数阴影技术都可以从帧与帧之间重用中间计算结果中获益。</strong></p>
<p><strong>所有的阴影投射器必须在光和地面接收器之间。如果光源在物体上的最高点以下，则生成反阴影，因为每个顶点都通过光源的点进行投影。正确的阴影和反阴影如下图所示。如果我们投射一个低于接收平面的物体，也会发生错误，因为它也不会投射阴影。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925154036.png" class="" title="image-20210925154036">

<p>在左边，一个正确的阴影被显示出来，而在右边的图形中，一个反阴影出现，因为光源在物体的顶点下面。</p>
<p><strong>当然，可以明确地剔除和修剪阴影三角形，以避免此类伪影。接下来介绍的一种更简单的方法是使用现有的GPU管线执行带有裁剪的投影。</strong></p>
<h3 id="Soft-Shadows-软阴影"><a href="#Soft-Shadows-软阴影" class="headerlink" title="Soft Shadows 软阴影"></a>Soft Shadows 软阴影</h3><p><strong>通过使用各种技术，投影阴影也可以变得柔和。在这里，我们描述了Heckbert和Herf提出的一种产生软阴影的算法。该算法的目标是在地平面上生成一个显示软阴影的纹理。然后我们描述不那么准确、更快的方法。</strong></p>
<p><strong>当光源有一个区域时，就会出现软阴影。一种近似区域光效果的方法是在它的表面使用几个准时的光来取样。对于每一个准时的光源，图像被渲染并累积到一个缓冲器中。这些图像的平均值就是带有软阴影的图像。注意，在理论上，任何生成硬阴影的算法都可以使用这种积累技术来生成半影。在实践中，由于涉及到执行时间，以交互速度执行通常是站不住脚的。</strong></p>
<p><strong>Heckbert和Herf使用基于截点的方法来产生他们的阴影。这个想法是把光当作观察者，地平面形成截锥的远剪切平面。截锥的宽度足以包含咬合器。</strong></p>
<p><strong>软阴影纹理是通过生成一系列地平面纹理而形成的。区域光源在其表面取样，每个位置用于遮蔽代表地平面的图像，然后将投射阴影的物体投射到该图像上。所有这些图像被求和并平均，以产生一个地平面阴影纹理。参见下图的左边的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925154223.png" class="" title="image-20210925154223">

<p>在左边，渲染使用Heckbert和Herf的方法，使用256个通道。右边是海恩斯的方法。用海恩斯的方法，阴影太大了，在门口和窗户周围特别明显。</p>
<p><strong>采样区域光方法的一个问题是，它往往看起来像它本来的样子:几个重叠的阴影来自准时光源。同样，对于n个阴影通道，只能生成n + 1个不同的阴影。大量的通道给出了准确的结果，但代价过高。该方法对于获取(字面上的)“地面真实”图像，以测试其他更快算法的质量是有用的。</strong></p>
<p><strong>一种更有效的方法是使用卷积。即过滤。在某些情况下，模糊从单个点生成的硬阴影就足够了，可以生成半透明的纹理，可以与真实世界的内容合成。参见下图。然而，在物体接触地面的地方，一个统一的模糊可能是不令人信服的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925154435.png" class="" title="image-20210925154435">

<p>阴影。阴影纹理是通过从上面渲染阴影投射体，然后模糊图像并在地平面上渲染它而生成的。(图片在Autodesk的A360查看器中生成，模型来自Autodesk的Inventor样本。)</p>
<p><strong>有许多其他方法可以提供更好的近似，但需要额外的成本。例如，Haines先投影一个硬阴影，然后用渐变来渲染剪影边缘，从中心的黑暗到边缘的白色，以创建可信的半影。如上上图右侧所示。然而，这些半影在物理上是不正确的，因为它们还应该延伸到轮廓边缘内部的区域。Iwanicki借鉴了球面谐函数的思想，用椭球体来近似遮挡字符，从而给出柔和的阴影。所有这些方法都有不同的近似值和缺点，但比平均一组大的投影图像要有效率得多。</strong></p>
<h2 id="Shadows-on-Curved-Surfaces-曲面阴影"><a href="#Shadows-on-Curved-Surfaces-曲面阴影" class="headerlink" title="Shadows on Curved Surfaces 曲面阴影"></a>Shadows on Curved Surfaces 曲面阴影</h2><p><strong>将平面阴影的概念扩展到曲面的一个简单方法是使用生成的阴影图像作为投影纹理。从光的角度考虑阴影。光明所看见的都被照亮;它看不见的东西就在阴影里。假设遮挡器从光线中呈现为黑色将视点转换为白色纹理。这个纹理可以被投射到表面上，以接收阴影。实际上，接收器上的每个顶点都有一个为其计算的(u, v)纹理坐标，并将纹理应用于它。这些纹理坐标可以由应用程序显式地计算。这与上一节中的地面阴影纹理有些不同，在那里物体被投射到一个特定的物理平面上。在这里，图像是通过光线形成的，就像放映机里的胶片。</strong></p>
<p><strong>当渲染时，投影的阴影纹理修改接收器表面。它也可以与其他阴影方法相结合，有时主要用于帮助感知物体的位置。例如，在一款平台跳跃电子游戏中，主角可能总是会被给予一个直接位于其下方的阴影，即使角色处于完全的阴影中。更精细的算法可以得到更好的结果。例如，Eisemann和D´ecoret假设有一个矩形顶灯，并创建一个物体水平切片的阴影图像堆栈，然后将其转换成mipmaps或类似的图像。每个切片对应的区域通过使用它的mipmap与它到接收者的距离成正比，这意味着越远的切片投射的阴影越柔和。</strong></p>
<p><strong>纹理投影方法存在一些严重的缺陷。首先，应用程序必须识别哪些对象是遮挡对象，哪些对象是它们的接收对象。程序必须保持接收器与光线的距离大于遮挡器，否则阴影将“向后投射”。此外，被遮挡的物体不能使自己阴影。接下来的两部分将介绍在不需要这种干预或限制的情况下生成正确阴影的算法。</strong></p>
<p><strong>注意，通过使用预先构建的投射纹理，可以获得各种照明模式。聚光灯是一个简单的方形投影纹理，内部有一个圆形定义光线。百叶窗效果可以通过由水平线组成的投影纹理来创建。这种类型的纹理被称为光衰减蒙版、cookie纹理或gobo贴图。通过简单地将两个纹理相乘，预先构建的图案可以与动态创建的投影纹理相结合。这种灯将在第6.9节中进一步讨论。</strong></p>
<h2 id="Shadow-Volumes-阴影体积"><a href="#Shadow-Volumes-阴影体积" class="headerlink" title="Shadow Volumes 阴影体积"></a>Shadow Volumes 阴影体积</h2><p><strong>Heidmann在1991年提出了一种基于Crow’s shadow volume的方法，该方法巧妙地利用模板缓冲区将阴影投射到任意物体上。它可以在任何GPU上使用，因为唯一的要求是一个模板缓冲区。它不是基于图像的(不像下面描述的阴影映射算法)，因此避免了采样问题，从而产生正确的清晰阴影。这有时可能是一个缺点。例如，角色的衣服可能会有褶皱，造成薄而硬的阴影，造成走样。由于其不可预测的成本，阴影体积今天很少被使用。我们在这里给出算法的简要描述，因为它说明了一些重要的原则和基于这些继续的研究。</strong></p>
<p><strong>首先，想象一个点和一个三角形。将直线从一点通过三角形的顶点延伸到无穷远处，就形成了一个无限的三角形金字塔。三角形下面的部分，即不包括点的部分是一个截断的无限大金字塔，上面的部分就是一个简单的金字塔。如下图所示。现在假设这个点是一个点光源。然后，在被截断的金字塔体积内(在三角形下面)的物体的任何部分都处于阴影中。这个体积称为阴影体积。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926110922.png" class="" title="image-20210926110922">

<p>左:点光源的线通过三角形的顶点延伸，形成一个无限的金字塔。右图:上面部分是一个金字塔，下面部分是一个无限截短的金字塔，也叫影子体积。所有在阴影体积内的几何体都在阴影中。</p>
<p><strong>假设我们查看某个场景，沿着从眼睛通过像素的光线，直到光线击中要显示在屏幕上的对象。当光线到达这个物体时，我们增加一个计数器，每次它经过正面的阴影体(即面向观众)。因此，每次光线进入阴影时计数器都增加。以同样的方式，每次射线经过被截断的金字塔的背面时，我们减少相同的计数器。然后光线从阴影中走出来。我们继续，递增和递减计数器，直到射线击中要在该像素上显示的对象。如果计数器大于零，则该像素处于阴影中;否则就不是。当有多个三角形投射阴影时，这个原则也适用。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926111055.png" class="" title="image-20210926111055">

<p>使用两种不同计数方法计算阴影-体积交叉的二维侧视图。在z-pass体积计数中，当射线通过阴影体积的前面向三角形时，计数增加，当离开阴影体积的后面向三角形时，计数减少。所以，在点A，光线进入两个阴影体积为+2，然后离开两个阴影体积，净重为0，所以这个点在光线中。在z-fail体积计数中，计数从表面以外开始(这些计数以斜体显示)。对于点B处的射线，z-pass方法通过两个正面三角形给予+2计数，而z-fail通过两个反面三角形给予相同计数。点C显示了z-fail阴影体积必须被封顶。从点C开始的射线首先击中一个正面的三角形，得到−1。然后它退出两个阴影体积(通过它们的尾盖，这是这个方法正常工作所必需的)，给出净计数+1。计数不为零，所以点处于阴影中。这两种方法总是给出相同的计数结果的所有点上观察的表面。</p>
<p><strong>用光线做这个是很耗时间的。但有一个更聪明的解决方案:一个模板缓冲区可以为我们做计数。首先，清除模板缓冲区。其次，整个场景被绘制到帧缓冲区中，只使用了未点亮的材质的颜色，以便在颜色缓冲区中获得这些着色组件，并将深度信息放入z缓冲区中。第三，关闭z-缓冲区更新和写入颜色缓冲区(尽管z-缓冲区测试仍在进行)，然后绘制阴影体的正面三角形。在此过程中，模具操作被设置为在绘制三角形的位置增加模具缓冲区中的值。第四步，使用模板缓冲区完成另一步，这一次只绘制阴影体的背面三角形。在此过程中，模板缓冲区中的值将在三角形被吸引。只有当渲染的阴影-体面的像素是可见的(例如:，而不是被任何真实的几何学所隐藏)。此时，模板缓冲区保存每个像素的阴影状态。最后，整个场景再次渲染，这一次只显示了受光照影响的活动材料的组件，并且只显示在模板缓冲区的值为0的地方。值为0表示光线走出阴影的次数与进入阴影体积的次数相同。这个位置被灯光照亮。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926111257.png" class="" title="image-20210926111257">

<p>阴影体积。在左边，一个人物投下了阴影。在右边，模型的挤压三角形显示。(图片来自Microsoft SDK样本“ShadowVolume”。)</p>
<p><strong>这种计算方法是影子体积背后的基本思想。阴影体积算法生成的阴影示例如上图所示。有许多有效的方法可以一次性实现算法。然而，当物体穿透相机的近平面时，计数就会出现问题。解决方法称为z-fail，涉及计数隐藏在可见表面后面而不是前面的交叉。上上图显示了这个替代方案的简要概述。</strong></p>
<p><strong>为每个三角形创建四边形会产生大量的透支。也就是说，每个三角形将创建三个必须被渲染的四边形。一个球体由一千个三角形组成三千个四边形，每一个四边形都可以跨越屏幕。一个解决方案是沿着物体的轮廓线只画那些四边形，例如，我们的球体可能只有50个轮廓线，所以只需要50个四边形。几何着色器可以用来自动生成这样的轮廓边缘。选择和夹紧技术也可以用来降低填充成本。</strong></p>
<p><strong>然而，阴影体积算法仍然有一个可怕的缺点:极端的可变性。想象一个单一的小三角形。如果相机和光源处于完全相同的位置，阴影体积成本是最小的。形成的四边形不会覆盖任何像素，因为它们是视图的边。只有三角形本身才重要。假设观察者现在绕着三角形旋转，保持它在视野中。当相机远离光源时，阴影-体积四边形将变得更加可见，并覆盖更多的屏幕，导致更多的计算发生。如果观察者碰巧移动到三角形的阴影中，阴影体积将完全填满屏幕，与我们最初的视图相比，需要花费相当多的时间来评估。这种可变性使得阴影体积在具有一致帧率的交互应用中不可用。像其他情况一样，朝光看会导致算法成本的巨大、不可预测的飞跃。</strong></p>
<p><strong>由于这些原因，阴影体积在很大程度上已经被应用程序所抛弃。然而，考虑到新的和不同的方式在GPU上访问数据的持续发展，以及研究人员对这种功能的巧妙重新用途，阴影体积可能有一天会重新被普遍使用。例如，Sintorn等人概述了提高效率的阴影体积算法，并提出了自己的层次加速结构。</strong></p>
<p><strong>下一个提出的算法，阴影贴图，具有更可预测的成本，并且非常适合GPU，因此在许多应用中形成阴影生成的基础。</strong></p>
<h2 id="Shadow-Maps-阴影贴图"><a href="#Shadow-Maps-阴影贴图" class="headerlink" title="Shadow Maps 阴影贴图"></a>Shadow Maps 阴影贴图</h2><p><strong>1978年，Williams提出了一种通用的基于z缓冲区的渲染器，可以用于在任意物体上快速生成阴影。这个想法是渲染场景，使用z缓冲区，从光源的位置投射阴影。凡是光“看到”的都被照亮了，其余的都处于阴影中。当生成这个映像时，只需要z缓冲。灯光、纹理和写入值到颜色缓冲可以关闭。</strong></p>
<p><strong>z缓冲区中的每个像素现在都包含了离光源最近的物体的z深度。我们将z缓冲区的全部内容称为阴影贴图，有时也称为阴影深度贴图或阴影缓冲区。为了使用阴影贴图，场景将进行第二次渲染，但这一次是基于观察者的视角。当每个绘图原语被渲染时，它在每个像素处的位置将与阴影图进行比较。如果一个渲染点离光源的距离大于阴影贴图中对应的值，那么这个点就处于阴影中，否则就不是。这种技术是通过使用纹理映射来实现的。参见下图。阴影映射是一种流行的算法，因为它相对来说是可预测的。构建阴影地图的成本与渲染原语的数量大致成线性关系，访问时间是恒定的。阴影贴图可以生成一次，并在光线和物体不移动的场景中重复使用每一帧，例如用于计算机辅助设计。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926111708.png" class="" title="image-20210926111708">

<p>阴影贴图。在左上角，阴影贴图是通过在视图中存储表面深度而形成的。在右上角，眼睛注视着两个地方。球体在点va处可见，这个点被发现位于阴影贴图的texel a。存储在那里的深度并不(远)小于点va从光线处的深度，因此点被照亮。矩形击中点vb 比存储在texel b的深度(远)远离光，因此在阴影中。左下角是从光的角度看的场景，白色更远。在右下角是用阴影贴图渲染的场景。</p>
<p><strong>当一个z缓冲区被生成时，光线只能“看”到一个特定的方向，就像相机一样。对于一个遥远的定向光，如太阳，光线的视野被设置为包含所有物体，在眼睛所看到的观察体积中投射阴影。光线使用正投影，它的视图需要在x和y上足够宽和高来观察这组物体。当地的光源也需要尽可能的进行类似的调整。如果局部光线离投射阴影的物体足够远，一个单一的视锥可能足以包含所有这些。或者，如果局部的光是一个聚光灯，它有一个与它相关联的自然锥，与它的锥外的一切被认为是不照明的。</strong></p>
<p><strong>如果局部光源在场景中，并且被阴影投射器包围，一个典型的解决方案是使用六视图立方体，类似于立方体环境映射。这些被称为全向阴影贴图。全向映射的主要挑战是避免沿着两个独立映射相遇的接缝处的工件。King和Newhall深入分析了问题并提出了解决方案，Gerasimov提供了一些实施细节。Forsyth出了一种用于全向光的通用多锥体分区方案，在需要的地方提供了更多的阴影贴图分辨率。Crytek根据每个视图的投影截锥的屏幕空间覆盖范围为点光源设置了每个视图的分辨率，所有地图存储在一个纹理图集中。</strong></p>
<p><strong>并不是场景中的所有物体都需要渲染到光线的视图体中。首先，只有能够投射阴影的物体才需要渲染。例如，如果已知地面只能接收阴影而不能投射阴影，那么就不需要将其渲染到阴影地图中。</strong></p>
<p><strong>阴影投射体定义为光线视野锥体内的阴影投射体。这个截锥可以通过多种方式增强或收紧，让我们可以安全地忽略一些阴影投射器。想象一组肉眼可见的阴影接收器。这组物体在光线视野方向的最大距离内。任何超过这个距离的物体都不能在可见的接收器上投下阴影。同样，可见接收器的集合可能比光线的原始x和y视图边界要小。参见下图。另一个例子是，如果光源在眼睛的视锥内，那么这个额外视锥外的任何物体都不能在接收器上投下阴影。只渲染相关对象不仅可以节省渲染时间，还可以减少光锥所需的尺寸，从而提高阴影图的有效分辨率，从而提高质量。此外，如果光锥的近平面尽可能地远离光，如果远平面尽可能地远离光，它会有所帮助尽可能接近。这样做可以提高z缓冲区的有效精度(章节4.7.2)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926112004.png" class="" title="image-20210926112004">

<p>在左侧，光的视野围绕着眼睛的视锥。在中间，光的远平面被拉进来，只包括可见的接收器，所以选择三角形作为施法者;近平面也进行了调整。在右侧，光线的截锥侧面被用来约束可见的接收器，剔除绿色的胶囊。</p>
<p><strong>阴影贴图的一个缺点是阴影的质量取决于阴影映射的分辨率(以像素为单位)和z缓冲区的数值精度。由于在深度比较过程中对阴影图进行采样，该算法容易出现走样问题，特别是在靠近物体接触点的地方。一个常见的问题是自阴影走样叠，通常被称为“表面痤疮”或“阴影痤疮”，在这种情况下，三角形被错误地认为是阴影本身。这个问题有两个根源。一个是处理器精度的数值限制。另一个来源是几何的，因为点样本的值被用来代表一个区域的深度。也就是说，为光线生成的样本几乎从不位于与屏幕样本相同的位置(例如，像素通常在其中心取样)。当光线的存储深度值与被观察表面的深度相比较时，光线的值可能会略低于表面的深度，从而导致自阴影。这些错误的影响如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926112152.png" class="" title="image-20210926112152">

<p>阴影贴图的走样。在左边，偏差太低，所以出现了自阴影。在右边，高偏置导致鞋子不会投出接触影子。阴影贴图的分辨率也太低，给阴影一个块状的外观。(图片由Christoph Peters使用阴影演示生成。)</p>
<p><strong>一种帮助避免(但不总是消除)各种阴影映射的常见方法是引入偏差因素。当检查在阴影图中发现的距离与被测试的位置的距离，一个小的偏差从接收机的距离。参见下图。这种偏置可以是一个恒定值，但当接收器不是主要面向光时，这样做可能会失败。一种更有效的方法是使用与接收器对光线的角度成比例的偏置。为了避免这个问题，表面倾斜得越远，偏移就越大。这种类型的偏差被称为坡度比例偏差。这两种偏差都可以通过使用命令来应用，例如OpenGL的glPolygonOffset()来将每个多边形移离光线。注意，如果一个表面直接面对光线，它不偏向后都是由坡度比例偏差决定的。由于这个原因，一个常数偏差与坡度偏差一起使用，以避免可能的精度误差。坡度比例偏差也经常固定在某个最大值，因为当从光线下观察时，当表面接近边缘时，切线值可能非常高。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926112520.png" class="" title="image-20210926112520">

<p>阴影的偏置。这些表面被渲染成一个阴影贴图，以垂直线表示阴影贴图的像素中心。遮挡深度被记录在×位置。我们想知道表面是否在显示为点的三个样品处被照亮。最接近的阴影贴图深度值用相同的颜色×显示。在左边，如果没有添加偏移，蓝色和橙色的样本将被错误地判定为处于阴影中，因为它们距离光线比它们对应的阴影贴图深度更远。在中间，从每个样本中减去一个恒定的深度偏差，使每个样本更靠近光。蓝色样本仍然被认为是在阴影中，因为它并不比测试时的阴影贴图深度更接近光源。在右侧，阴影贴图是通过将每个多边形移动到与其斜度成比例的光线之外而形成的。所有的样本深度现在都比阴影贴图的深度更接近，所以都是亮的。</p>
<p><strong>Holbert引入了法向偏移，它首先使接收器的世界空间位置沿着表面的法向稍微移动一点，并与光的方向和几何法向之间角度的正弦成比例。这不仅改变了深度，而且改变了样本在阴影贴图上测试的x和y坐标。当光线与表面的角度变得更浅时，偏移量就会增加，希望样本能够离表面足够远，以避免自阴影。这种方法可以看作是将样品移动到接收器上方的“虚拟表面”。这个偏移是一个世界空间距离，所以Pettineo建议根据阴影贴图的深度范围缩放它。Pesce提出了沿着摄像机视图方向偏移的想法，这也可以通过调整阴影贴图坐标来工作。其他偏差方法在第7.5节讨论，因为阴影方法也需要测试几个邻近的样本。</strong></p>
<p><strong>太大的偏差会导致一个被称为“光泄漏”或“Peter Panning”的问题，在这个问题中，物体似乎漂浮在下方表面的上方。产生这种人为现象的原因是物体接触点下方的区域，例如脚下的地面，被推得太远，所以没有影子。</strong></p>
<p><strong>避免自阴影问题的一种方法是只渲染阴影贴图的背面。这个方案被称为二次深度阴影映射，它在许多情况下都能很好地工作，特别是在一个不能手动调整偏移的渲染系统中。当物体是双面的、薄的或相互接触时，就会出现问题。如果一个对象是一个模型，其中网格的两边都是可见的，例如，一个棕榈叶或一张纸，自阴影可能发生，因为背面和正面在同一位置。类似地，如果不进行偏置，在轮廓边缘或薄物体附近也会出现问题，因为在这些区域中，背面接近正面。添加偏置可以帮助避免表面粉刺，但该方案更容易漏光，因为在接收端和遮挡器的背面接触点没有分离。参见下图。选择哪种方案取决于具体情况。例如，Sousa等人发现，使用正面作为阳光阴影，使用背面作为室内灯光，对它们的应用效果最好。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926112758.png" class="" title="image-20210926112758">

<p>阴影贴图表面为一个头顶光源。在左边，面向光的表面(用红色标记)被发送到阴影地图。表面可能会被错误地确定为自阴影(“痤疮”)，所以需要偏向远离光线。在中间，只有背面三角形被渲染到阴影贴图中。将这些遮光器向下推的偏置可能会让光线泄漏到位置A附近的地平面上;向前偏置会使标记为b的剪影边界附近被照亮的位置被认为处于阴影中。在右侧，阴影地图上每个位置上最近的正面和背面三角形之间的中点形成了一个中间表面。漏光可能发生在c点附近(第二深度阴影贴图也可能发生)，因为最近的阴影贴图样本可能在这个位置左边的中间表面上，所以这个点离光源更近。</p>
<p><strong>注意，对于阴影贴图，对象必须是“水密的”(流形和封闭的，例如固体;第16.3.3节)，或者必须同时将正面和背面渲染到映射中，否则对象可能不能完全投射阴影。Woo提出了一种通用的方法，从字面上讲，它试图在仅仅使用正面或背面阴影之间找到一种折衷的方法。这个想法是将实体物体渲染到阴影贴图上，并跟踪两个距离光线最近的表面。这个过程可以通过深度剥离或其他与透明度相关的技术来完成。两个物体之间的平均深度形成了一个中间层，它的深度被用作阴影贴图，有时也被称为双重阴影贴图。如果物体足够厚，自阴影和光漏的影响就会最小化。Bavoil等人讨论了处理潜在伪影的方法，以及其他实现细节。主要的缺点是额外的成本关联使用两个阴影地图。Myers讨论了闭塞器和接收器之间由艺术家控制的深度层。</strong></p>
<p><strong>当观察者移动时，光线的视野体积通常会随着阴影投射体的变化而变化。这样的变化导致阴影在帧与帧之间的轻微移动。这是因为光线的阴影地图是抽样一组不同方向的光,而这些方向与前面不一致集。对于定向照明,解决办法是迫使每一个成功的影子映射生成维持相同的相对 texel beam位置在世界空间。也就是说，您可以将阴影地图看作是在整个世界上强加一个二维网格参考框架，每个网格单元代表地图上的一个像素样本。当你移动的时候，阴影贴图会生成一组不同的相同网格单元。换句话说，光线的视野投射被迫在这个网格上，以保持帧对帧的连贯性。</strong></p>
<h3 id="Resolution-Enhancement-分辨率增强"><a href="#Resolution-Enhancement-分辨率增强" class="headerlink" title="Resolution Enhancement 分辨率增强"></a>Resolution Enhancement 分辨率增强</h3><p><strong>与纹理的使用类似，理想情况下，我们希望一个阴影贴图texel覆盖大约一个图像像素。如果我们有一个光源位于与眼睛相同的位置，阴影地图与屏幕空间像素完美地一对一映射(并且没有可见的阴影，因为光线正好照亮眼睛看到的东西)。当光线的方向改变时，每像素的比例就会改变，这就会造成伪影。下图显示了一个示例。阴影是块状的，定义很差，因为前景中的大量像素与阴影贴图的每个像素相关联。这种不匹配被称为透视走样。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926113332.png" class="" title="image-20210926113332">

<p>左边的图像是使用标准阴影映射创建的;使用LiSPSM查看右边的图像。图中显示了每个阴影贴图的像素投影。这两种阴影图具有相同的分辨率，不同之处在于LiSPSM改变了光源的矩阵，以提供更接近观察者的更高采样率。(图片由维也纳理工大学的Daniel Scherzer提供)</p>
<p><strong>单个阴影贴图像素也可以如果一个表面接近光的侧面，但面对观众，覆盖许多像素。这个问题被称为投影走样;参见下图。块性可以通过增加阴影映射的分辨率来降低，但代价是额外的内存和处理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926113449.png" class="" title="image-20210926113449">

<p>左边的灯几乎就在头顶上。阴影的边缘有点参差不齐，因为与眼睛的视图相比，分辨率较低。在右侧，光线靠近地平线，所以每个阴影纹理水平覆盖了相当多的屏幕区域，因此给了一个更锯齿状的边缘。(图片由realmjp在Github上的“阴影”程序生成。)</p>
<p><strong>还有另一种方法来创建光的采样模式，使其更接近相机的模式。这是通过改变场景向光线投射的方式来实现的。通常我们认为视图是对称的，视图向量位于截锥的中心。然而，视图方向仅仅定义了一个视图平面，而不是哪个像素被采样。定义截锥的窗口可以在这个平面上移动、倾斜或旋转，创建一个四边形，提供了不同的世界到视图空间的映射。四边形仍然按规则间隔采样，因为这是线性变换矩阵的性质和GPU的使用。采样率可以通过改变光线的视图方向和视图窗口的边界来修改。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926113536.png" class="" title="image-20210926113536">

<p>对于顶灯，左边地板上的采样与眼睛的频率不匹配。通过改变光线的视野方向和右边的投影窗口，采样率倾向于在靠近眼睛的地方有更高的像素密度。</p>
<p><strong>在将光线映射到眼睛上有22个自由度。对这个解决方案空间的探索导致了几种不同的算法进行尝试以便更好地匹配光线的采样率与眼睛的采样率。方法包括透视阴影图(PSM)、梯形阴影图(TSM)和光空间透视阴影图(LiSPSM)。参见本节首图中的示例。这个技术被称为透视扭曲方法。</strong></p>
<p><strong>这些矩阵扭曲算法的一个优点是，除了修改光的矩阵之外，不需要额外的工作。每种方法都有自己的优点和缺点，因为每种方法都可以帮助匹配某些几何和照明情况下的采样率，而在其他情况下则会降低采样率。Lloyd等人分析了PSM、TSM和LiSPSM之间的等效性，很好地概述了这些方法的采样和走样问题。当光线的方向垂直于视图的方向时(例如，头顶)，这些方案工作得最好，因为透视变换可以移动到更靠近眼睛的地方放置更多的样本。</strong></p>
<p><strong>矩阵扭曲技术无法帮助的一种照明情况是当一盏灯在相机前面并指向它时。这种情况被称为dueling frusta，或者更通俗的说法是“deer in the headlights”。“需要更多的阴影贴图样本靠近眼睛，但线性扭曲只会让情况更糟。这个问题和其他问题，如质量的突然变化和“紧张的”，不稳定的阴影在相机运动中产生，使这些方法不再受欢迎。</strong></p>
<p><strong>在观察者所在的位置添加更多的样本是一个很好的想法，这导致了为给定视图生成多个阴影地图的算法。当Carmack在2004年地震经济大会上描述这个想法时，这个想法第一次产生了显著的影响。Blow独立实现了这一系统。这个想法很简单:生成一组固定的阴影贴图(可能在不同的分辨率)，覆盖场景的不同区域。在Blow的方案中，四个阴影地图嵌套在查看器周围。通过这种方式，高分辨率的地图可以用于附近的物体，而对于远处的物体，分辨率会下降。Forsyth提出了一个相关的想法，为不同的可见物体集生成不同的阴影地图。在他的设置中，避免了如何处理跨越两个阴影贴图边界的对象的转换问题，因为每个对象都有且只有一个与它相关的阴影贴图。Flagship Studios开发了一个混合了这两种理念的系统。一个阴影图是用于附近的动态对象，另一个是用于观察者附近的静态对象的网格部分，第三个是用于场景中的整体静态对象。每一帧生成第一个阴影贴图。另外两个可以只生成一次，因为光源和几何形状是静态的。虽然所有这些特定的系统现在都很老了，但针对不同的对象和情况(一些是预先计算的，一些是动态的)的多个地图的想法，是此后开发的算法中的一个共同主题。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926114059.png" class="" title="image-20210926114059">

<p>在左侧，视觉上的视锥体被分割成四个体量。在右侧，为体块创建了包围框，它决定了方向光的四个阴影贴图所渲染的体块。(在恩格尔)。</p>
<p><strong>2006年Engel、Lloyd等和Zhang等独立研究了相同的基本思想。这个想法是通过平行于视图方向的切片将视图截体的体积分成几块。参见上图。随着深度的增加，每个连续体积的深度范围大约是前一体积的2到3倍。对于每个视图体，光源可以创建一个紧密绑定的锥体，然后生成阴影贴图。通过使用纹理图集或数组，不同的阴影图可以被视为一个大的纹理对象，从而最小化缓存访问延迟。获得的质量改进的对比如下图所示。恩格尔为这种算法命名为级联阴影映射(CSM)，比张的术语平行分割阴影映射更常用，但两者都出现在文献中，实际上是相同的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926114235.png" class="" title="image-20210926114235">

<p>在左侧，场景的宽可视区域导致一个2048 × 2048分辨率的阴影地图显示透视走样。在右侧，四个1024 × 1024的阴影地图沿着视图轴放置，大大提高了质量。围栏的前角的缩放显示在插入的红框中。(图片由香港中文大学张帆提供)</p>
<p><strong>该算法实现简单，可以覆盖大面积的场景，结果合理，具有较强的鲁棒性。决斗锥柱问题可以通过在靠近眼睛的地方以更高的采样率来解决，而且不会出现严重的最坏情况问题。由于这些优点，级联阴影映射在许多应用程序中被使用。</strong></p>
<p><strong>虽然可以使用透视扭曲将更多的样本打包到单个阴影贴图的细分区域中，但规范是为每个级联使用单独的阴影贴图。如上上图所示，下图从查看者的角度显示，每个地图所覆盖的区域可能不同。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926114408.png" class="" title="image-20210926114408">

<p>级联阴影映射可视化。紫色、绿色、黄色和红色分别代表最近和最远的级联。(图片由Unity Technologies提供。)</p>
<p><strong>对于更近的阴影贴图，更小的视图体积提供了更多需要的样本。决定z-depth的范围如何在映射之间划分—一个称为z-partitioning的任务—可能非常简单，也可能非常复杂。一种方法是对数划分，其中对每个级联映射，使远平面距离与近平面距离的比率相同:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926114606.png" class="" title="image-20210926114606">

<p><strong>其中n和f是整个场景的近平面和远平面，c是地图的数量，r是生成的比率。例如，如果场景中最近的物体在1米之外，p最大距离是1000米，我们有三个级联地图，然后r = ³√(1000/1) = 10。最近视图的远近平面距离是1和10，下一个间隔是10到100以保持这个比例，最后一个是100到1000米。初始近深度对这种划分有很大的影响。如果近深度只有0.1米，那么10000的立方根是21.54，这是一个相当高的比率，例如0.1到2.154,46.42到1000。这意味着生成的每个阴影地图必须覆盖更大的区域，从而降低其精度。在实践中，这样的划分为近平面附近的区域提供了相当大的分辨率，如果在这个区域中没有物体，这就浪费了。避免这种不匹配的一种方法是将分割距离设置为对数和等距分布的加权混合，但如果我们能够为场景确定紧密的视图边界，那就更好了。</strong></p>
<p><strong>挑战在于设置近距离的飞机。如果距离眼睛太远，物体可能会被平面夹住，这是一个非常糟糕的藏物。对于过场动画，美工可以设置场景这个值恰好提前，但对于交互式环境来说，这个问题更具挑战性。Lauritzen等人提出了样本分布阴影图(SDSM)，它使用前一帧的z-depth值，通过两种方法中的一种来确定更好的分区。</strong></p>
<p><strong>第一种方法是查看z深度的最小值和最大值，并使用这些值设置近平面和远平面。这是使用所谓的GPU上的reduce操作来执行的，在这个操作中，一系列越来越小的缓冲区被计算器或其他着色器分析，输出缓冲区反馈作为输入，直到1 × 1缓冲区被留下。通常情况下，这些值会稍微往外推一点，以适应场景中物体的移动速度。除非采取纠正措施，从屏幕边缘进入的附近物体仍可能对画面造成问题，但在下一帧中会很快得到纠正。</strong></p>
<p><strong>第二种方法还分析深度缓冲区的值，制作一个称为直方图的图，记录z-深度沿范围的分布。除了发现紧密的近平面和远平面外，图中可能会有根本没有物体的间隙。任何通常添加到该区域的分区平面都可以被捕捉到对象实际存在的地方，从而为级联映射集提供更多的z-depth精度。</strong></p>
<p><strong>在实践中，第一种方法是通用的，速度快(通常在1 ms /帧范围内)，效果好，因此在多个应用中被采用。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926114825.png" class="" title="image-20210926114825">

<p>深度边界效果。在左边，没有特殊处理来调整近平面和远平面。在右边，SDSM用来寻找更紧密的边界。注意每个图像左边缘附近的窗口框架，二楼的花盒下面的区域，以及一楼的窗口，由于松散的视图边界导致的欠采样导致了伪影。指数阴影图用于渲染这些特定的图像，但提高深度精度的想法是有用的所有阴影图技术。(图片由Ready at Dawn Studios提供，版权为索尼互动娱乐公司。)</p>
<p><strong>与单个阴影贴图一样，由于光样本在帧间移动而产生的闪烁伪影是一个问题，当物体在级联之间移动时可能会更糟。各种方法被用来保持世界空间中稳定的样本点，每种方法都有各自的优点。当一个物体跨越两个阴影图之间的边界时，阴影的质量会发生突然的变化。一种解决方案是让视图稍微重叠。在这些重叠区域中采集的样本从相邻的阴影图中收集结果，并进行混合。另一种方法是利用抖动法在该区域采集单个样本。</strong></p>
<p><strong>由于它的普及，人们在提高效率和质量方面投入了相当大的努力。如果阴影贴图的截锥内没有任何变化，则不需要重新计算阴影贴图。对于每一种光，阴影投射者的列表可以通过找出哪些物体对光线可见，以及其中哪些物体可以在接收器上投射阴影来预先计算出来。由于很难判断阴影是否正确，因此可以采用一些适用于级联和其他算法的捷径。一种技术是使用低细节级别的模型作为实际投射阴影的代理。另一种方法是从考虑中去除微小的遮挡器。较远的阴影地图更新频率可能少于每帧一次，理论上这样的阴影不太重要。这种想法有可能是由大型移动物体造成的，因此需要小心使用。Day提出了从一帧到另一帧“滚动”远程地图的想法，这个想法是大多数静态阴影地图可重用的帧到帧，只有边缘可能改变，因此需要渲染。《毁灭战士》(2016)等游戏保留了大量的阴影地图，只生成那些物体移动的地方。更进一步的级联贴图可以被设置为完全忽略动态对象，因为这样的阴影对场景的贡献可能很小。在某些环境中，高分辨率的静态阴影图可以代替这些进一步的级联，这可以显著减少工作量。稀疏纹理系统(章节19.10.1)可以用于单个静态阴影地图非常庞大的世界。级联阴影贴图可以与烘烤的光线贴图纹理或其他更适合于特定情况的阴影技术相结合。Valient的报告值得注意的是，它描述了各种电子游戏的不同影子系统定制和技术。第11.5.1节详细讨论了预先计算的光和影算法。</strong></p>
<p><strong>创建几个独立的阴影贴图意味着要为每个贴图运行一些几何体。许多提高效率的方法都建立在将遮挡器渲染到一组阴影贴图的想法上。几何着色器可以用来复制对象数据，并将其发送到多个视图。实例几何着色器允许对象输出到32个深度纹理。</strong></p>
<p><strong>多视口扩展可以执行一些操作，例如将一个对象渲染到一个特定的纹理数组切片。第21.3.1节将在它们用于虚拟现实的背景下更详细地讨论这些。视口共享技术的一个可能的缺点是，所有生成的阴影贴图的遮挡器必须被发送到管线中，而不是与每个阴影贴图相关的集合。</strong></p>
<p><strong>你自己目前处于世界上数十亿光源的阴影中。光只从其中几个到达你。在实时渲染中，如果所有的光都处于激活状态，那么带有多个光的大型场景可能会被计算淹没。如果一个空间体积在视锥内部，但肉眼不可见，则遮挡该接收体体积的对象不需要评估。Bittner等人使用眼睛的遮挡剔除(第19.7节)来找到所有可见的阴影接收器，然后从光线的角度将所有潜在的阴影接收器渲染到模板缓冲掩模中。这个遮罩编码了从光中看到的可见阴影接收器。为了生成阴影贴图，他们使用遮挡剔除从光线中渲染对象，并使用蒙版剔除没有接收器所在的对象。各种选择策略也适用于光。由于辐照度随距离的平方而衰减，一种常见的技术是在一定的阈值距离后对光源进行消光。例如，第19.5节中的门户筛选技术可以发现哪些光线影响哪些细胞。这是一个活跃的研究领域，因为性能的好处是相当可观的。</strong></p>
<h2 id="Percentage-Closer-Filtering-Percentage-Closer过滤"><a href="#Percentage-Closer-Filtering-Percentage-Closer过滤" class="headerlink" title="Percentage-Closer Filtering Percentage-Closer过滤"></a>Percentage-Closer Filtering Percentage-Closer过滤</h2><p><strong>阴影贴图技术的一个简单扩展可以提供伪软阴影。这种方法还可以帮助改善分辨率问题，当一个光样本单元覆盖了许多屏幕像素时，阴影看起来是块状的。解决方法类似于纹理放大(章节6.2.1)。不是从阴影地图上取一个样本，而是取四个最近的样本。该技术并没有插入深度本身，而是与表面深度比较的结果。也就是说，将表面的深度分别与四个texel深度进行比较，然后确定每个阴影贴图样本的点处于光照或阴影中。这些结果,即0为阴影，1为光线，然后用双线性插值来计算光线对表面位置的实际贡献。这种过滤结果是一个人为的软阴影。这些半影会根据阴影地图的分辨率、相机位置和其他因素而变化。例如，更高的分辨率会使边缘的软化幅度更小。不过，有一点半影和平滑总比没有好。</strong></p>
<p><strong>这种从阴影映射中提取多个样本并混合结果的想法被称为接近百分比滤波(PCF)。区域灯产生柔和的阴影。到达一个表面某个位置的光的数量与该位置可见的光的面积的比例有关。PCF试图通过反转过程来近似点光源(或方向光源)的软阴影。</strong></p>
<p><strong>它不是从一个表面位置寻找光的可见区域，而是从一组靠近原始位置的表面位置寻找准时光的可见性。参见下图。“接近百分比过滤”的名称指的是最终目标，即找到在光线下可见的样本的百分比。这个百分比是用来着色表面的光的多少。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927144303.png" class="" title="image-20210927144303">

<p>在左边，来自区域光源的棕色线显示了半影形成的地方。对于接收器上的单个点p，可以通过测试区域光的表面上的一组点并找到没有被任何遮挡物遮挡的点来计算接收到的光照量。在右边，点光源不会投出半影。PCF通过反转过程来近似区域光的效果:在一个给定的位置，它对阴影贴图上的一个可比区域进行采样，以得出有多少样本被照亮的百分比。红色椭圆表示阴影地图上的采样区域。理想情况下，这个圆盘的宽度与接收器和遮挡器之间的距离成正比。</p>
<p><strong>在PCF中，位置生成在一个表面位置附近，在相同的深度，但在阴影贴图上的不同texel位置。每个位置的可见性都被检查，这些结果的布尔值，亮的或未亮的，然后混合得到一个软阴影。注意这个过程是非物理的:不是直接对光源取样，这个过程依赖于对表面本身取样的想法。到遮挡器的距离不影响结果，所以阴影有相似大小的半影。尽管如此，这种方法在许多情况下提供了一个合理的近似。</strong></p>
<p><strong>一旦确定要采样的区域的宽度，以避免混叠的方法进行采样是很重要的。有许多不同的方法来采样和过滤附近的阴影贴图位置。变量包括采样区域的宽度，使用多少样本，采样模式，以及如何对结果进行加权。使用性能较差的API，可以通过一种类似于双线性插值的特殊纹理采样模式来加速采样过程，该模式访问四个相邻节点的位置。不是混合结果，而是将四个样本分别与给定值进行比较，返回通过测试的比率。然而，在规则网格模式中执行最近邻采样可能会产生明显的伪数据。使用联合双边过滤器，使结果模糊，但尊重物体边缘，可以提高质量，同时避免阴影泄漏到其他表面。有关此过滤技术的更多信息，请参阅12.1.1节。</strong></p>
<p><strong>DirectX 10引入了对PCF的单指令双线性滤波支持，使结果更加平滑。这比最近的邻居取样提供了相当大的视觉改进，但是常规取样产生的伪影仍然是一个问题。最小化网格模式的一个解决方案是使用预先计算的泊松分布模式对一个区域进行采样，如下图所示。这种分布将样本分散开来，使它们既不接近彼此，也不是有规律的模式。众所周知，对每个像素使用相同的采样位置，无论其分布如何，都会产生模式。这种伪影可以通过围绕其中心随机旋转样本分布来避免，这将使混叠变成噪声。Casta ~ no发现泊松采样产生的噪声因其平滑、程式化的内容而特别明显。他提出了一种基于双线性抽样的高效高斯加权抽样方案。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927144513.png" class="" title="image-20210927144513">

<p>最左边显示了4×4网格模式中的PCF抽样，使用的是最近邻抽样。最右边显示了圆盘上的12点泊松采样模式。使用这个模式对阴影贴图进行采样，可以在中间的左半部分得到改进的结果，尽管伪影仍然可见。在右中，采样模式围绕其中心从一个像素随机旋转到另一个像素。结构化的阴影伪影变成了(不那么令人讨厌的)噪音。(图片由ATI研究公司的John Isidoro提供)</p>
<p><strong>自我遮蔽问题和光线泄露，即痤疮和彼得·潘宁，会因PCF而变得更糟。坡度比例偏差纯粹基于它与光线的角度将表面推离光线，假设一个样本在阴影贴图上的距离不超过一个texel。通过从表面上的单一位置在更大范围内取样，一些测试样品可能会被真实表面挡住。</strong></p>
<p><strong>一些不同的额外偏见因素被发明出来，并成功地用于减少自我跟踪的风险。Burley描述了偏锥，其中每个样本向光方向移动，其距离与原始样本的距离成正比。Burley建议斜率为2.0，并有一个小的恒定偏差。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927144627.png" class="" title="image-20210927144627">

<p>附加阴影偏差方法。对于PCF，在原始样品位置(5个点的中心)周围采集几个样品。所有这些样本都应该被点亮。在左图中，形成了一个偏锥，样本被移动到它上面。锥形的陡度可以增加，以使右边的样本足够接近而被点亮，但有可能增加其他地方(没有显示)真正被阴影笼罩的样本的光泄漏。在中间的图中，所有的样品被调整到位于接收器的平面上。这种方法对于凸面很有效，但对于凹面就会适得其反，如左侧所示。在右图中，法向偏移偏移沿表面的法向移动样本，与法向和光线之间的角度的正弦成正比。对于中心样本，这可以被认为是移动到原始表面之上的一个想象表面。这种偏差不仅会影响深度，还会改变用于测试阴影贴图的纹理坐标。</p>
<p><strong>sch¨uler、Isidoro和Tuft提出了基于观测的技术，即接收器本身的斜率应该用来调整其余样本的深度。在这三种方法中，Tuft的公式最容易应用于级联阴影贴图。Dou等进一步细化和扩展了这一概念，解释了z-深度如何以非线性方式变化。这些方法假定附近的样本位置在由三角形构成的同一平面上。被称为接收平面深度偏差或其他类似术语，这种技术在许多情况下可以相当精确，因为这个假想平面上的位置确实在表面上，或者如果模型是凸的，就在它前面。如上图所示，凹腔附近的样品会被隐藏。常数、坡度、接收平面、视图偏差和正常偏移偏差的组合已经用于解决自阴影问题，但仍然需要对每个环境进行手动调整。</strong></p>
<p><strong>PCF的一个问题是，由于采样区域的宽度保持不变，阴影会均匀地呈现柔和，所有的阴影都具有相同的半影宽度。在某些情况下这可能是可以接受的，但在闭塞器和接收器之间有地面接触的地方似乎是不正确的。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927144759.png" class="" title="image-20210927144759">

<p>接近百分比的过滤和接近百分比的软阴影。在左边，硬阴影加上一点PCF滤波。在中间，恒定宽度的软阴影。在右侧，当物体与地面接触时，有适当硬度的可变宽度软阴影。(图片由NVIDIA公司提供。)</p>
<h2 id="Percentage-Closer-Soft-Shadows-Percentage-Closer软阴影"><a href="#Percentage-Closer-Soft-Shadows-Percentage-Closer软阴影" class="headerlink" title="Percentage-Closer Soft Shadows Percentage-Closer软阴影"></a>Percentage-Closer Soft Shadows Percentage-Closer软阴影</h2><p><strong>2005年，Fernando发表了一种有影响力的方法，称为百分比-更接近的软阴影(PCSS)。它试图通过搜索附近的区域来解决问题阴影贴图找到所有可能的遮挡器。这些遮挡器离位置的平均距离用来确定样本面积宽度:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927145021.png" class="" title="image-20210927145021">

<p><strong>dr 接收器到光和do的距离是多少的平均遮挡距离。换句话说，样本表面面积的宽度随着平均遮挡器离接收器和光线的距离越来越远而增大。查看下图，并考虑移动遮挡器的效果，看看这是如何发生的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927144303.png" class="" title="image-20210927144303">

<p><strong>如果没有发现遮挡器，位置是完全照明，没有进一步的处理是必要的。类似地，如果位置完全被遮挡，处理就会结束。否则，则对感兴趣的区域进行采样，并计算光的近似贡献。为了节省加工成本，样品面积的宽度可以用来改变取样的数量。其他技术也可以实现，例如，对不太重要的远处软阴影使用较低的采样率。</strong></p>
<p><strong>这个方法的缺点是，它需要采样一个公平大小的阴影地图的区域，以找到遮挡器。使用旋转的泊松盘模式可以帮助隐藏欠采样的伪影。Jimenez注意到泊松采样在运动时可能是不稳定的，并发现通过使用介于抖动和随机之间的函数形成的螺旋模式可以在帧与帧之间提供更好的结果。</strong></p>
<p><strong>Sikachev等人详细讨论了一种使用AMD引入的SM 5.0特性的PCSS更快的实现，通常称之为接触硬化阴影(CHS)。这个新版本还解决了基本PCSS的另一个问题:半影的大小受阴影地图分辨率的影响。参见下图。这个问题可以通过首先生成阴影贴图的mipmaps来最小化，然后选择最接近用户定义的世界空间内核大小的mip级别。采样一个8 × 8的区域以找到平均阻塞深度，只需要16次GatherRed()纹理调用。一旦半影估计被发现，高分辨率的mip电平用于阴影的尖锐区域，而低分辨率的mip级别用于较软的区域。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927144759.png" class="" title="image-20210927144759">

<p><strong>CHS已经在大量的电子游戏中使用，研究还在继续。例如，Buades等提出了可分离软阴影映射(SSSM)，其中对网格采样的PCSS过程被分割成可分离的部分，元素尽可能从一个像素到另一个像素重用。</strong></p>
<p><strong>一个被证明有助于加速每像素需要多个样本的算法的概念是分层最小/最大阴影贴图。虽然阴影贴图深度通常不能被平均，但是每个mipmap级别的最小值和最大值是有用的。也就是说，可以形成两个mipmap，一个保存每个区域中最大的z- depth(有时称为HiZ)，一个保存最小的z- depth。给定一个texel位置、深度和要采样的面积，mipmaps可以用来快速确定完全光照和完全阴影的条件。例如，如果texel的z-depth大于mipmap中存储的对应区域的最大z-depth，那么texel必须处于阴影中-不需要进一步的采样。这种类型的阴影地图使得确定光线能见度的任务更加有效。</strong></p>
<p><strong>PCF等方法通过对附近的接收器位置进行采样来工作。PCSS通过寻找附近遮挡器的平均深度来工作。这些算法不直接考虑光源的面积，而是取样附近的表面，并受到阴影贴图分辨率的影响。PCSS背后的一个主要假设是，平均阻滞剂是半影大小的合理估计。当两种遮挡器，比如一盏路灯和一座遥远的山，部分遮挡同一表面上的一个像素时，这种假设就被打破了，并可能导致伪影。理想情况下，我们希望确定从单个接收器位置可见光源面积的多少。一些研究人员已经探索了使用GPU的反投影。这个想法是将每个接收器的位置作为一个视点，将区域光源作为视点平面的一部分，并将遮挡器投射到这个平面上。Schwarz和Stamminger和Guennebaud等都总结了之前的工作，并提出了自己的改进。Bavoil等人采用了不同的方法，使用深度剥离创建多层阴影贴图。反投影算法可以给出很好的结果，但(到目前为止)每像素的高成本意味着它们还没有被应用到交互式应用中。</strong></p>
<h2 id="Filtered-Shadow-Maps-过滤阴影贴图"><a href="#Filtered-Shadow-Maps-过滤阴影贴图" class="headerlink" title="Filtered Shadow Maps 过滤阴影贴图"></a>Filtered Shadow Maps 过滤阴影贴图</h2><p><strong>Donnelly 和 Lauritzen的 variance shadow map (VSM)是一种允许对生成的阴影图进行过滤的算法。该算法将深度存储在一个映射中，将深度平方存储在另一个映射中。当生成地图时，可以使用MSAA或其他抗锯齿方案。这些地图可以被模糊处理、映射、放入求和区域表或任何其他方法。将这些地图视为可过滤纹理的能力是一个巨大的优势，因为当从它们检索数据时，可以使用整个采样和过滤技术阵列。</strong></p>
<p><strong>我们将在这里对VSM进行一些深入的描述，以说明这个过程是如何工作的;同样，这类算法中的所有方法都使用相同类型的测试。有兴趣进一步了解这一领域的读者可以查阅相关参考资料，我们也推荐Eisemann等人的书，这本书为这一主题提供了相当大的空间。</strong></p>
<p><strong>首先，对于VSM，深度图在接收器的位置取样(仅一次)，以返回最近光遮挡器的平均深度。当这个平均深度M1，称为第一矩，大于阴影上接收机深度t时，则认为接收机完全处于光照中。当平均深度小于接收机深度时，用下式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927205951.png" class="" title="image-20210927205951">

<p><strong>pmax 样品的最大百分比是在光，σ² 为方差，t为受者深度，M1 是阴影图中预期的平均深度。深度平方阴影贴图的样本M2，称为第二矩，用于计算方差:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927205959.png" class="" title="image-20210927205959">

<p><strong>pmax 是接收端可见性百分比的上限。实际照度百分比p不能大于此值。这个上界来自Chebyshev不等式的片面变型。这个方程试图用概率论来估计，在表面位置上遮挡物的分布有多少超出了表面到光的距离。Donnelly和Lauritzen表明，对于平面闭塞器和平面接收器在固定深度，p = pmax，所以公式可以作为许多真实阴影情况的一个很好的近似。</strong></p>
<p><strong>Myers建立了一种关于为什么这种方法有效的直觉。在阴影边缘区域的方差增加。深度差异越大，方差就越大。(t−M1)²项是可见性百分比的重要决定因素。如果这个值略高于零，这意味着平均遮挡深度比接收深度更接近光，pmax 然后接近1(完全点亮)。这种情况会发生在半影完全亮着的边缘。进入半影，平均遮挡深度变得更接近光，所以这一项变得更大，pmax 下降。与此同时，方差本身在半影中发生变化，从边缘的几乎为零到最大的方差，其中遮挡器在深度上不同，并平等地共享该区域。这些项相互平衡，在半影上形成线性变化的阴影。与其他算法的对比如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927210244.png" class="" title="image-20210927210244">

<p>左上方是标准阴影映射。右上方，透视阴影贴图，增加观察者附近阴影贴图的纹理密度。左下角，接近百分比的软阴影，随着闭塞器与接收器的距离增加，阴影变得柔和。右下角是具有恒定软阴影宽度的方差阴影映射，每个像素用单个方差映射样本进行着色。(图片由Nico Hempe、Yvonne Jung和Johannes Behr提供。)</p>
<p><strong>方差阴影映射的一个重要特征是，它可以以一种优雅的方式处理由于几何原因造成的表面偏差问题。Lauritzen推导了如何利用表面的斜率来修改二阶矩的值。来自数值稳定性的偏差和其他问题可能是方差映射的问题。例如，式减去一个较大的值从另一个相似的值。这种类型的计算往往夸大了基础数字表示的准确性的缺乏。使用浮点纹理可以帮助避免这个问题。</strong></p>
<p><strong>总的来说，由于GPU优化的纹理能力得到了有效的利用，VSM的处理时间显著提高了质量。而PCF需要更多的样本，因此需要更多的时间，为了避免产生柔和阴影时的噪声，VSM可以只用一个高质量的样本来确定整个区域的效果，从而产生一个平滑的半影。这种能力意味着阴影可以在算法的限制范围内，在没有额外成本的情况下任意软化。</strong></p>
<p><strong>与PCF一样，滤波核的宽度决定了半影的宽度。通过寻找接收机和最近的遮挡器之间的距离，可以改变核宽度，从而给出令人信服的软阴影。mimapapping样本是一个缓慢增加宽度的半影覆盖范围的差估计器，创建了方框伪影。Lauritzen详细介绍了如何使用求和面积表来提供更好的阴影效果。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927210423.png" class="" title="image-20210927210423">

<p>方差阴影映射，其中到光源的距离从左到右增加。(图片来自NVIDIA SDK 10样本，由NVIDIA公司提供。)</p>
<p><strong>当两个或更多的遮挡器覆盖一个接收器并且一个遮挡器靠近接收器时，沿半影区域的方差阴影映射中断。概率理论中的Chebyshev不等式将产生一个与正确的光百分比无关的最大光值。最近的遮光器，由于只部分地隐藏光，抛弃了方程的近似值。这导致轻度出血(又称透光)，完全闭塞的区域仍然接受光照。参见下图。通过在更小的区域上获取更多的样本，可以解决这个问题，将方差阴影映射变成一种PCF形式。与PCF一样，速度和性能都需要权衡，但对于阴影深度复杂度较低的场景，方差映射效果很好。Lauritzen给出了一种由艺术家控制的方法来改善这个问题，即将低百分比视为完全阴影，并将其余百分比范围重新映射为0%到100%。这种方法使光出血变暗，以缩小整个半影为代价。虽然光出血是一个严重的限制，但由于这种阴影很少涉及多个遮挡器，所以VSM在从地形生成阴影方面是很好的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927210547.png" class="" title="image-20210927210547">

<p>在左边，方差阴影映射应用于茶壶。在右边，一个三角形(没有显示)在茶壶上投下阴影，在地上的阴影中造成了令人讨厌的伪影。(图片由Marco Salvi提供。)</p>
<p><strong>利用滤波技术快速产生平滑阴影的前景在滤波阴影映射中产生了很大的兴趣;主要的挑战是解决各种出血问题。Annen等人引入了卷积阴影映射。扩展了Soler和Sillion的平面算法背后的想法接收器，其思想是将阴影深度编码为傅立叶展开。与方差阴影映射一样，这样的映射可以被过滤。该方法收敛到正确答案，从而减少了漏光问题。</strong></p>
<p><strong>卷积阴影映射的一个缺点是需要计算和访问几个项，大大增加了执行和存储成本。Salvi和Annen等人同时独立地想到了使用基于指数函数的单一项的想法。这种方法被称为指数阴影映射(ESM)或指数方差阴影映射(EVSM)，它将深度的指数和其二阶矩保存到两个缓冲区中。指数函数更接近于阴影映射执行的阶跃函数。因此，这可以显著减少出血的假象。它避免了卷积阴影映射的另一个问题，称为振铃，轻微的光泄漏可能发生在特定深度刚刚超过原始遮挡器的深度。</strong></p>
<p><strong>存储指数值的一个限制是，第二阶矩值可能变得非常大，因此使用浮点数会超出范围。为了提高精度，并使指数函数下降得更陡，可以生成z-深度，使其为线性。</strong></p>
<p><strong>由于指数阴影映射方法的质量优于VSM，且与卷积映射方法相比，其存储容量更低，性能更好，因此在三种滤波方法中最受关注。Pettineo注意到其他几个改进，例如使用MSAA来改善结果和获得有限的透明度的能力，并描述了如何利用计算着色器提高过滤性能。</strong></p>
<p><strong>最近，Peters和Klein引入了矩影映射。它提供了更好的质量，尽管以使用四分钟或更多的时间为代价，增加了存储成本。可以通过使用16位整数来存储矩来降低这个代价。Pettineo实现了这种新方法，并将其与ESM进行了比较，提供了一个探索多种变体的代码库。</strong></p>
<p><strong>级联阴影映射技术可以应用于滤波映射以提高精度。级联ESM相对于标准级联映射的一个优点是，可以为所有级联设置一个偏差因子。Chen和Tatarchuk详细介绍了级联ESM遇到的各种透光问题和其他文物，并提出了一些解决方案。</strong></p>
<p><strong>过滤映射可以被认为是PCF的一种廉价形式，它只需要很少的示例。像PCF一样，这种阴影的宽度是恒定的。这些过滤的方法都可以与PCSS一起使用，以提供可变宽度的半影。力矩阴影贴图的扩展还包括提供光散射和透明效果的能力。</strong></p>
<h2 id="Volumetric-Shadow-Techniques-体积阴影技术"><a href="#Volumetric-Shadow-Techniques-体积阴影技术" class="headerlink" title="Volumetric Shadow Techniques 体积阴影技术"></a>Volumetric Shadow Techniques 体积阴影技术</h2><p><strong>透明的物体会减弱并改变光的颜色。对于一些透明对象集合，可以使用类似于第5.5节中讨论的技术来模拟这种效果。例如，在某些情况下，可以生成第二种阴影地图。将透明对象渲染到它，并存储最近的深度和颜色或alpha覆盖。如果接收端没有被不透明的阴影贴图阻塞，则测试透明深度贴图，如果被遮挡，则根据需要检索颜色或覆盖率。这个想法让人想起第7.2节中的阴影和光投影，存储的深度避免在透明物体和光线之间投影到接收器上。这种技术不能应用于透明物体本身。</strong></p>
<p><strong>对于头发和云彩等物体的真实渲染来说，自阴影是至关重要的，因为这些物体要么很小，要么是半透明的。单深度阴影贴图不适用于这些情况。Lokovic和Veach首先提出了深阴影贴图的概念，在这个概念中，每个阴影贴图texel存储了一个关于光线如何随深度下降的函数。这个函数通常由一系列不同深度的样本来近似，每个样本都有一个不透明度值。在地图的两个样本，括号给定位置的深度是用来寻找阴影的效果。GPU面临的挑战是如何高效地生成和评估这些函数。这些算法使用了类似的方法，遇到了一些与顺序无关的透明算法(章节5.5)遇到的类似挑战，比如忠实地表示每个函数所需的数据压缩存储。</strong></p>
<p><strong>Kim和Neumann首先提出了一种基于GPU的方法，他们称之为不透明度阴影地图。仅存储不透明度的地图生成在一个固定的深度集。Nguyen和Donnelly给出了这种方法的更新版本。然而，由于深度切片都是平行且均匀的，由于线性插值，需要大量的切片来隐藏切片之间的不透明度伪影。Yuksel和Keyser通过创建更接近模型形状的不透明度地图来提高效率和质量。这样做可以减少所需的层数，因为对每一层的评估对最终图像更重要。</strong></p>
<p><strong>为了避免依赖固定切片设置，人们提出了更多的自适应技术。Salvi等人引入了自适应体积阴影贴图，其中每个阴影贴图texel同时存储不透明度和层深。像素着色器操作用于有损压缩数据流(表面不透明度)，因为它是栅格化。这避免了需要无限的内存来收集所有的样本并在一个集合中处理它们。该技术类似于深阴影贴图，但在像素着色器中进行了动态压缩步骤。将函数表示限制为一个小的、固定数量的存储不透明度/深度对，使得GPU上的压缩和检索更加高效。由于需要读取、更新和回写曲线，因此成本高于简单的混合，这取决于用于表示曲线的点的数量。在这种情况下，该技术还需要支持无人机和ROV功能的最新硬件(章节3.8的末尾)。如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927210945.png" class="" title="image-20210927210945">

<p>头发和烟雾渲染与自适应体积阴影贴图。(转载由Marco Salvi和英特尔公司许可，版权属英特尔公司，2010年。)</p>
<p><strong>在游戏GRID2中，采用自适应体积阴影映射方法进行逼真的烟雾渲染，平均成本低于2 ms/frame。F¨urst等人描述并提供了他们为电子游戏实现深度阴影贴图的代码。他们使用链表来存储深度和alpha，并使用指数阴影映射来提供光照和阴影区域之间的软过渡。</strong></p>
<p><strong>阴影算法的探索仍在继续，各种算法和技术的综合变得越来越普遍。例如，Selgrad等人研究了用链表存储多个透明样本，并使用带有分散写操作的计算着色器来构建地图。他们的作品使用了深阴影贴图的概念，以及过滤贴图和其他元素，为提供高质量的软阴影提供了一个更普遍的解决方案。</strong></p>
<h2 id="Irregular-Z-Buffer-Shadows-不规则Z缓存阴影"><a href="#Irregular-Z-Buffer-Shadows-不规则Z缓存阴影" class="headerlink" title="Irregular Z-Buffer Shadows 不规则Z缓存阴影"></a>Irregular Z-Buffer Shadows 不规则Z缓存阴影</h2><p><strong>各种各样的阴影贴图方法之所以流行有几个原因。它们的成本是可预测的，并且可以很好地扩展场景大小，最坏情况下与原语的数量成线性关系。它们可以很好地映射到GPU上，因为它们依赖于光栅化来定期采样光线对世界的看法。然而，由于这种离散采样，问题出现了，因为眼睛看到的位置与光线看到的位置不是一对一的映射。当光线对一个表面的采样频率低于人眼时，就会出现各种走样问题。即使取样率是可比较的，也存在偏差问题，因为表面取样的位置与人眼看到的位置略有不同。</strong></p>
<p><strong>阴影体积提供了一个精确的解析解，因为光线与表面的相互作用产生了一组三角形，定义了任何给定位置是处于光照还是阴影中。该算法在GPU上实现时的不可预测成本是一个严重的缺点。近年来探索的改进是诱人的，但还没有一个“存在的证据”被采纳在商业应用。</strong></p>
<p><strong>另一种分析阴影测试方法在较长时期内可能有潜力:光线追踪。在第11.2.2节中详细描述了它的基本思想，特别是对于阴影。一束光线从接收器位置射向光线。如果发现任何物体挡住了光线，接收器就处于阴影中。快速射线跟踪器的大部分代码都致力于生成和使用分层数据结构，以最小化每条射线所需的对象测试数量。为动态场景构建和更新这些结构是一个有几十年历史的话题和持续的研究领域。</strong></p>
<p><strong>另一种方法是使用GPU的光栅化硬件来查看场景，但是除了z深度之外，还存储了关于光线每个网格单元中闭塞器边缘的额外信息。例如，想象在每个阴影贴图texel中存储重叠网格单元格的三角形列表。这样的列表可以通过保守栅格化生成，即如果三角形的任何部分重叠像素，而不仅仅是像素的中心，则生成一个碎片(章节23.1.2)。这种方案的一个问题是，每个texel的数据量通常需要被限制，这反过来会导致在确定每个接收器位置的状态时不准确。考虑到GPU的现代链表原理，每个像素存储更多数据当然是可能的。然而，除了物理内存限制外，在每个texel的列表中存储可变数量的数据的问题是GPU处理会变得非常低效，因为单个warp可能有几个片段需要检索和处理许多项的线程，而其余线程是空闲的，没有工作要做。构造着色器以避免由于动态“if”语句和循环导致的线程发散对性能至关重要。</strong></p>
<p><strong>在阴影贴图中存储三角形或其他数据并测试接收器位置的另一种方法是翻转问题，存储接收器位置，然后针对每个位置测试三角形。Johnson等人和Aila and Laine首先探索了这种保存接收机位置的概念，称为不规则z-缓冲区(IZB)。这个名字有点误导人，因为缓冲区本身有一个正常的、规则的阴影贴图形状。相反，缓冲区的内容是不规则的，因为每个阴影贴图texel将有一个或多个接收器位置存储在里面，或者可能根本没有。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210929131651.png" class="" title="image-20210929131651">

<p>不规则z-buffer。在左上角，眼睛在像素中心产生了一组点。两个三角形形成一个立方体的面显示。在右上角，这些点是从光线的角度显示出来的。在左下角，一个阴影贴图网格被应用。对于每个texel，将生成网格单元格内所有点的列表。在右下角，通过保守的栅格化对红色三角形进行阴影测试。在每一个被触摸的texel(显示为淡红色)上，它列表中的所有点都被测试在光线下的可见性。(下面的光栅图像由Timo Aila和Samuli Laine提供。)</p>
<p><strong>使用Sintorn等人和Wyman等人提出的方法，一个多通道算法创建IZB，并测试其内容从光的能见度。首先，场景从眼睛渲染，以找到从眼睛看到的表面的z深度。这些点被转换为场景中的光视图，并且从这个集合中形成了光的截锥。然后这些点被储存在光的IZB中，每一个点都被放入一个对应texel的列表中。注意，有些列表可能是空的，光线可以看到空间的体积，但眼睛看不到表面。遮光器被保守地栅格化到光的IZB，以确定是否有任何点被隐藏，因此在阴影中。保守的栅格化确保了，即使一个三角形没有覆盖光像素的中心，它也会被测试到它可能重叠的点上。</strong></p>
<p><strong>可见性测试在像素着色器中进行。测试本身可以看作是光线追踪的一种形式。光线从图像点的位置到光线产生。如果一个点在三角形的内部，并且距离三角形的平面更远，那么这个点就被隐藏了。一旦所有的遮挡器都被栅格化，光的可见性结果就被用来遮蔽表面。这个测试也被称为截锥跟踪，因为三角形可以被认为是定义了一个视图截锥，检查其体积中包含的点。</strong></p>
<p><strong>仔细的编码是使这种方法与GPU良好工作的关键。Wyman等人指出，他们的最终版本比最初的原型快两个数量级。部分性能的提高是直接的算法改进，比如剔除表面法线背光的图像点(所以总是没有光照)，避免为空像素生成碎片。其他性能的提高来自于改进GPU的数据结构，以及通过在每个像素中使用短的、相似长度的点列表来最小化线程发散。上图显示了一个带有长列表的低分辨率阴影图。理想情况是每个列表有一个图像点。更高的分辨率提供更短的列表，但也增加了闭塞器生成的碎片的数量进行评估。</strong></p>
<p><strong>从上图左下方的图像中可以看出，由于透视效果的影响，地平面左侧可见点的密度明显高于右侧。使用级联阴影贴图可以通过聚焦更接近眼睛的光线贴图来降低这些区域的列表大小。</strong></p>
<p><strong>这种方法避免了其他方法的采样和偏差问题，并提供了完美的清晰阴影。出于美学和感知的原因，软阴影通常是需要的，但可能会有偏置问题与附近的闭塞器，如Peter Panning。Story和Wyman探索混合阴影技术。核心思想是使用遮挡距离来混合IZB和PCSS阴影，当遮挡距离较近时使用硬阴影结果，当遮挡距离较远时使用软阴影结果。参见下图。阴影质量对于附近的物体通常是最重要的，所以IZB的成本可以通过只在一个选定的子集上使用这种技术来降低。这个解决方案已经成功地应用于电子游戏中。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210929131955.png" class="" title="image-20210929131955">

<p>在左边，PCF为所有物体提供均匀柔和的阴影。在中间，PCSS通过距离遮挡器的距离来软化阴影，但是树枝阴影重叠在箱子的左上角会产生伪影。在右侧，来自IZB的锐利阴影与来自PCSS的柔和阴影混合，得到了改进的结果。(图片来自育碧的《Tom Clancy’s The Division》。)</p>
<h2 id="Other-Applications-其他应用"><a href="#Other-Applications-其他应用" class="headerlink" title="Other Applications 其他应用"></a>Other Applications 其他应用</h2><p><strong>将阴影贴图定义为一个空间体量，将光与暗分开，也可以帮助确定物体的哪些部分需要阴影。Gollent描述了CD Projekt的地形阴影系统如何计算每个仍然被遮挡的区域的最大高度，然后不仅可以用于地形，还可以用于场景中的树木和其他元素的阴影。为了找到每个高度，可见区域的阴影图被渲染为太阳。然后检查每个地形高度场位置的太阳能见度。如果在阴影中，太阳第一次可见的高度是通过增加一个固定的步长来估计的，直到太阳进入视野，然后执行二元搜索。换句话说，我们沿着一条垂直线前进，并迭代以缩小它与分离光明与黑暗的阴影地图表面相交的位置。邻近高度被插值，以在任何位置找到这个闭塞高度。在下图中可以看到一个用于地形高程软阴影的例子。我们将在第14章中看到更多光线穿越光明和黑暗区域的用法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210929132203.png" class="" title="image-20210929132203">

<p>地形与太阳第一次看到的高度计算每个高度场位置。注意沿着阴影边缘的树是如何被正确遮蔽的。(CD PROJEKT R, The Witcher R是CD PROJEKT Capital Group的注册商标。The Witcher game c CD PROJEKT S.A.版权所有《巫师》游戏是根据Andrzej Sapkowski的散文改编的。所有其他版权和商标均为其各自所有者的财产。)</p>
<p><strong>最后一个值得一提的方法是渲染屏幕空间阴影。阴影图往往不能产生精确的遮挡小特征，因为他们的分辨率有限。这在渲染人脸时尤其成问题，因为我们特别容易注意到人脸上的任何视觉伪影。例如，渲染发光的鼻孔(当不是有意的时候)看起来很刺耳。虽然使用更高分辨率的阴影图或单独的阴影图只针对感兴趣的区域可以有所帮助，但另一种可能性是利用已经存在的数据。在大多数现代的渲染引擎中，深度缓冲从相机的角度，来自早期的预印版，在渲染过程中是可用的。存储在其中的数据可以当作高度场来处理。通过迭代采样这个深度缓冲区，我们可以执行一个射线行进过程(章节6.8.1)，并检查朝向光线的方向是否未被遮挡。虽然成本很高，因为它需要重复采样深度缓冲区，但这样做可以为过场动画中的特写提供高质量的结果，在这方面花费额外的毫秒通常是合理的。该方法由Sousa at al.提出，目前在许多游戏引擎中普遍使用。</strong></p>
<p><strong>总结整个章节，阴影映射在某些形式是迄今为止最常用的算法用于投射到任意曲面形状上的阴影。级联阴影贴图提高采样质量时，阴影投射在一个大的区域，如室外场景。通过SDSM找到一个合适的近平面最大距离可以进一步提高精度。接近百分比滤波(PCF)使阴影具有一定的柔和性，接近百分比软阴影(PCSS)及其变体具有接触硬化性，而不规则z缓冲区可以提供精确的硬阴影。滤波后的阴影图提供了快速的软阴影计算，当遮挡器远离接收器时工作得特别好，就像地形一样。最后，屏幕空间技术可以用于提高精度，尽管成本相当高。</strong></p>
<p><strong>在本章中，我们重点讨论了当前应用程序中使用的关键概念和技术。每一种都有自己的优势，选择取决于世界的大小、组成(静态内容vs动画)、材质类型(不透明、透明、头发或烟雾)，以及灯光的数量和类型(静态或动态;本地或遥远;点、点或区域)，以及一些因素，如底层纹理可以隐藏任何工件的程度。GPU的性能在不断发展和改进，因此我们预计在未来几年将继续看到新的算法能够很好地映射到硬件上。例如，章节19.10.1中描述的稀疏纹理技术已被应用于阴影贴图存储以提高分辨率。sintorn用一种创造性的方法，K¨ampe等人探索了将用于照明的二维阴影图转换为三维体素集的想法(小盒子;见13.10节)。使用体素的一个优点是它可以被分类为有光或有影，因此需要最小的存储空间。高度压缩稀疏体素八叉树表示为大量的光和静态遮挡器存储阴影。Scandolo等人将他们的压缩技术与使用双阴影映射的基于区间的方案结合起来，得到了更高的压缩率。Kasyan[865]使用体素锥跟踪(第13.10节)从区域灯光生成柔和阴影。如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210929132401.png" class="" title="image-20210929132401">

<p>在顶部是一个用基本的软阴影近似生成的图像。在底部是基于体素的区域光阴影，使用圆锥跟踪，在场景的体素化。注意，汽车的阴影更加弥散。光照也因一天中时间的变化而不同。(图片由Crytek提供。)</p>
<h1 id="8-Light-and-Color-光照和颜色"><a href="#8-Light-and-Color-光照和颜色" class="headerlink" title="8 Light and Color 光照和颜色"></a>8 Light and Color 光照和颜色</h1><h2 id="Light-Quantities-光量"><a href="#Light-Quantities-光量" class="headerlink" title="Light Quantities 光量"></a>Light Quantities 光量</h2><p><strong>任何基于物理的渲染方法的第一步都是以精确的方式量化光。首先介绍辐射度量学，因为这是与光的物理传输有关的核心领域。我们接着讨论光度学，这涉及由人眼灵敏度加权的光值。我们对颜色的感知是一种心理物理现象:对物理刺激的心理感知。颜色感知在比色法一节中讨论。最后讨论了用RGB颜色值绘制图像的有效性。</strong></p>
<h3 id="Radiometry-辐射度量学"><a href="#Radiometry-辐射度量学" class="headerlink" title="Radiometry 辐射度量学"></a>Radiometry 辐射度量学</h3><p><strong>辐射度量学研究的是电磁辐射的测量。这种辐射以波的形式传播，将在第9.1节中详细讨论。不同波长的电磁波——相同相位的两个相邻点之间的距离，例如两个相邻的峰——往往具有不同的性质。在自然界中，电磁波存在于一个巨大的波长范围，从长度不到百分之一纳米的伽马波到数万公里长的极低频(ELF)无线电波。人类可以看到的海浪由这个范围的一小部分组成，从紫光的约400纳米到红光的略高于700纳米。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930102945.png" class="" title="image-20210930102945">

<p>可见光的波长范围，在整个电磁波谱中显示。</p>
<p><strong>辐射量的存在是为了测量电磁辐射的各个方面:总能量、功率(随时间变化的能量)和功率密度与面积、方向或两者有关。下表总结了这些量。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930103037.png" class="" title="image-20210930103037">

<p>辐射的量和单位。</p>
<p><strong>在放射学中，基本单位是辐射通量Φ。辐射通量是辐射能随时间——功率的流动，以瓦特(W)为单位。</strong></p>
<p><strong>辐照度是辐射通量相对于面积的密度，即dΦ/ dA。辐照度是根据一个区域来定义的，这个区域可能是空间中的一个想象区域，但通常是物体的表面。它的计量单位是瓦特每平方米。</strong></p>
<p><strong>在我们讨论下一个量之前，我们需要先介绍立体角的概念，它是角概念的三维扩展。角度可以被认为是一个平面上连续方向集的大小的度量单位，其弧度值等于这组方向集与半径为1的外圆相交的弧的长度。同样，立体角测量三维空间中连续方向集的大小，用立体角(缩写为“sr”)测量，立体角是由半径为1的外接球面上的交点面积定义的。实心角用ω符号表示。</strong></p>
<p><strong>在二维空间中，2π弧度的角覆盖整个单位圆。将此扩展到三维，一个4π立体角将覆盖单位球的整个面积。一个立体角的大小可以在下图中看到。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930103310.png" class="" title="image-20210930103310">

<p>圆锥体从圆角球的剖面图上去掉一个立体角的圆锥体。形状本身与测量无关。球表面的覆盖率是关键。</p>
<p><strong>现在我们可以引入辐射强度I，这是相对于方向的通量密度——更准确地说，是立体角(dΦ/dω)。它的测量单位是瓦特每立体角。</strong></p>
<p><strong>最后，辐射亮度(L)是对单条射线的电磁辐射的测量。更准确地说，它被定义为辐射通量相对于面积和立体角的密度(dΦ²/dAdω)。这个面积是在垂直于射线的平面上测量的。如果在其他方向上对表面施加辐射，则必须使用余弦校正因子。你可能会遇到用术语“投影面积”来指代这个校正因子的辐亮度定义。</strong></p>
<p><strong>亮度是传感器(如眼睛或相机)所测量的(更多细节见9.2节)，所以它在渲染中是最重要的。计算着色方程的目的是计算沿给定光线从着色表面点到相机的亮度。沿着这条射线的L的值与cshaded在物理上是等价的(第5章)。辐射的公制单位是瓦特每平方米每立体角。</strong></p>
<p><strong>环境中的辐亮度可以看作是五个变量(或六个变量，包括波长)的函数，称为辐亮度分布。其中三个变量指定位置，另外两个指定方向。这个函数描述所有在空间中任何地方传播的光。一种考虑渲染过程的方法是，眼睛和屏幕定义一个点和一组方向(例如，通过每个像素的光线)，这个函数在每个方向的眼睛处进行评估。在第13.4节中讨论的基于图像的渲染使用了一个相关的概念，称为光场。</strong></p>
<p><strong>在着色方程中，辐亮度常以Lo(x, d)或Li(x, d)的形式出现分别表示从x点发出的辐亮度和进入x点的辐亮度。方向向量d表示射线的方向，按照惯例，射线总是指向远离x的方向。而对于Li来说，这种惯例可能有些令人困惑，由于d指向与光传播方向相反的方向，因此便于计算点积等。</strong></p>
<p><strong>辐亮度的一个重要特性是它不受距离的影响，忽略了大气效应，如雾。换句话说，一个表面将有相同的辐射，不管它距离观众的距离。当距离越远时，表面覆盖的像素越少，但从表面到每个像素的辐亮度是恒定的。</strong></p>
<p><strong>大多数光波包含许多不同波长的混合物。这通常被可视化为光谱功率分布(SPD)，这是一个显示光的能量如何在不同波长分布的图。下图显示了三个示例。值得注意的是，尽管在图中，中间和底部spd之间存在显著差异，但它们被认为是相同的颜色。很明显，人眼的光谱仪很差。我们将在8.1.3节中详细讨论颜色视觉。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930103813.png" class="" title="image-20210930103813">

<p>三种不同光波的光谱功率分布。顶部的SPD是绿色激光器，它的光谱分布非常窄。它的波形与简单的正弦波相似。中间的SPD用于由相同的绿色激光器和两个额外的激光器组成的光，一个红色和一个蓝色。这些激光器的波长和相对强度对应于RGB激光投影显示器，显示中性白色。底部的SPD是标准的D65光源，这是一个典型的中性白色参考，旨在代表室外照明。这种spd的能量持续分布在可见光谱中，是典型的自然照明。</p>
<p><strong>所有的辐射量都有光谱分布。由于这些分布是密度在波长上的分布，它们的单位是原始量除以纳米的单位。例如，辐照度的光谱分布以瓦特每平方米每纳米为单位。</strong></p>
<p><strong>由于使用完整的spd进行渲染是很笨拙的，特别是在交互速率下，在实践中辐射量被表示为RGB三元组。在8.1.3节中，我们将解释这些三元组与光谱分布的关系。</strong></p>
<h3 id="Photometry-光度学"><a href="#Photometry-光度学" class="headerlink" title="Photometry 光度学"></a>Photometry 光度学</h3><p><strong>辐射测量学只研究物理量，不考虑人的感知。一个相关的领域，光度学，就像辐射测量学，除了它通过人眼的灵敏度来衡量一切。通过与CIE光度曲线相乘，辐射计算的结果被转换为光度单位，1是一条以555 nm为中心的钟形曲线，代表眼睛对不同波长光的响应。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930104054.png" class="" title="image-20210930104054">

<p>光度曲线。</p>
<p><strong>转换曲线和测量单位是光度学理论和辐射学理论的唯一区别。每个辐射量都有一个等效的光度量。下表显示了每一种的名称和单位。单位都有预期的关系(lux是照明度每平方米)。虽然从逻辑上应该是基本单位，但历史上candela被定义为基本单位，其他单位都是从它派生出来的。在北美，照明设计师使用已被废弃的英制测量单位“ foot-candle”(fc)来代替lux来测量照明度。无论哪种情况，照度是大多数光度计测量的，它在照明工程中很重要。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930104146.png" class="" title="image-20210930104146">

<p>辐射和光度的量和单位。</p>
<p><strong>亮度通常用来描述平面的亮度。例如，高动态范围(HDR)电视屏幕的峰值亮度通常在500到1000nit之间。相比之下，晴空的亮度约为8000nit，60瓦的灯泡约为12万nit，地平线上的太阳约为60万nit。</strong></p>
<h3 id="Colorimetry-比色法"><a href="#Colorimetry-比色法" class="headerlink" title="Colorimetry 比色法"></a>Colorimetry 比色法</h3><p><strong>在第8.1.1节中，我们已经看到我们对光线颜色的感知与光线的SPD(光谱功率分布)密切相关。我们也看到这不是一个简单的一对一对应。上上图中底部和中间的SPDs是完全不同的，但被认为是完全相同的颜色。比色法研究光谱功率分布与颜色感知之间的关系。</strong></p>
<p><strong>人类能分辨大约一千万种不同的颜色。在颜色感知方面，眼睛的视网膜上有三种不同类型的锥状受体，每种受体对不同波长的光作出不同的反应。其他动物有不同数量的颜色感受器，在某些情况下多达15个。所以，对于一个特定的SPD，我们的大脑只能从这些受体接收到三种不同的信号。这就是为什么只用三个数字就可以精确地代表任何颜色刺激。</strong></p>
<p><strong>但是哪三个数字呢?CIE出了一套测量颜色的标准条件，并利用这些条件进行了配色实验。在配色中，三种颜色的光投射在白色屏幕上，使它们的颜色叠加在一起，形成一个补丁。要匹配的测试颜色投影在这个补丁旁边。测试色斑是单一波长的。然后观察者可以使用校准到范围加权[−1,1]的旋钮来改变三种颜色的灯，直到测试颜色匹配。需要一个负权重来匹配一些测试颜色，这样的权重意味着相应的光被添加到波长的测试色斑中。下图显示了三个灯(称为r、g和b)的一组测试结果。灯几乎是单色,每个狭隘的能量分布集中在一个波长:r：645 nm , g：526nm,b：444 nm。每一组相关的函数匹配的重量测试补丁波长称为比对功能。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930105039.png" class="" title="image-20210930105039">

<p>r, g，和b 2度颜色匹配曲线，来自Stiles和Burch。这些配色曲线不能与配色实验中使用的光源的光谱分布相混淆，后者是纯波长的。</p>
<p><strong>这些函数提供的是一种将频谱功率分布转换为三个值的方法。给定单一波长的光，可以从图中读出三种颜色的光设置，设置旋钮，并创建光照条件，使屏幕上的两个光块产生相同的感觉。对于任意的光谱分布，颜色匹配函数可以乘以分布和每个结果曲线下的面积(即积分)给出相对数量将彩色的光设置成与光谱产生的可感知的颜色相匹配。相当不同的光谱分布可以解析相同的三个权值，即它们在观察者看来是一样的。给出匹配权重的谱分布称为超谱分布。</strong></p>
<p><strong>三个加权的r、g、b光不能直接代表所有可见的颜色，因为它们的配色函数对不同波长的光都有负权值。CIE提出了三种不同的假设光源的颜色匹配函数，对所有可见波长都是积极的。这些曲线是原始的r, g, b颜色匹配函数的线性组合。这就要求光源的光谱功率分布在某些波长是负的，所以这些光是无法实现的数学抽象。它们的颜色匹配函数记为ˉx(λ)， ˉy(λ)， ˉz(λ)，如下图所示。配色函数y(λ)与光度曲线相同，因为辐亮度通过该曲线转换为亮度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930105434.png" class="" title="image-20210930105434">

<p>Judd-Vos-modified CIE(1978)二度颜色匹配函数。注意，这两个x是同一曲线的一部分。</p>
<p><strong>与前面的颜色匹配函数集一样，ˉx(λ)，ˉy(λ)，ˉz(λ)被用来通过乘法和积分将任何SPDs(λ)减少到三个数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930105528.png" class="" title="image-20210930105528">

<p><strong>这些X、Y和Z三刺激值是在CIE XYZ空间中定义颜色的权重。把颜色分为亮度(亮度)和色度通常是很方便的。色度是一种与亮度无关的颜色的特性。例如，两种深浅不同的蓝色，一种深一种亮，尽管亮度不同，却可以具有相同的色度。</strong></p>
<p><strong>为此，CIE通过将颜色投射到X +Y +Z = 1平面上定义了一个二维色度空间。参见下图。这个空间中的坐标称为x和y，计算方法如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930105722.png" class="" title="image-20210930105722">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930105757.png" class="" title="image-20210930105757">

<p>CIE RGB三原色的RGB颜色立方体显示在XYZ空间，以及它在X + Y + Z = 1平面上的投影(紫色)。蓝色轮廓线包含可能的色度值空间。从原点辐射出来的每条线都有一个恒定的色度值，只在亮度上变化。</p>
<p><strong>z值不提供额外的信息，所以通常省略它。色度坐标x和y值的曲线称为CIE 1931色度图。参见下图。图中曲线的轮廓表示了可见光谱的颜色所处的位置，而连接光谱两端的直线称为紫色线。黑点表示光源D65的色度，它是常用的白点，用来定义白色或无色(无色)刺激的色度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930105927.png" class="" title="image-20210930105927">

<p>CIE 1931色度图。这条曲线用相应的纯色的波长标记。白色三角形和黑点分别显示色域和白点，用于sRGB和Rec. 709颜色空间。</p>
<p><strong>总而言之，我们首先进行了一个实验，使用了三种单波长光，并测量了每种光需要多少光才能与其他波长的光相匹配。有时这些纯光必须添加到被观察的样品，以匹配。这提供了一组颜色匹配函数，将它们组合起来创建一个没有负值的新集合。有了这个非负的颜色匹配函数集在手，我们可以将任何光谱分布转换为XYZ坐标，XYZ坐标定义了颜色的色度和亮度，可以简化为xy来描述色度，保持亮度不变。</strong></p>
<p><strong>给定一个颜色点(x, y)，从白点通过这个点画一条线到边界(光谱线或紫色线)。色点与区域边缘距离的相对距离就是色的激发纯度。区域边缘上的点定义了主导波长。这些比色术语在图形学中很少遇到。相反，我们使用饱和度和色相，它们分别与激发纯度和主导波长松散相关。饱和度和色调的更精确定义可以在Stone和其他人的书中找到。</strong></p>
<p><strong>色度图描述了一个平面。要完全描述一种颜色需要的第三个维度是Y值，即亮度。这些定义了所谓的xyY坐标系。色度图对于理解颜色在渲染中是如何使用的，以及渲染系统的限制是很重要的。电视或计算机显示器通过使用R、G和B颜色值的一些设置来显示颜色。每个颜色通道控制一个显示原色，该原色发出具有特定光谱功率分布的光。这三种原色中的每一种都根据其各自的颜色值进行缩放，然后将它们加在一起，形成观众所感知的单一光谱功率分布。</strong></p>
<p><strong>色度图中的三角形表示典型电视或电脑显示器的色域。三角形的三个角是三原色，即屏幕所能显示的最饱和的红色、绿色和蓝色。色度图的一个重要性质是，这些极限颜色可以用直线连接起来，以显示整个显示系统的极限。直线代表了通过混合这三种原色所能显示的颜色的极限。白点表示当R、G、B颜色值相等时显示系统产生的色度。重要的是要注意显示系统的全色域是一个三维体积。色度图只显示了这个体积在二维平面上的投影。更多信息请参阅Stone的书。</strong></p>
<p><strong>在渲染中有几个感兴趣的RGB空间，每个都由R、G和B三原色和一个白点定义。为了比较它们，我们将使用一种不同类型的色度图，称为CIE 1976 UCS(均匀色度比例尺)图。这张图是CIELUV颜色空间的一部分，CIE(以及另一个颜色空间CIELAB)采用了CIELUV颜色空间，目的是为XYZ空间提供更统一的感知选择[1707]。在CIE XYZ空间中，颜色对的差异可以达到20倍。CIELUV在此基础上进行了改进，将比率降低到最大4倍。这种增加的感知一致性使得1976年的图在比较RGB空间的色域方面比1931年的图要好得多。对感知统一颜色空间的持续研究最近产生了集成电路ICTCP和Jzazbz空间。这些颜色空间比CIELUV在感知上更统一，特别是对于现代显示器的高亮度和饱和颜色。但是，基于这些颜色空间的色度图还没有被广泛采用，所以我们在本章中使用CIE 1976 UCS图，例如下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930110334.png" class="" title="image-20210930110334">

<p>一张CIE 1976 UCS图显示了三个RGB颜色空间的原色和白点:sRGB, DCI-P3，和ACEScg。sRGB图也可以用于Rec. 709，因为这两个颜色空间有相同的原色和白点。</p>
<p><strong>在上图所示的三个RGB空间中，sRGB是目前为止在实时渲染中最常用的。需要注意的是，在本节中，我们使用“sRGB颜色空间”来指具有sRGB原色和白点的线性颜色空间，而不是第5.6节中讨论的非线性sRGB颜色编码。大多数计算机显示器都是为sRGB颜色空间设计的，同样的原色和白点也适用于Rec. 709颜色空间，这用于高清电视显示器，因此对游戏机来说很重要。然而，越来越多的显示器正在使用更宽的色域。一些用于照片编辑的计算机显示器使用adobe1998彩色空间(未显示)。DCI-P3彩色空间最初是为制作故事片而开发的，现在正得到更广泛的应用。苹果已经在从iphone到mac的产品线中采用了这种颜色空间，其他制造商也纷纷效仿。虽然超高清(UHD)内容和显示器被指定使用极宽色域Rec. 2020彩色空间，但在很多情况下，DCI-P3实际上也被用作UHD的彩色空间。Rec. 2020没有在上图显示，但它的色域非常接近图中的第三个颜色空间，ACEScg。ACEScg色彩空间由美国电影艺术与科学学院(AMPAS)开发，用于故事片的计算机图形渲染。它不打算用作显示颜色空间，而是用作呈现的工作颜色空间，在呈现后将颜色转换为适当的显示颜色空间。</strong></p>
<p><strong>虽然目前sRGB颜色空间在实时渲染中无处不在，但更宽的颜色空间的使用可能会增加。最直接的好处是针对宽色域显示器的应用程序，但即使针对sRGB或Rec. 709显示器的应用程序也有优势。常规的渲染操作，如乘法，在不同的颜色空间中执行时会得到不同的结果，有证据表明，在DCI-P3或ACEScg空间中执行这些操作产生的结果比在线性sRGB空间中执行更精确。</strong></p>
<p><strong>从RGB空间到XYZ空间的转换是线性的，可以用由RGB空间的原色和白点导出的矩阵来完成。通过矩阵反演和串接，可以导出矩阵从XYZ转换到任何RGB空间，或在两个不同的RGB空间之间。注意，在这样的转换之后，RGB值可以是负数或大于1。这些是超出色域的颜色，也就是。，在目标RGB空间中不可复制。可以使用各种方法将这些颜色映射到目标RGB域。</strong></p>
<p><strong>一种常用的转换是将RGB颜色转换为灰度亮度值。因为亮度与Y系数相同，所以这个操作只是RGB到XYZ转换的“Y部分”。换句话说，它是RGB系数和RGB到XYZ矩阵的中间行之间的点积。对于sRGB和Rec. 709空格，公式为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930110837.png" class="" title="image-20210930110837">

<p><strong>这让我们再次回到光度曲线。这条曲线代表了一个标准观察者的眼睛对不同波长的光的反应，乘以三次原色的光谱功率分布，每条结果曲线都被整合。这三个权重就是上面亮度方程的形式。灰度强度值不等于红、绿、蓝的原因是眼睛对不同波长的光有不同的敏感性。</strong></p>
<p><strong>比色法可以告诉我们两种颜色刺激是否匹配，但它不能预测它们的外观。给定的XYZ颜色刺激的出现很大程度上取决于诸如光照、周围的颜色和之前的条件等因素。颜色外观模型(CAM)，如CIECAM02试图处理这些问题并预测最终的颜色外观。</strong></p>
<p><strong>色彩外观建模是更广泛的视觉感知领域的一部分，其中包括掩蔽等效应。这是指在物体上放置高频率、高对比度的图案往往会掩盖缺陷。换句话说，贴图(如Persian rug)将有助于伪装色带和其他着色伪影，这意味着渲染这样的表面会需要更少的努力。</strong></p>
<h3 id="Rendering-with-RGB-Colors-RGB颜色渲染"><a href="#Rendering-with-RGB-Colors-RGB颜色渲染" class="headerlink" title="Rendering with RGB Colors RGB颜色渲染"></a>Rendering with RGB Colors RGB颜色渲染</h3><p><strong>严格地说，RGB值代表知觉量而不是物理量。从技术上讲，使用它们进行基于物理的渲染是一个类别错误。正确的方法是对光谱数量进行绘制计算，通过密集采样或在合适的基础上投影来表示，并在最后转换为RGB颜色。</strong></p>
<p><strong>例如，最常见的渲染操作之一是计算从对象反射的光。物体的表面通常会反射一些波长的光比其他波长的光更多，正如它的光谱反射曲线所描述的那样。计算反射光颜色的严格正确方法是将入射光的SPD乘以每个波长的光谱反射率，得到反射光的SPD，然后将其转换为RGB颜色。相反，在RGB渲染器中，光线和表面的RGB颜色相乘得到反射光的RGB颜色。在一般情况下，这并不能给出正确的结果。为了说明这一点，我们将看一个有点极端的例子，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930111408.png" class="" title="image-20210930111408">

<p>上图显示的是一种用于投影屏幕的材料的光谱反射率。下面两幅图显示了相同RGB颜色的两种光源的光谱功率分布:中间图是RGB激光投影仪，底部图是D65标准光源。屏幕材料会反射大约80%的激光投影仪的光，因为它的反射峰与投影仪的原色一致。然而，它将反射不到20%的来自D65光源的光，因为大部分光源的能量在屏幕的反射峰值之外。这个场景的RGB渲染可以预测屏幕对两种光的反射强度是相同的。</p>
<p><strong>我们的例子展示了为使用激光投影仪而设计的屏幕材料。它在匹配激光投影仪波长的窄波段中具有高反射率，而在大多数其他波长中具有低反射率。这使得它反射来自投影仪的大部分光，但吸收来自其他光源的大部分光。在这种情况下，RGB渲染器将产生严重误差。</strong></p>
<p><strong>然而，上图所示的情况远非典型。实际中遇到的表面的光谱反射率曲线要平滑得多，如下图所示。典型的光源spd类似于D65光源，而不是示例中的激光投影仪。当光源SPD和表面光谱反射率均为光滑时，RGB绘制引入的误差相对较小。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930111517.png" class="" title="image-20210930111517">

<p>黄色香蕉的光谱反射率。</p>
<p><strong>在预测渲染应用中，这些细微的错误可能很重要。例如，两个光谱反射曲线在一个光源下可能具有相同的颜色外观，而在另一个光源下则不然。这个问题被称为异聚体故障或光源异聚体，在喷漆修理的车身部件时就会引起严重的关注。RGB渲染在试图预测这种效果的应用程序中是不合适的。</strong></p>
<p><strong>然而，对于大多数渲染系统，特别是那些交互式应用，不是为了产生预测模拟，RGB渲染惊人地好。即使是故事片离线渲染也只是最近才开始使用光谱渲染，而且它还远未普及。</strong></p>
<p><strong>本节只涉及色彩科学的基础知识，主要是让人们意识到光谱与颜色三幅图的关系，并讨论设备的局限性。下一节将讨论一个相关的主题，即渲染场景颜色到显示值的转换。</strong></p>
<h2 id="Scene-to-Screen-场景到屏幕"><a href="#Scene-to-Screen-场景到屏幕" class="headerlink" title="Scene to Screen 场景到屏幕"></a>Scene to Screen 场景到屏幕</h2><p><strong>本书接下来的几章将重点讨论基于物理的渲染问题。给定一个虚拟场景，基于物理的渲染的目标是计算如果场景是真实的，将会出现的亮度。然而，在这一点上，工作还远远没有完成。最终的结果(显示的帧缓冲区中的像素值)仍然需要确定。在本节中，我们将介绍在此确定过程中涉及的一些考虑事项。</strong></p>
<h3 id="High-Dynamic-Range-Display-Encoding-高动态范围显示编码"><a href="#High-Dynamic-Range-Display-Encoding-高动态范围显示编码" class="headerlink" title="High Dynamic Range Display Encoding 高动态范围显示编码"></a>High Dynamic Range Display Encoding 高动态范围显示编码</h3><p><strong>本节中的内容建立在第5.6节的基础上，该节涵盖了显示编码。我们决定将高动态范围(HDR)显示的覆盖到本节，因为它需要一些主题的背景知识，比如色域，而这些主题在本书的这一部分中还没有讨论过。</strong></p>
<p><strong>第5.6节讨论了标准动态范围(SDR)监视器的显示编码，SDR监视器通常使用sRGB显示标准，SDR电视使用Rec. 709和Rec. 1886标准。这两套标准具有相同的RGB色域和白点(D65)，以及有点相似(但不相同)的非线性显示编码曲线。它们也有大致相似的参考白亮度水平(sRGB为80 cd/m², Rec. 709/1886为100 cd/m²)。这些亮度规格并没有被显示器和电视制造商严格遵守，他们在实践中倾向于制造更明亮的白光水平的显示器。</strong></p>
<p><strong>HDR显示器使用Rec. 2020和Rec. 2100标准。Rec. 2020定义了一个明显更宽的色域的颜色空间，如下图所示，和Rec. 709和sRGB颜色空间相同的白点(D65)。Rec. 2100定义了两种非线性显示编码:感知量化器(PQ)和混合对数伽马(HLG)。HLG编码在渲染情况下使用的不多，所以我们在这里将重点放在PQ上，它定义的峰值亮度值为10,000 cd/m²．</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930112118.png" class="" title="image-20210930112118">

<p>一张CIE 1976 UCS图显示了Rec. 2020和sRGB/Rec的色域和白点(D65)。709彩色空间。还显示了DCI-P3颜色空间的色域，以供比较。</p>
<p><strong>虽然峰值亮度和色域规格对编码目的很重要，但就实际显示而言，它们有些不切实际。在撰写本文时，很少有消费级HDR显示器的峰值亮度水平超过1500 cd/m²．在实际操作中，显示域比Rec. 2020更接近DCI-P3的显示域(也如上图所示)。因此，HDR显示器执行从标准规范到实际显示功能的内部色调和色域映射。这个映射可能会受到应用程序传递的元数据的影响，以指示内容的实际动态范围和色域。</strong></p>
<p><strong>从应用程序方面来看，将图像传输到HDR显示器有三种路径，但根据显示器和操作系统的不同，这三种路径并非都可用:</strong></p>
<pre><code>**1.HDR10：广泛支持在HDR显示器以及PC和控制台操作系统。帧缓冲区格式为每像素32位，每个RGB通道10位无符号整数位，alpha为2位。采用PQ非线性编码和Rec 2020颜色空间。每个HDR10显示模型执行其自己的色调映射，这不是标准化的或文档化的。**

**2.scRGB(线性变体)：仅在Windows操作系统上支持。名义上它使用sRGB原色和白色级，尽管这两者都可以被超越，因为标准支持RGB值小于0和大于1。帧缓冲区格式为每个通道16位，并存储线性RGB值。它可以与任何HDR10显示，因为驱动程序转换为HDR10。它主要是为了方便和向后兼容sRGB。**

**3.Dolby Vision：专用格式，还没有广泛支持在显示器或任何控制台(在撰写本文时)。它使用自定义的每通道12位帧缓冲格式，并使用PQ非线性编码和Rec. 2020颜色空间。显示内部色调映射在模型之间是标准化的(但没有文档记录)。**
</code></pre>
<p><strong>Lottes指出，实际上还有第四种选择。如果仔细调整曝光和颜色，那么HDR显示器可以通过规则的SDR信号路径驱动，效果很好。</strong></p>
<p><strong>scRGB以外的任何选项,作为显示编码步骤的一部分,应用程序需要将像素的RGB值呈现工作空间Rec.2020——需要一个3×3矩阵变换和应用PQ编码,这是更昂贵的比Rec.709或sRGB编码功能。Patry给出了一个廉价的PQ曲线近似。在HDR显示器上合成用户界面(UI)元素时需要特别注意，以确保用户界面是清晰的，并处于舒适的亮度水平。</strong></p>
<h3 id="Tone-Mapping-色调映射"><a href="#Tone-Mapping-色调映射" class="headerlink" title="Tone Mapping 色调映射"></a>Tone Mapping 色调映射</h3><p><strong>在第5.6节和8.2.1节中，我们讨论了显示编码，即为显示硬件将线性亮度值转换为非线性代码值的过程。显示编码所应用的函数是显示器的光电传递函数(EOTF)的逆函数，它确保输入的线性值与显示器发出的线性辐射度匹配。我们之前的讨论忽略了呈现和显示编码之间的一个重要步骤，我们现在准备探索这个步骤。</strong></p>
<p><strong>色调映射或色调再现是将场景辐亮度值转换为显示辐亮度值的过程。在此步骤中应用的转换称为端到端传递函数，或场景到屏幕的转换。图像状态的概念是理解色调映射的关键。有两种基本的形象状态。场景参考图像的定义参考场景辐亮度值，而显示参考图像的定义参考显示辐亮度值。图像状态与编码无关。这两种状态下的图像可以线性编码，也可以非线性编码。下图显示了图像状态、色调映射和显示编码如何在成像管线中结合在一起，该管线处理从初始渲染到最终显示的颜色值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930112847.png" class="" title="image-20210930112847">

<p>合成(渲染)图像的成像管道。我们渲染线性场景参考亮度值，色调映射将其转换为线性显示参考值。显示编码应用逆EOTF将线性显示值转换为非线性编码值(代码)，并传递给显示。最后，显示硬件应用EOTF将非线性显示值转换为从屏幕发射到人眼的线性亮度。</p>
<p><strong>关于色调映射的目标有几个常见的误解。这并不是保证场景到屏幕的转换是一个身份转换，完美地再现了显示场景的辐射值。也不是将场景的高动态范围中的每一个信息“挤”到显示的低动态范围中，尽管考虑场景和显示动态范围的差异确实起到了重要的作用。</strong></p>
<p><strong>为了理解色调映射的目的，最好将它看作是图像复制的一个实例。图像复制的目标是创建一个显示——参考图像的复制——尽可能接近，考虑到显示属性和观看条件——如果观看者正在观察原始场景，他们会产生的知觉印象。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930112954.png" class="" title="image-20210930112954">

<p>图像再现的目的是确保再现(右)所唤起的知觉印象尽可能接近原场景(左)。</p>
<p><strong>有一种图像复制的目标略有不同。首选图像复制的目的是创建一个在某种意义上比原始场景更好看的显示参考图像。稍后将在8.2.3节中讨论首选图像复制。</strong></p>
<p><strong>由于一个典型场景的亮度范围超过了原始场景，因此要再现与原始场景相似的感知印象是一个具有挑战性的目标几个数量级的显示能力。场景中至少一些颜色的饱和度(纯度)也可能远远超过显示能力。然而，正如文艺复兴时期的画家们所做的那样，摄影、电视和电影确实设法产生了令人信服的对原始场景的感知相似性。这一成就是通过利用人类视觉系统的某些特性实现的。</strong></p>
<p><strong>视觉系统弥补绝对亮度的差异，这种能力被称为适应能力。由于这种能力，在昏暗房间的屏幕上再现的室外场景可以产生与原始场景相似的感知，尽管复制的亮度不到原始场景的1%。然而，适应所提供的补偿是不完善的。在较低的亮度水平下，感知到的对比度会降低(史蒂文斯效应)，感知到的“色彩”(亨特效应)也是如此。</strong></p>
<p><strong>其他因素影响实际的或感知的复制对比。显示器的环绕(显示矩形外的亮度水平，例如房间照明的亮度)可能会增加或减少感知到的对比度(巴特尔森-布里尼曼效应)。显示耀斑是由于显示缺陷或屏幕反射而添加到显示图像上的不需要的光线，它会降低图像的实际对比度，通常是相当大的程度。这些效果意味着，如果我们想保持与原始场景相似的感知效果，就必须提高显示参考图像值的对比度和饱和度。</strong></p>
<p><strong>然而，这种反差的增加加剧了一个现有的问题。由于场景的动态范围通常比显示器的动态范围大得多，我们必须选择一个狭窄的亮度值窗口来再现，窗口上方和下方的值被裁剪为黑色或白色。提高对比度会进一步缩小这个窗口。为了部分抵消暗和亮值的裁剪，使用了一个软滚动来带来一些阴影和突出细节。</strong></p>
<p><strong>所有这些都导致了一个s形(s形)的色调复制曲线，类似于光化学薄膜所提供的曲线。这并非偶然。柯达和其他公司的研究人员仔细调整了光化学胶片乳剂的特性，以产生有效和令人满意的图像复制。由于这些原因，“电影的”这个形容词经常出现在色调映射的讨论中。</strong></p>
<p><strong>曝光的概念对于色调映射是至关重要的。在摄影中，曝光指的是控制落在胶片或传感器上的光量。然而，在渲染中，曝光是在色调再现变换之前对场景参考图像进行线性缩放操作。曝光的棘手之处在于确定要采用何种比例因子。色调再现、变换和曝光是紧密联系在一起的。色调变换的设计通常是预期它们将应用于以某种方式曝光的场景参考图像。</strong></p>
<p><strong>通过曝光进行缩放，然后应用色调再现变换的过程是一种全局色调映射，其中相同的映射应用于所有像素。相比之下，局部色调映射过程根据周围像素和其他因素使用不同的像素到像素的映射。实时应用程序几乎已经过时专门使用全局色调映射(除了少数例外)，因此我们将重点讨论这一类型，首先讨论色调再现转换，然后是曝光。</strong></p>
<p><strong>重要的是要记住场景引用的图像和显示引用的图像是完全不同的。物理操作只有在场景引用的数据上才有效。由于显示的限制和我们已经讨论过的各种感知效果，两个图像状态之间总是需要一个非线性变换。</strong></p>
<h4 id="Tone-Reproduction-Transform-色调再现变换"><a href="#Tone-Reproduction-Transform-色调再现变换" class="headerlink" title="Tone Reproduction Transform 色调再现变换"></a>Tone Reproduction Transform 色调再现变换</h4><p><strong>色调再现变换通常表示为一维曲线，将场景引用的输入值映射到显示引用的输出值。这些曲线既可以独立应用于R、G和B值，也可以应用于亮度。在前一种情况下，结果将自动在显示范围内，因为每个显示参考的RGB通道值将在0和1之间。然而，在RGB通道上执行非线性操作(特别是剪切)可能会导致饱和度和色相的偏移，以及所需的亮度偏移。Giorgianni和Madden指出，饱和度的变化在感知上是有益的。大多数复制转换使用的对比度增强来抵消史蒂文斯效应(以及环绕和观看耀斑效应)，将导致相应的饱和度增强，这将抵消亨特效应。然而，色相变化通常被认为是不可取的，现代色调变换试图通过在色调曲线之后应用额外的RGB调整来减少它们。</strong></p>
<p><strong>通过将色调曲线应用到亮度上，可以避免色相和饱和度的变化(或至少减少)。然而，由此产生的显示参考颜色可能超出了显示的RGB范围，在这种情况下，需要将其映射回来。</strong></p>
<p><strong>色调映射的一个潜在问题是，将非线性函数应用到场景涉及的像素颜色可能会导致一些反锯齿技术的问题。这个问题(以及解决它的方法)将在第5.4.2节中讨论。</strong></p>
<p><strong>Reinhard色调再现算子是早期用于实时渲染的色调变换之一。它保持深色值基本不变，而明亮值渐近地变成白色。Drago等人提出了一种有点类似的色调映射算子，该算子具有调整输出显示亮度的能力，这可能使其更适合HDR显示。Duiker在视频游戏中创造了一个接近柯达胶片响应曲线的方法。这条曲线后来被Hable修改以添加更多用户控制，并被用于《神秘海域2》中。Hable在这条曲线上的展示很有影响力，导致“Hable电影曲线”被用于多款游戏中。后来，Hable提出了一种新的曲线，与他早期的工作相比，它有许多优点。</strong></p>
<p><strong>Day呈现的是sigmoid曲线，这是Insomniac Games的游戏以及《使命召唤:高级战争》所使用的曲线。Gotanda创造了模拟胶片和数码相机传感器响应的色调变换。这些都是在《Star Ocean 4》和其他游戏中使用的。Lottes指出显示器耀斑对显示器有效动态范围的影响是显著且高度依赖于房间照明条件。出于这个原因，为用户提供色调映射的调整是很重要的。他提出了一种支持此类调整的色调再现转换，可用于SDR和HDR显示。</strong></p>
<p><strong>学院色彩编码系统(ACES)是由美国电影艺术与科学学院的科学与技术委员会创建的，作为管理电影和电视行业色彩的提议标准。ACES系统将场景到屏幕的转换分成两部分。第一个是参考呈现转换(RRT)，它将场景引用的值转换为一个称为输出颜色编码规范(OCES)的标准、设备无关的输出空间中的显示引用的值。第二部分是输出设备转换(ODT)，它将颜色值从OCES转换为最终的显示编码。有许多不同的ODT，每一个都是为特定的显示设备和查看条件设计的。RRT和适当的ODT的连接创建了整个转换。这种模块化结构便于处理各种显示类型和查看条件。Hart推荐ACES色调映射转换用于需要同时支持SDR和HDR显示的应用程序。</strong></p>
<p><strong>虽然ACES是为电影和电视设计的，但它的转换在实时应用中的应用越来越多。ACES色调映射在Unreal Engine中默认启用，它也被Unity支持。Narkowicz给出了用SDR和HDR ODTs拟合ACES RRT的廉价曲线，Patry也是如此。Hart提出了ACES odt的参数化版本，以支持一系列设备。</strong></p>
<p><strong>HDR显示的色调映射需要一些注意，因为显示器也会应用它们自己的色调映射。Fry提供了一套在Frostbite游戏引擎中使用的色调映射变换。他们申请一个相对积极的色调特别提供再现曲线显示,不再显示使用HDR10信号路径(与一些变化基于显示器的亮度峰值),和没有色调映射显示使用杜比视觉路径(换句话说,他们依靠内置杜比视觉色调映射应用的显示)。Frostbite色调复制转换设计为中性，没有显著的对比或色调变化。目的是通过颜色分级应用任何想要的对比度或色调修改(章节8.2.3)。为此，在集成电路中应用了色调再现变换ICTCP颜色空间，为感知均匀性和色度轴与亮度轴之间的正交性而设计。Frostbite变换色调映射亮度和日益降低饱和度的色度，因为亮度滚动显示白色。这提供了一个没有色相变化的干净的变换。</strong></p>
<p><strong>具有讽刺意味的是，在资产(如火焰效果)出现问题后，Frostbite团队最终修改了转换，使用户能够在显示引用的颜色中重新引入某种程度的色调转换。下图显示了Frostbite转换与本节中提到的其他几个转换的对比。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930114152.png" class="" title="image-20210930114152">

<p>一个场景与四种不同的色调转换应用。差异主要体现在圆圈区域，那里的场景像素值特别高。左上角: clipping(加上sRGB OETF);右上角:Reinhard;左下:Duiker ;右下:Frostbite(色彩保存版本)。Reinhard, Duiker和Frostbite变换都保留了通过剪切丢失的高光信息。然而，Reinhard曲线趋向于在图像较暗的部分去饱和度，而Duiker变换在较暗的区域增加饱和度，这有时被认为是一个理想的特征。通过设计，Frostbite变换保留了饱和度和色调，避免了在其他三张图片左下角的圆圈中看到的强烈色调偏移。(图片来自2018年Electronic Arts Inc.)</p>
<h4 id="Exposure-曝光"><a href="#Exposure-曝光" class="headerlink" title="Exposure 曝光"></a>Exposure 曝光</h4><p><strong>一个常用的技术家族的计算曝光依赖于分析场景参考亮度值。为了避免出现档位，这种分析通常是通过对前一帧进行采样来完成的。</strong></p>
<p><strong>根据Reinhard等人的建议，早期实现中使用的一个度量是日志平均场景亮度。通常，曝光量是通过计算帧的对数平均值来确定的。这个对数平均数是通过执行一系列向下采样的后处理过程来计算的，直到最后计算出帧的单个值。</strong></p>
<p><strong>使用平均值往往对异常值过于敏感，例如，少量的明亮像素可能会影响整个画面的曝光。随后的实现通过使用亮度值的直方图来改善这个问题。直方图可以计算中位数，而不是平均值，中位数更稳健。直方图中的其他数据点可以用于改进结果。例如，在Valve的The Orange Box中，基于第95百分位和中位数的启发式方法用于确定暴露程度。Mittring描述了使用计算着色器来生成亮度直方图。</strong></p>
<p><strong>到目前为止讨论的技术的问题是，像素亮度是一个错误的度量，以驱动曝光。如果我们看看摄影实践，例如安塞尔·亚当斯的区域系统，以及如何使用入射光度计来设置曝光，就会明白，最好是单独使用照明(没有表面反照率的影响)来确定曝光。这样做是可行的，因为初步估计，摄影曝光是用来抵消光线的。这就产生了一种主要显示物体表面颜色的印刷品，这与人类视觉系统的颜色恒定特性相对应。以这种方式处理曝光也确保正确的值传递给色调转换。例如，在电影或电视行业中使用的大多数色调变换被设计成将曝光场景参考值0.18映射到显示参考值0.1，期望0.18代表主导场景照明中18%的灰度卡。</strong></p>
<p><strong>尽管这种方法在实时应用程序中还不常见，但已经开始使用了。例如，《合金装备V:归零地》就有一个基于光照强度的曝光系统。在许多游戏中，静态曝光水平是根据已知的场景光照值手动设置的。这样做可以避免曝光的意外动态变化。</strong></p>
<h3 id="Color-Grading-颜色分级"><a href="#Color-Grading-颜色分级" class="headerlink" title="Color Grading 颜色分级"></a>Color Grading 颜色分级</h3><p><strong>在8.2.2节中，我们提到了首选图像复制的概念，即生成在某种意义上比原始场景更好看的图像。通常情况下，这涉及到对图像颜色的创造性处理，这个过程被称为颜色分级。</strong></p>
<p><strong>数字色彩分级在电影工业中应用已有一段时间了。早期的例子包括电影《O Brother, Where Art Thou?》(2000)和《Am´elie》(2001)。颜色分级通常是通过交互操作示例场景图像中的颜色来实现的，直到达到理想的创造性“外观”。然后将相同的操作序列重新应用于一个镜头或序列中的所有图像。颜色分级从电影传播到游戏，现在它被广泛使用。</strong></p>
<p><strong>Selan展示了如何将颜色分级或图像编辑应用程序中的任意颜色转换“烘焙”到一个三维颜色查找表(LUT)中。通过使用输入R、G和B值作为x、y和z坐标来在表中查找新颜色，这样的表可以应用于从输入到输出颜色的任何映射，直到LUT的分辨率限制。Selan的烘焙过程首先取一个标识符LUT(将每个输入的颜色映射到相同的颜色)，并将其“切片”，以创建一个二维图像。然后将这个切片的LUT图像加载到颜色分级应用程序中，并对其应用定义所需的创造性外观的操作。要注意只对LUT应用颜色操作，避免模糊等空间操作。编辑的LUT然后被保存出来，“打包”到一个三维GPU纹理中，并在渲染应用程序中使用，以便在动态渲染像素上应用相同的颜色转换。Iwanicki提出了一种在LUT中存储颜色变换时减少采样误差的聪明方法，即使用最小二乘最小化。</strong></p>
<p><strong>在后来的出版物中，Selan区分了两种进行颜色分级的方法。在一种方法中，颜色分级是在显示参考图像数据上执行的。另一种方法是对通过显示变换预览的场景参考数据进行颜色分级操作。虽然以显示为参照的颜色分级方法更容易设置，但以场景为参照的分级数据可以产生更高保真度的结果。</strong></p>
<p><strong>当实时应用程序首次采用颜色分级时，参考显示的方法占主导地位。然而，场景参考方法由于其更高的视觉质量而获得了关注。参见下图。将颜色分级应用到场景参考数据中还可以通过将色调映射曲线烘烤到分级LUT来节省一些计算，就像在游戏《Uncharted 4》中所做的那样。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930133523.png" class="" title="image-20210930133523">

<p>这是《神秘海域4》中的一个场景。上面的截图没有颜色分级。另外两张截图都应用了颜色分级操作。为了说明的目的，选择了极端的颜色分级操作(乘以高度饱和的青色)。在左下角的截图中，颜色分级应用于显示参考(post-tone-mapping)图像，在右下角的截图中，颜色分级应用于场景参考(pre-tone-mapping)图像。(UNCHARTED 4 A Thief ’s End  c / TM 2016 SIE. Created and developed by Naughty Dog LLC.)</p>
<p><strong>在查找LUT之前，场景引用的数据必须重新映射到范围[0,1]。在Frostbite引擎中，感知量化器OETF用于此目的，尽管可以使用更简单的曲线。Duiker使用对数曲线，Hable建议使用一到两次的平方根算子。</strong></p>
<p><strong>Hable很好地概述了常见的颜色分级操作和实现注意事项。</strong></p>
<h1 id="9-Physically-Based-Shading-基于物理的着色"><a href="#9-Physically-Based-Shading-基于物理的着色" class="headerlink" title="9 Physically Based Shading 基于物理的着色"></a>9 Physically Based Shading 基于物理的着色</h1><h2 id="Physics-of-Light-物理光"><a href="#Physics-of-Light-物理光" class="headerlink" title="Physics of Light 物理光"></a>Physics of Light 物理光</h2><p><strong>光和物质的相互作用形成了物理上的着色基础。要理解这些相互作用，对光的本质有一个基本的了解是有帮助的。</strong></p>
<p><strong>在物理光学中，光被建模为一种电磁横波，一种垂直于其传播方向的振荡电场和磁场的波。这两个场的振荡是耦合的。磁场和电场矢量是互相垂直的，它们的长度之比是固定的。这个比值等于相速度，这个我们稍后会讨论。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001133449.png" class="" title="image-20211001133449">

<p>光，一种电磁横波。电和磁场矢量振荡在90◦彼此和传播的方向。图中所示的波是可能存在的最简单的光波。它是单色的(只有一个波长λ)和线偏振的(电场和磁场都沿着一条线振荡)。</p>
<p><strong>在上图中，我们看到了一个简单的光波。事实上，它是最简单的——一个完美的正弦函数。这个波有一个波长，用希腊字母λ (lambda)表示。正如我们在第8.1节中所看到的，光的颜色与其波长密切相关。因此，单波长的光被称为单色光，意思是“单色的”。“然而，在实践中遇到的大多数光波是多色的，包含许多不同的波长。</strong></p>
<p><strong>上图中的光波在另一方面非常简单。它是线性极化的。这意味着对于空间中的一个固定点，电场和磁场每一个都沿着一条线来回移动。相比之下，在这本书中，我们将重点放在非偏振光，这是更为普遍的。在非偏振光中，场振荡均匀地分布在垂直于传播轴的所有方向上。尽管它们很简单，但理解单色线偏振波的行为是有用的，因为任何光波都可以被分解成这种波的组合。</strong></p>
<p><strong>如果我们以给定的相位(例如，振幅峰值)跟踪波上的一个点，随着时间的推移，我们会看到它以恒定的速度穿过空间，这就是波的相速度。对于穿过真空的光波，相速度是c，通常被称为光速，大约每秒30万公里。</strong></p>
<p><strong>在8.1.1节中，我们讨论了这样一个事实:对于可见光，单个波长的大小大约在400-700纳米范围内。为了直观地了解这个长度，它大约是一根蜘蛛丝宽度的二分之一到三分之一，而蛛丝本身的宽度还不到人类头发宽度的五十分之一。参见下图。在光学中，讨论特征相对于光波长的大小通常是有用的。在这种情况下，我们可以说蜘蛛丝线的宽度约为2λ-3λ(2-3个光波)，而一根头发的宽度约为100λ-200λ。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001133709.png" class="" title="image-20211001133709">

<p>左边显示的是相对于一根蛛丝的可见光波长，这根蛛丝的宽度略大于1微米。在右边，一根类似的蛛丝被展示在一根人的头发旁边，以提供一些额外的背景。(图片由URnano/罗切斯特大学提供。)</p>
<p><strong>光波携带能量。能量流的密度等于电场大小和磁场大小的乘积，因为磁场大小是成比例的，正比于电场大小的平方。我们把重点放在电场上，因为它对物质的影响比磁场大得多。在渲染中，我们关注的是随时间的平均能量流，它与波幅的平方成正比。这个平均能量流密度就是辐照度，用字母E表示。辐照度及其与其他光量的关系已在第8.1.1节中讨论。</strong></p>
<p><strong>光波线性组合。总波是各分量波的和。然而，由于辐照度与振幅的平方成正比，这似乎会导致一个悖论。例如，对两个相等的波进行求和，是否不会导致“1 + 1 = 4”的辐照度?既然辐照度测量能量流，这不会违反能量守恒吗?这两个问题的答案分别是“有时”和“不”。</strong></p>
<p><strong>为了说明这一点，我们将看一个简单的例子:添加n个单色波，除了相位不同外，它们是相同的。每个n波的振幅为a，如前所述，辐照度为E1 与a²成正比，换句话说就是E1 = ka² 对于某个常数k。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001133912.png" class="" title="image-20211001133912">

<p>将频率、极化和振幅相同的n个单色波加在一起的三种情况。从左到右依次为相干干涉、相干干涉和非相干相加。在每一种情况下，组合波的振幅和辐照度(底部)相对于n个原始波(顶部)显示。</p>
<p><strong>上图显示了这个案例的三个示例场景。在左边，所有的波都以相同的相位排列并相互加强。组合波辐照度为n²倍于单个波的辐照度，即n倍于单个波的辐照度之和。这种情况称为相长干涉。在图的中心，每对波处于相反的相位，相互抵消。组合波的振幅为零，辐照度为零。这种情况是破坏性干扰。</strong></p>
<p><strong>相干叠加和相干干涉是相干叠加的两种特殊情况，其中波峰和波谷以某种一致的方式排列起来。根据相对相位关系，n个相同波的相干叠加可以产生一个辐照度在0到n²之间的波乘以一个单独的波浪。然而，大多数情况下，当波相加时，它们是相互不相干的，如上图。在这个阶段的情景中，振幅是相对随机的。如人们所期望的那样，单个波的辐照度与单个波的辐照度线性相加为n倍。</strong></p>
<p><strong>看来，破坏性和建设性的干涉违反了能量守恒定律。但是上图并没有显示全貌——它只显示了一个位置的波的相互作用。当波在空间中传播时，它们之间的相位关系从一个位置到另一个位置会发生变化，如下图所示。在某些地方，波会构成干涉，并且组合波的辐照度大于单个波辐照度值的总和。在其他地方，它们会产生破坏性的干扰，导致综合辐照度小于单个波辐照度值的总和。这并不违反能量守恒定律，因为通过相长干涉获得的能量和通过相消干涉损失的能量总是相互抵消的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001134154.png" class="" title="image-20211001134154">

<p>从两个频率相同的点源发出的单色波。波在空间的不同区域产生建设性和破坏性的干涉。</p>
<p><strong>当物体中的电荷振荡时就发出光波。引起振荡的部分能量——热、电能、化学能——被转换成光能，光能从物体辐射出去。在渲染中，这些对象被视为光源。我们在第5.2节中首先讨论了光源，在第10章中将从更物理的角度对它们进行描述。</strong></p>
<p><strong>光波被发射后，它们在太空中旅行，直到遇到一些可以相互作用的物质。背后的核心现象大多数光与物质的相互作用是简单的，与上面讨论的发射情况非常相似。振荡的电场推动和拉动物质中的电荷，使它们依次振荡。振荡电荷发射出新的光波，将入射光波的一些能量转向新的方向。这种反应称为散射，是各种光学现象的基础。</strong></p>
<p><strong>散射的光波与原始波的频率相同。通常情况下，当原始波包含多个频率的光时，每一个频率都分别与物质相互作用。以一个频率入射的光能不会对以不同频率发射的光能产生贡献，除了特定的、相对罕见的情况，如荧光和磷光，我们将在本书中不进行描述。</strong></p>
<p><strong>一个孤立的分子向各个方向散射光，强度有一定的方向变化。更多的光被散射到靠近原始传播轴的方向，无论是向前还是向后。分子作为散射体的有效性——其附近的光波被散射的几率——随波长的不同而有很大的变化。短波长的光比长波长的光更能有效地散射。</strong></p>
<p><strong>在渲染中，我们关心的是许多分子的集合。与这种聚集体的光相互作用不一定类似于与孤立分子的相互作用。从附近分子散射的波往往相互相干，因此表现出干涉，因为它们来自同一入射波。本节的其余部分将专门讨论光从多个分子散射的几个重要的特殊情况。</strong></p>
<h3 id="Particles-粒子"><a href="#Particles-粒子" class="headerlink" title="Particles 粒子"></a>Particles 粒子</h3><p><strong>在理想气体中，分子之间不相互影响，因此它们的相对位置是完全随机和不相关的。虽然这是一个抽象的概念，但对于常压下的空气来说，这是一个相当好的模型。在这种情况下，从不同分子散射的波之间的相位差是随机的，并且不断变化。因此，散射波是非相干的，它们的能量线性增加，如上上图的右侧所示。换句话说，从n个分子散射的总光能是从单个分子散射的光能的n倍。</strong></p>
<p><strong>相反，如果分子紧密地聚集在比光波波长小得多的簇中，每个簇中的散射光波就会处于相位并相互干涉。这导致散射波能量以二次形式叠加，如上上图的左侧所示。因此，由n个分子组成的小团簇散射的光的强度为n² 乘以单个分子散射的光，比理想气体中相同数量的分子散射的光多n倍。这种关系意味着，对于每立方米固定的分子密度，分子聚集成簇将显著增加散射光的强度。使团簇更大，同时仍然保持整个分子密度常数，将进一步增加散射光的强度，直到星团直径变得接近光的波长。除此之外，星团大小的额外增加不会进一步增加散射光强度。</strong></p>
<p><strong>这个过程解释了为什么云和雾会如此强烈地散射光。它们都是由冷凝产生的，这是空气中的水分子聚集成越来越大的簇的过程。这大大增加了光散射，即使水分子的总体密度没有变化。云绘制将在14.4.2节中讨论。</strong></p>
<p><strong>当讨论光散射时，粒子这一术语既指孤立的分子，也指多分子团簇。由于直径小于一个波长的多分子粒子的散射是孤立分子散射的放大(通过相构干涉)版本，它表现出相同的方向变化和波长依赖性。这种散射在大气粒子的情况下称为瑞利散射，在粒子嵌入固体的情况下称为廷德尔散射。</strong></p>
<p><strong>当粒子的大小超过一个波长时，散射波在整个粒子上不再处于相位，这一事实改变了散射特性。散射越来越倾向于正向，波长依赖性逐渐减小，直到所有可见波长的光散射相等。这种散射称为米氏散射。瑞利散射和米氏散射将在第14.1节中详细讨论。</strong></p>
<h3 id="Media-媒介"><a href="#Media-媒介" class="headerlink" title="Media 媒介"></a>Media 媒介</h3><p><strong>另一个重要的例子是光通过均匀介质传播，均匀介质是一个充满均匀间隔的相同分子的体积。分子间距不必像晶体那样完全规则。如果液体和非结晶固体的成分是纯的(所有的分子都是相同的)，并且没有空隙或气泡，那么它们在光学上是均匀的。</strong></p>
<p><strong>在均匀介质中，散射波排列成一排，使它们在除原始传播方向外的所有方向上发生破坏性干扰。当原始波与所有从单个分子散射的波结合后，最终的结果与原始波相同，除了它的相速度和(在某些情况下)振幅。最后的波不表现出任何散射——它已被破坏性干涉有效地抑制了。</strong></p>
<p><strong>原波和新波的相速度之比定义了介质的一种光学性质，称为折射率(IOR)或折射率，用字母n表示。有些介质是可吸收的。它们将部分光能转换为热能，使波的振幅随距离的增加呈指数级减小。衰减率由衰减指数定义，以希腊字母κ (kappa)表示。n和κ通常随波长而变化。这两个数字完全定义了介质对给定波长的光的影响，它们经常被组合成一个复数n + iκ，称为复折射率。</strong></p>
<p><strong>折射率去掉了光相互作用的分子级细节，使得将介质视为一个连续的体积，这就简单得多了。</strong></p>
<p><strong>虽然光的相速度不会直接影响外观，但速度的变化会，我们稍后会解释。另一方面，光的吸收对视觉效果有直接的影响，因为它降低了光的强度，并且(如果根据波长变化)也会改变光的颜色。下图显示了一些光吸收的例子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001134620.png" class="" title="image-20211001134620">

<p>四个小容器的液体具有不同的吸收特性。从左到右:清水、石榴汁水、茶和咖啡。</p>
<p><strong>非均匀介质通常可以模拟为含有散射粒子的均匀介质。在均匀介质中抑制散射的破坏性干涉是由分子的均匀排列引起的，因此是由它们产生的散射波引起的。分子分布的任何局部变化都会打破这种破坏性干涉的模式，允许散射的光波传播。这种局部变化可以是不同分子类型的簇、气隙、气泡或密度变化。无论如何，它会像前面讨论的粒子一样散射光，散射特性同样依赖于星团的大小。甚至气体也可以用这种方法建模。因此，“散射粒子”是由分子不断运动引起的瞬时密度波动。该模型可以为气体建立一个有意义的n值，这对理解气体的光学性质是有用的。下图显示了一些光散射的例子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001134717.png" class="" title="image-20211001134717">

<p>从左到右:水，加了几滴牛奶的水，加了10%牛奶的水，全脂牛奶，和乳白色玻璃。大多数牛奶的散射粒子都比可见光波长大，所以它的散射基本上是无色的，在中间的图像中有一种微弱的蓝色。乳白色玻璃中的散射粒子都小于可见光波长，因此蓝光的散射比红光更强烈。由于明暗背景的分裂，透射光在左侧更明显，散射光在右侧更明显。</p>
<p><strong>散射和吸收都与尺度有关。在小场景中不产生任何明显散射的介质在大尺度上可能产生相当明显的散射。例如，当观察房间里的一杯水时，光在空气中的散射和在水中的吸收是不可见的。然而，在扩展的环境中，这两种效果都是显著的，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001134800.png" class="" title="image-20211001134800">

<p>左边的图像显示，在数米的距离内，水吸收光线，尤其是红光，非常强烈。右边的图像显示，即使在没有严重污染或雾的情况下，明显的光线也散射在数英里的空气中。</p>
<p><strong>在一般情况下，介质的出现是由散射和吸收的某种结合引起的，如下图所示。散射的程度决定了云量，高散射造成不透明的外观。除了一些罕见的例外情况，如上上图中的乳白色玻璃，固体和液体介质中的颗粒往往大于光波长，并倾向于均匀地散射所有可见波长的光。因此，任何颜色的色调通常是由波长依赖性的吸收引起的。介质的亮度是这两种现象的结果。特别是白色是高散射和低吸收结合的结果。这将在14.1节中进行更详细的讨论。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001134858.png" class="" title="image-20211001134858">

<p>表现出不同吸收和散射组合的液体容器。</p>
<h3 id="Surfaces-表面"><a href="#Surfaces-表面" class="headerlink" title="Surfaces 表面"></a>Surfaces 表面</h3><p><strong>从光学角度看，物体表面是一个二维界面，将不同折射率的体分开。在典型的渲染情况下，外层包含空气，折射率约为1.003，通常为简单起见假设为1。内部体积的折射率取决于制成物体的物质。</strong></p>
<p><strong>当光波照射到一个表面时，该表面的两个方面对结果有重要影响:两侧的物质和表面的几何形状。我们将从物质方面开始，假设最简单的表面几何，一个完美的平面。我们用“外面”(入射波或入射波产生的那一边)的折射率表示n1 而“内部”(波穿过表面后将被透射的地方)的折射率为n₂．</strong></p>
<p><strong>在前一节中我们已经看到，当光波遇到材料组成或密度的不连续时，即散射。，在折射率。一个不同折射率的平面表面是一种特殊类型的不连续，以特定的方式散射光。边界条件要求平行于表面的电场分量是连续的。换句话说，电场向量在平面上的投影必须与平面的任意一侧相匹配。这有几个含义:</strong></p>
<pre><code>**1.在水面上，任何散射波必须与入射波同相，或180◦异相。因此，在表面上，散射波的波峰必须与入射波的波峰或波谷对齐。这就限制了散射波只能向两种可能的方向移动，一种是继续向水面前进，另一种是后退。第一种是透射波，第二种是反射波。**

**2.散射波必须与入射波具有相同的频率。我们假设这里是一个单色波，但是我们讨论的原理可以应用于任何一般波，首先要把它分解成单色分量。**

**3.当光波从一种介质移动到另一种介质时，相速度——即光波穿过介质的速度——与相对折射率成正比变化(n₁/ n₂)．由于频率是固定的，波长也与(n₁/ n₂)成比例变化．**
</code></pre>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001135538.png" class="" title="image-20211001135538">

<p>入射平面的光波，折射率n₁ 和n₂．图的左侧显示了一个侧面视图，入射波从左上方进入。红色波段的强度表示波的相位。表面以下的波的间距与比率(n₁/ n₂)成比例变化，在本例中为0.5。相位沿表面排列，因此间距的变化弯曲(折射)透射波的方向。三角形的构造说明了斯涅尔定律的推导。为清晰起见，图的右上角分别显示了反射波。它与入射波有相同的波间距，因此它的方向与表面法线有相同的角度。图的右下角显示了波的方向向量。</p>
<p><strong>最终结果如上图所示。反射波和入射波方向具有相同的角度θi 表面法线。透射波的方向弯曲(折射)成θ角t，它与θ的关系如下i：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001135638.png" class="" title="image-20211001135638">

<p><strong>这个折射方程被称为斯涅尔定律。它用于全局折射效应，这将在14.5.2节中进一步讨论。</strong></p>
<p><strong>虽然折射通常发生在透明的材料，如玻璃和晶体，它也发生在不透明物体的表面。当不透明物体发生折射时，光在物体内部发生散射和吸收。光与物体的介质相互作用，就像上上图中不同杯子的液体一样。以金属为例，其内部包含许多自由电子(没有与分子绑定的电子)，它们“吸收”折射的光能，并将其重新定向到反射波中。这就是金属具有高吸收率和高反射率的原因。</strong></p>
<p><strong>我们已经讨论过的表面折射现象——反射和折射——需要折射率的突变，发生在小于一个波长的距离内。更渐进的折射率变化不会使光分裂，而是使光的路径弯曲，类似于折射过程中发生的不连续弯曲。这种效应通常可以在空气密度因温度而变化时看到，如海市蜃楼和热变形。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001135735.png" class="" title="image-20211001135735">

<p>由于折射率的逐渐变化而引起的光路弯曲的一个例子，在这种情况下是由温度变化引起的。(“EE lighting heat haze，”Paul Lucas，在CC BY 2.0许可下使用。)</p>
<p><strong>即使一个物体有明确的边界，如果它浸没在具有相同折射率的物质中，它也不会有可见的表面。在没有折射率变化的情况下，就不会发生反射和折射。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001135824.png" class="" title="image-20211001135824">

<p>这些装饰珠子的折射率与水一样。在水面上，由于它们的折射率与空气的不同，它们有一个可见的表面。在水下，珠子表面两侧的折射率是一样的，所以表面是看不见的。由于颜色的吸收，珠子本身是可见的。</p>
<p><strong>到目前为止，我们一直专注于表面两侧物质的影响。现在我们将讨论另一个影响表面外观的重要因素:几何。严格地说，一个完全平坦的平面是不可能的。每个表面都有某种不规则性，即使只有单个原子构成了表面。然而，比波长小得多的表面不规则性对光线没有影响，而比波长大得多的表面不规则性有效地使表面倾斜，而不影响其局部平坦度。只有在1-100波长范围内的不规则现象，通过一种称为衍射的现象，使表面的行为与平面不同，这将在第9.11节中进一步讨论。</strong></p>
<p><strong>在渲染中，我们通常使用几何光学，这忽略了波的影响，如干涉和衍射。这相当于假设所有表面的不规则性要么小于光波长，要么大于光波长。在几何光学中，光被模拟成射线而不是波。在光线与曲面相交的那一点上，该曲面被局部地视为一个平面。上上上图右下角的图可以看作是反射和折射的几何光学图，与图中其他部分的波动图形成对比。我们将从这一点保持几何光学的领域，直到9.11节，这是专门的主题的阴影模型基于波动光学。</strong></p>
<p><strong>正如我们前面提到的，比波长大得多的表面不规则性会改变表面的局部方向。当这些不规则现象太小而无法单独呈现时——换句话说，比像素还小——我们称之为微几何。反射和折射的方向取决于表面法线。微几何的作用是改变表面上不同点的法线，从而改变光的反射和折射方向。</strong></p>
<p><strong>尽管表面上的每个特定点只在一个方向反射光线，但每个像素覆盖了许多在不同方向反射光线的表面点。外观是由所有不同反射方向的聚合结果驱动的。下图展示了两个表面的例子，它们在宏观尺度上具有相似的形状，但微观几何形状却有显著不同。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001140015.png" class="" title="image-20211001140015">

<p>左边是两个表面的照片，右边是它们的微观结构图。顶部表面有轻微粗糙的微观几何形状。射入的光线击中表面的点的角度有些不同，并在一个狭窄的圆锥方向反射。可见的效果是反射物有轻微的模糊。底部表面有粗糙的微观几何形状。被入射光线击中的表面点的角度有显著不同的方向和反射光在一个宽的锥体中扩散，造成更模糊的反射。</p>
<p><strong>对于渲染，而不是显式地建模微几何，我们处理它统计和观察表面有一个随机分布的微观结构法线。因此，我们将表面建模为连续方向上的反射(和折射)光。这种扩展的宽度，以及反射和折射细节的模糊程度，取决于微几何法向量的统计方差，换句话说，就是表面微尺度粗糙度。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001140108.png" class="" title="image-20211001140108">

<p>从宏观上看，表面可以看作是在多个方向反射和折射光线。</p>
<h3 id="Subsurface-Scattering-次表面散射"><a href="#Subsurface-Scattering-次表面散射" class="headerlink" title="Subsurface Scattering 次表面散射"></a>Subsurface Scattering 次表面散射</h3><p><strong>折射的光继续与物体的内部体积相互作用。如前所述，金属反射大部分入射光，并迅速吸收其余的光。相反，非金属表现出各种各样的散射和吸收行为与之前图中所示的杯状液体相似。低散射和低吸收的材料是透明的，可以将任何折射的光穿透整个物体。在第5.5节中讨论了在没有折射的情况下渲染这些材料的简单方法，而折射将在第14.5.2节中详细讨论。在这一章中，我们将重点关注不透明物体，在这些物体中，透射光经历多次散射和吸收事件，直到其中一些最终从表面重新发射回来。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001140323.png" class="" title="image-20211001140323">

<p>折射的光在穿过材料时被吸收。在这个例子中，大部分的吸收是在较长的波长，主要留下短波长的蓝光。此外，它从物质内部的粒子散射。最终，一些折射的光被散射出表面，如蓝色箭头所示，从不同的方向离开表面。</p>
<p><strong>这种次表面散射光以不同的距离从表面进入点。入射出口距离的分布取决于材料中散射粒子的密度和性质。这些距离和着色比例(像素的大小，或着色样本之间的距离)之间的关系是重要的。如果入口-出口距离与遮阳尺度相比较小，则可以假设它们为有效的零遮阳目的。这使得次表面散射与表面反射结合到一个局部的阴影模型中，在一个点上发出的光只依赖于在同一点上进入的光。然而，由于次表面散射光的外观与表面反射光有显著的不同，将它们划分为单独的遮光项是很方便的。镜面项模拟表面反射，漫反射项模拟局部次表面散射。</strong></p>
<p><strong>如果入口-出口距离比阴影尺度大，那么就需要专门的渲染技术来捕捉光线从一点进入表面和从另一点离开表面的视觉效果。这些全球次表面散射技术将在第14.6节详细介绍。局部和全局次表面散射的区别如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001140338.png" class="" title="image-20211001140338">

<p>在左边，我们正在渲染一个材质的次表面散射。黄色和紫色分别显示了两种不同的抽样大小。大的黄色圆圈表示单个阴影样本覆盖的面积大于次表面散射距离。因此，这些距离可以忽略，使次表面散射被视为局部阴影模型中的漫射项，如右图所示。如果我们靠近这个表面，着色样本区域会变得更小，如紫色的小圆圈所示。与着色样本覆盖的区域相比，次表面散射距离现在很大。从这些样本中生成逼真的图像需要全局技术。</p>
<p><strong>值得注意的是，局部和全局次表面散射技术模拟的是完全相同的物理现象。每种情况下的最佳选择并不取决于不仅在物质特性上，而且在观察尺度上。例如，当渲染一个孩子玩塑料玩具的场景时，很可能需要全局技术来精确渲染孩子的皮肤，而局部漫反射阴影模型对于玩具来说就足够了。这是因为在皮肤中的散射距离比在塑料中大得多。然而，如果相机足够远，皮肤散射距离将小于一个像素和局部着色模型将是准确的孩子和玩具。相反，在一个极端的特写镜头，塑料将显示出明显的非局部次表面散射和全球技术将需要渲染玩具准确。</strong></p>
<h2 id="The-Camera-相机"><a href="#The-Camera-相机" class="headerlink" title="The Camera 相机"></a>The Camera 相机</h2><p><strong>如8.1.1节所述，在渲染时，我们计算从阴影表面点到摄像机位置的亮度。这模拟了成像系统的简化模型，如胶片相机、数码相机或人眼。</strong></p>
<p><strong>这种系统包含由许多离散的小传感器组成的传感器表面。例如眼睛中的视杆细胞和视锥细胞，数码相机中的光电二极管，或者胶片中的染料颗粒。每个传感器检测其表面的辐照度值，并产生颜色信号。辐照度传感器本身无法产生图像，因为它们平均来自所有入射方向的光线。由于这个原因，一个完整的成像系统包括一个有一个小孔径(开口)的防光外壳，以限制光线可以从哪个方向进入并攻击传感器。放置在光圈上的透镜聚焦光，这样每个传感器只接收一小部分入射方向的光。外壳、光圈和透镜具有使传感器具有方向性的综合效果。它们平均的光面积小，方向也小。我们在8.1.1节中已经看到，平均辐照度量化了来自各个方向的光的表面密度，而这些传感器测量的是平均辐照度，平均辐照度量化了单光束的亮度和颜色。</strong></p>
<p><strong>在过去，渲染已经模拟了一个特别简单的成像传感器称为针孔相机，如下图的顶部所示。针孔相机的光圈非常小——在理想情况下，是零尺寸的数学点——而且没有镜头。点孔径限制传感器表面上的每个点收集单一光线，离散传感器收集狭窄的光线圆锥，其基底覆盖传感器表面，其顶点位于孔径。渲染系统模型针孔摄像机在一个稍微不同(但等效)的方式，如下图的中间部分所示。针孔孔径的位置由点c表示，通常称为“相机位置”或“眼睛位置”。这个点也是透视变换的投影中心(章节4.7.2)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001140623.png" class="" title="image-20211001140623">

<p>每一个相机模型都包含一组像素传感器。实线将三个传感器从现场收集到的光线集合绑定在一起。每个图中的插入图像显示了由像素传感器上的单点样本收集的光线。上图是一个针孔摄像机，下图是一个典型的针孔摄像机和摄像机点c的渲染系统模型，下图是一个物理上更正确的带有镜头的摄像机。红色的球在焦点上，其他两个球不在焦点上。</p>
<p><strong>渲染时，每个着色样本对应于一条射线，因此对应于传感器表面上的一个样本点。反走样的过程(章节5.4)可以解释为重构在每个离散传感器表面上采集的信号。然而，由于渲染不受物理传感器的限制，我们可以更一般地看待这个过程，即从离散样本重建连续图像信号。</strong></p>
<p><strong>虽然已经制造出了实际的针孔摄像机，但对于实际使用的大多数摄像机以及人眼来说，它们都是糟糕的模型。使用透镜的成像系统模型如上图的底部所示。加上透镜可以使用更大的光圈，这大大增加了成像系统收集的光量。然而，它也会导致相机有一个有限的景深(章节12.4)，模糊的对象太近或太远。</strong></p>
<p><strong>除了限制景深外，镜头还有一个额外的效果。每个传感器的位置都接收到一个光锥，即使是聚焦完美的点。理想化的模型，其中每个着色样本代表一个单一的观察射线有时会引入数学奇点，数值不稳定性，或视觉混叠。当我们渲染图像时，记住物理模型可以帮助我们识别和解决这些问题。</strong></p>
<h2 id="The-BRDF-双向反射分布函数"><a href="#The-BRDF-双向反射分布函数" class="headerlink" title="The BRDF 双向反射分布函数"></a>The BRDF 双向反射分布函数</h2><p><strong>最终，基于物理的渲染归结为计算沿着一组视图射线进入相机的亮度。使用8.1.1节介绍的入射辐亮度符号，对于给定的视场射线，我们需要计算的量是Li(c，−v)，其中c为摄像机位置，−v为沿视图射线的方向。我们使用−v是由于两种符号约定。首先是Li()中的方向向量总是指向给定的点，在本例中是摄像机位置。其次，视图向量v总是指向相机。</strong></p>
<p><strong>在渲染中，场景通常被建模为对象的集合，对象之间有媒介(“媒介”这个词实际上来自于拉丁词“在中间”或“在中间”)。通常所讨论的介质是适量的相对干净的空气，它不会明显地影响光线的亮度，因此在渲染时可以忽略它。有时，射线穿过的介质通过吸收或散射对其辐射有明显的影响。这类媒体被称为参与媒体，因为它们参与了光在场景中的传输。参与的媒体将在第14章详细介绍。在本章中，我们假设没有参与的媒体在场，因此进入相机的亮度等于在相机方向上离开最近物体表面的亮度:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112113.png" class="" title="image-20211002112113">

<p><strong>其中p是视图射线与最近物体表面的交点。</strong></p>
<p><strong>根据上式，我们的新目标是计算Lo(p, v)。该计算是5.1节中讨论的着色模型评估的物理版本。有时辐亮度直接由表面发出。更常见的情况是，离开表面的辐亮度来自别处，并通过第9.1节所述的物理相互作用被表面反射到视场射线中。在本章中，我们先不讨论透明度(第5.5节和第14.5.2节)和全局次表面散射(第14.6节)。换句话说，我们关注的是局部反射现象，它将照射到当前阴影点的光线向外折射。这些现象包括表面反射和局部亚表面散射，只依赖于入射光方向l和出射视图方向v。局部反射通过双向反射分布函数(BRDF)来量化，记为f(l, v)。</strong></p>
<p><strong>在其原始推导中，BRDF被定义为均匀曲面。也就是说，BRDF假定在表面上是相同的。然而，现实世界中的物体(以及渲染场景)很少在其表面具有统一的材质属性。即使是由单一材料制成的物体，例如银制的雕像，也会有划痕、污点、污渍和其他变化，导致其视觉特性从一个表面点到另一个表面点发生变化。从技术上讲，根据空间位置捕获BRDF变化的函数称为空间变化BRDF (SVBRDF)或空间BRDF (SBRDF)。然而，这种情况在实践中非常普遍，因此经常使用短期BRDF，并隐含地假定它依赖于表面位置。</strong></p>
<p><strong>进方向和出方向各有两个自由度。常用的参数化包括两个角度:相对于表面法线n的仰角θ和关于n的方位角(水平旋转)φ。在一般情况下，BRDF是四个标量变量的函数。各向同性BRDFs是一个重要的特例。这样的BRDFs保持不变，当进入和向外的方向是围绕表面法线旋转，保持他们之间的相对角度相同。下图显示了两种情况下使用的变量。各向同性BRDFs是三个标量变量的函数，因为光与相机之间只有一个角度φ旋转是必要的。这意味着，如果一个均匀的各向同性的材料被放置在转盘上并进行旋转，在给定固定的光线和摄像机的情况下，它在所有旋转角度上都是相同的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112303.png" class="" title="image-20211002112303">

<p>双向反射。方位角度φi 和φo 的相对方位角φ，用在各向同性BRDFs中代替φi 和φo，不需要参考切向量。</p>
<p><strong>由于我们忽略了荧光和磷光等现象，我们可以假设入射光的波长是相同的。反射的光的数量可以根据波长而变化，波长可以用两种方法之一来建模。要么将波长视为BRDF的附加输入变量，要么将BRDF视为返回光谱分布值。在离线渲染中有时会使用第一种方法，而在实时渲染中总是使用第二种方法。由于实时渲染器将光谱分布表示为RGB三元组，这仅仅意味着BRDF返回一个RGB值。</strong></p>
<p><strong>计算Lo(p, v)，我们将BRDF纳入到反射方程中:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112408.png" class="" title="image-20211002112408">

<p><strong>l∈Ω下标的积分符号执行意味着集成/ l向量躺在上面的单位半球表面(集中在表面上正常n)。注意,l是被不断在西半球的方向——它不是一个特定的“光源的方向。“这个想法是，任何入射方向都可能(通常会)有一些与之相关的辐射。我们用dl表示l周围的微分实心角(实心角在8.1.1节中讨论)。</strong></p>
<p><strong>综上所述，反射率方程表明出射辐亮度等于入射辐亮度的积分(在Ω中除以l)乘以BRDF乘以n与l之间的点积。</strong></p>
<p><strong>为简洁起见，在本章的其余部分，我们将从L中省略曲面点pi(), Lo()，反射率方程为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112456.png" class="" title="image-20211002112456">

<p><strong>在计算反射率方程时，通常采用球坐标φ和θ对半球进行参数化。对于这个参数化，微分立体角dl等于sin θi dθi dφi．利用这个参数化，可以推导出上式的二重积分形式，该形式使用球坐标(回想一下(n·l) = cos θi）：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112543.png" class="" title="image-20211002112543">

<p><strong>角度θi,φi,θo,φo 如上图所示。</strong></p>
<p><strong>在某些情况下，使用略微不同的参数化是方便的，使用仰角的余弦µi = cosθi 和µo = cosθo 作为变量而不是角度θi 和θo 他们自己。对于这个参数化，微分立体角dl等于dµi dφi．利用(µ，φ)参数化得到如下积分形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112712.png" class="" title="image-20211002112712">

<p><strong>BRDF仅在光线和视图方向都高于表面的情况下被定义。光方向在表面以下的情况可以通过将BRDF乘以0或不首先计算该方向的BRDF来避免。但是曲面下的视图方向呢，也就是说n·v的点积是负的?从理论上讲，这种情况永远不应该发生。表面将背对着摄像机，因此是看不见的。然而，插值顶点法线和法线映射(这两种方法在实时应用中都很常见)在实践中可能会产生这种情况。通过将n·v夹持为0或使用其绝对值，可以避免对表面下的视图方向的BRDF进行评估，但这两种方法都可能产生伪影。Frostbite引擎使用n·v的绝对值加上一个小数字(0.00001)来避免被零除。另一种可能的方法是“软夹”，当n和v之间的夹角超过90°时，它逐渐趋于零．</strong></p>
<p><strong>物理定律对任何BRDF都有两个限制。第一个约束条件是Helmholtz reciprocity，即输入输出角可以切换，函数值不变:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112920.png" class="" title="image-20211002112920">

<p><strong>在实践中，渲染中使用的BRDFs经常违反Helmholtz reciprocity，而没有明显的伪影，除非离线渲染算法特别需要互易性，例如双向路径跟踪。然而，当确定BRDF在物理上是否合理时，它是一个有用的工具。</strong></p>
<p><strong>第二个约束是能量守恒——输出的能量不能大于输入的能量(不包括发光的表面，这是一个特例)。离线渲染算法，如路径跟踪节约能源，确保收敛。对于实时渲染，精确的能量守恒是不必要的，但近似的能量守恒是重要的。用BRDF渲染的表面严重违反了能量节约，会太亮，因此可能看起来不现实。</strong></p>
<p><strong>方向半球反射率R(l)是一个与BRDF有关的函数。它可以用来测量BRDF的节能程度。尽管它的名字有点吓人，方向半球面反射是一个简单的概念。它测量从一个给定方向入射的光被反射到半球表面法线周围任何方向的量。本质上，它测量的是给定入射方向的能量损失。该函数的输入为输入方向向量l，其定义如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113013.png" class="" title="image-20211002113013">

<p><strong>注意这里的v，就像反射方程中的l一样，覆盖了整个半球，并不代表一个单一的观察方向。</strong></p>
<p><strong>一个类似但在某种意义上相反的函数，半球定向反射率R(v)可以类似地定义为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113021.png" class="" title="image-20211002113021">

<p><strong>如果BRDF是倒数的，则半球方向反射率和半球方向反射率相等，可以使用相同的函数来计算两者。方向性反照率可以作为这两种反照率的概括性术语，在它们可以互换使用的情况下。</strong></p>
<p><strong>由于能量守恒，方向半球反射率R(l)的值必须始终在[0,1]范围内。反射值为0表示所有入射光被吸收或丢失的情况。如果所有的光都被反射，反射率为1。在大多数情况下，它会在这两个值之间。和BRDF一样，R(l)的值随波长而变化，因此为了渲染的目的，它被表示为RGB向量。由于每个组件(红色、绿色和蓝色)都被限制在[0,1]范围内，所以R(l)的值可以被认为是一种简单的颜色。注意，这个限制不适用于BRDF的值。作为一个分布函数，如果BRDF描述的分布是高度不均匀的，那么它可以在某些方向上有任意高的值(例如高光的中心)。BRDF节能的要求是R(l)对于所有可能的l值不大于1。</strong></p>
<p><strong>可能最简单的BRDF是Lambertian着色模型，它对应于在第5.2节中简要讨论的Lambertian着色模型。朗伯BRDF有一个常数值。著名的(n·l)因子区分朗伯氏着色不是BRDF的一部分，而是方程的一部分。尽管它很简单，兰伯特BRDF经常被用于实时渲染来表示局部的次表面散射(尽管它正在被更精确的模型所取代，如9.9节所述)。朗伯曲面的方向半球面反射率也是一个常数。对上上方程求常值f(l, v)的值，得到方向-半球反射率作为BRDF函数的如下值:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113223.png" class="" title="image-20211002113223">

<p><strong>LambertianBRDF的常数反射值通常被称为漫反射颜色cdiff 或者是ρ反照率。在本章中，为了强调与次表面散射的联系，我们将把这个量称为次表面反照率ρss．地下反照率将在第9.9.1节中详细讨论。由上式得到的BRDF结果如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113231.png" class="" title="image-20211002113231">

<p><strong>1/π因子是由于在半球上对余弦因子积分得到π值而产生的。这些因素在BRDFs中很常见。</strong></p>
<p><strong>理解BRDF的一种方法是在输入方向不变的情况下将其形象化。参见下图。对于入射光的给定方向，BRDF的值显示所有出站方向。在交点周围的球面部分是漫反射部分，因为发出的辐亮度在任何方向上都有相同的反射机会。椭球状的部分是镜面裂片。这样的波瓣自然处于入射光的反射方向，波瓣的厚度与反射的模糊性相对应。根据相互作用的原理，这些相同的可视化也可以被认为是每个不同的入射光方向对单个出射光方向的贡献。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113441.png" class="" title="image-20211002113441">

<p>双向反射的例子。每个图形右侧的实绿线为入射光方向，绿白虚线为理想的反射方向。在上面一行，左图显示了一个朗伯式BRDF(一个简单的半球)。中间的图显示了添加到lambert术语中的Blinn-Phong高亮显示。右图显示的是库克-托伦斯BRDF。注意镜面的高光在反射方向上不是最强的。在最下面一行，左图是沃德的各向异性模型的特写。在这种情况下，效果是倾斜镜面瓣。中间的图是Hapke/Lommel-Seeliger“月球表面”BRDF，具有强烈的反反射。右图显示的是Lommel-Seeliger散射，在这个过程中，布满灰尘的表面将光线散射到掠射角度。(图片由Szymon Rusinkiewicz提供，来自他的“bv”BRDF浏览器)</p>
<h2 id="Illumination-光照"><a href="#Illumination-光照" class="headerlink" title="Illumination 光照"></a>Illumination 光照</h2><p><strong>Li(l)(入射辐亮度)项在反射方程中表示从场景其他部分照射到着色表面点的光线。全局光照算法计算Li(l)通过模拟光线如何在场景中传播和反射。这些算法使用绘制方程，其中反射方程是一个特例。整体照明将在第11章中讨论。在这一章和下一章中，我们重点关注局部照明，它使用反射方程来计算每个表面点的局部阴影。在局部光照算法Li(l)已给出，不需要计算。</strong></p>
<p><strong>在现实场景中，Li(l)包括来自各个方向的非零辐亮度，不论是直接由光源发出还是由其他表面反射而来。与第5.2节中讨论的定向光源和点灯不同，真实世界的光源是覆盖非零立体角的区域光源。在本章中，我们使用L的限制形式Li(l)只包含方向灯和点灯，将更一般的照明环境留给第10章。这个限制允许更集中的讨论。</strong></p>
<p><strong>虽然准时光和定向光是非物理抽象的，但它们可以作为物理光源的近似来推导。这样的推导是重要的，因为它使我们能够在一个基于物理的渲染框架中合并这些光，并且我们能够自信地理解所涉及的错误。</strong></p>
<p><strong>我们取一个小的，远处的光，定义lc 作为指向它中心的向量。我们还定义了光的颜色clight 如白色的朗伯氏表面对着光的反射亮度(n = lc)。这是对创作的直观定义，因为光的颜色直接对应着它的视觉效果。</strong></p>
<p><strong>根据这些定义，可以导出一个方向光作为缩小面积光的大小为零而保持c值的极限情况light 。在这种情况下，反射率方程中的积分简化为单个BRDF计算，计算成本大大降低:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113738.png" class="" title="image-20211002113738">

<p><strong>点积(n·l)通常被固定为零，作为跳过表面下光源贡献的一种方便的方法:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113746.png" class="" title="image-20211002113746">

<p><strong>注意1.2节中介绍的x+符号，它表示负数被固定为零。</strong></p>
<p><strong>准时的灯光也可以用类似的方法来处理。唯一的区别是区域光不需要是远距离的，clight 如第5.11公式(111页)所示。在多个光源的情况下，将上上式多次计算，并将结果求和:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113857.png" class="" title="image-20211002113857">

<p><strong>lci和clighti 分别为第i个光的方向和颜色。注意公式5.6(第109页)的相似之处。</strong></p>
<p><strong>上式中的π因子抵消了BRDFs中经常出现的1/π因子。这个取消将除法操作移出着色器，使着色方程更容易读取。然而，当从学术论文中改编BRDFs用于实时着色方程时，必须小心。通常情况下，BRDF在使用前需要乘以π。</strong></p>
<h2 id="Fresnel-Reflectance-菲尼尔反射"><a href="#Fresnel-Reflectance-菲尼尔反射" class="headerlink" title="Fresnel Reflectance 菲尼尔反射"></a>Fresnel Reflectance 菲尼尔反射</h2><p><strong>在第9.1节中，我们从高层讨论了光与物质的相互作用。在第9.3节中，我们介绍了用数学方法表达这些相互作用的基本机制:BRDF和反射方程。现在我们准备开始深入到特定的现象，量化它们，以便它们可以用于着色模型。我们将从平面反射开始，第一次讨论在章节9.1.3。</strong></p>
<p><strong>物体的表面是周围介质(通常是空气)和物体本身之间的界面。光与两种物质之间的平面界面的相互作用遵循奥古斯汀-让·菲涅耳(1788 - 1827)提出的菲涅耳方程。菲涅耳方程要求遵循几何光学假设的平面界面。换句话说，假设表面在1个波长和100个波长之间没有任何不规则。小于此范围的不规则度对光线没有影响，较大的不规则度会使表面倾斜，但不会影响其局部平坦度。</strong></p>
<p><strong>入射到平面上的光分为反射部分和折射部分。反射光的方向(用矢量ri表示)形成相同的角(θi)，以表面法线n为入射方向l。反射矢量ri 可以由n和l计算:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003113634.png" class="" title="image-20211003113634">

<p><strong>参见下图。反射光的数量(作为入射光的一部分)由菲涅耳反射率F描述，它取决于入射角θi．</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003113720.png" class="" title="image-20211003113720">

<p>平面上的反射光向量l围绕法向量n反射，以生成ri．首先，将l投影到n上，得到法线(n·l)n的缩放版本。然后求l的负数，加上投影向量的两倍得到反射向量。</p>
<p><strong>如第9.1.3节所述，反射和折射受平面两侧两种物质折射率的影响。我们将继续使用之前讨论过的符号。n1 在入射光和反射光传播的界面上方的物质的折射率是否为n2 为折射光传播的界面下方物质的折射率。</strong></p>
<p><strong>菲涅耳方程描述了F对θi,n1和n2的依赖关系．我们将描述它们的重要特征，而不是给出方程本身，因为它们有些复杂。</strong></p>
<h3 id="External-Reflection-全反射"><a href="#External-Reflection-全反射" class="headerlink" title="External Reflection 全反射"></a>External Reflection 全反射</h3><p><strong>全反射是n1 &lt; n2．换句话说，光线是从表面折射率较低的一侧发出的。通常，这一面含有空气，折射率约为1.003。为简单起见，我们假设n1 = 1。相反的转变，从物体到空气，称为内部反射，将在后面的章节9.5.3中讨论。</strong><br><strong>对于给定的物质，菲涅耳方程可以定义一个反射率函数F(θi)，只取决于入射光的角度。理论上F(θi)的值在可见光谱上不断变化。出于渲染目的，它的值被视为RGB向量。函数F(θi)有下列特点:</strong></p>
<pre><code>**•当θi=0 ◦使光线垂直于表面(l = n)， F(θi)具有一种价值，即该物质的一种属性。这个值,F0，可以认为是该物质特有的镜面颜色。θi = 0◦的情况 叫做正态入射。**

**•为θi 当光照射到表面的角度增大时，F(θi)将趋于增加，在θi= 90◦ 处所有频率(白色)均为1．**
</code></pre>
<p><strong>下图显示了F(θi)的功能，以几种不同的方式表现出来。曲线是高度非线性的，在θi = 75◦之前几乎没有变化然后快速到1。从F0 到1开始的增加是单调的，尽管一些物质(如下图中的铝)在变成白色之前有轻微的下降。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003114533.png" class="" title="image-20211003114533">

<p>菲涅耳反射率F为三种物质的全反射:玻璃，铜和铝(从左到右)。最上面一行是F作为波长和入射角的函数的三维图。第二行显示了每个入射角的光谱值F转换为RGB，并绘制为每个颜色通道的单独曲线。玻璃的曲线是一致的，因为它的菲涅耳反射率是无色的。在第三行，R、G和B曲线与入射角的正弦曲线相对应，以解释下图中所示的透视缩短。下面一行的条带使用相同的x轴，将RGB值显示为颜色。</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003114617.png" class="" title="image-20211003114617">

<p>远离眼睛倾斜的表面被缩短。这种透视缩短与根据v和n之间夹角的正弦(对于镜面反射，这与入射角相同)来突出表面点是一致的。因此，在上图和下图中，菲涅耳反射率与入射角的正弦作了对比。</p>
<p><strong>在镜面反射的情况下，出射角或视角与入射角相同。这意味着表面是在一个瞥视角度进入具有θi 接近90◦值的光也与眼睛有一个斜视角度。由于这个原因，反射的增加主要是在物体的边缘看到的。此外，从相机的角度来看，表面反射率增加最强的部分被缩短了，因此它们只占用相对较少的像素。下图和上上图下半部分的菲涅尔反射率图和彩色条与sin(θi)作对比，以显示菲涅尔曲线的不同部分与它们的视觉突出度成比例，而不是直接指向θi．上图说明了为什么sin(θi)是为此目的而适当选择的轴。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003114846.png" class="" title="image-20211003114846">

<p>Schlick的近似菲涅尔反射率与六种物质全反射的正确值进行比较。排名前三的物质与上上图相同:玻璃、铜和铝(从左到右)。底部的三种物质是铬、铁和锌。每一种物质都有一个RGB曲线图，实线显示完整的菲涅耳方程，虚线显示Schlick的近似。每个曲线图下面的上色条显示的是完整菲涅耳方程的结果，下色条显示的是Schlick近似的结果。</p>
<p><strong>从这里开始，我们通常用F(n, l)来代替F(θi)，以强调所涉及的向量。回想一下,θi 是向量n和l之间的夹角。当菲涅耳函数作为BRDF的一部分加入时，通常会用不同的向量代替表面法线n。详情请参见9.8节。</strong></p>
<p><strong>在渲染出版物中，反射角度的增加通常被称为菲涅耳效应(在其他领域，这个术语与无线电波的传输有不同的含义)。你可以通过一个简短的实验自己看到菲涅耳效应。拿一部智能手机，坐在明亮的地方，比如电脑显示器前。在不打开手机的情况下，首先将手机拿近胸部，向下看，并稍微倾斜，使其屏幕能够反射屏幕。在手机屏幕上应该有一个相对较弱的显示器反射。这是因为玻璃的正入射反射率很低。现在把智能手机举起来，让它大致位于你的眼睛和显示器之间，再次调整屏幕的角度反映了班长。现在显示器在手机屏幕上的反射应该几乎和显示器本身一样亮。</strong></p>
<p><strong>除了它们的复杂性，菲涅耳方程还有其他的特性，使得直接使用它们来绘制变得困难。它们需要在可见光谱上取样的折射率值，这些值可能是复数。上上图中的曲线表明了一种基于特征高光颜色F0的更简单的方法．Schlick给出了菲涅耳反射率的近似:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003115041.png" class="" title="image-20211003115041">

<p><strong>这个函数是白色和F0之间的RGB插值．尽管如此简单，这种近似还是相当准确的。</strong></p>
<p><strong>上图包含了一些从Schlick曲线发散出来的物质，在变成白色之前显示出明显的“下降”。事实上，最下面一行的物质之所以被选中，是因为它们在很大程度上偏离了Schlick近似。即使对于这些物质，产生的误差也是相当细微的，如图中每个图底部的色条所示。在极少数情况下，精确捕捉这些材质的行为非常重要，可以使用Gulbrandsen给出的另一种近似方法。这种近似可以达到与金属的全菲涅耳方程很接近的结果，尽管它更接近在计算上比Schlick的昂贵。一个更简单的选择是修改Schlick的近似，以允许将最后一项提升为5以外的幂(如下下式)。这将改变“锐度”的过渡到白色在90◦，这可能导致更接近的匹配。 Lagarde总结了菲涅耳方程及其几个近似。</strong></p>
<p><strong>当使用Schlick近似时，F0 是唯一控制菲涅耳反射率的参数。这很方便，因为F0 在[0,1]中有一个定义良好的有效值范围，很容易用标准的选色界面进行设置，并且可以使用为颜色设计的纹理格式进行纹理化。另外，F0 的参考值可获得许多真实世界的材质。折射率也可以用来计算F0．假设n1 = 1是空气折射率的近似值，用n代替n2 表示物体的折射率。这种简化得到以下方程:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003115243.png" class="" title="image-20211003115243">

<p><strong>如果使用(复)折射率的大小，这个方程甚至适用于复数折射率(如金属折射率)。在折射率在可见光谱上显著变化的情况下，计算F0 的准确RGB值需要先计算F0 ，然后使用8.1.3节所述的方法将得到的光谱矢量转换为RGB值。</strong></p>
<p><strong>在一些应用中使用了更一般的Schlick近似形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003115336.png" class="" title="image-20211003115336">

<p><strong>这提供了对菲涅尔曲线在90◦转场时的颜色的控制，以及转型的“锐度”。使用这种更普遍的形式通常是出于增加艺术控制的愿望，但在某些情况下它也有助于匹配物理现实。如上所述，修改功率可以使某些材料更适合。同时,设置F90 可以帮助匹配菲涅耳方程没有很好地描述的材料，例如表面覆盖着颗粒大小为单个光波长的细粉尘。</strong></p>
<h3 id="Typical-Fresnel-Reflectance-Values-典型菲涅耳反射率值"><a href="#Typical-Fresnel-Reflectance-Values-典型菲涅耳反射率值" class="headerlink" title="Typical Fresnel Reflectance Values 典型菲涅耳反射率值"></a>Typical Fresnel Reflectance Values 典型菲涅耳反射率值</h3><p><strong>物质根据其光学性质可分为三大类。有电介质，是绝缘体;金属是导体;还有半导体，它的特性介于电介质和金属之间。</strong></p>
<h4 id="Fresnel-Reflectance-Values-for-Dielectrics-介质的菲涅耳反射值"><a href="#Fresnel-Reflectance-Values-for-Dielectrics-介质的菲涅耳反射值" class="headerlink" title="Fresnel Reflectance Values for Dielectrics 介质的菲涅耳反射值"></a>Fresnel Reflectance Values for Dielectrics 介质的菲涅耳反射值</h4><p><strong>日常生活中遇到的大多数材料都是电介质——玻璃、皮肤、木材、头发、皮革、塑料、石头和混凝土等等。水也是一种电介质。最后一个可能是令人惊讶的是，因为在日常生活中，水是导电的，但这种导电是由于各种杂质。电介质的F0值相当低通常为0.06或更低。这种正入射时的低反射率使得菲涅耳效应在电介质中尤其明显。电介质的光学特性在可见光谱中很少有很大的变化，导致无色的反射值。F0 几种常用电介质的值见下表。这些值是标量而不是RGB，因为RGB通道对于这些材料没有显著的差异。为方便起见，下表包括线性值以及用sRGB传递函数编码的8位值(纹理绘制应用程序通常使用的形式)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003115747.png" class="" title="image-20211003115747">

<p>F0 的值适用于各种介质的全反射。每个值都以线性数字、纹理值(非线性编码的8位无符号整数)和颜色样本的形式给出。如果给定了一个值的范围，那么色块就在范围的中间。回想一下，这些是高光色。例如，宝石通常有鲜艳的颜色，但这些颜色是物质内部吸收的结果，与菲涅尔反射率无关。</p>
<p><strong>F0 其他电介质的值可以通过查看表中的类似物质来推断。对于未知介质，0.04是一个合理的默认值，与大多数常见材料相差不大。</strong></p>
<p><strong>一旦光被传输到电介质中，它可能会被进一步散射或吸收。这个过程的模型将在第9.9节中进行更详细的讨论。如果材质是透明的，光线将一直持续到“从内部”照射到物体表面，详见章节9.5.3。</strong></p>
<h4 id="Fresnel-Reflectance-Values-for-Metals-金属的菲涅耳反射率值"><a href="#Fresnel-Reflectance-Values-for-Metals-金属的菲涅耳反射率值" class="headerlink" title="Fresnel Reflectance Values for Metals 金属的菲涅耳反射率值"></a>Fresnel Reflectance Values for Metals 金属的菲涅耳反射率值</h4><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003120014.png" class="" title="image-20211003120014">

<p>F0 的值用于各种金属(和一种合金)的全反射，按亮度的增加排序。金色的实际红色值稍微超出了sRGB范围。显示的值是夹紧后的值。</p>
<p><strong>金属的F0值很高几乎总是0.5或以上。有些金属具有在可见光谱中变化的光学特性，从而产生彩色的反射率值。F0 几种金属的值见上表。</strong></p>
<p><strong>与上上表类似，上表有线性值以及用于纹理的8位sRGB编码值。然而，这里我们给出RGB值，因为许多金属都有彩色菲涅耳反射。这些RGB值是使用sRGB(和Rec. 709)原色和白点定义的。黄金有一个不同寻常的F0 价值。它是颜色最强烈的，红色通道值略高于1(它刚好在sRGB/Rec之外。709色域)和特别低的蓝色通道值(上表中唯一显著低于0.5的值)。它也是最亮的金属之一，这可以从它在表中的位置看出，这是根据其亮度的增加来排序的。黄金的明亮和强烈的反射可能有助于它在历史上独特的文化和经济意义。</strong></p>
<p><strong>回想一下，金属会立即吸收任何透射光，因此它们不会表现出任何次表面散射或透明度。金属的所有可见颜色都从F0显现出来了．</strong></p>
<h4 id="Fresnel-Reflectance-Values-for-Semiconductors-半导体的菲涅耳反射值"><a href="#Fresnel-Reflectance-Values-for-Semiconductors-半导体的菲涅耳反射值" class="headerlink" title="Fresnel Reflectance Values for Semiconductors 半导体的菲涅耳反射值"></a>Fresnel Reflectance Values for Semiconductors 半导体的菲涅耳反射值</h4><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003120329.png" class="" title="image-20211003120329">

<p>F0 的值与明亮的介质(钻石)和黑色金属(钛)相比，具有代表性的半导体(晶体形式的硅)。</p>
<p><strong>正如人们所预料的那样，半导体具有F0 值介于最亮电介质和最暗金属之间，如上表所示。在实践中很少需要渲染这些物质，因为大多数渲染场景都没有散布晶体硅块。为了实际目的，F0 的范围应该避免在0.2和0.45之间的值，除非你有意试图模拟一个奇异或不切实际的材料。</strong></p>
<h4 id="Fresnel-Reflectance-Values-in-Water-水中的菲涅耳反射率"><a href="#Fresnel-Reflectance-Values-in-Water-水中的菲涅耳反射率" class="headerlink" title="Fresnel Reflectance Values in Water 水中的菲涅耳反射率"></a>Fresnel Reflectance Values in Water 水中的菲涅耳反射率</h4><p><strong>在我们讨论全反射时，我们假设渲染的表面被空气包围。如果没有，反射率将会改变，因为它取决于界面两侧折射率之间的比率。如果我们不能再假设n1 = 1，则需要将之前式中的n替换为相对折射率n1/ n2．这就得到了以下更一般的等式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003120447.png" class="" title="image-20211003120447">

<p><strong>可能是最常见的情况，n1 ≠1是渲染水下场景。由于水的折射率大约是空气的1.33倍，F0 在水下是不同的。这种效应在电介质中比在金属中更强，如下表所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003120559.png" class="" title="image-20211003120559">

<p>F0 值之间的比较在空气中，在水中，对于各种物质。从上式可以看出，折射率接近水的电介质受到的影响最大。相比之下，金属几乎没有受到影响。</p>
<h4 id="Parameterizing-Fresnel-Values-参数化菲涅耳值"><a href="#Parameterizing-Fresnel-Values-参数化菲涅耳值" class="headerlink" title="Parameterizing Fresnel Values 参数化菲涅耳值"></a>Parameterizing Fresnel Values 参数化菲涅耳值</h4><p><strong>一种常用的参数化方法是将镜面颜色F0 弥散色ρss (漫反射颜色将在9.9节中进一步讨论)。这种参数化利用了观察到的金属没有漫反射颜色和电介质有一组F0可能值的限制集，它包括RGB表面颜色csurf 以及标量参数m，称为“金属”或“金属性”。”如果m = 1，那么F0 设置为csurf 和ρss 设置为黑色。如果m = 0，那么F0 设置为介电值(常数或由附加参数控制)和ρss 设置为csurf ．</strong></p>
<p><strong>“metalness”参数首次出现在布朗大学(Brown University)使用的早期着色模型中，其当前形式的参数化首次被皮克斯(Pixar)在电影《机器人总动员》(Wall-E)中使用。对于迪士尼原则性的着色模型，从《无敌破坏王》开始在迪士尼动画电影中使用，Burley添加了一个额外的着色模型标量“镜面”参数来控制电介质F0 在一定范围内。这种形式的参数化在Unreal Engine中使用，Frostbite引擎使用了稍微不同的形式，F0 的范围可能更大电介质的值。《使命召唤:无限战争》使用了一种变体，将这些金属属性和镜面参数整合到一个单一值中，以节省记忆。</strong></p>
<p><strong>对于那些使用金属参数化而不是使用F0 和ρss 的渲染应用程序直接来说，动机包括用户方便和保存纹理或G-buffer存储。在游戏《使命召唤:无限战争》中，这种参数化以一种不同寻常的方式使用。艺术家为F0 和ρss绘制纹理，自动转换为金属度参数化作为压缩方法。</strong></p>
<p><strong>使用金属性也有一些缺点。它不能表达某些类型的材料，例如涂有着色电介质F0的值。伪影可能出现在金属和电介质之间的边界上。</strong></p>
<p><strong>一些实时应用程序使用的另一个参数化技巧利用了没有材料具有F0 值低于0.02这一事实，外涂特殊防反射涂层。这个技巧被用来抑制表面区域的高光，这些区域代表空洞或空隙。而不是使用单独的高光遮挡纹理，值F0 低于0.02用于“关闭”菲涅耳边缘亮度。这种技术首先由Sch¨uler提出，并在Unreal和Frostbite引擎中使用。</strong></p>
<h3 id="Internal-Reflection-全反射"><a href="#Internal-Reflection-全反射" class="headerlink" title="Internal Reflection 全反射"></a>Internal Reflection 全反射</h3><p><strong>虽然在渲染中经常遇到全反射，但内部反射有时也很重要。当n1 &gt; n2．在换句话说，当光在透明物体内部传播并“从内部”遇到该物体表面时，全反射就发生了。见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003121347.png" class="" title="image-20211003121347">

<p>平面上的全反射，其中n1 &gt; n2．</p>
<p><strong>斯涅尔定律表明，对于内反射，sin θt &gt; sinθi．因为这些值都在0◦ 和90◦之间，这个关系式也暗示了θt &gt;θi，如上图所示。在全反射的情况下，情况正好相反。这种差异是理解内部反射和全反射如何不同的关键。在全反射中，sin θt的一个有效(较小)值 对于sin θi 的任何可能值都存在在0和1之间。对于内在反思来说，情况并非如此。对于θi 的值大于临界角θc斯涅尔定律暗示sin θt &gt;1，这是不可能的。事实上，根本就没有θt．当θi &gt;θc时，不发生透射，所有射入的光都被反射。这种现象被称为全反射。</strong></p>
<p><strong>菲涅耳方程是对称的，因为入射矢量和透射矢量可以互换，反射率保持不变。结合斯涅尔定律，这种对称性意味着F(θi)内部反射曲线将类似于全反射曲线的“压缩”版本。F0 的值是相同的，全反射曲线在θc 而不是90◦．如下图所示。下图还显示，平均而言，内部反射的反射率更高。例如，这就是为什么在水下看到的气泡具有高度反光的银色外观。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003121741.png" class="" title="image-20211003121741">

<p>玻璃-空气界面内外反射曲线的比较。在临界角θc处，内反射率曲线趋于1.0．</p>
<p><strong>全反射只发生在电介质中，因为金属和半导体会迅速吸收在它们内部传播的任何光。由于介质具有实值折射率，从折射率或从计算临界角度F0 很简单:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003121842.png" class="" title="image-20211003121842">

<p><strong>之前式中所示的Schlick近似对于全反射是正确的。通过代入透射角θt 为θi，可用于内反射．如果已经计算出透射方向矢量t(例如，绘制折射-见14.5.2节)，就可以用它来求θt．否则就可以用斯涅尔定律了计算θt 从θi，但这是昂贵的，并需要折射率，这可能无法得到。</strong></p>
<h2 id="Microgeometry-微观几何"><a href="#Microgeometry-微观几何" class="headerlink" title="Microgeometry 微观几何"></a>Microgeometry 微观几何</h2><p><strong>正如我们在前面的9.1.3节中讨论的，比像素小得多的表面不规则性不能被明确地建模，因此BRDF从统计角度对其聚合效应进行建模。目前，我们仍停留在几何光学领域，该领域假设这些不规则性要么小于光的波长(因此对光的行为没有影响)，要么要大得多。在“波动光学领域”(大约1-100个波长)中不规则的影响将在第9.11节中讨论。</strong></p>
<p><strong>每个可见表面点包含许多微表面法线，这些法线将反射光反射到不同的方向。由于各个微表面的方向在某种程度上是随机的，因此将它们建模为统计分布是有意义的。对于大多数表面，微观几何表面法线的分布是连续的，在宏观表面法线处有一个强烈的峰值。这种分布的“紧密性”是由表面粗糙度决定的。表面越粗糙，微几何法线就越“分散”。</strong></p>
<p><strong>增加微尺度粗糙度的可见效果是反射的环境细节更模糊。在小而明亮的光源的情况下，这种模糊导致更宽和更暗的高光。那些来自粗糙表面的光线更暗，因为光能扩散到一个更大的方向锥。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003124128.png" class="" title="image-20211003124128">

<p>从可见细节到微尺度的渐变。图像序列从上一行从左到右，然后从下一行从左到右。表面形状和光照是恒定的。只有表面细节的比例发生了变化。</p>
<p><strong>上图显示了可见光反射是如何由单个微尺度表面细节的聚合反射产生的。这一系列的图像显示了一个被单一光线照亮的曲面，其中的凸起在比例上稳步下降，直到最后一张图像中的凸起比单个像素小得多。许多小亮点中的统计模式最终成为最终聚合亮点形状的细节。例如，相对稀疏的个别凹凸高光在外围成为相对黑暗的聚集高光远离其中心。</strong></p>
<p><strong>对于大多数表面，微尺度表面法线的分布是各向同性的，这意味着它是旋转对称的，没有任何固有的方向性。其他表面具有各向异性的微尺度结构。这些表面具有各向异性的表面正态分布，导致反射和高光的方向模糊。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003124226.png" class="" title="image-20211003124226">

<p>左边是各向异性表面(拉丝金属)。注意反射的方向模糊。在右边，一张显微照片显示了一个相似的表面。注意细节的方向性。(显微照片由康奈尔大学计算机图形学程序提供。)</p>
<p><strong>一些表面具有高度结构的微几何，导致各种微尺度正态分布和表面形貌。织物是一个常见的例子——天鹅绒和缎子的独特外观是由于它们的微几何结构。面料模型将在第9.10节中讨论。</strong></p>
<p><strong>虽然多重表面法线是微几何对反射率的主要影响，但其他影响也可能很重要。阴影是指光源通过微尺度表面细节的遮挡，如下图左侧所示。掩蔽，也就是一些面隐藏了其他面的镜头，显示在图的中心。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003124332.png" class="" title="image-20211003124332">

<p>微尺度结构的几何效应。在左边，黑色虚线箭头表示一个区域被其他微几何体遮蔽(从光遮蔽)。在中间，红色虚线箭头表示一个区域被其他微几何遮罩(从视图中遮挡)。右图显示了微尺度结构之间的光相互反射。</p>
<p><strong>如果微几何高度与表面法线有一定的相关性，那么阴影和掩蔽可以有效地改变正态分布。例如，想象一个表面，凸起的部分已经被风化或其他过程磨平，而较低的部分仍然粗糙。在反光角度，较低的部分的表面将倾向于阴影或蒙面，导致一个有效的光滑表面。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003124436.png" class="" title="image-20211003124436">

<p>显微几何图形显示高度和表面法线之间有很强的相关性，凸起的区域是平滑的，较低的区域是粗糙的。在上面的图像中，表面从一个接近宏观表面法线的角度被照亮。在这个角度，许多入射光线都能进入粗糙的凹坑，所以很多光线会分散到不同的方向。在下面的图像中，表面从一个角度被照亮。阴影挡住了大部分凹坑，所以很少有光线照射到凹坑上，大部分光线都是从表面光滑的部分反射回来的。在这种情况下，表观粗糙度很大程度上取决于照明角度。</p>
<p><strong>对于所有的表面类型，表面不规则的可见尺寸随入射角θi 的增大而减小增加到正常水平。在非常倾斜的角度，这种效应可以减少不规则的观察尺寸，使其小于光的波长，使它们“消失”，就光响应而言。这两种效果结合菲涅尔效应，使表面出现高度反射和镜子一样的视角和照明角度接近90◦。</strong></p>
<p><strong>你自己确认一下。把一张不发亮的纸卷成一个长管。不要从洞里往外看，把你的眼睛稍微抬高一点，这样你就可以往下看长度。把你的电视机对着明亮的窗户或电脑屏幕。当你的视角几乎与纸张平行时，你会看到窗户或屏幕在纸张上的强烈反射。角度必须非常接近90度◦ 看看效果如何。</strong></p>
<p><strong>被微尺度表面细节遮挡的光不会消失。它可能会反射到其他的微观几何结构上。光在到达眼睛之前可能会以这种方式经历多次反射。这样的相互反射如上上图的右侧所示。由于光在每次反弹时都被菲涅耳反射率衰减，所以在电介质中相互反射往往是微妙的。在金属中，多次反射是任何可见漫反射的来源，因为金属缺乏次表面散射。有色金属的多次反射比主反射颜色更深，因为它们是光与表面多次相互作用的结果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003124631.png" class="" title="image-20211003124631">

<p>由于微尺度粗糙度的反射。这两幅图都显示了一个粗糙的表面，低菲涅耳反射率和高散射反照率，因此地下反射率在视觉上很重要。在左边，观看和照明方向是相似的。微几何的明亮部分也是最可见的部分，导致了明亮的外观。在右侧，观看和照明方向差异很大。在这种情况下，明亮的区域被遮挡从视图和可见区域被阴影，导致一个更暗的外观。</p>
<p><strong>到目前为止，我们已经讨论了微几何对镜面反射率的影响。，即表面反射率。在某些情况下，微尺度的表面细节也会影响地下反射率。如果微几何形状的不规则性大于次表面散射距离，那么阴影和掩蔽会导致反反射效应，光线会优先反射回入射方向。这种效果的发生是因为阴影和掩蔽将遮挡光照区域时，观察和照明方向的差异很大。参见上图。反光会使粗糙的表面变得平整。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003124642.png" class="" title="image-20211003124642">

<p>由于微尺度的表面粗糙度，两个物体表现出非朗伯特反反射行为的照片。(右侧照片由Peter-Pike Sloan提供。)</p>
<h2 id="Microfacet-Theory-微表面理论"><a href="#Microfacet-Theory-微表面理论" class="headerlink" title="Microfacet Theory 微表面理论"></a>Microfacet Theory 微表面理论</h2><p><strong>许多BRDF模型都是基于微几何对反射率影响的数学分析，称为微面理论。该工具最初是由光学领域的研究人员开发的。1977年Blinn和1981年Cook和Torrance将它引入计算机图形学。该理论的基础是将微几何建模为微表面的集合。</strong></p>
<p><strong>每个微面都是平的，有一个微表面法线m。微表面根据微BRDF fμ分别反射光µ(l, v, m)，所有微表面的综合反射率加起来等于整个表面BRDF。通常的选择是每个微表面都是一个完美的菲涅尔镜面，从而产生一个镜面微表面 BRDF来建模表面反射。然而，也有其他选择。漫反射微BRDFs已经被用于创建多个局部次表面散射模型。衍射微BRDF被用来创建一个结合几何和波动光学效应的着色模型。</strong></p>
<p><strong>微表面模型的一个重要特性是微表面法线m的统计分布。这种分布由表面的正态分布函数(NDF)定义。一些参考文献使用了术语正态分布，以避免与高斯正态分布混淆。我们将用D(m)来表示方程中的NDF。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004115934.png" class="" title="image-20211004115934">

<p>微表面的侧视图。在左边，我们看到积分D(m)(n·m)， 微表面面积投影到宏观平面上，得到宏观表面的面积(在这个侧视图中，长度)，按照惯例是1。在右边,整合D (m) (v·米),微表面面积投射到平面垂直于v,等于微表面这个平面上的投影,cosθo或(v·n)。当多个微表面重叠的预测,背面微表面的负的投影面积沿微表面抵消“额外”前面的微表面。(以Matej Drame的人物命名。)</p>
<p><strong>NDF D(m)是微表面表面法线在微几何表面积上的统计分布。对整个微表面法线球积分D(m)就得到了微表面的面积。更有用的是，对D(m)(n·m)进行积分，D(m)在宏观平面上的投影，可以得到宏观patch的面积，按照惯例等于1，如上图左侧所示。也就是说，投影D(m)(n·m)是归一化的:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004120322.png" class="" title="image-20211004120322">

<p><strong>这个积分是在整个球面上进行的，这里用Θ表示，不像本章中之前的球面积分，只对以n为中心的半球进行积分，用Ω表示。尽管一些参考文献使用Ω来表示完整的球体，但大多数图形出版物都使用这种符号。在实际应用中，图形中使用的微观结构模型多为高度场，即在Ω外的m方向上，D(m) = 0。然而，上式同样适用于非高度场微结构。</strong></p>
<p><strong>一般来说，微面和宏观面在垂直于任意视图方向v的平面上的投影是相等的:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004141747.png" class="" title="image-20211004141747">

<p><strong>上面两个方程中的点积不是固定为0。上图的右侧显示了原因。上面两个方程规定了函数D(m)必须服从的约束条件，使其为有效的NDF。</strong></p>
<p><strong>直观地说，NDF就像微表面法线的直方图。它在微表面法线更可能指向的方向上有高值。大多数表面都有NDF，在宏观表面法线n处显示一个强烈的峰值。9.8.1节将涵盖在渲染中使用的几个NDF模型。</strong></p>
<p><strong>再看一下上图的右侧。尽管有许多具有重叠投影的微表面，但最终为了渲染，我们只关心可见的微表面，即。，在每个重叠集中最接近相机的微表面。这一事实提出了一种将投影的微表面面积与投影的宏观几何区域关联起来的替代方法:可见微表面的投影面积之和等于宏观曲面的投影面积。我们可以通过定义掩蔽函数G1(m, v)来用数学方法来表示它，它给出沿视图向量v可见的法向m的微表面的分数。G1(m, v)D(m)(v·m)+ 的积分球面，然后给出宏观表面投影到垂直于v的平面上的面积:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004142027.png" class="" title="image-20211004142027">

<p><strong>如下图所示。与上上式不同，上式中的点积是固定为零的。这个运算用x+ 表示在第1.2节中介绍的符号。背面的微表面不可见，因此在本例中不计算它们。产品G1(m, v)D(m)为可见正态分布。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004142057.png" class="" title="image-20211004142057">

<p>将可见微表面的投影面积(亮红色)进行积分，就可以得到宏观表面在垂直于v的平面上的投影面积。</p>
<p><strong>而上式对G1(m, v)施加约束它不是唯一决定它的。有无限函数满足给定微表面正态分布D(m)的约束。这是因为D(m)没有完全指定微表面。它告诉我们有多少微表面的法线指向某个方向，但不告诉我们它们是如何排列的。</strong></p>
<p><strong>尽管各种G1 多年来一直有人提出函数，但在Heitz的一篇优秀论文中(至少目前)解决了该使用哪个函数的难题。Heitz讨论了Smith掩蔽函数，它最初是由高斯正态分布推导出来的，后来推广到任意NDFs。Heitz证明，在文献中提出的掩模函数之外，只有两个——Smith函数和Torrance-Sparrow“V-cavity”函数——服从上式，因此在数学上是有效的。他进一步表明，史密斯函数比托伦斯-斯派洛函数更接近于随机微表面的行为。Heitz还证明了Smith掩蔽函数是唯一可能的既符合上式又具有正规掩蔽独立性的函数。这意味着G1(m, v)的值不依赖于m的方向，只要m不是背向的。只要m·v≥0。史密斯G1 函数的形式如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004142409.png" class="" title="image-20211004142409">

<p><strong>其中χ+(x)为正特征函数</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004142418.png" class="" title="image-20211004142418">

<p><strong>Λ(lambda)函数对于每个NDF是不同的。Walter等人和Heitz的出版物中描述了为给定NDF推导 Λ的过程。</strong></p>
<p><strong>Smith屏蔽函数确实有一些缺点。从理论的角度来看，它的要求与实际表面的结构不一致，甚至可能在物理上无法实现。从实用的角度来看，虽然它对随机表面是相当精确的，但对于法向和掩蔽之间有更强依赖性的表面，其精度预期会降低，特别是如果表面有一些重复结构(就像大多数织物)。然而，在找到更好的替代方案之前，它是大多数呈现应用程序的最佳选择。</strong></p>
<p><strong>给出微几何描述，包括微BRDF fµ(l, v, m)，正态分布函数D(m)，掩蔽函数G1(m, v)，可推导出整体宏观表面BRDF:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004142624.png" class="" title="image-20211004142624">

<p><strong>这个积分是在以n为中心的半球Ω上，以避免从表面下收集光的贡献。而不是掩蔽函数G1(m, v)， 上式使用联合遮蔽函数G2(l v m)这个函数，由G1，给出了从两个方向可见的具有法向m的微表面的比例:视图向量v和光向量l2 函数，上式使BRDF能够考虑掩蔽和遮蔽，但不考虑微表面之间的相互反射。缺少微表面相互反射是由上式推导出来的所有BRDFs共有的一个限制。因此，这样的BRDFs有些过于黑暗。在9.8.2和9.9节中，我们将讨论一些已经提出的解决这一限制的方法。</strong></p>
<p><strong>Heitz讨论了G2 函数。最简单的是可分离形式，其中掩蔽和阴影分别使用G1 进行评估相乘:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004142913.png" class="" title="image-20211004142913">

<p><strong>这种形式相当于假设遮蔽和遮蔽是不相关的事件。在现实中，它们不是，并且假设导致BRDFs使用这种形式的G2过度暗化．</strong></p>
<p><strong>作为一个极端的例子，考虑视图和光方向相同的情况。这里是G2 应该等于G1，因为所有可见的面都没有阴影，但使用上式G2 将等于G1²。</strong></p>
<p><strong>如果微表面是一个高度场，这通常是用于绘制微表面模型的情况，那么当v和l之间的相对方位角φ等于0◦,G2(l, v, m)等于min(G1 (v, m)，G1(l, m))。这种关系提供了一种解释掩蔽和遮蔽之间相关性的一般方法，可以用于任何G1 功能:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004143122.png" class="" title="image-20211004143122">

<p><strong>其中λ(φ)是随着角度φ增大而从0增加到1的函数。Ashikhmin等提出了一个标准差为15◦(~ 0.26 弧度)的高斯分布 :</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004143347.png" class="" title="image-20211004143347">

<p><strong>van Ginneken等人提出了一个不同的λ函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004143356.png" class="" title="image-20211004143356">

<p><strong>不管光线和视图方向的相对对齐，在一个给定的表面点上的遮蔽和阴影是相关的还有一个原因。两者都与点相对于曲面其余部分的高度有关。对于较低的点，掩蔽的概率增加，遮蔽的概率也增加。如果使用Smith掩蔽函数，这种相关性可以用Smith高度相关的掩蔽-阴影函数精确地解释:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004143432.png" class="" title="image-20211004143432">

<p><strong>海茨还描述了史密斯G2 它结合了方向和高度的相关性:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004143446.png" class="" title="image-20211004143446">

<p><strong>其中λ(v, l)可以是一个经验函数，如上上上两个方程中的那些，或一个专门为给定NDF推导出来的函数。</strong></p>
<p><strong>在这些备选方案中，Heitz推荐了Smith函数的高度相关形式(上上式)，因为它的代价与不相关形式相似，而且精度更高。这种形式在实践中使用最广泛，尽管有些实践者使用可分离形式。</strong></p>
<p><strong>通用微表面 BRDF不直接用于渲染。它被用来推导一个闭形式的解(精确的或近似的)给定一个特定的微BRDF fµ选择．下一节将展示这种类型的派生的第一个示例。</strong></p>
<h2 id="BRDF-Models-for-Surface-Reflection-表面反射的BRDF模型"><a href="#BRDF-Models-for-Surface-Reflection-表面反射的BRDF模型" class="headerlink" title="BRDF Models for Surface Reflection 表面反射的BRDF模型"></a>BRDF Models for Surface Reflection 表面反射的BRDF模型</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006133451.png" class="" title="image-20211006133451">

<p>半矢量h与光矢量和视图矢量形成相等的角度(如图所示)。</p>
<p><strong>除了少数例外，在基于物理的渲染中使用的高光BRDF术语来自微表面理论。在镜面反射的情况下，每个微面是一个完美光滑的菲涅耳镜。回想一下，这种镜子将每一束射入的光线反射到一个单一的反射方向。这意味着微BRDF fµ每个面(l, v, m)等于零,除非v是平行的反射l。对于给定l和v向量,这个配置相当于情况微表面法线m是与一个向量指向l和诉的正中间。这个向量是半矢量h。参见上图。通过将v和l相加并对结果进行归一化计算:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006133405.png" class="" title="image-20211006133405">

<p><strong>当由之前式子推导镜面微面模型时，对于所有m≠ h，菲涅耳镜微BRDF fµ(l, v, m)等于零是很方便的，因为它将积分分解为在m = h处的积分函数的值。这样做就产生了镜面BRDF项</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006133631.png" class="" title="image-20211006133631">

<p><strong>关于推导的细节可以在Walter et al. ， Heitz和Hammon的出版物中找到。Hammon还提出了一种优化BRDF实现的方法，通过计算n·h和l·h而不计算向量h本身。</strong></p>
<p><strong>我们用符号fspec 对于上式中的BRDF项，表示它仅模拟表面(镜面)反射。在一个完整的BRDF中，它可能会与另一个模型下表面(漫反射)着色的术语配对。为了直观地理解上式，考虑到只有那些法线恰好与半矢量(m = h)对齐的微表面才能正确地将光线从l反射到v，见下图。因此，反射光的数量取决于法线等于h的微表面的浓度。这个值由D(h)给出，D(h)是那些从光线和视野方向都能看到的微表面的比例，等于G2(l, v, h)，以及每个微表面反射的光的部分，由F(h, l)指定。在求菲涅尔函数时，向量h代替表面法线。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006133857.png" class="" title="image-20211006133857">

<p>由微面组成的表面。只有表面法线与半矢量h对齐的红色微表面参与从入射光矢量l到视图矢量v的反射。</p>
<p><strong>在遮罩-阴影函数中使用半矢量可以进行较小的简化。由于涉及的角度永远不能大于90◦，χ+项在方程中可以被删除。</strong></p>
<h3 id="Normal-Distribution-Functions-正态分布函数"><a href="#Normal-Distribution-Functions-正态分布函数" class="headerlink" title="Normal Distribution Functions 正态分布函数"></a>Normal Distribution Functions 正态分布函数</h3><p><strong>正态分布函数对渲染表面的外观有重要影响。NDF的形状，绘制在微表面法线的球面上，决定了反射光线(镜面)的锥的宽度和形状叶)，这反过来决定了高光的大小和形状。NDF影响表面粗糙度的整体感知，以及更微妙的视觉方面，如高光是否有明显的边缘或被雾霾包围。</strong></p>
<p><strong>然而，镜面叶并不是NDF形状的简单复制。它，以及高光形状，根据表面曲率和视角的不同，被或大或小程度地扭曲。这种扭曲对于平面来说尤其强烈，如下图所示。Ngan等人对这种扭曲背后的原因进行了分析。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006134325.png" class="" title="image-20211006134325">

<p>左边的图像是用非物理Phong反射模型渲染的。该模型的镜面波瓣围绕反射矢量旋转对称。这种BRDFs在早期的计算机图形学中经常使用。中心的图像是用基于物理的微表面BRDF渲染的。左上方和中间显示了一个平面表面在一个斜视角度照明。左上方显示一个不正确的圆形高光，而中心显示微表面 BRDF上的特征高光延伸。正如右边的照片所示，中间的视图与现实相符。高光形状的差异在下面两个渲染图像中显示的球体上要微妙得多，因为在这种情况下，表面曲率是高光形状的主要因素。(摄影:Elan Ruskin)</p>
<h4 id="Isotropic-Normal-Distribution-Functions-各向同性正态分布函数"><a href="#Isotropic-Normal-Distribution-Functions-各向同性正态分布函数" class="headerlink" title="Isotropic Normal Distribution Functions 各向同性正态分布函数"></a>Isotropic Normal Distribution Functions 各向同性正态分布函数</h4><p><strong>大多数用于绘制的NDFs是关于宏观表面法线n的各向同性旋转对称。在这种情况下，NDF只是一个变量的函数，角度θm 在理想情况下，NDF可以写成cos θm 的表达式它可以被有效地计算为n和m的点积。</strong></p>
<p><strong>Beckmann NDF是光学界开发的第一个微表面模型中使用的正态分布。时至今日，它仍在那个社区被广泛使用。它也是为Cook-Torrance BRDF选择的NDF。归一化贝克曼分布有以下形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006164058.png" class="" title="image-20211006164058">

<p><strong>项χ+(n·m)确保所有微表面法线的NDF值为0宏观表面下的点。这个属性告诉我们，这个NDF，就像我们将在本节讨论的所有其他NDF一样，描述了一个高度场微表面。的αb 参数控制表面粗糙度。它与微几何表面的均方根(RMS)斜率成正比，因此αb = 0表示完美光滑的表面。</strong></p>
<p><strong>来推导Smith G2 对于Beckmann NDF函数，我们需要相应的Λ函数，代入9.24式(如果使用G2)， 9.31(高度相关形式)，或9.32(方向和高度相关形式)。</strong></p>
<p><strong>Beckmann NDF是形状不变的，这简化了Λ的推导。根据Heitz的定义，如果粗糙度参数的影响等效于微表面的缩放(拉伸)，则各向同性NDF是形状不变的。形状不变NDFs可以写成以下形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006164328.png" class="" title="image-20211006164328">

<p><strong>其中g表示任意的单变量函数。对于任意的各向同性NDF， Λ函数依赖于两个变量。第一个是粗糙度α，第二个是计算Λ的向量(v或l)的入射角。然而，对于形状不变的NDF， Λ函数只依赖于变量a:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006164358.png" class="" title="image-20211006164358">

<p><strong>其中s是表示v或l向量。在这种情况下，Λ只依赖于一个变量，这一事实便于实现。单变量函数可以更容易地用近似曲线拟合，并且可以在一维数组中制成表格。</strong></p>
<p><strong>贝克曼NDF的Λ函数为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006164410.png" class="" title="image-20211006164410">

<p><strong>上式的计算代价很高，因为它包含误差函数erf。为此，通常使用近似:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006164535.png" class="" title="image-20211006164535">

<p><strong>下一个我们要讨论的NDF是Blinn-Phong NDF。在过去，它在计算机图形学中被广泛使用，尽管在最近的时间里它已经被其他发行版所取代。Blinn-Phong NDF仍然用于计算成本较高的情况下(例如，在移动硬件上)，因为它比本节讨论的其他NDF的计算成本更低。</strong></p>
<p><strong>Blinn-Phong NDF是由Blinn推导出来的，是对(非物理的)Phong着色模型的修正:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006164728.png" class="" title="image-20211006164728">

<p><strong>αp 为Phong NDF的粗糙度参数。高值代表光滑表面，低值代表粗糙表面。αp 对于极其光滑的表面可以达到任意的高度——一个完美的镜子需要αp =∞。通过设置，可以得到最大随机表面(均匀NDF)αp 为0。αp 参数的视觉冲击力极不均匀，不便于直接操作。较小的数值变化对于较小的αp 值具有较大的视觉效果，但是较大的值可以在没有太多视觉影响的情况下进行显著更改。因此，αp 通常由用户操作的参数通过非线性映射导出。例如,αp=m^s，其中s是0到1之间的参数值，m是αp 的上限在给定的应用程序中。许多游戏都使用了这种映射，包括《使命召唤:黑色行动》，其中m被设置为8192。</strong></p>
<p><strong>当BRDF参数的行为在感知上不一致时，这种“接口映射”通常是有用的。这些映射用于解释通过滑块设置或绘制纹理的参数。</strong></p>
<p><strong>Beckmann和Blinn-Phong粗糙度参数的等值值可以用αp = 2αb^−2−2关系求得。当参数通过这种方式匹配时，两种分布非常接近，特别是对于相对光滑的表面，如下图左上角所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006165128.png" class="" title="image-20211006165128">

<p>左上方是Blinn-Phong(蓝色虚线)和Beckmann(绿色)分布的对比，αb的值从0.025到0.2(使用αp = 2αb^-2−2的参数关系)。右上方是GGX(红色)和Beckmann(绿色)分布的对比。αb 和左边的图一样。αg 已调整眼睛，以匹配高光大小。这些相同的值也被用在底部图像的球体中。顶部行使用Beckmann NDF，底部行使用GGX。</p>
<p><strong>Blinn-Phong NDF不是形状不变的，它的Λ函数不存在解析形式。Walter等人建议将贝克曼Λ函数与α函数结合使用p = 2αb^−2−2参数等价。</strong></p>
<p><strong>在同一篇1977年的论文中，Blinn将Phong着色函数应用到微表面 NDF中，他提出了另外两个NDF。在这三种分布中，Blinn推荐了Trowbridge和Reitz推导的一种分布。这一建议没有得到广泛重视，但30年后，沃尔特等人独立地重新发现了Trowbridge-Reitz分布，并将其命名为GGX分布。这一次，种子生根了。在几年内，GGX发行方式开始在电影和游戏行业传播开来，今天它可能是这两个行业最常用的发行方式。布林的建议似乎超前了30年。虽然“Trowbridge-Reitz发行版”在技术上是正确的名称，但我们在本书中使用GGX的名称，因为它已被牢固确立。</strong></p>
<p><strong>GGX发行版是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006165437.png" class="" title="image-20211006165437">

<p><strong>由αg参数提供的粗糙度控制与由Beckmann αb 提供的粗糙度控制相似参数。在迪士尼原则着色模型中，Burley揭示粗糙度控制为αg = r²，其中r为用户界面粗糙度参数值，取值范围为0 ~ 1。将r显示为滑块值意味着效果以更线性的方式变化。大多数使用GGX发行版的应用程序都采用了这种映射。</strong></p>
<p><strong>GGX分布是形状不变的，其Λ函数相对简单:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006165605.png" class="" title="image-20211006165605">

<p><strong>变量a在上式中只作为a²出现，因为可以避免之前式中的平方根。</strong></p>
<p><strong>由于GGX发行版和Smith遮蔽功能的流行，人们一直在努力优化这两者的组合。拉加德观察到，高度相关的Smith G2 对于GGX，当与镜面微表面 BRDF(9.34式)的分母结合时，有抵消的项。合并项可以简化为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006165755.png" class="" title="image-20211006165755">

<p><strong>该方程采用变量替换法μi=(n·l)+，μo = (n·v)+为了简洁。Karis提出了Smith G1 的近似形式GGX函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006165927.png" class="" title="image-20211006165927">

<p><strong>其中s可以用l或v代替。Hammon表明G1 得到了高度相关的Smith G2 组合项的有效近似函数和镜面微表面 BRDF 分母:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006170113.png" class="" title="image-20211006170113">

<p><strong>它使用线性插值算子，lerp(x, y, s) = x(1 - s) + ys。</strong></p>
<p><strong>对比上图中的GGX分布和Beckmann分布，可以明显看出两者的形状有根本的不同。GGX的峰值比贝克曼的要窄，而这些峰值周围的“尾巴”则更长。在下图底部的渲染图像中，我们可以看到GGX较长的尾部在高光核心周围产生了薄雾或辉光的外观。</strong></p>
<p><strong>许多真实世界的材料显示了类似的模糊亮点，其尾部通常比GGX分布的尾部更长。参见下图。这种认识是GGX发行版日益流行的重要原因，同时也促使人们不断寻找新的发行版，以便更准确地匹配测量到的材料。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006170240.png" class="" title="image-20211006170240">

<p>NDFs适合测量铬从MERL数据库。在左边，我们画出了反射峰相对于θm 的曲线对于铬(黑色)，GGX(红色;αg = 0.006)， Beckmann(绿色;αb = 0.013)， and Blinn-Phong(蓝色破折号;n = 12000)。渲染后的高亮显示在右边的chrome, GGX和Beckmann。(数据来自Brent Burley。)</p>
<p><strong>Burley提出了广义的Trowbridge-Reitz (GTR) NDF，其目标是对NDF的形状，特别是分布的尾部进行更多的控制:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006170415.png" class="" title="image-20211006170415">

<p><strong>γ参数控制尾形。γ = 2时，GTR与GGX相同。随着γ值的减小，分布的尾部变长，随着γ值的增大，他们变得更短。γ值较高时，GTR分布与Beckmann分布相似。k(α,γ)项是归一化因子，由于它比其他NDFs更复杂，我们用单独的方程给出:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006170535.png" class="" title="image-20211006170535">

<p><strong>GTR分布不是形状不变的，这使寻找它的Smith G2 遮罩-阴影函数变得复杂。在NDF发表之后，花了三年时间才找到G2 。这个G2 解是相当复杂的，带有γ某些值的解析解表(对于中间值，必须使用插值)。GTR的另一个问题是，参数α和γ以一种非直观的方式影响感知粗糙度和“辉光”。</strong></p>
<p><strong>Student’s t-distribution(STD)和指数功率分布(EPD) NDFs包括形状控制参数。与GTR相反，这些函数对于它们的粗糙度参数是形状不变的。在撰写本文时，这些都是新出版的，因此尚不清楚它们是否会在应用中得到应用。</strong></p>
<p><strong>为了更好地匹配测量材料，一种替代方案是使用多个镜面瓣，而不是增加NDF的复杂性。这个想法是由Cook和Torrance提出的。Ngan对其进行了实验测试，发现对于许多材料来说，添加第二个瓣确实显著提高了契合度。皮克斯的PxrSurface材料有一个“粗糙镜面”瓣，打算用于这个目的(与主镜面瓣一起使用)。附加瓣是一个具有所有相关参数和项的全镜面微表面 BRDF。Imageworks采用了一种更为外科手术的方法，使用两种GGX NDF的混合，这两种NDF作为扩展的NDF暴露给用户，而不是整个单独的高光BRDF术语。在这种情况下，唯一需要的附加参数是第二个粗糙度值和混合量。</strong></p>
<h4 id="Anisotropic-Normal-Distribution-Functions-各向异性正态分布函数"><a href="#Anisotropic-Normal-Distribution-Functions-各向异性正态分布函数" class="headerlink" title="Anisotropic Normal Distribution Functions 各向异性正态分布函数"></a>Anisotropic Normal Distribution Functions 各向异性正态分布函数</h4><p><strong>虽然大多数材料具有各向同性表面统计，但有些材料的微观结构具有显著的各向异性，显著影响其外观。为了准确地渲染这些材料，我们需要BRDFs，特别是 NDFs，也是各向异性的。</strong></p>
<p><strong>与各向同性 NDFs不同，各向异性 NDFs不能只用角度θm来计算．需要额外的定向信息。一般情况下，微面法线m需要转换为由法线向量n、切线向量t和双切线向量b定义的局部坐标系或切线空间。在实践中，这个变换通常表示为三个独立的点积:m·n, m·t，和m·b。</strong></p>
<p><strong>当法线映射与各向异性BRDFs相结合时，确保法线映射扰动正切和双切向量以及法线向量是很重要的。这一过程通常是通过将修正的Gram-Schmidt过程应用于摄动的法向量n和插值的顶点切线和双切线向量t0 和b0 来完成的(下面假设n已经归一化):</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171044.png" class="" title="image-20211006171044">

<p><strong>或者，在第一行之后，正交b向量可以通过取n和t的叉乘来创建。</strong></p>
<p><strong>对于拉丝金属或卷发这样的效果，逐像素修改切线方向是需要的，通常由切线贴图提供。这个贴图是一个纹理，它存储每像素的正切，类似于法线贴图存储每像素的法线。切映射通常存储切向量在垂直于法线的平面上的二维投影。这种表示可以很好地用于纹理过滤，并且可以像法线贴图一样进行压缩。有些应用程序存储标量旋转量，用于围绕n旋转切向量。尽管这种表示更紧凑，但它容易产生旋转角度为360◦ 到0◦的纹理过滤现象．</strong></p>
<p><strong>创建各向异性NDF的常用方法是推广现有的各向同性NDF。所用的一般方法可以应用于任何形状不变的各向同性NDF，这是形状不变NDF更可取的另一个原因。回想一下，各向同性形状不变NDFs可以写成以下形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171214.png" class="" title="image-20211006171214">

<p><strong>用g表示表示NDF形状的一维函数。各向异性的版本是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171224.png" class="" title="image-20211006171224">

<p><strong>参数αx 和αy 表示沿t和b方向的粗糙度，分别。如果αx =αy上式又还原为各向同性形式。</strong></p>
<p><strong>G2 各向异性NDF的遮蔽函数与各向同性NDF相同，只是变量a(传递到Λ函数)的计算方式不同:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171322.png" class="" title="image-20211006171322">

<p><strong>其中s代表v或l。</strong></p>
<p><strong>利用这种方法，我们得到了Beckmann NDF的各向异性版本，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171412.png" class="" title="image-20211006171412">

<p><strong>GGX NDF，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171421.png" class="" title="image-20211006171421">

<p><strong>如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171440.png" class="" title="image-20211006171440">

<p>使用各向异性NDFs渲染的球体:第一行是Beckmann，第二行是GGX。在两行中αy 保持不变，αx 从左到右递增。</p>
<p><strong>而参数化各向异性ndf最直接的方法是使用各向同性粗糙度参数化两次，一次是αx 一次是αy，有时会使用其他参数化。在Disney原则性着色模型中，各向同性粗糙度参数r与第二个标量参数kaniso 相结合取值范围为[0,1]。αx 和αy 从这些参数计算值如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171642.png" class="" title="image-20211006171642">

<p><strong>0.9因素限制宽高比为10:1。</strong></p>
<p><strong>Imageworks使用了一种不同的参数化方法，允许任意程度的各向异性:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171704.png" class="" title="image-20211006171704">

<h3 id="Multiple-Bounce-Surface-Reflection-多次反射表面反射"><a href="#Multiple-Bounce-Surface-Reflection-多次反射表面反射" class="headerlink" title="Multiple-Bounce Surface Reflection 多次反射表面反射"></a>Multiple-Bounce Surface Reflection 多次反射表面反射</h3><p><strong>如前面9.7节所述，微表面 BRDF框架不考虑从微表面多次反射(“反弹”)的光。这种简化会导致一些能量损失和过度暗化，特别是对于粗糙金属。</strong></p>
<p><strong>Imageworks使用了一种技术，结合了以前工作中的元素，创建了一个可以添加到BRDF中的术语，以模拟多次反弹的表面反射:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171806.png" class="" title="image-20211006171806">

<p><strong>在RsF1 的方向反照率为(第9.3节)fsF1，即带有F0 的高光BRDF项设置为1。RsF1 的函数取决于粗糙度α和仰角θ。它是相对光滑的，所以它可以预先计算数值，并存储在一个小的二维纹理中。Imageworks发现32 × 32的分辨率就足够了。</strong></p>
<p><strong>ˉRsF1 的函数是RsF1 的余弦加权平均值。它只依赖于α，所以它可以存储在一维纹理中，或者可以用廉价的曲线来拟合数据。自RsF1 是关于n，ˉRsF1 旋转对称可以用一维积分来计算。我们还利用变量的变化量µ= cos θ:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006172115.png" class="" title="image-20211006172115">

<p><strong>最后，ˉF为菲涅耳项的余弦加权平均值，计算方法相同:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006172125.png" class="" title="image-20211006172125">

<p><strong>Imageworks提供了上式的闭格式解，如果F使用的是广义Schlick式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006172134.png" class="" title="image-20211006172134">

<p><strong>如果使用原始的Schlick近似，则解简化为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006172228.png" class="" title="image-20211006172228">

<p><strong>在各向异性的情况下，Imageworks使用αx 和αy 之间的中间粗糙度为了计算fms．这种近似避免了增大RsF1 维数的需要查找表，它引入的错误很小。</strong></p>
<p><strong>Imageworks多次反射反射项的结果如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006172238.png" class="" title="image-20211006172238">

<p>在所有的行中，表面的粗糙度从左到右递增。顶部的两行显示了黄金材质。呈现第一行时不使用Imageworks多次反弹项，呈现第二行时使用多次反弹项。这种差异在粗糙的球体中最为明显。接下来的两行是黑色的电介质材料。呈现第三行时不使用多次反弹项，而呈现第四行时应用了多次反弹项。这里的差别更微妙，因为镜面反射要低得多。(图由Christopher Kulla提供。)</p>
<h2 id="BRDF-Models-for-Subsurface-Scattering-次表面散射的BRDF模型"><a href="#BRDF-Models-for-Subsurface-Scattering-次表面散射的BRDF模型" class="headerlink" title="BRDF Models for Subsurface Scattering 次表面散射的BRDF模型"></a>BRDF Models for Subsurface Scattering 次表面散射的BRDF模型</h2><p><strong>在前一节中，我们讨论了镜面反射。在本节中，我们将讨论问题的另一方面，即光在表面下折射时会发生什么。正如我们在9.1.4节中讨论的，这种光经历了一些散射和吸收的结合，其中一部分被重新发射出原始表面。我们将在这里集中讨论不透明介质中局部次表面散射或漫射表面响应的BRDF模型。金属是无关的，因为它们没有任何显著的地下光相互作用。介质材料是透明的或表现出全面的次表面散射将在第14章中涉及。</strong></p>
<p><strong>我们开始讨论漫反射模型的一部分，漫反射颜色的属性和可能的值，这种颜色可以在现实世界的材料。在下面的小节中，我们将解释表面粗糙度对漫射着色的影响，以及对于给定的材质选择使用平滑表面还是粗糙表面着色模型的标准。最后两个小节专门讨论光滑表面和粗糙表面模型本身。</strong></p>
<h3 id="Subsurface-Albedo-次表面反照率"><a href="#Subsurface-Albedo-次表面反照率" class="headerlink" title="Subsurface Albedo 次表面反照率"></a>Subsurface Albedo 次表面反照率</h3><p><strong>地下层反照率ρss 一种不透明介质的能量是从表面逃逸的光的能量与进入材料内部的光的能量之比。ρss 的值介于0(所有光线都被吸收)和1(没有光线被吸收)之间，取决于波长，所以ρss 建模为RGB矢量进行渲染。对于创作,ρss 常被称为表面的漫反射颜色，就像正入射菲涅耳反射率F0 通常被称为高光色。地下反照率与第14.1节讨论的散射反照率密切相关。</strong></p>
<p><strong>由于电介质传输大部分入射光而不是将其反射到表面，所以次表面反照率ρss 通常更明亮，因此在视觉上比镜面颜色F0．因为它是由不同的物理过程产生的，不同于内部的镜面颜色吸收，而不是表面的菲涅耳反射-ρss 通常有不同的光谱分布(因此是RGB颜色)与F0．例如，彩色塑料是由透明、透明的基材组成的，基材内部嵌有颜料颗粒。镜面反射的光将是无色的，而漫反射的光将被色素颗粒吸收而着色;例如，一个红色的塑料球有一个白色的高光。</strong></p>
<p><strong>次表面反照率可以被认为是吸收和散射之间“竞赛”的结果——光线会在有机会从物体散射回来之前被吸收吗?这就是为什么液体上的泡沫比液体本身更亮。起泡过程并不改变液体的吸收率，但大量气液界面的加入大大增加了散射量。这导致大部分入射光在被吸收之前就被散射，从而产生高的地下反照率和明亮的外观。新雪是高反照率物质的另一个例子。雪粒和空气之间的界面有相当大的散射，但吸收很少，导致在可见光谱中地下反照率为0.8或更高。白漆略少，约0.7。日常生活中遇到的许多物质，如混凝土、石头、土壤，平均在0.15到0.4之间。煤是一种地下反照率极低的材料，接近0.0。</strong></p>
<p><strong>许多物质在潮湿时颜色变深的过程与液体泡沫的例子相反。如果材料是多孔的，水就会渗透到以前充满空气的空间。电介质材料的折射率更接近水而不是空气。相对折射率的降低降低了在物质内部的散射，光在逃离物质之前(平均)传播了更长的距离。这种变化导致更多的光被吸收，次表面反照率变暗。</strong></p>
<p><strong>这是一个常见的误解(甚至反映在备受尊重的材料创作指南)，价值ρss 对于真实的材料创作，永远不应该低于0.015-0.03的下限(30-50在8位非线性sRGB编码)。然而，这个下限是基于颜色测量，包括表面(镜面)和次表面(漫反射)，因此太高了。实际材料的值可能更低。例如，“OSHA黑色”涂料标准的联邦规范的Y值为0.35(满分100)。根据测量条件和表面光泽度，这个Y对应于ρss 值约0.0035(11在8位非线性sRGB编码)。</strong></p>
<p><strong>当获取点值或纹理ρss 从现实世界的表面，分离出镜面反射是很重要的。这种提取可以通过仔细使用受控的照明和偏振滤波器来完成。为了准确的颜色，还应该进行校准。</strong></p>
<p><strong>并不是每一个RGB三重都表示ρ值的合理(甚至物理上可能)值ss．反射光谱比发射光谱功率分布受到更多的限制:对于任何波长，反射光谱都不能超过1，而且它们通常非常光滑。这些限制在颜色空间中定义了包含ρ的所有可能的RGB值的体积ss．即使是相对较小的sRGB色域也包含在这个音量之外的颜色，所以在设置ρss 值时必须小心避免指定不自然的饱和和明亮的颜色。除了降低现实主义，这些颜色还会在预计算全局光照时造成过亮的二次反射(章节11.5.1)。孟等人2015年发表的论文对这一课题有很好的参考价值。</strong></p>
<h3 id="Scale-of-Subsurface-Scattering-and-Roughness-次表面散射与粗糙度的比例尺"><a href="#Scale-of-Subsurface-Scattering-and-Roughness-次表面散射与粗糙度的比例尺" class="headerlink" title="Scale of Subsurface Scattering and Roughness 次表面散射与粗糙度的比例尺"></a>Scale of Subsurface Scattering and Roughness 次表面散射与粗糙度的比例尺</h3><p><strong>一些局部次表面散射的BRDF模型考虑了表面粗糙度——通常是使用带有漫射微BRDF f的微面理论µ而有些则不然。使用哪种类型的模型的决定因素不仅仅是表面有多粗糙，尽管这是一个常见的误解。正确的决定因素与地表不规则的相对大小和次表面散射距离有关。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008130001.png" class="" title="image-20211008130001">

<p>三个表面具有相似的NDFs但有差异微几何尺寸与次表面散射距离的关系。在左上方，次表面散射距离小于地表不规则性。在右上方，散射距离大于表面的不规则性。底部图中显示了一个多尺度粗糙度的微表面。红色虚线表示仅包含大于次表面散射距离的微观结构的有效表面。</p>
<p><strong>参见上图。如果微几何形状的不规则性大于次表面散射距离(图左上方)，那么次表面散射将表现出与微几何相关的效应，如反反射。对于这样的表面，应该使用粗糙表面扩散模型。如上所述，此类模型通常基于微表面理论，将次表面散射视为每个微表面的局部，因此只影响微BRDF fµ．</strong></p>
<p><strong>如果散射距离都大于不规则距离(上图右上角)，那么为了模拟次表面散射，表面应该被认为是平坦的，这样就不会发生反反射等效果。次表面散射不是微表面局部的，并且不能通过微表面理论进行建模。在这种情况下，应该使用平滑表面扩散模型。</strong></p>
<p><strong>在中间情况下，表面的粗糙度在比散射距离更大或更小的尺度上，那么应该使用粗糙表面漫射模型，但有效表面只包括比散射距离更大的不规则。漫反射和镜面反射都可以用微表面理论建模，但每个都有不同的粗糙度值。镜面项将使用一个基于实际表面粗糙度的值，漫反射项将使用一个较低的值，基于有效表面的粗糙度。</strong></p>
<p><strong>观察的尺度也与此相关，因为它决定了“微几何学”的定义。“例如，月球经常被认为是一个应该使用粗糙表面漫反射模型的例子，因为它展示了显著的后反射。当我们从地球上看月球时，观察的尺度是如此之大，甚至一块5英尺高的石头都是“微观几何”。“因此，我们观察到粗糙表面的漫反射效果就不足为奇了。</strong></p>
<h3 id="Smooth-Surface-Subsurface-Models-光滑表面次表面模型"><a href="#Smooth-Surface-Subsurface-Models-光滑表面次表面模型" class="headerlink" title="Smooth-Surface Subsurface Models 光滑表面次表面模型"></a>Smooth-Surface Subsurface Models 光滑表面次表面模型</h3><p><strong>这里我们将讨论光滑表面的次表面模型。这些适用于建模材料的表面不规则小于次表面散射距离。漫反射阴影不直接影响表面粗糙度这样的材料。如果漫反射和镜面条件是耦合的，这是本节中的一些模型的情况，那么表面粗糙度可能会间接影响漫反射阴影。</strong></p>
<p><strong>如第9.3节所述，实时渲染应用程序经常使用朗伯项来模拟局部次表面散射。在这种情况下，BRDF扩散项是ρss 在π:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008131205.png" class="" title="image-20211008131205">

<p><strong>兰伯特模型没有解释在表面反射的光不能用于次表面散射的事实。为了改进这个模型，在表面(镜面)和次表面(漫反射)反射项之间应该有一个能量平衡。菲涅耳效应表明，这种表面-地下能量平衡随入射光角θi的变化而变化．随着掠入射角度的增加，漫反射随着镜面反射的增加而减小。计算这种平衡的一个基本方法是将漫反射项乘以1减去镜面项的菲涅耳部分。如果镜面术语是平面镜的术语，则产生的漫反射项是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008131250.png" class="" title="image-20211008131250">

<p><strong>如果镜面项是微表面 BRDF项，那么最终的漫反射项为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008131300.png" class="" title="image-20211008131300">

<p><strong>上面两个公式导致出射光均匀分布，因为BRDF值不依赖于出射方向v。这个行为有一定的意义，因为光在重新发射之前通常会经历多次散射事件，所以它的出射方向将是随机的。然而，有两个理由怀疑出射光的分布不完全均匀。首先，由于上上式中的扩散BRDF项随入射方向而变化，亥姆霍兹互易性意味着它也必然随出射方向而变化。其次，光线在出射时必须经历折射，这将对出射的光线施加某种方向偏好。</strong></p>
<p><strong>Shirley等人对平面提出了耦合漫反射项，解决了菲涅耳效应和表面-地下反射权衡，同时支持能量守恒和亥姆霍兹互易。推导中假设菲涅耳反射率采用Schlick近似:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008131411.png" class="" title="image-20211008131411">

<p><strong>上式仅适用于镜面反射为完美菲涅尔镜面的表面。提出了一种广义的计算方法，该方法可用于计算与任意镜面项耦合的互反的、能量守恒的漫反射项Ashikhmin和Shirley，并由Kelemen和Szirmay-Kalos进一步细化:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008131441.png" class="" title="image-20211008131441">

<p><strong>在这里,Rspec 是镜面项的方向反照率(第9.3节)和Rspec 是它是半球上的余弦加权平均值。R值spec 可以预计算并存储在查找表中。平均Rspec 的计算方法与我们前面遇到的类似平均值相同:RsF1 方程。</strong></p>
<p><strong>上式中的形式与之前式子有一些明显的相似之处，这并不奇怪，因为Imageworks的多次反射反射项是从Kelemen-Szirmay-Kalos耦合漫反射项派生出来的。然而，有一个重要的区别。这里，不是RsF1 我们用Rspec，包括菲涅耳的全镜面BRDF项的方向反照率，以及与多次反射的镜面项f的方向反照率ms 同样，如果使用的话。这种差异增加了Rspec 的查找表的维数因为它不仅与粗糙度α和仰角θ有关，还与菲涅耳反射率有关。</strong></p>
<p><strong>在Imageworks对Kelemen-Szirmay-Kalos耦合漫反射项的实现中，他们使用了一个以折射率为第三轴的三维查找表。他们发现，在积分中包含多次弹跳项使Rspec 比RsF1 平滑，所以一个16×16×16表格就足够了。结果如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008131658.png" class="" title="image-20211008131658">

<p>第一行和第三行显示添加到朗伯项的镜面项。第二和第四行显示了与Kelemen-Szirmay-Kalos耦合漫反射项相同的镜面术语。上面两行的粗糙度值比下面两行低。在每一行中，粗糙度从左到右递增。(图由Christopher Kulla提供。)</p>
<p><strong>如果BRDF使用Schlick Fresnel近似且不包含多次反射反射项，则F0 的值可以被提出来。这样做允许我们对Rspec使用一个二维表，每个条目存储两个量，而不是Karis所讨论的三维表格。另外，Lazarov提出了一个拟合Rspec的解析函数，同理分解F0 来简化拟合函数。</strong></p>
<p><strong>Karis和Lazarov都使用了镜面定向反照率Rspec 用于不同的目的，与基于图像的照明有关。关于该技术的更多细节可以在第10.5.2节中找到。如果在同一个应用程序中实现了这两种技术，那么可以对这两种应用程序使用相同的表查找，从而提高效率。</strong></p>
<p><strong>这些模型是通过考虑表面(镜面)和次表面(漫反射)之间的能量守恒而建立的。其他模型是从物理原理发展而来的。这些模型中的许多都依赖于Subrahmanyan Chandrasekhar(1910-1995)的工作，他开发了一个半无限、各向同性散射体积的BRDF模型。Kulla和Conty证明，如果平均自由路径足够短，该BRDF模型是任意形状散射体积的完美匹配。Chandrasekhar BRDF可以在他的书中找到，不过Dupuy等人的一篇论文的方程30和31中可以找到使用熟悉的渲染符号的更容易理解的形式。</strong></p>
<p><strong>由于它不包括折射，钱德拉塞卡BRDF只能用来建模折射率匹配的表面。这些是折射率的表面两侧相同。为了模拟非折射率匹配表面，必须对BRDF进行修改，以考虑光线进入和离开表面时的折射。这种修改是 Hanrahan ， Krueger 和 Wolf的工作重点。</strong></p>
<h3 id="Rough-Surface-Subsurface-Models-粗糙次表面模型"><a href="#Rough-Surface-Subsurface-Models-粗糙次表面模型" class="headerlink" title="Rough-Surface Subsurface Models 粗糙次表面模型"></a>Rough-Surface Subsurface Models 粗糙次表面模型</h3><p><strong>作为迪士尼原则着色模型的一部分，Burley包含了一个漫反射BRDF术语，该术语旨在包括粗糙度效应和匹配测量材料:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008132323.png" class="" title="image-20211008132323">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008132335.png" class="" title="image-20211008132335">

<p><strong>α是镜面粗糙度。在各向异性的情况下，αx 和αy 之间的中间值使用。这个方程通常被称为迪士尼扩散模型。</strong></p>
<p><strong>下面的项fss 是受到Hanrahan-Krueger BRDF的启发，目的是作为一种廉价的替代对遥远物体的全球地下散射。扩散模型混合在fss 和fd 基于用户控制参数kss的粗糙扩散项．</strong></p>
<p><strong>迪士尼漫反射模型已被用于电影，以及游戏(尽管没有次表面术语)。完整的迪士尼漫反射BRDF还包括一个光泽的术语，这主要是为了建模面料，但也有助于弥补由于缺乏多重反弹镜面术语的能量损失。迪士尼的光泽术语将在第9.10节中讨论。几年后，Burley提出了一个更新的模型，旨在集成全球地下散射渲染技术。</strong></p>
<p><strong>由于迪士尼漫反射模型使用相同的粗糙度作为高光BRDF术语，它可能有建模某些材料的困难。参见上上图。然而，使用一个单独的漫射粗糙度值将是一个微不足道的修改。</strong></p>
<p><strong>大多数其他粗糙表面漫射BRDFs是利用微表面理论开发的，NDF D、micro-BRDF fµ有各种不同的选择，遮罩-阴影函数G2．这些模型中最著名的是Oren和Nayar提出的。Oren-Nayar BRDF使用了朗伯微BRDF、球面高斯NDF和托伦斯-斯派洛“v腔”遮蔽函数。完整形式的BRDF模型一次二次反弹。Oren和Nayar还在他们的论文中加入了一个简化的“定性”模型。多年来，人们提出了对Oren-Nayar模型的一些改进，包括优化、在不增加成本的情况下使“定性”模型更接近完整模型的调整，以及将微BRDF改为更精确的光滑表面漫反射模型。</strong></p>
<p><strong>Oren-Nayar模型假设了一个微表面，其正态分布和遮蔽函数与当前的镜面模型有很大的不同。利用各向同性GGX NDF和高度-导出了两种扩散微面模型相关的Smith遮蔽函数。第一个模型由Gotanda提出，是对通用微表面方程进行数值积分的结果，使用之前式子中的镜面耦合漫反射项作为微BRDF。然后对数值积分数据拟合一个解析函数。goanda的BRDF没有考虑面之间的相互反射，拟合函数也相对复杂。</strong></p>
<p><strong>Hammon使用与Gotanda相同的NDF、遮罩-遮蔽函数和微BRDF数值模拟BRDF，包括相互反射。他指出，相互反射对于这种微表面结构是很重要的，它代表了粗糙表面总反射率的一半。然而，第二次反弹几乎包含了所有缺失的能量，因此Hammon使用了两次反弹模拟的数据。此外，可能是因为添加了相互反射使数据变得平滑，Hammon能够将一个相当简单的函数拟合到模拟结果中:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008133037.png" class="" title="image-20211008133037">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008133047.png" class="" title="image-20211008133047">

<p><strong>和αg 为GGX镜面粗糙度。为了清晰起见，这里的术语与哈蒙的陈述略有不同。请注意,fsmooth 从9.64方程中得到的耦合扩散BRDF是否没有ρss/π因子，因为它在9.68式中被乘了。Hammon讨论了用其他光滑表面漫反射BRDFs代替f的“混合”BRDFssmooth，以提高性能或改进与在旧模型下创建的资产的兼容性。</strong></p>
<p><strong>总的来说，Hammon的弥漫性BRDF是廉价的，基于可靠的理论原理，尽管他没有展示与测量数据的比较。需要注意的是，表面不规则性大于散射距离的假设是推导BRDF的基础，这可能限制了它可以精确模拟的材料类型。参见上上图。</strong></p>
<p><strong>9.61式中所示的简单朗伯项仍然被许多实时渲染应用程序所实现。除了lambert术语的低计算成本外，它比其他漫射模型更容易使用间接和烘烤光照，而且它与更复杂的模型之间的视觉差异往往是微妙的。然而，对照片写实主义的持续追求正推动更精确模型的使用增加。</strong></p>
<h2 id="BRDF-Models-for-Cloth-布料的BRDF模型"><a href="#BRDF-Models-for-Cloth-布料的BRDF模型" class="headerlink" title="BRDF Models for Cloth 布料的BRDF模型"></a>BRDF Models for Cloth 布料的BRDF模型</h2><p><strong>布料往往具有不同于其他类型材料的微观几何形状。根据织物类型的不同，它可能具有高度重复的编织微结构，圆柱体(线)垂直地从表面突出，或两者兼有。因此,布料表面有表象特征,通常需要专门的阴影模型,如各向异性高光、粗糙面散射(明亮的边缘效应引起的光散射通过突出,半透明的纤维),甚至颜色变化与视图方向(由线程运行的不同的颜色通过织物)。</strong></p>
<p><strong>除了BRDF，大多数面料都有高频空间变化，这也是创造令人信服的布料外观的关键]。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008133345.png" class="" title="image-20211008133345">

<p>使用《神秘海域4》中布料系统的材料。左上方的球体有一个标准w表面镜面和lambert漫反射。中上方球体采用BRDF面料。每一个其他的球体都增加了不同类型的逐像素变化，从左到右，从上到下:织物编织细节、织物老化、不完美细节和小褶皱。(UNCHARTED 4 A Thief ’s End  c / TM 2016 SIE. Created &amp; developed by Naughty Dog LLC。)</p>
<p><strong>布BRDF模型主要分为三类:通过观察建立的经验模型、基于微表面理论的模型和微柱体模型。我们将从每个类别中举出一些值得注意的例子。</strong></p>
<h3 id="Empirical-Cloth-Models-经验布料模型"><a href="#Empirical-Cloth-Models-经验布料模型" class="headerlink" title="Empirical Cloth Models 经验布料模型"></a>Empirical Cloth Models 经验布料模型</h3><p><strong>在游戏《神秘海域2》中，布料表面使用以下漫反射BRDF术语:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008135045.png" class="" title="image-20211008135045">

<p><strong>krim，kinner和kdiff 分别是用户控制的边缘照明术语、照亮前向(内)表面术语和朗伯术语的比例因子。此外,αrim 和αinner 控制边缘和内部条款的脱落。这种行为是非物理的，因为有几个依赖于视图的效果，但没有一个依赖于光的方向。</strong><br><strong>相比之下，《神秘海域4》中的布料使用了微表面或微圆柱体模型，这取决于布料的类型(如下两部分详细说明)，而“包裹照明”的经验次表面散射近似是漫反射的术语:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008135201.png" class="" title="image-20211008135201">

<p><strong>这里我们使用1.2节中介绍的(x)+ˉ符号，它表示0和1之间的夹紧。奇符号fdiff (l, v)(n·l)+根…表明该模型影响照明以及BRDF。箭头右边的项代替了左边的项。用户指定的参数cscatter 是一种散射颜色，值w，范围[0,1]，控制环绕照明宽度。</strong></p>
<p><strong>对于模型布，迪士尼使用了漫反射BRDF术语(第9.9.4节)，并在模型粗糙散射中添加了光泽术语:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008135338.png" class="" title="image-20211008135338">

<p><strong>其中ksheen是一个用户参数，用于调制亮度项的强度。光泽色csheen 是白色和ρss的亮度归一化值之间的混合(由另一个用户参数控制)．换句话说，ρss 用亮度来区分色调和饱和度。</strong></p>
<h3 id="Microfacet-Cloth-Models-微表面布料模型"><a href="#Microfacet-Cloth-Models-微表面布料模型" class="headerlink" title="Microfacet Cloth Models 微表面布料模型"></a>Microfacet Cloth Models 微表面布料模型</h3><p><strong>Ashikhmin等人提出使用反高斯NDF来模拟天鹅绒。该NDF在后续工作中略有修改，该工作还提出了用于一般材料建模的微表面 BRDF的变体形式，没有遮罩-阴影项，分母也经过修改。</strong></p>
<p><strong>在游戏The Order: 1886中使用的布料BRDF结合了改进的微表面 BRDF和Ashikhmin和Premoˇze后来的报告中使用的天鹅绒NDF的一般形式，以及之前公式中的扩散术语。广义天鹅绒NDF是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008155945.png" class="" title="image-20211008155945">

<p><strong>其中α控制反高斯函数的宽度和kamp 控制它的振幅。全布料BRDF是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008160028.png" class="" title="image-20211008160028">

<p><strong>在《神秘海域4》使用了这种BRDF的变体，用于制作毛料和棉花等粗糙织物。</strong></p>
<p><strong>Imageworks使用不同的倒NDF来表示光泽，可以添加到任何BRDF中:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008160055.png" class="" title="image-20211008160055">

<p><strong>虽然这个NDF没有Smith遮蔽函数的封闭解，但Imageworks可以用解析函数逼近数值解。Estevez和Kulla详细讨论了遮蔽函数和光泽项与BRDF其余部分之间的能量守恒。一些使用Imageworks光泽术语渲染的例子见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008160131.png" class="" title="image-20211008160131">

<p>Imageworks的光泽镜面术语添加到红色漫反射术语。从左到右依次为α = 0.15、0.25、0.40、0.65和1.0。(图由Alex Conty提供)</p>
<p><strong>到目前为止，我们看到的每一种布料模型都仅限于特定类型的布料。下一节讨论的模型试图以一种更普遍的方式来建模布料。</strong></p>
<h3 id="Micro-Cylinder-Cloth-Models-微圆柱布料模型"><a href="#Micro-Cylinder-Cloth-Models-微圆柱布料模型" class="headerlink" title="Micro-Cylinder Cloth Models 微圆柱布料模型"></a>Micro-Cylinder Cloth Models 微圆柱布料模型</h3><p><strong>用于布料的微圆柱模型与用于头发的模型非常相似，因此第14.7.2节中关于头发模型的讨论可以提供额外的背景。这个想法在这些模型的背后是假定表面被一维线覆盖。Kajiya和Kay针对该案例开发了一个简单的BRDF模型，Banks为该模型提供了坚实的理论基础。它也被称为Kajiya-Kay BRDF或Banks BRDF。这个概念是基于这样一种观察:一个由一维线组成的曲面在任何给定位置都有无限条法线，这条法线是由垂直于该位置切向量t的法平面定义的。尽管许多更新的微圆筒模型已经从这个框架发展出来，但由于其简单性，原来的Kajiya-Kay模型仍然有一些用途。例如，在《神秘海域4》中，Kajiya-Kay BRDF被用来指代闪亮的织物，如丝绸和天鹅绒。</strong></p>
<p><strong>梦工厂使用一个相对简单的、艺术家可以控制的微圆筒模型来制作织物。纹理可以用来改变粗糙度、颜色和线的方向，这些可以指向表面平面，用于建模天鹅绒和类似的织物。经纬线可设定不同的参数，以模拟复杂的变色面料，如散弹丝。模型被归一化为节能的。</strong></p>
<p><strong>Sadeghi等人提出了一种基于织物样品和单个丝线测量的微圆筒模型。该模型还考虑了线间遮罩和线间阴影。</strong></p>
<p><strong>在某些情况下，实际的头发BSDF模型(第14.7节)用于布料。Render- Man的PxrSurface材质有一个“fuzz”叶，使用Marschner等人的毛发模型中的R术语(第14.7节)。Wu和Yuksel在实时布料渲染系统中实现的模型之一是源自迪士尼动画电影中使用的头发模型。</strong></p>
<h2 id="Wave-Optics-BRDF-Models-波动光学BRDF模型"><a href="#Wave-Optics-BRDF-Models-波动光学BRDF模型" class="headerlink" title="Wave Optics BRDF Models 波动光学BRDF模型"></a>Wave Optics BRDF Models 波动光学BRDF模型</h2><p><strong>我们在前几节中讨论的模型依赖于几何光学，即光以射线而不是波的形式传播。正如在之前所讨论的，几何光学是基于这样的假设:任何表面的不规则性不是小于一个波长就是大于大约100个波长。</strong></p>
<p><strong>现实世界的表面就没那么亲切了。它们在所有尺度上都有不规则性，包括1-100波长范围。我们提到纳米几何尺寸的不规则性，以区别于前面讨论的微几何不规则性，微几何不规则性太小，无法单独渲染，但大于100个波长。纳米几何对反射率的影响不能用几何光学来模拟。这些效应取决于光的波动性质，需要波动光学(也称为物理光学)来模拟它们。</strong></p>
<p><strong>厚度接近光波的表层或薄膜也会产生与光波性质有关的光学现象。</strong></p>
<p><strong>在本节中，我们将讨论波动光学现象，如衍射和薄膜干涉，讨论它们(有时令人惊讶)在真实渲染这些看似相对平凡的材料中的重要性。</strong></p>
<h3 id="Diffraction-Models-衍射模型"><a href="#Diffraction-Models-衍射模型" class="headerlink" title="Diffraction Models 衍射模型"></a>Diffraction Models 衍射模型</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008234403.png" class="" title="image-20211008234403">

<p>在左边，我们看到一个平面波阵面在真空中传播。如果波前上的每个点都被当作一个新的球面波的源，新波在除正向外的所有方向都发生破坏性的干涉，再次产生一个平面波前。在中心，波浪遇到了障碍。在障碍物边缘的球形波，其右侧没有对其产生破坏性干扰的波，所以有些波会绕射或“泄漏”到障碍物边缘。在右边，一个平面波阵面从一个平面反射回来。平面波前与左侧面点的接触时间比右侧面点的接触时间早，因此从左侧面点发射的球面波有更多的时间传播，因此球面波更大。不同尺寸的球面波阵面沿反射平面波阵面边缘产生建设性干涉，在其他方向产生破坏性干涉。</p>
<p><strong>纳米几何会引起一种叫做衍射的现象。为了解释它，我们使用惠更斯-菲涅耳原理，该原理指出，波前(具有相同波相的点的集合)上的每一点都可以被视为一个新的球面波的源。参见上图。当波遇到障碍物时，惠更斯-菲涅耳原理表明，它们会在转角轻微弯曲，这是衍射的一个例子。这种现象是几何光学所不能预测的。在光入射到一个平面上的情况下，几何光学确实正确地预测光将在一个方向上反射。也就是说，菲涅尔-惠更斯原理提供了额外的见解。它表明表面的球面波刚好排成一条直线，形成反射波阵面，而其他方向的波则通过破坏性干扰被消除。当我们观察纳米不规则的表面时，这种洞察力变得非常重要。由于表面点的高度不同，表面上的球面波不再整齐排列。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008234744.png" class="" title="image-20211008234744">

<p>在左边，我们看到平面波面入射到一个粗糙的纳米几何表面。在中心，我们看到根据菲涅耳-惠更斯原理在表面形成的球波。在右边我们看到，在发生了相干和相干干涉之后，一些产生的波(红色部分)形成了一个平面反射波。剩下的部分(紫色部分)是衍射的，每个方向的光传播量不同，这取决于波长。</p>
<p><strong>如图所示，光线分散在不同的方向。它的一部分是镜面反射的，即在反射方向上叠加成一个平面波前。剩余的光以一种依赖于纳米几何特性的定向模式衍射出去。镜面反射光和衍射光之间的划分取决于纳米几何凸起的高度，或者更准确地说，取决于高度分布的方差。衍射光在周围的角扩散镜面反射的方向取决于相对于光波长的纳米几何凸起的宽度。与直觉相悖的是，更广泛的违规行为会导致更小的价差。如果不均匀度大于100个波长，则衍射光和镜面反射光之间的角度很小，可以忽略不计。尺寸减小的不规则性会导致衍射光扩散得更广，直到不规则性变得小于光的波长，在这一点上就不会发生衍射。</strong></p>
<p><strong>在具有周期性纳米几何结构的表面上，衍射是最清晰可见的，因为重复的图案通过构造干涉加强了衍射光，造成了彩色的彩虹色。这种现象可以在CD和DVD光盘和某些昆虫中观察到。虽然衍射也发生在非周期表面，但计算机图形界多年来一直认为这种影响是轻微的。因此，除了少数例外，计算机图形学文献多年来大多忽略了衍射。</strong></p>
<p><strong>然而，Holzschuch和Pacanow- ski最近对实测材料的分析表明，许多材料中都存在显著的衍射效应，这可能解释了用现有模型拟合这些材料的持续困难。同一作者的后续工作介绍了一个结合微表面和衍射理论的模型，通过使用通用微表面 BRDF和一个可以解释衍射的微BRDF。与此同时，Toisoul和Ghosh提出了捕捉周期性纳米几何产生的彩虹衍射效应的方法，并使用点光源和基于图像的照明实时渲染它们。</strong></p>
<h3 id="Models-for-Thin-Film-Interference-薄膜干涉模型"><a href="#Models-for-Thin-Film-Interference-薄膜干涉模型" class="headerlink" title="Models for Thin-Film Interference 薄膜干涉模型"></a>Models for Thin-Film Interference 薄膜干涉模型</h3><p><strong>薄膜干涉是一种波光学现象，当光路径从薄介质层的顶部和底部反射时发生相互干涉。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211009000217.png" class="" title="image-20211009000217">

<p>入射到反射衬底上的薄膜上的光。除了主反射外，还有多种路径的光折射，从衬底反射，或者从顶部薄膜表面的内部反射，或者通过它折射。这些路径都是同一波的副本，但由于路径长度的不同，相位延迟较短，因此它们相互干涉。</p>
<p><strong>不同波长的光要么是建设性的干涉，要么是破坏性的干涉，这取决于波长和路径长度差之间的关系。</strong></p>
<p><strong>由于路径长度的差异随着角度的变化而变化，最终的结果是虹彩颜色的漂移，因为不同的波长在建设性和破坏性干涉之间的过渡。</strong></p>
<p><strong>薄膜需要很薄才能产生这种效应的原因与相干长度的概念有关。这个长度是光波的一个拷贝被移动并且仍然与原波相干的最大距离。这个长度与光的带宽成反比，带宽是光谱功率分布(SPD)延伸的波长范围。激光由于其极窄的带宽而具有极长的相干长度。根据激光的类型，可以达到数英里。这种关系是有意义的，因为一个简单的正弦波被许多波长所取代，仍然会与原始波相干地干涉。如果激光器真的是单色的，那么它的相干长度将是无限的，但实际上激光器的带宽是非零的。相反，极宽带宽的光会产生混沌波形。这种波形的一个副本只需要移动一小段距离，就会停止与原始波形的相干干扰，这是有道理的。</strong></p>
<p><strong>理论上，混合了所有波长的理想白光的相干长度为零。然而，对于可见光光学而言，人类视觉系统(仅在400-700 nm范围内感知光)的带宽决定了相干长度，约为1微米。因此，在大多数情况下，问题的答案是“一层薄膜能有多厚才能不再引起可见干扰?”是“大约1微米。”</strong></p>
<p><strong>与衍射相似，多年来，薄膜干涉被认为是一种特殊情况下的效应，只发生在表面，如肥皂泡和油渍。然而Akin指出，薄膜干涉确实会带来微妙的色彩对许多日常表面，并展示了如何建模这种效果可以增加现实主义。参见下图。他的文章使人们对基于物理的薄膜干涉的兴趣大大增加，各种着色模型包括Render- Man的PxrSurface和Imageworks着色模型都支持这种效果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211009000324.png" class="" title="image-20211009000324">

<p>一种没有(左边)薄膜干涉和(右边)薄膜干涉的皮革材料。由薄膜干涉引起的镜面着色增加了图像的真实感。(图片来源:阿提拉·阿金，Next Limit Technologies )</p>
<p><strong>适用于实时绘制的薄膜干涉技术已经存在一段时间了。Smits和Meyer提出了一种有效的方法来解释一阶光路和二阶光路之间的薄膜干涉。他们观察到产生的颜色主要是路径长度差的函数，路径长度差可以从薄膜厚度、视角和折射率有效地计算出来。它们的实现需要一个带有RGB颜色的一维查找表。表格的内容可以使用密集光谱采样和转换成RGB颜色作为预处理，这使得技术相当快。在《使命召唤:无限战争》(Call of Duty: Infinite Warfare)这款游戏中，使用了一种不同的快速薄膜近似材料作为分层材料系统的一部分。这些技术不能模拟薄膜中光线的多次反射，也不能模拟其他物理现象。Belcour和Barla提出了一种更精确、计算成本更高、但仍以实时实现为目标的技术。</strong></p>
<h2 id="Layered-Materials-分层材质"><a href="#Layered-Materials-分层材质" class="headerlink" title="Layered Materials 分层材质"></a>Layered Materials 分层材质</h2><p><strong>在现实生活中，材料通常是层叠在一起的。表面可能被灰尘、水、冰或雪覆盖;它可以用漆或其他涂层来粉刷出于装饰或保护的原因;或者它可能有多层作为其基本结构的一部分，如许多生物材料。</strong></p>
<p><strong>一种最简单和最具视觉意义的分层情况是一层透明涂层，这是一层光滑的透明层覆盖在一些不同的材料的基板上。例如在粗糙的木材表面上涂一层光滑的清漆。迪士尼原则性的着色模型包括一个透明涂层术语，就像Unreal Engine，RenderMan的PxrSurface材质，以及梦工厂动画和Imageworks使用的着色模型等。</strong></p>
<p><strong>透明涂层最显著的视觉效果是光从透明涂层和底层基底反射而产生的双重反射。当衬底是金属时，第二次反射最为显著，从那时起，介质透明涂层的折射率与衬底之间的差异最大。当衬底是电介质时，其折射率接近于透明涂层的折射率，导致第二次反射相对较弱。这种效果类似于水下材料。</strong></p>
<p><strong>透明层也可以着色。从物理学的观点来看，这种着色是吸收的结果。根据比尔-朗伯定律(第14.1.2节)，光的吸收量取决于光穿过透明层的路径长度。这个路径长度取决于视角和光线的角度，以及材料的折射率。更简单的透明层实现，例如那些在迪士尼原则模型和虚幻引擎中，不建模这种视图依赖。其他的可以，比如PxrSurface的实现，Imageworks和Dreamworks的着色模型。Imageworks模型还允许连接任意数量的不同类型的层。</strong></p>
<p><strong>在一般情况下，不同的层可能有不同的表面法线。一些例子包括流过平坦路面的小溪，崎岖不平的土壤上的光滑的冰层，或者覆盖纸板箱的皱巴巴的塑料膜。电影行业使用的大多数分层模型都支持每层分离法线。这种做法在实时应用程序中并不常见，尽管虚幻引擎的透明实现支持它作为一个可选特性。</strong></p>
<p><strong>Weidlich和Wilkie提出了一个分层的微表面模型，假设层的厚度与微表面的尺寸相比很小。他们的模型支持任意数量的层，并跟踪反射和折射事件，从顶层到底层再回到顶层。它非常简单，可以实时实现，但没有考虑到层之间的多次反射。Jakob等人提出了一种全面而精确的模拟层状材料(包括多次反射)的框架。虽然不适合实时实现，但该系统对地面真实比较是有用的，所使用的思想可能为未来的实时技术提供建议。</strong></p>
<p><strong>《使命召唤:无限战争》(Call of Duty: Infinite Warfare)使用的分层材质系统尤其引人注目。它允许用户合成任意数量的材料层。它支持折射、散射和基于路径长度的吸收层，以及不同的表面法线每层。结合高效的实现，该系统能够实现前所未有的实时材料的复杂性，特别是对一个运行在60hz的游戏印象深刻。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211009000655.png" class="" title="image-20211009000655">

<p>测试表面显示各种功能的使命召唤:无限战争多层材料系统。这种材料模拟了一个具有扭曲和散射的几何复杂表面，尽管每个边仅由两个三角形构成。(图片由动视出版公司提供，2018年)</p>
<h2 id="Blending-and-Filtering-Materials-混合和过滤材质"><a href="#Blending-and-Filtering-Materials-混合和过滤材质" class="headerlink" title="Blending and Filtering Materials 混合和过滤材质"></a>Blending and Filtering Materials 混合和过滤材质</h2><p><strong>材质混合是将各属性结合起来的过程，即BRDF参数，适用于多种材料。例如，要建模带有锈斑的金属板，我们可以绘制一个蒙版纹理来控制锈斑的位置，并使用它来混合材料属性(镜面颜色F0，扩散色ρss锈蚀和金属的粗糙度α)。每个被混合的材料也可以在空间上变化，参数存储在纹理中。混合可以作为创建新纹理的预处理，通常称为“烘培”，或在着色器中飞行。虽然表面法线n在技术上不是BRDF参数，但它的空间变化对外观很重要，所以材质混合通常也包括法线贴图混合。</strong></p>
<p><strong>材料混合是许多实时渲染应用的关键。例如，游戏the Order: 1886就有一个复杂的材质混合系统它允许用户从广泛的库中提取材质，并由各种空间掩模控制，任意深度的堆栈。大多数材料混合是作为离线预处理完成的，但某些合成操作可以根据需要推迟到运行时。这种运行时处理通常用于环境，为平铺纹理添加独特的变化。流行的材质创作工具Substance Painter和Substance Designer使用类似的方法进行材质合成，Mari纹理绘画工具也是如此。</strong></p>
<p><strong>混合纹理元素在飞行中提供了一套不同的效果，同时保存记忆。游戏基于各种目的使用材质混合，例如:</strong></p>
<pre><code>**•显示建筑物，车辆和活着的(或不死的)生物的动态伤害。** 

**•允许用户自定义游戏内装备和服装。**

**•增加字符和环境的视觉多样性。**
</code></pre>
<p><strong>有时一个材质混合在另一个材质上，不透明度小于100%，但即使是完全不透明的混合也会有像素(或像素，如果烘焙成纹理)在蒙版边界上，部分混合需要执行。在这两种情况下，严格正确的方法是评估每个材质的着色模型并混合结果。然而，混合BRDF参数，然后评估一次着色要快得多。在材料属性的情况下，有一个线性或接近线性的关系，以最终的着色颜色，如漫反射和镜面颜色参数，很少或没有错误引入这种插值。在许多情况下，即使参数与最终着色的高度非线性关系(如镜面粗糙度)，沿蒙版边界引入的误差是不令人反感的。</strong></p>
<p><strong>混合法线贴图需要特别的考虑。通常，把这个过程看作是高程图之间的混合，法线图就是从高程图中推导出来的，可以得到好的结果。在某些情况下，例如在基础表面上覆盖一个细节法线贴图时，其他形式的混合是可取的。</strong></p>
<p><strong>材质过滤是一个与材质混合密切相关的话题。材质属性通常存储在纹理中，通过GPU双线性滤波和mipmapping等机制进行过滤。然而，这些机制是基于被过滤的数量(这是着色方程的输入)与最终颜色(着色方程的输出)有线性关系的假设。线性同样适用于某些量，但不是一般的量。在法线贴图或包含非线性BRDF参数(如粗糙度)的纹理上使用线性mipmapping方法可以产生伪影。这些伪影可以表现为高光走样(闪烁的高光)，或者是表面光泽度或亮度的意外变化，因为表面距离相机的变化。在这两者中，镜面走样要明显得多;缓解这些伪影的技术通常被称为镜面抗锯齿技术。现在我们将讨论其中的几种方法。</strong></p>
<h3 id="Filtering-Normals-and-Normal-Distributions-正态分布和正态滤波"><a href="#Filtering-Normals-and-Normal-Distributions-正态分布和正态滤波" class="headerlink" title="Filtering Normals and Normal Distributions 正态分布和正态滤波"></a>Filtering Normals and Normal Distributions 正态分布和正态滤波</h3><p><strong>大部分材料过滤伪影(主要来自镜面走样)，以及它们最常用的解决方案，都与正态和正态分布函数的过滤有关。由于它的重要性，我们将在这方面进行一些深入的讨论。</strong></p>
<p><strong>为了理解这些伪影产生的原因以及如何解决它们，请回忆NDF是亚像素表面结构的统计描述。当相机和表面之间的距离增加时，之前覆盖多个像素的表面结构可能会减少到亚像素大小，从凹凸贴图的领域移动到NDF的领域。这种转换与mipmap链密切相关，它将纹理细节缩减到亚像素大小。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010113418.png" class="" title="image-20211010113418">

<p>在左边，圆柱体是用原始法线贴图渲染的。在中间，使用了一个低分辨率的法线贴图，它包含了平均和重正化的法线，如下图左下角所示。在右边，圆柱体用同样低分辨率的纹理进行渲染，但包含符合理想NDF的正常和光泽值，如下图右下角所示。右边的图像明显更好地呈现了原始的外观。在低分辨率渲染时，这个表面也不容易出现走样。(图片由工业光魔的帕特里克·康兰提供。)</p>
<p><strong>考虑一个对象的外观，例如上图左边的圆柱体，是如何建模的。外观建模总是假定一定的观察规模。大尺度(大尺度)几何模型为三角形，中尺度(中尺度)几何模型为纹理，小于单个像素的微尺度几何模型通过BRDF进行建模。</strong></p>
<p><strong>根据图中所示的比例，将圆柱体建模为光滑网格(宏观尺度)，并用法线贴图(中尺度)表示凸起。具有固定粗糙度αb 的Beckmann NDF来模拟微尺度正态分布。这种组合表示法在这个比例下很好地模拟了圆柱体的外观。但是，当观察范围发生变化时，会发生什么呢?</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010113621.png" class="" title="image-20211010113621">

<p>部分表面从上图。最上面的一行显示了正态分布(红色显示的是平均正态分布)和隐含的微观几何形状。下面一行显示了将四个ndf平均为一个的三种方法，就像在mipmapping中所做的那样。左边是地面真实值(平均正态分布)，中心分别显示平均(正态分布)和方差(粗糙度)的结果，右边显示一个拟合平均NDF的NDF瓣。</p>
<p><strong>上图研究。顶部的黑框图形显示了表面的一小部分，被四个法线贴图texel覆盖。假设我们以一个比例渲染表面，这样每个法线贴图texel平均被一个像素覆盖。为每个texel，正态(即分布的平均值)用红色箭头表示，被Beckmann NDF(用黑色表示)包围。法线和NDF隐式指定了一个底层表面结构，如横断面所示。中间的大隆起是法线图上的隆起之一，而小的摆动则是微尺度的表面结构。法线贴图中的每一个texel，结合粗糙度，可以被看作是在纹理覆盖的表面上收集法线的分布。</strong></p>
<p><strong>现在假设相机离物体更远了，所以一个像素覆盖了所有四个法线贴图像素。在这个分辨率下，理想的表面表示应该准确地表示在每个像素所覆盖的更大的表面积上收集到的所有法线的分布。这种分布可以通过在顶级mipmap的四个像素中平均ndf来找到。左下角的图显示了理想的正态分布。这个结果，如果用于渲染，将最准确地代表表面的外观在这个较低的分辨率。底部中心图显示了分别平均正态分布、每个分布的平均值和粗糙度的结果，粗糙度对应于每个分布的宽度。结果有正确的平均正态(红色)，但分布太窄。这个错误会导致表面看起来太光滑。更糟糕的是，由于NDF很窄，它会以闪烁的高光的形式造成走样。</strong></p>
<p><strong>我们不能直接用 Beckmann NDF来表示理想的正态分布。然而，如果我们使用粗糙度图，贝克曼粗糙度αb 可以从像素到像素不等。想象一下，对于每个理想NDF，我们找到与它最匹配的定向Beckmann波瓣，无论是在方向上还是总体宽度上。我们将该Beckmann波瓣的中心方向存储在法线图中，将其粗糙度值存储在粗糙度图中。结果显示在右下角。这个NDF更接近于理想。如上上图所示，用这种方法比用简单的正常平均法更能真实地表示圆柱体的外观。</strong></p>
<p><strong>为了获得最好的结果，像mipmapping这样的过滤操作应该应用于正态分布，而不是正态或粗糙度值。这样做意味着考虑ndf和常规之间关系的方法略有不同。通常NDF是在由法线贴图的每像素法线决定的局部切线空间中定义的。然而，当在不同法线上过滤NDF时，更有用的是将法线贴图和粗糙度贴图的组合看作是在潜在几何表面的切线空间中定义一个倾斜的NDF(一个没有平均到垂直向上的法线的NDF)。</strong></p>
<p><strong>早期解决NDF滤波问题的尝试使用数值优化来将一个或多个NDF叶瓣拟合到平均分布。这种方法存在健壮性和速度方面的问题，目前还不怎么使用。相反，目前使用的大多数技术都是通过计算正态分布的方差来工作的。Toksvig做了一个聪明的观察，如果正态分布是平均的而不是重新正态化的，则平均正态分布的长度与正态分布的宽度成反比。也就是说，原始法线越指向不同的方向，其平均值就越短。他提出了一种基于此法向长度来修改NDF粗糙度参数的方法。用修改后的粗糙度来评估BRDF近似于滤波后法线的扩散效果。</strong></p>
<p><strong>Toksvig最初的公式是用于Blinn-Phong NDF的:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010113903.png" class="" title="image-20211010113903">

<p><strong>其中αp 是原始粗糙度参数修改后的值αp′ ，||ˉn||为平均法线长度。通过等效αp = 2αb^−2−2，该方程也可用于Beckmann NDF(来自Walter et al.)，因为这两个NDFs的形状非常接近。使用GGX的方法就不那么简单了，因为GGX和Blinn-Phong(或Beckmann)之间没有明显的等价性。使用αb 等效为αg 在中心处的值是相同的高光，但高光的外观是相当不同的。更麻烦的是，GGX分布的方差是未定义的，这使得这种基于方差的技术在与GGX一起使用时的理论基础不稳固。尽管有这些理论上的困难，在GGX分布中使用上式是相当普遍的，通常使用αp = 2αg^−2−2。这样做在实践中相当有效。</strong></p>
<p><strong>Toksvig方法的优点是可以考虑GPU纹理滤波引入的正态方差。它还适用于最简单的法向mipmapping方案，即不需要标准化的线性平均。这个特性对于动态生成的法线贴图特别有用，比如水波纹贴图，对于这些贴图，mipmap生成必须在运行中完成。该方法对于静态法线映射不太好，因为它不能很好地与常用的法线映射压缩方法一起工作。这些压缩方法依赖于单位长度的法线。由于Toksvig的方法依赖于平均法线变化的长度，与它一起使用的法线映射可能必须保持未压缩。即使这样，存储缩短的法线也会导致精度问题。</strong></p>
<p><strong>Olano和Baker的LEAN映射技术是基于正态分布协方差矩阵的映射。像Toksvig的技术一样，它可以很好地用于GPU纹理过滤和线性映射。它还支持各向异性正态分布。与Toksvig的方法类似，精益映射可以很好地处理动态生成的法线，但为了避免精度问题，当使用静态法线时，它需要大量存储。Hery等人独立开发了类似的技术，并在皮克斯的动画电影中用于渲染亚像素细节，如金属薄片和小划痕。LEAN映射的一个更简单的变体CLEAN映射，需要更少的存储空间，但代价是失去各向异性支持。LEADR映射扩展了精益映射，也考虑了位移映射的可见性影响。</strong></p>
<p><strong>实时应用程序中使用的大多数法线映射是静态的，而不是动态生成的。对于这样的映射，通常使用方差映射族技术。在这些技术中，当法线地图的mipmap链生成时，就会计算通过平均而丢失的方差。Hill指出，Toksvig技术的数学公式、LEAN映射和CLEAN映射都可以以这种方式预先计算方差，这就消除了这些技术在使用其原始形式时的许多缺点。在某些情况下，预先计算的方差值存储在单独的方差纹理的mipmap链中。更常见的情况是，这些值用于修改现有粗糙度图的mipmap链。例如，《使命召唤:黑色行动》中的方差映射技术就采用了这种方法。修改的粗糙度值是通过将原始粗糙度值转换为方差值，添加法线映射的方差，并将结果转换回粗糙度来计算的。在游戏《秩序:1886》中，Neubelt和Pettineo以类似的方式使用了Han的技术。他们将法线映射NDF与BRDF的高光项NDF进行卷积，将结果转换为粗糙度，并将其存储在一个粗糙度映射中。</strong></p>
<p><strong>为了改进结果，需要额外存储一些数据，可以在纹理空间的x和y方向上计算方差，并存储在各向异性的粗糙度图中。就其本身而言，这项技术仅限于轴向各向异性，这在人造表面很常见，但在自然发生的表面不太常见。以多存储一个值为代价，也可以支持定向各向异性。</strong></p>
<p><strong>与Toksvig、LEAN和CLEAN映射的原始形式不同，方差映射技术不考虑GPU纹理滤波引入的方差。为了弥补这一点，方差映射实现通常用一个小过滤器卷积法线映射的顶层mip。当组合多个法线贴图时，例如详细法线贴图，需要注意正确组合法线贴图的方差。</strong></p>
<p><strong>法向方差可以由高曲率几何以及法向映射引入。由这种差异产生的工件不能通过前面讨论的技术得到缓解。存在一组不同的方法来处理几何正态方差。如果一个独特的纹理映射存在于几何体上(通常是角色，而不是环境)，那么几何曲率就可以“烘培”到粗糙度映射中。曲率也可以通过使用像素-着色器衍生指令来动态估计。这种估计可以在渲染几何图形时完成，或者在后期处理过程中，如果正常缓冲区可用。</strong></p>
<p><strong>到目前为止讨论的方法集中在镜面反射，但正常的方差也可以影响漫反射阴影。考虑正态方差对n·l项的影响有助于提高漫反射遮阳和镜面遮阳的精度，因为在反射率积分中两者都乘以了该因子。</strong></p>
<p><strong>方差映射技术近似正态分布为光滑的高斯波瓣。这是一个合理的近似，如果每个像素覆盖成千上万的颠簸，以便它们都平滑地平均出来。然而，在许多情况下，一个像素只覆盖了几百或几千个凸起，这可能导致“闪烁”的外观。一个例子可以在328页的图9.25中看到，这是一个图像序列，显示了一个球体的大小随着图像的不同而减小。右下角的图像显示了当凸起足够小到可以平均为平滑的高亮时的结果，但左下角和底部中心的图像显示的凸起小于一个像素，但不够小到可以平滑地平均。如果你观察这些球体的动画渲染，嘈杂的高光会在帧与帧之间出现闪烁。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010114557.png" class="" title="image-20211010114557">

<p>左边是随机凹凸不平表面的一小块区域(一侧有几十个凸起)的NDF。右边是一个宽度近似相同的Beckmann NDF波瓣。(图片由Miloˇ的Haˇsan提供)</p>
<p><strong>如果我们要绘制这样一个曲面的NDF，它看起来就像上图中的左图。当球体动画时，h矢量移动到NDF上，穿过亮区和暗区，这导致了“闪闪发光”的外观。如果我们在这个表面上使用方差映射技术，它将有效地近似这个NDF与一个平滑的NDF在上图的右边，失去闪闪发光的细节。</strong></p>
<p><strong>在电影工业中，这通常是通过大量的超采样来解决的，这在实时渲染应用中是不可行的，甚至在离线渲染中也是不可取的。</strong></p>
<p><strong>已经开发了几种技术来解决这个问题。有些不适合实时使用，但可能为未来的研究提供了途径。为了实时实现，设计了两种技术。Wang和Bowles展示了一种在游戏《迪士尼无限3.0》中渲染闪亮雪花的技术。该技术的目的是产生一个似是而非的闪光外观，而不是模拟一个特定的NDF。它是用于材料，如雪，有相对稀疏的闪光。Zirr和Kaplanyan的技术在多个尺度上模拟了正态分布，在空间和时间上都是稳定的，并允许更广泛的形式出现。</strong></p>
<p><strong>我们没有空间来涵盖关于材料过滤的所有广泛的文献，所以我们将提到一些值得注意的参考文献。Bruneton等人提出了一种跨尺度处理海洋表面从几何到BRDF(包括环境照明)的方差的技术。Schilling讨论了一种支持环境贴图的各向异性着色的方差映射类技术。Bruneton和Neyret提供了这一领域早期工作的全面概述。</strong></p>
<h1 id="10-Local-Illumination-直接光照"><a href="#10-Local-Illumination-直接光照" class="headerlink" title="10 Local Illumination 直接光照"></a>10 Local Illumination 直接光照</h1><p><strong>在第九章中，我们讨论了物理基材料的理论，以及如何用准时光源来评价它们。有了这个内容，我们可以通过模拟光线与表面的相互作用来进行着色计算，以测量在给定方向上有多少亮度发送到我们的虚拟相机。这个光谱亮度是场景参考像素颜色，它将被转换(第8.2节)为最终图像中给定像素的显示参考颜色。</strong></p>
<p><strong>在现实中，我们需要考虑的交互从来都不是准时的。我们已经在9.13.1节中看到，为了正确地评估着色，我们必须求解曲面BRDF响应在整个像素足迹上的积分，这是像素区域在曲面上的投影。这个积分过程也可以被认为是一个抗锯齿的解决方案。我们预先积分，而不是对频率分量没有界限的着色函数进行采样。</strong></p>
<p><strong>到目前为止，只有点和方向光源的影响已经提出，这限制了表面接收来自少数离散方向的光。这种照明描述是不完整的。事实上，表面接收来自所有入射方向的光。户外的景色不仅仅是由阳光照亮的。如果这是真的，所有处于阴影或背向太阳的表面都将是黑色的。天空是一个重要的光源，由大气中的阳光散射引起。天光的重要性可以从月球的照片上看出来，月球因为没有大气而缺乏天光。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010124326.png" class="" title="image-20211010124326">

<p>这是在月球上拍摄的照片，月球上没有天光，因为没有大气层来散射阳光。这张图片显示了当场景只被直接光源照亮时的样子。注意背向太阳的表面上漆黑的阴影和缺乏任何细节。这张照片显示宇航员詹姆斯·b·欧文在阿波罗15号任务期间站在月球漫游车旁边。前景的阴影来自登月舱。宇航员大卫·r·斯科特(指挥官)拍摄。(图片来自NASA的收藏)</p>
<p><strong>在阴天，在黄昏或黎明，室外照明都是天空光。即使在晴朗的日子，从地球上看，太阳也笼罩着一个圆锥体，所以也不是无极小。奇怪的是，尽管太阳和月球的大小有巨大的差异——太阳的半径比月球大两个数量级，但太阳和月球的相对角度都差不多，大约是半度。</strong></p>
<p><strong>事实上，照明从来不是准时的。在某些情况下，无穷小的实体是有用的，可以作为廉价的近似，或者作为更完整模型的构建块。为了形成一个更加真实的照明模型，我们需要整合BRDF响应整个半球的入射方向在表面。在实时绘制中，我们倾向于通过寻找闭形式的解或近似来解决绘制方程(第11.1节)所包含的积分。我们通常避免平均多个样本(射线)，因为这种方法往往要慢得多。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010124512.png" class="" title="image-20211010124512">

<p>左边是我们在第9章见过的积分:表面积和点状光。在右边，本章的目标将是扩展我们的着色数学，以说明在光表面的积分。</p>
<p><strong>本章致力于探索此类解决方案。特别地，我们想通过计算各种非点状光源的BRDF来扩展我们的着色模型。通常，为了找到便宜的解决方案(或任何解决方案)，我们需要近似的光发射器，BRDF，或两者。在一个感性的框架中评估最终的着色效果是很重要的，理解什么元素在最终的图像中是最重要的，所以要在这些方面投入更多的精力。</strong></p>
<p><strong>我们在这一章开始用公式来积分分析区域光源。这种发射器是场景中的主要光源，负责大部分的直接照明强度，所以对于这些，我们需要保留所有选择的材质属性。阴影应该计算这样的发射器，因为光线泄漏将导致明显的伪影。然后，我们研究如何表现更一般的照明环境，其中包括任意分布在传入半球。在这些情况下，我们通常接受更近似的解决方案。环境照明用于大型、复杂但强度较低的光源。例子包括从天空和云层散射的光，场景中大物体反射的间接光，和调暗直接区域光源。这样的发射器对于图像的平衡非常重要，否则图像会显得太暗。即使我们考虑了间接光源的影响，我们仍然不在整体照明的领域(第11章)，这依赖于场景中其他表面的明确知识。</strong></p>
<h2 id="Area-Light-Sources-区域光"><a href="#Area-Light-Sources-区域光" class="headerlink" title="Area Light Sources 区域光"></a>Area Light Sources 区域光</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010124806.png" class="" title="image-20211010124806">

<p>由光源照亮的表面，考虑由表面法线n定义的可能入射光方向的半球。在左侧，光源是无穷小的。在右边，它被建模为一个区域光源。</p>
<p><strong>在第九章中，我们描述了理想的无穷小光源:准时的和定向的。上图显示了入射半球在表面点上，以及无穷小光源和非零尺寸的面积光源之间的差异。左边的光源使用9.4节中讨论的定义。它从一个方向lc照亮表面．它的亮度用颜色clight来表示，定义为白色朗伯氏表面对着光线反射的亮度。点或方向光对出射亮度Lo(v)的贡献在v方向上为πf(lc, v)clight(n·lc)+(请注意1.2节介绍的用于将负数夹紧为零的x+符号)。或者，区域光源(右侧)的亮度用其亮度Ll表示．面积灯对着一个实心角ωl 从地面的位置。它对v方向的输出辐射的贡献是f(l, v)Ll(n·l)+除以ωl的积分。</strong></p>
<p><strong>无穷小光源的基本近似表达式为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125056.png" class="" title="image-20211010125056">

<p><strong>一个区域光源对一个表面位置的照明的贡献量是它的亮度(Ll)和从该位置看到的大小(ωl)．正如我们在第9.4节中看到的，点光源和定向光源是在实践中无法实现的近似，因为它们的零立体角意味着无限的亮度。理解近似值带来的视觉错误将有助于知道何时使用它，以及当不能使用它时采取什么方法。这些误差将取决于两个因素:光源有多大(由它从着色点覆盖的实心角度测量)，以及表面有多光滑。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125150.png" class="" title="image-20211010125150">

<p>从左到右，球体材料的表面粗糙度增加，使用GGX BRDF。最右边的图像复制了系列中的第一个，垂直翻转。注意，在一个低粗糙度的材料上由一个大的圆盘光源引起的高光和着色看起来是如何类似于在一个更粗糙的材料上由一个较小的光源引起的高光。</p>
<p><strong>上图显示了镜面高光的大小和形状如何取决于材料的粗糙度和光源的大小。对于一个小光源，一个与视场角度相比包含一个很小的实心角度的光源，误差很小。粗糙的表面也倾向于显示光源大小小于抛光的效果。一般情况下，面点的面发射面积和面BRDF的镜面波瓣都是球面函数。如果我们考虑这两个函数有重要贡献的方向集，我们得到两个实心角。误差的决定因素与发射角相对于BRDF镜面高光立体角的大小成正比。</strong></p>
<p><strong>最后，请注意，区域光的高光可以通过使用准时光和增加表面粗糙度来近似。这个观察结果对于推导出代价更低的面积光积分近似是有用的。这也解释了为什么在实践中许多实时渲染系统只使用准时源就能产生可信的结果:艺术家弥补了这个错误。然而，这样做是有害的，因为它将材质属性与特定的照明设置结合在一起。以这种方式创建的内容在灯光场景改变时看起来并不正确。</strong></p>
<p><strong>对于朗伯曲面的特殊情况，使用点光作为面积光是准确的。对于这样的表面，输出辐亮度与辐照度成正比:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125424.png" class="" title="image-20211010125424">

<p><strong>在ρss 为表面的次表面反照率或漫反射色(第9.9.1节)。根据这个关系，我们可以使用等效的上上公式来计算辐照度，这要简单得多:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125434.png" class="" title="image-20211010125434">

<p><strong>矢量辐照度的概念有助于理解辐照度在区域光源存在时的行为。矢量辐照度是由Gershun提出的，他称之为光矢量，并由Arvo进一步扩展。利用矢量辐照度，可以将任意大小和形状的面积光源准确地转换为点或方向光源。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125548.png" class="" title="image-20211010125548">

<p>矢量辐照度的计算。左:点p被各种形状、大小和亮度分布的光源包围。黄色的亮度表示放射出的亮度。橙色箭头是指向所有方向的矢量，每个长度等于从那个方向发出的辐射量乘以箭头覆盖的无限小实心角度。原则上，箭头的数目应该是无限的。右:矢量辐照度(大橙色箭头)是所有这些矢量的总和。矢量辐照度可用来计算任意平面在p点的净辐照度。</p>
<p><strong>想象一个亮度Li 的分布进入空间中的点p。参见上图。现在我们假设Li 是波长无关的，因此可以表示为标量。对于以入射方向l为中心的每一个无限小实心角dl，将构造一个与l对齐的向量，其长度等于从该方向入射的(标量)亮度乘以dl。最后，将所有向量相加，得到向量辐照度e:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125646.png" class="" title="image-20211010125646">

<p><strong>其中Θ表示对整个方向球进行积分。</strong></p>
<p><strong>向量辐照度e可以通过执行点积来求出任意方向平面上p处的净辐照度:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125716.png" class="" title="image-20211010125716">

<p><strong>n是平面的法线。通过一个平面的净辐照度是通过该平面的“正面”(由平面法线n定义)和通过该平面“负面”的辐照度之间的差。“光网辐照度本身并不能用于遮阳。然而，如果没有亮度通过“负的一面”发射(换句话说，被分析的光分布没有部分之间的角度l和n超过90◦)，那么E(p，−n) = 0和</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125813.png" class="" title="image-20211010125813">

<p><strong>单个区域光源的矢量辐照度可以使用上式，以任意法线n照亮朗伯氏表面，只要n不面对大于90◦远离区域光源的任何部分。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125857.png" class="" title="image-20211010125857">

<p>单一区域光源的矢量辐照度。在左边，箭头表示用于计算矢量辐照度的矢量。在右边，大的橙色箭头是矢量辐照度e。红色虚线代表光源的范围，红色矢量(每个垂直于红色虚线)定义了一组表面法线的限制。法线外的这个设置将有一个大于90◦与区域光源的某些部分的角度。这些法线不能正确地使用e来计算它们的辐照度。</p>
<p><strong>如果我们假设Li 波长独立不成立，那么在一般情况下，我们不能再定义一个单一的向量e。然而，有色光通常在所有点有相同的相对光谱分布，这意味着我们可以因子Li 变成颜色c′ 和波长无关的辐射分布L′i．在这种情况下，我们可以计算L ‘的ei 将上式扩展为n·e乘以c ‘。这样做得到的结果与从a开始计算辐照度的公式相同定向光源，替换如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130011.png" class="" title="image-20211010130011">

<p><strong>我们有效地将任意形状和大小的面积光源转换为定向光源而不引入任何误差。</strong></p>
<p><strong>求矢量辐照度的公式10.4对于简单情况可以用解析方法求解。例如，假设一个圆心为pl 的球形光源半径是rl．光发出恒定的亮度Ll 从球体上的每一点，从各个方向。对于这种光源，公式10.4和上式得出如下结果:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130109.png" class="" title="image-20211010130109">

<p><strong>这个等式与带有clight0 = Ll, r0 = rl的泛光灯(章节5.2.2)相同，和标准的平方反比距离衰减函数。这个衰减函数可以调整，以考虑到球内的点，并将光的影响限制到给定的最大距离。有关此类调整的更多细节可参阅第5.2.2节。</strong></p>
<p><strong>所有这些都是正确的，只有当没有“负的一面”辐照度。另一种思考方法是，区域光源的任何部分都不能“在地平线下”，或者被表面遮挡。我们可以推广这个说法。对于朗伯曲面，区域和点光源之间的所有差异都是由遮挡差异造成的。点光源的辐照度在光线不被遮挡的情况下服从余弦定律。Snyder推导了考虑遮挡的球形光源的解析表达式。这个表达式相当复杂。然而，由于它只取决于两个量(r/rl 和θi， n和lc之间的夹角)，它可以预先计算成一个二维纹理。Snyder还给出了两个适用于实时渲染的函数逼近。</strong></p>
<p><strong>在上上上图中，我们看到区域照明的效果对粗糙表面不太明显。这个观察结果也允许我们使用一种较少物理基础但仍然有效的方法来建模Lambertian表面上的区域灯光效果:包裹照明。在这种技术中，对n·l的值做一些简单的修改，然后将其固定为0。Forsyth给出了一种包裹式照明的形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130340.png" class="" title="image-20211010130340">

<p><strong>kwrap 范围从0(点光源)到1(覆盖整个半球的区域光源)。Valve使用了另一种模拟大面积光源效果的形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130350.png" class="" title="image-20211010130350">

<p><strong>一般来说，如果我们计算区域光照，我们还应该修改阴影计算，以考虑非准时源。如果我们不这样做，一些视觉效果可能会被强烈的阴影抵消。如第7章所述，软阴影可能是区域光源最明显的效果。</strong></p>
<h3 id="Glossy-Materials-光泽材质"><a href="#Glossy-Materials-光泽材质" class="headerlink" title="Glossy Materials 光泽材质"></a>Glossy Materials 光泽材质</h3><p><strong>区域灯光在非兰伯特表面上的效果更复杂。Snyder推导出球形光源的求解方法，但其限于原始的反射矢量Phong材料模型，且极其复杂。在今天的实践中，需要近似法。</strong></p>
<p><strong>区域灯光在光滑表面上的主要视觉效果是亮点。参见上上上图。它的大小和形状与区域光相似，而高光的边缘根据表面的粗糙度而模糊。这一观察结果导致了对这种效应的几个经验近似。这些在实践中很有说服力。例如，我们可以修改高光计算的结果，加入一个临界值，创建一个大的平面高光区域。这可以有效地创造球光源镜面反射的错觉，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130529.png" class="" title="image-20211010130529">

<p>光滑物体上的高光是光源形状的强烈反射。在左边，这个外观已经通过阈值的Blinn-Phong着色器的高亮值来近似。在右侧，相同的对象使用未修改的Blinn-Phong着色器进行比较。(图片由拉里·格里茨提供)</p>
<p><strong>大多数用于实时渲染的区域照明效果的实际近似都是基于这样的想法:为每个着色点寻找一个等效的准时照明设置，以模拟一个非无穷小光源的效果。该方法常用于实时绘制，以解决各种问题。这与我们在第9章中看到的处理表面像素足迹上的BRDF积分的原理相同。它产生的近似值通常很便宜，因为所有的工作都是通过改变着色方程的输入来完成的，而不会引入任何额外的复杂性。因为数学没有被改变，我们经常可以保证，在某些条件下，我们恢复到对原始着色的计算，从而保留它的所有属性。由于大多数典型系统的着色代码都是基于点灯的，所以将这些用于区域灯只会引入本地化的代码更改。</strong></p>
<p><strong>开发的第一个近似是Mittring的粗糙度修改，用于Unreal Engine的“Unreal Engine”。这个想法是首先找到一个包含大部分光源照射到半球方向上的圆锥体。然后，我们在镜瓣周围安装一个类似的锥，包含“大部分”BRDF。参见下图。这两种视锥细胞都是半球功能的替代品，它们包含了一组方向，在这些方向上，这两种功能的值大于给定的任意临界值。这样，我们可以通过寻找一个新的BRDF瓣来近似光源与材料BRDF的卷积，这个BRDF瓣的粗糙度不同，它有一个对应的圆锥，其立体角等于光瓣角与材料BRDF的和。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130803.png" class="" title="image-20211010130803">

<p>GGX BRDF，以及一个圆锥体，用于包围反射镜瓣反射大部分入射光的方向集。</p>
<p><strong>Karis将Mittring原理应用于GGX/Trowbridge- Reitz BRDF(章节9.8.1)和球面面积光，得到了GGX粗糙度参数αg的简单修正：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130902.png" class="" title="image-20211010130902">

<p><strong>注意在第1.2节中介绍的符号x+ˉ的用法，用于在0和1之间夹紧。这种近似工作得相当好，而且非常便宜，但对于有光泽的、几乎像镜子一样的材质来说，这种方法就行不通了。这是因为镜面波瓣总是平滑的，不能模拟由区域光源在表面上的强烈反射引起的高光。此外，大多数微表面 BRDF模型都有一个瓣，它不是“紧凑的”(局部的)，但表现出一个广泛的衰减(镜面尾)，使得粗糙度重映射的效率降低。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130957.png" class="" title="image-20211010130957">

<p>球形照明。从左到右:数值积分、粗糙度修正技术、代表点技术计算的参考解。(图片来源:Epic Games Inc.， Brian Karis)</p>
<p><strong>而不是改变材料的粗糙度，另一个想法是表示区域照明的来源与光的方向，根据被着色点的变化。这被称为最具代表性的点解决方案，修改光矢量，使其在产生最大光的区域表面上的点的方向上对着色表面的能量贡献。参见上图。Picott使用光线上与反射光形成最小角度的点。Karis改进了Picott的公式，为了提高效率，他将球面上与反射光距离最短的点夹角最小的点近似。他还提出了一个廉价的公式来衡量光的强度，以尽量保持整体释放的能量。参见下图。大多数有代表性的点解都是方便的，并且已经发展为各种光几何，因此了解它们的理论背景是很重要的。这些方法类似于蒙特卡罗积分中的重要抽样的思想，在蒙特卡罗积分中，我们通过在积分域上平均样本来数值计算定积分的值。为了更有效地做到这一点，我们可以尝试对总体平均值有较大贡献的样本进行优先排序。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010131146.png" class="" title="image-20211010131146">

<p>球面的Karis代表点近似。首先计算出反射光上最接近球心l的点:pcr = (l·r)r−l，那么球面上最接近pcr的点:pcs = l + pcr·min(1，radius /||pcr||)．</p>
<p><strong>更严格地证明其有效性的是定积分的中值定理，它允许我们用同一函数的单个求值来替换函数的积分:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010131331.png" class="" title="image-20211010131331">

<p><strong>如果f (x)在D是连续,然后∫D 1是域的面积,与c点∈D在函数最小值和最大值之间的界线在D .对于照明,我们考虑的是产品的积分和双向光辐照度超过半球的面积覆盖的光。我们通常认为我们的光是均匀照射的，所以我们只需要考虑光的衰减，并且大多数近似也假设区域D从着色点是完全可见的。 即使有这些假设，确定点c和归一化因子∫D 1仍然可能太昂贵，所以要使用进一步的近似。</strong></p>
<p><strong>有代表性的点解决方案也可以通过它们对高光形状的影响来框定。在表面的一部分，当反射矢量在区域光所覆盖的方向锥的外面时，代表点不会改变，我们使用点光有效地照明。高光的形状只取决于下面的镜面瓣的形状。或者，如果我们在反射向量击中区域光的表面上着色点，那么代表点将不断变化，以指向最大贡献的方向。这样做有效地扩展了镜面波瓣峰值，“扩大”它，这种效果类似于上上上上图中的硬阈值。</strong></p>
<p><strong>这个宽的、恒定的高光峰也是近似中剩余的误差来源之一。在粗糙的表面上，区域的光反射看起来比地面真实的解决方案更“锐利”。通过蒙特卡洛积分得到一个与粗糙修改技术的过度模糊相反的视觉缺陷。为了解决这个问题，Iwanicki和Pesce将BRDF瓣、软阈值、代表性点参数和比例因子(为了节能)拟合到通过数值积分计算得到的球形区域照明结果中，得到了近似结果。这些拟合函数的结果是一个由材质粗糙度、球体半径和光源中心与表面法线和视图向量之间的角度索引的参数表。由于在着色器中直接使用这种多维查找表是昂贵的，因此提供了封闭形式的近似。最近，de Carpentier推导出了一种改进的方法，用于基于微面的BRDFs，可以更好地保留球面区域源在掠入射角度下的高光形状。这种方法的工作原理是找到一个具有代表性的点，使表面法线和光线视图半矢量之间的点积n·h最大化，而不是原始公式的n·r(这是为Phong BRDF导出的)。</strong></p>
<h3 id="General-Light-Shapes-一般灯光形状"><a href="#General-Light-Shapes-一般灯光形状" class="headerlink" title="General Light Shapes 一般灯光形状"></a>General Light Shapes 一般灯光形状</h3><p><strong>到目前为止，我们已经看到了一些计算均匀发射球形区域光和任意光滑BRDFs着色的方法。这些方法中的大多数都采用了各种各样的近似方法，以便得出能够快速实时评估的数学公式，因此与实际问题的解决方法相比，会显示出不同程度的误差。然而，即使我们有计算能力得出一个精确的解，我们仍然会犯一个很大的错误，一个我们嵌入在照明模型假设中的错误。现实世界中的光通常不是球体，它们也很难成为完美的均匀发射体。参见下图。球面区域灯在实践中仍然是有用的，因为他们提供了最简单的方法来打破照明和表面粗糙度之间的错误相关性，准时灯引入。然而，只有当球面光源相对较小时，它才能很好地近似于大多数真实光源。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010132015.png" class="" title="image-20211010132015">

<p>常用的光形状。从左到右:球体，矩形(卡)，管(线)，和聚焦发射管(沿光表面法线集中，不均匀散布在半球)。注意它们创建的不同的亮点。</p>
<p><strong>由于基于物理的实时渲染的目标是生成令人信服的、可信的图像，在这个追求中，我们只能将自己限制在一个理想化的场景中。在计算机图形学中，这是一种反复出现的权衡。我们可以通常是在为简化假设的简单问题生成精确的解决方案，还是为更贴近现实的更普遍的问题生成近似的解决方案之间进行选择。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010132145.png" class="" title="image-20211010132145">

<p>一个光管。图像采用代表性点解进行计算。</p>
<p><strong>球形灯的一个最简单的扩展是“管”灯(也称为“胶囊”)，它可以用来代表现实世界中的荧光灯。参见上图。对于Lambertian BRDFs, Picott给出了一个封闭形式的照明积分公式，该公式等价于用适当的衰减函数计算线性光段的两个点光源的照明:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010132214.png" class="" title="image-20211010132214">

<p><strong>p0 和p1 是线性光的两个端点，n是表面法线。Picott还推导出了Phong高光BRDF积分的一个代表性点解，近似为从放置在光段位置的点光源进行照明，当连接到考虑的表面点时，形成了与反射矢量的最小夹角。这个具有代表性的点解动态地将线性光转换为点1，因此我们可以使用任何近似球面光来“加厚”光夹具到一个胶囊中。</strong></p>
<p><strong>在球形灯的情况下,Karis提供了一个更高效的(但不太准确)变体Picott最初的解决方案,通过使用最小的点线距离反射向量(而不是最小的角),并提出一个缩放公式,试图恢复能量守恒。</strong></p>
<p><strong>我们可以很容易地获得许多其他光形状的代表性点近似，如环和B´ezier分段，但我们通常不希望我们的着色器分支太多。在我们的场景中，好的光形状可以用来代表许多真实世界的光。最具表现力的形状类别之一是平面区域灯，定义为由给定几何形状(如矩形(在这种情况下它们也被称为卡片灯)、磁盘或更普遍的多边形)约束的平面的一部分。这些原体可以用于发射面板，如广告牌和电视屏幕，代替常用的摄影照明(软盒，反弹卡)，模拟许多更复杂的照明装置的光圈，或表示从墙壁和场景中其他大型表面反射的光线。</strong></p>
<p><strong>Drobot是卡片灯(以及磁盘)的第一个实际近似值。这也是一个具有代表性的点解，但它特别值得注意，因为将这种方法扩展到平面的二维区域非常复杂，而且对于求解的整体方法来说也是如此。机器人从均值定理开始，作为第一次近似，确定一个好的候选点用于光线评估应该位于光照积分的全局最大值附近。</strong></p>
<p><strong>对于朗伯BRDF，这个积分是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010132452.png" class="" title="image-20211010132452">

<p><strong>Ll 是光发射的恒定辐射度，ωl 是灯光几何正对立体角，rl 是在l方向上从曲面到灯光平面的光线长度，(n·l)+为常用的朗伯夹紧点积。(n·l)+的最大值点pc 在光区域的边界上，从该表面发出的光线沿法线方向与光平面相交而得到的离点p ‘最近的点。同样，1/rl² 的最大值是点pr 在最接近p′′ 点的边界上这是光平面上离被着色覆盖的表面点最近的地方。参见下图。被积函数的全局最大值就在连接pr 和pc的线段上的某个地方: pmax = tmpc +(1 - tm) pr，tm ∈[0,1]。Drobot使用数值积分来找到许多不同构型的最佳代表点，然后找到单个tm 这在平均水平上是最好的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010133131.png" class="" title="image-20211010133131">

<p>Drobot矩形面积光代表点近似的几何构造。</p>
<p><strong>Drobot的最终解决方案采用了漫反射和镜面照明的进一步近似，所有这些都是通过与数值上发现的地面真实解决方案进行比较来实现的。他还推导出了一种算法，用于纹理卡片灯的重要情况，在光线的矩形区域，发射不是恒定的，而是由纹理调制的。该过程使用一个三维查找表执行，该表包含在不同半径的圆形足迹上预集成的发射纹理版本。Mittring使用类似的方法来处理光滑反射，将反射光线与有纹理的矩形广告牌相交，并根据光线相交距离索引预计算的纹理模糊版本。这项工作先于Drobot的发展，但它是一种更经验性的、不那么有原则的方法，确实试图匹配实际的整体解决方案。</strong></p>
<p><strong>对于平面多边形区域灯的更一般情况，Lambert最初推导出了一种完全漫射表面的精确封闭解。Arvo对该方法进行了改进，允许将光滑材质建模为Phong镜面瓣。Arvo通过将矢量辐照度的概念扩展到高维辐照度张量，并利用斯托克定理将面积积分作为沿积分域轮廓的简单积分来求解。他的方法做出的唯一假设是，光从着色表面点完全可见(这是一个常见的，可以通过剪切与表面相切的光多边形来绕过)，BRDF是一个径向对称的余弦瓣。不幸的是，在实践中，Arvo的解析解对于实时渲染是相当昂贵的，因为它需要评估一个公式，其时间复杂度是线性的Phong瓣指数使用，每个区域光多边形的每条边。最近Lecocq通过找到一个O(1)逼近轮廓积分函数，并将解推广到一般的、基于半矢量的BRDFs，使这种方法更加实用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010133523.png" class="" title="image-20211010133523">

<p>线性变换余弦技术背后的关键思想是，通过使用3 × 3变换矩阵，一个简单的余弦叶(在左边)可以很容易地缩放、拉伸和倾斜。这使得余弦瓣在球面上有许多不同的形状。(图片由Eric Heitz提供。)</p>
<p><strong>迄今为止所描述的所有实际的实时区域照明方法都采用了某些简化假设，以允许推导分析结构和近似处理得到的积分。Heitz等人对线性变换余弦(LTCs)采取了不同的方法，得出了实用、准确和通用的技术。他们的方法是从在球体上设计一类具有高度表现力的函数开始。例如，它们可以有多种形状)，并且可以在任意球形多边形上轻松集成。参见上图。LTCs只使用一个通过3×3矩阵变换的余弦瓣，因此它们可以在半球上调整大小、拉伸和旋转，以适应各种形状。球面多边形的简单余弦瓣(不像Blinn-Phong，没有取指数)的积分已经建立，可以追溯到Lambert。Heitz等人的关键观察是，在波瓣上用变换矩阵扩展积分不会改变其复杂性。我们可以通过矩阵的逆变换多边形域，并在积分内消去矩阵，返回到一个简单的余弦叶作为被积函数。参见下图。通用的双向反射和区域灯光形状,剩下的工作就是想办法(近似)表达的双向反射函数作为一个或多个LTCs范围,可以离线完成的工作和列表中查找数组索引与BRDF参数:粗糙度、入射角等上。线性变换的基于余弦的解决方案，既适用于一般的纹理多边形区域光源，也适用于特殊的、计算成本较低的形状，如卡片、磁盘和线灯。LTCs可能比典型的点解决方案更昂贵，但更精确。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010133721.png" class="" title="image-20211010133721">

<p>给定一个LTC和一个球面多边形域(左图)，我们可以通过LTC矩阵的逆对它们进行变换，从而得到一个简单的余弦瓣和一个新的域(右图)。余弦瓣在变换域中的积分等于LTC在原域中的积分。(图片由Eric Heitz提供。)</p>
<h2 id="Environment-Lighting-环境光"><a href="#Environment-Lighting-环境光" class="headerlink" title="Environment Lighting 环境光"></a>Environment Lighting 环境光</h2><p><strong>原则上，反射率(公式9.3)不区分直接来自光源的光和从天空或场景中物体散射的间接光。所有入射方向都有辐亮度，反射率方程对所有方向进行积分。然而，在实践中，直射光通常以相对小的实心角度和高辐亮度值来区分，而间接光往往以中到低辐亮度值漫射覆盖半球的其余部分。这种拆分为分别处理这两个问题提供了很好的实际理由。</strong></p>
<p><strong>到目前为止，区域光技术讨论了积分恒定辐射从光的形状发射。这样做为每个着色表面点创建了一组方向，这些方向具有恒定的非零入射辐亮度。我们现在所研究的是在所有可能的入射方向上用变化函数定义的辐亮度的积分方法。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011135924.png" class="" title="image-20211011135924">

<p>渲染在不同的环境照明下同一个场景。</p>
<p><strong>虽然我们通常会在这里讨论间接照明和“环境”照明，但我们不会研究全局照明算法。关键的区别在于，在本章中，所有的着色数学并不依赖于场景中其他表面的知识，而是依赖于一组光基元。所以，虽然我们可以，举个例子，使用区域光来模拟光线从墙壁的反射，这是一个全局效果，但着色算法不需要知道墙壁的存在。它拥有的唯一信息是关于光源的，所有的着色都是在局部执行的。全局照明(第11章)将经常与本章的概念密切相关，因为许多解决方案可以看作是计算的方法为每个物体或表面位置使用正确的局部光原语集，以模拟光线在场景周围反弹的交互作用。</strong></p>
<p><strong>环境光是环境照明最简单的模型，其亮度不随方向变化，LA为常数．即使是这样一个环境照明的基本模型也能显著提高视觉质量。一个不考虑光线从物体间接反射的场景显得非常不现实。在这样的场景中，处于阴影或背光的物体将是完全黑色的，这与现实中发现的任何场景都不一样。在376页的图10.1中，月球表面与之很接近，但即使在这样的场景中，一些间接的光线也会反射到附近的物体上。</strong></p>
<p><strong>环境光的确切效果将取决于BRDF。对于朗伯曲面，固定的亮度LA 无论表面法向n或视图方向v，输出辐亮度的贡献都是恒定的:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011140144.png" class="" title="image-20211011140144">

<p><strong>当着色时，这个恒定的出射亮度贡献被添加到直接光源的贡献中。对于任意BRDFs，等价方程为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011140154.png" class="" title="image-20211011140154">

<p><strong>该方程的积分与方向反照率R(v)(第9.3节式9.9)相同，因此方程等价于Lo(v) = LAR (v)。旧的实时渲染应用程序有时假定R(v)是一个常量，称为环境色camb．这进一步将方程简化为Lo(v) = camblA．</strong></p>
<p><strong>反射方程忽略遮挡，即许多表面点会被其他物体或同一物体的其他部分挡住，无法“看到”一些进入的方向。这种简化降低了现实主义一般，但它是特别明显的环境照明，当遮挡被忽略时，它显得非常平坦。解决这个问题的方法将在第11.3节讨论，特别是在第11.3.4节。</strong></p>
<h2 id="Spherical-and-Hemispherical-Functions-球面和半球函数"><a href="#Spherical-and-Hemispherical-Functions-球面和半球函数" class="headerlink" title="Spherical and Hemispherical Functions 球面和半球函数"></a>Spherical and Hemispherical Functions 球面和半球函数</h2><p><strong>为了将环境照明扩展到一个常数项之外，我们需要一种方法来表示从任何方向入射到物体上的亮度。首先，我们将认为辐亮度仅仅是被积分方向的函数，而不是表面位置的函数。这样做是基于光照环境是无限远的假设。</strong></p>
<p><strong>到达某一给定点的辐射在每个入射方向上都是不同的。照明可以从左边变为红色，从右边变为绿色，或者从顶部被阻挡而从侧面不被阻挡。这些类型的量可以用球形表示函数，定义在单位球面上，或者R³的方向空间上．我们将这个域表示为s。这些函数的工作方式不受它们产生单个值还是多个值的影响。例如，通过为每个颜色通道存储单独的标量函数，用于存储标量函数的相同表示也可以用于编码颜色值。</strong></p>
<p><strong>假设朗伯曲面，球形函数可以用来计算环境照明，通过存储一个预先计算的辐照度函数，例如，辐射与余弦瓣卷积，每个可能的表面法向。更复杂的方法存储辐亮度，并在运行时使用BRDF计算每个着色表面点的积分。球面函数也广泛用于全局光照算法(第11章)。</strong></p>
<p><strong>与球面函数相关的是那些半球函数，在这种情况下，只有一半方向的值是定义的。例如，这些函数用于描述在没有来自下面的光的表面入射的辐亮度。</strong></p>
<p><strong>我们将把这些表示称为球基，因为它们是定义在球上的函数的向量空间的基。即使环境/高光/方向形式(章节10.3.3)在技术上不是数学意义上的基础，我们也将使用这个术语来指代它。将函数转换为给定的表示形式称为投影，从给定的表示形式求函数的值称为重构。</strong></p>
<p><strong>每种表示都有自己的一组权衡。我们可以在给定的基础上寻找的属性是:</strong></p>
<pre><code>**•高效的编码(投影)和解码(查找)。**

**•能够表示任意球面函数，系数小，重构误差低。**

**•投影的旋转不变性，它是旋转函数的投影的结果，与旋转函数然后进行投影是相同的。这种等效性意味着一个近似于，例如，球谐函数在旋转时不会改变。**

**•易于计算编码函数的总和和乘积。**

**•易于计算球面积分和卷积。**
</code></pre>
<h3 id="Simple-Tabulated-Forms-简单表格"><a href="#Simple-Tabulated-Forms-简单表格" class="headerlink" title="Simple Tabulated Forms 简单表格"></a>Simple Tabulated Forms 简单表格</h3><p><strong>表示球形(或半球形)函数的最直接方法是选择几个方向，并为每个方向存储一个值。对函数的求值涉及到在求值方向周围找到一些样本，然后用某种形式的插值来重建这个值。</strong></p>
<p><strong>这种表示很简单，但很有表现力。添加或相乘这样的球形函数就像添加或相乘相应的表项一样简单。</strong></p>
<p><strong>我们可以根据需要，通过添加更多的样本，以任意低的误差编码许多不同的球面函数。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011140617.png" class="" title="image-20211011140617">

<p>在球面上分布点的几种不同方法。从左到右:随机点，立方体网格点，球面t形设计。</p>
<p><strong>以一种允许高效检索的方式将样本分布在一个球体上(参见上图)，同时相对平等地表示所有方向，这不是一件简单的事情。最常用的技术是首先将球体展开成一个矩形域，然后用点网格对这个域进行采样。由于二维纹理恰好代表了一个矩形上的点(像素)网格，我们可以使用像素作为样本值的底层存储。这样做可以让我们利用gpu加速的双线性纹理过滤来进行快速查找(重建)。在本章的后面，我们将讨论环境映射(第10.5节)，它是这种形式的球形函数，并讨论展开球形的不同选项。</strong></p>
<p><strong>表格也有缺点。在低分辨率下，硬件滤波提供的质量通常是不可接受的。卷积的计算复杂度是处理光照时的一种常见操作，它与样本的数量成正比，可能会令人却步。此外，投影在旋转下不是不变的，这在某些应用中可能是有问题的。例如，想象从一组方向照射到物体表面的光的亮度编码。如果对象旋转，编码的结果可能会以不同的方式重建。这可以导致编码的辐射能数量的变化，这可以在场景动画时表现为脉动的人工制品。通过在投影和重构过程中使用与每个样本相关的精心构造的核函数，可以减轻这些问题。不过，更常见的是，仅仅使用足够密集的采样就足以掩盖这些问题。</strong></p>
<p><strong>通常，当我们需要存储复杂的、高频率的函数时，我们会使用表格，这些函数需要许多数据点来进行低误差的编码。如果我们需要对球函数进行紧凑的编码，只有几个参数，可以使用更复杂的基。</strong></p>
<p><strong>环境立方体(AC)是一种流行的基本选择，它是最简单的表格形式之一，由沿长轴方向的6个平方余弦瓣构成。它被称为环境“立方体”，因为它相当于将数据存储在……的表面上一个立方体，当我们从一个方向移动到另一个方向时进行插值。对于任何给定的方向，只有三个叶瓣是相关的，所以其他三个叶瓣的参数不需要从内存中提取。数学上，环境立方体可以定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011140732.png" class="" title="image-20211011140732">

<p><strong>其中c+ 和c− 包含多维数据集面和sel+(c+,c−,(d)的六个值是一个向量函数，它的每个分量都假定来自c+ 或c− 的值根据d中各自的分量是否为正。</strong></p>
<p><strong>环境立方体类似于立方体映射(章节10.4)，每个立方体表面只有一个texel。在某些系统中，针对这种特殊情况，在软件中执行重构可能比在立方体映射上使用GPU的双线性滤波要快。Sloan推导出一个简单的公式，用于在环境立方和球谐基之间进行转换(第10.3.2节)。</strong></p>
<p><strong>使用环境立方体重建的质量相当低。通过存储和插值8个值而不是6个值(对应于立方体顶点)，可以获得稍微更好的结果。最近，Iwanicki和Sloan提出了一种称为环境骰子(AD)的替代方法。基由沿二十面体顶点方向的平方和四次方余弦瓣组成。存储的12个值中有6个用于重建，确定检索哪6个值的逻辑比环境立方体的对应逻辑稍微复杂一些，但结果的质量要高得多。</strong></p>
<h3 id="Spherical-Bases-基于球形"><a href="#Spherical-Bases-基于球形" class="headerlink" title="Spherical Bases 基于球形"></a>Spherical Bases 基于球形</h3><p><strong>有无数种方法可以将(编码)函数投射到使用固定数量值(系数)的表示上。我们所需要的是一个数学表达式，它跨越了我们的球域，带有一些我们可以改变的参数。然后我们可以通过拟合逼近任意给定的函数，即找到参数的值，使表达式与给定函数之间的误差最小化。</strong></p>
<p><strong>最小可能的选择是使用一个常量:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011143711.png" class="" title="image-20211011143711">

<p><strong>我们可以将给定的函数f在单位球的表面积上求平均，从而导出它在这个基底上的投影:<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011143820.png" class="" title="image-20211011143820">。平均函数c也称为直流分量。这种基具有简单的优点，甚至考虑了我们正在寻找的一些性质(易重构、加法、积、旋转不变性)。然而，它不能很好地表达大多数球形函数，因为它只是用它们的平均值来代替它们。我们可以用两个系数a和b构造一个稍微复杂一点的近似:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011143721.png" class="" title="image-20211011143721">

<p><strong>它创建了一种表示，可以在极点编码精确的值，并可以在它们之间插入穿过球体的表面。这种选择更具表现力，但现在投影变得更加复杂，并不是对所有旋转都是不变的。事实上，这个基础可以看作是一个表格形式，只有两个样本，放在极点。</strong></p>
<p><strong>一般来说，当我们讨论函数空间的基时，我们的意思是我们有一组函数，它们的线性组合(加权和求和)可以用来表示给定域中的其他函数。这个概念的示例如下图所示。本节的其余部分探讨了一些可用于在球面上近似函数的基的选择。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144010.png" class="" title="image-20211011144010">

<p>基函数的一个基本例子。在本例中，空格是“输入在0到5之间的值在0到1之间的函数”。左边的图显示了这种功能的一个例子。中间的图显示了一组基函数(每种颜色都是一个不同的函数)。右边的图显示了目标函数的近似值，它是通过将每个基函数乘以一个权重并对其求和而形成的。基函数按其各自的权重按比例表示。黑线表示求和的结果，它是原始函数的近似，用灰色表示以供比较。</p>
<h4 id="Spherical-Radial-Basis-Functions-球面径向基函数"><a href="#Spherical-Radial-Basis-Functions-球面径向基函数" class="headerlink" title="Spherical Radial Basis Functions 球面径向基函数"></a>Spherical Radial Basis Functions 球面径向基函数</h4><p><strong>使用GPU硬件滤波的表格重建质量较低，至少在一定程度上是由用于插值样本的双线性形状函数造成的。其他函数可以用来对重构样本进行加权。这种函数可能比双线性滤波产生更高质量的结果，而且它们可能还有其他优点。通常用于此目的的一组函数是球面径向基函数(SRBFs)。它们是径向对称的，这使得它们只有一个参数，即它们所指向的轴与计算方向之间的角度。基是由一组这样的函数组成的，这些函数被称为瓣，分布在整个球体上。函数的表示由每个叶的一组参数组成。这个集合可以包含它们的方向，但这会使投影变得更加困难(需要非线性、全局优化)。由于这个原因，波瓣方向通常被假定是固定的，均匀分布在整个球面上，并使用其他参数，如每个波瓣的大小或它的扩展，即覆盖的角度。重建是通过评估给定方向的所有瓣，并将结果相加来进行的。</strong></p>
<h4 id="Spherical-Gaussians-球形高斯函数"><a href="#Spherical-Gaussians-球形高斯函数" class="headerlink" title="Spherical Gaussians 球形高斯函数"></a>Spherical Gaussians 球形高斯函数</h4><p><strong>对于SRBF瓣，一个特别常见的选择是球形高斯分布(SG)，在方向统计中也称为von Mises-Fisher分布。我们应该注意到von-Mises-Fisher分布通常包含一个标准化常数，我们在公式中避免了这个常数。单个瓣可定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144331.png" class="" title="image-20211011144331">

<p><strong>其中v为评价方向(单位向量)，d为瓣方向轴(分布的均值，也归一化)，λ≥0为瓣锐度(控制其角宽，也称为浓度参数或扩散)。</strong></p>
<p><strong>为了构造球面基，我们使用给定数目的球面高斯函数的线性组合:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144344.png" class="" title="image-20211011144344">

<p><strong>将球函数投影到这个表示法中需要找到参数集合{wk,dk,λk}使重构错误最小化。这个过程通常是通过数值优化来完成的，通常使用非线性最小二乘优化算法(如Levenberg-Marquardt)。请注意，如果我们允许在优化过程中整组参数发生变化，我们就不会使用函数的线性组合，因此上方程并不代表一组基。只有选择一组固定的瓣(方向和扩展)，才能得到一个合适的基，使整个域都能很好地覆盖，并且只拟合权值wk进行投影．这样做也极大地简化了优化问题，因为现在它可以表述为普通的最小二乘优化。如果我们需要在不同的数据集(投影函数)之间进行插值，这也是一个很好的解决方案。在这种情况下，允许波瓣方向和锐度变化是有害的，因为这些参数是高度非线性的。</strong></p>
<p><strong>这种表述的优点是SGs的许多操作都有简单的解析形式。两个球面高斯函数的乘积是另一个球面高斯函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144501.png" class="" title="image-20211011144501">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144511.png" class="" title="image-20211011144511">

<p><strong>球面高斯函数的积分也可以通过解析计算:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144521.png" class="" title="image-20211011144521">

<p><strong>这意味着两个球面高斯积的积分也有一个简单的公式。</strong></p>
<p><strong>如果我们可以将光辐亮度表示为球面高斯函数，那么我们可以将其乘积与以相同表示形式编码的BRDF进行集成，以进行照明计算。由于这些原因，SGs在许多研究项目和工业应用中得到了应用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144625.png" class="" title="image-20211011144625">

<p>各向异性高斯球面。左:球体上的ASG和相应的自上而下的情节。右:ASG配置的其他四个例子，显示了公式的表现力。(徐坤图)</p>
<p><strong>对于平面上的高斯分布，von Mises-Fisher分布可以推广到允许各向异性。Xu等引入了各向异性球面高斯(ASGs;如上图所示)，其定义为在单方向d上加上两个补充轴t和b，共同构成一个正交切坐标系:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144700.png" class="" title="image-20211011144700">

<p><strong>其中λ，µ≥0控制波瓣沿正切坐标系的两轴展开，S(v, d) = (v·d)+为平滑项。这个术语是方向统计中使用的Fisher-Bingham分布和计算机图形学中使用的asg之间的主要区别。Xu等人还提供了积分、乘积和卷积算子的解析逼近。</strong></p>
<p><strong>尽管SGs有许多理想的属性，但它们的一个缺点是，与表格形式和一般有限范围(带宽)的内核不同，它们有全局支持。对于整个球体来说，每个波瓣都是非零的，尽管它的衰减相当快。这种全局范围意味着，如果我们使用N个瓣来表示一个函数，我们将需要所有N个瓣来在任何方向上进行重构。</strong></p>
<h4 id="Spherical-Harmonics-球面谐波"><a href="#Spherical-Harmonics-球面谐波" class="headerlink" title="Spherical Harmonics 球面谐波"></a>Spherical Harmonics 球面谐波</h4><p><strong>球面调和函数(SH)是球面上的一组正交基函数。基函数的正交集是这样一个集合，它使得任意两个不同函数的内积为零。内积是一个更一般，但类似于点积的概念。两个向量的内积是它们的点积:两个分量相乘的和。我们同样可以通过考虑两个函数相乘的积分，推导出两个函数的内积的定义:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144944.png" class="" title="image-20211011144944">

<p><strong>积分是在相关域上执行的。对于上上图所示的函数，相关的域在x轴上介于0和5之间(注意，这组函数是不正交的)。球面函数的形式略有不同，但基本概念是相同的:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144955.png" class="" title="image-20211011144955">

<p><strong>其中n∈Θ表示在单位球上进行积分。</strong></p>
<p><strong>标准正交集是一个正交集，其附加条件是集合中任意函数与自身的内积等于1。更正式地说，一组函数{fj()}是标准正交的条件是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011145006.png" class="" title="image-20211011145006">

<p><strong>下图显示了一个类似于上上图的例子，其中基函数是标准正交的。注意，下图所示的标准正交基函数不重叠。这个条件对于非负函数的标准正交集是必要的，因为任何重叠都意味着一个非零内积。函数在其部分范围内的负值可以重叠，并仍然形成一个标准正交集。这种重叠通常会导致更好的逼近，因为它允许基底平滑。不相交区域的基容易造成不连续。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011145109.png" class="" title="image-20211011145109">

<p>标准正交基函数。本示例使用与上上图相同的空间和目标函数，但基函数已被修改为标准正交。左边是目标函数，中间是基函数的标准正交集，右边是缩放后的基函数。对目标函数的近似结果用黑色虚线表示，原始函数用灰色表示以供比较。</p>
<p><strong>标准正交基的优点是找到与目标函数最接近的近似的过程是直接的。为了进行投影，每个基函数的系数都是目标函数ftarget()的内积具有适当的基函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011145207.png" class="" title="image-20211011145207">

<p><strong>在实践中，这个积分必须用数值计算，通常是通过蒙特卡罗采样，将均匀分布在球体上的n个方向平均。</strong></p>
<p><strong>标准正交基在概念上类似于4.2.4节中介绍的三维向量的“标准基”。标准基的目标不是函数，而是点的位置。标准基由三个向量(每维一个)组成，而不是一组函数。根据上上公式中使用的相同定义，标准基是标准正交的。将点投影到标准基上的方法也是一样的，因为系数是位置向量与基向量的点积的结果。一个重要的区别是，标准基精确地再现了每一个点，而有限的基函数集只能近似它的目标函数。结果永远不可能是精确的，因为标准基使用三个基向量来表示一个三维空间。一个函数空间有无限多的维数，所以有限的基函数永远不能完美地表示它。</strong></p>
<p><strong>球谐是正交的和标准正交的，它们还有其他一些优点。它们是旋转不变的，并且SH基函数的计算成本不高。它们是单位长度向量的x、y和z坐标上的简单多项式。然而，像球面高斯函数一样，它们具有全局支持，因此在重建过程中需要评估所有的基函数。基函数的表达式可以在一些参考文献中找到，包括Sloan的陈述。他的介绍值得注意的是，它讨论了许多使用球面谐波的实用技巧，包括公式，在某些情况下，着色器代码。最近，Sloan还发现了进行SH重建的有效方法。</strong></p>
<p><strong>SH基函数按频带排列。第一个基函数是常数，接下来的三个是线性函数，在球面上变化缓慢，接下来的五个是二次函数，变化稍微快一些。参见下图。频率较低的函数(例如。例如辐照度值，可以用相对较少的SH系数精确地表示(我们将在第10.6.1节中看到)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011145324.png" class="" title="image-20211011145324">

<p>球谐的前五个频带。每个球谐函数都有正的区域(绿色)和负的区域(红色)，当它们接近零时逐渐变黑。(罗宾·格林提供的球面调和可视化。)</p>
<p><strong>当投影到球谐时，得到的系数代表投影函数的各种频率的振幅，即它的频谱。在这个谱域，有一个基本的性质:两个函数的乘积的积分等于函数投影系数的点积。这个属性允许我们高效地计算光照积分。</strong></p>
<p><strong>球面谐波的许多运算在概念上很简单，可以归结为系数向量上的矩阵变换。在这些操作中，计算投影到球谐的两个函数的乘积、旋转投影函数和计算卷积是很重要的例子。在实际中，SH中的矩阵变换意味着这些操作的复杂性是所使用的系数数量的二次，这可能是一个巨大的代价。幸运的是，这些矩阵通常有特殊的结构，可以用来设计更快的算法。Kautz等人提出了一种优化旋转计算的方法，将它们分解为围绕x轴和z轴的旋转。Hable给出了一种流行的快速旋转低阶SH投影的方法。Green的调查讨论了如何利用旋转矩阵的块结构来更快地计算。目前的技术状态是通过分解成带状谐波来表示的，如Nowrouzezahrai等人所提出的。</strong></p>
<p><strong>谱变换的一个常见问题，如下面描述的球谐和h基，是它们可以表现出一种视觉伪影，称为振铃(也称为吉布斯现象)。如果原始信号包含不能用带限近似表示的快速变化，重构将显示出振荡。在极端情况下，这个重建函数甚至可以产生负值。可以使用各种预过滤方法来解决这个问题。</strong></p>
<h4 id="Other-Spherical-Representations-其他球形表示"><a href="#Other-Spherical-Representations-其他球形表示" class="headerlink" title="Other Spherical Representations 其他球形表示"></a>Other Spherical Representations 其他球形表示</h4><p><strong>使用有限数目的系数可以对球函数进行编码。线性变换余弦(第10.1.2节)是一个例子，它可以有效地近似BRDF函数，同时具有在球体的多边形截面上易于积分的特性。</strong></p>
<p><strong>球面小波是一种平衡空间局部(具有紧密的支持)和频率(平滑)的基，允许高频函数的压缩表示。球形分段常数基函数将球体划分成常值区域，以及依赖矩阵分解的双簇近似]，也被用于环境照明。</strong></p>
<h3 id="Hemispherical-Bases-基于半球"><a href="#Hemispherical-Bases-基于半球" class="headerlink" title="Hemispherical Bases 基于半球"></a>Hemispherical Bases 基于半球</h3><p><strong>尽管上述碱基可以用来表示半球函数，但它们是浪费的。信号的一半总是等于零。在这些情况下，通常首选使用直接在半球域上构造的表示。这对于定义在表面上的函数尤其相关:BRDF、入射辐亮度和到达物体给定点的辐照度都是常见的例子。这些函数自然地局限于以给定曲面点为中心的半球，并与曲面法线对齐;它们没有指向对象内部方向的值。</strong></p>
<h4 id="Ambient-Highlight-Direction-环境-高光-方向"><a href="#Ambient-Highlight-Direction-环境-高光-方向" class="headerlink" title="Ambient/Highlight/Direction 环境/高光/方向"></a>Ambient/Highlight/Direction 环境/高光/方向</h4><p><strong>沿着这些线最简单的表述之一是一个常数函数和一个单一方向的组合，在这个方向上，信号在半球最强。它通常被称为环境/高光/方向(AHD)基础，它最常见的用途是存储辐照度。AHD的名称代表了单个组件所代表的:一个恒定的环境光，加上一个方向光，该方向近似于“高光”方向的辐照度，以及大部分入射光集中的方向。AHD基础通常需要存储八个参数。两个角度用于方向向量，两种RGB颜色用于环境光和方向光强度。它的首次显著应用是在《雷神之锤3》中，即以这种方式存储动态对象的体光。从那时起，它便被用于许多游戏中，如《使命召唤》系列。</strong></p>
<p><strong>在这个表示法上的投影有点棘手。因为它是非线性的，寻找近似给定输入的最优参数是昂贵的计算。在实践中，使用的是启发式。首先将信号投影到球面谐波，并利用最优线性方向来定位余弦瓣。给定方向，环境值和亮点值可以使用最小二乘最小化计算。Iwanicki和Sloan展示了如何在执行非负向时执行这种投射。</strong></p>
<h4 id="Radiosity-Normal-Mapping-Half-Life-2-Basis-辐射法向映射-基于半条命2"><a href="#Radiosity-Normal-Mapping-Half-Life-2-Basis-辐射法向映射-基于半条命2" class="headerlink" title="Radiosity Normal Mapping/Half-Life 2 Basis 辐射法向映射/基于半条命2"></a>Radiosity Normal Mapping/Half-Life 2 Basis 辐射法向映射/基于半条命2</h4><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011150039.png" class="" title="image-20211011150039">

<p>《半条命2》照明基础。这三个基向量的仰角约为26◦在切平面以上，他们的投影到该平面的间隔为120◦ 在正常区间的间隔。它们是单位长度，每一个都垂直于另外两个。</p>
<p><strong>Valve为《半条命2》系列游戏使用了一种新颖的表示方法，即在辐射法向映射的背景下表达方向辐照度。它最初设计用于存储预计算的漫反射光照，同时允许法线映射，现在被称为《半条命2》的基础。它通过在切线空间的三个方向上采样来表示曲面上的半球函数。参见上图。这三个相互垂直的基向量在切空间中的坐标是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011150129.png" class="" title="image-20211011150129">

<p><strong>对于重建，给定切空间方向d，我们可以插值E0,E1和E2沿三个基向量:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011150139.png" class="" title="image-20211011150139">

<p><strong>Green指出，如果改为在切空间方向d上预先计算以下三个值，则上式的代价会大大降低:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011150149.png" class="" title="image-20211011150149">

<p><strong>对于k = 0,1,2。式上上化简为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011150159.png" class="" title="image-20211011150159">

<p><strong>Green描述了这种表示的其他几个优点，其中一些将在第11.4节中讨论。</strong></p>
<p><strong>《半条命2》的基础可以很好地用于定向辐照度。 Sloan发现这种表示产生的结果优于低阶半球谐波。</strong></p>
<h4 id="Hemispherical-Harmonics-H-Basis-半球形谐波-H-Basis"><a href="#Hemispherical-Harmonics-H-Basis-半球形谐波-H-Basis" class="headerlink" title="Hemispherical Harmonics/H-Basis 半球形谐波/ H-Basis"></a>Hemispherical Harmonics/H-Basis 半球形谐波/ H-Basis</h4><p><strong>Gautron等人将球面谐波专门用于半球域，他们称之为半球谐波(HSHs)。可以使用各种方法来执行这种专门化。</strong></p>
<p><strong>例如，泽尼克多项式是正交函数，类似于球面调和函数，但定义在单位圆盘上。与SH一样，这些可以用于在频域(频谱)上变换函数，这产生了许多方便的性质。由于可以将一个单位半球转化为一个圆盘，因此可以用泽尼克多项式来表示半球函数。然而，用这些材料进行重建是相当昂贵的。Gautron等人的解决方案既更经济，又允许系数向量上的矩阵乘法进行相对快速的旋转。</strong></p>
<p><strong>然而，HSH基的评估仍然比球面谐波更昂贵，因为它是通过将球体的负极移到半球的外边缘来构建的。这种移位操作使得基本函数是非多项式的，需要计算除法和平方根，这在GPU硬件上通常是很慢的。此外，基底在半球边缘始终是恒定的，因为它映射到球上的一个点之前的移动。近似误差可能是相当大的附近的边缘，特别是如果只有几个系数(球谐带)使用。</strong></p>
<p><strong>Habel引入了H基，H基部分用于纵向参数化球面调和基，部分用于纵向参数化HSH。这个基础，一个混合了移位和非移位的SH版本，仍然是正交的，同时允许有效的评估。</strong></p>
<h2 id="Environment-Mapping-环境映射"><a href="#Environment-Mapping-环境映射" class="headerlink" title="Environment Mapping 环境映射"></a>Environment Mapping 环境映射</h2><p><strong>在一个或多个图像中记录一个球形函数被称为环境映射，因为我们通常使用纹理映射来实现表中的查找。这种表现形式是最强大和最流行的环境照明形式之一。与其他球形表示法相比，它消耗更多内存，但实时解码简单快速。此外，它可以表达任意高频率的球面信号(通过提高纹理的分辨率)，并能准确捕获任意频率的球面信号环境辐射范围(通过增加每个通道的比特数)。这样的准确性是有代价的。不同于存储在其他常用纹理中的颜色和着色器属性，存储在环境地图中的亮度值通常具有较高的动态范围。每像素的比特数越多，环境地图就会比其他纹理占用更多空间，访问速度也会更慢。</strong></p>
<p><strong>对于任何全局球函数，我们都有一个基本的假设，即用于场景中的所有物体，即入射亮度Li 只取决于方向。这个假设要求被反射的物体和光线在很远的地方，而且反射器不会反射自己。</strong></p>
<p><strong>依赖于环境映射的着色技术通常不以它们代表环境照明的能力为特征，而是通过我们如何将它们与给定的材料整合。也就是说，为了完成积分，我们必须对BRDF采用什么样的近似和假设?反射映射是环境映射的最基本情况，在这种情况下，我们假设BRDF是一个完美的镜像。光学平面或镜面将入射光线反射到光的反射方向ri (9.5节)。同样地，出射辐亮度只包括来自一个方向的入射辐亮度，即反射视图向量r。这个向量的计算方法与ri 相同方程(9.15):</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012135509.png" class="" title="image-20211012135509">

<p><strong>反射镜的反射方程大大简化:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012135526.png" class="" title="image-20211012135526">

<p><strong>其中F是菲涅耳项(第9.5节)。注意,与菲涅耳上一半基于矢量的双向反射(使用半矢量之间的夹角h和l或者v),菲涅耳方程上式术语使用曲面法线之间的夹角n和反射向量r (n和v之间的角度是一样的)。</strong></p>
<p><strong>因为入射亮度Li 只依赖于方向，它可以存储在一个二维表中。这种表示使我们能够有效地用任意入射亮度分布的任何形状的镜面。我们计算每个点的r值，并在表中查找亮度。这个表被称为环境地图，由Blinn和Newell提出。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012135723.png" class="" title="image-20211012135723">

<p>反射的映射。查看器看到一个对象，反射视图向量r由v和n计算得到。反射视图向量访问环境的表示。通过使用一些投影仪函数来计算访问信息，将反射视图向量(x, y, z)转换为纹理坐标，用于检索环境的存储亮度。</p>
<p><strong>反射映射算法的步骤如下:</strong> </p>
<pre><code>**•生成或加载一个代表环境的纹理。**

**•对于每个包含反射物体的像素，计算物体表面位置的法线。**

**•从视图向量和法线计算反射视图向量。**

**•使用反射视图向量在环境地图中计算一个索引，该索引表示反射视图方向的入射亮度。**

**•使用环境地图中的texel数据作为上方程中的入射亮度。** 
</code></pre>
<p><strong>值得一提的是环境映射的一个潜在障碍。当使用环境映射时，平面通常不能很好地工作。一个平面的问题是，从它反射回来的光线变化通常不超过几度。这种紧密的集群导致环境表的一小部分被映射到一个相对较大的表面上。在第11.6.1节中讨论的同样使用辐射的位置信息的技术可以得到更好的结果。此外，如果我们假设表面是完全平坦的，例如地板，则可以使用平面反射的实时技术(第11.6.2节)。</strong></p>
<p><strong>用纹理数据照亮场景的想法也被称为基于图像的照明(IBL)，通常是通过相机捕捉360度全景、高动态范围的图像从真实场景中获得环境地图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012135936.png" class="" title="image-20211012135936">

<p>一个光(在相机)结合凹凸和环境映射。从左到右:没有环境映射，没有凹凸映射，没有相机上的光，三者结合起来。(图片生成自three.js示例webgl materials displacementmap，模型来自AMD GPU MeshMapper。)</p>
<p><strong>使用环境映射和法线映射特别有效，可以产生丰富的视觉效果。参见上图。这些特征的组合在历史上也很重要。颠簸环境映射的一种受限形式是在消费级图形硬件中首次使用依赖纹理读取(章节6.2)，这使得这种能力成为像素着色器的一部分。</strong></p>
<p><strong>有许多投影仪功能可以将反射的视图向量映射到一个或多个纹理中。我们在这里讨论更流行的映射，并指出每种映射的优点。</strong></p>
<h3 id="Latitude-Longitude-Mapping-经度映射"><a href="#Latitude-Longitude-Mapping-经度映射" class="headerlink" title="Latitude-Longitude Mapping 经度映射"></a>Latitude-Longitude Mapping 经度映射</h3><p><strong>1976年，Blinn和Newell开发了第一个环境映射算法。他们使用的地图是地球上常见的经纬度系统这就是为什么这种技术通常被称为纬度-经度映射或后期-长映射。他们的方案不像从外面看的地球仪，而是像夜空中星座的地图。就像地球仪上的信息可以被平铺成墨卡托或其他投影地图一样，空间中某个点周围的环境也可以被映射到纹理上。当一个反射视图矢量计算一个特定的表面位置，矢量转换为球坐标(ρ， φ)。这里的φ，相当于经度，从0到2π弧度变化，而ρ，相当于纬度，从0到π弧度变化。对(ρ， φ)由下式计算，其中r = (rx, ry, rz)是正规化的反射视图向量，+z向上:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012140309.png" class="" title="image-20211012140309">

<p><strong>有关atan2的描述，请参阅第8页。然后使用这些值访问环境地图，并检索在反射视图方向上看到的颜色。请注意经纬度映射与墨卡托投影不同。它保持纬度线之间的距离不变，而墨卡托在两极趋于无穷。</strong></p>
<p><strong>为了将球体展开成一个平面，某些扭曲总是必要的，特别是如果我们不允许多次切割，并且每个投影在保留面积、距离和局部角度之间都有自己的权衡。这种映射的一个问题是，信息的密度是不均匀的。从下图的顶部和底部的极端拉伸可以看出，靠近两极的区域接收到的texel要比靠近赤道的区域多得多。这种失真是有问题的，不仅因为它不能产生最有效的编码，而且当使用硬件纹理过滤时，它还会产生伪影，尤其是在两极奇点处。滤波核不跟随纹理的拉伸，从而有效地收缩纹理密度较高的区域。还要注意投影数学是简单的，它可能不是有效的，因为超越函数，如arccosine在GPUs上是昂贵的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012140431.png" class="" title="image-20211012140431">

<p>与传统的墨卡托投影相反，地球的纬度和经线等间距。(图片来自NASA的“蓝色大理石”系列。)</p>
<h3 id="Sphere-Mapping-球体映射"><a href="#Sphere-Mapping-球体映射" class="headerlink" title="Sphere Mapping 球体映射"></a>Sphere Mapping 球体映射</h3><p><strong>最初由Williams提出，由Miller和Hoffman独立开发，球体映射是第一种通用商业图形硬件支持的环境映射技术。纹理图像来自环境的外观，就像在一个完全反射的球体中以正投影的方式观察的那样，所以这个纹理被称为球体地图。制作真实环境的球体地图的一种方法是给发光的球体拍照，比如圣诞树装饰。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012140639.png" class="" title="image-20211012140639">

<p>球面映射(左)和经纬度格式的等效映射(右)。</p>
<p><strong>由此产生的圆形图像也被称为光探测器，因为它捕获了球体所在位置的照明情况。拍摄球形探头是一种有效的方法方法来捕获基于图像的光照，即使我们在运行时使用其他编码。我们总是可以在球面投影和另一种形式之间进行转换，例如后面讨论的立方体映射(章节10.4.3)，如果捕获有足够的分辨率来克服方法之间的失真差异。</strong></p>
<p><strong>一个反射球体仅仅在球体的前面显示整个环境。它将每个反射的视图方向映射到这个球体的二维图像上的一个点。假设我们想去另一个方向，给定球面地图上的一个点，我们想要反射视图的方向。为了做到这一点，我们将在球面上取那个点的表面法线，然后生成反射视图方向。因此，为了反转这个过程并从反射视图向量中获得球面上的位置，我们需要推导球面上的表面法线，这将产生访问球面映射所需的(u, v)参数。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012140757.png" class="" title="image-20211012140757">

<p>给定恒定的视图方向v和球面映射空间中的反射视图向量r，球面映射的法线n在两者之间。对于原点处的单位球，交点h与单位法线n有相同的坐标y (从原点测量)和球体贴图纹理坐标v(不要与视图向量v混淆)是相关的。</p>
<p><strong>球面法线是反射视图向量r和原始视图向量v之间的半角向量，在球面映射空间中为(0,0,1)。参见上图。这个法向量n是原始视图向量和反射视图向量的和，即(rx, ry, rz + 1)。 正规化这个向量得到单位法线:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012140912.png" class="" title="image-20211012140912">

<p><strong>如果球面在原点，半径为1，那么单位法线坐标也就是球面上法线的位置h。我们不需要hz, (hx,hy)描述球面图像上的一个点，每个值都在范围[−1,1]。要将这个坐标映射到范围[0,1)以访问球体映射，每一个都除以2，并加上一半:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012140953.png" class="" title="image-20211012140953">

<p><strong>与经纬度映射相比，球面映射计算起来要简单得多，并且显示了一个位于图像圆边缘的奇异点。缺点是球体贴图纹理捕获的环境视图只对单个视图方向有效。这个纹理确实捕获了整个环境，所以可以计算一个新的观察方向的纹理坐标。然而，这样做可能会导致视觉伪影，因为球体地图的一小部分由于新视图而被放大，边缘周围的奇异点变得明显。在实践中，球面地图通常被假定跟随摄像机，在视图空间中操作。</strong></p>
<p><strong>由于球面映射定义为一个固定的视图方向，原则上球面映射上的每个点不仅定义了一个反射方向，而且还定义了一个表面法线。参见上图。对于任意的各向同性BRDF，可以求解反射方程，并将其结果存储在球面映射中。这个BRDF可以包括漫反射、镜面反射、反反射和其他术语。只要照明和视图方向是固定的，球面地图就会是正确的。只要球体的BRDF是均匀且各向同性的，就可以使用在实际光照下的真实球体的摄影图像。</strong></p>
<p><strong>它也可以索引两个球面地图，一个是反射矢量，另一个是表面法线，以模拟高光和漫反射环境效果。如果我们调整存储在球体贴图中的值，以考虑表面材料的颜色和粗糙度，我们就有了一种廉价的技术，可以生成令人信服的(尽管与视图无关)材料效果。这种方法是通过雕刻软件Pixologic ZBrush作为“MatCap”着色来推广的。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141111.png" class="" title="image-20211012141111">

<p>“MatCap”渲染的例子。左边的对象使用右边的两个球面贴图进行着色。顶部的映射使用视图空间的法向量进行索引，而底部的映射使用视图空间的反射向量，并将两者的值相加。结果效果是相当令人信服的，但移动视点将揭示照明环境遵循相机的坐标框架。</p>
<h3 id="Cube-Mapping-立方体映射"><a href="#Cube-Mapping-立方体映射" class="headerlink" title="Cube Mapping 立方体映射"></a>Cube Mapping 立方体映射</h3><p><strong>1986年，Greene引入了立方体环境地图，通常称为立方体映射。这种方法是目前最流行的方法，它的投影直接在硬件上实现在现代GPUs上。立方体地图是通过将环境投影到立方体的侧面而创建的，立方体的中心位于摄像机的位置。立方体表面上的图像随后被用作环境地图。见下两图。立方体映射通常以“交叉”图的形式显示，即打开立方体并把它压平。然而，在硬件上，立方体映射被存储为6个方形纹理，而不是一个单一的矩形纹理，所以没有浪费空间。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141332.png" class="" title="image-20211012141332">

<p>插图格林的环境地图，并显示关键点。左边的立方体将展开到右边的环境地图中。</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141342.png" class="" title="image-20211012141342">

<p>与之前图中使用的环境地图相同，转换为立方体映射格式。</p>
<p><strong>有可能创建立方体地图综合渲染场景六次与相机在立方体的中心，看着每个立方体的面与90◦视图角度。参见下图。为了从真实环境中生成立方体地图，通常将通过拼接或专用摄像机获得的球形全景投影到立方体地图坐标系统中。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141506.png" class="" title="image-20211012141506">

<p>《极限竞速7》中的环境地图照明会随着汽车位置的改变而更新。(图片由微软Turn 10 Studios提供。)</p>
<p><strong>与球面映射不同，立方体环境映射与视图无关。它也比经纬度制图具有更均匀的采样特征，经纬度制图对两极进行采样，而不是赤道。Wan等人提出了一种称为等立方的映射，它比立方体映射的采样率差更低，同时仍然利用立方体映射纹理硬件来提高性能。</strong></p>
<p><strong>访问多维数据集映射很简单。任何向量都可以直接作为一个三分量的纹理坐标来获取它所指向的方向上的数据。所以，对于反射，我们可以把反射的视图向量r传递给GPU，甚至不需要标准化它。在较老的GPUs上，双线性过滤可以显示立方体边缘的接缝，因为纹理硬件无法正确地过滤不同的立方体面(这个操作执行起来有点昂贵)。为了避免这个问题，我们开发了一些技术，比如让视图投影更宽一些，这样单个面就可以包含这些相邻的像素。所有现代GPUs现在都可以正确地执行这种过滤，所以这些方法不再是必要的。</strong></p>
<h3 id="Other-Projections-其他预测"><a href="#Other-Projections-其他预测" class="headerlink" title="Other Projections 其他预测"></a>Other Projections 其他预测</h3><p><strong>如今，立方体地图是最受欢迎的环境照明表格表示法，因为它的通用性、再现高频细节的准确性以及在GPU上的执行速度。然而，还有一些其他的预测也值得一提。</strong></p>
<p><strong>Heidrich和Seidel提出使用两种纹理来执行双抛物面环境映射。这个想法就像球面映射，但不是通过记录环境在球面上的反射来生成纹理，而是使用了两个抛物线投影。每个抛物面创建一个类似于球体地图的圆形纹理，每个都覆盖一个环境半球。</strong></p>
<p><strong>与球面映射一样，反射视图射线是在地图的基础上计算的，即在其参照系中。反射视图向量的z分量符号用来决定访问两个纹理中的哪个。访问函数是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141813.png" class="" title="image-20211012141813">

<p><strong>对于前面的图像，同样的，r的符号倒转z，用于背面图像。</strong></p>
<p><strong>与球体地图甚至立方体地图相比，抛物线地图具有更均匀的环境纹理采样。然而，必须注意在两个投影之间的接缝处进行适当的采样和插值，这使得访问双抛物面映射更加昂贵。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141855.png" class="" title="image-20211012141855">

<p>球体的立方体映射展开(左)与八面体展开(右)比较。(以尼米兹的Shadertoy命名。)</p>
<p><strong>八面体映射是另一个值得注意的投影。它不是将周围的球体映射到一个立方体，而是映射到一个八面体(参见上图)。为了把这个几何形状变平，它的八个三角形面被切割并安排在一个平面上。正方形或矩形结构都是可能的。如果我们使用正方形结构，访问八面体映射的数学方法是非常有效的。给定一个反射方向r，我们用L1 绝对值规范:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141958.png" class="" title="image-20211012141958">

<p><strong>对于r′y 是正的，我们可以用</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012142007.png" class="" title="image-20211012142007">

<p><strong>在r′y 为负时，我们需要用变换将八面体的后半部分向外“折叠”</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012142017.png" class="" title="image-20211012142017">

<p><strong>八面体映射不受对偶抛物面映射的过滤问题的影响，因为参数化的接缝与使用的纹理的边缘相对应。纹理“环绕”采样模式可以自动从另一边访问texels，并执行正确的插值。虽然用于投影的数学方法稍微复杂一些，但在实践中表现得更好。引入的失真量与立方体映射相似，所以当立方体映射纹理硬件不存在时，八面体映射是一个很好的选择。另一个值得注意的用途是仅使用两个坐标表示三维方向(标准化向量)，作为压缩的平均值(第16.6节)。</strong></p>
<p><strong>对于围绕对称轴径向对称的环境地图的特殊情况，Stone提出了一种简单的分解方法，使用单一的一维纹理存储从对称轴出发的任何子午线上的亮度值。他将这个方案扩展到二维纹理，在每一行存储一个环境地图，用不同的Phong瓣预卷积。这种编码可以模拟多种材料，并被用于编码从晴朗的天空发射的辐射。</strong></p>
<h2 id="Specular-Image-Based-Lighting-基于图像的镜面光照"><a href="#Specular-Image-Based-Lighting-基于图像的镜面光照" class="headerlink" title="Specular Image-Based Lighting 基于图像的镜面光照"></a>Specular Image-Based Lighting 基于图像的镜面光照</h2><p><strong>虽然环境映射最初是作为一种绘制镜面表面的技术开发的，但它也可以扩展到光滑的反射。当用于模拟无限远光源的一般镜面效果时，环境地图也被称为镜面光探测器。之所以使用这个术语，是因为它们在场景中给定的点捕捉到来自各个方向的辐亮度(从而探测)，并利用这些信息来评估一般BRDFs——而不仅仅是局限于纯镜子或朗伯曲面的情况。高光立方体贴图的名字也用于存储环境照明的立方体贴图，这些立方体贴图被操纵来模拟在光滑材料上的反射。</strong></p>
<p><strong>为了模拟表面粗糙度，可以对纹理中的环境表示进行预过滤。通过模糊环境贴图纹理，我们可以呈现一个镜面反射，看起来比完美的镜面反射更粗糙。这种模糊应以非线性的方式进行，即不同部位的纹理应该有不同的模糊。这种调整是必要的，因为环境贴图纹理表示具有到理想球面空间方向的非线性映射。两个相邻像素中心之间的角距离不是恒定的，单个像素所覆盖的立体角也不是恒定的。预处理立方体地图的专门工具，如AMD的CubeMapGen(现在是开源的)，在过滤时会考虑这些因素。来自其他人脸的邻近样本被用来创建mipmap链，并且每个texel的角度范围被考虑在内。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012142244.png" class="" title="image-20211012142244">

<p>在顶部，原始的环境地图(左)和着色结果应用于一个球体(右)。在底部，使用高斯核模糊相同的环境地图模拟粗糙材质的外观。</p>
<p><strong>模糊的环境地图，虽然经验接近粗糙表面的外观，与实际的BRDF没有联系。一个更有原则的方法是当考虑给定的表面法线和视图方向时，考虑BRDF函数在球体上的形状。然后我们使用这个分布来筛选环境映射。参见下图。用镜面波瓣对环境地图进行过滤不是简单的，因为BRDF可以假设任何形状，这取决于它的粗糙度参数以及视图和法向量。至少有五个维度的输入值(粗糙度和两个极角的视图和法线方向)来控制得到的瓣形状。为其中的每个选择存储多个环境映射是不可行的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012142331.png" class="" title="image-20211012142331">

<p>左图显示了从一个对象反射的眼球光线，以从一个环境纹理(在本例中是一个立方体映射)获得一个完美的镜面反射。右图显示了反射视图射线的镜面波瓣，它被用来采样环境纹理。绿色的正方形代表立方体地图的横截面，红色的勾号表示像素之间的边界。</p>
<h3 id="Prefiltered-Environment-Mapping-预过滤环境映射"><a href="#Prefiltered-Environment-Mapping-预过滤环境映射" class="headerlink" title="Prefiltered Environment Mapping 预过滤环境映射"></a>Prefiltered Environment Mapping 预过滤环境映射</h3><p><strong>应用于光滑材料的环境照明的预过滤的实际实现需要近似BRDF使用，从而产生纹理独立于视图和法向量。如果我们限制BRDF的形状变化仅为材料光泽度，我们可以计算和存储一些环境地图对应的不同选择的粗糙度参数，并选择一个合适的在运行时使用。在实践中，这意味着限制我们使用的模糊核，从而使瓣形状围绕反射向量径向对称。</strong></p>
<p><strong>想象一些光线从一个给定的反射视图方向射入。直接来自反射视图方向的光将提供最大的贡献，随着入射光的方向与反射视图方向的差异越来越大而衰减。环境地图texel的面积乘以texel的BRDF贡献给出了这个texel的相对效果。这个加权贡献乘以环境地图texel的颜色，并将结果相加，计算q。加权贡献的总和，也计算s。最终的结果，q/s，是在反射视图方向的波瓣上集成的整体颜色，并存储在生成的反射映射中。</strong></p>
<p><strong>如果我们使用Phong材料模型，径向对称假设自然成立，我们可以几乎准确地计算环境照明。Phong通过经验推导出了他的模型，与我们在9.8节中看到的BRDFs相比，没有物理动机。冯氏的模型和Blinn-Phong双向9.8.1正余弦叶节中我们讨论了提高力量,但在冯氏着色的情况下,cos是由反射的点积向量方程(9.15)和视图,而不是一半的向量方程(见9.33)和正常的。这使得反射波瓣是旋转对称的。请参见第338页图9.35。</strong></p>
<p><strong>有一个径向对称的镜面波瓣，这是我们唯一还不能理解的效果适应，因为它使瓣形状依赖于视图方向，是水平剪切。想想看一个闪亮的球体(不是镜面)。观察球体表面的中心，会得到一个对称的峰瓣。观察附近的表面球体的轮廓在现实中必须被切掉一部分，因为地平线以下的光线无法照射到眼睛。参见下图。这与我们之前讨论区域照明近似时(第10.1节)看到的问题相同，但在实践中，实时方法经常忽略它。这样做会导致过度明亮的着色在掠角。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012144914.png" class="" title="image-20211012144914">

<p>两个观察者看到一个闪亮的球体。球体上的不同位置为两个观察者提供相同的反射视图方向。左侧观察者的表面反射采样一个对称瓣。右方观察者的反射波瓣必须被表面本身的视界切掉，因为光线不能从视界以下的表面反射出去。</p>
<p><strong>Heidrich和Seidel以这种方式使用单个反射映射来模拟表面的模糊。为了适应不同的粗糙度水平，通常使用环境立方体地图的mipmaps(章节6.2.2)。每一级用于存储入射亮度的模糊版本，较高的mip级存储粗糙的表面，即更宽的Phong叶。在运行时，我们可以通过使用反射向量来处理立方体映射，并根据期望的Phong指数(材料粗糙度)强制选择给定的mip水平。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012145014.png" class="" title="image-20211012145014">

<p>环境地图前置过滤。将立方体映射与不同粗糙度的GGX叶进行卷积，并将卷积结果存储在纹理mip链中。随着粗糙度从左到右的减少，最终的纹理mips显示在底部，一个球体被渲染在上面以反射矢量的方向访问它们。</p>
<p><strong>粗糙材料使用的更宽的过滤区域可以去除高频，因此需要更低的分辨率才能得到充分的结果，这与mipmap结构完美地对应。此外，通过使用GPU硬件的三线性滤波，可以在预滤波的mip水平之间进行采样，模拟我们没有确切表示的粗糙度值。当与菲涅耳术语结合在一起时，这种反射映射对光滑表面似乎很有效。</strong></p>
<p><strong>出于性能和走样的原因，选择要使用的mipmap级别不仅要考虑着色点的材质粗糙度，还要考虑被着色像素覆盖的表面面积上的法线和粗糙度的变化。Ashikhmin Ghosh指出,为达到最佳效果,两个候选人产生的指数水平(缩小级别计算纹理硬件和对应于当前过滤器宽度)应该相比,和应该使用低分辨率产生水平指数。为了更加准确，应该考虑表面方差的扩大效应，并使用一个新的粗糙度水平，对应于一个BRDF瓣，该瓣在像素足迹中最适合的平均值，应该使用。这个问题与BRDF抗锯齿(章节9.13.1)完全相同，也适用相同的解决方案。</strong></p>
<p><strong>前面提出的滤波方案假设在给定的反射视图方向上的所有瓣都是相同的形状和高度。这个假设也意味着叶瓣必须是径向对称的。除了视界上的问题，大多数BRDFs在所有角度上都没有均匀的径向对称瓣。例如，在掠角时，叶片往往会变得更尖锐和更薄。此外，叶的长度通常随仰角而变化</strong></p>
<p><strong>这种效果对于曲面通常是看不出来的。然而，对于像地板这样的平面，径向对称滤波器可能会引入明显的误差。(参见第338页的图9.35)</strong></p>
<h4 id="Convolving-the-Environment-Map-卷积环境地图"><a href="#Convolving-the-Environment-Map-卷积环境地图" class="headerlink" title="Convolving the Environment Map 卷积环境地图"></a>Convolving the Environment Map 卷积环境地图</h4><p><strong>生成预过滤的环境地图意味着计算每一个texel，对应一个方向v，环境辐射与镜面的积分lobe D:</strong> </p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012145352.png" class="" title="image-20211012145352">

<p><strong>这个积分是一个球面卷积，通常不能用解析的方法来执行，如Li，对于环境地图，仅以表格形式知道。一种流行的数值解是采用蒙特卡罗方法:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012145400.png" class="" title="image-20211012145400">

<p><strong>其中lk 对于k = 1,2，…， N为单位球(方向)上的离散样本， 和p(lk， v)是在lk方向上生成样本的概率函数．如果我们对球均匀采样，那么p(lk， v)总是= 1。虽然这个总和对于我们想要积分的每个方向v都是正确的，但在将结果存储到环境地图中时，我们还必须考虑到投影带来的失真，通过对每个计算texel所对应的立体角进行加权(参见Driscoll)。</strong></p>
<p><strong>虽然蒙特卡罗方法简单正确，但它可能需要大量的样本才能收敛到积分的数值，即使是离线过程也会很慢。这种情况在mipmap的第一级尤其明显，在这里我们编码浅镜面叶(Blinn-Phong为高指数，Cook-Torrance为低粗糙度)。我们不仅需要计算更多的像素(因为我们需要存储高频细节的分辨率)，而且对于不接近完美反射的方向，波瓣可能接近于零。大多数样本都被“浪费”了，就像D(lk，v)≈0。</strong></p>
<p><strong>为了避免这种现象，我们可以使用重要采样，我们用概率分布生成方向，试图匹配镜面瓣的形状。这样做是蒙特卡罗积分的一种常见的方差减少技术，重要度抽样策略存在于最常用的叶型中。为了更有效的采样方案，还可以结合镜面瓣的形状来考虑环境图中辐射度的分布。然而，所有依赖于点采样的技术通常只用于离线渲染和地面真实模拟，因为通常需要数百个样本。</strong></p>
<p><strong>为了进一步减小采样方差(即我们也可以估计样本之间的距离和积分使用锥的和，而不是单一的方向。使用锥体对环境地图进行采样可以通过对其mip水平之一进行点采样来近似，选择其像素大小跨越与锥体相似的立体角的水平。这样做会引入偏差，但它允许我们大大减少实现无噪声结果所需的样本数量。这种类型的采样可以在GPU的帮助下以交互速率进行。</strong></p>
<p><strong>同样利用区域样本，McGuire等人开发了一种技术，旨在实时逼近与镜面波瓣的卷积结果，而不需要任何预计算。这个过程是通过明智地混合非预过滤环境立方体映射的多个mipmap级别来实现的，以重建Phong瓣的形状。类似地，Hensley等人使用求和面积表(章节6.2.2)来快速进行近似。McGuire et al.和Hensley et al.的技术在技术上都不是没有任何预计算的，因为在渲染一个环境地图之后，他们仍然需要我们分别生成mip级别或前缀和。对于这两种情况，都存在有效的算法，因此所需的预计算要比执行全镜面波瓣卷积快得多。这两种技术都足够快，甚至可以实时用于环境照明的表面着色，但它们不如其他依赖于临时预滤波的方法准确。</strong></p>
<p><strong>Kautz等人提出了另一种变体，一种快速生成滤波抛物面反射图的分层技术。最近，Manson和Sloan使用一种有效的二次B样条滤波方案来生成环境地图的mip水平，显著改进了这一技术。这些经过特别计算的B样条滤波的mips然后通过结合少量样本使用，类似于McGuire等人和Kautz等人的技术，以产生快速而准确的近似。这样做可以生成实时的结果，这些结果与通过重要性采样蒙特卡罗技术计算的地面真实值难以区分。</strong></p>
<p><strong>快速卷积技术允许实时更新预过滤的立方体映射，当我们想要过滤的环境映射被动态渲染时，这是必要的。使用环境地图通常会让物体在不同的光照环境中移动变得困难，例如，从一个房间到另一个房间。立方环境贴图可以在帧与帧之间动态生成(或每隔几帧生成一次)，所以如果采用有效的滤波方案，交换新的镜面反射贴图是相对便宜的。</strong></p>
<p><strong>另一种替代方法是重新生成完整的环境贴图，将动态光源的高光添加到静态的基础环境贴图上。添加的高光可以被添加到预过滤的基础环境地图上的预过滤“斑点”。这样做可以避免在运行时进行任何过滤。限制是由于环境映射的假设，光线和反射的物体是遥远的，因此不会随观察物体的位置而改变。这些要求意味着当地的光源不容易使用。</strong></p>
<p><strong>如果几何图形是静态的，但是一些光源(如太阳)移动了，一种不需要在立方体地图中动态渲染场景的更新探针的廉价技术是在G缓冲环境地图中存储表面属性(位置、法线、材质)。G -buffer将在第20.1节中详细讨论。然后我们使用这些属性在环境地图中计算表面的辐射亮度。《使命召唤:无限战争》、《巫师3》]和《孤岛惊魂4》等游戏都使用了这种技术。</strong></p>
<h3 id="Split-Integral-Approximation-for-Microfacet-BRDFs-微表面BRDFs的分裂积分近似"><a href="#Split-Integral-Approximation-for-Microfacet-BRDFs-微表面BRDFs的分裂积分近似" class="headerlink" title="Split-Integral Approximation for Microfacet BRDFs 微表面BRDFs的分裂积分近似"></a>Split-Integral Approximation for Microfacet BRDFs 微表面BRDFs的分裂积分近似</h3><p><strong>环境照明的用处是如此之大，以至于许多技术已经发展起来，以减少立方体映射预滤波中固有的BRDF近似问题。</strong></p>
<p><strong>到目前为止，我们已经描述了通过假设Phong波瓣，然后乘上完美镜菲涅耳项来工作的近似:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012150127.png" class="" title="image-20211012150127">

<p><strong>其中∫ΩDPhong(r) 是使用每一个r到环境立方体映射,如果我们考虑使用在337页方程9.34的镜面微表面 BRDF fsmf，得到简单的替换</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012150610.png" class="" title="image-20211012150610">

<p><strong>我们注意到，即使假设D(h)≈DPhong(r)是有效的，我们正在从照明积分中移除BRDF的重要部分。阴影项G₂(l, v, h)和半向量菲涅耳项F(h, l)在积分之外的应用没有理论基础。Lazarov表明，使用依赖于n·v的完美镜菲涅尔，而不是微表面 BRDF中的n·h，比完全不使用菲涅尔项产生更大的误差。Gotanda ， Lazarov， Karis分别推导出了类似的分裂积分近似:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012150716.png" class="" title="image-20211012150716">

<p><strong>注意，即使这个解通常被称为“分裂积分”，我们也没有将积分分解成两个不相交的项，因为这不是一个很好的近似。记住,fsmf 包括镜面波瓣D，我们注意到后者和n·l项都被复制到两边。在分裂积分近似中，我们在两个积分中都包含了环境映射中围绕反射向量对称的所有项。Karis称他的推导为分裂和，因为它是在他在预计算中使用的重要性采样数值积分器(上上上上方程)上完成的，但实际上它是相同的解。</strong></p>
<p><strong>由此得到的两个积分都可以有效地预先计算。第一种取决于表面粗糙度和反射矢量，假设是径向对称的D瓣。在实践中，我们可以使用任意的波瓣，使n = v = r。这个积分可以像往常一样预先计算并存储在立方体映射的mip层中。当将半矢量BRDFs转换为反射矢量周围的瓣时，为了在环境光和分析光之间获得类似的高光，径向对称瓣应该使用修改的粗糙度。例如，要将纯基于phong的反射矢量反射项转换为使用半角的Blinn-Phong BRDF，可以将指数除以4获得良好的拟合。</strong></p>
<p><strong>第二个积分是镜面项Rspec(v)的半球定向反射率(第9.3节), Rspec 函数取决于仰角θ、粗糙度α和菲涅耳项F。通常F是使用Schlick近似(9.16式)实现的，该近似仅对单个值F0进行参数化，从而使Rspec 一个有三个参数的函数。Gotanda预计算Rspec 在数值上，将结果存储在一个三维查找表中。Karis和Lazarov注意到F0 可以从Rspec中分解出来，导致两个因素，每个因素取决于两个参数:仰角和粗糙度。Karis使用这种洞察力来减少对Rspec的预计算查找到一个二维表格，可以存储在一个双通道纹理中，而Lazarov通过函数拟合得出两个因素的解析近似。一个更精确和更简单的解析近似后来由Iwanicki和Pesce推导出来。请注意,Rspec 也可用于提高漫反射BRDF模型的精度(见第352页公式9.65)。如果这两种技术是在同一个应用程序中实现的，那么Rspec 两者都可以使用，提高效率。</strong></p>
<p><strong>对于常数环境映射，分裂积分解是精确的。立方体映射部分提供了与镜面反射率成比例的光照强度，这是均匀光照下正确的BRDF积分。Karis和Lazarov都从经验上观察到，这种近似也适用于一般的环境地图，特别是在频率含量相对较低的情况下，这在户外场景中并不少见。参见下图。与地面真实值相比，这种技术的最大误差来源是对预过滤环境立方体图的径向对称、非裁剪镜面瓣的限制(上上图)。拉加德建议根据表面粗糙度，将用于获取预过滤环境地图的矢量从反射方向倾斜到法线方向，因为从经验上讲，这减少了与地面真实相比较的误差。这样做是合理的，因为它部分地补偿了不与表面的入射辐亮度半球裁剪瓣。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012151014.png" class="" title="image-20211012151014">

<p>Karis“分裂和”近似。从左到右:材质粗糙度增加。第一行:引用解决方案。第二行:分裂积分近似。第三行:将需要的径向对称的分裂积分加到镜面波瓣(n = v = r)。这最后一项要求是引入误差最多的。(图片来源:Epic Games Inc.， Brian Karis)</p>
<h3 id="Asymmetric-and-Anisotropic-Lobes-非对称各向异性叶"><a href="#Asymmetric-and-Anisotropic-Lobes-非对称各向异性叶" class="headerlink" title="Asymmetric and Anisotropic Lobes 非对称各向异性叶"></a>Asymmetric and Anisotropic Lobes 非对称各向异性叶</h3><p><strong>到目前为止，我们看到的解决方案都局限于各向同性的镜面瓣，这意味着当入射和出射方向围绕表面法线旋转时(第9.3节)，它们不会改变，并且径向对称反射向量。微表面 BRDF瓣是围绕半矢量h = (l+v)/||l+v||定义的(9.33式)，因此即使在各向同性的情况下也不具有我们需要的对称性。半矢量取决于光的方向l，对于环境照明来说，它不是唯一定义的。因此，在Karis之后，对于这些BRDFs，我们施加n = v = r，并推导出一个恒定的粗糙度校正因子，以匹配镜面高光的大小，以原始的半矢量公式。这些假设都是相当大的误差来源(见下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012151325.png" class="" title="image-20211012151325">

<p>比较GGX BRDF(红色)和GGX NDF瓣的两幅图，该瓣适合于围绕反射向量径向对称(绿色)。后者已经被缩放以匹配GGX镜面瓣的峰值，但请注意它如何不能捕获基于半矢量的BRDF的各向异性形状。在右边，注意两个脑叶在球体上形成的高光的不同。(图片使用迪士尼的开源软件BRDF Explorer生成。)</p>
<p><strong>我们在第10.5.1节中提到的一些方法可以用于计算具有任意BRDFs的交互速率环境照明，如Luksch等人和Colbert和Kˇriv´anek的方法。然而，由于这些方法需要几十个样本，很少用于表面的实时着色。它们可以被看作是蒙特卡罗积分的快速重要采样技术。</strong></p>
<p><strong>与预滤器环境地图创建的镜面叶施加径向对称,和访问预滤器叶的简单直接的逻辑对应于当前的镜面表面粗糙度,结果只在观看时保证是正确的连续表面(n = v)。在所有其他情况下没有这样的保证,并在放牧的角度我们承担错误不管双向叶的形状,因为我们忽略了真正的叶瓣不能下沉到阴影表面点的地平线以下。一般来说，在镜面反射的准确方向上的数据可能不是与现实的最佳匹配。</strong></p>
<p><strong>Kautz和McCool通过使用存储在预过滤环境图中的径向对称叶的更好的采样方案改进了朴素的预积分。他们提出了两种方法。第一种方法使用单个样本，但试图找到最好的来近似当前视场方向上的BRDF，而不是依赖一个恒定的校正因子。第二种方法是对来自不同叶的几个样本进行平均。第一种方法较好地模拟了掠射角度下的曲面。他们还推导了一个校正因子，以解释使用径向对称瓣近似与原始BRDF相比反射的总能量的差异。第二个解决方案扩展了结果，包括典型的半矢量模型的拉伸亮点。在这两种情况下，都使用优化技术来计算驱动预滤叶采样的参数表。Kautz和McCool的技术使用了贪婪拟合算法和抛物线环境地图。</strong></p>
<p><strong>最近，Iwanicki和Pesce使用一种称为Nelder-Mead最小化的方法，推导出了GGX BRDFs和环境立方体映射的类似近似。他们还分析了利用现代图形处理器的硬件各向异性滤波能力来加速采样的想法。</strong></p>
<p><strong>Revie还探索了使用预过滤的立方体映射的单个样本，但将其位置调整到更复杂的高光BRDF的峰值的想法，用于结合延迟着色的毛皮渲染(第20.1节)。在这种情况下，限制不是直接来自环境映射，而是需要在g缓冲区中编码尽可能少的参数。McAuley扩展了这一思想，将此技术用于延迟渲染系统中的所有表面。</strong></p>
<p><strong>McAllister等人开发了一种技术，通过利用拉福BRDF的特性，可以绘制各种效应，包括各向异性和反反射。这个BRDF本身就是一个基于物理的渲染的近似。它由多个Phong瓣组成，在反射方向周围受到扰动。Lafortune通过将这些叶拟合到He-Torrance模型和通过角反射仪测量真实材料，证明了这种BRDF表示复杂材料的能力。McAllister的技术依赖于注意到，由于Lafortune叶是广义的Phong叶，可以使用传统的预过滤环境图，其mips编码不同的Phong指数。Green等人提出了一种类似的方法，使用高斯瓣代替Phong瓣。此外，他们的方法可以扩展为支持环境地图的方向阴影(章节11.4)。</strong></p>
<h2 id="Irradiance-Environment-Mapping-辐射度量环境映射"><a href="#Irradiance-Environment-Mapping-辐射度量环境映射" class="headerlink" title="Irradiance Environment Mapping 辐射度量环境映射"></a>Irradiance Environment Mapping 辐射度量环境映射</h2><p><strong>上一节讨论了使用过滤环境贴图进行镜面反射。这些地图也可以用于漫反射。镜面反射的环境贴图有一些共同的属性，无论它们是用于镜面反射的未过滤的，还是用于光滑反射的过滤的。在这两种情况下，镜面环境地图都是用反射视图向量索引的，并且它们包含了辐亮度值。未过滤的环境地图包含传入的辐亮度值，而过滤的环境地图包含传出的辐亮度值。</strong></p>
<p><strong>相反，漫反射的环境映射仅用表面法线n索引，并且包含辐照度值。因此，它们被称为辐照度环境图。上图10.35显示了带有环境贴图的光滑反射在某些条件下由于其固有的模糊性而存在错误。相同的反射视图向量可能对应不同的反射情况。这个问题不会发生在辐照度环境贴图上。表面法线包含了漫反射的所有相关信息。由于辐照度环境图与原始照度相比是非常模糊的，它们可以以明显较低的分辨率存储。通常使用预过滤镜面环境图的最低mip级之一来存储辐照度数据。此外，与我们之前研究的光滑反射不同，我们没有对BRDF瓣积分，该瓣需要被剪切到表面法线周围的半球。环境光照与夹持余弦瓣的卷积是精确的，而不是近似的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013114149.png" class="" title="image-20211013114149">

<p>计算辐照度环境图。围绕表面法线的余弦加权半球从环境纹理(在本例中是一个立方体贴图)采样，并对其进行求和，以获得与视图无关的辐照度。绿色的正方形代表立方体地图的横截面，红色的勾号表示像素之间的边界。虽然显示了多维数据集映射表示，但可以使用任何环境表示。</p>
<p><strong>对于地图中的每个texel，我们需要总结所有影响给定法线方向表面的照明的余弦加权贡献。辐照度环境地图是通过应用深远的过滤器创建的，覆盖整个可见半球，原始环境地图。滤波器包括余弦因子。参见上图。408页图10.26中的球面图有一个相应的照度图，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013114332.png" class="" title="image-20211013114332">

<p>光照图由格雷斯大教堂球体图组成。左边的图是原始的球面图。右图是将半球上每个像素上的加权颜色相加形成的。(左图由保罗·德贝维奇提供，debevec.org;右图由斯坦福大学计算机图形实验室的Ravi ramamoori提供。)</p>
<p><strong>下图给出了使用中的辐照度图的一个例子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013114407.png" class="" title="image-20211013114407">

<p>使用辐照度贴图进行角色照明。(图片由Tecmo, Ltd. 2001游戏“Dead or Alive R 3”提供)</p>
<p><strong>辐照度环境映射与镜面环境或反射映射是分开存储和访问的，通常是一个视图独立的表示，如立方体映射。参见下图。而不是反射的视图向量，表面法线用于访问立方体映射来检索辐照度。从辐照度环境图中检索到的值乘以漫反射，从镜面环境图中检索到的值乘以镜面反射率。菲涅尔效应也可以建模，即在掠射角度增加镜面反射(可能降低漫反射)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013114539.png" class="" title="image-20211013114539">

<p>一个立方体映射(左)和它相应的过滤的辐照度映射(右)。(经微软公司许可转载)</p>
<p><strong>由于辐照度环境图使用非常宽的过滤器，很难通过采样有效地在飞行中创建它们。King讨论了如何在GPU上执行卷积来创建辐照度贴图。他能够在2004年的硬件上，通过将环境映射转换到频域，以超过300 FPS的速率生成辐照度映射。</strong></p>
<p><strong>漫反射或粗糙表面的过滤环境地图可以以低分辨率存储，但有时也可以由场景中相对较小的反射地图生成，例如64 × 64像素的立方体地图面。这种方法的一个问题是，一个区域光源渲染成如此小的纹理可能会“落在像素之间”，导致光闪烁或完全消失。为了避免这个问题，Wiley和Scheuermann建议在渲染动态环境地图时，用大型“卡片”(有纹理的矩形)来表示这些光源。</strong></p>
<p><strong>就像在光滑反射的情况下，动态光源也可以添加到预过滤的辐照度环境地图。Brennan给出了一种便宜的方法。想象一个单一光源的辐照度图。在光的方向上，亮度是最大的，因为光直接击中表面。给定表面法线方向的亮度。(一个给定的texel)随着角度对光线的余弦值下降，当表面背向光线时为零。GPU可以通过绘制一个半球来快速地将这个贡献直接添加到现有的辐照度图中，该半球代表余弦瓣，以观察者为中心，半球的极点沿着光线的方向。</strong></p>
<h3 id="Spherical-Harmonics-Irradiance-球面谐波辐照度"><a href="#Spherical-Harmonics-Irradiance-球面谐波辐照度" class="headerlink" title="Spherical Harmonics Irradiance 球面谐波辐照度"></a>Spherical Harmonics Irradiance 球面谐波辐照度</h3><p><strong>虽然我们已经讨论过只用纹理(如立方体贴图)来表示辐照度环境贴图，但是其他的表示也可以，如10.3节所述。球谐尤其作为一种辐照度环境地图表示非常流行，因为环境照明的辐照度是平滑的。用余弦瓣对辐射进行卷积可以去除环境地图中所有的高频成分。</strong></p>
<p><strong>Ramamoori和Hanrahan指出，仅仅用前9个SH系数(每一个都是SH系数)就能以约1%的精度表示辐照度环境图系数是RGB向量，所以我们需要存储27个浮点数)。任何辐照度环境图都可以被解释为一个球函数E(n)，并使用公式10.21和10.23投影到9个RGB系数上。这种形式比三次或抛物线映射更紧凑，在渲染期间，可以通过计算一些简单的多项式来重建辐照度，而不是访问纹理。通常，如果辐照度环境图代表间接照明，则需要较低的精度，这在交互式应用中是一种常见情况。在这种情况下，对于常数基函数和三个线性基函数，四个系数往往可以产生良好的结果，因为间接光照的频率往往较低，即随着角度的变化缓慢。</strong></p>
<p><strong>Ramamoori和Hanrahan还表明，入射辐亮度函数L(l)的SH系数可以通过每个系数乘以一个常数转化为辐照度函数E(n)的系数。这样做产生了一个快速的方法来过滤环境映射到辐照环境映射，即将它们投影到SH基中，然后将每个系数乘以一个常数。例如，King实现的快速辐照度滤波就是这样工作的。其思想是，通过辐射计算辐照度相当于在入射辐射度函数L(l)和夹持余弦函数cos(θi）+之间进行球面卷积．由于夹持余弦函数是围绕球的z轴旋转对称的，它在SH中有一种特殊形式:它的投影在每个频带中只有一个非零系数。非零系数对应于图10.21中中心列的基函数(401页)，它们也被称为区域谐波。</strong></p>
<p><strong>在一个普通球面函数和一个旋转对称函数(如夹紧余弦函数)之间执行一个球面卷积的结果是球面上的另一个函数。这种卷积可以有效地在函数的SH系数上进行。卷积结果的SH系数相等 p 两个函数系数的乘积，按比例乘以√4π/(2l + 1)，其中l是频带指数。于是，辐照度函数E(n)的SH系数等于辐照度函数L(l)的系数乘以夹持余弦函数cos(θi）+的系数，乘以频带常数。cos (θi）+的系数超过前9个系数的值很小，这解释了为什么九个系数足以表示辐照度函数E(n)。用这种方法可以快速地评估SH辐照度环境图。Sloan描述了一种高效的GPU实现。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013115343.png" class="" title="image-20211013115343">

<p>夹持余弦函数(红色)与它的九系数球谐近似(蓝色)。近似是相当接近的。注意π/2和π之间的下移和上移。</p>
<p><strong>这里有一个固有的近似，因为尽管E(n)的高阶系数很小，但它们不是零。参见上图。虽然π/2和π之间曲线的“摆动”在信号处理中被称为振铃，但这个近似非常接近。它通常发生在高频函数用少量基函数逼近时，如10.3.2节所示。π/2处的钳位为零是一个急剧的变化，这意味着钳位余弦函数有一个无限频率的信号。在大多数情况下，铃声是不明显的，但它可以看到在极端光照条件下的颜色转移或物体阴影侧面的明亮“斑点”。如果辐照度环境图只用于存储间接照明(经常发生)，那么铃声不太可能是一个问题。有一些预过滤方法可以最小化这个问题。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013115513.png" class="" title="image-20211013115513">

<p>左:由振铃引起的视觉伪影的例子。正确:一个可能的解决方案是使原始功能更平滑，这样它就可以在没有铃声的情况下表示，这个过程叫做“窗口化”。(图片由Peter-Pike Sloan提供。)</p>
<p><strong>图10.40显示了直接得到的照度图与由九项函数合成的照度图的比较。这种SH表示可以在使用当前表面法线n进行渲染时进行评估，也可以用于快速创建一个立方体或抛物线图供以后使用。这种照明是廉价的，并提供了良好的视觉效果漫反射情况。</strong></p>
<p><strong>动态渲染的立方体环境地图可以投影到SH基础上。由于立方环境地图是入射辐亮度函数的离散表示，方程10.21中球面上的积分将成为立方地图texels的总和:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013115601.png" class="" title="image-20211013115601">

<p><strong>其中t是当前立方体贴图贴图texel的索引，r[t]是指向当前贴图贴图贴图texel的方向向量，fj (r[t])为r[t]处的第j个SH基函数，L[t]为存储在texel中的亮度，dω[t]为texel所面对的立体角。Kautz， King和Sloan描述了如何计算dω[t]。</strong></p>
<p><strong>转换辐射系数kLj 在辐照度系数中，需要乘以固定余弦函数cos(θi）+的比例系数：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013115612.png" class="" title="image-20211013115612">

<p><strong>其中kEj 是辐照度函数E(n)的第j个系数，kLj 是入射亮度函数L(l)的第j个系数，k′cos+j 为夹持余弦函数cos(θi) +按√4π/(2l + 1)缩放后的第j个系数(l为频带指数)。</strong></p>
<p><strong>给定t和立方体映射分辨率，对于每个基函数fj (），因子k’ cos +j fj (r[t])dω[t]是常数．这些基本因素可以离线预计算并存储在多维数据集映射中，多维数据集映射的分辨率应该与将要呈现的动态环境映射相同。使用的纹理数量可以通过在每个颜色通道中打包一个单独的基础因子来减少。为计算动态立方体映射的辐照度系数，将适当的基因子映射的像素与动态立方体映射的像素相乘，并对结果进行总结。除了动态辐照度立方体映射的信息，King还提供了GPU SH投影的实现细节。</strong></p>
<p><strong>动态光源可以添加到现有的SH辐照度环境地图中。这个合并是通过计算光的辐照度贡献的SH系数，并将它们加入到现有的系数中来完成的。这样做可以避免重新计算整个辐照度环境图。这是一个简单的过程，因为点、盘和球面光的系数存在简单的解析表达式。把系数加起来和把辐照度加起来有同样的效果。对于与z轴对齐的光来说，通常这些表示是在区域谐波中给出的，然后可以应用旋转来将光定位到任意方向。区域谐波旋转是SH旋转的一种特殊情况(章节10.3.2)，它更有效，只需要一个点积而不需要一个完整的矩阵变换。对于形状更复杂的光源，可以通过将其绘制成图像来计算系数，然后将图像数值投影到SH基础上。对于物理天空模型的特殊情况，Habel显示了Preetham天窗在球面谐波中的直接扩展。</strong></p>
<p><strong>常见的分析光源投射到SH中是很重要的，因为通常环境照明被用来代替远处或较弱的光源。补光灯是一个重要的例子。在渲染中，这些光源被放置来模拟场景中的间接光。光线从表面反射回来。对于填充光，高光的贡献通常不会被计算出来，特别是当这些光相对于被着色物体而言在物理上是很大的，而相对于场景中的其他光源来说则是相对昏暗的。这些因素使他们的高光更分散，不太明显。这种类型的光在现实世界中与电影和视频的照明有相似之处，物理补光通常用于在阴影中添加照明。</strong></p>
<p><strong>在球面谐波空间也是相反的推导过程简单,也就是说,从光芒中提取分析光源投射在SH。在他的调查SH技术,斯隆表明,给定一个定向光源与一个已知的轴,很容易从SH辐照度计算表示光的强度应该最小化错误本身和编码的辐照度之间。</strong></p>
<p><strong>在他之前的工作斯隆展示了如何通过只使用第一个(线性)波段的系数来选择一个接近最优的方向。该调查还包括一种提取多个方向光的方法。结果表明，球面谐波是光求和的实际基础。我们可以将多个光源投射到SH中，并提取出数量更少、能够接近投影集的定向光源。lightcuts框架提供了一种聚合次要光源的原则性方法。</strong></p>
<p><strong>虽然最常用于辐照度，SH投影可以用来模拟光滑的，视相关的BRDF照明。Ramamoori和Hanrahan描述了一种这样的技术。与单一颜色不同，它们在一个立方体映射中存储球谐投影的系数，编码环境映射的视图依赖性。然而，在实践中，这种技术比我们前面看到的预过滤环境映射方法需要更多的空间。Kautz等人利用二维SH系数表推导出一种更经济的解，但这种方法仅限于相当低频率的照明。</strong></p>
<h3 id="Other-Representations-其他表示"><a href="#Other-Representations-其他表示" class="headerlink" title="Other Representations 其他表示"></a>Other Representations 其他表示</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013120403.png" class="" title="image-20211013120403">

<p>各种编码辐照度的方法。从左到右:环境图和漫射照明，通过蒙特卡罗积分计算辐照度;用环境立方体编码的辐照度;球面谐波;球形高斯函数;和h基(它只能代表一个半球的方向，所以背面的法线是不着色的)。(图片是由Yuriy O ‘Donnell和David Neubelt通过开源软件Probulator计算的。)</p>
<p><strong>虽然立方体映射和球面调和是最流行的辐照度环境映射表示，其他表示也可能。参见上图。许多辐照度环境地图有两种主要颜色:顶部的天空颜色和底部的地面颜色。受此观察的启发，Parker等人提出了只使用两种颜色的半球照明模型。假设上半球发射均匀辐亮度Lsky，下半球发射均匀辐亮度Lground．这种情况下的辐照度积分是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013120452.png" class="" title="image-20211013120452">

<p><strong>其中θ是表面法线与天球轴之间的夹角。Baker和Boyd提出了一个更快的近似(由Taylor描述):</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013120519.png" class="" title="image-20211013120519">

<p><strong>它是天空和地面之间的线性插值，使用(cos θ + 1)/2作为插值因子。术语cosθ通常是快速计算点积,在通常情况下,天空半球轴是一个红衣主教轴(例如,y或z轴),它不需要计算,因为它等于n的世界坐标之一。近似相当接近,明显加快,所以它比大多数应用程序的完整表达式。</strong></p>
<p><strong>Forsyth提出了一种便宜而灵活的照明模型，称为三权照明，它包括定向照明、双向照明、半球形照明和包裹照明。</strong></p>
<p><strong>Valve最初引入了辐照度的环境立方体表示法(章节10.3.1)。一般来说，我们在第10.3节中看到的所有球面函数表示都可以用于预计算辐照度。对于辐射函数所代表的低频信号，我们知道SH是一个很好的近似。我们倾向于创造特殊的方法来简化或使用比球面谐波更少的存储。</strong></p>
<p><strong>如果我们想要评估遮挡和其他全局光照效果，或者如果我们想要合并光滑反射(章节10.1.1)，就需要对高频进行更复杂的表示。预计算光照以考虑所有相互作用的一般思想称为预计算辐射传输(PRT)，将在第11.5.3节中讨论。捕捉高频率的光泽照明也被称为全频率照明。小波表示通常用于这种情况，作为压缩环境映射和在设计有效操作符的手段比我们见过的球谐函数更时髦。Ng等人演示了使用哈尔小波将辐照度环境映射推广到模型自阴影。它们在小波基中存储环境地图和阴影函数，阴影函数在物体表面上变化。这种表示是值得注意的，因为它相当于对环境立方体映射进行变换，对每个立方体面执行二维小波投影。因此，它可以被看作是一种立方体映射的压缩技术。</strong></p>
<h2 id="Sources-of-Error-误差的来源"><a href="#Sources-of-Error-误差的来源" class="headerlink" title="Sources of Error 误差的来源"></a>Sources of Error 误差的来源</h2><p><strong>为了正确地进行着色，我们必须在非点状光源上计算积分。在实践中，这一要求意味着我们可以使用许多不同的技术，基于正在考虑的灯的特性。通常实时引擎会对一些重要的灯光进行分析建模，在灯光区域上近似积分，并通过阴影贴图计算遮挡。所有其他光源——远处照明、天空、补光和在表面上反弹的光——通常由环境立方体贴图(用于镜面组件)和球面基础(用于漫射光)来表示。</strong></p>
<p><strong>使用照明技术的混合意味着我们不会直接使用给定的BRDF模型，而是使用具有不同程度误差的近似。有时BRDF近似是明确的，因为我们为了计算照明积分而拟合中间模型——ltcs就是一个例子。其他时候，我们构建的近似是在特定(通常很少)条件下对给定BRDF精确的，但在一般的预过滤立方体映射中容易出错——这就属于这一类。</strong></p>
<p><strong>在开发实时着色模型时需要考虑的一个重要方面是确保不同形式的光照之间的差异不明显。从视觉上看，从不同的表征中获得相干光的结果，甚至可能比每个表征产生的绝对近似误差更重要。</strong></p>
<p><strong>遮挡对于真实渲染来说也是至关重要的，因为在应该没有光线的地方光线“漏出”通常比在应该有光线的地方没有光线更明显。大多数区域光表示对于阴影来说并不简单。今天，没有一种现有的实时阴影技术，即使考虑到“软化”效果(第7.6节)，也不能准确地考虑光的形状。我们计算一个标量因子，当物体投射阴影时，我们乘这个标量因子来减少给定光的贡献，这是不正确的;在用BRDF积分时，我们应该考虑这种遮挡。环境照明的情况是特别困难的，因为我们没有一个明确的、主导的光方向，所以不能使用点状光源的阴影技术。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013120839.png" class="" title="image-20211013120839">

<p>生产照明。(拖车公园5。档案颜料打印，17x22英寸。格雷戈里·克鲁德森的《玫瑰下》系列剧照。c Gregory Crewdson。礼貌高古轩)。</p>
<p><strong>即使我们已经看到了一些相当先进的照明模型，但重要的是要记住，这些并不是真实世界光源的精确表示。例如，在环境照明的情况下，我们假设无限远辐射源，那些永远不可能的。我们所见过的所有解析光都建立在一个更强的假设上，即光对其表面上的每个点均匀地向外照射半球。在实践中，这种假设可能会产生误差，因为通常真实的光具有很强的方向性。在摄影和电影照明中，特别制作的面具和过滤器，称为gobos, cuculoris，或饼干，经常被用于艺术效果。例如，如上图中由摄影师Gregory Crewdson设计的复杂的电影照明。为了限制照明角度，同时保持大范围的发射，可以在大型发光面板(所谓的软箱)前面添加被称为蜂巢的黑色屏蔽材料网格。镜子和反光镜的复杂配置也可以用于灯的外壳，如室内照明、汽车前照灯和手电筒。参见下图。这些光学系统创建了一个或多个远离物理中心辐射光的虚拟发射器，在进行衰减计算时应该考虑这个偏移。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013120943.png" class="" title="image-20211013120943">

<p>相同的圆盘灯有两种不同的发射剖面。左:圆盘上的每一点都均匀地向外射出光线。右图:发射聚焦在正常圆盘周围的一个瓣上。</p>
<p><strong>请注意，这些错误应该总是在一个感知的、面向结果的框架中评估(除非我们的目标是做预测渲染，即以可靠地模拟表面的真实世界外观)。在艺术家的手中，某些简化，即使不现实，仍然可以产生有用和富有表现力的原语。物理模型是有用的，因为它可以让艺术家更容易地创造出视觉上可信的图像，但它们不是自己的目标。</strong></p>
<h1 id="11-Global-Illumination-全局光照"><a href="#11-Global-Illumination-全局光照" class="headerlink" title="11 Global Illumination 全局光照"></a>11 Global Illumination 全局光照</h1><p><strong>辐亮度是通过渲染过程计算出来的最终数量。到目前为止，我们一直使用反射率方程来计算它:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014113728.png" class="" title="image-20211014113728">

<p><strong>其中Lo(p, v)是从表面位置p在视图方向v上发出的辐亮度，Ω是p以上方向的半球，f(l, v)是v和当前入射方向l, Li(p, l)的BRDF值是从l入射到p的亮度，(n·l)+是l和n之间的点积，负的值固定为零。</strong></p>
<h2 id="The-Rendering-Equation-渲染方程"><a href="#The-Rendering-Equation-渲染方程" class="headerlink" title="The Rendering Equation 渲染方程"></a>The Rendering Equation 渲染方程</h2><p><strong>反射率方程是Kajiya在1986年提出的全渲染方程的一个限制性特例。渲染方程使用了不同的形式。我们将使用这个版本:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014114339.png" class="" title="image-20211014114339">

<p><strong>新元素是Le(p, v)，为表面位置p在v方向上发出的辐亮度，替换如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014114428.png" class="" title="image-20211014114428">

<p><strong>这一项意味着从l方向进入位置p的入射辐亮度等于从相反方向-l的另一点发出的辐亮度。在这种情况下，“其他点”是由光线投射函数r(p, l)定义的。该函数返回从p向l方向投射光线击中的第一个表面点的位置。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014114638.png" class="" title="image-20211014114638">

<p>着色表面位置p，光照方向l，光线投射函数r(p, l)，入射亮度Li(p, l)，也表示为Lo(r(p, l)，−l)。</p>
<p><strong>渲染方程的含义很简单。要遮蔽表面位置p，我们需要知道出射亮度Lo 让p在视图方向v，这就等于发射的辐亮度Le 加上反射的亮度。光源的发射和反射率已在前几章中研究过。甚至光线投射操作符也不像看起来那么陌生。例如，z缓冲区对从眼睛射入场景的光线进行计算。</strong></p>
<p><strong>唯一的新项是Lo(r(p, l)，−l)，这说明入射到某一点的光辉必定是从另一点发出来的。不幸的是，这是一个递归术语。也就是说，它是通过对位置r(r(p, l),l ‘)的输出辐亮度的另一个求和来计算的。这些依次需要计算从位置r(r(r(p, l),l ‘),l “)到无穷远的输出辐亮度。现实世界能够实时计算出所有这些，真是令人惊讶。</strong></p>
<p><strong>我们凭直觉就知道，光线照亮一个场景，光子四处反弹，每次碰撞都以各种方式被吸收、反射和折射。渲染方程很重要，因为它将所有可能的路径总结成一个简单的方程。</strong></p>
<p><strong>渲染方程的一个重要属性是，它对发射的光照是线性的。如果我们把光线放大两倍，着色的效果会更亮两倍。材质对每种光的响应也独立于其他光源。也就是说，一种光的存在并不影响另一种光与材质的相互作用。</strong></p>
<p><strong>在实时渲染中，通常只使用局部光照模型。计算光照只需要可见点的表面数据，而这正是GPU最有效的功能。基元分别被处理和栅格化，然后被丢弃。在b点进行计算时，不能访问a点的光照计算结果。透明度、反射和阴影都是全局光照算法的例子。它们使用的信息来自于其他物体而不是被照亮的物体。这些效果有助于提高渲染图像的真实感，并提供线索，帮助观众理解空间关系。同时，模拟它们也很复杂，可能需要预计算或呈现多个通道来计算一些中间信息。</strong></p>
<p><strong>思考照明问题的一种方法是通过光子的路径。在局部照明模型中，光子从光到表面(忽略干涉物体)，然后到眼睛。阴影技术考虑到这些干涉对象的直接遮挡效应。环境地图捕捉从光源到远处物体的照明，然后应用到局部闪亮的物体上，这些物体将光线反射到眼睛。辐照度图还可以捕捉到光对遥远物体的影响，在半球的每个方向上进行整合。从所有这些物体反射的光被加权和求和，以计算出一个表面的照明，然后被眼睛看到。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014115309.png" class="" title="image-20211014115309">

<p>一些路径和它们到达眼睛时的等价符号。请注意，从网球开始有两条连续的路径。</p>
<p><strong>以更正式的方式思考光传输路径的不同类型和组合有助于理解现有的各种算法。Heckbert提出了一种有用的符号格式，用于描述一种技术所模拟的路径。光子从光(L)到眼睛(E)的每一次相互作用都可以被标记为漫反射(D)或镜面(S)。分类还可以进一步增加其他表面类型，如“光滑的”，意思是有光泽但不像镜子。参见上图。可以用正则表达式对算法进行简要总结，显示它们模拟的交互类型。基本表示法的概述见下表。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014115420.png" class="" title="image-20211014115420">

<p>正则表达式的符号。</p>
<p><strong>光子从光到眼睛可以有不同的路径。最简单的路径是LE，光直接被眼睛看到。一个基本的z缓冲区是L(D|S)E，或等价于LDE|LSE。光子离开光，到达漫反射或镜面，然后到达眼睛。注意，在基本的渲染系统中，点光源没有物理表示。给出灯的几何形状将产生一个系统L(D |S)?E，这样光线也可以直接进入眼睛。</strong></p>
<p><strong>如果将环境映射添加到渲染器中，那么紧凑表达式就不那么明显了。虽然Heckbert的表示法读起来从头到脚，但构建相反方向的表达式通常更容易。眼睛首先会看到镜面或漫反射面,(S|D)E。如果表面是高光的，它也可以选择反射一个(远处的)高光或漫反射表面，渲染到环境地图中。因此，有一个额外的潜在路径:((S|D)?S|D)E。要计算眼睛直接看到光的路径，加一个L((S|D)?S|D)?E。</strong></p>
<p><strong>该表达式可以扩展为LE|LSE|LDE|LSSE|LDSE，单独显示所有可能的路径，或更短的L(D|S)?S?E。每一种都有其在理解关系和限制方面的作用。这种表示法的部分效用在于表达算法效果，并能够基于这些效果进行构建。例如，L(S|D)是生成环境映射时编码的内容，而SE是随后访问该映射的部分。</strong></p>
<p><strong>渲染方程本身可以用简单的表达式L(D|S)∗E总结，即来自光的光子在进入眼睛之前可以接触到零到几乎无限个漫反射或镜面。</strong></p>
<p><strong>全局照明研究的重点是计算沿这些路径的光传输的方法。当将它应用到实时渲染时，我们经常愿意牺牲一些质量或正确性来进行有效的评估。最常见的两种策略是简化和预计算。例如，我们可以假设所有的光在到达眼睛之前都是漫反射的，这种简化在某些环境中很有效。我们还可以离线预计算物体间效果的一些信息，例如生成记录表面光照水平的纹理，然后在实时中仅根据这些存储的值进行基本计算。本章将举例说明如何使用这些策略来实现实时的各种全局照明效果。</strong></p>
<h2 id="General-Global-Illumination-通用全局光照"><a href="#General-Global-Illumination-通用全局光照" class="headerlink" title="General Global Illumination 通用全局光照"></a>General Global Illumination 通用全局光照</h2><p><strong>前面几章重点介绍了求解反射率方程的各种方法。我们假设入射辐亮度L有一定的分布i，并分析了它如何影响阴影。在本章中，我们将介绍用于求解完整渲染方程的算法。两者的区别在于前者忽略了光芒的来源——它只是被给予。后者明确地说明了这一点:到达某一点的辐亮度是由其他点发射或反射出来的辐亮度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014120257.png" class="" title="image-20211014120257">

<p>路径跟踪可以生成逼真的图像，但在计算上很昂贵。上面的图像每个像素使用超过2000条路径，每条路径最长可达64段。它花了两个多小时渲染，但仍然有一些轻微的噪音。(“乡村厨房”模型由Jay-Artist, Benedikt Bitterli渲染资源，授权CC by 3.0。使用三菱渲染器渲染。)</p>
<p><strong>解决完整渲染方程的算法可以生成令人惊叹的、逼真的图像(上图)。然而，对于实时应用程序来说，这些方法的计算成本太高。那么，为什么要讨论它们呢?第一个原因是，在静态或部分静态场景中，这样的算法可以作为预处理运行，将结果存储起来，以便在渲染时使用。例如，这是游戏中的常见方法，我们将讨论这类系统的不同方面。</strong></p>
<p><strong>第二个原因是全局光照算法建立在严格的理论基础上。它们是直接从渲染方程中推导出来的，并且它们做出的任何近似都是经过仔细分析的。在设计实时解决方案时，可以也应该应用类似类型的推理。即使我们走了某些捷径，我们也应该意识到后果是什么正确的方法。随着图形硬件变得越来越强大，我们将能够做出更少的妥协，并创建更接近正确的物理结果的实时渲染图像。</strong></p>
<p><strong>求解绘制方程的两种常用方法是有限元法和蒙特卡罗法。Radiosity是基于第一种方法的算法;不同形式的光线追踪使用的是第二种方法。在这两种方法中，射线追踪要流行得多。这主要是因为它可以在同一个框架内有效地处理一般的光传输——包括体积散射等效应。它也更容易伸缩和并行化。</strong></p>
<p><strong>我们将简要描述这两种方法，但感兴趣的读者应该参考任何优秀的书籍，其中涵盖了在非实时设置下求解渲染方程的细节。</strong></p>
<h3 id="Radiosity-光能传递"><a href="#Radiosity-光能传递" class="headerlink" title="Radiosity 光能传递"></a>Radiosity 光能传递</h3><p><strong>辐射度是第一种计算机图形技术，用于模拟漫反射表面之间的反射光。它的名字来自算法计算的数量。在经典的形式中，辐射度可以计算区域光的互反射和软阴影。关于这个算法的书籍已经有了，但其基本思想相对简单。光线在环境中反射。你打开一盏灯，光线很快就会达到平衡。在这种稳定状态下，每个表面都可以被认为是一个光源。基本的辐射度算法简化假设所有的间接光都来自漫射表面。这一前提不适用于有抛光大理石地板或墙壁上有大镜子的地方，但对于许多建筑设置来说，这是一个合理的近似。辐射度可以跟随有效的无限数量的漫反射。使用本章开始时介绍的符号，其轻型传输集为LD∗E。</strong></p>
<p><strong>辐射度假定每个表面都是由若干个小块组成的。对于每一个较小的区域，它计算一个单一的平均辐射值，因此这些补丁需要足够小，以捕获所有的照明细节(例如，阴影边缘)。然而，它们不需要与下面的表面三角形一一匹配，甚至不需要大小一致。</strong></p>
<p><strong>从渲染方程出发，我们可以得出patch i的辐射度为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014124422.png" class="" title="image-20211014124422">

<p><strong>Bi 为patch i, Bi^e的辐射度为辐射出度，即第i块发射的辐射度，和ρss 为次表面反照率(第9.3节)。只有光源的发射不为零。Fij 是斑块i和j之间的形状因子。形状因子被定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014124553.png" class="" title="image-20211014124553">

<p><strong>Ai 为patch i的面积，V (i, j)为点i和点j之间的可见度函数，如果两者之间没有遮挡光，则为1，否则为0。θi 和θj 是两个贴片法线和射线连接点i和j之间的夹角，最后是dij 为射线的长度。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014124717.png" class="" title="image-20211014124717">

<p>两个表面点之间的形状因子。</p>
<p><strong>形状因子是一个纯粹的几何术语。它是离开patch i的均匀扩散辐射能入射到patch j上的分数。两个补丁的面积、距离和方向，以及它们之间的任何表面，都会影响它们的形状因子值。想象一个补丁，比如说，一个电脑显示器。房间里的其他每一块都将直接接收显示器发出的光的一部分。如果表面在监视器后面或不能“看到”监视器，这个分数可能为零。这些分数加起来都是1。辐射度算法的一个重要部分是准确地确定场景中对patch之间的形状因素。</strong></p>
<p><strong>通过计算形状因子，将所有patch的方程(上上式)组合成一个单一的线性系统。然后对系统进行求解，得到每个补丁的辐射度值。由于计算复杂度高，随着patch数量的增加，减少这样一个矩阵的成本是相当大的。</strong></p>
<p><strong>由于该算法伸缩性差，并且有其他限制，经典的辐射很少用于产生照明解决方案。然而，在现代实时全球照明系统中，预计算形状因子并在运行时使用它们来执行某种形式的光传播的想法仍然很流行。我们将在本章后面(第11.5.3节)讨论这些方法。</strong></p>
<h3 id="Ray-Tracing-光线追踪"><a href="#Ray-Tracing-光线追踪" class="headerlink" title="Ray Tracing 光线追踪"></a>Ray Tracing 光线追踪</h3><p><strong>射线投射(Ray casting)是指从某个位置发射射线，以确定某个特定方向上的物体的过程。光线追踪使用光线来确定光线在不同场景元素之间的传输。在其最基本的形式中，光线从相机通过像素网格射入场景。对于每一条射线，要找到最近的物体。然后，通过向每一束光发射一条射线，并寻找是否有任何物体处于两者之间，来检查交点是否处于阴影中。不透明的物体会挡住光线;透明物体会使它衰减。其他射线可以从交点产生。如果一个表面是有光泽的，则在反射方向产生一条射线。这条射线拾取第一个物体相交的颜色，然后对其相交点进行阴影测试。光线也可以产生在折射方向的透明固体物体，再次递归评估。这一基本机制非常简单，以至于功能性射线示踪剂被写在名片的背面。</strong></p>
<p><strong>经典的光线追踪只能提供有限的效果:强烈的反射和折射，以及硬阴影。然而，同样的基本原理可以用来解决完整的渲染方程。Kajiya意识到发射射线和计算它们携带多少光的机制可以用来计算公式11.2中的积分。这个方程是递归的，这意味着对于每一条射线，我们需要在不同的位置，重新计算积分。幸运的是，处理这个问题的坚实的数学基础已经存在。蒙特卡罗方法是在曼哈顿计划期间为物理实验而开发的，专门设计来处理这类问题。不是直接通过求积规则计算每个阴影点的积分值，而是在定义域的一些随机点上计算被积函数。然后用这些值计算积分值的估计值。采样点越多，精度越高。这种方法最重要的性质是只需要被积函数的点计算。只要有足够的时间，我们可以任意精度地计算这个积分。在渲染的上下文中，这正是光线追踪所提供的。当我们发射射线时，我们对11.2式中的被积函数进行点采样。即使在交点处还有另一个积分，我们不需要它的最终值，我们可以对它再次进行点采样。当光线穿过场景时，一条路径就建立起来了。沿每条路径携带的光提供被积函数的一个计算值。这个过程称为路径跟踪(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014125004.png" class="" title="image-20211014125004">

<p>由路径跟踪算法生成的示例路径。这三种路径都通过胶片平面上相同的像素，并用于估计其亮度。底部的地板是高度光滑的，并以一个小的实心角度反射光线。蓝色的方框和红色的球体是漫射的，所以光线在交点处均匀地围绕法线散射。</p>
<p><strong>跟踪路径是一个非常强大的概念。路径可以用于渲染光滑或漫反射材质。使用它们，我们可以生成柔和的阴影和渲染透明的物体以及焦散效果。将路径跟踪扩展到样本点的体积，而不仅仅是表面，它可以处理雾和次表面散射效果。</strong></p>
<p><strong>路径跟踪的唯一缺点是实现高视觉保真度所需的计算复杂性。对于电影质量的图像，可能需要追踪数十亿条路径。这是因为我们从不计算积分的实际值，只计算它的估计值。如果使用的路径太少，这种近似将是不精确的，有时相当不精确。此外，即使是相邻的点，结果也可能会有很大的不同，因为人们会期待灯光几乎是相同的。我们说这样的结果有高方差。从视觉上看，这在图像中显示为噪声(下图)。已经提出了许多方法来消除这种影响，而不需要追踪额外的路径。一种流行的技术是重要性采样。这个想法是，通过向大部分光线来自的方向发射更多的光线，方差可以大大减少。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014125118.png" class="" title="image-20211014125118">

<p>在样本数目不足的情况下使用蒙特卡罗路径跟踪所产生的噪声。左边的图像每像素渲染8条路径，右边的图像每像素渲染1024条路径。来自Benedikt Bitterli Rendering Resources的“Cornell Box”模型，在CC BY 3.0下授权。使用三菱渲染器渲染。)</p>
<p><strong>在路径跟踪及其相关方法方面，已经发表了许多论文和著作。Pharr等人对现代脱机光线追踪技术作了很好的介绍。Veach为现代关于光传输算法的推理奠定了数学基础。我们将在本章末尾的第11.7节讨论交互速率下的光线和路径跟踪。</strong></p>
<h2 id="Ambient-Occlusion-环境遮蔽"><a href="#Ambient-Occlusion-环境遮蔽" class="headerlink" title="Ambient Occlusion 环境遮蔽"></a>Ambient Occlusion 环境遮蔽</h2><p><strong>上一节介绍的通用全局光照算法在计算上非常昂贵。它们可以产生各种各样的复杂效果，但生成一张图像可能需要几个小时。我们将开始我们的探索实时替代与最简单的，但仍然视觉上令人信服的解决方案，并逐步建立更复杂的影响，整个章节。</strong></p>
<p><strong>一个基本的全局照明效果是环境遮挡(AO)。这种技术是在21世纪初由工业光魔公司的兰迪斯开发的，用于提高电影《珍珠港》(Pearl Harbor)中电脑生成飞机的环境照明质量。尽管这种效应的物理基础包括相当数量的简化，但结果看起来令人惊讶地可信。这种方法在光线缺乏方向变化且不能显示物体细节时提供了关于形状的提示。</strong></p>
<h3 id="Ambient-Occlusion-Theory-环境遮蔽理论"><a href="#Ambient-Occlusion-Theory-环境遮蔽理论" class="headerlink" title="Ambient Occlusion Theory 环境遮蔽理论"></a>Ambient Occlusion Theory 环境遮蔽理论</h3><p><strong>环境遮蔽的理论背景可以直接从反射方程推导出来。为了简单起见，我们将首先关注朗伯曲面。出射亮度Lo 辐照度是入射辐亮度的余弦加权积分。一般来说，它取决于表面位置p和表面法线n。同样，为简单起见，我们将假设入射辐亮度为常数Li(l) = LA，对于所有入射方向l，得到计算辐照度的公式如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015132655.png" class="" title="image-20211015132655">

<p><strong>积分是在可能传入方向的半球Ω上执行的。在恒定均匀照明的假设下，辐照度(以及由此产生的出射亮度)不依赖于表面位置或法线，在整个物体上是恒定的。这导致了一个扁平的外观。</strong></p>
<p><strong>上方程没有考虑任何可见性。有些方向可能会被物体的其他部分或场景中的其他物体挡住。这些方向会有不同的入射亮度，而不是LA．为简单起见，我们假设从闭塞方向入射的辐亮度为零。这忽略了场景中其他物体反射的所有光线，并最终从这些被阻挡的方向到达p点，但它极大地简化了推理。得到由Cook和Torrance首先提出的方程:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015132811.png" class="" title="image-20211015132811">

<p><strong>其中，v(p, l)是一个可见性函数，如果从p向l方向投射的光线被阻挡，该函数等于零，如果不被阻挡，则等于1。</strong></p>
<p><strong>可视性函数的归一化余弦加权积分称为环境遮蔽:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015132906.png" class="" title="image-20211015132906">

<p><strong>它代表了未被遮挡半球的余弦加权百分比。值的范围从0(完全遮挡的表面点)到1(没有遮挡的位置)。值得注意的是，凸面物体，如球体或盒子，不会造成自身的遮挡。如果场景中不存在其他物体，凸物体的环境遮蔽值将到处为1。如果物体有凹穴，在这些区域遮挡将小于一个。</strong></p>
<p><strong>一旦kA 定义时，遮挡存在时的环境辐照度方程为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015132944.png" class="" title="image-20211015132944">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015133024.png" class="" title="image-20211015133024">

<p>一个物体渲染只有恒定的环境光(左)和环境光遮蔽(右)。即使在光照恒定的情况下，环境遮挡也会带来物体的细节。(“龙”模型由Delatronic, Benedikt Bitterli渲染资源，在CC by 3.0下许可。使用三菱渲染器渲染。)</p>
<p><strong>注意，现在辐照度确实随表面位置而改变，因为kA 所做的事。这将导致更加真实的结果，如上图所示。表面位置在尖锐的折痕将是黑暗的，因为他们的值kA 很低。比较地表位置p0 和p1 如下图所示。表面方向也有影响，因为可视性函数v(p, l)在积分时被余弦因子加权。比较p1 p2 在图的左边。两者都有一个大小相同的未闭塞立体角，但p1 是绕其表面法线，所以余弦系数比较高，从箭头的亮度就可以看出。相比之下，p2 偏离表面法线的一侧，相应的余弦系数值较低。因此，kA 的值在p2点更低．从这里开始，为了简短起见，我们将不再显式地显示对表面位置p的依赖关系。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015133215.png" class="" title="image-20211015133215">

<p>环境照明下的物体三分(p0,p1和p2)所示。在左边，被阻挡的方向显示为相交点(黑色圆圈)结束的黑色射线。畅通的方向显示为箭头，根据余弦系数着色，以便那些更接近表面法线较轻。在右边，每个蓝色箭头显示平均未闭塞方向或弯曲法线。</p>
<p><strong>除了kA， Landis也计算出平均未遮挡方向，称为弯曲法线。这个方向向量被计算为未被遮挡光方向的余弦加权平均值:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015133308.png" class="" title="image-20211015133308">

<p><strong>符号||x||表示向量x的长度。积分的结果除以其自身的长度以产生标准化结果。如上图右侧所示。结果向量可以在着色过程中代替几何法线，以提供更准确的结果，而不需要额外的性能成本(章节11.3.7)。</strong></p>
<h3 id="Visibility-and-Obscurance-可视性和遮蔽"><a href="#Visibility-and-Obscurance-可视性和遮蔽" class="headerlink" title="Visibility and Obscurance 可视性和遮蔽"></a>Visibility and Obscurance 可视性和遮蔽</h3><p><strong>可视性函数v(l)用于计算环境遮挡因子kA (上上上式)需要仔细定义。对于一个物体，例如一个角色或车辆，它是直接定义v(l)基于从表面位置在l方向投射的光线是否相交于同一物体的任何其他部分。然而，这并不能解释被附近其他物体遮挡的原因。通常，物体可以假定被放置在一个平面上以达到照明的目的。通过在可见性计算中包含这个平面，可以实现更真实的遮挡。另一个好处是，物体对地平面的遮挡可以用作接触阴影。</strong></p>
<p><strong>不幸的是，可见函数方法在封闭几何中失败了。想象这样一个场景:一个封闭的房间里有各种各样的物品。所有曲面都是kA 值为0，因为所有来自表面的射线都会击中某个物体。经验方法，试图复制环境遮蔽的外观，而不必模拟延迟物理可视性通常更适合这类场景。其中一些方法受到Miller无障碍着色概念的启发，该概念模拟了表面的角落和裂缝如何捕获污垢或腐蚀。</strong></p>
<p><strong>Zhukov等人引入了遮蔽的思想，通过将可视性函数v(l)替换为距离映射函数ρ(l)来修改环境遮挡计算:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015133810.png" class="" title="image-20211015133810">

<p><strong>与v(l)不同，v(l)只有两个有效值，1表示无交点，0表示有交点，ρ(l)是一个基于射线与曲面相交前的距离的连续函数。对于大于指定距离d的任意交点，ρ(l)在交点距离为0和1处的值为dmax，或者根本没有交集。dmax 之外不需要测试，可大大加快kA。下图显示了ambient occlusion 和 ambient obscurance的区别。注意，使用ambient occlusion渲染的图像相当暗。这是因为即使在很远的距离处也能检测到交叉点，因此会影响kA的值。</strong></p>
<p><strong>尽管试图在物理上证明它，模糊在物理上是不正确的。然而，它通常会给出符合观众期望的可信结果。缺点之一是dmax 的值需要手动设置才能达到令人满意的效果。这种妥协在计算机图形学中经常出现，其中一种技术没有直接的物理基础，但“在感知上令人信服”。“目标通常是一个可信的图像，所以这种技术使用起来很好。也就是说，基于理论的方法的一些优点是它们可以自动工作，并可以通过推理真实世界的工作方式进一步改进。</strong></p>
<h3 id="Accounting-for-Interreflections-相互反射的计算"><a href="#Accounting-for-Interreflections-相互反射的计算" class="headerlink" title="Accounting for Interreflections 相互反射的计算"></a>Accounting for Interreflections 相互反射的计算</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015134512.png" class="" title="image-20211015134512">

<p>没有反射和有反射的环境遮蔽的区别。左边的图像只使用关于可见性的信息。右边的图像也使用了间接照明的反射。(“维多利亚风格的房子”模型由mr黑猩猩2313,Benedikt Bitterli渲染资源，授权CC by 3.0。使用三菱渲染器渲染。)</p>
<p><strong>尽管由环境遮挡产生的结果在视觉上是令人信服的，但它们比由全局照明模拟产生的结果要暗。比较上图中的图像。</strong></p>
<p><strong>环境遮蔽和全局照明之间的一个重要区别是相互反射。方程11.8假设在闭塞方向上的辐亮度为零，而在现实中，相互反射将从这些方向引入非零辐亮度。这种效果可以从上图左侧模型的折痕和凹坑中看到，与右侧模型相比。这种差异可以通过增加kA的值来解决。使用遮挡距离映射函数代替可视性函数(章节11.3.2)也可以缓解这个问题，因为遮挡函数对于阻塞方向的值通常大于零。</strong></p>
<p><strong>以更精确的方式跟踪相互反射是昂贵的，因为它需要解决递归问题。要遮蔽一个点，必须先遮蔽其他点，以此类推。计算kA 的值这比执行一个完整的全局照明计算要便宜得多，但是它经常以某种形式包含这个缺失的光，以避免过度暗。Stewart和Langer提出了一种便宜但惊人精确的近似相互反射的方法。它是基于对扩散照明下的朗伯场景的观察，从一个给定位置可见的表面位置趋向于有相似的亮度。假设亮度Li 从封闭方向发射的辐射亮度Lo 从当前着色点，递归被打破，可以找到一个解析表达式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015134755.png" class="" title="image-20211015134755">

<p><strong>在ρss 为地下反照率，或漫反射。这等价于替换环境遮挡因子kA 有一个新的因子kA′：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015134836.png" class="" title="image-20211015134836">

<p><strong>这个方程将倾向于使环境遮挡因子变亮，使它在视觉上更接近一个完整的全局照明解决方案的结果，包括相互反射。这种效应高度依赖于ρss值。潜在的近似假设表面颜色在着色点附近是相同的，以产生一种有点像颜色出血的效果。Hoffman和Mitchell使用这种方法用天空光照亮地形。</strong></p>
<p><strong>Jimenez等人提出了一个不同的解。他们为许多场景执行完全的、离线的路径跟踪，每个场景都被一个统一的白色、无限远的环境地图照亮，以获得适当考虑相互反射的遮挡值。基于这些例子，他们拟合三次多项式来逼近由环境遮挡值kA 映射的函数f 以及次表面反照率ρss 到遮挡值kA′ ，它被反射光照亮。他们的方法也假设反照率是局部常数，并且入射反照率的颜色可以根据给定点的反照率得到。</strong></p>
<h3 id="Precomputed-Ambient-Occlusion-预计算环境遮挡"><a href="#Precomputed-Ambient-Occlusion-预计算环境遮挡" class="headerlink" title="Precomputed Ambient Occlusion 预计算环境遮挡"></a>Precomputed Ambient Occlusion 预计算环境遮挡</h3><p><strong>环境遮蔽因子的计算非常耗时，通常在渲染前离线进行。预计算任何与光照相关的信息的过程，包括环境遮蔽，通常被称为烘培。</strong></p>
<p><strong>最常用的预计算环境遮挡的方法是蒙特卡罗方法。光线投射和检查与场景的交叉口，方程11.8是数值计算。例如，我们随机选择N个方向l，均匀分布在法线n附近的半球上，沿着这些方向跟踪光线。基于交叉结果，我们评估可视性函数v，然后环境遮蔽可计算为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015135414.png" class="" title="image-20211015135414">

<p><strong>当计算环境遮挡时，投射光线可以被限制在一个最大距离，并且v的值是基于所找到的交点距离。</strong></p>
<p><strong>环境遮挡或遮蔽因子的计算包括一个余弦加权因子。虽然它可以直接包含，如上式所示，但更有效地包含该权重因子的方法是采用重要性采样。射线方向的分布是余弦加权的，而不是均匀地投射在半球上并对结果进行余弦加权。换句话说，光线更有可能投射到更接近表面法线的方向，因为从这个方向产生的结果可能更重要。这种采样方案称为马利方法。</strong></p>
<p><strong>环境遮挡预计算可以在CPU上执行，也可以在GPU上执行。在这两种情况下，可以使用库来加速针对复杂几何体的光线投射。最受欢迎的两个是CPU的Embree和GPU的OptiX。过去，来自GPU管线的结果，如深度映射或遮挡查询，也被用于计算环境遮蔽。随着GPU上越来越普遍的光线投射解决方案的普及，它们的使用在今天已经不那么普遍了。大多数商业上可用的建模和渲染软件包提供了一个选项来预计算环境遮蔽。</strong></p>
<p><strong>遮挡数据对于对象上的每个点都是唯一的。它们通常以纹理、体积或网格顶点的形式存储。不管存储的信号类型是什么，不同存储方法的特点和问题都是相似的。如第11.5.4节所述，同样的方法也可以用于存储环境遮蔽、方向遮蔽或预计算光照。</strong></p>
<p><strong>预先计算的数据也可以用来模拟物体相互之间的环境遮挡效应。Kontkanen和Laine将一个物体对其周围环境的环境遮挡效应存储在一个立方体映射中，称为环境遮蔽场。他们用二次多项式的倒数来模拟环境遮蔽值如何随着与物体的距离而变化。它的系数存储在一个立方体映射中，以模拟遮挡的方向变化。在运行时，利用遮挡对象的距离和相对位置获取合适的系数并重建遮挡值。</strong></p>
<p><strong>Malmer等人通过将环境遮蔽因子和可选的弯曲法线存储在一个称为环境遮蔽体积的三维网格中，显示了改进的结果。计算要求较低，因为环境遮挡因子直接从纹理中读取，而不是计算。与Kontkanen和Laine的方法相比，存储的标量更少，两种方法的纹理分辨率都很低，所以总体存储需求是相似的。Hill和Reed描述了Malmer等人的方法在商业游戏引擎中的实现。他们讨论算法的各个实际方面以及有用的优化。这两种方法都适用于刚性对象，但它们可以扩展到具有少量运动部件的铰接对象，其中每个部件被视为单独的对象。</strong></p>
<p><strong>无论我们选择哪种方法来存储环境遮蔽值，我们都需要知道我们处理的是连续信号。当我们从空间中的一个特定点发射光线时，我们进行采样，当我们在着色之前从这些结果中插入一个值时，我们进行重建。来自信号处理领域的所有工具都可以用来提高采样重构过程的质量。Kavan等人提出了一种他们称之为最小二乘烘焙的方法。遮挡信号通过网格均匀采样。接下来，导出顶点的值，使插值和采样点之间的总差最小，在最小二乘意义上。他们专门讨论在顶点存储数据的上下文中的方法，但是同样的推理也可以用于导出存储在纹理或体积中的值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015135933.png" class="" title="image-20211015135933">

<p>命运号在其间接照明计算中使用了预先计算的环境遮蔽。该解决方案被用于两代不同硬件的游戏版本，提供了高质量和性能。(图片c 2013 Bungie, Inc.版权所有。)</p>
<p><strong>《命运》是一款使用预计算环境遮挡作为间接照明解决方案基础的广受好评的游戏(上图)。这款游戏是在两代主机硬件之间的过渡时期发行的，它需要一个解决方案来平衡新平台的高质量与老平台的性能和内存使用的局限性。游戏的特点是一天中的动态时间，所以任何预先计算的解决方案都必须正确地考虑到这一点。开发人员选择环境遮蔽，因为它的可信外观和低成本。由于环境遮挡将能见度计算与光照解耦，所以无论一天中的哪个时间，都可以使用相同的预计算数据。完整的系统，包括基于GPU的烘培管线，由Sloan等人描述。</strong></p>
<p><strong>育碧的《刺客信条》和《Far Cry》系列也使用了一种预计算环境遮挡的形式来增强它们的间接照明解决方案。他们从自上而下的视角渲染世界，并处理得到的深度图来计算大规模遮挡。根据邻近深度样本的分布，使用各种启发式方法来估计值。通过将世界空间的位置投影到纹理空间，生成的世界空间AO地图应用于所有物体。他们称这个方法为World AO。Swoboda也描述了类似的方法</strong>。</p>
<h3 id="Dynamic-Computation-of-Ambient-Occlusion-环境遮蔽的动态计算"><a href="#Dynamic-Computation-of-Ambient-Occlusion-环境遮蔽的动态计算" class="headerlink" title="Dynamic Computation of Ambient Occlusion 环境遮蔽的动态计算"></a>Dynamic Computation of Ambient Occlusion 环境遮蔽的动态计算</h3><p><strong>对于静态场景，环境遮蔽因子kA 弯曲法线nbent 可以预先计算的。然而，对于物体移动或改变形状的场景，通过动态计算这些因素可以获得更好的结果。这样做的方法可以分为在物体空间操作的，和在屏幕空间操作的。</strong></p>
<p><strong>离线计算环境遮挡的方法通常涉及从每个表面点向场景投射大量光线，几十到数百条，并检查相交。这是一项昂贵的操作，实时方法关注于近似或避免大量此类计算的方法。</strong></p>
<p><strong>Bunnell计算环境遮蔽因子kA 弯曲法线nbent 通过将曲面建模为放置在网格顶点上的圆盘形元素的集合。选择圆盘是因为一个圆盘被另一个圆盘遮挡可以通过分析计算，避免了需要投射光线。简单地将一个磁盘的遮挡因子与所有其他磁盘相加，就会由于双重阴影而导致过度暗的结果。也就是说，如果一个圆盘在另一个圆盘的后面，那么两个圆盘都将被计算为封闭表面，即使只有两个圆盘之间更近的部分应该被计算。邦内尔使用了一个聪明的双通道方法来避免这个问题。第一个通道计算环境遮蔽，包括双阴影。在第二次通过中，每个盘的贡献因其从第一次通过的遮挡而减少。这只是一个近似值，但在实践中，它产生的结果是令人信服的。</strong></p>
<p><strong>计算每个元素对之间的遮挡是O(n²)，这是太昂贵的，除了最简单的场景。通过对远处表面的简化表示可以降低代价。Bunnell构造了一个层次结构的元素树，其中每个节点都是一个磁盘，它表示树中它下面的磁盘的聚合。在执行盘间遮挡计算时，较高层的节点用于较远处的表面。这将计算减少到O(nlogn)阶，这是更合理的。邦内尔的技术相当高效，并产生高质量的结果。例如，《加勒比海盗》(Pirates of the Caribbean)电影的最终渲染使用了它。</strong></p>
<p><strong>Hoberock对Bunnell的算法提出了几个改进，以更高的计算费用提高了算法的质量。他还提出了一个距离衰减因子，其结果类似于Zhukov等人提出的遮蔽因子。</strong></p>
<p><strong>Evans描述了一种基于符号距离场(SDF)的动态环境遮挡近似方法。在这幅图中，一个物体被嵌入到一个三维网格中。网格中的每个位置存储到物体最近表面的距离。对于任何对象内部的点，该值为负值，对于所有对象外部的点，该值为正值。Evans在一个体积纹理中创建并存储一个场景的SDF。为了估计物体上某个位置的遮挡，他使用了一种启发式方法，该方法结合了一些点的采样值，沿着法线逐渐远离表面。正如Qu´ılez所描述的，当SDF以解析方式表示(第17.3节)而不是存储在三维纹理中时，也可以使用相同的方法。虽然这种方法是非物理的，但结果在视觉上令人愉悦。</strong></p>
<p><strong>Wright进一步推广了将符号距离场用于环境遮挡。我们没有使用特别的启发式来生成遮挡值，Wright执行圆锥追踪。视锥产生于被遮蔽的位置，并通过在距离场中编码的场景表示对交叉口进行测试。圆锥跟踪是通过沿着轴执行一组步骤和检查相交的SDF与一个不断增加的半径在每一步。如果到最近的遮挡器的距离(从SDF采样的值)小于球体的半径，那部分锥体被遮挡(下图)。追踪单个圆锥是不精确的，并且不允许包含余弦项。基于这些原因，Wright追踪了一组覆盖整个半球的视锥细胞，以估计周围环境的遮挡。为了提高视觉保真度，他的解决方案不仅为场景使用全局SDF，而且还使用局部SDF，代表单个对象或逻辑连接的对象集。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015141351.png" class="" title="image-20211015141351">

<p>圆锥跟踪是通过在场景几何图形和逐渐增大半径的球体之间进行一系列的交点来近似实现的。球面的大小对应于从轨迹原点到给定距离的圆锥的半径。在每一步中，圆锥角度被减少，以考虑场景几何遮挡。最后的遮挡因子被估计为被剪切锥所覆盖的立体角与原始锥的立体角的比值。</p>
<p><strong>Crassin等人在场景体素表示的背景下描述了一种类似的方法。他们使用稀疏体素八叉树(第13.10节)存储场景的体素化。他们计算环境遮蔽的算法是渲染全全局光照效果的更通用方法的一个特例(章节11.5.7)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015141505.png" class="" title="image-20211015141505">

<p>环境遮挡效果是模糊的，不显示遮挡器的细节。AO计算可以使用更简单的几何表示，但仍然可以达到合理的效果。犰狳模型(左)近似于一组球体(右)。在他们身后墙上的模型几乎没有遮挡投射的区别。(模型由斯坦福计算机图形实验室提供。)</p>
<p><strong>Ren等人将遮挡几何体近似为球体的集合(上图)。用球谐函数表示被单球面遮挡的表面点的能见度函数。由一组球体遮挡的聚集可见性函数是将单个球体可见性函数相乘的结果。不幸的是，计算球谐函数的乘积是一项昂贵的操作。他们的关键思想是对单个球面调和可见性函数的对数求和，并将结果取幂。这产生了与乘可见性函数相同的最终结果，但是球面调和函数的求和比乘要便宜得多。本文表明，正确的逼近，对数和指数可以快速执行，产生一个整体的加速。</strong></p>
<p><strong>该方法不仅计算环境遮挡因子，而且计算一个完整的球面能见度函数，用球面谐波表示(第10.3.2节)。一阶(0)系数可用作环境遮挡系数kA，下三个(阶1)系数可用于计算弯曲法向nbent．高阶系数可以用于阴影环境地图或圆形光源。由于几何图形近似为边界球体，从折痕和其他小细节的遮挡不被建模。</strong></p>
<p><strong>Sloan等在屏幕空间中对Ren描述的可见性函数进行了积累。对于每个闭塞器，他们考虑一组像素，这些像素距离它的中心在一定的世界空间距离内。这个操作可以通过渲染一个球体，或者在着色器中执行距离测试，或者使用模板测试来实现。对于所有受影响的屏幕区域，适当的球谐值被添加到屏幕外缓冲区。在积累了所有遮挡器的可见性后，缓冲区中的值被取幂得到最终的组合可见性函数每个屏幕像素。Hill使用了相同的方法，但将球谐可见性函数限制为只有二阶系数。在这种假设下，球面谐波乘积只是少量的标量乘法，甚至GPU的固定功能混合硬件都可以执行。这使得我们能够在性能有限的主机硬件上使用这种方法。由于该方法使用低阶球面谐波，它不能用于生成边界更明确的硬阴影，而只是大部分无方向遮挡。</strong></p>
<h3 id="Screen-Space-Methods-屏幕空间方法"><a href="#Screen-Space-Methods-屏幕空间方法" class="headerlink" title="Screen-Space Methods 屏幕空间方法"></a>Screen-Space Methods 屏幕空间方法</h3><p><strong>对象空间方法的开销与场景复杂度成正比。然而，一些关于遮挡的信息可以纯粹地从屏幕空间数据中推断出来，比如深度和法线。这些方法的成本是恒定的，与场景的细节无关，而只与渲染所用的分辨率有关</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015144755.png" class="" title="image-20211015144755">

<p>Crytek的环境遮挡方法应用于三个表面点(黄色圆圈)。为清晰起见，算法以二维形式显示，相机(没有显示)位于图上方。在这个例子中，10个样本分布在每个表面点周围的圆盘上(实际上，它们分布在一个球体上)。未通过z检验的样本，即那些超出存储的z-缓冲区值的样本显示为红色，通过的样本显示为绿色。k的值A 是通过的样本与总样本之比的函数。为了简单起见，我们忽略变量样本权重。左边的点在10个样本中有6个通过，因此比率为0.6,kA 计算。中点有三个通过的样本。还有一个在对象外部，但没有通过z测试，如红色箭头所示。这就得到kA为0.3。右边的点有一个通过的样本，所以是kA 是0.1。</p>
<p><strong>Crytek开发了一种用于《孤岛危机》的动态屏幕空间环境遮挡(SSAO)方法。他们使用z缓冲区作为唯一的输入，在全屏通道中计算环境遮挡。环境遮蔽因子kA 每个像素的估计是通过测试一组点，这些点分布在像素位置周围的一个球体上，与z缓冲区相对。k的值A 是z缓冲区中对应值前面的样本数量的函数。通过的样本数量越少，kA值就越低。参见上图。样本的权重随着与像素的距离而减小，类似于模糊因子。请注意，由于样本不是由(n·l)+因子加权的，因此产生的环境遮蔽是不正确的。所有的样本都被计算在内，而不是只考虑在一个表面位置上的半球的样本。这种简化意味着在表面以下的样本不应该被计算的时候被计算。这样做会使平面变暗，边缘比周围的环境更亮。尽管如此，结果往往是赏心悦目的。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015144947.png" class="" title="image-20211015144947">

<p>屏幕空间环境遮挡的效果显示在左上方。右上方显示无环境遮挡的反照率(漫反射色)。在左下方，这两个组合显示。镜面阴影和阴影被添加到最终的图像，在右下角。(图片来自Crytek公司提供的《孤岛危机》。)</p>
<p><strong>Shanmugam和Arikan同时开发了一种类似的方法。在他们的论文中，他们描述了两种方法。一个从小的，附近的细节生成精细的环境遮挡。另一种方法是对较大的物体产生粗糙的环境遮挡。将这两种方法的结果结合起来产生最终的环境遮挡因子。他们的精细尺度环境遮挡方法使用全屏通道访问z缓冲区，以及包含可见像素的表面法线的第二个缓冲区。对于每个阴影像素，从z缓冲区中采样附近的像素。采样像素被表示为球体，并对着色像素计算遮挡项，考虑其法线。没有考虑双重阴影，所以结果有点暗。他们的粗糙遮挡方法类似于Ren等人(在456页讨论)的对象空间方法，遮挡几何近似为球体的集合。然而，Shanmugam和Arikan使用屏幕对齐的广告牌覆盖屏幕空间每个闭塞球体的“效果区域”。与Ren等人的方法不同，粗遮挡方法中也没有考虑双重遮挡。</strong></p>
<p><strong>这两种方法极其简单，很快被业界和学术界注意到，并催生了大量后续工作。许多方法，如Filion等人在《星际争霸2》[471]中使用的方法和McGuire等人[1174]中使用的可扩展环境遮蔽方法，使用特别启发式来生成遮挡因子。这些方法具有良好的性能特点，并暴露出一些可以手工调整的参数，以达到预期的艺术效果。</strong></p>
<p><strong>其他方法旨在提供更有原则的计算遮挡的方法。Loos和Sloan注意到Crytek的方法可以解释为蒙特卡罗积分。他们称计算值为体积模糊度和定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015145227.png" class="" title="image-20211015145227">

<p><strong>其中X是一个围绕点的三维球面邻域，ρ是距离映射函数，类似于方程11.11,d是距离函数，o(X)是占据函数，如果X没有被占据，则等于0，否则等于1。他们注意到ρ(d)函数对最终的视觉质量影响很小，所以使用常数函数。在此假设下，体积模糊度是一个点邻域上的占位函数的积分。Crytek的方法是随机采样三维邻域来计算积分。洛斯和斯隆通过随机采样一个像素的屏幕空间邻域，在xy维度上计算积分。z维是解析积分的。如果球形邻域的点不包含任何几何、积分的长度等于x射线和一个球体代表之间的相交的几何、深度缓冲用作入住率的近似函数,积分计算,只有每个线段的空置的一部分。如下图左侧所示。该方法生成的结果与Crytek的质量相当，但使用更少的样本，因为在一个维度上的集成是精确的。如果表面法线是可用的，该方法可以扩展到考虑它们。在那个版本中，线积分的计算被固定在计算点的法线定义的平面上。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015145438.png" class="" title="image-20211015145438">

<p>体积模糊度(左)用线积分估计点周围的未占用体积的积分。体积环境遮挡(右图)也使用线积分，但要计算到阴影点的球切线的占用率，这是从反射方程模拟余弦项。在这两种情况下，积分是由球体的未占用体积(用绿色实线标记)与球体的总体积(用红色虚线标记的未占用体积和已占用体积之和)的比值估计的。对于这两幅图，相机都是从上方观察的。绿色的圆点表示从深度缓冲区读取的样本，黄色的圆点是正在计算遮挡的样本。</p>
<p><strong>Szirmay-Kalos等人提出了另一种使用正常信息的屏幕空间方法，称为体积环境遮蔽。方程11.6对一个半球的法向函数进行积分，其中包括余弦项。他们提出，这种类型的积分可以通过从被积函数中去除余弦项和用余弦分布夹紧积分范围来近似。这将积分变换为在一个球面上而不是在一个半径为一半的半球上，并沿法线移动，以完全包围在半球内。其未占用部分体积的计算方法与Loos和Sloan方法一样，通过对像素邻域随机采样，并对占据函数在z维上进行解析积分。如上图右侧所示。</strong></p>
<p><strong>Bavoil等人提出了一种不同的方法来估计局部可视性问题。他们的灵感来自Max的地平线制图技术。他们的方法称为基于水平的环境遮挡(HBAO)，假设z缓冲区中的数据代表一个连续的高度场。某一点的能见度可以通过确定地平角来估计，地平角是被邻域遮挡的切平面上方的最大角度。也就是说，给定一个点的方向，我们记录可见的最高物体的角度。如果我们忽略余弦项，那么环境遮蔽因子可以计算为视界上未遮挡部分的积分，或者，1减去视界下遮挡部分的积分:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015145622.png" class="" title="image-20211015145622">

<p><strong>式中h(φ)为切平面以上的地平角，t(φ)为切平面与视场矢量的切角，W(ω)为衰减函数。参见下图。的1/ 2π 项使积分标准化，使结果在0和1之间。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015145725.png" class="" title="image-20211015145725">

<p>基于水平的环境遮挡(左)找到切平面以上的水平角h，并整合它们之间的未遮挡角。切平面和视图向量之间的角度被记为t。地面真实环境遮挡(右)使用相同的地平线角度h1 和h2，但也使用法线和视图向量之间的角度γ，将余弦项纳入计算。在这两幅图中，相机都是从上方观察场景的。图中显示了横截面，水平角为φ的函数，φ是视角周围的角度。绿色的圆点表示从深度缓冲区读取的样本。黄色的点是正在计算遮挡的样本。</p>
<p><strong>对于给定的φ，利用到定义视界的点的距离上的线性衰减，我们可以解析地计算内部积分:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015145805.png" class="" title="image-20211015145805">

<p><strong>其余的积分是通过对几个方向取样并找到地平角进行数值计算的。</strong></p>
<p><strong>Jimenez等人也使用了基于水平的方法，他们称之为地面真实环境遮挡(GTAO)。他们的目的是获得地面真实结果，与射线追踪得到的结果相匹配，假设唯一可用的信息是z-缓冲区数据形成的高度场。基于水平的环境遮挡在其定义中不包括余弦项。它还增加了在11.8式中不存在的特别衰减，所以它的结果，即使与光线追踪的结果很接近，也不一样。GTAO引入了缺失的余弦因子，去除衰减函数，并在视图向量周围的参考坐标系中推导遮挡积分。遮挡因子定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015145902.png" class="" title="image-20211015145902">

<p><strong>在h1(φ)和h2(φ)为给定φ的左右视界角度，γ为法线方向与视界方向之间的角度。标准化术语1/ π 与HBAO不同，因为它包含了余弦项。这使得开放半球与π积分。公式中不包含余弦项，积分为2π。在高度场假设下，这个公式与11.8式完全匹配。参见上图。内积分仍然可以用解析方法求解，因此只需要对外积分进行数值计算。这个积分与HBAO中的方法相同，通过在给定像素周围采样多个方向来实现。</strong></p>
<p><strong>在基于水平的方法中，过程中最昂贵的部分是沿着屏幕空间线取样深度缓冲区以确定水平角度。Timonen提出了一种专门旨在改进性能特性的方法这一步。他指出，用于估算给定方向的视界角度的样本可以在屏幕空间中沿直线排列的像素之间大量重用。他将遮挡计算分为两个步骤。首先，他在整个z缓冲区执行线跟踪。在跟踪的每一步，他都会根据规定的最大影响距离，在沿着直线移动时更新视界角度，并将此信息写入缓冲区。为水平映射中使用的每个屏幕空间方向创建一个这样的缓冲区。缓冲区不需要与原始深度缓冲区的大小相同。它们的大小取决于线之间的间距，以及沿线的步骤之间的距离，在选择这些参数时有一定的灵活性。不同的设置会影响最终的质量。</strong></p>
<p><strong>第二步是根据缓冲区中存储的地平线信息计算遮挡因子。Timonen使用HBAO定义的遮挡因子(上上方程)，但可以使用其他遮挡估计器，如GTAO(上方程)。</strong></p>
<p><strong>深度缓冲并不是场景的完美表现，因为只有最近的对象被记录在一个给定的方向上，我们不知道它后面发生了什么。许多方法使用不同的启发式来尝试推断一些关于可见物体厚度的信息。在许多情况下，这些近似就足够了，眼睛可以原谅不准确的地方。虽然有一些方法使用多层深度来缓解这个问题，但由于与渲染引擎的复杂集成和高运行时成本，它们从未得到广泛的普及。</strong></p>
<p><strong>屏幕空间方法依赖于重复采样z缓冲区，以在给定点周围形成一些简化的几何模型。实验表明，要达到高质量的视觉效果，需要多达几百个样本。然而，为了便于交互渲染，最多只能采集10到20个样本，通常甚至更少。Jimenez等人报告称，为了符合60帧/秒游戏的性能预算，他们只能在每个像素中使用一个样本!为了在理论和实践之间架起桥梁，屏幕空间方法通常采用某种形式的空间抖动。在最常见的形式中，每个屏幕像素使用一组稍微不同的随机样本，并进行径向旋转或移动。在AO计算的主要阶段之后，执行全屏滤波。联合双边滤波(章节12.1.1)用于避免跨越表面不连续的滤波，并保持锐利的边缘。它使用有关深度或法线的可用信息来限制过滤只使用属于同一表面的样本。一些方法使用随机变化的采样模式和实验选择的滤波核;另一些使用固定大小的屏幕空间模式(例如，4 × 4像素)的重复样本集，以及一个限制在该邻域的过滤器。</strong></p>
<p><strong>环境遮挡计算也经常随时间进行超采样。这个过程通常是通过每帧应用不同的采样模式并对遮挡因子进行指数平均来完成的。使用上一帧的z缓冲区、相机变换和动态对象的运动信息，前一帧的数据被重新投影到当前视图。然后与当前帧结果混合。基于深度、标准或速度的试探法通常用于检测来自最后一帧的数据不可靠，应该被丢弃的情况(例如，因为一些新的对象进入了视图)。第5.4.2节在更一般的情况下解释了时间超采样和抗锯齿技术。时间滤波的成本很小，实现起来也很简单，尽管它并不总是完全可靠，但在实践中，大多数问题都是不明显的。这主要是因为环境遮挡从来没有直接可视化，它只是作为照明计算的输入之一。在将这个效果与法线贴图、反照纹理和直接照明相结合后，任何次要的伪影都被掩盖掉，不再可见。</strong></p>
<h3 id="Shading-with-Ambient-Occlusion-环境遮蔽的阴影"><a href="#Shading-with-Ambient-Occlusion-环境遮蔽的阴影" class="headerlink" title="Shading with Ambient Occlusion 环境遮蔽的阴影"></a>Shading with Ambient Occlusion 环境遮蔽的阴影</h3><p><strong>尽管我们已经在恒定的、远处的照明环境中导出了环境遮蔽值，我们也可以将其应用到更复杂的照明场景中。再次考虑反射方程:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015150713.png" class="" title="image-20211015150713">

<p><strong>上面的形式包含可见性函数v(l)，如11.3.1节所介绍的。</strong></p>
<p><strong>如果我们处理的是漫反射面，我们可以用朗伯BRDF替换f(l, v)，它等于次表面反照率ρss 除以π。我们得到了</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015150822.png" class="" title="image-20211015150822">

<p><strong>我们可以用上面的公式来表示</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015150901.png" class="" title="image-20211015150901">

<p><strong>如果我们使用11.8式中环境遮挡的定义，上面模拟</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015150919.png" class="" title="image-20211015150919">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015150934.png" class="" title="image-20211015150934">

<p><strong>这种形式给了我们一个新的角度来看待这个过程。上上式中的积分可以看作是对入射辐亮度Li应用方向滤波核K。</strong></p>
<p><strong>滤波器K在空间和方向上都以一种复杂的方式变化，但它有两个重要的特性。首先，由于夹紧点积，它最多覆盖了法线p点附近的半球。第二，由于分母上的归一因子，它在半球上的积分等于1。</strong></p>
<p><strong>为了进行遮光，我们需要计算两个函数乘积的积分，即入射亮度Li 和滤波器函数k。在某些情况下，可以用一种简化的方法来描述滤波器，并以相当低的代价计算这个二重积积分Li 和K用球谐表示(第10.3.2节)。处理这个方程复杂性的另一种方法是用一个具有类似性质的更简单的滤波器来近似这个滤波器。最常见的选择是归一化余弦核H:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015151403.png" class="" title="image-20211015151403">

<p><strong>当没有任何东西挡住射入的光线时，这个近似是准确的。它还涵盖了与我们正在近似的滤波器相同的角度范围。它完全忽略了能见度，但环境遮挡kA 项仍然存在于上上上方程中，因此在着色表面上会有一些可视的变暗。</strong></p>
<p><strong>选择了这个过滤内核，上上上等式就变成了</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015151522.png" class="" title="image-20211015151522">

<p><strong>这意味着，在其最简单的形式，着色与环境遮蔽可以通过计算辐照度并将其乘以环境遮挡值而形成。辐照度可以来自任何来源。例如，它可以从辐照度环境图中取样(章节10.6)。该方法的准确性只取决于近似的滤波器在多大程度上代表了正确的滤波器。对于在球体上平滑变化的光线，近似值给出了合理的结果。如果Li 在所有可能的方向上都是常数，即就好像场景被代表照明的全白色环境地图照亮。</strong></p>
<p><strong>这个公式也给了我们一些见解，为什么环境遮挡是一个较差的近似值的时点或小面积光源的能见度。它们只在表面上包含一个小的实心角度——在点灯的情况下是无穷小的——可见性函数对照明积分的值有重要的影响。它几乎以二进制的方式控制光的贡献，即。，它要么完全启用，要么完全禁用。忽略可见性，正如我们在公式11.25中所做的，是一个重要的近似，通常不会产生预期的结果。阴影缺乏清晰度，不显示任何预期的方向性，也就是说，似乎不是由特定的光产生的。环境遮挡不是一个好的选择建模的能见度这样的灯。其他方法，如阴影贴图，应该使用。然而，值得注意的是，有时小的，局部的光被用来模拟间接照明。在这种情况下，用环境遮挡值调制它们的贡献是合理的。</strong></p>
<p><strong>到目前为止，我们假设我们是在朗伯曲面上着色。当处理一个更复杂的非常数BRDF时，这个函数不能从积分中提出来，就像我们在方程11.20中做的那样。对于镜面材料，K不仅取决于能见度和法线，还取决于观看方向。典型微表面 BRDF的波瓣在域上发生显著变化。用一个单一的、预先确定的形状来近似它是太粗糙了，无法得出可信的结果。这就是为什么使用环境遮挡来做着色对漫反射BRDFs最有意义的原因。其他方法，将在接下来的章节中讨论，更适合更复杂的材料模型。</strong></p>
<p><strong>使用弯曲法线(见第448页的11.10式)可以看作是更精确地逼近滤波器K的一种方法。可见性项仍然没有出现在过滤器中，但它的最大值与平均未被遮挡方向匹配，这使得它总体上更接近11.23式。在几何法线和弯曲法线不匹配的情况下，使用后者将提供更准确的结果。Landis不仅将其用于环境地图的着色，还用于一些直接光照，而不是常规的阴影技术。</strong></p>
<p><strong>对于环境贴图的着色，Pharr提出了一种替代方案，使用GPU的纹理过滤硬件动态地执行过滤。滤波器K的形状是动态确定的。它的中心是弯曲法线的方向，它的大小取决于kA的值。这提供了与方程11.23中的原始过滤器更精确的匹配。</strong></p>
<h2 id="Directional-Occlusion-方向遮蔽"><a href="#Directional-Occlusion-方向遮蔽" class="headerlink" title="Directional Occlusion 方向遮蔽"></a>Directional Occlusion 方向遮蔽</h2><p><strong>尽管单独使用环境遮挡可以极大地提高图像的视觉质量，但它是一个大大简化的模型。当处理甚至是大面积的光源时，它提供了一个可怜的能见度近似，更不用说小的或准时的光源了。它也不能正确处理光滑的BRDFs或更复杂的照明设置。考虑一个被远处的顶灯照亮的表面，整个顶灯的颜色从红色变成绿色。这可能代表地面被来自天空的光线照亮——考虑到颜色，可能是在某个遥远的星球上。参见下图。即使环境遮挡会使点a和点b的光线变暗，它们仍然会被天空的红色和绿色部分照亮。使用弯曲的法线有助于缓解这种效果，但它也不是完美的。我们之前提出的简单模型不够灵活，无法处理这种情况。一种解决方案是用更有表现力的方式描述可见性。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015152408.png" class="" title="image-20211015152408">

<p>在复杂照明条件下，a和b点辐照度的近似颜色。环境遮挡不建模任何方向，所以颜色是相同的在两个点。使用弯曲的法线可以有效地将余弦波瓣移向天空中未被遮挡的部分，但由于积分范围没有受到任何限制，这不足以提供准确的结果。定向方法能够正确地消除来自天空闭塞部分的光线。</p>
<p><strong>我们将专注于编码整个球形或半球形可见性的方法，即用来描述哪个方向挡住了入射的辐射。虽然这个信息可以用来遮蔽准时的灯光，但这不是它的主要目的。针对这些特定类型的光的方法(在第7章中广泛讨论)能够获得更好的质量，因为它们需要为光源的单个位置或方向编码可见性。这里描述的解决方案主要用于为大面积光或环境照明提供遮挡生成的阴影是柔和的，由近似可见性引起的伪影是不明显的。此外，这些方法还可以用于在常规阴影技术不可行的情况下提供遮挡，如凹凸贴图细节的自阴影，以及超大场景的阴影，其中阴影贴图没有足够的分辨率。</strong></p>
<h3 id="Precomputed-Directional-Occlusion-预先计算的方向遮蔽"><a href="#Precomputed-Directional-Occlusion-预先计算的方向遮蔽" class="headerlink" title="Precomputed Directional Occlusion 预先计算的方向遮蔽"></a>Precomputed Directional Occlusion 预先计算的方向遮蔽</h3><p><strong>Max引入了水平映射的概念来描述高度场表面的自遮挡。在地平制图中，对于地面上的每一点，确定一组方位角方向的地平高度角，如八:北，东北，东，东南，在周围。</strong></p>
<p><strong>作为一个整体，未被遮挡的三维方向集可以被建模为一个椭圆形或圆形孔径，而不是存储某些给定罗盘方向的地平角。后一种技术称为环境光圈照明(下图)。这些技术的存储要求比地平线图低，但当未被遮挡的方向集不像椭圆形或圆形时，可能会导致不正确的阴影。例如，在一个平面上，每隔一定的间隔就会有一个高尖刺突出来，这个平面应该有一个星形的方向集，这就不能很好地映射到方案中。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015152743.png" class="" title="image-20211015152743">

<p>环境光圈照明近似于阴影点上方未遮挡区域的实际形状。在左边，区域光源用黄色显示，而地面位置的可见地平线用蓝色显示。在右边，地平线被简化为一个圆，这是从表面位置向上和向右突出的一个圆锥的边缘，用虚线显示。然后估计区域光的遮挡，通过将其圆锥与遮挡圆锥相交，得到红色显示的区域。</p>
<p><strong>遮挡技术有许多变体。Wang等人使用球面带符号距离函数(SSDF)来表示能见度。它编码一个带符号的距离到球体上被遮挡区域的边界。第10.3节中讨论的任何球形或半球形基也可以用于编码能见度。就像环境遮蔽一样，方向可见性信息可以存储在纹理、网格顶点或体积中。</strong></p>
<h3 id="Dynamic-Computation-of-Directional-Occlusion-方向遮蔽的动态计算"><a href="#Dynamic-Computation-of-Directional-Occlusion-方向遮蔽的动态计算" class="headerlink" title="Dynamic Computation of Directional Occlusion 方向遮蔽的动态计算"></a>Dynamic Computation of Directional Occlusion 方向遮蔽的动态计算</h3><p><strong>许多用于生成环境遮挡的方法也可以用来生成方向能见度信息。Ren等人的球谐指数法，以及Sloan等人的屏幕空间变量法产生球谐向量形式的可见性。如果使用一个以上的SH波段，这些方法本身就提供方向信息。使用更多的波段可以使编码可见性更精确。</strong></p>
<p><strong>如来自Crassin等和Wright的圆锥跟踪方法，为每个轨迹提供一个遮挡值。由于质量原因，即使是环境遮挡估计也使用多个轨迹，因此可用信息已经具有方向性。如果需要特定方向的能见度，我们可以追踪更少的锥。</strong></p>
<p><strong>Iwanicki也使用了圆锥追踪，但他将其限制在一个方向上。结果被用于生成由一组球体近似的动态特征投射到静态几何上的软阴影，类似于Ren等人和Sloan等人。在这个解决方案中，静态几何的光照使用AHD编码存储(章节10.3.3)。环境和方向组件的可见性可以独立处理。对环境部分的遮挡进行了解析计算。绘制单个圆锥并与球体相交以计算方向分量的衰减因子。</strong></p>
<p><strong>许多屏幕空间方法也可以扩展为提供定向遮挡信息。Klehm等人使用z-buffer数据计算屏幕空间弯曲锥，这些锥实际上是圆形孔径，很像Oat和Sander离线预计算的那些锥。当对一个像素的邻域采样时，它们对未遮挡方向求和。结果向量的长度可用于估计能见度锥的顶角，它的方向定义了这个锥的轴。Jimenez等人根据地平角估计圆锥轴方向，并从环境遮挡因子得出角度。</strong></p>
<h3 id="Shading-with-Directional-Occlusion-有方向遮蔽的着色"><a href="#Shading-with-Directional-Occlusion-有方向遮蔽的着色" class="headerlink" title="Shading with Directional Occlusion 有方向遮蔽的着色"></a>Shading with Directional Occlusion 有方向遮蔽的着色</h3><p><strong>有这么多不同的编码方向遮挡的方法，我们不能提供一个单一的处方如何执行着色。解决方案将取决于我们想要达到的具体效果。</strong></p>
<p><strong>让我们再次考虑反射方程，在一个入射辐亮度分裂为远处光照Li 的版本中及其能见度v:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015154705.png" class="" title="image-20211015154705">

<p><strong>我们能做的最简单的操作就是利用能见度信号对准时的灯光进行投影。由于大多数编码可见性的方法都很简单，所以结果的质量往往不能令人满意，但它允许我们根据一个基本的例子进行推理。这种方法也可以用于传统的阴影方法由于分辨率不足而失败的情况，结果的精度比实现任何形式的遮挡都不重要。这种情况的例子包括非常大的地形模型，或者用凹凸贴图表示的小的表面细节。</strong></p>
<p><strong>在第9.4节讨论之后，当处理准时照明时，上式变成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015154754.png" class="" title="image-20211015154754">

<p><strong>其中clight 是在面对光线的白色朗伯式表面反射出的亮度，而lc 是指向光的方向。我们可以将上述方程解释为计算材料对未遮挡光的响应，并将结果乘以能见度函数的值。如果光的方向落在地平线下(当使用地平线贴图时)，在能见度锥外(当使用环境光圈照明时)，或在SSDF的负区域，能见度函数等于零，因此光的任何贡献都不应该被考虑。值得一提的是，尽管可见性被定义为二进制函数，许多表示形式可以返回整个范围的值，而不仅仅是0或1。这样的值表示部分遮挡。球谐或H基甚至可以重建负值，由于振铃。这些行为可能是不需要的，但只是编码的固有属性。</strong></p>
<p><strong>我们可以对区域灯的照明进行类似的推理。在这种情况下是Li 在任何地方都等于零，除了在光线所面对的立体角内，它等于这个光源发出的亮度。我们称它为Ll 假设它在光的实心角度上是恒定的。我们可以用光的实心角度的积分Ω代替整个球面的积分Ωl：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165151.png" class="" title="image-20211015165151">

<p><strong>如果我们假设BRDF是常数——所以我们在处理一个朗伯曲面——它也可以从积分下面拉出来:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165225.png" class="" title="image-20211015165225">

<p><strong>为了确定遮挡光照，我们需要计算能见度函数乘以余弦项除以光线所覆盖的立体角的积分。在某些情况下，这可以通过分析来实现。Lambert推导了一个计算球面多边形上余弦积分的公式。如果我们的区域光是多边形的，并且我们可以将它与可见性表示进行剪辑，那么我们只需要使用Lambert公式来得到一个精确的结果(下图)。这是可能的，例如，当我们选择视界角度作为我们的可见性表示。然而，如果由于某种原因我们选择了另一种编码，例如弯曲锥，剪切将产生圆形段，我们不能再使用Lambert公式。同样，如果我们想使用非多边形区域灯。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165308.png" class="" title="image-20211015165308">

<p>一个黄色多边形光源可以投射到一个单位半球上的阴影点，形成一个球形多边形。如果能见度是用地平线映射来描述的，那么这个多边形可以被裁剪到它上面。红色裁剪多边形的余弦加权积分可以用朗伯公式进行解析计算。</p>
<p><strong>另一种可能是假设余弦项的值在整个积分域中是常数。如果光的面积很小，这个近似是相当精确的。为了简单起见，我们可以使用余弦值在区域光的中心方向的值。这就剩下能见度项对光线立体角的积分了。我们的选择取决于，我们的可见性表示和面灯类型的选择。如果我们使用球面光和弯曲锥表示的能见度，积分的值是能见度锥与光线所面对的锥交点的立体角。它可以通过解析计算得到，如Oat和Sander所示。虽然确切的公式很复杂，但它们提供了一个在实践中很有效的近似。如果能见度用球谐编码，积分也可以用解析方法计算。</strong></p>
<p><strong>对于环境照明，我们不能限制集成范围，因为照明来自四面八方。我们需要找到一种方法来计算11.26式的完整积分。让我们首先考虑朗伯BRDF:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165404.png" class="" title="image-20211015165404">

<p><strong>这个方程中的积分类型称为三重积积分。如果单个函数以特定的方式表示——例如，球谐函数或小波函数——它就可以通过分析来计算。不幸的是，这对于典型的实时应用程序来说太昂贵了，尽管这种解决方案已经被证明在简单的设置下以交互帧率运行。</strong></p>
<p><strong>我们的特殊情况稍微简单一点，因为其中一个函数是cos。我们可以把上式写成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165453.png" class="" title="image-20211015165453">

<p><strong>或</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165510.png" class="" title="image-20211015165510">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165519.png" class="" title="image-20211015165519">

<p><strong>这两个ˉLi(l)和ˉv(l)是球面函数，就像Li(l)和v (l)一样。与其计算三重积积分，不如先把cos乘以Li (上上上式)或vi 方程(上上式)。这样做使得被积函数只是两个函数的乘积。虽然这看起来可能只是一个数学技巧，但它显著简化了计算。如果因数用标准正交基表示，如球谐，则可以简单地计算二重积积分。它是它们系数向量的点积(第10.3.2节)。</strong></p>
<p><strong>我们仍然需要计算ˉLi(l)或者ˉv(l)但是因为它们包含了cos，这比完全一般的情况要简单。如果我们用球谐来表示函数，余弦投影到区域谐波(ZH)，一个球谐的子集，每个波段只有一个系数是非零的(章节10.3.2)。这个投影的系数有简单的解析公式。一个SH和一个ZH的乘积比一个SH和另一个SH的乘积的计算效率要高得多。</strong></p>
<p><strong>如果我们决定先将cos乘以v(上上方程)，我们可以离线进行，而不是只存储可见性。正如Sloan等人(第11.5.3节)所描述的，这是一种预先计算的亮度传递形式。然而，在这种形式下，我们不能对法线进行任何精细的修改，因为由法线控制的余弦项已经与可见性融合在一起了。如果我们想要模拟精确尺度的法向细节，我们可以用Li 乘以cos第一个方程(11.31)。由于我们事先不知道法线方向，我们可以预先计算不同法线的乘积，或者在运行时执行乘法。预计算Li 的乘积而离线余弦意味着，反过来，任何照明的改变都是受限制的，而允许照明在空间上改变将需要大量的内存。另一方面，在运行时计算产品在计算上是昂贵的。Iwanicki和Sloan描述了如何降低成本。产品可以在较低的粒度上计算——在它们的情况下，在顶点上。结果与余弦项进行卷积，投影到一个更简单的表示(AHD)上，然后用逐像素法向量插值并重建。这种方法允许他们在性能要求为60 FPS的游戏中使用这种方法。</strong></p>
<p><strong>Klehm等人提出了一种用环境地图和用圆锥体编码的能见度表示照明的解决方案。他们用不同大小的核过滤环境地图，这些核代表了一个产品的可视性和不同锥开口的照明的整体。它们存储在纹理的mip级别中增加锥角的结果。这是可能的，因为大锥角的预过滤结果在球体上平滑地变化，不需要以高角度分辨率存储。在预滤波时，他们假设视锥的方向与法线对齐，这是一个近似，但在实践中给出了可信的结果。他们分析了这种近似是如何影响最终质量的。</strong></p>
<p><strong>如果我们要处理光滑的BRDFs和环境照明，情况会更加复杂。我们不能再把BRDF从积分下面拉出来了，因为它不是常数。为了解决这个问题，Green等人建议用一组球面高斯函数来近似BRDF本身。这些是径向对称函数，可以只用三个参数来紧密表示:方向(或均值)d，标准差µ，和振幅w。近似的BRDF定义为球面高斯函数的和:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165955.png" class="" title="image-20211015165955">

<p><strong>其中G(d，µ，l)为球形高斯瓣，方向为d，具有锐度µ(章节10.3.2)，wk 在第k波瓣的振幅中。对于一个各向同性BRDF，波瓣的形状只取决于法线和视图方向之间的角度。近似可以存储在一维查找表中并进行插值。</strong></p>
<p><strong>根据这个近似，我们可以把11.26式写成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015170038.png" class="" title="image-20211015170038">

<p><strong>Green等人还假设能见度函数在每个球形高斯的整个支持范围内是恒定的，这允许他们将其从积分下拉出来。他们在波瓣中心方向评估能见度函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015170113.png" class="" title="image-20211015170113">

<p><strong>剩下的积分表示入射光与给定方向和给定标准偏差的球面高斯卷积。这种卷积的结果可以被预先计算并存储在环境地图中，较大的卷积存储在较低的mip层中。可见性用低阶球面谐波编码，但也可以使用任何其他表示，因为它只是点计算。</strong></p>
<p><strong>Wang等人以类似的方式近似BRDF，但以更精确的方式处理可见性。他们的表示允许他们计算一个单球面高斯在支持的可见性函数的积分。他们用这个值来引入一个新的球面高斯函数，它具有相同的方向和标准偏差，但振幅不同。他们在计算光照时使用这个新功能。</strong></p>
<p><strong>对于某些应用程序，这种方法可能过于昂贵。它需要从预过滤的环境地图中获取多个样本，而纹理采样通常已经是渲染过程中的一个瓶颈。Jimenez等人和El Garawany提出了更简单的近似。为了计算遮挡因子，它们用单个锥代表整个BRDF瓣，忽略其对视角的依赖，只考虑材料粗糙度等参数(下图)。他们将能见度近似为一个圆锥体，并计算能见度和BRDF圆锥体相交的立体角，就像对环境光圈照明所做的那样。标量结果被用来衰减光照。尽管它是一个显著的简化，结果是可信的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015170248.png" class="" title="image-20211015170248">

<p>为了计算遮挡，有光泽材料的镜面瓣可以表示为一个锥体。如果能见度近似为另一个锥体，遮挡因子可以计算为两者交点的实心角度，方法与环境光圈照明相同(上上图)。该图像显示了用锥表示BRDF波瓣的一般原理，但只是作为一种说明。在实践中，为了产生貌似合理的遮挡效果，锥体需要更宽一些。</p>
<h2 id="Diffuse-Global-Illumination-漫反射全局光照"><a href="#Diffuse-Global-Illumination-漫反射全局光照" class="headerlink" title="Diffuse Global Illumination 漫反射全局光照"></a>Diffuse Global Illumination 漫反射全局光照</h2><p><strong>接下来的部分将涵盖模拟各种方法，不仅是遮挡，还包括实时的全光反射。它们可以大致分为两种算法，即假设光线在到达人眼之前会从漫反射面或镜面反射。相应的光路可以分别写成L(D |S)∗DE或L(D|S)∗SE，其中许多方法对早期反弹的类型施加了一些约束。第一组的解决方案假设入射光在阴影点上方的半球上平滑地变化，或者完全忽略这种变化。第二组算法假设在入射方向上有很高的变化率。它们依赖于这样一个事实，即光线只能在一个相对较小的实心角度内进入。由于这些约束有很大的不同，分开处理这两组是有益的。我们将在这一节介绍漫反射全局照明的方法，下一节介绍镜面照明，然后在最后一节介绍统一的方法。</strong></p>
<h3 id="Surface-Prelighting-表面预照明"><a href="#Surface-Prelighting-表面预照明" class="headerlink" title="Surface Prelighting 表面预照明"></a>Surface Prelighting 表面预照明</h3><p><strong>辐射度和路径跟踪都是为离线使用而设计的。虽然已经有人在实时设置中使用它们，但结果仍然太不成熟，不能用于生产。目前最常见的做法是使用它们来预计算光照相关的信息。这种昂贵的离线过程会提前运行，其结果会被存储起来，然后在显示过程中使用，以提供高质量的照明。如第11.3.4节所述，以这种方式对静态场景进行预计算称为烘培。</strong></p>
<p><strong>这种做法有一定的限制。如果我们提前执行光照计算，我们就不能在运行时更改场景设置。所有场景的几何形状、灯光和材料需要保持不变。我们不能改变时间，也不能在墙上炸个洞。在许多情况下，这种限制是可以接受的。建筑可视化可以假设用户只能在虚拟环境中行走。游戏也会限制玩家的行动。在这些应用中，我们可以把几何分为静态和动态对象。静态对象在预计算过程中使用，它们与照明完全交互。静态的墙投射阴影和静态红地毯反射红光。动态对象只能作为接收者。它们不会阻挡光线，也不会产生间接照明效果。在这种情况下，动态几何通常被限制为相对较小的，所以它对其他照明的影响可以忽略或使用其他技术建模，以最小的质量损失。例如，动态几何学可以使用屏幕空间方法来生成遮挡。一组典型的动态对象包括角色、装饰几何体和车辆。</strong></p>
<p><strong>可以预先计算的最简单的照明信息形式是辐照度。对于平面，朗伯的表面，连同表面颜色，它完全描述了材料对光线的反应。由于光源的效果是独立于其他光源的，因此可以在预先计算的辐照度上添加动态光源(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015205157.png" class="" title="image-20211015205157">

<p>给定一个具有已知法线的朗伯曲面，就可以预先计算出它的辐照度。在运行时，这个值乘以实际的表面颜色(例如，从纹理)来获得反射的亮度。根据表面颜色的确切形式，可能需要额外除以π以确保节能。</p>
<p><strong>1996年的Quake和1997年的Quake II是第一个使用预先计算的辐照度值的商业交互式应用程序。Quake预先计算了静态光的直接贡献，主要是作为一种提高性能的方法。《雷神之锤2》也包含了一个间接组件，这使得它成为第一款使用全局光照算法来生成更真实光照的游戏。它使用了一种基于辐射的算法，因为这种技术非常适合在朗伯环境中计算辐照度。此外，记忆的时间限制限制了照明的相对低分辨率，这与模糊，低频阴影典型的辐射解决方案。</strong></p>
<p><strong>预先计算的辐照度值通常与漫反射颜色或反照率地图相乘，存储在一个单独的纹理集。虽然在理论上可以预先计算出出度(辐照度乘以漫射颜色)并存储在一组纹理中，但在大多数情况下，许多实际考虑都排除了这个选项。颜色地图的使用频率通常很高，它们使用各种各样的贴图，并且它们的部分经常在模型中被重用，所有这些都是为了保持合理的内存使用。辐照度值的频率通常要低得多，不容易重复使用。保持光照和表面颜色分离会消耗更少的内存。</strong></p>
<p><strong>目前，除了最严格的硬件平台外，很少使用预先计算的辐照度。由于根据定义，辐照度是在给定的法线方向上计算的，因此我们不能使用法线映射来提供高频细节。这也意味着只能预先计算平面的辐照度。如果我们需要在动态几何体上使用烘烤光照，我们需要其他方法来存储它。这些限制促使人们寻找一种方法来存储带有方向组件的预计算光照。</strong></p>
<h3 id="Directional-Surface-Prelighting-定向表面预照明"><a href="#Directional-Surface-Prelighting-定向表面预照明" class="headerlink" title="Directional Surface Prelighting 定向表面预照明"></a>Directional Surface Prelighting 定向表面预照明</h3><p><strong>为了在朗伯曲面上使用预光照和法线映射，我们想要一种方法来表示辐照度如何随表面法线变化。为动态几何提供间接照明，我们还需要它的值为每个可能的表面方向。幸运的是，我们已经有了表示这些函数的工具。在第10.3节中，我们描述了根据法线方向确定光照的各种方法。这包括函数域是半球形的情况下的特殊解决方案，球体下半部分的值无关紧要，就像不透明表面的情况一样。</strong></p>
<p><strong>最常用的方法是存储全球面辐照度信息，例如利用球面谐波。该方案首先由Good和Taylor在加速光子映射的背景下提出，并由Shopf等人在实时设置中使用。在这两种情况下，方向辐照度都存储在纹理中。如果使用九个球谐系数(三阶SH)，质量很好，但存储和带宽成本很高。仅仅使用四个系数(二阶SH)是比较便宜的，但是许多细微之处会丢失，灯光对比度更低，法线贴图也不那么明显。</strong></p>
<p><strong>Chen在光晕3中使用了一种方法的变体，开发该方法是为了以更低的成本实现三阶SH的质量。他从球形信号中提取出最主要的光，并将其分别存储为颜色和方向。残差使用二阶SH编码，这将系数的数目从27减少到18，几乎没有质量损失。Hu描述了如何进一步压缩这些数据。Chen和Tatarchuk提供了他们在生产中使用的基于GPU的烘烤管道的进一步信息。</strong></p>
<p><strong>Habel等人提出的H基是另一种解决方案。由于它只编码半球信号，较少的系数可以提供与球面谐波相同的精度。只需6个系数就可以得到与三阶SH相当的质量。因为基是为一个半球定义的，我们需要在表面上的一些局部坐标系来正确地定位它。通常，由紫外线参数化得到的切线框架用于此目的。如果将h基组件存储在纹理中，其分辨率应该足够高，以适应底层切线空间的变化。如果多个切线空间显著不同的三角形覆盖同一像素，重构信号将不精确。</strong></p>
<p><strong>球谐和H基的一个问题是它们可以表现出振铃(章节10.6.1)。虽然预滤波可以缓和这种效果，但它也可以使光线更平滑，这可能并不总是可取的。此外，即使是价格较低的变体，在存储和计算方面的成本也相对较高。在更严格的情况下，例如在低端平台或在呈现虚拟现实时，这种开销可能会令人望而却步。</strong></p>
<p><strong>成本是简单的替代品仍然受欢迎的原因。《半条命2》使用自定义的半球形基础(第10.3.3节)，存储三个颜色值，每个样本共九个系数。环境/高光/方向(AHD)基础(章节10.3.3)也是一个受欢迎的选择，尽管它很简单。它已被用于《使命召唤》系列和《最后生存者》等游戏中。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015211436.png" class="" title="image-20211015211436">

<p>《使命召唤:第二次世界大战》使用了AHD表示法来编码光照地图中光照的方向变化。该网格用于在调试模式中可视化光地图密度。每个正方形对应一个光贴图texel。(图片由动视出版公司提供，2018年)</p>
<p><strong>Crytek在《孤岛惊魂》中使用了一种变体。Crytek表示法由切线空间中的平均光方向、平均光色和标量方向因子组成。最后一个值用于混合环境和方向组件，它们都使用相同的颜色。这将每个样本的存储减少到6个系数:3个颜色值，2个方向值，1个方向因子值。Unity引擎也在其中一个模式中使用了类似的方法。</strong></p>
<p><strong>这种类型的表示是非线性的，这意味着，从技术上讲，线性插值单个组件，无论是在像素或顶点之间，都不是数学的正确。如果主导光的方向变化迅速，例如在阴影边界上，视觉伪影可能会出现在阴影中。尽管有这些不准确之处，但结果在视觉上还是令人满意的。由于环境和方向光照区域之间的高对比度，法线贴图的效果被强调，这通常是可取的。此外，方向性成分可以用于计算BRDF的镜面反射响应，为低光泽材料的环境地图提供低成本的替代方案。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015211620.png" class="" title="image-20211015211620">

<p>The Order:1886存储投射到一组球面高斯叶上的入射亮度。在运行时，将亮度与余弦瓣进行卷积以计算漫反射响应(左图)，并使用适当形状的各向异性球面高斯函数生成镜面响应(右图)。(图片由Ready at Dawn Studios提供，版权为索尼互动娱乐公司。)</p>
<p><strong>在光谱的另一端是为高视觉质量设计的方法。Neubelt和Pettineo在游戏《the Order: 1886》(上图)中使用纹理贴图存储球形高斯系数。它们存储的不是辐照度，而是入射辐亮度，它被投影到一组高斯叶(章节10.3.2)，在切线框架中定义。根据特定场景中灯光的复杂程度，他们使用5到9个瓣叶。为了产生扩散响应，球面高斯函数与沿表面法线方向的余弦瓣进行卷积。通过将高斯波与高光BRDF波瓣进行卷积，这种表示法也足够精确，足以提供低光泽的镜面效果。Pettineo详细描述了整个系统。他还提供了一个能够烘培和渲染不同照明表示的应用程序的源代码。</strong></p>
<p><strong>如果我们需要关于任意方向的照明信息，而不仅仅是在表面上方的一个半球内(例如，为动态几何体提供间接照明)，我们可以使用编码完整球形信号的方法。球面谐波在这里是很自然的。当记忆不那么重要时，三阶SH(每个颜色通道九个系数)是最受欢迎的选择;否则，将使用二阶系数(每个颜色通道有四个系数，这与RGBA纹理中的组件数量相匹配，因此一个地图可以存储一个颜色通道的系数)。球面高斯函数也可以在一个完全球形的环境下工作，因为叶状结构可以分布在整个球体上，也可以只分布在法线周围的半球上。然而,由于对于球形技术来说，需要被瓣覆盖的立体角是两倍大，我们可能需要使用更多瓣来保持相同的质量。</strong></p>
<p><strong>如果我们想避免处理振铃，但又负担不起使用大量的瓣，环境立方体(第10.3.1节)是一个可行的选择。它由6个沿长轴固定的cos²瓣组成。每个余弦叶只覆盖一个半球，因为它们有局部支持，这意味着它们只有在其球域的子集上有非零值。因此，在重建过程中只需要六个存储值中的三个可见叶。这限制了照明计算的带宽成本。重构质量与二次球面谐波相似。</strong></p>
<p><strong>环境骰子(也是第10.3.1节)可以用于比环境立方体更高的质量。该方案使用沿二十面体顶点方向的12个瓣，这些瓣是cos²和cos⁴瓣的线性组合。存储的12个值中有6个在重构期间使用。其质量可与三阶球面谐波相媲美。这些和其他类似的表示(例如，由三个cos²组成的基) 叶和余弦叶扭曲覆盖一个实心球)已经使用在许多商业成功的游戏,比如半条命2,《使命召唤》系列,Far Cry 3,Tom Clancy’s The Division,和刺客信条4:黑旗,等等。</strong></p>
<h3 id="Precomputed-Transfer-预先计算的变换"><a href="#Precomputed-Transfer-预先计算的变换" class="headerlink" title="Precomputed Transfer 预先计算的变换"></a>Precomputed Transfer 预先计算的变换</h3><p><strong>虽然预先计算的光照看起来令人惊叹，但它本身也是静态的。任何几何体或照明的改变都会使整个解决方案失效。就像在现实世界中一样，打开窗帘(局部改变场景中的几何形状)可能会使整个房间充满光(全局改变照明)。人们花费了大量的研究工作来寻找能够允许某些类型变化的解决方案。</strong></p>
<p><strong>如果我们假设场景的几何形状没有变化，只改变了灯光，我们就可以预先计算光线如何与模型交互。物体间效应，如相互反射或地下散射，可以预先分析到一定程度，并将结果存储起来，而无需对实际辐射值进行操作。将入射光线转化为整个场景中亮度分布的描述的函数称为传递函数。预先计算这个的解决方案称为预先计算转移或预先计算辐射转移(PRT)方法。</strong></p>
<p><strong>与完全脱机烘培照明不同，这些技术确实有明显的运行成本。当在屏幕上显示场景时，我们需要计算特定照明设置的亮度值。为了做到这一点，直接光的实际数量被“注入”到系统中，然后传递函数被应用到整个场景中。有些方法假设这种直接光照来自环境地图。其他方案允许照明设置是任意的，并以灵活的方式改变。</strong></p>
<p><strong>斯隆等人将预先计算的亮度传递概念引入图形。他们用球谐来描述它，但方法不必使用SH，基本思想很简单。如果我们使用一些(最好是较低的)“构建块”灯来描述直接照明，我们就可以预先计算每个灯如何照亮场景。假设一个房间里有三台电脑显示器，每个显示器只能显示一种颜色，但亮度不同。考虑每个屏幕的最大亮度等于1，一个标准化的“单位”亮度。我们可以独立地预估每个显示器对房间的影响。这个过程可以使用第11.2节中介绍的方法来完成。因为光传输是线性的，用所有三个显示器照亮场景的结果将等于每个显示器直接或间接发出的光的总和。每个显示器的照明不会影响其他解决方案，所以如果我们将其中一个屏幕的亮度设置为原来的一半，这样做只会改变它对总照明的贡献。</strong></p>
<p><strong>这使我们能够快速计算整个房间内的全部反射光线。我们将每一个预先计算的光解乘以屏幕的实际亮度，并将结果相加。我们可以打开或关闭显示器，使它们更亮或更暗，甚至改变它们的颜色，所有需要得到的最终照明是这些倍数和添加(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015212627.png" class="" title="image-20211015212627">

<p>使用预先计算的亮度传递的渲染示例。从三个显示器的全部照明运输分别预先计算，获得一个“单位”响应。由于光传输的线性，这些单独的解决方案可以乘以屏幕的颜色(这里的例子中是粉色、黄色和蓝色)来获得最终的照明。</p>
<p><strong>我们可以写</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015212717.png" class="" title="image-20211015212717">

<p><strong>L(p)是p, Li(p)为屏幕i预计算的单位贡献，wi 就是它当前的亮度。这个方程用Li 定义了一个数学意义上的向量空间是这个空间的基向量。任何可能的照明都可以由灯光贡献的线性组合创建。</strong></p>
<p><strong>斯隆等人的原始PRT论文使用了相同的推理，但是在使用球面谐波表示的无限远的照明环境的背景下。它们不是存储场景对监视器屏幕的响应，而是存储场景对周围光线的响应，其分布由球谐基函数定义。通过这样做一些SH波段，他们可以渲染一个场景照明任意的照明环境。他们将这个照明投射到球面谐波上，将每个结果系数乘以其各自的标准化“单位”贡献，然后将这些加在一起，就像我们在监视器上做的那样。</strong></p>
<p><strong>请注意，用于将光线“注入”到场景中的基础的选择是独立于用于表达最终照明的表示的。例如，我们可以用球谐来描述场景是如何被照亮的，但是选择另一个基底来存储在任何给定点到达的亮度。假设我们用一个环境立方体来储存。我们可以计算出有多少光辉来自顶部，有多少来自侧面。每个方向的转移将被单独存储，而不是作为代表总转移的单个标量值。</strong></p>
<p><strong>斯隆等人的PRT论文分析了两个案例。第一种是当接收基只是表面的标量辐照度值时。为此，接收器需要是一个完全扩散的表面，与预定法线，这意味着它不能使用法线地图为精细的细节。传递函数的形式是输入光照的SH投影和预先计算的传递向量之间的点积，它在场景中随空间变化。</strong></p>
<p><strong>如果我们需要渲染非朗伯材料，或者允许法线映射，我们可以使用第二种变体。在这种情况下，将周围光线的SH投影转换为某一给定点的入射亮度的SH投影。因为这个操作为我们提供了整个球体(或半球，如果我们处理的是一个静态不透明物体)的亮度分布，我们可以适当地将它与任何BRDF卷积。传递函数将SH向量映射到其他SH向量，并具有矩阵乘法的形式。这个乘法运算在计算和内存方面都很昂贵。如果我们对源和接收器都使用三阶SH，我们需要为场景中的每个点存储9×9矩阵，这些数据仅用于单色传输。如果我们想要颜色，我们需要三个这样的矩阵——每个点都有难以置信的内存。</strong></p>
<p><strong>一年后，斯隆等人解决了这个问题。不直接存储传输向量或矩阵，而是使用主成分分析(PCA)技术对它们的整个集合进行分析。传递系数可以考虑多维空间中的点(例如，在81维的情况下，9 × 9矩阵)，但它们的集合在该空间中不是均匀分布的。它们形成低维度的簇。这种集群就像三维空间的一维子空间中的三维点沿直线分布一样有效。PCA可以有效地检测这种统计关系。一旦发现了一个子空间，点就可以用更少的坐标表示，因为我们可以用更少的维数存储子空间中的位置。用直线类比，不是用三个坐标存储点的全部位置，我们可以只存储点沿直线的距离。Sloan等人使用这种方法将转移矩阵的维数从625维(25 × 25转移矩阵)降至256维。虽然这对于典型的实时应用程序来说仍然过高，但许多后来的轻传输算法已经采用PCA作为压缩数据的方法。</strong></p>
<p><strong>这种类型的降维本质上是有损的。在极少数情况下，数据会形成一个完美的子空间，但大多数情况下它是近似的，所以将数据投射到它上面会导致一些退化。为了提高质量，Sloan等人将转移矩阵集合划分为簇，并分别对每个簇执行PCA。该过程还包括一个优化步骤，以确保在集群边界上没有不连续。还提出了一种允许物体有限变形的扩展，称为局部可变形预计算辐射转移(LDPRT)。</strong></p>
<p><strong>PRT已经在一些游戏中以各种形式被使用。在那些游戏玩法侧重于户外区域(游戏邦注:这些区域的时间和天气状况会发生动态变化)的游戏中，这种方法尤其受欢迎。《孤岛惊魂3》和《孤岛惊魂4》使用PRT，其中源基础是二阶SH，接收基础是定制的四方向基础。《刺客信条4:黑旗》使用一种基本功能作为源(太阳色)，但会预计算一天中不同时间的转移。这种表示可以解释为在时间维度而不是方向上定义源基函数。接收器基础与《孤岛惊魂》中使用的相同。</strong></p>
<p><strong>关于预计算辐射传递的SIGGRAPH 2005课程提供了该领域研究的一个很好的概述。Lehtinen给出了一个数学框架，可以用来分析各种算法之间的差异，并开发新的算法。</strong></p>
<p><strong>最初的PRT方法假设周围的光线无限远。虽然这个模型的室外场景照明相当好，但它对室内环境的限制太大。然而，正如我们前面提到的，这个概念完全不知道照明的初始来源。Kristensen等人描述了一种计算整个场景中一组散射光的PRT的方法。这相当于拥有大量的“源”基函数。接下来，这些光被组合成簇，接收的几何图形被分割成区域，每个区域受不同子集的光的影响。这个过程导致传输数据的显著压缩。在运行时，由任意放置的光源产生的照明是通过从预计算集中最接近的光源中插值数据来近似的。Gilabert和Stefanov在《Far Cry 3》中使用这种方法生成间接照明。这种方法的基本形式只能处理点光源。而它可以扩展到支持其他类型，成本随着每个光的自由度的数量呈指数增长。</strong></p>
<p><strong>在这一点上讨论的PRT技术预先计算从一些元素的转移，然后使用这些元素建模的灯。另一类流行的方法是预计算曲面之间的转换。在这种类型的系统中，照明的实际来源变得无关紧要。任何光源都可以使用，因为这些方法的输入是某一组表面发出的辐亮度(或者其他一些相关的量，如辐照度，如果方法假设只扩散表面)。这些直接照明计算可以使用阴影(第7章)，辐照度环境图(第10.6节)，或本章前面讨论的环境和方向遮挡方法。任何表面也可以简单地通过设置其发出的亮度到一个期望的值，把它变成一个区域光源。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015213042.png" class="" title="image-20211015213042">

<p>几何启发可以实时生成全局光照效果。下图展示了它与Unity引擎整合的例子。用户可以自由地改变一天的时间，以及打开和关闭灯。所有间接照度实时更新。(庭院演示c Unity Technologies, 2015)</p>
<p><strong>根据这些原则运行的最流行的系统是Enlighten by Geomerics(上图)。虽然该算法的确切细节从未被完全公开，但无数的演讲和演讲给出了该系统原理的准确图像。</strong></p>
<p><strong>场景被假定为兰伯特式的，但仅仅是为了光转移的目的。使用Heckbert表示法，处理的路径集为LD∗(D|S)E，因为眼前的最后一个表面不需要仅进行扩散。系统定义了一组“源”元素和另一组“接收”元素。源元素存在于表面上，并且共享它们的一些属性，如漫反射颜色和法线。的预处理步骤计算光如何在源元素和接收器之间传输。这种信息的确切形式取决于源元素是什么，以及在接收器上收集光线的基础是什么。在最简单的形式中，源元素可以是点，然后我们感兴趣的是在接收位置产生辐照度。在这种情况下，传输系数就是源与接收者之间的相互可见性。在运行时，向系统提供所有源元件的出射亮度。根据这些信息，我们可以利用预先计算的能见度和已知的源和接收机的位置和方向信息，数值积分反射率方程(方程11.1)。用这种方法，光的一次反弹就完成了。由于大部分的间接照明来自于第一次反射，仅进行一次反射就足以提供合理的照明。然而，我们可以使用这个光并再次运行传播步骤来生成第二次光反弹。这通常是在几帧的过程中完成的，其中一帧的输出被用作下一帧的输入。</strong></p>
<p><strong>使用点作为源元素会导致大量的连接。为了提高性能，表示相似法线和颜色区域的点簇也可以用作源集。在这种情况下，传递系数与在辐射度算法中看到的形状因子相同(第11.2.1节)。请注意，尽管有相似之处，该算法与经典的辐射度不同，因为它每次只计算一次光的反弹，不涉及解线性方程组。它借鉴了渐进式辐射的概念。在这个系统中，一个小块可以通过迭代过程确定它从其他小块接收到多少能量。把辐射度传送到接收位置的过程称为收集。</strong></p>
<p><strong>接收元件上的辐射可以以不同的形式收集。向接收单元的传输可以使用我们前面描述的任何方向基。在这种情况下，单个系数成为一个值向量，其维数等于接收基中的函数数。当使用定向表示进行收集时，结果与第11.5.2节中描述的离线解决方案相同，因此它可以与法线映射一起使用，或提供低光泽度的镜面响应。</strong></p>
<p><strong>同样的概念在许多变体中被使用。为了节省内存，Sugden和Iwanicki使用SH转移系数，量化它们，并将它们间接存储为调色板中某项的索引。Jendersie等人构建了源补丁的层次结构，并在子节点所照顾的立体角太小时存储对该树中较高元素的引用。Stefanov引入了一个中间步骤，在这个步骤中，来自表面元素的辐射首先传播到场景的体素化表示，随后作为传输的源。</strong></p>
<p><strong>(在某种意义上)理想的表面分割成源块取决于接收器的位置。对于远处的元素，将它们视为独立的实体会产生不必要的存储成本，但在近距离观察时应该单独处理它们。源补丁的层次结构在一定程度上缓解了这个问题，但并不能完全解决它。某些补丁可以组合为特定的重新Ceivers之间的距离可能足以阻止这种合并。Silvennoinen和Lehtinen提出了一种解决这个问题的新方法。他们的方法不是显式地创建源补丁，而是为每个接收位置生成一组不同的源补丁。对象被渲染到散落在场景周围的一组稀疏的环境地图中。每个地图都被投影到球谐，这个低频版本“几乎”被投影回环境中。接收点记录他们能看到多少投影，这个过程是针对每个发送者的SH基函数分别完成的。这样做会根据来自环境探测和接收点的可见性信息，为每个接收方创建一组不同的源元素。</strong></p>
<p><strong>因为源基础是由环境地图投影到SH生成的，所以它自然地结合了较远处的表面。为了选择要使用的探测器，接收者使用了一种倾向于附近探测器的启发式方法，这使得接收者以类似的规模“看到”环境。为了限制必须存储的数据量，使用集群PCA对传输信息进行压缩。</strong></p>
<p><strong>Lehtinen等人描述了另一种预计算转移形式。在这种方法中，源和接收单元都不存在于网格中，而是具有体积的，可以在三维空间的任何位置进行查询。这种形式可以方便地在静态和动态几何之间提供光照一致性，但这种方法在计算上相当昂贵。</strong></p>
<p><strong>Loos等人在具有不同侧壁配置的模块化单元内预计算转移。然后缝合和弯曲多个这样的细胞，以近似的几何场景。亮度首先传播到作为界面的细胞边界，然后使用预先计算的模型传播到邻近的细胞。即使在移动平台上，这种方法也足够快速有效地运行，但由此产生的质量可能不足以满足要求更高的应用程序。</strong></p>
<h3 id="Storage-Methods-存储方法"><a href="#Storage-Methods-存储方法" class="headerlink" title="Storage Methods 存储方法"></a>Storage Methods 存储方法</h3><p><strong>无论我们是想使用完全预先计算的光照还是预先计算传输信息并允许光照的一些变化，结果数据都必须以某种形式存储。GPU友好的格式是必须的。</strong></p>
<p><strong>光照图是存储预计算光照最常见的方法之一。这些是存储预计算信息的纹理。虽然有时像辐照度图这样的术语被用来表示存储的特定类型的数据，但术语光图被用来统称所有这些数据。在运行时，使用GPU的内置纹理机制。值通常是双线性过滤的，这对于某些表示可能不是完全正确的。例如，当使用AHD表示时，滤波后的D(方向)分量在插值后将不再是单位长度，因此需要进行重正化。使用插值还意味着A(环境值)和H(高光值)并不完全是我们在采样点直接计算的结果。也就是说，结果通常看起来是可以接受的，即使表示是非线性的。</strong></p>
<p><strong>在大多数情况下，光贴图不使用mipmapping，这通常是不需要的，因为光贴图的分辨率比典型的反照率贴图或法线贴图小。即使在高质量的应用程序中，一个光贴图的texel至少可以覆盖20×20厘米的面积，通常还会更多。使用这种尺寸的像素，额外的mip级别几乎是不需要的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015213559.png" class="" title="image-20211015213559">

<p>光线被烘烤到一个场景中，连同灯光贴图应用到表面上。光映射使用一种独特的参数化。场景被划分为多个元素，这些元素被压平并打包成一个共同的纹理。例如，左下角的剖面对应于地面，显示了立方体的两个阴影。(来自three.js示例webgl materials lightmap。)</p>
<p><strong>为了在纹理中存储光照，对象需要提供一个独特的参数。当将漫反射颜色纹理映射到一个模型上时，通常网格的不同部分使用相同的纹理区域是很好的，特别是当一个模型的纹理具有一般的重复模式时。再使用灯光地图是非常困难的。光照对于网格上的每个点都是独特的，所以每个三角形都需要在光照地图上占据自己独特的区域。创建参数化的过程从将网格分割成更小的块开始。这既可以使用一些启发式自动完成，也可以使用创作工具手动完成。通常情况下，已经存在于其他纹理映射中的分割被使用。接下来，对每个chunk进行独立参数化，确保其各部分在纹理空间中不重叠。纹理空间中生成的元素称为图表或壳。最后，所有图表都打包到一个共同的纹理中(上图)。必须小心确保图表不仅不重叠，而且它们的过滤足迹必须保持分离。当渲染一个给定的图表时，所有可以访问的像素(双线性滤波访问四个相邻的像素)都应该被标记为使用过的，这样就不会有其他图表与它们重叠。否则，图表之间可能会出现出血现象，其中一个图表的光照可能会在另一个图表上可见。尽管为灯光地图系统提供一个用户控制的“排水沟”量用于灯光地图图表之间的间距是相当普遍的，但这种分离是不必要的。图表的正确过滤足迹可以通过在光映射空间中使用一套特殊规则进行栅格化自动确定。参见下图。如果炮弹栅格化这种方式不重叠，我们保证不会流血将发生。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015213714.png" class="" title="image-20211015213714">

<p>为了准确地确定一个图表的过滤足迹，我们需要找到渲染期间可以访问的所有texel。如果一个图表与四个相邻像素中心之间的正方形相交，那么所有这些像素都将用于双线性滤波。texel网格用实线标记，texel中心用蓝点，图表用粗实线进行栅格化(左)。我们首先保守地将图表栅格化为移动了一半像素大小的网格，并以虚线(中间)标记。任何接触标记单元格的texel都被认为占用(右)。</p>
<p><strong>避免出血是mipmapping很少用于光贴图的另一个原因。图表过滤足迹需要在所有mip水平上保持分离，这将导致壳之间的间距过大。</strong></p>
<p><strong>将图表最优地打包到纹理中是一个np完全问题，这意味着没有已知的算法可以生成具有多项式复杂性的理想解决方案。由于实时应用程序可能在一个纹理中有数十万个图表，所有真实世界的解决方案都使用微调的启发式和仔细优化的代码来快速生成打包。如果光照图稍后进行块压缩(章节6.2.6)，为了提高压缩质量，可能会向封隔器添加额外的约束条件，以确保单个块只包含类似的值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015213824.png" class="" title="image-20211015213824">

<p>为了为一个环面创建一个独特的参数化，它需要被切割和展开。左边的环面使用了一个简单的映射，创建时没有考虑到切割在纹理空间中的位置。注意左边代表像素的网格的不连续。使用更高级的算法，我们可以创建一个参数化，以确保texel网格线在三维网格上保持连续，就像右边那样。这种展开方法对于光线映射是完美的，因为产生的光线不会显示出任何不连续。</p>
<p><strong>光照贴图的一个常见问题是接缝(上图)。由于网格被分割成多个图表，并且每个图表都是独立参数化的，因此不可能确保分割边缘两侧的光照完全相同。这表现为视觉上的不连续性。如果网格是手动分割的，这个问题可以通过在不直接可见的区域分割来避免。然而，这样做是一个费力的过程，并且不能在自动生成参数化时应用。Iwanicki对最终的光照贴图进行后期处理，沿着分裂的边缘修改texel，以最小化两边插值值之间的差异。Liu和Ferguson等人通过等式约束强制沿边插值值匹配，并求解最能保持平滑的texel值。另一种方法是在创建参数化和包装图表时考虑这个约束。Ray等人展示了如何使用保持网格的参数化来创建不受接缝伪影影响的光映射。</strong></p>
<p><strong>预先计算的光照也可以存储在网格的顶点上。缺点是光照的质量取决于网格镶嵌的精细程度。因为这个决定通常是在创作的早期阶段做出的，很难确保网格上有足够的顶点来在所有预期的光照情况下看起来很好。此外，镶嵌可能是昂贵的。如果网格被精细地镶嵌，灯光信号将被过采样。如果使用定向存储光照的方法，整个表示需要由GPU在顶点之间插入，并传递到像素着色阶段来执行光照计算。在顶点和像素着色器之间传递如此多的参数是相当罕见的，并产生现代GPU没有优化的工作负载，这导致效率低下和性能较低。由于所有这些原因，在顶点上存储预先计算的光照很少被使用。</strong></p>
<p><strong>尽管关于入射亮度的信息在表面上是需要的(除了在做体积渲染时，在第14章讨论)，我们可以在体积上预计算和存储它。这样，就可以在空间的任意点查询光照，为在预计算阶段不存在的对象提供光照。但是请注意，这些物体不会正确地反射或遮挡光线。</strong></p>
<p><strong>Greger等人提出了辐照度体积，通过辐照度环境图的稀疏空间采样表示五维(三个空间和两个方向)辐照度函数。也就是说，在空间中有一个三维网格，在每个网格点上都有一个辐照度环境地图。动态对象从最近的地图中插值辐照度值。Greger等人使用两级自适应网格进行空间采样，但也可以使用其他体积数据结构，如八叉树。</strong></p>
<p><strong>在原始辐照度体积中，Greger等人将每个采样点的辐照度存储在一个小纹理中，但这种表示在GPU上无法有效过滤。如今，体积照明数据通常以三维形式存储纹理，所以体积采样可以使用GPU的加速过滤。样本点辐照度函数的最常见表示包括:</strong></p>
<pre><code>**•二阶和三阶球面谐波(SH)，前者更常见，因为一个颜色通道所需的四个系数方便地打包到四个典型纹理格式的通道。**

**•球高斯函数。**

**•环境立方体或环境骰子。**
</code></pre>
<p><strong>AHD编码，即使在技术上能够表示球面辐照度，也会产生分散的伪影。如果使用SH，球谐梯度可以进一步提高质量。以上所有表示方法都成功地应用于许多游戏。</strong></p>
<p><strong>Evans描述了一个在小小大星球上用来测量辐照度的技巧。不是一个完整的辐照度地图表示，平均辐照度存储在每个点。由辐照度场的梯度计算出近似的方向因子，即磁场变化最快的方向。代替显式计算梯度,梯度和表面之间的点积法线n是通过计算两个样品的辐照度,一个表面点p和另一个点的方向n,二者相减。这种近似表示是由于在小大星球上的辐照度体积是动态计算的。</strong></p>
<p><strong>辐照度体积也可以用来为静态表面提供照明。这样做的好处是不必为光线映射提供单独的参数化。这种技术也不会产生裂缝。静态和动态对象都可以使用相同的表示，使两种几何类型之间的照明一致。在延迟着色(第20.1节)中，体积表示很方便使用，其中所有照明都可以在一次通过中执行。其主要缺点是内存消耗。光图所使用的内存大小与分辨率的平方成正比;对于一个规则的体积结构，它与立方体一起增长。由于这个原因，网格体积表示使用了相当低的分辨率。自适应、分层形式的照明体量具有更好的特性，但它们仍然比照明地图存储更多的数据。它们也比有规则间隔的网格慢，因为额外的间接在着色器代码中创建加载依赖，这可能导致暂停和更慢的执行。</strong></p>
<p><strong>在体积结构中存储表面照明有点棘手。多个表面，有时有着非常不同的照明特性，可以占用相同的体素，这使得我们不清楚应该存储哪些数据。当从这些体素进行采样时，光照往往是不正确的。在光线明亮的室外和黑暗的室内之间的墙壁附近，这种情况尤其常见，结果要么是室外一片黑暗，要么是室内一片明亮。对此的补救措施是使体素大小足够小，以永远不会跨越这些边界，但这通常是不切实际的，因为所需的数据量。处理这个问题最常用的方法是沿法线移动采样位置，或者在插值过程中调整三线性混合权值。这通常是不完美的，可能需要手工调整几何体来掩盖问题。Hooker在辐照度体积上增加了额外的剪切平面，这将它们的影响限制在凸多面体的内部。Kontkanen和Laine讨论了各种减少出血的策略。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015214306.png" class="" title="image-20211015214306">

<p>Unity引擎使用一个四面体网格来插值一组探针的光照。(死亡之书——Unity Technologies, 2018)</p>
<p><strong>容纳照明的体积结构不必是规则的。一种流行的选择是将其存储在不规则的点云中，然后连接形成一个Delaunay四面体(上图)。Cupisz推广了这种方法。为了查看灯光，我们首先找到采样位置所在的四面体。这是一个迭代过程，可能会有些昂贵。我们遍历网格，在相邻的单元格之间移动。查找点相对于当前四面体角的重心坐标用于在下一个步骤中选择要访问的邻居(下图)。因为典型场景可能包含数千个位置，其中存储了照明，这个过程可能会很耗时。为了加快速度，我们可以记录一个四面体，用于在前一帧(如果可能的话)查找，或者使用一个简单的体积数据结构，为场景中的任意点提供一个良好的“开始四面体”。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015214401.png" class="" title="image-20211015214401">

<p>二维四面体网格的查找过程。步骤显示从左到右，从上到下。给定一些起始单元格(用蓝色标记)，我们计算查找点(蓝点)相对于单元格角的重心坐标。在接下来的步骤中，我们沿着与最负坐标的拐角相对的边缘向邻居移动。</p>
<p><strong>一旦正确的四面体被定位，存储在它的角落的光线被插值，使用已经可用的重心坐标。这个操作不被GPU加速，但是它只需要4个值来进行插值，而不是网格上的三线性插值需要8个值。</strong></p>
<p><strong>预先计算和存储光照的位置可以手动或自动。它们通常被称为照明探头，或光探头，因为它们探测(或取样)照明信号。这个术语不应与“光探头”(第10.4.2节)混淆，它是在环境地图上记录的远距离照明。</strong></p>
<p><strong>从一个四面体网格中采样的光照质量高度依赖于网格的结构，而不仅仅是探测器的总体密度。如果它们不均匀分布，产生的网格可能包含产生视觉伪影的细长四面体。如果用手放置探头，问题可以很容易地纠正，但这仍然是一个手动过程。四面体的结构与场景的几何结构没有关系，所以如果处理不当，灯光将会在墙壁上插入并产生流血的人工制品，就像辐照度体积一样。在手动放置探针的情况下，可以要求用户插入额外的探针以防止这种情况发生。当使用自动放置探针时，可以在探针或四面体上添加某种形式的可见性信息，以将其影响限制在相关区域。</strong></p>
<p><strong>对静态和动态几何图形使用不同的光照存储方法是一种常见的做法。例如，静态网格可以使用光照贴图，而动态对象可以从体积结构中获得光照信息。虽然很受欢迎，但这种方案可以在不同类型的几何形状之间创建不一致的外观。其中的一些差异可以通过正则化来消除，在正则化中，光照信息在表示中被平均。</strong></p>
<p><strong>当烘培照明时，只需要在它们真正有效的地方计算它的值。网格通常是不完美的。一些顶点可能被放置在几何体内部，或者部分网格可能自相交。如果我们在这些有缺陷的位置计算入射亮度，结果将是不正确的。它们会造成不必要的暗化或不正确的无着色照明。Kontkanen和Laine以及Iwanicki和Sloan讨论了可以用来丢弃无效样本的不同启发式方法。</strong></p>
<p><strong>环境和方向遮蔽信号共享漫射照明的许多空间特征。如第11.3.4节所述，上述所有方法也可以用于存储它们。</strong></p>
<h3 id="Dynamic-Diffuse-Global-Illumination-动态漫反射全局照明"><a href="#Dynamic-Diffuse-Global-Illumination-动态漫反射全局照明" class="headerlink" title="Dynamic Diffuse Global Illumination 动态漫反射全局照明"></a>Dynamic Diffuse Global Illumination 动态漫反射全局照明</h3><p><strong>尽管预计算光照可以产生令人印象深刻的结果，但它的主要优点也是它的主要缺点——它需要预计算。这种脱机流程可能会很长。在典型的游戏关卡中，光照烘培需要花费数小时的时间。因为光照计算需要很长时间，美工通常被迫同时处理多个关卡，以避免等待烘培完成时的停工时间。这反过来又会导致用于呈现的资源负载过大，并导致烘培时间更长。这种循环会严重影响生产力并导致挫败感。在某些情况下，甚至不可能预先计算光照，因为几何图形在运行时发生变化或在某种程度上由用户创建。</strong></p>
<p><strong>研究了动态环境下全局光照的模拟方法。它们要么不需要任何预处理，要么准备阶段足够快，可以每帧都执行。</strong></p>
<p><strong>最早在全动态环境中模拟全局光照的方法之一是基于“瞬时辐射度”。尽管名称如此，但该方法与辐射度算法几乎没有共同之处。在它里面，光线从光源向外投射。对于光线照射到的每一个位置，都放置一盏灯，代表来自该表面元素的间接照明。这些光源被称为虚点光源(VPLs)。基于这个想法，Tabellion和Lamorlette开发了一种在制作《怪物史莱克2》时使用的方法，该方法对场景表面进行直接照明，并将结果存储在纹理中。然后，在渲染过程中，该方法跟踪光线并使用缓存的照明创建单反射间接照明。Tabellion和Lamorlette表明，在许多情况下，一次弹跳就足以产生令人信服的结果。这是一种离线方法，但它启发了Dachsbacher和Stamminger的一种方法，即反射阴影地图(RSM)。</strong></p>
<p><strong>类似于常规阴影贴图(章节7.4)，反射阴影贴图是从光线的角度渲染的。除了深度之外，它们还存储了其他有关可见表面的信息，如反照率、正常照度和直接照度(通量)。当执行最后的着色时，RSM的像素被当作点光源来提供间接照明的单一反弹。因为一个典型的RSM包含几十万个像素，所以只选择其中的一个子集，使用重要度驱动启发式。Dachsbacher和Stamminger后来展示了如何通过逆转过程来优化该方法。不是从RSM中为每个着色点选择相关的像素，而是基于整个RSM和屏幕空间中的散开(章节13.9)创建一些灯。</strong></p>
<p><strong>该方法的主要缺点是它不能为间接照明提供遮挡。虽然这是一个重要的近似，但结果看起来是可信的，并且在许多应用程序中是可接受的。</strong></p>
<p><strong>为了达到高质量的效果，并在光运动时保持时间稳定，需要创建大量的间接光。如果创建的太少，它们往往会在RSM重新生成时迅速改变它们的位置，并导致工件闪烁。另一方面，从性能的角度来看，过多的间接光源是一个挑战。Xu描述了该方法是如何在《神秘海域4》中执行的。为了保持在性能限制范围内，他在每个像素上使用少量的光(16)，但是在几个帧上循环使用不同的光集，并暂时过滤结果(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015214940.png" class="" title="image-20211015214940">

<p>在《神秘海域4》中，玩家使用手电筒的反射阴影地图提供间接照明。左边的图像显示了没有间接贡献的场景。右边的图片已经启用了它。插图显示了没有(顶部)和启用(底部)时间过滤的帧的特写。它用于增加每个图像像素所使用的VPLs的有效数量。((UNCHARTED 4 A Thief ’s End  c / TM 2016 SIE. Created and developed by Naughty Dog LLC.)</p>
<p><strong>人们提出了不同的方法来解决间接遮挡的不足。Laine等人使用双抛物面阴影贴图作为间接光源，但将它们增量地添加到场景中，因此在任何一帧中只有少量的阴影贴图被渲染。Ritschel等人使用简化的、基于点的场景表示来渲染大量不完美的阴影地图。当直接使用时，这样的贴图很小，包含很多缺陷，但经过简单的过滤后，提供了足够的保真度，为间接照明提供适当的遮挡效果。</strong></p>
<p><strong>有些游戏使用了与这些解决方案相关的方法。Dust 514呈现了一个自上而下的世界视图，在需要的时候有多达四个独立的层。这些产生的纹理被用来进行间接照明的收集，很像Tabellion和Lamorlette的方法。在Kite演示中，使用类似的方法从地形提供间接照明，展示了Unreal Engine。</strong></p>
<h3 id="Light-Propagation-Volumes-光传播量"><a href="#Light-Propagation-Volumes-光传播量" class="headerlink" title="Light Propagation Volumes 光传播量"></a>Light Propagation Volumes 光传播量</h3><p><strong>辐射传输理论是模拟电磁辐射在介质中传播的一般方法。它解释了散射、发射和吸收。尽管实时图像努力呈现所有这些效果，但除了最简单的情况外，用于这些模拟的方法成本太高，无法直接用于渲染。然而，该领域中使用的一些技术在实时图形方面被证明是有用的。</strong></p>
<p><strong>光传播体积(LPV)是由Kaplanyan提出的，灵感来自于辐射传输中的离散坐标方法。在他的方法中，场景被离散成一个规则的三维网格。每个细胞都将保持一个方向分布的光辉流动通过它。他用二阶球面谐波来处理这些数据。在第一步中，光线被注入细胞，这些细胞的表面直接被光照射。可以使用反射阴影贴图来找到这些细胞，但也可以使用任何其他方法。注入的光线是被照亮的表面反射的亮度。因此，它形成了一个分布周围的法线，面对表面，并得到其颜色的材料的颜色。接下来，光线被传播。每个细胞分析其相邻细胞的辐射场。然后，它调整自己的分布，以适应来自各个方向的辐射。在一个单一的步骤中，辐射只传播到一个细胞的距离。需要多次迭代来进一步分发它(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015215433.png" class="" title="image-20211015215433">

<p>光线分布通过一个体积网格的三个传播步骤。左边的图像显示了由定向光源照亮的几何体反射的光的分布。注意，只有直接靠近几何图形的单元格具有非零分布。在随后的步骤中，来自邻近细胞的光被收集并通过网格传播。</p>
<p><strong>这种方法的重要优点是它为每个细胞产生一个完整的辐射场。这意味着我们可以使用任意的BRDF来做着色尽管当使用二阶球面谐波时，光滑BRDF的反射质量会相当低。Kaplanyan展示了漫反射和反射表面的例子。</strong></p>
<p><strong>为了允许光在更大的距离内传播，以及增加体积覆盖的面积，同时保持内存的合理使用，Kaplanyan和Dachsbacher开发了该方法的一个级联变体。他们不是使用单个细胞大小一致的体积，而是使用一组细胞逐渐变大，嵌套在一起的体积。光照被注入到所有的层次并独立地传播。在查找过程中，他们为给定的位置选择最详细的级别。</strong></p>
<p><strong>最初的实现没有考虑到间接照明的遮挡。修改后的方法使用了来自反射阴影贴图的深度信息，以及来自相机位置的深度缓冲区，以添加关于光阻挡器的信息到体块。这个信息是不完整的，但场景也可以在预处理过程中进行体素化，从而使用更精确的表示。</strong></p>
<p><strong>这种方法存在其他容积法的问题，其中最大的问题是出血。不幸的是，增加网格分辨率来修复它会导致其他问题。当使用更小的单元时，需要更多的迭代来在相同的世界空间距离上传播光，这使得该方法的成本大大增加。在网格的分辨率和性能之间找到平衡并非易事。该方法还存在混叠问题。有限的网格分辨率，再加上粗糙的辐射方向表示，导致信号在相邻单元之间移动时退化。空间工件，比如对角线条纹，可能会在多次迭代之后出现在解决方案中。其中一些问题可以通过在传播通过后执行空间滤波来消除。</strong></p>
<h3 id="Voxel-Based-Methods-基于体素锥体的方法"><a href="#Voxel-Based-Methods-基于体素锥体的方法" class="headerlink" title="Voxel-Based Methods 基于体素锥体的方法"></a>Voxel-Based Methods 基于体素锥体的方法</h3><p><strong>由Crassin提出的体素锥体跟踪全局照明(VXGI)也是基于体素化场景表示的。几何本身以稀疏体素八叉树的形式存储，在第13.10节中描述。关键的概念是，这种结构提供了一种类似于mipmap的场景表示，因此，例如，可以快速测试空间的遮挡。体素还包含关于它们所代表的几何形状反射的光的数量的信息。它是以定向形式存储的，因为辐射是在六个主要方向反射的。使用反射阴影贴图，直接光照首先注入到八叉树的最低层。然后将其向上传播到层次结构。</strong></p>
<p><strong>八叉树用于估计入射辐亮度。理想情况下，我们可以通过追踪光线来估计来自特定方向的亮度。然而，这样做需要很多光线，所以整个束的这些代替了接近一个圆锥跟踪他们的平均方向，只返回一个单一的值。精确地测试圆锥与八叉树的交点不是简单的，所以这个操作近似于沿着圆锥的轴对树进行一系列的查找。每次查找都读取树的层次，其节点大小与给定点的圆锥的横截面相对应。查找提供了在圆锥体原点方向反射的滤波亮度，以及几何形状所占查找足迹的百分比。这个信息被用来衰减来自后续点的光线，以一种类似于alpha混合的方式。跟踪整个锥体的遮挡情况。在每一步中，它被减少，以说明当前样品的几何占据的百分比。当积累辐亮度时，它首先乘以综合遮挡因子(下图)。该策略不能检测出由多个局部遮挡导致的完全遮挡，但结果是可信的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015215829.png" class="" title="image-20211015215829">

<p>体素锥体跟踪是通过对体素树的一系列过滤查找来近似一个精确的锥体跟踪。左侧显示的是三维轨迹的二维模拟。右侧显示体素化几何结构的层次表示，每一列显示的是树的越来越粗的层次。每行显示用于为给定示例提供覆盖率的层次结构的节点。选择所使用的级别，以便粗级别中的节点大小大于查找大小，而细级别中的节点大小小于查找大小。一个类似于三线性滤波的过程被用来在这两个选择的能级之间进行插值。</p>
<p><strong>为了计算漫射光，需要追踪一些锥。生成和强制转换的数量是性能和精度之间的折衷。追踪更多的视锥细胞可以提供更高质量的结果，但代价是花费更多的时间。假设余弦项在整个圆锥上是常数，因此这一项可以从反射率方程积分中提出。这样做使得漫射光照的计算简单到计算圆锥轨迹返回值的加权和。</strong></p>
<p><strong>如Mittring所述，该方法在虚幻引擎的原型版本中实现。他给出了开发人员需要的几个优化，使其作为一个完整的渲染管道的一部分运行。这些改进包括以较低的分辨率执行跟踪，并在空间上分布视锥。这样做的目的是让每个像素只追踪一个圆锥。漫射响应的全辐射是通过在屏空间中对结果进行滤波得到的。</strong></p>
<p><strong>使用稀疏八叉树存储照明的一个主要问题是查找成本很高。找到包含给定位置的叶节点对应于一系列内存查找，并穿插一个简单的逻辑来确定要遍历哪棵子树。一次典型的内存读取可能需要几百个周期。GPU试图通过并行执行多组着色线程(扭曲或波前)来隐藏这个延迟(第三章)。即使在任何给定的时间只有一组执行ALU操作，当它需要等待内存读取时，另一组代替它。同时激活的扭曲数量是由不同的因素决定的，但所有这些因素都与单个组使用的资源数量有关(第23.3节)。在遍历分层数据结构时，大部分时间都花在等待从内存中获取下一个节点上。然而，在此等待期间执行的其他翘曲很可能也会执行内存读取。由于与内存访问的数量相比，ALU工作很少，而且由于飞行中的翘曲总数量是有限的，因此，所有组都在等待内存而没有实际工作执行的情况是很常见的。</strong></p>
<p><strong>大量的失速翘曲会导致性能不佳，人们已经开发了一些方法来缓解这些效率低下的问题。McLaren用一组级联的三维纹理替换了八叉树，很像级联的光传播体积(章节11.5.6)。它们具有相同的维度，但覆盖的区域越来越大。通过这种方式，读取数据只需要一个常规的纹理查找—不需要依赖的读取。存储在纹理中的数据与稀疏体素八叉树中的数据相同。它们包含六个方向的反照率、占用率和反射照明信息。因为级联的位置会随着相机的移动而改变，物体会不断地进出高分辨率区域。由于内存的限制，不可能一直保留这些体素化版本，所以它们在需要时按需进行体素化。McLaren还描述了一些优化方法，使这一技术适用于FPS为30的游戏《the Tomorrow Children》(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015220204.png" class="" title="image-20211015220204">

<p>《The Tomorrow Children》游戏使用体素锥跟踪来渲染间接照明效果。(c 2016年索尼互动娱乐公司。“明日之子”是美国索尼互动娱乐有限责任公司的商标。)</p>
<h3 id="Screen-Space-Methods-屏幕空间方法-1"><a href="#Screen-Space-Methods-屏幕空间方法-1" class="headerlink" title="Screen-Space Methods 屏幕空间方法"></a>Screen-Space Methods 屏幕空间方法</h3><p><strong>就像屏幕空间环境遮挡(章节11.3.6)，一些漫反射全局照明效果可以仅使用存储在屏幕位置的表面值来模拟。这些方法不像SSAO那样流行，主要是因为有限的可用数据产生的工件更加明显。像颜色出血这样的效果是强烈的直接光照射相当恒定的颜色大面积的结果。像这样的表面通常不可能完全适应视图。这种情况使得反射光的数量强烈地依赖于当前帧，并随着相机的移动而波动。由于这个原因，屏幕空间方法仅用于在精细尺度上增加其他解决方案，超出了主算法所能达到的分辨率。游戏《Quantum Break》使用了这种类型的系统。辐照度体积用于模拟大规模的全局照明效果，屏幕空间解决方案提供有限距离的反弹光。</strong></p>
<h3 id="Other-Methods-其他方法"><a href="#Other-Methods-其他方法" class="headerlink" title="Other Methods 其他方法"></a>Other Methods 其他方法</h3><p><strong>Bunnell计算环境遮挡的方法(第11.3.5节)也允许动态计算全局光照效果。场景的基于点的表示(章节11.3.5)通过存储关于每个磁盘的反射辐亮度的信息来增强。在收集步骤中，不只是收集遮挡，可以在每个收集位置构建一个完整的入射亮度函数。就像环境遮蔽一样，必须执行后续步骤来消除来自闭塞磁盘的光照。</strong></p>
<h2 id="Specular-Global-Illumination-镜面全局光照"><a href="#Specular-Global-Illumination-镜面全局光照" class="headerlink" title="Specular Global Illumination 镜面全局光照"></a>Specular Global Illumination 镜面全局光照</h2><p><strong>前几节中介绍的方法主要用于模拟漫射全局照明。现在，我们将看看各种方法，可以用来渲染依赖视图的效果。对于有光泽的材料，镜面瓣比用于漫射照明的余弦瓣紧密得多。如果我们想要展示一种极其闪亮的材料，一种具有薄镜面瓣的材料，我们需要一种能够呈现高频细节的亮度表示。另外，这些条件也意味着反射率方程的评估只需要从一个有限的实心角度入射的光照，不像朗伯BRDF反射整个半球的光照。这与漫反射材料的要求完全不同。这些这些特性解释了为什么需要做出不同的权衡来实现实时的效果。</strong></p>
<p><strong>存储入射辐亮度的方法可用于提供粗略的视相关效果。当使用AHD编码或HL2基时，我们可以计算镜面反射响应，就好像照明来自编码方向的定向光(或三个方向，在HL2基的情况下)。这种方法确实提供了一些间接照明的高光，但它们是相当不精确的。对于AHD编码来说，使用这种方法尤其成问题，因为在AHD编码中，方向分量在很小的距离内就会发生巨大的变化。这种变化导致高光以不自然的方式变形。伪影可以通过空间方向滤波来减少。当使用HL2基时，如果相邻三角形之间的切空间快速变化，也会观察到类似的问题。</strong></p>
<p><strong>伪影也可以通过以更高的精度表示入射光来减少。Neubelt和Pettineo在游戏the Order: 1886中使用球形高斯瓣来表示入射辐射。为了渲染镜面效果，他们使用了Xu等人的方法，他们开发了一个典型微表面 BRDF的镜面响应的有效近似(章节9.8)。如果用一组球面高斯函数来表示光照，并假定菲涅耳项和遮蔽函数在其支撑上为常数，则反射率方程可近似为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016133846.png" class="" title="image-20211016133846">

<p><strong>其中Lk 为表示入射亮度的第k个球面高斯函数，M为菲涅耳和遮蔽函数的结合因子，D为NDF。Xu等人引入了一个各向异性球面高斯(ASG)，他们使用它来模拟NDF。它们还提供了计算SG和ASG乘积积分的有效近似，如上式所示。</strong></p>
<p><strong>Neubelt和Pettineo使用9到12个高斯叶来代表照明，这让他们只模拟适度光泽的材料。他们能够使用这种方法来代表大多数的游戏照明，因为游戏发生在19世纪的伦敦，高度抛光的材料，玻璃，和反射表面是罕见的。</strong></p>
<h3 id="Localized-Environment-Maps-本地化环境映射"><a href="#Localized-Environment-Maps-本地化环境映射" class="headerlink" title="Localized Environment Maps 本地化环境映射"></a>Localized Environment Maps 本地化环境映射</h3><p><strong>到目前为止讨论的方法还不足以令人信服地渲染抛光材料。对于这些技术，亮度场太粗糙，无法精确编码入射亮度的细节，这使得反射看起来很暗淡。如果使用相同的材料，产生的结果也与分析光的高光不一致。一种解决方案是使用更多的球面高斯函数或更高阶SH函数来获得我们需要的细节。这是可能的，但我们很快面临一个性能问题:SH和SGs都有全球支持。每个基函数在整个球面上都是非零的，这意味着我们需要所有的基函数来评估光照给定的方向。这样做变得非常昂贵，只需要很少的基函数，而不需要渲染清晰的反射，因为我们需要数千个基函数。也不可能以漫射照明通常使用的分辨率存储那么多数据。</strong></p>
<p><strong>在实时设置中提供全局照明的高光组件的最流行的解决方案是本地化的环境地图。它们解决了我们之前的两个问题。入射辐亮度表示为一个环境地图，因此只需要少量的值来评估辐亮度。它们也稀疏地分布在整个场景中，因此入射辐亮度的空间精度被增加的角分辨率所取代。这种在场景中特定点上渲染的环境映射通常称为反射探测。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016134321.png" class="" title="image-20211016134321">

<p>一个简单的场景，设置了局部反射探测。反射球代表探头位置。黄线表示框形反射代理。注意代理是如何近似场景的整体形状的。</p>
<p><strong>环境地图是自然适合渲染完美的反射，这是镜面间接照明。已经开发了许多使用纹理的方法来提供广泛的镜面效果(章节10.5)。所有这些都可以用于局部环境地图，以渲染间接照明的镜面响应。</strong></p>
<p><strong>《半条命2》是最早将环境地图与特定空间点绑定在一起的游戏之一。在他们的系统中，艺术家首先将采样地点放置在现场。在预处理步骤中，从每个位置渲染一个立方体映射。物体然后使用最近的位置的结果作为入射光在高光照明计算的表示。可能会发生相邻的对象使用不同的环境地图，这会导致视觉不匹配，但美工可以手动重写立方体地图的自动分配。</strong></p>
<p><strong>如果一个物体很小，环境地图从它的中心渲染(隐藏物体后，它不会出现在纹理中)，结果是相当精确的。不幸的是，这种情况很少见。通常相同的反射探头用于多个对象，有时具有显著的空间范围。镜面的位置离环境地图的中心越远，结果就越可能与现实不同。</strong></p>
<p><strong>Brennan和Bjorke提出了一种解决这个问题的方法。他们并没有将入射光视为来自于一个无限远的周围球体，而是假设它来自于一个有限大小的球体，半径是用户定义的。当查看入射辐亮度时，方向不是直接用于索引环境地图，而是作为来自评估的表面位置并与这个球体相交的射线。接下来，计算一个新的方向，从环境地图的中心到十字路口位置。这个向量作为查找方向。参见下图。该过程具有在空间中“固定”环境地图的效果。这样做通常被称为视差校正。同样的方法也可以用于其他原语，比如box。用于光线相交的形状通常称为反射代理。所使用的代理对象应该表示渲染到环境地图中的几何图形的一般形状和大小。虽然通常不可能，但如果它们完全匹配，例如用一个盒子来代表一个矩形的房间，这种方法就能提供完美的局部反射。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016134442.png" class="" title="image-20211016134442">

<p>使用反射代理在空间上定位环境地图(EM)的效果。在这两种情况下，我们都想在黑色圆圈的表面上渲染环境的反射。左边是规则的环境映射，由蓝色圆圈表示(但它可以是任何表示，例如立方体映射)。它的效果是通过使用反射视图方向r 访问环境地图上的一个点来确定的。通过使用这个方向，蓝色圆圈EM被视为无穷大且遥远。对于黑圆上的任何一点，电磁似乎都是以这里为中心。在右边，我们想让EM代表周围的黑色房间是局部的，而不是无限远的。蓝色的圆圈EM是从房间的中心生成的。为了访问这个EM，就像它是一个房间一样，从位置p的反射光线沿着反射视图的方向被跟踪，并在着色器中与一个简单的代理对象相交，房间周围的红框。这个交点和电磁中心然后被用来形成方向r ‘，它被用来像往常一样通过一个方向访问电磁。通过找到r ‘，这个过程将电磁视为一个物理形状，即红色方框。由于代理形状与实际房间的几何形状不匹配，代理框假设将在下方的两个角落打破。</p>
<p><strong>这种技术在游戏中很受欢迎。它易于实现，运行时速度快，可以在前向和延迟呈现方案中使用。艺术家可以直接控制外观和内存的使用。如果某些区域需要更精确的照明，他们可以放置更多的反射探头，并更好地适合代理。如果使用太多内存来存储环境映射，则很容易删除探测。当使用光滑材质时，阴影点和代理形状的交点之间的距离可以用来决定使用哪个级别的预过滤环境贴图(下图)。这样做模拟了当我们离开阴影点时BRDF瓣的占地面积的增长。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016134607.png" class="" title="image-20211016134607">

<p>点a和点b的BRDFs是相同的，视图向量v和v ‘是相等的。因为从a点到反射代理点的距离d比从b点到反射代理点的距离d ‘短，所以反射代理点(用红色标记)一侧的BRDF瓣的足迹更小。当采样一个预先过滤的环境地图时，这个距离可以与反射点的粗糙度一起使用，以影响mip水平。</p>
<p><strong>当多个探测覆盖相同区域时，可以建立关于如何组合它们的直观规则。例如，探测可以有一个用户设置的优先级参数，使具有较高值的探测优先于较低值的探测，或者它们可以平滑地融合在一起。</strong></p>
<p><strong>不幸的是，这种方法的简单本质导致了各种各样的工件。反射代理很少与底层几何精确匹配。这使得反射在某些区域以不自然的方式伸展。这是一个问题，主要是高反射，抛光材料。此外，反射物体渲染到环境中他们的BRDFs评估从地图的位置。表面位置访问环境地图将不会有这些对象的完全相同的视图，所以纹理的存储结果不是完全正确的。</strong></p>
<p><strong>代理也会导致(有时是严重的)光线泄露。通常，查找将返回环境地图明亮区域的值，因为简化的光线投射错过了应该导致遮挡的局部几何体。这个问题有时可以通过使用定向遮挡方法来缓解(第11.4节)。另一个缓解这个问题的流行策略是使用预计算的漫射照明，这通常以更高的分辨率存储。环境地图中的值首先被渲染位置的平均漫反射光照所分割。这样做可以有效地从环境映射中去除平滑、扩散的影响，只留下更高频率的组件。当进行着色时，在被着色位置的反射乘以漫射光。这样做可以部分缓解反射探测缺乏空间精度的问题。</strong></p>
<p><strong>解决方案已经开发出来，使用更复杂的表示反射探头捕获的几何图形。szirmai - kalos等人为每个反射探头存储一个深度图，并在查找时对其执行射线跟踪。这可以产生更准确的结果，但要付出额外的代价。McGuire等人提出了一种更有效的方法来跟踪探针深度缓冲区中的射线。他们的系统存储多个探针。如果最初选择的探测没有包含足够的信息来可靠地确定命中位置，则选择回退探测，并使用新的深度数据继续跟踪。</strong></p>
<p><strong>当使用光滑的BRDF时，环境地图通常是预过滤的，每个mipmap存储与逐渐增大的核卷积的入射辐亮度。预过滤步骤假设这个内核是径向对称的(章节10.5)。然而，当使用视差校正时，BRDF瓣在反射代理形状上的足迹取决于阴影点的位置。这样做会使预过滤略有错误。Pesce和Iwanicki分析了这个问题的不同方面，并讨论了可能的解决方案。</strong></p>
<p><strong>反射代理不必是封闭的凸形状。也可以使用简单的平面矩形来代替或增加具有高质量细节的盒子或球体代理。</strong></p>
<h3 id="Dynamic-Update-of-Environment-Maps-环境地图的动态更新"><a href="#Dynamic-Update-of-Environment-Maps-环境地图的动态更新" class="headerlink" title="Dynamic Update of Environment Maps 环境地图的动态更新"></a>Dynamic Update of Environment Maps 环境地图的动态更新</h3><p><strong>使用局部反射探测需要渲染和过滤每个环境地图。这项工作通常是离线完成的，但在某些情况下，可能需要在运行时完成这项工作。在开放世界游戏中，每天的时间是变化的，或者当世界的几何图形是动态生成的，离线处理所有这些地图可能会花费太长时间，并影响生产力。在极端情况下，当需要许多变体时，甚至可能不可能将它们全部存储在磁盘上。</strong></p>
<p><strong>在实践中，有些游戏在运行时渲染反射探测。这种类型的系统需要谨慎地进行调优，以免显著影响性能。</strong></p>
<p><strong>除了一些琐碎的情况，我们不可能在每一帧中重新渲染所有可见的探头，因为现代游戏中的典型帧可能使用数十甚至数百个探头。幸运的是，这不是必需的。我们很少要求反射探头在任何时候都精确地描绘出它们周围的所有几何形状。大多数情况下，我们确实希望它们能够正确地对一天中的时间变化做出反应，但我们可以通过一些其他方法来近似反映动态几何，例如后面描述的屏幕空间方法(第11.6.5节)。这些假设允许我们在加载时渲染一些探测，而当它们进入视图时，逐步渲染其余的探测。</strong></p>
<p><strong>即使我们确实想要在反射探测中渲染动态几何体，我们几乎肯定能够以较低的帧率更新探测。我们可以定义需要花费多少帧时间来渲染反射探测，并在每一帧中更新固定数量的反射探测。基于每个探针到摄像机的距离、自上次更新以来的时间以及类似因素的启发式方法可以确定更新顺序。在时间预算特别小的情况下，我们甚至可以在多个帧上分割一个环境地图的渲染。例如，我们可以在每一帧渲染一个立方体映射的单个面。</strong></p>
<p><strong>离线卷积时通常使用高质量滤波。这种过滤涉及多次采样输入纹理，这在高帧率下是不可能承受的。Colbert和Kˇriv´anek开发了一种方法，使用重要抽样，在相对较低的样本计数(按64个顺序)下实现可比较的过滤质量。为了消除大多数噪声，他们从一个完整的mip链的立方体映射中取样，并使用启发式方法来确定每个样本应该读取哪个mip级别。他们的方法是环境地图快速、运行时预过滤的流行选择。Manson和Sloan利用基函数构造了所需的滤波核。构造特定核的精确系数必须在优化过程中得到，但对于给定的形状只会发生一次。卷积分两个阶段进行。首先，对环境地图进行下采样，同时用一个简单的核进行过滤。接下来，来自最终mip链的样本被组合起来构建最终的环境地图。</strong></p>
<p><strong>为了限制在照明通道中使用的带宽，以及内存的使用，压缩产生的纹理是有益的。Narkowicz描述了一种将高动态范围反射探头压缩为BC6H格式(章节6.2.6)的有效方法，该格式能够存储半精度浮点值。</strong></p>
<p><strong>渲染复杂的场景，即使一次渲染一个立方体映射面，对CPU来说可能太昂贵了。一种解决方案是为环境映射离线准备g缓冲区，只计算(更少的CPU要求)照明和卷积。如果需要，我们甚至可以在预生成的G缓冲区之上渲染动态几何。</strong></p>
<h3 id="Voxel-Based-Methods-基于体素锥体的方法-1"><a href="#Voxel-Based-Methods-基于体素锥体的方法-1" class="headerlink" title="Voxel-Based Methods 基于体素锥体的方法"></a>Voxel-Based Methods 基于体素锥体的方法</h3><p><strong>在大多数性能受限的场景中，本地化环境映射是一种出色的解决方案。然而，它们的质量往往不能令人满意。在实践中，必须使用变通方法来掩盖由探测器空间密度不足或代理过于粗糙的实际几何形状近似所造成的问题。当每帧有更多的可用时间时，可以使用更精细的方法。</strong></p>
<p><strong>体素锥跟踪——无论是在稀疏八叉树还是级联版本(章节11.5.7)——也可以用于高光分量。该方法对存储在稀疏体素八叉树中的场景表示进行锥跟踪。单个圆锥轨迹只提供一个值，代表从圆锥所面对的实心角度发出的平均辐亮度。对于漫射照明，我们需要追踪多个锥，因为只使用一个锥是不准确的。</strong></p>
<p><strong>对于光滑的材料使用锥形跟踪是非常有效的。在镜面照明的情况下，BRDF瓣很窄，只需要考虑来自小实心角度的亮度。我们不再需要追踪多个锥细胞;在很多情况下，一个就足够了。只有在粗糙材料上的镜面效应可能需要追踪多个锥，但因为这样的反射是模糊的，在这种情况下，通常回到局部反射探头就足够了，根本不追踪锥。</strong></p>
<p><strong>与之相反的是高度抛光的材料。它们的镜面反射几乎像镜子一样。这使得圆锥体很薄，就像一条单线。有了这样精确的轨迹，底层场景表示的体素本质可能会在反射中被注意到。它将显示由体素化过程产生的立方体，而不是多边形几何。这个工件在实践中很少有问题，因为反射几乎从来没有被直接看到过。它的贡献是由纹理修改的，这经常掩盖任何缺陷。当需要完美的镜面反射时，可以使用其他方法，以更低的运行成本提供它们。</strong></p>
<h3 id="Planar-Reflections-平面反射"><a href="#Planar-Reflections-平面反射" class="headerlink" title="Planar Reflections 平面反射"></a>Planar Reflections 平面反射</h3><p><strong>另一种选择是重用场景的常规表示，并重新渲染它以创建一个反射图像。如果反射表面的数量有限，并且它们是平面的，我们可以使用常规的GPU渲染管道来创建场景反射这些表面的图像。这些图像不仅可以提供精确的镜面反射，而且还可以通过对每个图像进行一些额外的处理来呈现似是而非的光泽效果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016135339.png" class="" title="image-20211016135339">

<p>在一个平面上的反射，显示入射角和反射角、反射几何形状和反射器。</p>
<p><strong>理想的反射镜遵循反射定律，即入射角等于反射角。也就是说，入射光和法线的夹角等于反射光和法线的夹角。参见上图。这个图也显示了被反射物体的“图像”。根据反射定律，物体的反射像就是物体本身，在物理上通过平面反射。也就是说，我们不是沿着反射光走，而是沿着入射光穿过反射器到达同一点，但是在被反射物体上。</strong></p>
<p><strong>这就引出了一个原理，即反射可以通过创建对象的副本，将其转换为反射位置，然后从那里进行渲染。为了实现正确的照明，光源也必须在平面上进行反射，包括位置和方向。一种等效的方法是将观察者的位置和方向通过镜子反射到反射器的另一侧。这种反射可以通过对投影矩阵的简单修改来实现。</strong></p>
<p><strong>在远端的物体(即在背面)不应被反射。这个问题可以用反射器的平面方程来解决。最简单的方法是在像素着色器中定义一个剪切平面。放置裁剪平面，使其与反射器平面重合。在渲染反射场景时使用这个剪切平面将会剪切掉所有与视点同侧的反射几何体，也就是所有原本在镜子后面的物体。</strong></p>
<h3 id="Screen-Space-Methods-屏幕空间方法-2"><a href="#Screen-Space-Methods-屏幕空间方法-2" class="headerlink" title="Screen-Space Methods 屏幕空间方法"></a>Screen-Space Methods 屏幕空间方法</h3><p><strong>就像环境遮挡和漫反射全局照明一样，一些镜面效果可以仅在屏幕空间中计算。这样做比在漫反射的情况下稍微更精确，因为镜面叶的清晰度。关于亮度的信息只需要从反射视图向量周围有限的固体角度，而不是从整个半球，所以屏幕数据更有可能包含它。这种类型的方法最早由Sousa等人提出，同时也被其他开发人员发现。这一整套方法被称为屏幕空间反射(SSR)。</strong></p>
<p><strong>给定被着色点的位置、视图向量和法线，我们可以沿着穿过法线反射的视图向量追踪光线，用深度缓冲区测试交点。这个测试是通过沿着射线迭代移动，将位置投影到屏幕空间，并从该位置检索z-缓冲区深度来完成的。如果射线上的点距离相机比深度缓冲区所代表的几何图形更远，这意味着射线在几何图形内部，命中被检测到。然后从颜色缓冲读取相应的值，以获得从跟踪方向入射的亮度值。这种方法假设射线击中的表面是朗伯方程的，但这个条件是许多方法的共同近似，在实践中很少成为约束。光线在世界空间中可以匀速追踪。这个方法相当粗糙，所以当检测到命中时，可以执行一个细化步骤。在有限的距离内，可以使用二值搜索来精确定位交点位置。</strong></p>
<p><strong>McGuire和Mara注意到，由于透视投影，在均匀的世界空间间隔中行走会造成采样点在屏幕空间中沿射线的不均匀分布。靠近相机的部分光线采样不足，因此可能会错过一些碰撞事件。那些距离较远的像素会被过度采样，因此相同深度的缓冲区像素会被多次读取，从而产生不必要的内存流量和冗余计算。他们建议用数字差分分析仪(DDA)代替在屏幕空间中执行射线移动，这种方法可以用于栅格化线条。</strong></p>
<p><strong>首先，要追踪的光线的起点和终点都投影到屏幕空间。沿着这条线的像素依次检查，以保证统一的精度。这种方法的一个结果是，交集测试不需要为每个像素完全重建视图空间深度。在典型透视投影的情况下，视图空间深度的倒数(即存储在z缓冲区中的值)在屏幕空间中线性变化。这意味着我们可以在实际跟踪之前计算它对屏幕空间x和y坐标的导数，然后使用简单的线性插值来得到屏幕空间段上任何位置的值。计算值可以直接与深度缓冲区的数据进行比较。</strong></p>
<p><strong>屏幕空间反射的基本形式只能追踪一条射线，只能提供镜面反射。然而，完美的镜面是相当罕见的。在现代的基于物理的渲染管道中，更经常需要光滑的反射，SSR也可以用来渲染这些。</strong></p>
<p><strong>简单的，特别的方法，反射仍然沿着反射方向用单线追踪。结果存储在屏幕外缓冲区中，在后续步骤中进行处理。应用了一系列的滤波内核，通常与下行采样的缓冲区相结合，以创建一组反射缓冲区，每个反射缓冲区都被模糊到不同的程度。当计算照明时，BRDF瓣的宽度决定了哪个反射缓冲器被采样。即使滤波器的形状经常被选择来匹配BRDF瓣的形状，这样做仍然只是一个粗略的近似，因为屏幕空间滤波是在不考虑不连续面的情况下进行的定位等因素对结果的精度至关重要。自定义启发式添加在最后，以使光滑的屏幕空间反射在视觉上匹配来自其他来源的高光贡献。尽管这是一个近似值，但结果是令人信服的。</strong></p>
<p><strong>Stachowiak以一种更有原则的方式处理这个问题。计算屏幕空间的反射是射线追踪的一种形式，就像射线追踪一样，它可以用来进行适当的蒙特卡罗积分。他使用BRDF的重要抽样，并随机发射射线，而不是仅仅使用反射视图方向。由于性能的限制，跟踪以一半的分辨率完成，每个像素(1到4)跟踪少量的射线。这是太少的光线产生一个无噪声的图像，所以交集的结果是共享的相邻像素。假设在一定范围内的像素的局部可见性是相同的。如果射线沿d0方向从点p0射出在第一点与场景相交i0，我们可以假设如果我们沿d1方向从点p1发射一条射线使它也经过i0，它也会击中i0 中的几何体在它之前不会有任何交叉。这让我们不用追踪光线，只需要适当地修改它对邻域积分的贡献。正式地说，从邻近像素射出的射线方向，相对于当前像素的BRDF的概率分布函数，将有不同的概率。</strong></p>
<p><strong>为了进一步增加有效的射线数，结果被暂时过滤。通过离线执行与场景无关的集成部分，并将其存储在由BRDF参数索引的查找表中，还可以减少最终积分的方差。在反射光线所需的所有信息都可以在屏幕空间获得的情况下，这些策略使我们能够获得精确的、无噪声的结果，接近路径跟踪地面真实图像(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016135948.png" class="" title="image-20211016135948">

<p>该图像中的所有镜面效果都是使用随机屏幕空间反射算法渲染的。注意微表面模型反射的垂直拉伸特性。(图片由Tomasz Stachowiak提供。场景建模和纹理由Joacim Lunde)</p>
<p><strong>在屏幕空间中追踪光线通常是昂贵的。它包括重复采样深度缓冲区(可能是多次)，并对查找结果执行一些操作。因为读取是相当不连贯的，缓存利用率可能很差，导致在着色器执行期间从等待内存事务完成很长时间的停顿。需要非常注意使实现尽可能快。屏幕空间反射通常以降低的分辨率计算，时间滤波用来弥补降低的质量。</strong></p>
<p><strong>Uludag描述了一种使用层次深度缓冲区(章节19.7.2)加速跟踪的优化。首先，创建一个层次结构。深度缓冲器是逐步向下采样的，每一步在每个方向上按因子2进行采样。较高层次的像素存储较低层次的四个对应像素之间的最小深度值。接下来，通过层次结构执行跟踪。如果在一个给定的步骤中，光线没有击中存储在单元格中的几何体，它将被推进到单元格的边界，在下一步中使用一个低分辨率的缓冲区。如果射线在当前单元格中遇到碰撞，它将被推进到碰撞位置，并在下一步使用更高分辨率的缓冲区。当最高分辨率缓冲区上的命中被注册时，跟踪终止(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016140135.png" class="" title="image-20211016140135">

<p>通过层次深度缓冲区追踪光线。如果光线在通过一个像素时没有击中几何体，下一步使用一个粗糙的分辨率。如果已注册命中，则后续步骤使用更细的分辨率。这个过程允许光线以大的步骤遍历空白区域，提供更高的性能。</p>
<p><strong>该方案特别适合长轨迹，因为它确保了不会错过任何特征，同时允许射线以大增量前进。它也能很好地访问缓存，因为深度缓冲区不是在随机的、遥远的位置读取的，而是在本地附近读取的。Grenier给出了许多实现该方法的实用技巧。</strong></p>
<p><strong>另一些则完全避免追踪光线。机器人利用反射代理重新定位交叉点，并从那里查看屏幕空间的亮度。Cichocki假设使用平面反射器，而不是追踪光线，而是反向进行整个过程，在整个屏幕上，每个像素都将其值写入应该被反射的位置。</strong></p>
<p><strong>与其他屏幕空间方法一样，反射也会受到可用数据有限造成的人为影响。这是很常见的反射光线离开屏幕区域之前登记一个击中，或击中几何体的背面，这是没有照明信息可用。这种情况需要优雅地处理，因为跟踪的有效性甚至对于相邻像素也是不同的。空间滤波器可以用来部分填充跟踪缓冲区中的空白。</strong></p>
<p><strong>SSR的另一个问题是缺乏关于深度缓冲区中物体厚度的信息。因为只存储一个值，所以当光线进入深度数据描述的表面后，没有办法判断光线是否击中了任何东西。Cupisz讨论了各种低成本的方法，以减轻由于不知道深度缓冲区中对象的厚度而产生的失真。Mara等人描述了深层G-buffer，它存储了多层数据，因此有更多关于地表和环境的信息。</strong></p>
<p><strong>屏幕空间反射是一个很好的工具，可以提供一组特定的效果，比如附近物体在平面上的局部反射。它们极大地提高了实时镜面照明的质量，但并没有提供一个完整的解决方案。本章中描述的不同方法通常是相互叠加的，以交付一个完整而健壮的系统。屏幕空间反射作为第一层。如果不能提供准确的结果，则使用局部反射探测作为备用方法。如果在给定区域中没有应用任何探测，则使用全局的默认探测。这种类型的设置提供了一种一致和健壮的方法来获得貌似可信的间接镜面贡献，这对于真实的外观尤其重要。</strong></p>
<h2 id="Unified-Approaches-统一的方法"><a href="#Unified-Approaches-统一的方法" class="headerlink" title="Unified Approaches 统一的方法"></a>Unified Approaches 统一的方法</h2><p><strong>目前提出的方法可以组合成一个连贯的系统，能够绘制美丽的图像。然而，它们缺乏路径跟踪的优雅性和概念上的简单性。渲染方程的每个方面都以不同的方式处理，每个方面都做出不同的妥协。尽管最终的图像看起来很真实，但在很多情况下，这些方法都失败了，错觉也破灭了。由于这些原因，实时路径跟踪一直是重要研究工作的重点。</strong></p>
<p><strong>用路径跟踪来渲染可接受的图像所需的计算量远远超过了即使是快速的CPU的能力，所以使用GPU代替。它们极快的速度和计算单元的灵活性使它们成为这项任务的最佳候选人。实时路径跟踪的应用包括建筑电影渲染的演练和预可视化。对于这些用例来说，较低且变化的帧率是可以接受的。当相机静止时，可以使用渐进细化(第13.2节)等技术来改善图像质量。高端系统可以使用多个GPU。</strong></p>
<p><strong>相比之下，游戏需要呈现最终质量的帧，并且他们需要在时间预算内始终如一地做到这一点。GPU可能还需要执行渲染本身以外的任务。例如，像粒子模拟这样的系统通常都是由GPU来释放一些CPU处理能力。所有这些元素结合在一起使得路径跟踪对于今天的渲染游戏来说是不切实际的。</strong></p>
<p><strong>在图形界有这样一种说法:“光线追踪是未来的技术，它永远都是!”这句妙语暗示了这个问题是如此复杂，即使在硬件速度和算法上都有了进步，也总会有更有效的方法来处理渲染管道的特定部分。支付额外的成本和仅使用光线投射，包括初级能见度，可能很难证明。因为gpu从来没有被设计来执行有效的射线追踪，所以目前有相当多的事实可以证明这一点。他们的主要目标一直是栅格化三角形，而且他们非常擅长这项任务。虽然光线追踪可以映射到GPU，但目前的解决方案没有任何来自固定功能硬件的直接支持。用运行在GPU计算单元上的有效软件解决方案总是很难击败硬件光栅化。</strong></p>
<p><strong>更合理、更不纯粹的方法是对光栅化框架中难以处理的效果使用路径跟踪方法。栅格化从相机可见的三角形，但不是依靠近似的反射代理，或不完整的屏幕空间信息，跟踪路径来计算反射。而不是尝试用特殊的模糊来模拟区域的光阴影，将光线追踪到光源并计算正确的遮挡。充分发挥GPU的优势，对无法在硬件中有效处理的元素使用更通用的解决方案。这样的系统仍然有点拼凑，并且缺少路径跟踪的简单性，但是实时渲染总是需要妥协。如果为了额外的几毫秒而不得不放弃一些优雅，这就是正确的选择——帧率是不可商量的。</strong></p>
<p><strong>虽然我们可能永远无法将实时渲染称为“已解决的问题”，但更多地使用路径跟踪将有助于把理论和实践更紧密地结合在一起。随着GPU的速度越来越快，在不久的将来，这种混合解决方案甚至应该适用于要求最高的应用程序。建立在这些原则基础上的系统的最初例子已经开始出现。</strong></p>
<p><strong>光线追踪系统依赖于加速方案，例如使用包围体层次(BVH)来加速可见性测试。有关此主题的更多信息，请参阅19.1.1节。一个简单的BVH实现不能很好地映射到GPU。正如在第3章中解释的，GPU本地执行一组线程，称为翘曲或波阵面。经纱是用锁步法处理的，每条线都执行相同的操作。如果某些线程不执行代码，它们暂时被禁用。出于这个原因，GPU代码应该以一种方式编写，使同一波阵面内的线程之间的发散流控制最小化。假设每个线程处理一个射线。这种方案通常会导致线程之间的巨大分歧。不同的射线将执行遍历代码的分叉分支，并在此过程中相交不同的边界体。有些射线会比其他射线更早地完成树的遍历。这种行为让我们偏离了理想状态，即所有的线程都在使用GPU的计算能力。为了消除这些效率低下的问题，已经开发了遍历方法，以最小化分歧并重用早期完成的线程。</strong></p>
<p><strong>为了生成高质量的图像，每个像素可能需要追踪数百或数千条射线。即使有最优的BVH、高效的树遍历算法和快速的GPU，在今天，除了最简单的场景外，这样做也不可能在实时中实现。我们在可用性能约束下生成的图像噪声非常大，不适合显示。然而，它们可以用去噪算法处理，以产生大部分无噪声的图像。参见下图，以及第1044页的图24.2。该领域最近取得了令人印象深刻的进展，已经开发出的算法可以从输入中创建高质量的、路径跟踪的参考图像，即使每像素只追踪一条路径。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016140512.png" class="" title="image-20211016140512">

<p>时空方差引导滤波可用于降噪每像素一个样本，路径跟踪图像(左)，以创建平滑的无伪图像(中)。其质量可与每像素2048个样本渲染的参考图像相媲美(右)。(图片由英伟达公司提供。)</p>
<p><strong>2014年PowerVR发布了他们的Wizard GPU。除了典型的功能，它还包含在硬件中构造和遍历加速结构的单元(章节23.11)。该系统证明了对固定功能单元进行定制以加速光线投射的能力和兴趣。</strong></p>
<h1 id="12-Image-Space-Effects-图像空间影响"><a href="#12-Image-Space-Effects-图像空间影响" class="headerlink" title="12 Image-Space Effects 图像空间影响"></a><strong>12 Image-Space Effects</strong> 图像空间影响</h1><p><strong>制作图像比简单地描绘物体要复杂得多。使图像看起来真实的一部分就是使它看起来像一张照片。就像摄影师调整他们的最终结果一样，我们也可能希望修改，比如说，色彩平衡。在渲染图像中添加胶片纹理、渐晕和其他细微的变化可以使渲染看起来更有说服力。另一方面，更戏剧化的效果，如镜头光晕和开花可以传达戏剧感。描绘景深和运动模糊可以增加现实主义和艺术效果。</strong></p>
<p><strong>利用GPU可以有效地对图像进行采样和处理。在本章中，我们首先讨论如何使用图像处理技术修改渲染后的图像。额外的数据，如深度和法线，可以用来增强这些操作，例如，允许平滑噪声区域，同时仍然保留尖锐的边缘。重投影方法可以用来节省阴影计算，或快速创建缺失的帧。最后，我们提出了各种基于样本的技术，以产生镜头光晕，bloom，景深，运动模糊和其他效果。</strong></p>
<h2 id="Image-Processing-图像处理"><a href="#Image-Processing-图像处理" class="headerlink" title="Image Processing 图像处理"></a>Image Processing 图像处理</h2><p><strong>图形加速器通常关注从几何和阴影描述创建人工场景。图像处理是不同的，我们用不同的方法对输入图像进行修改。可编程着色器和使用输出图像作为输入纹理的能力的结合，为使用GPU实现各种图像处理效果开辟了道路。这种效果可以与图像合成相结合。通常，生成一个图像，然后对其执行一个或多个图像处理操作。渲染后修改图像被称为后处理。在渲染单个帧时，可以执行大量的通道，访问图像、深度和其他缓冲区。例如，《战地4》拥有超过50种不同类型的渲染通道，尽管并非所有通道都在同一帧中使用。</strong></p>
<p><strong>使用GPU进行后处理有几个关键技术。场景以某种形式呈现到屏幕外缓冲区，如彩色图像、z-depth缓冲区或两者兼有。然后将生成的图像作为纹理处理。这个纹理应用于填充屏幕的四边形。后期处理是通过渲染这个四边形来完成的，因为像素着色程序将为每个像素调用。大多数图像处理效果依赖于在相应像素处检索图像texel的信息。根据系统限制和算法，这可以通过从GPU检索像素位置或通过向四边形分配范围为[0,1]的纹理坐标并根据进入的图像大小缩放来实现。</strong></p>
<p><strong>实际上，填充屏幕的三角形可能比四边形更有效。例如，在AMD GCN架构上，当使用单个三角形而不是由两个三角形组成的四边形时，图像处理速度提高了近10%，这是由于更好的缓存相干性。三角形被做得足够大，足以填满整个屏幕。参见下图。无论使用何种原始对象，其目的都是相同的:让像素着色器为屏幕上的每个像素进行评估。这种类型的渲染称为全屏传递。如果可以，您还可以使用计算着色器来执行图像处理操作。如上所述，这样做以后有几个好处。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017152939.png" class="" title="image-20211017152939">

<p>在左边，一个填充屏幕的四边形，显示了(u, v)纹理坐标。在右侧，一个三角形填满了屏幕，它的纹理坐标经过适当调整以提供相同的映射。</p>
<p><strong>使用传统的管线，舞台现在设置为像素着色器访问图像数据。检索所有相关的相邻样本，并对其进行操作。邻居的贡献由一个值加权，该值取决于其相对于被评估像素的位置。有些操作，如边缘检测，有一个固定大小的邻域(例如，3 × 3像素)，每个邻域和像素本身的原始值具有不同的权值(有时是负的)。每个texel的值乘以其相应的权重，并对结果进行求和，从而产生最终结果。</strong></p>
<p><strong>如第5.4.1节所述，可以使用各种滤波核来重构信号。以类似的方式，可以使用滤镜核来模糊图像。旋转不变滤波核是指分配给每个贡献texel的权重不依赖于径向角度的核。也就是说，在滤波操作中，这样的滤波核完全用一个texel到中心像素的距离来描述。在第135页的5.22号方程中，sinc过滤器是一个简单的例子。高斯滤波器，即众所周知的钟形曲线，是一种常用的核函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017153055.png" class="" title="image-20211017153055">

<p><strong>其中r为到texel中心的距离，σ为标准差;σ² 叫做方差。标准差越大，钟形曲线越宽。一个粗略的经验法则是使支持，过滤器大小，3σ像素宽或更大，作为一个开始。更广泛的支持提供更多的模糊，以更多的内存访问为代价。</strong></p>
<p><strong>e前面的这一项使连续曲线下的面积等于1。然而，当形成一个离散滤波器核时，这一项是无关的。每像素计算的值在面积上相加，然后所有值除以这个和，这样最终的权重总和为1。由于这种规范化过程，常数术语没有任何用途，因此经常不在过滤器内核描述中显示。如下图所示的高斯二维和一维滤波器就是这样形成的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017153308.png" class="" title="image-20211017153308">

<p>执行高斯模糊的一种方法是采样一个5 × 5的区域，加权每个贡献并相加。图的(a)部分显示了σ = 1的模糊核的权重。第二种方法是使用可分离过滤器。连续执行两个一维高斯模糊(b)和(c)，结果相同。第一次通过，如图(b)所示，对5行单独的行，使用该行中的5个样本水平模糊每个像素。第二步，(c)，对(b)的结果图像应用5个样本的垂直模糊过滤器，以得到最终结果。将(b)中的权重乘以(c)中的权重得到与(a)中相同的权重，这表明该滤波器是等价的，因此可以分离。与(a)中需要25个样本不同，(b)和(c)中的每个都有效地使用了每像素5个样本，总共10个样本。</p>
<p><strong>sinc滤波器和高斯滤波器的一个问题是函数会无限延伸。一个权宜之计是将这样的过滤器夹紧到一个特定的直径或方形区域，并简单地将任何超出这个范围的东西视为值为零。其他过滤核是为各种特性而设计的，例如易于控制、平滑性或评估的简单性。Bjorke和Mitchell等提供了一些常用的旋转不变滤波器等关于GPU上图像处理的信息。</strong></p>
<p><strong>任何全屏过滤操作都将尝试从显示边界之外取样像素。例如，如果您为屏幕上的左上角像素收集3×3样本，则您正在尝试检索不存在的像素。一个基本的解决方案是设置纹理采样器钳到边缘。当请求一个离屏的、不存在的texel时，将检索最近的边缘texel。这将导致图像边缘的过滤错误，但这些错误通常是不明显的。另一种解决方案是生成过滤后的图像，其分辨率略高于显示区域，这样这些离屏像素就会存在。</strong></p>
<p><strong>使用GPU的一个优势是内置的插值和mipmapping硬件可以帮助最小化象素访问的数量。例如，我们的目标是使用框式过滤器。，取九个像素的平均值，在给定像素周围形成一个3 × 3的网格，并显示这个模糊的结果。这9个纹理样本将被像素着色器加权并相加，然后将模糊结果输出到像素。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017153629.png" class="" title="image-20211017153629">

<p>在左边，通过执行9个纹理样本并将其平均在一起，应用了一个方框过滤器。在中间，使用了5个样本的对称模式，外部的每个样本代表两个像素，因此每个样本的权重是中心样本的两倍。这种类型的模式可以用于其他过滤器内核，通过在它们的两个像素之间移动外部样本，每个像素的相对贡献可以改变。在右边，使用了更有效的四样本模式。左上方的样本在四个像素值之间进行插值。那些在右上方和左下方的每个插值两个像素的值。每个样本都被赋予与它所代表的像素数成比例的权重。</p>
<p><strong>然而，9个显式示例操作是不必要的。通过使用纹理的双线性插值，一次纹理访问可以检索最多四个相邻像素的加权和。使用这个想法，3 × 3网格可以通过4次纹理访问进行采样。参见上图。对于一个盒子过滤器，在重量相等的情况下，一个样本可以放置在四个像素的中间，得到四个像素的平均值。对于高斯滤波器，权值的不同使得四个样本之间的双线性插值可能是不准确的，每个样本仍然可以被放置在两个像素之间，但偏移更接近其中一个。例如，假设一个像素的重量是0.01，而它的相邻像素的重量是0.04。可以将样本放置到与第一个像素点的距离为0.8，与相邻像素点的距离为0.2，这样每个像素点就有了合适的比例。这个单一样本的重量将是两个像素的重量的总和，0.05。或者，高斯可以通过使用双线性插值样本为每四个像素，找到偏移，给出最接近理想权重的近似。</strong></p>
<p><strong>有些过滤核是可分离的。两个例子是高斯滤波器和箱形滤波器。这意味着它们可以应用于两个单独的一维模糊。这样做的结果是相当少的texel访问需要整体。成本从d² 到2d，其中d是内核直径或支持度。例如，假设盒子过滤器将应用于图像中每个像素的5 × 5区域。首先，图像可以水平过滤:左边和右边相邻的两个texel，每个像素右侧的两个像素以及像素值本身的权重相等乘以0.2，相加。然后生成的图像被垂直模糊，上面和下面的两个相邻像素与中心像素平均。例如，玩家可以通过两次访问总共10个像素，而不是一次访问25个像素。参见上上图。更宽的过滤器内核受益更多。</strong></p>
<p><strong>圆磁盘滤波器对散景效果很有用(第12.4节)，由于在实数范围内不可分离，所以通常计算起来很昂贵。然而，使用复数打开了一个广泛的函数家族。Wronski讨论了这种可分离滤波器的实现细节。</strong></p>
<p><strong>计算着色器很适合滤波，与像素着色器相比，核越大，性能越好。例如，线程组内存可以用来共享不同像素的滤波计算之间的图像访问，从而降低带宽。任何半径的盒过滤器都可以通过使用计算着色器的分散写入来实现。对于水平和垂直通道，计算行或列中第一个像素的核值。每个连续像素的结果是通过在核的前沿加入下一个样本，并减去在远端留下的样本来确定的。这种“移动平均”技术可以用来在常数时间内近似任意大小的高斯模糊。</strong></p>
<p><strong>向下采样是另一个GPU相关的技术，通常用于模糊。其想法是将要操作的图像缩小，例如，沿两个轴将分辨率减半，以制作四分之一屏幕图像。根据输入数据和算法的要求，原始图像可能会在尺寸上被过滤或简单地以较低的分辨率创建。当这个图像被访问到最终的，全分辨率的图像，纹理的放大将使用双线性插值来混合样本。这将产生进一步的模糊效果。在原始图像的小版本上执行操作，可以显著减少访问的texels总数。此外，任何应用于这幅较小图像的过滤器都有增加过滤器核的相对大小的净效果。例如，应用一个宽度为5的内核。对于较小的图像，在效果上类似于对原始图像应用宽度为9的核函数。质量将会降低，但对于许多眩光效果和其他现象的常见情况下的大面积相似颜色的模糊，大多数伪影将是最小的。减少每像素的比特数是降低内存访问成本的另一种方法。下行采样可以用于其他缓慢变化的现象，例如，许多粒子系统可以以半分辨率渲染。这种下采样的想法可以扩展到创建图像的mipmap，并从多层采样，以提高模糊过程的速度。</strong></p>
<h3 id="Bilateral-Filtering-双边滤波"><a href="#Bilateral-Filtering-双边滤波" class="headerlink" title="Bilateral Filtering 双边滤波"></a>Bilateral Filtering 双边滤波</h3><p><strong>使用某种形式的双边滤波器可以改进上采样结果和其他图像处理操作。这个想法是要抛弃或降低影响与中心样品表面无关的样品。这个过滤器是用来保留边缘的。想象一下，你把相机聚焦在远处蓝色物体前面的红色物体上，背景是灰色的。蓝色的物体应该是模糊的，红色的物体应该是锐利的。一个简单的双边过滤器将检查像素的颜色。如果是红色，就不会出现模糊——物体仍然是锐利的。否则，像素会被模糊。所有非红色的样本将被用来模糊像素。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017154803.png" class="" title="image-20211017154803">

<p>双边滤波器。左上方是原始图像。在左下角，我们模糊并使用那些非红色像素的样本。在右侧显示了一个像素的滤波核。红色像素在计算高斯模糊时被忽略。其余像素的颜色乘以相应的滤波器权重并相加，这些权重的总和也被计算出来。在这种情况下，权重之和为0.8755，因此计算出的颜色除以这个值。</p>
<p><strong>对于本例，我们可以通过检查像素的颜色来决定忽略哪些像素。联合或交叉双边滤波器使用额外的信息，如深度、法线、识别值、速度或其他数据，以确定是否使用邻近的样本。例如，Ownby等人展示了当仅使用少量样本进行阴影映射时，模式是如何产生的。模糊这些结果看起来好得多。然而，一个物体上的阴影不应该影响另一个不相关的模型，模糊会使阴影在物体的边缘外流血。他们使用双边滤波器，通过比较给定像素与其相邻像素的深度来丢弃不同表面上的样本。以这种方式减少一个区域的变异性被称为去噪，通常用于屏幕空间环境遮挡算法(章节11.3.6)。</strong></p>
<p><strong>仅使用与相机的距离来寻找边缘往往是不够的。例如，穿过两个立方体面之间形成的边缘的软阴影可能落在上面只有一张脸，另一张脸背光。当模糊时，仅仅使用深度可能会导致阴影从一张脸流到另一张脸，因为这个边缘不会被检测到。我们可以通过只使用那些深度和表面法线与中心样本相似的邻居来解决这个问题。这样做会限制样本跨越共享边缘，因此这种双边滤波器也被称为边缘保持滤波器。决定是否以及在多大程度上削弱或忽略邻近样本的影响取决于开发人员，并取决于诸如模型、渲染算法和查看条件等因素。</strong></p>
<p><strong>除了花费额外的时间检查邻居和加权，双边过滤还有其他性能代价。滤波优化方法如双通道可分滤波和双线性插值加权采样更难使用。我们事先不知道哪些样本应该被忽略或削弱影响，所以我们不能使用GPU在一次“点击”中收集多个图像像素的技术。也就是说，可分离双通滤波器的速度优势导致了近似方法的产生。</strong></p>
<p><strong>Paris等人讨论了双边滤波器的许多其他应用。双边滤波器应用于边缘必须保留但样本可以重复使用以减少噪声的地方。它们也被用来从几何体渲染的频率中分离阴影频率。例如，Yang等人以较低的分辨率进行阴影处理，然后使用法线和深度，在上采样期间进行双边滤波，形成最终帧。另一种方法是最接近深度滤波，即检索低分辨率图像中的4个样本，使用深度最接近高分辨率图像深度的样本。Hennessy和Pesce对这些方法和其他上采样方法进行了对比和比较。低分辨率渲染的一个问题是细节可能会丢失。Herzog等人通过利用时间相干和再投影进一步提高了质量。注意，双边滤波器是不可分离的，因为每个像素的样本数量可以变化。Green指出，将其视为可分离的伪影可以被其他着色效果隐藏。</strong></p>
<p><strong>实现后处理光线的一种常见方法是使用乒乓缓冲区。这只是在两个屏幕外缓冲区之间应用操作的想法，每个缓冲区用于保存中间或最终结果。对于第一次传递，第一个缓冲区是输入纹理，第二个缓冲区是输出发送的地方。在接下来的传递中，角色颠倒了，第二个作为输入纹理，第一个用于输出。在第二次传递中，第一个缓冲区的原始内容被覆盖——它是临时的，被用作处理传递的临时存储。管理和重用瞬态资源是设计现代渲染系统的关键因素。从架构的角度来看，让每个单独的通道执行特定的效果是很方便的。然而，为了提高效率，最好是将尽可能多的效果结合在一起。</strong></p>
<p><strong>在前几章中，访问相邻像素着色器用于形态反锯齿、软阴影、屏幕空间环境遮挡和其他技术。后期处理的效果一般是运行在最终的图像上，并且可以模仿热成像，再现膜粒和色差，进行边缘检测，产生热微光和波纹，分割图像，帮助渲染云，并执行大量其他操作。第15.2.3节介绍了一些用于非真实感渲染的图像处理技术。参见下图中的几个示例。它们都使用一个彩色图像作为唯一的输入。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017155210.png" class="" title="image-20211017155210">

<p>使用像素着色器的图像处理。对左上方的原始图像进行了各种处理。右上部分为高斯差分运算，左下部分为边缘检测，右下部分为边缘检测与原始图像混合后的合成图像。(图片由NVIDIA公司提供。)</p>
<p><strong>在本章结束时，我们将使用各种广告牌和图像处理技术实现一些效果，而不是继续穷尽(和耗尽)所有可能的算法。</strong></p>
<h2 id="Reprojection-Techniques-重投影技术"><a href="#Reprojection-Techniques-重投影技术" class="headerlink" title="Reprojection Techniques 重投影技术"></a>Reprojection Techniques 重投影技术</h2><p><strong>重投影是基于重用前一帧中计算的样本的思想。顾名思义，这些示例从一个新的查看位置和方向尽可能地重用。重投影方法的一个目标是摊销几帧的渲染成本，即利用时间一致性。因此，这也与5.4.2节中涉及的时间抗锯齿有关。另一个目标是，如果应用程序未能及时完成当前帧的渲染，则形成一个近似结果。这种方法在虚拟现实应用中尤其重要，以避免模拟出错(第21.4.1节)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017155347.png" class="" title="image-20211017155347">

<p>t−1时刻的绿色三角形和蓝色三角形以及t时刻之后的坐标系，三维点pi^t在两个像素中心的绿色三角形上，连同像素面积反向投影到点pi ^(t−1)上。可以看出，如果没有着色结果可以重用，当p0 ^t是可见的，p0 ^(t−1)是闭塞的。然而,p1 在t−1和t处都可见，那么着色可能会被重用。(Nehab等人的插图。)</p>
<p><strong>重投影方法分为反向重投影和正向重投影。反投影的基本思想如上图所示。呈现一个三角形在时间t时,顶点位置的计算当前帧(t)和前(t−1)。使用顶点着色,z和w的像素着色器可以计算一个插入值z / w,t和t−1,如果他们足够近,双线性查找在pi^(t−1)可以在前面的颜色缓冲中完成，并且可以使用那个着色值来代替计算一个新的着色值。对于之前被遮挡的区域，然后变得可见(例如，上图中的深绿色区域)，没有着色像素可用。这被称为缓存丢失。在这样的事件中，我们计算新的像素着色来填补这些洞。由于重用阴影值假设它们独立于任何类型的运动(物体，摄像机，光源)，明智的做法是不要在太多的帧中重复使用着色值。Ne- hab等人建议自动刷新应该总是发生在几帧重复使用之后。一种方法是将屏幕分成n组，每组都是2 × 2像素区域的伪随机选择。每一帧，一个组被更新，避免重用像素值太长时间。反向重投影的另一种变体是存储一个速度缓冲区并在屏幕空间中执行所有测试，这避免了顶点的双重转换。</strong></p>
<p><strong>为了更好的质量，还可以使用运行平均滤波器，它会逐渐淘汰旧值。这些特别推荐用于空间抗锯齿、软阴影和全局照明。过滤器描述为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017161745.png" class="" title="image-20211017161745">

<p><strong>其中c (p^t)为 p^t处新着色像素值，c (p^(t−1)是前一帧的反投影颜色，cf (p^t)是应用滤镜后的最终颜色。Nehab等人在一些用例中使用α = 3/5，但建议根据渲染内容尝试不同的值。</strong></p>
<p><strong>正向重投影从帧t−1的像素开始工作，并将它们投影到帧t中，因此不需要双顶点着色。这意味着像素从t-1分散到t帧,而反向重投影方法收集来自t−1帧像素值t。这些方法还需要处理成为可见的闭塞的地区,这是通常使用不同的启发式hole-filling方法完成,即缺失区域的值是从周围像素推断出来的。Yu等人使用正向重投影以廉价的方式计算景深效应。Didyk等人利用基于运动向量的自适应生成框架t−1上的网格，避免了传统的孔洞填充。这个网格通过深度测试进行渲染，并投影到帧t中，这意味着遮挡和折叠是通过深度测试对自适应网格三角形进行栅格化处理的一部分。Didyk等人使用他们的方法从左眼重新投射到右眼，以便为虚拟现实生成一对立体图像，在虚拟现实中，两幅图像之间的相干性通常很高。后来，Didyk等人提出了一种感知动机的方法来执行时间上采样，例如，将帧率从40 Hz增加到120 Hz。</strong></p>
<p><strong>Yang和Bowles提出了将两个在t和t+1处的帧投影到两个帧之间的t+δt处的帧的方法，δt∈[0,1]。这些方法有更大的机会更好地处理遮挡情况，因为它们使用两个帧而不是一个。在游戏中使用这种方法可以将帧率从30帧提高到60帧，这是可能的，因为它们的方法运行时间不到1毫秒。我们推荐他们的课程笔记和Scherzer等人对时间相干方法的广泛调查。Valient在《Killzone: Shadow Fall》中也使用了重投影来加速渲染。请参阅5.4.2节末尾的大量参考资料，了解使用重投影进行时间抗锯齿的实现细节。</strong></p>
<h2 id="Lens-Flare-and-Bloom-镜头光晕和泛光"><a href="#Lens-Flare-and-Bloom-镜头光晕和泛光" class="headerlink" title="Lens Flare and Bloom 镜头光晕和泛光"></a>Lens Flare and Bloom 镜头光晕和泛光</h2><p><strong>镜头光晕是光线通过镜头或眼睛通过间接反射或其他非预期路径传播而引起的现象。光晕可以根据几种现象分类，最显著的是晕轮（halo）和纤毛冕（ciliary corona）。光晕是由透镜物质结构的径向纤维引起的。它看起来像光周围的一个环，外部边缘是红色的，内部是紫色的。不论光源的距离如何，光晕的视大小是恒定的。睫状日冕来自透镜的密度波动，表现为从一点辐射出来的射线，这一点可以延伸到光晕之外。</strong></p>
<p><strong>当镜头的一部分在内部反射或折射光线时，镜头也会产生二次效应。例如，由于相机的光圈叶片，可以出现多边形图案。由于玻璃上的小凹槽，也可以看到光条纹涂抹在挡风玻璃上。水华是由晶状体和眼睛其他部位的散射造成的，在光线周围产生辉光，并使场景其他部位的对比度变暗。摄像机通过利用电荷耦合器件(CCD)将光子转换成电荷来捕捉图像。当CCD中的电荷饱和并溢出到邻近的位置时，摄像机就会发生泛光。光晕、日冕和泛光作为一个类别被称为眩光效应。</strong></p>
<p><strong>事实上，随着相机技术的进步，大多数这样的人工制品越来越少被看到。更好的设计、镜头罩和抗反射涂层可以减少或消除这些杂散的鬼影现象。然而，这些效果现在通常是通过数字技术添加到真实照片中。由于计算机显示器产生的光强度是有限的，我们可以通过在图像中添加这样的效果来给场景或物体增加亮度的印象。由于泛光效果和镜头光晕的普遍使用，它们在照片、电影和交互式计算机图形中几乎是陈词滥调。然而，如果运用得当，这些效果可以给观众强烈的视觉暗示。</strong></p>
<p><strong>为了提供令人信服的效果，镜头光晕应该随光源的位置而变化。King创建了一组不同纹理的正方形来代表镜头光晕。然后将它们从屏幕上的光源位置通过屏幕中心指向一条直线。当光线远离屏幕中心时，这些正方形会变小，变得更透明;当光线向内移动时，这些正方形会变大，变得更不透明。Maughan通过使用GPU计算屏幕区域光源的遮挡来改变镜头光斑的亮度。他生成一个单像素强度纹理，然后用来减弱效果的亮度。Sekulic将光源渲染为单个多边形，使用遮挡查询硬件给出可见区域的像素计数(章节19.7.1)。为了避免GPU在等待查询返回一个值到CPU时陷入停滞，结果将在下一帧中用于确定衰减量。由于强度很可能以一种相当连续和可预测的方式变化，单个帧的延迟几乎不会引起知觉混乱。Gjøl和Svendsen首先生成一个深度缓冲器(他们也用于其他效果)，并以螺旋方式采样32次在镜头光晕将出现的区域的图案，使用结果来衰减光晕纹理。可见性采样是在渲染光晕几何图形时在顶点着色器中完成的，因此避免了硬件遮挡查询造成的延迟。</strong></p>
<p><strong>在一个场景中，明亮的物体或灯光的条纹可以通过类似的方式来执行，要么绘制半透明的广告牌，要么对明亮的像素本身执行后处理过滤。像《侠盗猎车手V》这样的游戏使用了一组纹理用于广告牌上的这些和其他效果。</strong></p>
<p><strong>Oat讨论了使用可操纵滤波器来产生条纹效应。这种类型的过滤器被指定一个方向，而不是在一个区域上对称地过滤。沿着这个方向的Texel值相加，产生条纹效果。使用一个向下采样到宽度和高度的四分之一的图像，并使用ping-pong缓冲区进行两次传递，给出一个令人信服的条纹效果。下图显示了这种技术的一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018142602.png" class="" title="image-20211018142602">

<p>镜头光晕，恒星眩光和泛光效果，以及景深和运动模糊。注意一些移动球的频闪伪影，因为积累了单独的图像。(图片来自川濑正树(Masaki Kawase)的《Rthdribl》。)</p>
<p><strong>许多其他的变化和技术存在，远远超出了广告牌。Mit- tring使用图像处理来分离明亮的部分，对它们进行取样，并在几个纹理中模糊它们。然后通过复制、缩放、镜像和着色，将它们重新合成到最终的图像上。使用这种方法，艺术家不可能独立地控制每个耀斑源的外观:对每个耀斑应用相同的过程。然而，图像的任何明亮部分都可能产生镜头耀斑，比如镜面反射或表面发射部分，或明亮的火花粒子。Wronski描述了变形镜头闪光，这是20世纪50年代使用的电影摄影设备的副产品。Hullin等人提供了各种重影伪影的物理模型，追踪光束束来计算效果。它给出了可信的结果，是基于镜头系统的设计，以及精度和性能之间的权衡。Lee和Eisemann在这项工作的基础上建立了一个线性模型，避免了昂贵的预处理。Hennessy给出了实施细节。下图显示了生产中使用的典型镜头光晕系统。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018142824.png" class="" title="image-20211018142824">

<p>在《巫师3》中产生太阳耀斑的过程。首先，将高对比度校正曲线应用于输入图像，以隔离未遮挡的太阳部分。接下来，以太阳为中心的径向模糊，应用到图像上。如左图所示，模糊是在一个系列中执行的，每一个操作都对前一个操作的输出进行操作。这样做可以创建一个平滑的、高质量的模糊，同时在每个通道中使用有限数量的样本来提高效率。所有模糊都以半分辨率执行，以减少运行时成本。最终的耀斑图像与原始场景渲染相结合。(CD PROJEKT R, The Witcher R是CD PROJEKT Capital Group的注册商标。The Witcher game c CD PROJEKT S.A.版权所有《巫师》游戏是根据Andrzej Sapkowski的散文改编的。所有其他版权和商标均为其各自所有者的财产。)</p>
<p><strong>bloom效果，即一个非常明亮的区域溢出到相邻的像素上，是通过结合几种已经提出的技术来实现的。主要思想是创建一个只包含要“过度曝光”的明亮物体的bloom图像，模糊它，然后合成它到正常的图像。使用的模糊通常是高斯，尽管最近与参考镜头的匹配显示其分布有更多的尖峰形状。制作这幅图像的常用方法是采用亮通滤波器:保留所有亮像素，将所有暗像素变为黑色，通常在过渡点进行一些混合或缩放。对于只有几个小对象的bloom，可以计算一个屏幕边界框来限制后期处理模糊和合成通道的范围。</strong></p>
<p><strong>这张bloom图像可以在低分辨率下进行渲染，例如，宽度和高度是原始图像的1 / 2到1 / 8。这样做可以节省时间，并有助于提高过滤效果。这张分辨率较低的图像被模糊，并与原始图像结合在一起。这种降低分辨率的方法用于许多后处理效果，如压缩或降低颜色分辨率的技术。bloom图像可以向下采样几次，并从生成的图像集中重新采样，在最小化采样成本的同时提供更宽的模糊效果。例如，一个明亮的像素在屏幕上移动可能会导致闪烁，因为它可能在某些帧中没有被采样。</strong></p>
<p><strong>因为目标是使图像在明亮的地方看起来过度曝光，所以这张图像的颜色被按所需的比例缩放，并添加到原始图像中。添加剂混合使颜色饱和，然后变成白色，这通常正是所需要的。下图显示了一个示例。Alpha混合可以用于更艺术的控制。可以对高动态范围图像进行过滤，而不是阈值处理，获得更好的结果。低和高动态范围花华可以分别计算和合成，以更令人信服的方式捕捉不同现象。其他的变体也是可能的，例如，前一帧的结果也可以添加到当前帧，给动画对象一个条纹辉光。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143114.png" class="" title="image-20211018143114">

<p>高动态范围色调映射和开花。下面的图像是通过在原始图像上使用色调映射，并添加一个后期处理bloom来生成的。(图片来自育碧的《孤岛惊魂》)</p>
<h2 id="Depth-of-Field-景深"><a href="#Depth-of-Field-景深" class="headerlink" title="Depth of Field 景深"></a>Depth of Field 景深</h2><p><strong>对于一个给定设置的相机镜头，有一个焦点范围，它的景深。超出这个范围的物体是模糊的——越远越模糊。在摄影中，这种模糊与光圈大小和焦距有关。减小孔径可以增加景深。聚焦深度范围更广，但会减少形成图像的光量(第9.2节)。在白天室外拍摄的照片通常有很大的景深，因为光线充足，可以使用小光圈，最好是针孔相机。在光线不好的房间里，景深会大大缩小。因此，控制景深效果的一种方法是将其与色调映射联系起来，使失焦的物体随着光阶的降低而变得更加模糊。另一种是允许手工艺术控制，改变焦点和增加景深，以获得所需的戏剧性效果。参见下图中的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143256.png" class="" title="image-20211018143256">

<p>景深取决于相机的焦距。(图片由Morgan McGuire提供，G3D渲染。)</p>
<p><strong>累积缓冲器可以用来模拟景深。参见下图。通过改变镜头上的视角位置并保持焦点固定，物体将相对于他们离这个焦点的距离变得模糊。然而，与其他累积效果一样，这种方法的成本很高，每张图像需要多次渲染。也就是说，它确实收敛于正确的地面真理图像，这对测试很有用。光线追踪也可以收敛到物理上正确的结果，通过改变眼睛光线在光圈上的位置。为了提高效率，许多方法可以对没有焦点的对象使用较低级别的细节。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143345.png" class="" title="image-20211018143345">

<p>通过积累的景深。观察者的位置被移动了一小部分，保持视角指向焦点。每个渲染的图像被加到一起，并显示所有图像的平均值。</p>
<p><strong>虽然对于交互式应用程序来说是不切实际的，但是移动镜头上的视图位置的累积技术提供了一种合理的方式来考虑在每个像素上应该记录什么。表面可以分为三个区域:靠近焦点距离的区域(焦点场或中间场)，那些在(远场)和那些更近的区域(近场)。对于焦距处的表面，每个像素都显示一个锐焦点区域，因为所有累积的图像的结果大致相同。聚焦场是一个深度范围，在这个范围内，物体只有轻微的焦距，例如，小于半像素。这个范围就是摄影师所说的景深。在交互式计算机图形中，我们默认使用具有完美焦距的针孔相机，因此景深是指模糊近场和远场内容的效果。平均图像中的每个像素都是在不同视图中看到的所有表面位置的混合，从而模糊了失焦区域，这些位置可能有很大的差异。</strong></p>
<p><strong>一个有限的解决方案是创建独立的图像层。仅渲染聚焦对象的图像，一个物体在远处，一个物体在近处。这可以通过改变近/远剪切平面的位置来实现。不久的然后对远场图像进行模糊处理，然后将三幅图像按前后顺序合成在一起。这种2.5维的方法，之所以称为2.5维方法，是因为二维图像被赋予了深度并进行了组合，在某些情况下提供了合理的结果。当目标跨越多个图像，突然从模糊变为聚焦时，这种方法就失效了。此外，所有经过过滤的物体都具有统一的模糊度，不会因为距离而产生任何变化。</strong></p>
<p><strong>观察这个过程的另一种方法是考虑景深如何影响表面上的单个位置。想象表面上的一个小点。当表面聚焦时，圆点通过单个像素可见。如果表面是失焦的，点将出现在附近的像素，这取决于不同的观点。在限制下，点将在像素网格上定义一个填充圆。这被称为混乱圈。</strong></p>
<p><strong>在摄影中，焦点场以外区域的审美质量被称为“散景”，这个词来自日语，意思是“模糊”。(这个词的发音是“bow-ke”，“bow”在“bow and arrow”中，“ke”在“kettle”中)通过光圈的光线通常是均匀分布的，而不是某种高斯分布。混淆区形状与孔径叶片的数量、形状以及尺寸有关。廉价的相机产生的模糊是五角形而不是完美的圆形。目前，大多数新相机都有7个叶片，高端机型有9个或更多。更好的相机有圆形的叶片，使得散景是圆形的。对于夜间拍摄，光圈尺寸更大，可以有一个更圆的图案。类似于镜头光晕和光华被放大的效果，我们有时渲染一个六角形的圆圈，以暗示我们是用物理相机拍摄。正如Barr´e-Brisebois所解释的那样，六边形是一种特别容易在可分离的双通道后处理模糊中产生的形状，因此被用于许多游戏中。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143538.png" class="" title="image-20211018143538">

<p>分散操作获取像素值并将其传播到邻近区域，例如通过渲染一个圆形精灵。在集合中，邻近的值被采样并用于影响一个像素。GPU的像素着色器经过优化，可以通过纹理采样执行收集操作。</p>
<p><strong>计算景深效果的一种方法是取每个像素在一个表面上的位置，并将其阴影值分散到这个圆或多边形内的邻居。如上图左侧所示。散射的概念不能很好地映射到像素着色器的能力。像素着色器可以有效地并行操作，因为它们不会将结果传播给邻居。一个解决方案是为每个近场和远场像素渲染精灵(章节13.5)。每个精灵都被渲染到一个独立的场层中，精灵的大小由混乱圈的半径决定。每一层存储所有重叠精灵的平均混合和，然后将各层合成到下一层。这种方法有时被称为正演映射技术。即使使用图像下采样，这种方法也会很慢，更糟糕的是，需要的时间也会变，特别是当焦点是浅的时候。性能的可变性意味着很难管理框架预算，例如，分配给执行所有呈现操作的时间量。不可预测性会导致帧数缺失和用户体验不均衡。</strong></p>
<p><strong>另一种思考混乱圈的方法是假设一个像素周围的局部邻域有相同的深度。有了这个想法，收集操作就可以完成了。如上图的右侧所示。像素着色器被优化以收集以前渲染通道的结果。因此，执行景深效果的一种方法是根据深度模糊每个像素的表面。深度定义了一个混乱圈，这是一个区域应该采样的宽度。这种集合方法称为向后映射或反向映射方法。</strong></p>
<p><strong>大多数实用的算法都是从一个角度的初始图像开始。这意味着，从一开始，就缺少一些信息。场景的其他视图将看到在这个单一视图中不可见的部分表面。正如Pesce所指出的，我们应该尽可能地利用现有的可见样本。</strong></p>
<p><strong>收集技术经过多年的发展，每个都改进了以前的工作。我们提出了Bukowski等人的方法及其所遇到问题的解决方案。他们的方案根据深度为每个像素生成一个有符号的值，表示混沌半径的圆。这个半径可以从相机设置和特性中得到，但美工通常喜欢控制效果，所以近场、焦距和远场的范围可以任意指定。半径符号指定像素是在近场还是远场，−0.5 &lt; r &lt; 0.5是在焦点场，其中半像素模糊被认为在焦点。</strong></p>
<p><strong>这个缓冲区包含混乱圆半径，然后用来将图像分割为两个图像，近场和其余的，每个图像都向下采样，并在两个通过与可分离的过滤器模糊。这种分离是为了解决一个关键问题，即近场中的物体边缘应该是模糊的。如果我们根据其半径模糊每个像素，并输出到单个图像，前景对象可能是模糊的，但有尖锐的边缘。例如，当通过剪影边缘从前景对象到焦点对象时，样本半径将降为零，因为焦点对象不需要模糊。这将导致前景对象对周围像素的影响有一个突然下降，导致尖锐的边缘。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143711.png" class="" title="image-20211018143711">

<p>近场模糊。左边是没有景深效应的原始图像。在中间，近场的像素被模糊，但在靠近焦点场的地方有一个锐利的边缘。右边显示了使用一个单独的近场图像合成在更远处的内容上的效果。(使用G3D生成的图像。)</p>
<p><strong>我们想要的是让近场中的物体平滑模糊，并产生超出它们边界的效果。这是通过在单独的图像中写入和模糊近场像素来实现的。此外，该近场图像的每个像素被赋予一个alpha值，表示其混合因子，这也是模糊的。在创建两个独立的图像时使用联合双边滤波和其他测试;详情请参阅文章和代码。这些测试有几个功能，例如，对于远场模糊，丢弃远比采样像素远得多的邻近物体。</strong></p>
<p><strong>在进行了基于模糊半径圆的分离和模糊后，进行合成。混沌圆半径被用来在原始聚焦图像和远场图像之间进行线性插值。这个半径越大，使用的远场结果就越模糊。alpha覆盖值在近场图像然后被用来混合近图像在这个插值结果。通过这种方式，近场模糊的内容适当地扩展到后面的场景之上。参见图12.10和下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143823.png" class="" title="image-20211018143823">

<p>《巫师3》中的景深。近场和远场模糊令人信服地与焦点场混合。(CD PROJEKT R, The Witcher R是CD PROJEKT Capital Group的注册商标。The Witcher game c CD PROJEKT S.A.版权所有《巫师》游戏是根据Andrzej Sapkowski的散文改编的。所有其他版权和商标均为其各自所有者的财产。)</p>
<p><strong>该算法进行了几次简化和调整，使其看起来合理。粒子可以用其他方法处理得更好，而透明度可能会导致问题，因为这些现象涉及每个像素多个z深度。尽管如此，只有颜色和深度缓冲区作为输入，并且只使用三个后处理通道，这种方法简单且相对健壮。基于混淆圆的采样和将近场和远场分离成单独的图像(或一组图像)的想法是已开发的用于模拟景深的广泛算法中的一个共同主题。我们将讨论一些在电子游戏中使用的新方法，因为这些方法必须是有效的，可靠的，并且具有可预测的成本。</strong></p>
<p><strong>第一种方法使用了一种我们将在下一节再次讨论的方法:运动模糊。回到混沌圆的概念，想象把图像中的每个像素都变成对应的混沌圆，其强度与圆的面积成反比。按顺序绘制这组圆会得到最好的结果。这就把我们带回到散点的概念，所以通常是不切实际的。正是这种思维模式在这里很有价值。给定一个像素，我们想要确定所有重叠位置的混乱圈，并将它们按顺序混合在一起。参见下图。使用场景的最大混乱圈半径，对于每个像素，我们可以检查这个半径内的每个邻居，并找出其混乱圈是否包含我们当前的位置。然后对所有这些影响像素的重叠邻居样本进行分类和混合。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143925.png" class="" title="image-20211018143925">

<p>重叠的混乱圈。左边是一个有五个点的场景，都是聚焦的。假设红点在近场中离观众最近，紧接着是橙点;绿色的圆点在焦点范围内;蓝色和紫色的点在远场，按这个顺序。右图显示了由于应用景深而产生的圆圈混乱，圆圈越大，每像素的效果越差。绿色是不变的，因为它是焦点。中心像素只被红色和橙色的圆圈重叠，所以这些被混合在一起，红色在橙色之上，以赋予像素颜色。</p>
<p><strong>这种方法是理想的，但是对发现的碎片进行排序在GPU上是非常昂贵的。相反地，我们使用了一种名为“在收集时分散”的方法，即我们通过寻找哪些邻居将分散到像素的位置来进行聚集。选择z-深度最小(最近距离)的重叠邻域来表示较近的图像。任何其他在z深度上与之相当接近的重叠邻域都将添加它们的阿尔法混合贡献，取平均值，并将颜色和阿尔法存储在“前景”层中。这种类型的混合不需要分类。所有其他重叠的邻居都被相似地求和并平均，结果被放在一个单独的“背景”层中。前景和背景层并不对应于近场和远场，它们是在每个像素的区域中碰巧找到的。前景图像然后在背景上合成图像，产生近场模糊效果。虽然这种方法听起来很复杂，但应用各种采样和过滤技术可以使其高效。参阅Jimenez、Sousa、Sterna和Courr’eges的介绍，了解一些不同的实现，并查看下图中的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018144039.png" class="" title="image-20211018144039">

<p>近和远景深与五角形散景在明亮的反射杆在前景。(使用BakingLab演示生成的图像，由Matt Pettineo提供。)</p>
<p><strong>在一些较早的电子游戏中使用的另一种方法是基于计算热扩散的理念。图像被认为是一个向外扩散的热分布，每个混乱的圆圈代表该像素的导热率。聚焦区域是完美的绝缘体，没有扩散。Kass等人描述了如何将一维热扩散系统视为一个三对角矩阵，该矩阵可以在每个样品常数时间内求解。存储和解决这种类型的矩阵在计算着色器上工作得很好，所以实践者已经开发了几种实现，在这些实现中，图像沿着每个轴分解成这些一维系统。困惑圈的可见性问题仍然存在，通常通过基于深度生成和合成单独的层来解决。这种技术不能很好地处理混乱圈中的不连续点，如果有的话，所以在今天基本上是一种好奇。</strong></p>
<p><strong>一种特殊的景深效应是由明亮的光源或框架中的反射引起的。光或镜面反射的混乱圈可能比在画面中它附近的物体要亮得多，即使它在一个区域中被分散的变暗效果也是如此。虽然将每个模糊像素渲染为精灵是昂贵的，但这些明亮的光源对比度更高，因此更清楚地显示出光圈形状。</strong></p>
<p><strong>其余的像素差别较小，所以形状不那么重要。有时“散景”一词(错误地)被用来描述这些明亮的区域。检测高对比度区域并将这些明亮像素作为精灵进行渲染，同时使用收集技术对其余像素进行渲染，从而得到一个具有定义的散景，同时也是高效的。参见上图。计算着色器也可以使用，为收集景深和散景有效的溅射创建高质量的总和面积表。</strong></p>
<p><strong>我们已经介绍了许多渲染景深和明亮焦景效果的方法中的一些，描述了一些用来使过程有效的技术。随机光栅化、光场处理和其他方法也进行了探索。Vaidyanathan等人的文章总结了之前的工作，McGuire对一些实现进行了总结。</strong></p>
<h2 id="Motion-Blur-运动模糊"><a href="#Motion-Blur-运动模糊" class="headerlink" title="Motion Blur 运动模糊"></a>Motion Blur 运动模糊</h2><p><strong>为了呈现令人信服的图像序列，重要的是要有一个足够稳定和高的帧率。流畅和连续的运动是最好的，太低的帧率会体验到不稳定的运动。电影以24帧/秒的速度放映，但影院很暗，眼睛的时间反应对昏暗光线下的闪烁不太敏感。此外，电影放映机以24帧每秒的速度改变图像，但通过在显示下一张图像之前重新显示每个图像2-4次来减少闪烁。也许最重要的是，每一帧胶片通常都是一幅运动模糊图像;默认情况下，交互式图形图像不是。</strong></p>
<p><strong>在电影中，运动模糊来自于画面中物体在屏幕上的移动或摄像机的运动。这种效果来自于相机的时间快门打开的时间是1/40到1/60秒，而每帧的打开时间是1/24秒。我们习惯于在电影中看到这种模糊，并认为这很正常，所以我们希望在电子游戏中也能看到这种情况。快门打开不到1/500秒就会产生一种过度运动的效果，这种效果首次出现在电影《Gladiator》和《Saving Private Ryan》中。</strong></p>
<p><strong>快速移动的物体在没有运动模糊的情况下会出现抖动，在帧间“跳跃”许多像素。这可以被认为是一种走样，类似于锯齿，但本质上是时间而不是空间。运动模糊可以被认为是时域的抗锯齿。正如提高显示分辨率可以减少但不能消除锯齿一样，提高帧率也不能消除运动模糊的需要。电子游戏的特点是摄像机和物体的快速运动，所以运动模糊可以显著改善游戏的视觉效果。事实上，带有运动模糊的30帧/秒通常比没有的60帧/秒更好。</strong></p>
<p><strong>运动模糊依赖于相对运动。如果一个物体在屏幕上从左到右移动，它就会在屏幕上水平模糊。如果摄像机在跟踪一个移动的物体，物体不会变得模糊——背景会。参见下图。这就是现实世界的相机是如何工作的，一个好的导演知道拍摄一个镜头，使感兴趣的区域在焦点和不模糊。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211019112135.png" class="" title="image-20211019112135">

<p>在左边，摄像机是固定的，汽车是模糊的。在右侧，摄像机跟踪着这辆车，背景变得模糊。(图片由Morgan McGuire等人提供。)</p>
<p><strong>与景深相似，积累一系列图像提供了一种创建运动模糊的方法。当快门打开时，帧有一个持续时间。场景在这个跨度的不同时间被渲染，摄像机和对象被重新定位。得到的图像混合在一起，得到一个模糊的图像，其中物体相对于相机的视野移动。对于实时渲染，这样的过程通常是适得其反的，因为它可以大大降低帧率。此外，如果物体快速移动，当个别图像变得可识别时，伪影是可见的。第525页的图12.7也显示了这个问题。随机栅格化可以避免多幅图像混合时出现的重影伪影，而不是产生噪声。</strong></p>
<p><strong>如果想要的是运动的暗示而不是纯粹的现实主义，那么积累的概念可以巧妙地运用。假设已经生成了一个模型的8帧，并将其归结为一个高精度缓冲区，然后将其平均并显示出来。在第九帧，模型被再次渲染累积，但也在这个时候，第一个帧的渲染再次执行，并从求和结果中减去。缓冲区现在有8帧模糊模型，从第2帧到第9帧。在下一帧，我们减去第二帧，加上第十帧，同样得到八帧的和，从3到10。这给了一个高度模糊的艺术效果，以每帧渲染场景两次为代价。</strong></p>
<p><strong>实时图形需要比多次渲染帧更快的技术。景深和运动模糊都可以通过平均一组视图来呈现，这表明了这两种现象之间的相似性。为了有效地渲染这些，这两种效果都需要将它们的样本分散到相邻的像素上，但我们通常会收集它们。他们还需要处理多个不同的模糊层，并根据单个起始帧的内容重建被遮挡的区域。</strong></p>
<p><strong>运动模糊有几个不同的来源，每一个都有可以应用到它的方法。这些可以分为摄像机方向变化、摄像机位置变化、对象位置变化和对象方向变化，其复杂度大致呈递增顺序。如果摄像机保持它的位置，整个世界可以被认为是围绕着观众的天空盒(第13.3节)。方向的改变会在整个图像上创建有方向的模糊。给定一个方向和速度，我们沿着这个方向对每个像素进行采样，速度决定了过滤器的宽度。这种方向模糊被称为线积分卷积(LIC)，它也被用于可视化流体流动。Mitchell讨论了给定运动方向的运动模糊立方环境映射。如果摄像机沿其视图轴旋转，则使用圆形模糊，每个像素的方向和速度相对于旋转中心发生变化。</strong></p>
<p><strong>如果相机的位置发生变化，视差就会起作用，例如，远处的物体移动得更慢，因此模糊程度也更小。当相机向前移动时，视差可能被忽略。放射状模糊可能是足够的，并可以夸大戏剧性的效果。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211019112325.png" class="" title="image-20211019112325">

<p>径向模糊增强运动的感觉。(图片来自育碧的《刺客信条》)</p>
<p><strong>为了增加真实感，比如在赛车游戏中，我们需要一个模糊的图像来正确计算每个物体的运动。如果在向前看的同时侧向移动，在计算机图形学中称为平移，深度缓冲告诉我们每个物体应该被模糊的程度。物体越靠近，就越模糊。如果向前移动，移动的量就更复杂了。Rosado描述了使用前一帧的相机视图矩阵来计算飞行速度。其想法是将像素的屏幕位置和深度转换回世界空间位置，然后使用前一帧的相机将这个世界点转换到屏幕位置。这些屏幕空间位置之间的区别是速度向量，它用于模糊该像素的图像。合成对象可以以四分之一屏幕大小渲染，既可以节省像素处理，又可以滤除采样噪声。</strong></p>
<p><strong>如果物体彼此独立运动，情况就会更加复杂。一个直接但有限的方法是建模和渲染模糊本身。这是绘制线段来表示运动粒子的基本原理。这个概念可以扩展到其他对象。想象一把剑划过天空。在叶片前后，沿着其边缘添加两个多边形。这些可以在运行中建模或生成。这些多边形每个顶点都使用alpha不透明度，所以当多边形遇到剑时，它是完全不透明的，而在多边形的外缘，alpha是完全透明的。这个模型在移动方向上是透明的，模拟的效果是，当(想象的)快门打开时，剑只在部分时间覆盖这些像素。</strong></p>
<p><strong>这种方法可以用于简单的模型，如摇摆的剑刃，但纹理、亮点和其他特征也应该是模糊的。每个移动的表面都可以看作是单个的样本。我们希望分散这些样本，早期的运动模糊方法就是这样做的，方法是沿着运动的方向扩展几何体。这种几何操作是昂贵的，所以就开发了“即聚即散”的方法。对于景深，我们将每个样本扩展到其混沌圆的半径。对于移动样本，我们代替将每个样本沿着它在帧内行进的路径拉伸，类似于LIC。一个快速移动的样本覆盖的面积更大，所以对每个地点的影响更小。理论上，我们可以在一个场景中取所有的样本，并把它们按照有序的顺序画成半透明的线段。如下图所示。随着采样次数的增加，产生的模糊在前后边缘有一个平滑的透明梯度，就像我们的剑的例子一样。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211019112459.png" class="" title="image-20211019112459">

<p>在左边，一个水平移动的样本给出一个透明的结果。在右侧，7个样本产生了渐缩效果，因为覆盖外部区域的样本更少。中间的区域是不透明的，因为在整个画面中它总是被一些样本覆盖着。(在吉梅内斯)。</p>
<p><strong>要使用这个想法，我们需要知道每个像素表面的速度。一个被广泛采用的工具是速度缓冲器的使用。要创建这个缓冲区，请在模型的每个顶点上插入屏幕空间速度。速度可以通过对模型应用两个建模矩阵来计算，一个用于前一帧，一个用于当前帧。顶点着色程序计算位置的差异，并将这个向量转换为相对的屏幕空间坐标。如下图所示。Wronski讨论了速度缓冲器的推导和运动模糊与时间抗锯齿的结合。Courr’eges简要说明了《毁灭战士》(2016)是如何实现这一组合的，并比较了结果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211019112601.png" class="" title="image-20211019112601">

<p>运动模糊由于物体和相机的运动。嵌入了深度和速度缓冲区的可视化。(图片由Morgan McGuire等人提供。)</p>
<p><strong>一旦形成了速度缓冲区，就可以知道每个像素处的每个对象的速度。未模糊的图像也被渲染。注意，我们在处理景深时也遇到了类似的问题，即计算效果所需的所有数据都无法从单一图像中获得。对于景深的理想情况是将多个视图平均在一起，其中一些视图将包括其他视图中看不到的对象。对于交互式运动模糊，我们从时间序列中取出一帧，并使用它作为代表图像。我们尽可能地使用这些数据，但重要的是要认识到所需的所有数据并不总是在那里，这可能会创建工件。</strong></p>
<p><strong>给定这一帧和速度缓冲，我们可以使用“散点即收集”的运动模糊系统，重建影响每个像素的对象。我们从McGuire等人描述的方法开始，并由Sousa和Jimenez进一步发展(Pettineo提供代码)。在第一遍中，计算屏幕各部分的最大速度，例如每个8 × 8像素贴图(第23.1节)。结果是每个贴图有一个最大速度的缓冲区，一个有方向和大小的矢量。在第二步中，每个贴图都会检查一个3 × 3的贴图结果缓冲区，以便找到最大值。这一关确保了在贴图中快速移动的物体会被相邻的贴图所影响。也就是说，我们对场景的初始静态视图将变成一个物体模糊的图像。这些模糊会重叠到相邻的贴图上，所以这些贴图必须检查足够宽的区域才能找到这些移动的物体。</strong></p>
<p><strong>最后对运动模糊图像进行了计算。类似于景深，每个像素的邻域检查可能快速移动和重叠像素的样本。不同之处在于，每个样本都有自己的速度，沿着自己的路径。已经开发了不同的方法来过滤和混合相关的样品。一种方法是利用最大速度的大小来确定核的方向和宽度。如果这个速度小于半个像素，则不需要运动模糊。否则，图像沿最大速度方向采样。注意，遮挡在这里很重要，因为它与景深有关。一个在静态对象后面快速移动的模型不应该让它的模糊效果在这个对象上扩散。如果发现相邻样本的距离与像素的z深度足够接近，则认为它是可见的。这些样品混合在一起形成前景的贡献。</strong></p>
<p><strong>在上上图中，运动模糊的物体有三个区域。不透明区域完全被前景对象覆盖，因此不需要进一步混合。在原始图像中，外部模糊区域(顶部一行有7个蓝色像素)有一个可用的背景颜色，在这些像素上可以混合前景。然而，内部模糊区域不包含背景，因为原始图像只显示前景。对于这些像素，背景估计是通过滤波的邻居采样的像素不在前景中，理由是任何对背景的估计总比什么都没有好。上图显示了一个示例。</strong></p>
<p><strong>有几种采样和过滤方法用于改进这种方法的外观。为了避免重影，样本位置随机抖动半个像素。在外部模糊区域，我们有正确的背景，但模糊一点可以避免与内部模糊估计的背景不连贯。一个像素点上的对象可能会以与3×3贴图组的主导速度不同的方向移动，因此在这种情况下可以使用不同的过滤方法。Bukowski等人提供了其他实现细节，并讨论了针对不同平台的扩展方法。</strong></p>
<p><strong>这种方法对运动模糊效果很好，但其他系统当然也有可能，在质量和性能之间进行权衡。例如，Andreev使用速度缓冲和运动模糊，以便在以30帧/秒渲染的帧之间插入，有效地提供60帧/秒的帧率。另一个概念是将运动模糊和景深结合到一个系统中。其核心思想是将速度矢量和混淆圆结合，得到统一的模糊核。</strong></p>
<p><strong>其他方法也被研究过，随着GPU的性能和性能的提高，研究还将继续。例如Munkberg等人使用随机和交错采样在低采样率下渲染景深和运动模糊。在随后的过程中，他们使用快速重建技术来减少采样伪影，恢复运动模糊的平滑特性和景深。</strong></p>
<p><strong>在电子游戏中，玩家的体验通常不像看电影，而是在他们的直接控制下，视角以不可预测的方式改变。在这种情况下，如果纯粹基于相机，运动模糊有时会应用得很糟糕。例如，在第一人称射击游戏中，有些用户发现旋转会让人分心或晕车。在《使命召唤:高级战争》中，有一个选项可以移除由于摄像机旋转而产生的运动模糊，所以这种效果只适用于移动的物体。美术团队在游戏过程中移除旋转模糊，并在一些电影序列中打开它。平移运动模糊仍然被使用，因为它有助于传达跑步时的速度。另外，艺术指导也可以用于修改运动模糊，这是物理电影摄像机无法模拟的。假设一艘飞船进入了用户的视野，而摄像机没有跟踪它，也就是说。玩家不会转过头。使用标准的运动模糊，船将是模糊的，即使玩家的眼睛在跟随它。如果我们假设玩家将追踪一个对象，我们便可以相应地调整算法，在观众的眼睛追随背景时模糊背景，并保持对象不模糊。</strong></p>
<p><strong>眼球追踪设备和更高的帧率可能有助于改进运动模糊的应用，或完全消除它。然而，这种效果会让人产生一种电影般的感觉，所以它可能会继续以这种方式使用，或出于其他原因，比如暗示生病或头晕。运动模糊很可能会得到持续的应用，应用它可以是一门艺术，也可以是一门科学。</strong></p>
<h1 id="13-Beyond-Polygons-剔除多边形"><a href="#13-Beyond-Polygons-剔除多边形" class="headerlink" title="13 Beyond Polygons 剔除多边形"></a>13 Beyond Polygons 剔除多边形</h1><p><strong>用三角形建模表面通常是解决场景中物体描绘问题的最直接的方法。然而，三角形只在一定程度上有用。用图像表示对象的一个很大的优点是，渲染成本与渲染的像素数成正比，而不是与几何模型中的顶点数成正比。因此，基于图像的渲染的一个用途是作为一种更有效的方式来渲染模型。然而，图像采样技术的用途要广泛得多。许多物体，如云和毛，都很难用三角形来表示。分层的半透明图像可以用来显示如此复杂的表面</strong></p>
<p><strong>本章首先对基于图像的绘制与传统的三角形绘制进行了比较和对比，并对算法进行了概述。然后我们将描述一些常用的技术，如精灵、广告牌、视点替用特效、粒子、点云和体素，以及更多实验方法。</strong></p>
<h2 id="The-Rendering-Spectrum-渲染谱"><a href="#The-Rendering-Spectrum-渲染谱" class="headerlink" title="The Rendering Spectrum 渲染谱"></a>The Rendering Spectrum 渲染谱</h2><p><strong>渲染的目标是在屏幕上描绘一个对象;如何实现这一目标是我们的选择。渲染场景没有单一正确的方法。每一种渲染方法都是真实的近似值，至少在以照片真实感为目标的情况下是这样。</strong></p>
<p><strong>三角形的优点是可以从任何角度以合理的方式表现物体。当摄像机移动时，物体的表现形式不必改变。然而，为了提高质量，我们可能希望替换一个更详细的模型，因为观众越来越接近的对象。相反地，如果距离很远，我们可能希望使用模型的简化形式。这些被称为水平细节技术(第19.9节)。它们的主要目的是使场景显示更快。</strong></p>
<p><strong>其他的渲染和建模技术可以发挥作用，当一个对象从观察者撤退。用图像代替三角形来表示物体可以获得速度。用可以快速发送到屏幕上的单一图像表示对象通常更便宜。一种表示绘制技术连续统一体的方法来自于Lengyel，如下图所示。首先，我们将从频谱的左边回到我们更熟悉的右边区域。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211019113526.png" class="" title="image-20211019113526">

<p>渲染谱。(在阿帕德)。</p>
<h2 id="Fixed-View-Effects-固定视口效果"><a href="#Fixed-View-Effects-固定视口效果" class="headerlink" title="Fixed-View Effects 固定视口效果"></a>Fixed-View Effects 固定视口效果</h2><p><strong>对于复杂的几何和阴影模型，以交互速率重新渲染整个场景可能是昂贵的。通过限制观看者的移动能力，可以实现各种形式的加速。最具限制性的情况是相机根本不移动。在这种情况下，很多渲染一次就可以完成。</strong></p>
<p><strong>例如，想象一个有栅栏的牧场作为场景的静态部分，有一匹马穿过它。牧场和围栏渲染一次，然后颜色和z缓冲区被存储起来。在每一帧中，这些缓冲用来初始化颜色和z缓冲。马本身是所有需要渲染的，以获得最终的图像。如果马在栅栏后面，存储和复制的z-depth值将使马变得模糊。注意，在这个场景下，马不会投射阴影，因为场景是不变的。可以进行进一步的阐述，例如，可以确定马的阴影的影响面积，然后只需要在存储的缓冲区上评估静态场景的这一小块区域。关键的一点是，在图像中设置每个像素的颜色的时间和方式没有限制。对于一个固定的视图，通过将一个复杂的几何模型转换成一组简单的缓冲区可以节省很多时间，这些缓冲区可以被许多帧重用。</strong></p>
<p><strong>在计算机辅助设计(CAD)应用程序中，所有建模对象都是静态的，当用户执行各种操作时，视图不会发生变化，这是很常见的道路。一旦用户移动到一个想要的视图，颜色和z缓冲区可以被存储以立即重用，用户界面和突出显示的元素然后绘制每帧。这允许用户快速注释、测量或与复杂的静态模型进行交互。通过在缓冲区中存储附加信息，可以执行其他操作。例如，三维绘制程序还可以通过存储给定视图的对象id、法线和纹理坐标，并将用户的交互转换为纹理本身的更改来实现。</strong></p>
<p><strong>与静态场景相关的概念是金线，也被称为适应性优化或渐进式优化。这个想法是，当观察者和场景是静态的，计算机可以随着时间的推移产生越来越好的图像。场景中的物体可以变得更逼真。这样高质量的渲染图可以突然交换，或者在一系列的帧中混合。这种技术在CAD和可视化应用中特别有用。可以进行许多不同类型的改进。随着时间的推移，可以在每个像素内的不同位置生成更多的样本，并在此过程中显示平均结果，从而提供抗锯齿。这同样适用于景深，其中样本在镜头和像素上随机分层。高质量的阴影技术可以用来创建更好的图像。我们也可以使用更复杂的技术，如光线或路径跟踪，然后在新图像中渐隐。</strong></p>
<p><strong>一些应用程序进一步采用了固定视图和静态几何的想法，以允许在电影质量的图像中进行交互编辑。这种方法被称为重照明，其原理是用户在场景中选择一个视图，然后使用它的数据进行脱机处理，而脱机处理又会产生一组缓冲区或更复杂的结构来表示场景。例如，Ragan-Kelley等人保持阴影样本与最终像素分离。这种方法允许他们执行运动模糊、透明效果和抗锯齿。他们还使用自适应细化来随着时间的推移提高图像质量。Pellacini等人扩展了基本的再照明，包括间接的全局照明。这些技术非常类似于在延迟着色方法中使用的技术(见第20.1节)。主要的区别是，在这里，这些技术被用来摊销昂贵的渲染在多帧上的成本，而延迟着色使用它们在一帧内加速渲染。</strong></p>
<h2 id="Skyboxes-天空盒"><a href="#Skyboxes-天空盒" class="headerlink" title="Skyboxes 天空盒"></a>Skyboxes 天空盒</h2><p><strong>环境地图(第10.4节)表示空间局部体积的入射辐亮度。虽然这种地图通常用于模拟反射，但它们也可以直接用于表示周围的环境。下图显示了一个示例。任何环境地图表示，如全景图或立方体地图，都可以用于此目的。它的网格被做得足够大，足以包含场景中的其他物体。这种网格被称为天空盒。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020104221.png" class="" title="image-20211020104221">

<p>Mission Dolores的全景图，从底部生成了三种视图。请注意，这些观点本身看起来是没有任何扭曲的。(图片由Ken Turkowski提供。)</p>
<p><strong>拿起这本书，越过左边或右边的边缘去看它后面的东西。用右眼看，然后是左眼。相比之下，这本书的优势发生了变化视差被称为视差。这种效应对附近的物体很重要，帮助我们在移动时感知相对深度。然而，对于一个或一组离观察者足够远、彼此足够近的物体，当观察者改变位置时几乎觉察不到任何视差效应。例如，如果你移动一米，甚至一千米，一座遥远的山本身通常看起来并没有明显的不同。当你移动时，它可能会被附近的物体挡住视线，但如果把这些物体拿走，山和它周围的环境看起来还是一样的。</strong></p>
<p><strong>天空盒的网格通常以观察者为中心，并与他们一起移动。天空盒网格不需要很大，因为通过保持相对位置，它看起来不会改变形状。对于一个如图13.2所示的场景，观众可能只移动了一小段距离，然后他们就会发现他们并没有相对于周围的建筑真正移动。对于更大规模的内容，如星形或远处的风景，用户通常不会移动得足够远和快，因为物体大小、形状或视差没有变化。</strong></p>
<p><strong>天空盒通常以立方体地图的形式呈现在盒子网格上，因为每个面上的纹理像素密度相对相等。为了让天空盒看起来更好，立方体贴图的纹理分辨率必须足够高。，每个屏幕像素一个像素。这个公式对于必要的解法是近似的</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020104451.png" class="" title="image-20211020104451">

<p><strong>fov是相机的视场。较低的视场值意味着立方体地图必须具有较高的分辨率，因为立方体表面的较小部分占用相同的屏幕大小。这个公式可以通过观察立方体地图的一个面的纹理必须覆盖一个视角(水平和垂直)为90度而得到。</strong></p>
<p><strong>除了盒子外，还有其他形状环绕着世界。例如，Gehling描述了一个系统，其中一个扁平的圆顶用来代表天空。这种几何形式被认为是模拟云层在头顶移动的最佳方法。云本身是通过组合和动画各种二维噪声纹理来表示的。</strong></p>
<p><strong>因为我们知道天空盒在所有其他物体的后面，所以我们可以做一些很小但很有价值的优化。天空盒从不需要写入z缓冲区，因为它从不阻塞任何东西。如果先绘制，天空盒也不必从z缓冲区读取，网格可以是任何尺寸，因为深度是无关紧要的。然而，在不透明对象之后，在透明对象之前绘制天空盒，这样做的好处是场景中的对象已经覆盖了几个像素，降低了渲染天空盒时所需的像素着色器调用的数量。</strong></p>
<h2 id="Light-Field-Rendering-光场渲染"><a href="#Light-Field-Rendering-光场渲染" class="headerlink" title="Light Field Rendering 光场渲染"></a>Light Field Rendering 光场渲染</h2><p><strong>亮度可以从不同的位置和方向，在不同的时间和变化的照明条件下捕捉。在现实世界中，计算摄影领域探索从这些数据中提取各种结果。对象的纯粹基于图像的表示可以用于显示。例如，Lumigraph和光场渲染技术试图从一组视点捕捉单个对象。给定一个新视图，这些技术在存储视图之间执行插值过程，以创建新视图。这是一个复杂的问题，存储所需的所有视图需要很高的数据要求。这个概念类似于全息术，二维的视图数组代表了物体。这种渲染形式的一个诱人的方面是能够捕获一个真实的物体，并能够从任何角度重新显示它。任何物体，无论表面和光线的复杂程度，都可以以几乎恒定的速度显示出来。关于这个主题的更多信息，请参阅Szeliski的书。近年来，人们对光场渲染重新产生了研究兴趣，因为它可以让眼睛使用虚拟现实显示器来适当调整焦点。这些技术目前在交互渲染中使用有限，但它们界定了计算机图形学领域的可能。</strong></p>
<h2 id="Sprites-and-Layers-精灵和图层"><a href="#Sprites-and-Layers-精灵和图层" class="headerlink" title="Sprites and Layers 精灵和图层"></a>Sprites and Layers 精灵和图层</h2><p><strong>精灵是最简单的基于图像的渲染原语之一。精灵是在屏幕上移动的图像，例如鼠标光标。精灵不需要有矩形形状，因为有些像素可以渲染成透明的。对于简单的精灵，存储的每个像素将被复制到屏幕上的一个像素。动画可以通过呈现一系列不同的精灵而生成。</strong></p>
<p><strong>更一般的精灵类型是将图像纹理渲染到总是面向观众的多边形上。这允许精灵调整大小和变形。图像的alpha通道可以为精灵的各种像素提供完全或部分透明度，因此也可以在边缘上提供抗锯齿效果(章节5.5)。这种类型的精灵可以有深度，也就是场景本身的位置。</strong></p>
<p><strong>我们可以把场景看作是一系列的图层，这在二维的cel动画中是很常见的。例如，在下图中，后挡板在鸡的前面，鸡在卡车驾驶室的前面，而卡车驾驶室又在道路和树木的前面。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020105224.png" class="" title="image-20211020105224">

<p>来自动画小鸡交叉，使用护身符模拟器渲染。在这个场景中，我们使用了80层精灵，其中一些被勾勒出来并显示在左边。由于鸡翅部分位于后挡板的前面和后面，两者被放置在一个精灵。(经微软公司许可转载)</p>
<p><strong>这种分层适用于大量的观点集。每个精灵层都有相应的深度。通过按照画家算法的前后顺序渲染，我们可以在不需要z缓冲区的情况下构建场景。相机缩放只是让对象变大，这很容易用相同的精灵或相关的mipmap来处理。移动相机实际上改变了前景和背景的相对覆盖，这可以通过改变每个精灵层的覆盖和位置来处理。当查看器横向或垂直移动时，层可以相对于它们的深度移动。</strong></p>
<p><strong>一组精灵可以代表一个对象，一个独立的精灵代表不同的视图。如果对象在屏幕上足够小，那么存储大量视图(即使是动画对象)也是可行的策略。视角的微小变化也可以通过扭曲精灵的形状来处理，尽管最终这种近似会被打破，需要生成一个新的精灵。具有不同表面的物体在小的旋转后会发生显著的变化，因为新的多边形变得可见，而其他的则被遮挡。</strong></p>
<p><strong>这一层和图像扭曲过程是90年代末微软支持的Talisman硬件架构的基础。虽然这个特定的系统由于许多原因而逐渐消失，但通过一个或多个基于图像的表示来表示模型的想法已经被发现是卓有成效的。使用不同容量的图像可以很好地映射到GPU的强度，基于图像的技术可以与基于三角形的渲染相结合。以下部分将讨论视点替用特效、深度精灵和其他使用图像代替多边形内容的方法。</strong></p>
<h2 id="Billboarding-公告牌"><a href="#Billboarding-公告牌" class="headerlink" title="Billboarding 公告牌"></a>Billboarding 公告牌</h2><p><strong>基于视图方向对一个有纹理的矩形进行定位称为公告牌，该矩形称为广告牌。当视图改变时，矩形的方向也随之改变。广告牌，结合alpha纹理和动画，可以代表许多现象，没有光滑的固体表面。草、烟、火、雾、爆炸、能量盾、蒸汽轨迹和云只是这些技术可以代表的对象中的一部分。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020105407.png" class="" title="image-20211020105407">

<p>代表雪、表面和人物的小广告牌。(来自three.js示例程序。)</p>
<p><strong>本节将介绍几种流行的广告牌形式。在每个，表面法线和向上的方向被发现为矩形的定向。这两个向量足以构成曲面的一组标准正交基。换句话说，这两个向量描述了将四边形旋转到最终方向所需的旋转矩阵(章节4.2.4)。在四边形上的锚点位置(例如，它的中心)然后用来确定它在空间中的位置。</strong></p>
<p><strong>通常，所要求的表面法向量n和上向量u不是垂直的。在所有的公告牌技术中，这两个向量中的一个被确定为必须在给定方向上保持的固定向量。使另一个向量垂直于这个固定向量的过程总是一样的。首先，创建一个“右”向量r，指向四边形右边的向量。这是通过求u和n的叉乘来完成的。将这个向量r标准化，因为它将被用作旋转矩阵的标准正交基的轴。如果向量r长度为零，则u和n必须是并行的，可以使用第4.2.4节中描述的技术。如果r的长度不是完全为零，而是接近于零，那么u和n几乎是平行的，就会出现精度误差。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020105700.png" class="" title="image-20211020105700">

<p>对于一个法向n和近似向上的向量方向u的广告牌，我们想要创建一个由三个相互垂直的向量组成的集合来定位广告牌。在中间的图中，右边的向量r是通过求u和n的叉乘得到的，所以它垂直于这两个向量。在右图中，固定向量n与r相交，得到相互垂直的向量u′。</p>
<p><strong>从(非并行)n和u向量计算r和新的第三个向量的过程如上图所示。如果正常的n保持不变，就像大多数公告牌技术一样，那么新的向上向量u′ 是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020105803.png" class="" title="image-20211020105803">

<p><strong>相反，如果向上的方向是固定的(对于轴向对齐的广告牌，如景观上的树)，那么新的法向量n ‘是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020105812.png" class="" title="image-20211020105812">

<p><strong>然后对新向量进行归一化，并用这三个向量形成一个旋转矩阵。例如，对于固定的法向量n和调整后的向量u ‘矩阵是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020105821.png" class="" title="image-20211020105821">

<p><strong>这个矩阵变换了一个四边形在xy平面与+y指向它的顶部边缘，并围绕其锚定位置为中心，以适当的方向。然后应用一个平移矩阵将四边形的锚点移动到所需的位置。</strong></p>
<p><strong>有了这些初步准备，剩下的主要任务是决定什么表面法线和向上的矢量用来定义广告牌的方向。下面几节将讨论几种构造这些向量的不同方法。</strong></p>
<h3 id="Screen-Aligned-Billboard-屏幕对齐公告牌"><a href="#Screen-Aligned-Billboard-屏幕对齐公告牌" class="headerlink" title="Screen-Aligned Billboard 屏幕对齐公告牌"></a>Screen-Aligned Billboard 屏幕对齐公告牌</h3><p><strong>最简单的广告牌形式是屏幕对齐的广告牌。这种形式与二维精灵相同，即图像始终与屏幕平行，并具有常量向上向量。摄像机将场景渲染到与近平面和远平面平行的视场平面上。我们经常在近平面的位置上想象这个假想平面。对于这种类型的广告牌，所需的表面法线是视平面法线的负，其中视平面法线vn 点远离视图位置。向上的向量u来自相机本身。它是视图平面上定义摄像机向上方向的向量。这两个向量已经是垂直的了，所以所需要的就是“右”方向向量r来形成广告牌的旋转矩阵。因为n和u对于摄像机来说是常数，所以这个旋转矩阵对于所有这种类型的广告牌都是相同的。</strong></p>
<p><strong>除了粒子效果，屏幕对齐的广告牌对于注释文本和地图placemark等信息也很有用，因为文本总是与屏幕本身对齐，因此得名“广告牌”。“请注意，在文本注释中，对象在屏幕上的大小通常是固定的。这意味着，如果用户放大或推离广告牌的位置，广告牌将增加世界空间的大小。因此，对象的大小依赖于视图，这可能会使锥角剔除等方案复杂化。</strong></p>
<h3 id="World-Oriented-Billboard-外向型公告牌"><a href="#World-Oriented-Billboard-外向型公告牌" class="headerlink" title="World-Oriented Billboard 外向型公告牌"></a>World-Oriented Billboard 外向型公告牌</h3><p><strong>我们希望广告牌能够显示玩家身份或位置名称。然而，如果摄像机倾斜，例如在飞行模拟中进入一个曲线，我们希望广告牌云倾斜响应。如果一个精灵代表一个物理对象，它通常是基于世界的向上方向，而不是摄像机的方向。圆形精灵不受倾斜的影响，但其他广告牌形状会受到影响。我们可能希望这些广告牌保持面向观众，但也要沿着它们的视图轴旋转，以保持面向世界。</strong></p>
<p><strong>对于这样的精灵，渲染它们的一种方法是使用这个世界上的向量来推导旋转矩阵。在这种情况下，法线仍然是视图平面法线的否定，这是固定的向量，一个新的垂直向上的向量是从世界上的上向量推导出来的，如前所述。与屏幕对齐的广告牌一样，这个矩阵可以在所有精灵中重复使用，因为这些向量不会在渲染场景中发生改变。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020110319.png" class="" title="image-20211020110319">

<p>有四个球体的视野，视野开阔。左上方是一个球体的广告牌纹理，使用视图平面对齐。右上角的广告牌是面向视点的。下面一行显示了两个真实的球体。</p>
<p><strong>在所有精灵中使用相同的旋转矩阵是有风险的。由于透视投影的性质，离视轴有一定距离的物体是弯曲的。见上图中底部的两个球体。由于在平面上的投影，球体变成椭圆形。这种现象不是错误，如果观众的眼睛与屏幕的距离和位置合适，它看起来很好。也就是说，如果虚拟相机的几何视场与人眼的显示视场匹配，那么这些球体看起来是不弯曲的。观察者不会注意到视野中高达10%-20%的轻微不匹配。然而，通常的做法是给虚拟相机一个更广阔的视野，以呈现更多的世界给用户。此外，匹配的视场将是有效的，只有当观众是在一个给定的距离前显示的中心。几个世纪以来，艺术家们已经意识到了这个问题，并做出了必要的补偿。被认为是圆的物体，如月亮，被画成圆形，而不管它们在画布上的位置。</strong></p>
<p><strong>当视场或精灵很小时，这种扭曲效果可以忽略，并使用一个与视图平面对齐的单一方向。否则，所需的法线需要等于从广告牌的中心到观众的位置的矢量。这就是我们所说的面向视点的广告牌。参见下图。使用不同对齐方式的效果如上图所示。可以看出，视图平面对准具有使广告牌不失真的效果，无论它在屏幕上的哪个位置。视点方向扭曲球体图像的方式与真实球体通过将场景投影到平面上而扭曲的方式相同。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020110440.png" class="" title="image-20211020110440">

<p>一个俯视图的两个广告牌对齐技术。这五块广告牌的正面不同，取决于使用的方法。</p>
<p><strong>外向型的广告牌对于呈现许多不同的现象是有用的。Guymon和Nguyen都讨论了制造令人信服的火焰、烟雾和爆炸。一种技术是以随机和混乱的方式聚集和重叠动画精灵。这样做有助于隐藏动画序列的循环模式，同时也避免让每次火灾或爆炸看起来都一样。</strong></p>
<p><strong>镂空纹理中的透明像素对最终图像没有影响，但必须由GPU处理，并在栅格化管道的后期丢弃，因为alpha是零。一组动画裁剪纹理通常会有特别大的透明像素边缘区域的框架。我们通常会考虑将纹理应用到矩形基元上。Persson注意到带有调整过的纹理坐标的更紧密的多边形能够更快速地渲染精灵，因为处理的像素更少。参见下图。他发现，一个只有四个顶点的新多边形可以提供实质性的性能改进，而使用超过8个顶点的新多边形将达到一个收益递减点。“粒子切割”工具是Unreal Engine 4的一部分，例如。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020110618.png" class="" title="image-20211020110618">

<p>云精灵包含一个大的透明条纹。使用绿色的凸包，红色的紧凑的四角和八角多边形可以包含更少的透明像素。与最左边的方形粒子相比，这样做可以使整体面积分别减少40%和48%。(图片由Emil Persson提供。)</p>
<p><strong>广告牌的一个常见用途是云渲染。Dobashi等人模拟云，并用广告牌渲染它们，并通过渲染同心半透明外壳来创建光轴。哈里斯和拉斯特拉也使用视点替用来模拟云。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020110810.png" class="" title="image-20211020110810">

<p>由一组面向世界的视点替用特效创建的云。(图片由北卡罗来纳大学教堂山分校的马克·哈里斯提供。)</p>
<p><strong>Wang详细介绍了在Mi- crosoft的飞行模拟器产品中使用的云建模和渲染技术。每块云是由5到400个广告牌组成的。只需要16种不同的基础精灵纹理，因为它们可以使用非均匀缩放和旋转来修改，以形成各种各样的云类型。根据离云中心的距离修改透明度，用于模拟云的形成和消散。为了节省处理时间，远处的云都被渲染到场景周围的一组8个全景纹理中，类似于天空盒。</strong></p>
<p><strong>平面广告牌并不是唯一可能的云渲染技术。例如，Elinas和Stuerzlinger通过渲染嵌套椭球集合来生成云，这些椭球集合在观测轮廓周围变得更加透明。Bahnassi和Bahnassi渲染椭球体，他们称之为“超级粒子”，然后使用模糊和屏幕空间的湍流纹理，以提供令人信服的云状外观。Pallister讨论了程序生成云图，并通过头顶的天空网格将其动画化。Wenzel用一系列的飞机在观察者上方观察远处的云。我们在这里专注于渲染和混合广告牌和其他原语。云广告牌的着色方面在第14.4.2节讨论，真实体积方法在第14.4.2节讨论。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020111030.png" class="" title="image-20211020111030">

<p>在左边，圈出的区域是由于灰尘云牌与物体相交而形成的边缘和带状。在右边，广告牌在靠近物体的地方淡出，避免了这个问题。在底部，较低的圆圈区域被放大以进行比较。(图片来自NVIDIA SDK 10样本“软粒子”，由NVIDIA公司提供。)</p>
<p><strong>如第5.5和6.6节所述，为了正确地执行合成，重叠的半透明广告牌应该按顺序呈现。当烟雾广告牌与固体物体相交时，会产生伪影。参见上图。这种错觉被打破了，因为应该是一个卷的东西被看作是一组层。一个解决方案是让像素着色程序在处理每个广告牌时检查底层对象的z深度。广告牌测试这一深度，但不取代它自己的，即不写z-depth。如果底层对象在像素处接近广告牌的深度，那么广告牌片段就会变得更加透明。这样，广告牌就更像一个体积，层工件就消失了。当达到最大衰落距离时，随深度线性衰落会导致不连续。s曲线衰减函数避免了这个问题。Persson指出，观察者与粒子的距离将改变如何最好地设置淡出范围。Lorach提供了更多的信息和实现细节。以这种方式改变其透明度的广告牌被称为软粒子。</strong></p>
<p><strong>使用软粒子的淡出解决了广告牌与实体物体相交的问题，如上图所示。其他藏物可能在爆炸时发生通过场景或观众在云中移动。在前一种情况下，广告牌可以在动画期间从一个物体的后面移动到前面。如果广告牌从完全不可见移动到完全可见，就会引起明显的弹出。类似地，当观众通过广告牌时，广告牌可以完全消失，因为它移动到近平面的前面，导致所看到的突然变化。一个快速的解决方法是让广告牌在靠近时变得更加透明，然后淡出以避免“流行”。</strong></p>
<p><strong>更现实的解决方案是可能的。Umenhoffer等人引入了球形广告牌的概念。广告牌对象被认为是在空间中定义一个球形体积。广告牌本身被渲染为忽略z深度读取;广告牌的目的纯粹是为了让像素着色程序在球体可能所在的位置执行。像素着色程序在这个球形体积上计算入口和出口位置，并使用实体对象根据需要改变出口深度和近剪辑平面来改变入口深度。通过这种方式，每个广告牌的球体可以适当地淡出，通过增加基于从相机的光线在剪切球体内旅行的距离的透明度。</strong></p>
<p><strong>在《孤岛危机》中使用了一种稍微不同的技术，使用盒形体积而不是球体来减少像素着色器成本。另一个优化是让广告牌代表音量的前面，而不是后面。这允许使用z-buffer测试跳过实体对象后面的卷部分。这种优化是可行的，只有当音量是已知的，完全在观众面前，所以广告牌不剪辑近视图平面。</strong></p>
<h3 id="Axial-Billboard-轴向广告牌"><a href="#Axial-Billboard-轴向广告牌" class="headerlink" title="Axial Billboard 轴向广告牌"></a>Axial Billboard 轴向广告牌</h3><p><strong>最后一种常见类型叫做轴向广告牌。在这种方案中，纹理对象通常不直接面对查看器。相反，它被允许围绕某个固定的世界空间轴旋转，并在这个范围内尽可能地面向观众。这种广告牌技术可以用于显示远处的树木。不是用一个实心的表面来表示一棵树，甚至是6.6节中描述的一对树的轮廓，而是使用一个单独的树广告牌。世界向上的向量是沿着树的树干的一个轴。随着查看器的移动，树面向查看器，如下图所示。此图像是一个面向摄像头的广告牌，与第203页图6.28所示的“十字树”不同。对于这种形式的广告牌，世界向上的矢量是固定的，视点方向是第二个可调节的矢量。一旦这个旋转矩阵形成，树就被平移到它的位置。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020111501.png" class="" title="image-20211020111501">

<p>当观众在场景周围移动时，灌木丛广告牌旋转面向前方。在这个例子中，灌木从南方被照亮，这样变化的视图使整体的着色随着旋转而变化。</p>
<p><strong>这种形式与面向世界的广告牌的不同之处在于什么是固定的，什么是允许旋转的。面向世界，广告牌直接面对观众，并可以沿着这个视图轴旋转。它被旋转，使广告牌的向上方向尽可能与世界的向上方向对齐。对于轴向广告牌，世界的向上方向定义了固定轴，广告牌围绕它旋转，使它尽可能面向观众。例如，如果观众是近在每一种类型的广告牌上方，面向世界的版本将完全面向它，而轴向的版本将更贴合场景。</strong></p>
<p><strong>由于这种行为，轴向广告牌的一个问题是，如果观察者从树的上方飞过并向下看，这种错觉就会被破坏，因为树几乎是在边缘上出现的，看起来就像它们原来的样子。一个解决方案是添加树的水平横截面纹理(不需要广告牌)来帮助改善问题。</strong></p>
<p><strong>另一种技术是使用细节级别技术将基于图像的模型转换为基于网格的模型。将树模型从三角形网格转换成一组广告牌的自动化方法将在第13.6.5节中讨论。Kharlamov等人提出了相关的树绘制技术，Klint解释了大量植被的数据管理和表示。第857页的图19.31显示了在商用SpeedTree包中用于渲染远处树的轴向广告牌技术。</strong></p>
<p><strong>就像屏幕对齐的广告牌适合表示对称的球形物体一样，轴向广告牌也适合表示圆柱形对称的物体。例如，激光光束效果可以用轴向广告牌渲染，因为它们的外观从轴的任何角度看起来都是一样的。如下图所示。第913页的图20.15显示了更多示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020111641.png" class="" title="image-20211020111641">

<p>广告牌的例子。平视显示器(HUD)图形和星形投射物是屏幕对齐的广告牌。右图中巨大的泪滴爆炸是一个面向视角的广告牌。曲线梁是由一组四边形连接而成的轴向广告牌。为了创造一个连续的梁，这些四边形在它们的角连接，因此不再是完全的矩形。(图片由Maxim Garber、Mark Harris、Vincent Scheib、Stephan Sherman和Andrew Zaferakis提供，来自《BHX: Beamrunner Hypercross》)</p>
<p><strong>这些类型的技术说明了这些算法的一个重要想法，即像素着色器的目的是评估真实的几何形状，丢弃在表示对象边界之外发现的碎片。对于广告牌来说，当图像纹理完全透明时，就会发现这样的碎片。正如将看到的，更复杂的像素着色器可以评估，以找到模型存在的地方。这些方法中的几何学功能是对像素着色器进行评估，并给出一些z深度的粗略估计，这可以通过像素着色器进行优化。我们想要避免在模型外计算像素上浪费时间，但我们也不想使几何形状如此复杂，顶点处理和不必要每个三角形外部的像素着色器调用(由于沿其边缘生成2 × 2个四边形;见18.2.3节)成为重大成本。</strong></p>
<h3 id="Impostors-视点替用"><a href="#Impostors-视点替用" class="headerlink" title="Impostors 视点替用"></a>Impostors 视点替用</h3><p><strong>视点替用特效是一个广告牌，它是通过将一个复杂的物体从当前的视点渲染成一个图像纹理来创建的，这个纹理被映射到广告牌上。视点替用特效可以用于对象的几个实例或几帧，从而摊销生成它的成本。本节将介绍更新视点替用特效的不同策略。Maciel和Shirley早在1995年就识别出了几种不同类型的视点替用，包括本节介绍的视点替用。从那时起，视点替用的定义就缩小到了我们在这里使用的。</strong></p>
<p><strong>视点替用特效图像在对象存在的地方是不透明的;其他地方都是完全透明的。它可以用几种方法来代替几何网格。例如，视点替用图像可以表示由小静态对象组成的杂波。视点替用特效对于快速渲染远处的物体很有用，因为一个复杂的模型被简化为一个单一的图像。另一种方法是使用最小级别的详细模型(第19.9节)。然而，这种简化的模型往往会丢失形状和颜色信息。视点替用特效没有这个缺点，因为生成的图像可以近似匹配显示器的分辨率。另一种使用视点替用特效的情况是，靠近观看者的物体在移动时暴露同一侧给观看者。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020112052.png" class="" title="image-20211020112052">

<p>在左侧，视点截锥从侧面观察的对象创建一个视点替用特效。视图的方向是指向对象的中心c，图像被渲染并用作视点替用特效纹理。如图所示，纹理应用于一个四边形。视点替用特效的中心等于对象的中心，而法线(从中心发出)直接指向视点。</p>
<p><strong>在渲染对象以创建视点替用特效图像之前，查看器被设置为查看对象边界框的中心，选择视点替用特效矩形以便它直接指向视点(上图中的左侧)。尺寸视点替用特效的四边形是包含物体投影边框的最小矩形。Alpha值被清除为零，在渲染对象的任何地方，Alpha值都被设置为1.0。然后，图像被用作面向视图的广告牌。如上图的右侧所示。当相机或视点替用特效对象移动时，纹理的分辨率可能会被放大，这可能会打破错觉。Schaufler和St¨urzlinger提出了决定视点替用图像何时需要更新的启发式方法。</strong></p>
<p><strong>Forsyth给出了许多在游戏中使用视点替用的实用技巧。例如，更频繁地更新靠近查看者或鼠标光标的对象可以提高感知质量。当视点替用特效被用于动态对象时，他描述了一种预处理技术，它决定了最大距离d，即在整个动画期间的任何顶点移动。这个距离除以动画中的时间步长数，因此∆= d/帧。如果一个视点替用特效被用于n帧而没有更新，则∆∗n被投影到图像平面上。如果此距离大于用户设置的阈值，则更新视点替用特效。</strong></p>
<p><strong>将纹理映射到面向观众的矩形上并不总是能产生令人信服的效果。问题是视点替用特效本身没有厚度，所以当与真实几何体结合时就会出现问题。参见图13.16中的右上方图像。Forsyth建议将纹理沿着视图方向投射到物体的边界框上。这至少给视点替用特效增加了一点几何效果。</strong></p>
<p><strong>通常最好是在物体移动时渲染几何体，当物体是静态时切换为视点替用特效。Kavan等人引入了polypostors，其中一个人的模型由一组视点替用代表，每个肢体一个和主干。这个系统试图在纯视点替用特效和纯几何之间取得平衡。Beacco等人描述了用于人群渲染的polypostors和其他大量与视点替用器相关的技术，并对每种技术的优缺点进行了详细的比较。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020112408.png" class="" title="image-20211020112408">

<p>一种视点替用特效技术，其中每个单独的动画元素都由一组图像来表示。这些是在一系列的掩蔽和合成操作中呈现的，这些操作结合起来为给定的视图形成一个令人信服的模型。(图片由Alejandro Beacco提供，版权c 2016 John Wiley &amp; Sons, Ltd.。)</p>
<h3 id="Billboard-Representation-广告牌表示"><a href="#Billboard-Representation-广告牌表示" class="headerlink" title="Billboard Representation 广告牌表示"></a>Billboard Representation 广告牌表示</h3><p><strong>视点替用特效的一个问题是，渲染后的图像必须继续面对观看者。如果远处的对象正在改变其方向，则必须重新计算视点替用特效。D´ecoret等人为了更像它们所代表的三角形网格，对远处的物体建模，提出了广告牌云的概念。一个复杂的模型通常可以由一小群重叠的镂空广告牌来表示。附加信息，如法线或位移贴图和不同的材料，可以应用到他们的表面，使这些模型更有说服力。</strong></p>
<p><strong>这种寻找一组平面的想法比剪纸的比喻所暗示的更普遍。广告牌可以相交，切口可以任意复杂。例如，一些研究人员将广告牌与树模型相匹配。从模型有成千上万的三角形，他们可以创建令人信服的广告牌云组成的不到100个纹理四边形。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020112624.png" class="" title="image-20211020112624">

<p>左边是由20,610个三角形组成的树模型。在树的中间，有78块广告牌。重叠的广告牌显示在右边。(图片由犹他州大学Dylan Lacewell提供。)</p>
<p><strong>使用广告牌云可以导致相当多的透支，这可能是昂贵的。质量也会受到影响，因为交叉的切割可能意味着严格的前后绘制顺序无法实现。Alpha到覆盖(章节6.6)可以帮助渲染复杂的Alpha纹理集。为了避免透支，SpeedTree等专业软件包使用带有alpha纹理的树叶和树枝集合的大网格来表示和简化模型。虽然几何图形处理需要更多的时间，但这远远超过了较低的透支成本。第857页的图19.31显示了一些示例。另一种方法是使用体积纹理来表示这些对象，并将其作为一系列垂直于人眼视图方向的层进行渲染，如第14.3节所述。</strong></p>
<h2 id="Displacement-Techniques-置换技术"><a href="#Displacement-Techniques-置换技术" class="headerlink" title="Displacement Techniques 置换技术"></a>Displacement Techniques 置换技术</h2><p><strong>如果视点替用特效的纹理是用深度组件增强的，这就定义了一个称为深度精灵(depth sprite)或钉板(nailboard)的渲染原语。因此，纹理图像是一个RGB图像，每个像素增加一个∆参数，形成一个RGB∆纹理。∆存储从深度精灵矩形到深度精灵所代表的正确几何深度的偏差。这个∆通道是视野空间中的一个高场。因为深度精灵包含深度信息，所以它们优于视点替用特效，因为它们可以更好地与周围的对象合并。当深度精灵矩形穿透附近的几何图形时，这一点尤其明显。这种情况如下图所示。像素着色器能够通过改变每个像素的z深度来执行这个算法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021131307.png" class="" title="image-20211021131307">

<p>左上方的图像显示了一个简单的几何渲染场景。右上方的图像显示了当为立方体、圆柱体和圆锥体创建并使用视点替用特效时会发生什么。下图显示了使用深度精灵时的结果。左边图像中的深度精灵使用2位的深度偏差，而右边图像中的深度精灵使用8位的深度偏差。(图片由Gernot Schaufler提供)</p>
<p><strong>Shade等人也描述了一个深度精灵原语，他们使用扭曲来解释新的视点。他们引入了一种叫做分层深度图像的原语，每个像素有几个深度。多重深度的原因是为了避免由于解除遮挡而产生的间隙。在翘曲过程中，隐藏区域变得可见)。Schaufler和Meyer and Neyret也提出了相关技术。为了控制采样率，Chang等人提出了一种称为LDI树的层次表示。</strong></p>
<p><strong>与深度精灵相关的是Oliveira等人引入的浮雕纹理映射。浮雕纹理是一幅具有高度场的图像，它代表了表面的真实位置。与深度精灵不同，图像不是呈现在广告牌上，而是面向世界空间中的一个四边形。对象可以通过一组匹配接缝的浮雕纹理来定义。使用GPU，高度场可以映射到表面上，射线行进可以用来渲染它们，如第6.8.1节所述。浮雕纹理映射也类似于一种称为栅格化包围体层次的技术。</strong></p>
<p><strong>Policarpo和Oliveira在一个单独的四边形上使用一组纹理来保持高度场，并且每个纹理都是依次渲染的。简单类推，在注塑机中形成的任何物体都可以通过两个高度场来形成。每个高度场代表模具的一半。更精细的模型可以通过附加的高度场重建。给定一个模型的特定视图，所需的高度场数量等于任何像素重叠的最大表面数量。像球形广告牌一样，每个底层四边形的主要目的是通过像素着色器来评估高度场纹理。这种方法也可以用来创建复杂的几何细节的表面;参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021131505.png" class="" title="image-20211021131505">

<p>编织表面模型通过应用四个高度场纹理的表面，并使用浮雕映射渲染。(图片由Fabio Policarpo和Manuel M. Oliveira提供)</p>
<p><strong>Beacco等人在人群场景中使用浮雕视点替用。在这种表示中，生成了模型的颜色、法线和高度场纹理，并与盒子的每个面相关联。当一个人脸被渲染时，光线前进被执行以找到每个像素可见的表面，如果有的话。一个盒子与模型的每个刚性部分(“骨骼”)相关联，这样就可以执行动画了。在假设角色离得很远的情况下，剥皮不会完成。纹理提供了一种简单的方法来降低原始模型的细节级别。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021131628.png" class="" title="image-20211021131628">

<p>Relief impostor。角色的表面模型被划分为多个框，然后用于为每个框的面创建高度场、颜色和普通纹理。模型使用地形映射进行渲染。(图片由Alejandro Beacco提供，版权c 2016 John Wiley &amp; Sons, Ltd.。)</p>
<p><strong>Gu等介绍了几何图像。这个想法是将一个不规则的网格转换成一个保持位置值的方形图像。图像本身代表一个常规的网格,即形成的三角形是从网格位置隐式的。也就是说，图像中的四个相邻像素构成两个三角形。形成这一形象的过程是困难的，而且相当复杂;这里我们感兴趣的是编码模型的结果图像。图像可以用来生成网格。其主要特点是几何图像可以被映射。不同层次的mipmap金字塔形成了模型的简单版本。这种模糊的线之间的顶点和texel数据，网格和图像，是一个迷人和诱人的方式来思考建模。几何图像也被用于具有特征保留地图的地形，以建立悬架模型。</strong></p>
<p><strong>在本章的这一点上，我们留下了用图像表示整个多边形对象，因为讨论转移到在粒子系统和点云中使用断开的、单独的样本。</strong></p>
<h2 id="Particle-Systems-粒子系统"><a href="#Particle-Systems-粒子系统" class="headerlink" title="Particle Systems 粒子系统"></a>Particle Systems 粒子系统</h2><p><strong>粒子系统是使用某种算法设置运动的独立小物体的集合。应用包括模拟火、烟、爆炸、水流、旋转星系和其他现象。因此，粒子系统控制动画和渲染。用于在粒子生存期内创建、移动、更改和删除粒子的控件是系统的一部分。</strong></p>
<p><strong>与本章相关的是这些粒子建模和渲染的方式。每个粒子可以是单个像素或从粒子先前位置到当前位置的线段，但通常由广告牌表示。如13.6.2节所述，如果粒子是圆的，那么向上矢量与它的显示无关。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021131951.png" class="" title="image-20211021131951">

<p>粒子系统:一个烟雾模拟(左)，流体(中)，和流星路径对抗星系天空盒(右)。(WebGL节目包括关颖珊的《精神》、李大卫的《流体粒子》和伊恩·韦伯斯特的《南三角洲宝瓶座流星雨》。)</p>
<p><strong>换句话说，所需要的只是粒子的位置来确定它的方向。上图给出了一些粒子系统的例子。每个粒子的广告牌可以通过调用几何着色器生成，但在实践中使用顶点着色器生成精灵可能更快。除了表示粒子的图像纹理外，还可以包含其他纹理，如法线贴图。轴向广告牌可以显示较粗的线条。参见609页的图14.18，以获得使用线段的雨的示例。</strong></p>
<p><strong>如果用半透明的广告牌颗粒来表示烟雾等现象，那么就必须解决正确渲染透明物体的挑战。前后排序可能是需要的，但可能很昂贵。Ericson提供了一长组有效渲染粒子的建议;我们在这里列出了一些，以及相关文章:</strong></p>
<pre><code>**•从厚的切割纹理制作烟雾;避免半透明意味着不需要分类和混合。** 

**•如果需要半透明，考虑添加或减法混合，不需要分类。**

**•使用一些动画粒子可以提供类似的质量和更好的性能比许多静态粒子。**

**•为了保持帧率，对渲染的粒子数量使用一个动态上限值。**

**•让不同的粒子系统使用相同的着色器，以避免状态更改成本(章节18.4.2)。**

**•包含所有粒子图像的纹理图集或数组可以避免调用纹理更改。**

**•平滑地绘制变化的粒子，如烟雾到一个低分辨率的缓冲区并合并，或在MSAA解析后绘制。** 
</code></pre>
<p><strong>Tatarchuk等人进一步提出了最后一种观点。他们将烟雾渲染到一个相当小的缓冲区，大小为十六分之一，并使用一个方差深度图来帮助计算粒子效果的累积分布函数。详情请参阅他们的演讲。</strong></p>
<p><strong>如果有大量的粒子，一个完整的排序可能会很昂贵。美术指导可以指示渲染顺序，以正确地分层不同的效果，从而改善问题。对于小的或低对比度的粒子，可能没有必要进行分类。粒子有时也可以以某种排序的顺序释放出来。如果粒子相当透明，则可以使用不需要排序的加权混合透明度技术。更复杂的独立于订单的透明系统也是可能的。例如，K¨ohler将渲染粒子描绘成一个九层深的缓冲区，存储在一个纹理数组中，然后使用一个计算着色器来执行排序。</strong></p>
<h3 id="Shading-Particles-粒子着色"><a href="#Shading-Particles-粒子着色" class="headerlink" title="Shading Particles 粒子着色"></a>Shading Particles 粒子着色</h3><p><strong>对于着色，它取决于粒子。像sparks这样的发射器不需要着色，为了简单起见经常使用添加剂混合。Green描述了如何将流体系统作为球形粒子渲染到深度图像中，随后的步骤是模糊深度，从中提取法线，并将结果与场景合并。像灰尘或烟雾这样的小颗粒可以使用每个基本值或每个顶点值来着色。然而，这样的光照可以使具有不同表面的粒子看起来平坦。为粒子提供一个法线贴图可以给适当的表面法线来照亮它们，但代价是额外的纹理访问。对于圆形粒子，在粒子的四个角上使用四条发散法线可能就足够了。烟雾粒子系统可以有更精细的光散射模型。辐射法向映射(第11.5.2节)或球谐也被用于照亮粒子。镶嵌可以用在更大的粒子上，使用域着色器在每个顶点上累积光照。</strong></p>
<p><strong>可以对每个顶点的光照进行评估，并在粒子四边形上进行插值。这是快速的，但对大粒子产生低质量，在那里的顶点远离可能错过小光的贡献。一种解决方案是在每像素的基础上对一个粒子进行着色处理，但分辨率要低于最终图像的分辨率。为此，每个可见粒子在光贴图纹理中分配一个贴图。每个贴图的分辨率可以根据屏幕上的颗粒大小进行调整，例如根据屏幕上的投影面积在1 × 1到32 × 32之间。一旦贴图被分配，粒子将为每个贴图渲染，并将像素的世界位置写入次级纹理中。然后分配一个计算着色器来评估到达从次级纹理读取的每个位置的亮度。如第20章所述，亮度是通过对场景中的光源取样来收集的，使用一个加速结构来评估可能产生影响的光源。由此产生的亮度可以以一种简单的颜色或球谐的形式写入到光贴图纹理中。当每个粒子最终呈现在屏幕上时，光照是通过在粒子四边形上映射每个贴图和使用纹理获取采样每个像素的亮度来应用的。</strong></p>
<p><strong>通过为每个发射器分配贴图，也可以应用相同的原则。在这种情况下，有一个深的光贴图纹理将有助于给照明与许多粒子的效果体积。值得注意的是，由于粒子的平面性质通常与观察者对齐，如果观察点旋转任何粒子发射器，在本节中呈现的每个照明模型都会产生可见的闪烁伪影。</strong></p>
<p><strong>与光照平行，粒子的体积阴影和自阴影的生成需要特别注意。为了接收来自其他遮挡器的阴影，小颗粒通常可以在阴影地图上测试它们的顶点，而不是每个像素。因为粒子是分散的点，被渲染成简单的面向相机的四边形，阴影投射到其他物体上不能使用光线通过阴影贴图来实现。但是，可以使用飞溅方法(第13.9节)。为了将来自太阳的阴影投射到其他场景元素上，粒子可以被分割成纹理，乘以每像素的透射率Tr = 1−α在缓冲区首先清除到1。纹理可以由一个用于灰度的通道或三个用于彩色透射的通道组成。这些纹理，在阴影级联层之后，通过将透射率与常规不透明阴影级联产生的可见性相乘应用到场景中，如7.4节所示。这种技术有效地提供了一个透明的单层阴影。这种技术的唯一缺点是，粒子会不正确地将阴影投射到粒子和太阳之间的不透明元素上。谨慎的关卡设计通常可以避免这种情况。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021132615.png" class="" title="image-20211021132615">

<p>粒子使用傅里叶不透明度映射投射体积阴影。在左边，傅里叶不透明度映射包含从一个聚光灯的角度来看的函数系数。在中间，粒子没有阴影渲染。在右侧，体积阴影投射在场景的粒子和其他不透明表面上。(图片由NVIDIA提供。)</p>
<p><strong>为了实现粒子的自阴影，必须使用更高级的技术，如傅立叶不透明度映射(FOM)。参见上图。粒子首先从光线的角度进行渲染，有效地将它们的贡献添加到透射函数中，表示为不透明度映射的傅里叶系数。当从这个角度渲染粒子时，可以通过从傅立叶系数中采样不透明度映射来重建透射率信号。这种表示法可以很好地表达平滑的透过率函数。然而，由于它使用有限系数的傅立叶基来维持纹理记忆要求，因此在透光率上有很大的变化。这可能导致渲染粒子四边形上不正确的亮或暗区域。FOM非常适合粒子，但也可以使用其他有不同优缺点的方法。这些包括自适应体积阴影地图部分中描述14.3.2(类似于深阴影地图),GPU优化粒子阴影地图(类似于不透明阴影地图,但仅限于camera-facing粒子,所以它不会工作丝带或motion-stretched粒子),和透过率函数映射(类似于FOM)。</strong></p>
<p><strong>另一种方法是在包含消光系数σt 的体积中对粒子进行体素化。这些卷可以被放置在相机周围，类似于剪贴图。该方法是一种统一评价体积鲱鱼的方法同时来自粒子和参与媒体的ows，因为它们都可以在这些公共体积中被体素化。生成一个存储Tr 的深阴影地图从这些“消光体积”中的每体素将自动导致从两个来源投射的体积阴影。产生的交互作用有很多:粒子和参与的媒体可以相互投射阴影，也可以投射自阴影;参见第613页的图14.21。结果质量与体素大小有关，为了实现实时性能，体素大小可能会很大。这将产生粗糙但视觉上柔和的体积阴影。有关更多细节，请参阅14.3.2节。</strong></p>
<h3 id="Particle-Simulation-粒子模拟"><a href="#Particle-Simulation-粒子模拟" class="headerlink" title="Particle Simulation 粒子模拟"></a>Particle Simulation 粒子模拟</h3><p><strong>使用粒子的有效和令人信服的物理过程近似是一个广泛的主题，超出了这本书的意图，所以我们将参考一些资源。GPU可以为精灵生成动画路径，甚至执行碰撞检测。流输出可以控制粒子的生死。这是通过将结果存储在一个顶点缓冲区中并在GPU上每帧更新这个缓冲区来实现的。如果无序访问视图缓冲区可用，粒子系统可以完全基于GPU，由顶点着色器控制。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021133245.png" class="" title="image-20211021133245">

<p>《命运2》中使用的粒子系统。(图片c 2017 Bungie, Inc.版权所有。)</p>
<p><strong>Van der Burg的文章和Latta的概述形成了对模拟基础的快速介绍。布莱德森关于计算机图形流体模拟的书深入讨论了理论，包括模拟各种形式的水、烟和火的物理基础技术。一些实践者提出了关于交互渲染器中的粒子系统的讨论。惠特利详细介绍了为命运号2开发的粒子系统。参见上图中的示例图像。Evans和Kirczenow从Bridson的文本中讨论了他们的流体流算法的实现。Mittring给出了关于粒子是如何存在的简要细节由Unreal Engine 4控制。Vainio深入研究了游戏《inFAMOUS Second Son》的粒子效果的设计和渲染。Wronski提出了一个有效生成和渲染雨水的系统。Gjøl和Svendsen讨论了烟雾和火灾效应，以及许多其他基于样品的技术。Thomas通过一个基于计算着色器的粒子模拟系统运行，该系统包括碰撞检测、透明排序和高效的基于瓦片的渲染。Xiao等人提出了一种交互式物理流体模拟器，该模拟器还可以计算用于显示的等值面。Skillman和Demoreuille通过他们的粒子系统和其他基于图像的效果来将游戏Br¨utal Legend的体积调到11。</strong></p>
<h2 id="Point-Rendering-点渲染"><a href="#Point-Rendering-点渲染" class="headerlink" title="Point Rendering 点渲染"></a>Point Rendering 点渲染</h2><p><strong>1985年，Levoy和Whitted写了一份开创性的技术报告，他们建议使用点作为一种新的原始元素来渲染一切。一般的想法是使用大量的点来表示一个表面，并渲染这些点。在随后的过程中，执行高斯滤波以填充渲染点之间的间隙。高斯滤波器的半径取决于表面上点的密度，以及屏幕上的投影密度。Levoy和Whitted在VAX-11/780上实现了这个系统。</strong></p>
<p><strong>然而，直到大约15年后，基于点的渲染才再次引起人们的兴趣。这一复兴的两个原因是计算能力的提高在这个水平上，基于点的渲染可以以交互速率实现，并且可以从激光测距扫描仪获得非常详细的模型。从那时起，各种用于探测距离的RGB-D(深度)设备开始出现，从用于地形测绘的空中激光雷达(光探测和测距)仪器，到微软Kinect传感器、iPhone TrueDepth相机和谷歌的Tango设备用于近程数据捕捉。自动驾驶汽车上的激光雷达系统每秒可以记录数百万个点。通过摄影测量或其他计算摄影技术处理的二维图像也用于提供数据集。这些不同技术的原始输出是一组带有附加数据的三维点，通常是强度或颜色。还可以提供其他分类数据，例如，一个点是来自建筑物还是路面。这些点云可以通过多种方式进行操作和渲染。</strong></p>
<p><strong>这些模型最初被表示为不相连的三维点。参见Berger等人对点云过滤技术和将其转化为网格的方法的深入概述。Kotfis和Cozzi提出了一种以交互速率处理、体素化和渲染这些体素化的方法。这里我们讨论直接渲染点云数据的技术。</strong></p>
<p><strong>QSplat是一个有影响力的基于点数的渲染器，首次发布于2000年。它使用球体的层次结构来表示模型。这个树中的节点被压缩，以允许渲染由数亿个点组成的场景。一个点被渲染为一个具有半径的形状，称为splat。可以使用的不同的splat形状有正方形、不透明圆和模糊圆。换句话说，splats是粒子，尽管渲染的目的是表示一个连续的表面。参见下图中的示例。渲染可以在树中的任何一层停止。该级别的节点被渲染为与节点球体半径相同的splats。因此，边界球层次结构是这样构造的，以便在任何级别上都不可见孔洞。由于遍历树可以在任何级别停止，因此可以通过在时间耗尽时停止遍历来获得交互帧率。当用户停止移动时，渲染的质量可以被反复优化，直到到达层次结构的叶子为止。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021133608.png" class="" title="image-20211021133608">

<p>这些模型使用基于点的渲染，使用圆形splats进行渲染。左边的图像显示了一个名叫露西的天使的完整模型，有1000万个顶点。然而，在渲染中只使用了大约300万个splats。中间和右边的图像放大了头部。中间的图像在渲染过程中使用了大约40000个splats。当观察者停止移动时，结果就会汇聚到右边显示的图像上，有60万个splats。(图片由QSplat程序由Szymon Rusinkiewicz生成。露西的模型是由斯坦福图形实验室创造的。)</p>
<p><strong>大约在同一时间，Pfister等人提出了surfer - 一个表面单元。它也是一个基于点的基元，用来表示物体表面的一部分，因此总是包含一个法线。一个八叉树(章节19.1.3)用于存储采样的sursurels:位置，法线，和过滤texels。在渲染过程中，surfels被投射到屏幕上，然后一个可见性飞溅算法被用来填充任何创建的洞。QSplat和surfels的论文确定并解决了点云系统的一些关键问题:管理数据集大小和从给定的点集绘制令人信服的表面。</strong></p>
<p><strong>QSplat使用一个层次结构，但它被细分到单点的层次，内部的父节点是包围球体，每个节点包含一个点，这是它的子节点的平均值。Gobbetti和Marton介绍了分层点云，这是一种分层结构，可以更好地映射到GPU，而不会创建人工的“平均”数据点。每个内部节点和子节点包含的内容大致相同数个点，称为n，在一个API调用中呈现为一个集合。我们通过从整个集合中取n个点来形成根节点，作为模型的粗略表示。选择一个点之间距离大致相同的集合比随机选择的结果更好。法线或颜色的差异也可以用于集群选择。其余的点在空间上划分为两个子节点。在每个节点上重复这个过程，选择n个有代表性的点，并将其余的分成两个子集。这种选择和细分一直持续到每个孩子有n个或更少的点。参见下图。Botsch等人的工作是目前最先进的一个很好的例子，它使用延迟着色(第20.1节)和高质量滤波的GPU加速技术。在展示期间,可见节点被加载和渲染，直到满足某些限制。节点的相对屏幕大小可用于确定加载点集的重要性，并可提供呈现的广告牌大小的估计。由于不为父节点引入新的点，内存使用量与存储的点的数量成正比。这种方案的一个缺点是，当放大单个子节点时，所有父节点都必须通过管线发送，即使每个节点中只有几个点可见。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021133832.png" class="" title="image-20211021133832">

<p>分层的点云。在左侧，根节点包含从子节点数据中提取的稀疏子集。接下来将显示一个子节点，然后与根节点中的点组合显示，说明子节点的区域是如何填充的。最右边是完整的点云、根和所有子节点。(图片来自Potree文档，开源软件，potree.org。Figure after Adorjan .)</p>
<p><strong>在目前的点云绘制系统中，数据集可能是巨大的，由数千亿个点组成。因为这些集合不能完全加载到内存中，更不用说以交互速率显示了，所以几乎每个点云渲染系统都使用了层次结构来加载和显示。使用的方案可能会受到数据的影响，例如，四叉树通常比八叉树更适合地形。对于点云数据结构的高效创建和遍历已经有了相当多的研究。Scheiblauer概述了这一领域的研究，以及表面重建技术和其他算法。Ador- jan给出了几个系统的概述，重点是分享由摄影测量生成的建筑点云。</strong></p>
<p><strong>理论上，splats可以提供单独的法线和半径来定义一个表面。在实践中，这样的数据占用了太多的内存，并且只有在经过大量的预处理之后才可用，所以通常使用固定半径的广告牌。由于分类和混合的成本，正确渲染半透明的广告牌点可能是昂贵的和人工负载。不透明的广告牌——正方形或镂空的圆圈——经常被用来保持交互性和质量。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021133948.png" class="" title="image-20211021133948">

<p>选择500万个点来渲染一个包含1.45亿个点的小镇数据集。通过检测深度差异增强边缘。在数据稀疏或广告牌半径过小的地方会出现间隙。下面一行显示的是图像预算分别为50万、100万和500万点时的选定区域。(使用Potree生成的图片，开源软件potree.org。奥地利Retz模型，RIEGL提供，riegl.com)</p>
<p><strong>如果点没有法线，那么可以采用不同的技术来提供着色。一种基于图像的方法是计算某种形式的屏幕空间环境遮挡(第11.3.6节)。通常情况下，所有的点首先被渲染到深度缓冲区中，具有足够宽的半径来形成一个连续的表面。在随后的渲染过程中，每一个点的着色都与靠近观察者的邻近像素的数量成比例地变暗。眼球圆顶照明(EDL)可以进一步强调表面细节。EDL的工作原理是检查相邻像素的屏幕深度，并找到那些比当前像素更接近观众的像素。对于每个这样的邻居，计算与当前像素的深度差并相加。这些差异的平均值，被否定，然后乘以一个强度因子，用作指数函数exp的输入。见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021134131.png" class="" title="image-20211021134131">

<p>在左边，点与法线在一次通过渲染。中间是一个没有法线的点云的屏幕空间环境遮挡渲染;右边是圆顶灯。最后两个方法都需要首先执行一个步骤来建立图像中的深度。(使用CloudCompare、GPL软件、cloudcompare.org生成的图像。足迹模型由Eugene Liscio提供。)</p>
<p><strong>如果每个点都有一个颜色或亮度，那么照明已经在里面了，所以可以直接显示出来，尽管有光泽或反光的物体不会对视图的变化做出反应。其他非图形属性，如对象类型或高度，也可以用于显示点。我们只涉及了管理和渲染点云的基础知识。Schuetz讨论了各种渲染技术，并提供了实现细节，以及一个高质量的开源系统。</strong></p>
<p><strong>点云数据可以与其他数据源相结合。例如，铯项目可以将点云与高分辨率地形、图像、矢量地图数据和摄影测量生成的模型结合起来。另一个scan-related科技-Nique是将环境从一个角度捕捉到一个天空盒中，保存颜色和深度信息，使场景捕捉具有物理存在。例如，用户可以添加合成模型到场景中，并使它们与这种类型的天空盒适当地合并，因为深度是可用的，周围图像中的每个点。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021134222.png" class="" title="image-20211021134222">

<p>在每个像素处具有可用深度的环境。对于一个固定的视图位置(但不是方向)，用户可以在世界空间位置和位置虚拟对象之间进行测量，并正确处理遮挡。(图片使用Autodesk ReCap Pro生成，Autodesk, Inc.提供)</p>
<p><strong>目前的技术已经有了相当大的进步，这些技术正在数据捕获和显示领域之外的领域得到应用。作为一个例子，我们简要总结了Evan为游戏Dreams提出的基于点数的渲染系统。每个模型由群集的包围体层次(BVH)表示，其中每个群集为256个点。这些点是由带符号的距离函数生成的(章节17.3)。对于细节级别的支持，将为每个细节级别生成单独的BVH、集群和点。为了从高细节过渡到低细节，高密度子集群中的点的数量随机地减少到25%，然后交换低细节的父集群。的Renderer基于一个计算着色器，它使用原子将点splicing to a framebuffer以避免碰撞。它实现了一些技术，如随机透明、景深(使用基于混乱圆的抖动板)、环境遮挡和不完美的阴影地图。为了平滑伪影，执行时间抗锯齿(第5.4.2节)。</strong></p>
<p><strong>点云代表空间中的任意位置，因此渲染起来很有挑战性，因为点之间的间隙通常不知道或不容易获得。Kobbelt和Botsch调查了这个问题和其他与点云相关的研究领域。为了结束这一章，我们转向一个非多边形表示法，其中样本与其相邻样本之间的距离总是相同的。</strong></p>
<h2 id="Voxels-体素"><a href="#Voxels-体素" class="headerlink" title="Voxels 体素"></a>Voxels 体素</h2><p><strong>正如像素是“图片元素”，像素是“纹理元素”，体素是“体积元素”。“每个体素代表一个统一的三维网格中的空间体积，通常是一个立方体。体素是存储体积数据的传统方法，可以表示从烟雾到3D打印模型，从骨骼扫描到地形表示的对象。可以存储单个位元，表示体素的中心是在对象内部还是外部。对于医疗应用，可能提供密度或不透明度，可能还提供容积流速。还可以存储颜色、法线、带符号的距离或其他值，以方便呈现。每个体素不需要位置信息，因为网格中的索引决定了它的位置。</strong></p>
<h3 id="Applications-应用程序"><a href="#Applications-应用程序" class="headerlink" title="Applications 应用程序"></a>Applications 应用程序</h3><p><strong>模型的体素表示可以用于许多不同的目的。一个规则的数据网格适合于所有与整个对象有关的操作，而不仅仅是它的表面。例如，由体素表示的物体的体积就是它内部体素的总和。网格的规则结构和体素定义良好的局部邻域意味着可以用元胞自动机或其他算法模拟烟雾、侵蚀或云形成等现象。有限元分析利用体素来确定物体的拉伸强度。雕刻或雕刻一个模型变成了减去体素的问题。相反，构建精细的模型可以通过将一个多边形模型放入体素网格并确定它重叠的体素来完成。与必须处理奇点和精度问题的更传统的多边形工作流相比，这种建设性的实体几何建模操作是高效的、可预测的，并且保证工作。OpenVDB和NVIDIA GVDB Voxels等基于体素的系统被用于电影制作、科学和医疗可视化、3D打印和其他应用。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021134600.png" class="" title="image-20211021134600">

<p>体素的应用程序。在左侧，流体模拟直接在稀疏体素网格上计算，并呈现为一个体积。在右侧，一个多边形兔子模型被体素化成一个带符号的距离场，然后用一个噪声函数扰动它，并绘制一个等值面。(左图由NVIDIA R提供，基于Wu等人的研究。右图使用NVIDIA R GVDB Voxels渲染，由NVIDIA公司提供。)</p>
<h3 id="Voxel-Storage-体素存储"><a href="#Voxel-Storage-体素存储" class="headerlink" title="Voxel Storage 体素存储"></a>Voxel Storage 体素存储</h3><p><strong>体素的存储有重要的内存需求，随着体素分辨率的O(n³)数据的增长。例如，每个维度分辨率为1000的体素网格会产生10亿个位置。《我的世界》等基于体素的游戏可以拥有巨大的世界。在这款游戏中，数据以每个16 × 16 × 256体素块的形式流进，并以每个玩家为半径。每个体素存储一个标识符和额外的方向或样式数据。每个块类型都有自己的多边形表示，无论是使用立方体显示的坚实的石头块，使用alpha纹理的半透明窗口，还是使用一对镂空广告牌表示的草地。参见第529页的图12.10和842页的图19.19提供示例。</strong></p>
<p><strong>存储在体素网格中的数据通常具有很大的相干性，因为相邻的位置可能具有相同或相似的值。根据数据源的不同，绝大多数网格可能是空的，这被称为稀疏卷。相干性和稀疏性都导致紧凑的表示。例如，一个八叉树(章节19.1.3)可以被施加到网格上。在最低的八叉树水平，每个2 × 2 × 2的体素样本可能都是相同的，这可以在八叉树和被丢弃的体素中被记录下来。可以在上面的树上检测相似度，并丢弃相同的子八叉树节点。只有在数据不同的地方才需要存储它们。这种稀疏体素八树(SVO)表示导致了自然水平的细节表示，相当于mipmap的三维体积。请参见下两图。Laine和Karras为SVO数据结构提供了丰富的实现细节和各种扩展。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021134841.png" class="" title="image-20211021134841">

<p>稀疏体素八叉树，二维形式。给定左侧的一组体素，我们注意到在树的上面哪个父节点有任何体素。右边是最后一个八叉树的可视化，显示了每个网格位置存储的最深的节点。(参见莱恩和卡拉斯)</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021134852.png" class="" title="image-20211021134852">

<p>不同细节层次的体素射线追踪。从左到右，包含模型的体素网格的每个边缘的分辨率分别为256、512和1024。(使用Optix和NVIDIA R GVDB Voxels渲染的图像，由NVIDIA公司提供。)</p>
<h3 id="Generation-of-Voxels-体素的生成"><a href="#Generation-of-Voxels-体素的生成" class="headerlink" title="Generation of Voxels 体素的生成"></a>Generation of Voxels 体素的生成</h3><p><strong>体素模型的输入可以来自多种来源。例如，许多扫描设备在任意位置生成数据点。GPU可以加速体素化，即将点云、多边形网格或其他表示转换为一组体素的过程。对于网格，Karabassi等人提出的一种快速但粗略的方法是从6个正投影视图渲染对象:顶部、底部和四个侧面。每个视图都生成一个深度缓冲区，所以每个像素都保存从那个方向第一个可见体素的位置。如果体素的位置超出了存储在6个缓冲区中的深度，那么它是不可见的，因此被标记为在对象内部。这种方法将错过任何在任何六个视图中看不到的特征，导致一些体素被不当地标记为内部。不过，对于简单的模型来说，这种方法已经足够了。</strong></p>
<p><strong>受视觉船体的启发，Loop等人使用一种更简单的系统来创建现实世界中的人的体素化。一组人的图像被捕获，轮廓被提取出来。每个剪影都被用来切割一组给定其摄像机位置的体素——只有你能看到的人的像素才会有与它们相关联的体素。</strong></p>
<p><strong>体素网格也可以从图像集合中创建，比如使用医学图像设备生成切片，然后将切片堆叠起来。沿着同样的路线，网格模型可以被逐片渲染，并且在模型中发现的体素被适当地记录下来。近平面和远平面被调整以绑定每个切片，检查其中的内容。Eisemann和D´ecoret引入了切片映射的概念，32位目标被认为是32个独立的深度，每个深度都有一个位标记。渲染到这个体素网格的三角形的深度被转换为它的位等值并存储。32层可以在渲染通道中渲染，如果使用更宽的通道图像格式和多个渲染目标，则可以使用更多的体素层。Forest等人给出了实现细节，指出在现代GPU上，一次通过最多可以渲染1024层。注意，这个切片算法只识别模型的表面，它的边界表示。上面的六视图算法也识别(虽然有时错误分类)体素完全在模型内部。下图是三种常见的体素化类型。Laine对术语、各种体素化类型以及生成和使用它们所涉及的问题进行了全面的处理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021135147.png" class="" title="image-20211021135147">

<p>一个球体以三种不同的方式体素化，并显示其横截面。左边是固体体素化，通过测试每个体素在球体上的中心来确定。在中间是一个保守的体素化，其中任何与球体表面接触的体素都被选中。这个表面被称为26分离体素化，其中内部体素在其3 × 3 × 3邻域内不与外部体素相邻。换句话说，内部体素和外部体素从不共享一个面、边或顶点。右边是6分离体素化，其中边缘和角可以在内部和外部体素之间共享。(图接Schwarz和Seidel)</p>
<p><strong>更有效的体素化可能与现代GPU提供的新功能。Schwarz和Seidel和Pantaleoni提出了体素化系统tems使用计算着色器，它提供了直接构建SVO的能力。Crassin和Green描述了他们用于规则网格体素化的开源系统，该系统利用了OpenGL 4.2中可用的图像加载/存储操作。这些操作允许对纹理存储器进行随机读写访问。通过使用保守的栅格化(章节23.1.2)来确定重叠体素的所有三角形，他们的算法有效地计算体素占用率，以及平均颜色和法线。他们也可以用这种方法创建SVO，从上到下构建，并在它们下降时只对非空节点进行体素化，然后使用自底向上的过滤mipmap创建来填充结构。Schwarz给出了栅格化和计算核体素化系统的实现细节，并解释了各自的特征。Rauwendaal和Bailey包含了他们的混合系统的源代码。它们提供了并行体素化方案的性能分析，以及如何正确使用保守栅格化以避免误报的细节。Takeshige讨论了MSAA如何成为保守光栅化的可行替代方案，如果少量的误差是可以接受的。Baert等提出了一种高效运行出核SVOs的算法，即无需整个模型驻留在内存中，就能对场景进行高精度体素化。</strong></p>
<p><strong>考虑到对场景进行体素化需要大量的处理，动态对象——那些移动或动画的对象——对基于体素的系统来说是一个挑战。Gai- tatzes和Papaioannou通过逐步更新他们对场景的体素表示来解决这个任务。他们使用场景相机的渲染结果和生成的任何阴影图来清除和设置体素。体素是针对深度缓冲区进行测试的，那些被发现比记录的z-深度更接近的将被清除。缓冲区中的深度位置随后被视为一组点并转换到世界空间。这些点对应的体素被确定和设置，如果之前没有标记。这个清晰和设置的过程是依赖于视图的，这意味着当前没有摄像机看到的场景部分实际上是未知的，因此可能是错误的来源。然而，这种快速的近似方法使得计算基于体素的全局光照效果在动态环境中以交互速率执行(章节11.5.6)。</strong></p>
<h3 id="Rendering-渲染"><a href="#Rendering-渲染" class="headerlink" title="Rendering 渲染"></a>Rendering 渲染</h3><p><strong>体素数据存储在一个三维数组中，它也可以被认为是，也确实是存储为一个三维纹理。这样的数据可以以多种方式显示。下一章将讨论可视化体素数据的方法，这些数据是半透明的，比如雾，或者放置切片机来检查数据集，比如超声图像。这里我们将专注于渲染表示实体对象的体素数据。</strong></p>
<p><strong>想象一下最简单的体积表示，每个体素包含一个标记，它是在物体内部还是外部。有几种常用的方法来显示这些数据。一种方法是直接用光线投射体积确定每个方块最近的击中面。另一种技术是将体素立方体转换为一组多边形。尽管使用网格渲染速度很快，但这在体素化过程中会产生额外的成本，最适合静态体积。如果每个体素的立方体显示为不透明的，那么我们可以剔除两个立方体相邻的任何面，因为它们之间的共享正方形是不可见的。这个过程留给我们一个正方形的外壳，里面是中空的。简化技术(第16.5节)可以进一步减少多边形数量。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021135705.png" class="" title="image-20211021135705">

<p>多维数据集扑杀。在左边，17074体素实心球体由102444个四元体素组成，每体素6个。在中间，相邻实体体素之间的两个四边形被删除，计数减少到4770。外观和左边一样，因为外壳没有动过。在右侧，一个快速贪婪算法将表面合并成更大的矩形，得到2100个四边形。(图片来自Mikola Lysenko的筛选程序。)</p>
<p><strong>对这组立方体面进行着色对于代表曲面的体素来说是没有说服力的。给立方体着色的一种常见的替代方法是使用行进立方体(marching cubes)等算法创建一个更平滑的网格表面。这个过程称为表面提取或多边形化(又称多边形化)。我们不把每个体素看作一个盒子，而是把它看作一个点样本。然后，我们可以用8个相邻的样品在2 × 2 × 2的模式中形成一个立方体，形成角落。这八个角的状态可以定义一个通过立方体的表面。例如，如果立方体的顶部四个角在外面，底部四个角在里面，那么用水平正方形将立方体分成两半是猜测表面形状的一个好方法。一个角在外面，其余的在里面，形成了一个三角形，由三个立方体边的中点连接到外面的角。参见下图。的过程把一组多维数据集的角落变成对应的多边形网格有效,八个角位可以被转换成一个索引从0到255,用于访问一个表指定的数量和位置每个可能的三角形配置。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021135859.png" class="" title="image-20211021135859">

<p>多维数据集。在左侧，四个底部角是物体内部的体素中心，因此在底部和顶部四个角之间形成了一个由两个三角形组成的水平正方形。在中间，一个角在外面，这样就形成了一个三角形。在右侧，如果有符号的距离值存储在角上，那么我们可以在每条边上插值三角形顶点为0.0。注意，共享一条给定边的其他立方体将在沿那条边的相同位置有一个顶点，以确保表面没有裂缝。</p>
<p><strong>其他渲染体素的方法，如水平集，更适合光滑、弯曲的表面。假设每个体素存储了到被表示物体表面的距离，一个正值表示内部，一个负值表示外部。我们可以利用这些数据来调整形成的网格的顶点位置，使其更准确地表示曲面，如上图中右侧所示。或者,我们可以直接射线追踪等值为零的水平集。这种技术称为水平集渲染。它特别擅长在没有任何附加体素属性的情况下表示曲面和曲线模型的法线。</strong></p>
<p><strong>表示密度差异的体素数据可以通过决定表面的形式以不同的方式可视化。例如，一些给定的密度可以很好地显示肾脏，另一个密度可以显示任何肾结石。选择密度值定义了等值面，等值面是一组具有相同值的位置。能够改变这个值对于科学可视化特别有用。射线直接追踪任何等值面值都是水平集射线追踪的推广，其中目标值始终为零。或者，可以提取等值面并将其转换为多边形模型。</strong></p>
<p><strong>2008年Olick做了一个很有影响力的演讲，讨论了如何通过光线投射直接渲染稀疏体素表示，启发了进一步的工作。针对正则体素测试射线非常适合GPU实现，并且可以在交互帧率下完成。许多研究人员已经探索了渲染的这一领域。首先介绍一下Crassin的博士论文和SIGGRAPH的介绍，这两篇论文涵盖了基于体素的方法的优点。Crassin利用了数据的类似mimap的特性，使用了锥体追踪。一般的想法是利用体素表示的规则性和良好定义的局部性来定义几何和阴影属性的预滤波方案，从而允许使用线性滤波器。一条光线被追踪到整个场景，但是它能够通过一个从它的起始点发出的锥体获得一个近似值。当射线在空间中移动时，它感兴趣的半径会增长，这意味着体素层级会在链的更高处采样，类似于mipmap在单个像素中有更多像素时采样的更高处。这种抽样方式可以快速计算例如，软阴影和景深，因为这些效果可以分解为锥跟踪问题。面积采样对其他处理也有价值，如反锯齿和适当过滤变化的表面法线。Heitz和Neyret描述了以前的工作，并提出了一种新的数据结构，用于提高锥跟踪的可见性计算结果。Kasyan使用体素锥跟踪区域灯光，讨论了误差来源。对比如下图所示。最后的结果请参见264页上的图7.33。圆锥跟踪用于计算全局照明效果将在第11.5.7节中讨论和说明。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021140038.png" class="" title="image-20211021140038">

<p>Cone-traced阴影。上图:在Maya中20秒内渲染的光线追踪球面区域光。下图:同一场景的体素化和锥跟踪耗时约20毫秒。模型用多边形渲染，体素化版本用于阴影计算。(图片由Crytek提供。)</p>
<p><strong>最近的趋势是在GPU上探索八叉树以外的结构。八叉树的一个关键缺点是，像射线跟踪这样的操作需要大量的树遍历跳，因此需要存储大量的中间节点。Hoet- zlein的研究表明，VDB树是一种网格层次结构，其GPU射线追踪可以比八元树获得显著的性能增益，并且更适合于体积数据的动态变化。Fogal等人证明了索引表，而不是八叉树，可以使用双通道方法实时绘制大量数据。第一步识别可见的子区域(砖)，以及来自磁盘的这些区域中的流。第二次传递呈现当前驻留在内存中的区域。Beyer等人对大规模体绘制进行了全面的研究。</strong></p>
<h3 id="Other-Topics-其他主题"><a href="#Other-Topics-其他主题" class="headerlink" title="Other Topics 其他主题"></a>Other Topics 其他主题</h3><p><strong>例如，表面提取通常用于可视化隐式表面(章节17.3)。有不同形式的基本算法和一些微妙的如何形成网格。例如，如果发现立方体的每个其他角都在里面，这些角应该在多边形网格中连接在一起，还是保持分离?参见de Ara´ujo等人的文章，了解隐式曲面的多边形化技术。Austin研究了各种一般多边形化方案的优缺点，发现立方体行进正方形具有最理想的特性。</strong></p>
<p><strong>当使用光线投射进行渲染时，除了完全多边形化之外，还有其他的解决方案。例如，Laine和Karras在每个接近表面的体素上附加一组平行平面，然后使用后处理模糊来掩盖体素之间的不连续。Heitz和Neyret以线性可过滤的表示法访问带符号的距离，这种表示法允许重建平面方程，并确定任意空间位置和分辨率在给定方向上的覆盖范围。</strong></p>
<p><strong>Eisemann和D´ecoret展示了体素表示如何用于执行深度阴影映射(章节7.8)，用于半透明重叠表面投射阴影的情况。正如K¨ampe, Sintorn等人所展示的，体素化场景的另一个优点是，相对于为每个光源生成一个阴影地图，所有光源的阴影射线都可以使用这一表示进行测试。与直接可见的表面绘制相比，眼睛更容易容忍次要效果中的小错误，如阴影和间接照明，这些任务需要的体素数据也少得多。当只跟踪一个体素占用时，许多稀疏体素节点之间可能存在极高的自相似性。例如，一堵墙会形成几层相同的体素集。这意味着树中的各个节点和整个子树都是相同的，因此我们可以为这些节点使用一个实例，并将它们存储在所谓的有向无环图中(章节19.1.5)。这样做通常会导致每个体素结构所需内存的大量减少。</strong></p>
<h1 id="14-Volumetric-and-Translucency-Rendering-体积和半透明渲染"><a href="#14-Volumetric-and-Translucency-Rendering-体积和半透明渲染" class="headerlink" title="14 Volumetric and Translucency Rendering 体积和半透明渲染"></a>14 Volumetric and Translucency Rendering 体积和半透明渲染</h1><p><strong>参与介质是用来描述充满粒子的体积的术语。顾名思义，它们是参与光传输的介质，换句话说，它们通过散射或吸收来影响通过它们的光。当渲染虚拟世界时，我们通常关注实体表面，简单而复杂。这些表面看起来是不透明的，因为它们是由光从稠密的粒子化介质(如介电介质或典型使用BRDF建模的金属)反射而定义的。密度较低的众所周知的介质是水、雾、蒸汽，甚至是空气，它们是由稀疏的分子组成的。根据介质的成分不同，介质与光的相互作用会有所不同——通过介质的光会被其粒子反射，这种现象通常被称为光散射。粒子的密度可以是均匀的，如空气或水的密度。或者它可能是不均匀的(不均匀的，随空间位置而变化)，就像云或蒸汽的情况一样。一些致密的材料通常呈现为固体表面，表现出高水平的光散射，如皮肤或蜡烛蜡。如第9.1节所示，漫射表面阴影模型是光在微观水平上散射的结果。一切都是散射。</strong></p>
<h2 id="Light-Scattering-Theory-光散射理论"><a href="#Light-Scattering-Theory-光散射理论" class="headerlink" title="Light Scattering Theory 光散射理论"></a>Light Scattering Theory 光散射理论</h2><p><strong>在本节中，我们将描述光在参与媒体中的模拟和渲染。这是对物理现象散射和吸收的定量处理，在9.1.1和9.1.2节中讨论过。在多重散射路径追踪的情况下，许多作者描述了辐射传输方程。在这里，我们将专注于单次散射，并建立一个关于它如何工作的良好直觉。单散射只考虑光的一次反弹构成参与媒体的粒子。多重散射跟踪每个光路的多次反射，因此要复杂得多。有和没有多次散射的结果可以在646页的图14.51中看到。用于表示散射方程中参与介质属性的符号和单位如下表所示。注意本章中的许多量，如σa,σs,σt,p,ρ,v和Tr 波长相关，这实际上意味着它们是RGB量。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022131125.png" class="" title="image-20211022131125">

<p>用于分散和参与媒体的符号。这些参数中的每一个都取决于波长(即波长)。， RGB)来实现对有色光的吸收或散射。相位函数的单位是反steradians(章节8.1.1)。</p>
<h3 id="Participating-Media-Material-参与媒介材质"><a href="#Participating-Media-Material-参与媒介材质" class="headerlink" title="Participating Media Material 参与媒介材质"></a>Participating Media Material 参与媒介材质</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022131614.png" class="" title="image-20211022131614">

<p>在参与的媒介中，不同的事件会沿一个方向d改变辐亮度。</p>
<p><strong>有四种类型的事件可以影响沿光线通过介质传播的亮度。如上图所示，并总结为:</strong></p>
<pre><code>**•吸收(函数σa)：光子被介质中的物质吸收，然后转化为热或其他形式的能量。**

**•向外散射(函数σs)：光子被介质物质中的粒子反弹而散射。这将根据描述光反射方向分布的相位函数p发生。**

**•发射：当介质达到高热时，例如火的黑体辐射，光就会被发射出来。关于排放的更多细节，请参考Fong等人的课程笔记。**

**•散射(函数σs)：光子从任何方向都可以散射到当前的光路径后反弹的粒子和贡献最后的光辉。从一个给定方向散射的光的数量也取决于该光方向的相位函数p。**
</code></pre>
<p><strong>综上所述，向路径添加光子是内散射σs 函数和发射。光子去除是消光函数σt =σa +σs，表示吸收和向外散射。如辐射传输方程所解释的一组系数表示位置x和朝向 v方向的辐射度相对于L(x, v)的导数。这就是为什么这些系数的值都在[0，+∞]范围内。详情见Fong等人的注释。散射和吸收系数决定了介质的反照率ρ，定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022132059.png" class="" title="image-20211022132059">

<p><strong>它表示了在考虑的每个可见光谱范围内介质中相对于吸收的散射的重要性，即媒介的整体反射性。ρ的值在[0,1]范围内。接近0的值表示大部分光线被吸收，导致介质浑浊，如深色的尾气烟雾。接近1的值表示大部分光线是散射的，而不是被吸收的，从而产生更明亮的介质，如空气、云或地球的大气层。</strong></p>
<p><strong>正如第9.1.2节所讨论的，介质的出现是它的散射和吸收特性的结合。已经测量并公布了真实参与媒体的系数值。例如，牛奶有很高的散射值，产生浑浊和不透明的外观。由于高反照率ρ &gt; 0.999，牛奶也呈现白色。另一方面，红葡萄酒的特点是几乎没有散射，而是高吸收，使其半透明和彩色的外观。参见下图中渲染的液体，并与301页图9.8中拍摄的液体进行对比。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022132209.png" class="" title="image-20211022132209">

<p>呈现的葡萄酒和牛奶，分别具有吸收和散射在不同的浓度。(图片由Narasimhan等人提供。)</p>
<p><strong>每个属性和事件都是波长相关的。这种依赖性意味着在给定的介质中，不同的光频率可能以不同的概率被吸收或散射。理论上，为了解释这一点，我们应该在渲染时使用光谱值。为了提高效率，在实时渲染中(也有一些例外在离线渲染中)我们使用RGB值。在可能的情况下，σa 和σs 应使用颜色匹配函数从光谱数据中预先计算(第8.1.3节)。</strong></p>
<p><strong>在前面的章节中，由于没有参与的介质，我们可以假设进入相机的辐亮度与离开最近表面的辐亮度相同。更确切地说，我们假设(在310页)Li(c, -v) = Lo(p, v)，其中c是摄像机位置，p是最近曲面与视图射线的交点，v是指向p到c的单位视图向量。</strong></p>
<p><strong>一旦引入了参与的媒体，这个假设就不再成立了，我们需要考虑沿视图射线的亮度变化。作为一个例子，我们将现在描述计算从准时光源散射光所涉及的计算。用一个无限小点表示的光源(第9.4节):</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022132444.png" class="" title="image-20211022132444">

<p><strong>其中Tr(c, x)为给定点x与摄像机位置c(章节14.1.2)和Lscat(x, v)之间的透射率是沿视场射线(章节14.1.3)上给定点x散射的光。计算的不同组成部分如下图所示，并在以下小节中进行解释。关于上式如何从辐射传递方程推导出来的更多细节可以在Fong等人的课程笔记中找到。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022132605.png" class="" title="image-20211022132605">

<p>点状光源的单次散射积分图解。沿视图射线的采样点显示为绿色，一个点的相位函数显示为红色，不透明表面S的BRDF显示为橙色。在这里,lc 是光中心的方向向量，plight 为光的位置，p为相位函数，v为能见度项。</p>
<h3 id="Transmittance-透光率"><a href="#Transmittance-透光率" class="headerlink" title="Transmittance 透光率"></a>Transmittance 透光率</h3><p><strong>透光率Tr 表示在一定距离内能够通过媒介的光的比率</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022132849.png" class="" title="image-20211022132849">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022133019.png" class="" title="image-20211022133019">

<p>透过率是深度的函数，σt =(0.5, 1.0, 2.0)。正如预期的那样，红色组分的消光系数越低，透射出的红色就越多。</p>
<p><strong>这种关系也被称为比尔-朗伯定律。光学深度τ无单位，表示光衰减量。消光或穿越距离越高，光学深度就越大，反过来，穿过介质的光就越少。当光学深度τ = 1时，约60%的光会被移除。例如，如果σt =(0.5, 1,2)，则通过深度d = 1米的光线为Tr = e^(−dσt)≈(0.61,0.37,0.14)。这种行为如上图所示。需要在(i)辐亮度Lo(p, v)上应用透射率来自不透明表面，(ii)辐射亮度Lscat(x, v)由内散射事件产生，以及(iii)从散射事件到光源的每条路径。从视觉上看，(i)将导致一些雾状的表面遮挡，(ii)将导致散射光遮挡，提供关于介质厚度的另一个视觉线索(见下下图)，(iii)将导致参与介质的体积自遮挡(见下图)。由于σt =σa +σs时，预期透过率同时受到吸收和向外散射分量的影响。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022133216.png" class="" title="image-20211022133216">

<p>由参与媒体制作的斯坦福兔子的体积阴影示例。左:无体积自阴影;中间:投影;右图:阴影投射到其他场景元素上。(模型由斯坦福计算机图形实验室提供。)</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022133227.png" class="" title="image-20211022133227">

<p>斯坦福龙与越来越多的媒体集中。从左到右:0.1、1.0、10.0，σs =(0.5、1.0、2.0)。(模型由斯坦福计算机图形实验室提供。)</p>
<h3 id="Scattering-Events-散射事件"><a href="#Scattering-Events-散射事件" class="headerlink" title="Scattering Events 散射事件"></a>Scattering Events 散射事件</h3><p><strong>对给定位置x场景中准时光源的散射积分从方向v可以做如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022133608.png" class="" title="image-20211022133608">

<p><strong>其中n为灯数，p()为相位函数，v()为能见度函数，lci是指向第i个光的方向向量，plighti是第i盏灯的位置。此外,clighti()是第i个光源的亮度作为其位置距离的函数，使用了第9.4节的定义和第5.2.2节的平方衰减反函数。可见性函数v(x, plighti)表示从光源plighti处到达位置x的光的比率</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022133753.png" class="" title="image-20211022133753">

<p><strong>其中volShad (x, plighti) = Tr (x,plighti)。在实时渲染中，阴影是由两种遮挡造成的:不透明遮挡和体积遮挡。不透明物体的阴影(shadowMap)传统上是通过使用阴影映射或第7章中的其他技术来计算的。</strong></p>
<p><strong>上式的体积阴影项volShad(x, plighti)表示光源位置plighti的透过率采样点x，其取值范围为[0,1]。由体积产生的遮挡是体积渲染的一个重要组成部分，其中体积元素可以自阴影或在其他场景元素上投射阴影。参见上上图。这种结果通常是通过从眼睛通过体积到第一个表面的主射线，然后沿着从每个样品到每个光源的次级射线路径来实现的。“光线行进”是指用n个样本对两点之间的路径进行采样，并对沿途的散射光和透射率进行积分。关于这种采样方法的更多细节，请参阅第6.8.1节，在这种情况下，它是用于渲染高度场的。光线行进与三维体相似，每条光线都是一步一步前进，并采样体材料或沿途的每一点照明。见图14.3，它显示了绿色的主射线和蓝色的次级阴影射线上的样本点。许多其他出版物也详细描述了射线行军。</strong></p>
<p><strong>O (n²)的复杂度，其中n是沿着每条路径的样本数量，射线快速前进将变得昂贵。作为质量和性能之间的权衡，特定的体积阴影表示技术可以用来存储传输从灯向外的方向。这些技术将在本章余下部分的适当章节中进行解释。</strong></p>
<p><strong>为了对介质中光散射和消光的行为有一些直观的认识，考虑σs =(0.5, 1,2)和σa =(0,0,0)。对于介质内的短光程，内散射事件将压倒消光，例如，在本例中，外散射事件，其中Tr 对于较小的深度≈1。该材料将显示蓝色，因为该通道的σs 值是最高的。光穿透介质越深，通过的光子就越少，这是由于消光造成的。在这种情况下，来自消光的透射色将开始占主导地位。这可以用σt =σs来解释,因为σa =(0,0,0)，因此，Tr = e^(−dσt)作为光学深度dσs的函数，将比散射光的线性积分下降得快得多使用方程14.2。对于这个例子，红光通道将较少受到消光通过介质，因为该通道的σt 价值是最低的，所以它将占主导地位。上图描述了这种行为，这正是在大气和天空中发生的事情。当太阳高的时候(例如，穿过大气层的短光，垂直于地面)，蓝色的光散射更多，使天空呈现出自然的蓝色。然而，当太阳在地平线上时，光线穿过大气层的路径很长，天空会显得更红，因为更多的红光被透射。这就产生了我们都知道的美丽的日出和日落过渡。有关大气物质组成的更多细节，请参阅14.4.1节。关于这种效果的另一个例子，请看299页图9.6右边的乳白色玻璃。</strong></p>
<h3 id="Phase-Functions-相位函数"><a href="#Phase-Functions-相位函数" class="headerlink" title="Phase Functions 相位函数"></a>Phase Functions 相位函数</h3><p><strong>参与的介质是由半径不同的粒子组成的。这些粒子的大小分布将影响光在特定方向散射的概率，相对于光的前进方向。这种行为背后的物理原理将在第9.1节中解释。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022134558.png" class="" title="image-20211022134558">

<p>图示相位函数(红色)及其对散射光的影响(绿色)作为θ的函数。</p>
<p><strong>在计算内散射时，使用相位函数在宏观水平上描述散射方向的概率和分布，如式14.4所示。如上图所示。红色的相位函数用参数θ表示，蓝色的是光的前进路径与绿色的v方向的夹角。注意这个相位函数例子中的两个主要的波瓣:一个在光路相反方向的小后向散射波瓣和一个大的前向散射波瓣。相机B处于大的前向散射波瓣方向，因此它接收到的散射辐亮度要比相机A大得多。在没有能量增益或损失的情况下，相位函数在单位球上的积分必须为1。</strong></p>
<p><strong>相位函数将根据到达该点的方向辐射信息改变该点的内散射。最简单的函数是各向同性的:光将均匀地向各个方向散射。这种完美但不现实的行为表现为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022134655.png" class="" title="image-20211022134655">

<p><strong>θ为入射光与向外散射方向的夹角，π为单位球的面积。</strong></p>
<p><strong>基于物理的相位函数依赖于相对大小sp</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022134704.png" class="" title="image-20211022134704">

<p><strong>其中r为粒子半径，λ为所考虑的波长:</strong></p>
<p><strong>•当sp ≪1，存在瑞利散射(如空气)。</strong></p>
<p><strong>•当sp ≈1，有米氏散射。</strong></p>
<p><strong>•当sp≫1，几何散射。</strong></p>
<h4 id="Rayleigh-Scattering-瑞利散射"><a href="#Rayleigh-Scattering-瑞利散射" class="headerlink" title="Rayleigh Scattering 瑞利散射"></a>Rayleigh Scattering 瑞利散射</h4><p><strong>瑞利勋爵(1842-1919)导出了光从空气分子散射的术语。在其他应用中，这些表达式被用来描述光在地球大气层中的散射。如图所示，这个相位函数有两个瓣在上图中，称为前后散射，相对于光的方向。这个函数在θ处计算，是入射光和向外散射方向的夹角。函数是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022135220.png" class="" title="image-20211022135220">

<p><strong>瑞利散射与波长高度相关。当把散射系数看成光波长λ的函数时，散射系数σs 因为瑞利散射与波长的四次方反比成正比:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022135249.png" class="" title="image-20211022135249">

<p><strong>这种关系意味着，短波长的蓝光或紫光比长波长的红光更容易散射。由上式得到的光谱分布可通过光谱颜色匹配函数(章节8.1.3)转换为RGB: σs =(0.490, 1.017, 2.339)。这个值被归一化为亮度1，并应根据所需的散射强度进行缩放。蓝光在大气中散射较多所产生的视觉效果，见14.4.1节。</strong></p>
<h4 id="Mie-Scattering-米氏散射"><a href="#Mie-Scattering-米氏散射" class="headerlink" title="Mie Scattering 米氏散射"></a>Mie Scattering 米氏散射</h4><p><strong>米氏散射是一个模型，当粒子的大小与光的波长大致相同时可以使用。这种类型的散射与波长无关。MiePlot软件可以用来模拟这一现象。米氏阶段对于特定粒径的函数通常是一个具有强烈而尖锐的方向性叶状的复杂分布，即表示在相对于光子旅行方向的特定方向上散射光子的高概率。为体积着色计算这样的相位函数是昂贵的，但幸运的是它很少需要。典型的介质具有颗粒尺寸的连续分布。对所有这些不同尺寸的Mie相函数进行平均，可以得到整个介质的平滑平均相函数。因此，可以用相对光滑的相位函数来表示米氏散射。</strong></p>
<p><strong>常用的一种相函数是Henyey-Greenstein (HG)相函数，它最初被用来模拟星际尘埃中的光散射。这个函数不能捕获每个真实世界散射行为的复杂性，但它可以很好地匹配代表一个相位函数瓣，即朝着主要的分散方向。它可以用来表示任何烟、雾或粉尘样的参与媒体。这种介质可以表现出强烈的向后或向前散射，导致光源周围出现大的视觉晕。例子包括雾中的聚光灯和在太阳方向的云的边缘有强烈的银衬效果。</strong></p>
<p><strong>HG相函数可以代表比瑞利散射更复杂的行为，并使用</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022135715.png" class="" title="image-20211022135715">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022135821.png" class="" title="image-20211022135821">

<p>。Henyey-Greenstein(蓝色)和Schlick近似(红色)相作为θ函数的极坐标图。光线从左边水平射入。参数g从0增加到0.3和0.6，导致在右侧有一个强烈的波瓣，这意味着光将沿着其前进的路径从左到右散射更多。</p>
<p><strong>它可以产生不同的形状，如上图所示。g参数可以用来表示后向(g &lt; 0)、各向同性(g = 0)或前向(g &gt; 0)散射，g在[-1,1]中。使用HG相函数的散射结果示例如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022135839.png" class="" title="image-20211022135839">

<p>参与媒体Stanford兔显示HG相功能影响，与g从各向同性到强正向散射。从左到右:g = 0.0, 0.5, 0.9, 0.99，和0.999。最下面一行使用了十倍密集的参与媒体。(模型由斯坦福计算机图形实验室提供。)</p>
<p><strong>获得与Henyey-Greenstein相函数相似结果的一种更快的方法是使用Blasi等人提出的近似方法第三作者作为Schlick阶段函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022140008.png" class="" title="image-20211022140008">

<p><strong>它不包括任何复杂的幂函数，而只是一个平方，这是更快的计算。为了将该函数映射到原始HG相函数，需要从g中计算k参数。对于具有恒定g值的参与介质，只需执行一次。在实际应用中，Schlick相位函数是一个很好的能量守恒近似，如上上图所示。</strong></p>
<p><strong>也可以混合多个HG或Schlick相函数，以表示更复杂的一般相函数范围。这使我们能够同时表示具有强前向散射和后向散射叶的相位函数，类似于云的行为，如14.4.2节所描述和说明的。</strong></p>
<h4 id="Geometric-Scattering-几何散射"><a href="#Geometric-Scattering-几何散射" class="headerlink" title="Geometric Scattering 几何散射"></a>Geometric Scattering 几何散射</h4><p><strong>几何散射发生在粒子明显大于光的波长的时候。在这种情况下，光可以在每个粒子内折射和反射。这种行为可能需要一个复杂的散射相位函数来在宏观层面上模拟它。光的偏振也会影响这种类型的散射。例如，一个真实的例子是视觉彩虹效应。它是由光线在空气中的水粒子内部的反射引起的，在一个小的视角(3度)上将太阳光散射成可见光谱。这种复杂的相位函数可以使用MiePlot软件进行模拟。第14.4.2节描述了这样一个相位函数的例子。</strong></p>
<h2 id="Specialized-Volumetric-Rendering-专业的体积渲染"><a href="#Specialized-Volumetric-Rendering-专业的体积渲染" class="headerlink" title="Specialized Volumetric Rendering 专业的体积渲染"></a>Specialized Volumetric Rendering 专业的体积渲染</h2><p><strong>本节以基本的、有限的方式介绍渲染体积效果的算法。有些人甚至会说，这些都是老掉牙的把戏，往往依赖于临时模型。它们被使用的原因是它们仍然工作得很好。</strong></p>
<h3 id="Large-Scale-Fog-大规模的雾"><a href="#Large-Scale-Fog-大规模的雾" class="headerlink" title="Large-Scale Fog 大规模的雾"></a>Large-Scale Fog 大规模的雾</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022140844.png" class="" title="image-20211022140844">

<p>雾过去常加重一种情绪。(图片由英伟达公司提供。)</p>
<p><strong>雾可以近似为基于深度的效果。它最基本的形式是根据与相机的距离在场景顶部的雾颜色的alpha混合，通常称为深度雾。这种效果对观众来说是一个视觉提示。首先，它可以提高现实主义和戏剧性的水平，如上图所示。其次，它是一个重要的深度线索，帮助场景的观众确定物体的位置。参见下图。第三，它可以用作遮挡剔除的一种形式。如果对象在距离太远时被雾完全遮挡，那么可以安全地跳过它们的渲染，从而提高应用程序的性能。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022140936.png" class="" title="image-20211022140936">

<p>在这张来自DICE游戏《战地1》的关卡图片中使用了雾，以揭示游戏玩法区域的复杂性。深度雾被用来揭示景物的大尺度性质。从右边的地面上可以看到高空雾，大量的建筑物拔地而起从山谷。(由DICE提供，2018年Electronic Arts Inc.)</p>
<p><strong>表示雾量的一种方法是用[0,1]中的f表示透射率，即f = 0.1表示10%的背景表面是可见的。假设曲面的输入颜色是ci 雾的颜色是cf ，则最后的颜色c由</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022141145.png" class="" title="image-20211022141145">

<p><strong>f的值可以用许多不同的方法计算。使用时雾可线性增加</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022141155.png" class="" title="image-20211022141155">

<p><strong>其中zstart 和zend 是用户参数，决定雾在哪里开始和结束(即变得完全雾蒙蒙)，zs 是从观察者到要计算雾的表面的线性深度。计算雾透过率的一种物理上准确的方法是使雾透过率随距离呈指数增长，从而遵循比尔-朗伯定律(第14.1.2节)。这种效果可以通过使用</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022141243.png" class="" title="image-20211022141243">

<p><strong>其中标量df 是控制雾密度的用户参数。这种传统的大尺度雾是对大气中光散射和吸收的粗略模拟(第14.4.1节)，但它仍然被用于今天的游戏中。参见上图。</strong></p>
<p><strong>这就是硬件雾如何暴露在遗留的OpenGL和DirectX API。对于硬件(如移动设备)上更简单的用例，考虑使用这些模型仍然是值得的。许多当前的游戏依赖于更高级的后期处理，如雾和光散射的大气效果。透视图中的雾的一个问题是深度缓冲值是用非线性方式计算的(第23.7节)。可以将非线性深度缓冲值转换回线性深度zs 使用逆投影矩阵数学。雾可以使用像素着色器作为全屏通道，从而实现更高级的结果，如高度依赖雾或水下着色。</strong></p>
<p><strong>高度雾代表一个单一板的参与媒体与参数化的高度和厚度。对于屏幕上的每个像素，密度和散射光被评估为视图射线在撞击表面之前穿过平板的距离的函数。Wenzel提出了一个封闭形式的解，该解对平板内参与介质的指数衰减进行f评估。这样做的结果是一个平滑的雾过渡附近的板的边缘。这在上图左侧的背景雾中可见。</strong></p>
<p><strong>雾的深度和高度可能有许多变化。cf 的颜色可以是单一的颜色，可以从使用视图向量采样的立方体地图读取，甚至可以是复杂的大气散射的结果，使用逐像素相位函数应用于方向颜色变化。也可以结合depth fd 和高度fh 雾透过率使用f = fdfh 并在一个场景中把两种类型的雾交织在一起。</strong></p>
<p><strong>深度雾和高度雾是大规模的雾效应。人们可能想要渲染更多的局部现象，如分离的雾区域，例如，在洞穴或墓地的几个坟墓周围。椭球或盒子等形状可以用于在需要的地方添加局部雾。这些雾元素使用它们的边界框从后到前渲染。前面的df 和db 在像素着色器中评估每个形状的视图向量的交集。使用容积深度d = max(0, min(zs,db)−df ),如果线性深度zs 代表最近的不透明表面，就有可能计算透射率Tr (第14.1.2节)，覆盖率为α = 1.0−Tr．散射光的量cf 加在上面可以被计算为αcf ．为了从网格中评估更多不同的形状，Oat和Scheuermann给出了一种聪明的单通道方法，计算体积中最近的入口点和最远的出口点。它们节省了表面距离ds，在一个通道的表面，并且1-ds 在另一个频道。通过设置alpha混合模式来保存找到的最小值，在渲染后，第一个通道的值df 最接近第二个通道的db值最大，编码为一维，允许恢复d。</strong></p>
<p><strong>水是一个参与的媒介，因此，展示了相同类型的基于深度的颜色衰减。沿岸水的透光率约为(0.3,0.73,0.63)/ m[261]，因此利用公式14.23可以得到σt =(1.2, 0.31, 0.46)。当使用不透明的表面渲染深色水时，当相机在水面以下时，可以启用雾逻辑，当相机在水面以上时，可以关闭雾逻辑。Wenzel提出了一个更先进的解决方案。如果相机在水下，散射和透光率是综合的，直到固体或水面被击中。如果在水面上，这些积分仅从水面到海床的固体几何形状之间的距离。</strong></p>
<h3 id="Simple-Volumetric-Lighting-简单的体积照明"><a href="#Simple-Volumetric-Lighting-简单的体积照明" class="headerlink" title="Simple Volumetric Lighting 简单的体积照明"></a>Simple Volumetric Lighting 简单的体积照明</h3><p><strong>光散射在参与媒体可能是复杂的评估。值得庆幸的是，在许多情况下，有许多有效的技术可以用来近似这种散射。</strong></p>
<p><strong>获得体积效果的最简单方法是在framebuffer上渲染混合的透明网格。我们将其称为飞溅方法(第13.9节)。要渲染穿过窗户，穿过茂密的森林，或来自聚光灯的光轴，一个解决方案是使用相机对齐的粒子，每个纹理。每个纹理四边形都沿着光轴的方向伸展，同时始终面对着摄像机(圆柱体约束)。</strong></p>
<p><strong>网格飞溅方法的缺点是，积累许多透明网格将增加所需的内存带宽，很可能导致瓶颈，并且面向摄像头的纹理四边形有时可以看到。为了解决这个问题，人们提出了使用闭形式解决光单散射的后处理技术。假设一个均匀的和球形的均匀相位函数，它是可能的积分散射光与正确的透过率沿路径假设一个恒定的介质。结果如下图所示。GLSL着色器代码片段显示了这种技术的一个实现示例:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022142146.png" class="" title="image-20211022142146">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022142022.png" class="" title="image-20211022142022">

<p>使用上面代码片段中的分析集成评估光源的体积光散射。它可以作为一个后期效果，假设均匀介质(左)或粒子，假设它们每个都是一个有深度的体积(右)。(图片由Miles提供<br>Macklin)。</p>
<p><strong>其中rayStart是射线的起始位置，rayDir是射线的归一化方向，rayDistance是沿光线的积分距离，lightPos是光源的位置。Sun等人的解还考虑了散射系数σs．它还描述了漫反射和镜面辐射在朗伯和冯氏表面的反弹应该受到光在击中任何表面之前在非直线路径中散射的影响。为了考虑透过率和相位函数，可以使用更重ALU的溶液[。所有这些模型在它们所做的事情上都是有效的，但不能考虑来自深度地图或异构参与媒体的阴影。</strong></p>
<p><strong>通过一种称为bloom的技术，可以近似地计算屏幕空间中的光散射。模糊framebuffer并将它的一小部分添加到上，会使每个明亮的对象在它周围散发出光辉。这种技术通常用于近似相机镜头中的缺陷，但在某些环境中，它是一种近似值，适用于短距离和无遮挡散射。第12.3节更详细地描述了bloom。</strong></p>
<p><strong>Dobashi等人提出了一种使用一系列平面对体积采样来绘制大尺度大气效应的方法。这些平面垂直于视图方向，并从后到前渲染。Mitchell也提出了相同的方法来渲染聚光灯轴，使用阴影贴图来投射不透明物体的体积阴影。在14.3.1节中详细描述了通过飞溅切片绘制体积的方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022142544.png" class="" title="image-20211022142544">

<p>使用屏幕空间后期处理渲染的光轴。(图片由Kenny Mitchell提供。)</p>
<p><strong>Mitchell和Rohleder and Jamrozik提出了一种在屏幕空间工作的替代方法;参见上图。它可以用来渲染来自遥远光线(如太阳)的光轴。首先，一个伪明亮物体在远平面的太阳周围渲染为一个清除为黑色的缓冲区，并使用深度缓冲区测试接受非闭塞像素。其次，在图像上应用方向模糊，以泄漏之前积累的太阳辐射向外。可以使用可分离的滤波技术(章节12.1)，通过两个通道，每个使用n个样本，得到与n²相同的模糊结果样本，但渲染速度更快。最后，可以将最后的模糊缓冲添加到场景缓冲中。这项技术是有效的，尽管缺点是只有在屏幕上可见的光源才能投射光轴，但它以很小的成本提供了显著的视觉效果。</strong></p>
<h2 id="General-Volumetric-Rendering-普通的体积渲染"><a href="#General-Volumetric-Rendering-普通的体积渲染" class="headerlink" title="General Volumetric Rendering 普通的体积渲染"></a>General Volumetric Rendering 普通的体积渲染</h2><p><strong>在本节中，我们将介绍更多基于物理的体绘制技术，例如试图表现介质的材料及其与光源的相互作用(第14.1.1节)。一般的体绘制涉及到空间变化的参与媒体，通常使用体素(第13.10节)表示，体光相互作用导致视觉上复杂的散射和遮蔽现象。一个通用的体积渲染解决方案还必须考虑到体积与其他场景元素的正确组成，如不透明或透明表面。不同空间的媒体属性可能是烟雾和火灾模拟的结果，需要在游戏环境中渲染，以及体光和阴影的交互作用。另外，我们可能希望将固体材料表示为半透明体，用于医学可视化等应用。</strong></p>
<h3 id="Volume-Data-Visualization-体积数据可视化"><a href="#Volume-Data-Visualization-体积数据可视化" class="headerlink" title="Volume Data Visualization 体积数据可视化"></a>Volume Data Visualization 体积数据可视化</h3><p><strong>体积数据可视化是一种用于显示和分析体积数据的工具，通常是标量字段。计算机断层扫描(CT)和磁共振成像(MRI)技术可以用来创建临床诊断图像的内部身体结构。一个数据集可以是，比如说，256³ 体素，每个位置保存一个或多个值。这些体素数据可以用来形成三维图像。体素渲染可以显示一个实体模型，或使各种材料(如皮肤和头骨)呈现部分或完全透明。切割面可以用来只显示源数据的一个子卷或部分。除了在医学和石油勘探等不同领域的可视化使用，体积绘制还可以产生逼真的图像。</strong></p>
<p><strong>有许多体素绘制技术。在复杂的照明环境下，可以使用常规路径跟踪或光子映射来可视化体积数据。为了实现实时性能，已经提出了几种成本较低的方法。</strong></p>
<p><strong>对于实体对象，隐式曲面技术可用于将体素转换为多边形曲面，如17.3节所述。对于半透明现象，体积数据集可以通过一组垂直于视图方向的分层等间距切片进行采样。下图显示了其工作原理。也可以用这种方法渲染不透明的表面[797]。在这种情况下，当密度大于某一给定阈值时，考虑固体体积存在，法向n可被计算为密度场的三维梯度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023123528.png" class="" title="image-20211023123528">

<p>一个体块是由一系列平行于视图面的切片来渲染的。一些切片和它们与体积的交集显示在左边。中间显示渲染的结果这片。右边显示的是大量切片被渲染和混合后的结果。(数据由德国Siegen大学Christof Rezk-Salama提供。)</p>
<p><strong>对于半透明数据，可以存储每个体素的颜色和不透明度。为了减少内存占用并使用户能够控制可视化，已经提出了传递函数。第一个解决方案是使用一维传输纹理将体素密度标量映射到颜色和不透明度。然而，这并不允许识别特定的材料转变，例如，人类鼻窦骨到空气或骨到软组织，独立地，用不同的颜色。为了解决这个问题，Kniss等人建议使用基于密度d和密度场梯度长度||▽d||的二维传递函数。变化区域具有高梯度强度。这种方法使得密度转换的着色更有意义。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023123739.png" class="" title="image-20211023123739">

<p>使用一维(左)和二维(右)传递函数评估体积材料和不透明度。在第二种情况下，保持树干的棕色是可能的，而不用覆盖较浅密度的绿色代表叶子。图像底部为传递函数，x轴为密度，y轴为密度场的梯度长度||▽d||。(图片由Joe Michael Kniss提供。)</p>
<p><strong>Ikits等人深入讨论了这项技术和相关问题。Kniss等人扩展了这种方法，取而代之的是根据半角进行切片。切片仍然由后到前渲染，但朝向介于光线和视图方向之间。使用这种方法，可以从光的角度渲染亮度和遮挡，并在视图空间中积累每个切片。当绘制下一个切片时，可以使用切片纹理作为输入，使用光方向的遮挡来评估体积阴影，使用亮度来估计多次散射，即。即光线在到达人眼之前在介质中多次反射。由于前一个切片是根据圆盘上的多个样本进行采样的，因此该技术只能合成圆锥内的前向散射引起的地下现象。最后的图像质量很高。参见下图。Schott等人对这种半角方法进行了扩展，用于评估环境遮挡和景深模糊效果，提高了用户查看体素数据时的深度和体积感知。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023123923.png" class="" title="image-20211023123923">

<p>利用光通过半角切片传播的前向地下散射体渲染。(图片由Ikits等提供。)</p>
<p><strong>如上图所示，半角切片可以呈现高质量的次表面散射。然而，由于光栅化的内存带宽成本必须为每片支付。Tatarchuk和Shopf在着色器中使用射线行进进行医学成像，因此只需支付一次光栅化带宽成本。照明和阴影可以在下一节中描述。</strong></p>
<h3 id="Participating-Media-Rendering-参与媒体渲染"><a href="#Participating-Media-Rendering-参与媒体渲染" class="headerlink" title="Participating Media Rendering 参与媒体渲染"></a>Participating Media Rendering 参与媒体渲染</h3><p><strong>实时应用程序可以通过呈现参与的媒体来描绘更丰富的场景。这些效果变得更需要渲染时，如时间等因素一天，天气或环境的变化，如建筑物的破坏。例如，森林中的雾在中午或黄昏时看起来会有所不同。树与树之间的光柱应适应太阳变化的方向和颜色。光照轴也应该根据树木的运动而动画化。通过爆炸移除一些树木会导致该区域的散射光的变化，因为更少的遮挡物和产生的灰尘。营火、手电筒和其他光源也会在空气中产生散射。在本节中，我们将讨论可以实时模拟这些动态视觉现象的效果的技术。</strong></p>
<p><strong>一些技术专注于绘制从单一源的大规模阴影散射。Yusov深入描述了一种方法。它是基于沿极线散射的采样，极线是指投射到相机图像平面上的单线上的光线。从光线的角度看，深度图用于确定样本是否被阴影笼罩。该算法从摄像机开始执行射线行军。沿着光线的最小/最大层次用于跳过空白空间，而只在深度不连续处，即它实际上需要准确地评估体积阴影。不是沿着极线取样这些不连续，而是可以在视图空间中通过渲染一个由光空间深度图生成的网格来实现。在视图空间中，只需要正面和背面之间的体积来评估最终散射亮度。为此，内散射的计算是通过在视图中添加从正面产生的散射辐亮度，并减去从背面产生的散射辐亮度。</strong></p>
<p><strong>这两种方法都能有效地再现由不透明表面遮挡造成的阴影单次散射事件。然而，两者都不能代表异质的参与介质，因为它们都假设介质是一种恒定的材料。此外，这些技术不能考虑来自非不透明表面的体积阴影，例如来自参与介质的自阴影或来自粒子的透明阴影(章节13.8)。它们仍然在游戏中发挥着重要作用，因为它们可以以高分辨率呈现，而且速度很快，这多亏了空格跳过技术。</strong></p>
<p><strong>溅射法已被提出用于处理更普遍的均匀介质的情况，沿着射线对体积材料进行取样。Crane等人在不考虑任何输入照明的情况下，使用飞溅来渲染烟、火和水，这些都是流体模拟的结果。在烟雾和火灾的情况下，在每个像素处产生一条光线，光线穿过体积，沿着其长度的规则间隔从材料中收集颜色和遮挡信息。在水的情况下，一旦射线的第一个命中点与水面相遇，体积采样就终止了。表面法线被评估为密度场梯度在每个样品位置。为保证水面光滑，采用三次插值法过滤密度值。下图显示了使用这些技术的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023130039.png" class="" title="image-20211023130039">

<p>使用体积渲染技术结合GPU上的流体模拟来渲染雾和水。(左图来自《地狱之门:伦敦》，由旗舰工作室提供;右图由NVIDIA公司提供。)</p>
<p><strong>考虑到太阳，连同点光源和聚光灯，Valient将边界体集合渲染成一个半分辨率缓冲区，在那里每个光源的散射都应该发生。每个光体都以每像素随机偏移应用于光线行进的起始位置进行光线行进。这样做增加了一点噪声，它的优点是消除由恒定步进产生的带状伪影。在每一帧中使用不同的噪声值是一种隐藏伪影的方法。在对前一帧进行重投影并与当前帧混合后，噪声将被平均从而消失。通过将平面粒子体素化成三维纹理，以八分之一的屏幕分辨率映射到摄像机视锥上，来呈现异构媒体。这个体积在光线行进时作为材料密度使用。半分辨率散射结果可以在全分辨率主缓冲上进行合成，首先使用双边高斯模糊，然后使用双边上采样滤波器，考虑到像素之间的深度差异。当深度增量与中心像素相比过高时，样本将被丢弃。这种高斯模糊在数学上是不可分离的(第12.1节)，但它在实践中工作得很好。这种算法的复杂性取决于屏幕上的光体数量，作为它们的像素覆盖的函数。</strong></p>
<p><strong>这种方法通过使用蓝色噪声得到了扩展，蓝色噪声能够更好地在一帧像素上产生均匀分布的随机值。这样做的结果是更平滑的视觉时，上采样和混合样本空间与双边过滤器。用四个随机样本混合在一起，也可以实现半分辨率缓冲的上采样。结果仍然是噪声，但因为它给出了全分辨率逐像素噪声，它可以很容易地通过时间反锯齿后处理来解决(章节5.4)。</strong></p>
<p><strong>所有这些方法的缺点是，深度有序的体积元素与任何其他透明表面将永远不会给出视觉上正确的结果顺序，例如，大型非凸透明网格或大型粒子效果。当涉及到在透明表面上应用体光时，所有这些算法都需要一些特殊的处理，例如在体素中包含内散射和透射率的体积。那么，为什么不用基于体素的表示法开始时，不仅要表示空间上不同的参与介质特性，还要表示光散射和透过率所产生的辐亮度分布?这些技术在电影工业中使用已久。</strong></p>
<p><strong>Wronski提出了一种方法，将场景中来自太阳和光线的散射辐射体素化成三维体纹理V0 映射到视图剪辑空间上。对每个体素中心的世界空间位置进行散射辐亮度评估，其中体块的x轴和y轴对应于屏幕坐标，而z轴则映射到摄像机截锥深度上。这个体积纹理的分辨率比最终图像低得多。这种技术的典型实现使用x轴和y轴上的体素分辨率为屏幕分辨率的八分之一。沿着z坐标细分取决于质量和性能的权衡，64个切片是一个典型的选择。这个纹理包含散射的RGB亮度Lscat以及alpha消光σt 。从这个输入数据，最终散射体积Vf 是通过从近到远的迭代每个片生成的</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023130340.png" class="" title="image-20211023130340">

<p><strong>其中L′scat= V0[x, y, z−1]rgb，T ′r= V0[x, y, z−1]a和 Trslice= e^(−σtds)。这个更新根据世界空间切片深度ds从先前的切片z−1数据到切片z。这样做会导致Vf 包含到达观察者的散射辐射和每个体素背景上的透射率。在上式中，注意Lscatin受的影响只有先前切片的透射率T ′r。这种行为是错误的，因为Lscatin在也应受到由σt 在当前片内。</strong></p>
<p><strong>Hillaire讨论了这个问题。他提出了Lscatin积分的解析解对于恒定消光σt 对于给定的深度:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023130842.png" class="" title="image-20211023130842">

<p><strong>最终像素亮度Lo 亮度Ls 的不透明表面将由Lscat 和Tr 从Vf ，采样的裁剪空间坐标为Lo = TrLs + Lscat。因为Vf 是粗糙的，它是受混叠从相机运动和高频率的强光或阴影。前一帧Vf 可以重新投影并与新的Vf 结合使用指数移动平均。</strong></p>
<p><strong>在这个框架之上，Hillaire提出了一种基于物理的方法来定义参与媒体材料，如下:散射σs、吸收σa，相位函数参数g，发射辐亮度Le。这个材质被映射到摄像机的视锥，并存储到参与的媒体材质体积纹理Vpm中，是储存不透明表面材料的G-buffer的三维版本(章节20.1)。Hillaire指出，仅考虑单次散射，尽管体素离散化，但使用这种基于物理的材料表示可以获得接近路径跟踪的视觉效果。类似于网格，位于世界中的参与媒体体素化为Vpm (见下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023131109.png" class="" title="image-20211023131109">

<p>艺术家将参与的媒体体量放置在一个关卡中，并体素化到摄像机截锥空间中。左边是一个三维纹理，形状是在这个例子中，球体被映射到体积上。纹理定义了体积的外观，类似于三角形上的纹理。在右边，这个体积通过考虑它的世界变换而被体素化到摄像机的视锥中。计算着色器将贡献累加到体积所包含的每个体素中。得到的材料可以用来评估每个体素中的光散射相互作用。注意，当映射到相机剪辑空间时，体素呈小frusta的形状，被称为froxels。</p>
<p><strong>在每一个体量中，都定义了单一的材料，并添加了变化，谢谢到密度从一个三维输入纹理采样，导致异构的参与媒体。结果如下图所示。在Unreal Engine中也实现了同样的方法，但不是使用盒子体积作为参与媒体的来源，而是使用粒子，假设一个球形体积而不是一个盒子。也可以使用稀疏结构来表示材料体纹理，使用每个体素为空或指向包含参与媒体材料数据的细粒度体块的最上面的体块。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023131250.png" class="" title="image-20211023131250">

<p>没有(上)而有(下)体积照明和阴影渲染的场景。场景中的每一盏灯都与参与的媒体相互作用。每个光的亮度、IES剖面和阴影图被用来积累其散射光的贡献。(图片由Frostbite,§c2018年Electronic Arts Inc.)</p>
<p><strong>基于摄像机截锥体积的方法的唯一缺点是，为了在功能较弱的平台上达到可接受的性能(并使用合理的内存)，需要较低的屏幕空间分辨率。这就是前面解释的飞溅方法的优点，因为它们产生了清晰的视觉细节。如前所述，溅射需要更多的内存带宽，并提供更少的统一解决方案，例如，它很难应用于任何其他透明表面，而没有分类问题或有参与的媒体在自身上投下体积阴影。</strong></p>
<p><strong>不仅是直接的光，而且已经反射或散射的光也可以通过介质散射。类似于Wronski，Unreal Engine使其能够烘焙体积光地图，存储在体积的辐照度，并使其散射回媒体时，体素化的视图体积。为了实现参与媒体的动态全局照明，也可以依赖光的传播体积。</strong></p>
<p><strong>一个重要的特点是体积阴影的使用。如果没有它们，在浓雾弥漫的场景中，最终的图像看起来会过于明亮和平坦。此外，阴影是一个重要的视觉线索。它们帮助观众感知深度和体积，产生更真实的图像，并可以导致更好的浸没式。Hillaire提出了一个统一的解决方案来实现体积阴影。根据clipmap分布方案，参与的介质体积和粒子被体素化为围绕相机级联的三个体积，称为消光体积。这些包含消光σt计算Tr 所需的值并代表了一个统一的数据源来采样，以便使用不透明度阴影图来实现体积阴影。参见下图。这种解决方案使粒子和参与的媒体能够自我阴影，并相互投射阴影，以及场景中任何其他不透明和透明的元素。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023131531.png" class="" title="image-20211023131531">

<p>在顶部，场景渲染没有(左)和(右)体积阴影。在底部，体素化粒子消光(左)和体阴影(右)的调试视图。更环保的意味着透射率更低[742]。(图片由Frostbite提供，§c2018年Electronic Arts Inc.)</p>
<p><strong>体积阴影可以用不透明度阴影贴图来表示。然而，如果需要高分辨率来捕捉细节，我们使用体积纹理很快就会成为一个限制。因此，提出了替代表示Tr 的方法更有效，例如使用函数的正交基，如傅立叶或离散余弦变换。详情见第7.8节。</strong></p>
<h2 id="Sky-Rendering-天空渲染"><a href="#Sky-Rendering-天空渲染" class="headerlink" title="Sky Rendering 天空渲染"></a>Sky Rendering 天空渲染</h2><p><strong>渲染一个世界本质上需要一个星球的天空，大气效果和云。我们所谓的地球上的蓝天，就是阳光在大气的参与介质中散射的结果。为什么白天的天空是蓝色的，太阳在地平线时是红色的，请参见14.1.3节。大气也是一个关键的视觉线索，因为它的颜色与太阳的方向有关，而太阳的方向又与一天中的时间有关。大气(有时)雾蒙蒙的外观有助于观众感知场景中元素的相对距离、位置和大小。因此，准确地渲染这些组件非常重要，因为越来越多的游戏和其他应用都需要这些组件，这些组件具有动态的一天时间，影响云形状的天气变化，以及用于探索、驾驶甚至飞越的大型开放世界。</strong></p>
<h3 id="Sky-and-Aerial-Perspective-天空和空中透视"><a href="#Sky-and-Aerial-Perspective-天空和空中透视" class="headerlink" title="Sky and Aerial Perspective 天空和空中透视"></a>Sky and Aerial Perspective 天空和空中透视</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023132131.png" class="" title="image-20211023132131">

<p>两种不同类型的大气光散射:顶部的瑞利散射和底部的常规瑞利散射的米氏散射。从左到右:密度为0，规则密度如[203]所述，并夸大了密度。(图片由Frostbite提供，c2018年电子艺界公司[743])。</p>
<p><strong>为了渲染大气效果，我们需要考虑两个主要组件，如上图所示。首先，我们模拟阳光与空气粒子的相互作用，产生波长相关的瑞利散射。这将导致天空的颜色和薄雾，也称为空中透视。其次，我们需要研究集中在地面附近的大颗粒对阳光的影响。这些物质的浓度大颗粒取决于天气条件和污染等因素。大粒子引起波长无关的米氏散射。这种现象会在太阳周围产生明亮的光晕，特别是在粒子浓度较大的情况下。</strong></p>
<p><strong>第一个基于物理的大气模型从太空渲染了地球及其大气，模拟了单次散射。使用O ‘Neil提出的方法也可以得到类似的结果。地球可以在一个单通道着色器中使用光线行进从地面渲染到太空。当渲染天空穹顶时，每个顶点都要进行昂贵的射线行军来整合Mie和瑞利散射。然而，视觉高频相位函数是在像素着色器中评估的。这使得外观平滑，避免了由于插值而暴露天空的几何形状。通过将散射存储在纹理中并将评估分布在几帧上，接受更新延迟以获得更好的性能，也可以获得相同的结果。</strong></p>
<p><strong>分析技术使用测量到的天空辐射的拟合数学模型，或使用大气中光散射的昂贵路径跟踪生成的参考图像。与参与的媒体材料相比，输入参数集通常是有限的。例如，浊度表示导致Mie散射的粒子的贡献，而不是σs 和σt 系数。Preetham等人提出的这种模型利用浑浊度和太阳高度来评估任何方向的天空亮度。通过增加对光谱输出的支持、对太阳周围散射辐射更好的方向性以及新的地面反照率输入参数，它得到了改进。分析天空模型的评估速度很快。然而，它们仅限于地面视图，大气参数不能被改变来模拟地外行星或实现特定的艺术驱动的视觉效果。</strong></p>
<p><strong>渲染天空的另一种方法是假设地球是完美的球形，周围有一层由不同的参与媒体组成的大气层。Bruneton和Neyret以及Hillaire对大气成分作了广泛的描述。利用这些事实，可以使用预先计算的表格来存储根据当前视图高度r(视图向量角相对于天顶的余弦)的透射率和散射率µv，即太阳方向角相对于天顶的余弦µs，以及视矢量角相对于太阳方向在方位角平面ν的余弦值。例如，从视点到大气边界的透射率可以用两个参量r和µv来参数化．在预计算步骤中，透光率可以集成到大气中，并存储在一个二维查找表(LUT)纹理Tlut 中可以在运行时使用相同的参数进行采样。这个纹理可以用于应用大气透过率的天空元素，如太阳，星星，或其他天体。</strong></p>
<p><strong>考虑到散射，Bruneton和Neyret描述了一种将其存储在四维LUT Slut 中的方法由前一段的所有参数参数化。它们还提供了一种方法来计算n阶的多次散射(i)计算单次散射表Slut， (ii)使用Slut^(n-1 评估Slut^n， (iii)将结果添加到Slut中．做(ii)和(iii) n-1次。Bruneton和Neyret提供了该过程的更多细节以及源代码。结果示例见下图。Bruneton和Neyret的参数化有时会在视界上显示出视觉伪影。Yusov提出了一个改进的改造方案。也可以通过忽略ν来使用唯一的三维LUT。使用这种方案，地球不会在大气中投下阴影，这是一个可以接受的权衡。其优点是这个LUT将更小，更新和取样的成本更低。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023132829.png" class="" title="image-20211023132829">

<p>使用查找表从地面(左)和从空间(右)实时渲染地球大气。(图片由Bruneton和Neyret提供。)</p>
<p><strong>这种最后的三维LUT方法被许多Electronic Arts Frostbite即时游戏所使用，如Need for Speed, Mirror’s Edge Catalyst, FIFA。在这种情况下，艺术家可以驱动物理基础大气参数，以达到目标天空视觉，甚至模拟地外大气。参见下图。当大气参数发生变化时，必须重新计算LUT。为了更有效地更新这些LUTs，还可以使用一个函数来近似大气中材料的积分，而不是射线穿过它[。通过临时分配LUTs的评估和多重散射，更新LUTs的成本可以摊销到原来的6%。这是只需更新Slut^n的一个子部分即可实现对于给定的n阶散射，则插入最后两个已解决的LUTs，接受一些延迟帧。作为另一种优化，为了避免对每个像素的不同LUTs进行多次采样，Mie和Rayleigh散射被烘焙在相机的锥视图映射的低分辨率体积纹理的体素中。为了在太阳周围产生平滑的散射晕，在像素着色器中评估视觉高频相位函数。使用这种类型的体纹理也允许对场景中任何透明物体的每个顶点应用空中透视。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023133219.png" class="" title="image-20211023133219">

<p>使用完全参数化模型进行实时渲染，可以模拟地球的大气层(顶部)和其他行星的大气层，比如火星的蓝色日落(底部)。(顶部图片由Bruneton和Neyret提供，底部图片由Frostbite提供，2018年电子艺界公司。)</p>
<h3 id="Clouds-云"><a href="#Clouds-云" class="headerlink" title="Clouds 云"></a>Clouds 云</h3><p><strong>云是天空中复杂的元素。当代表即将到来的风暴时，它们看起来可能是危险的，也可能是谨慎的、史诗般的、纤细的或巨大的。云变化缓慢，其大尺度形状和小尺度细节都随着时间的推移而演变。带有天气和时间变化的大型开放世界游戏更复杂，需要动态云渲染解决方案。根据目标性能和视觉质量，可以使用不同的技术。</strong></p>
<p><strong>云是由水滴组成的，具有高散射系数和复杂的相位函数，结果是一个特定的外观。如第14.1节所述，它们经常使用参与介质进行模拟，并且它们的材料已经被测量为具有高的单次散射反照率ρ = 1和消光系数σt 在层云(低空水平云层)的范围[0.04,0.06]和积云(孤立的低空棉花状蓬松云)的范围[0.05,0.12]。参见下图。假设ρ接近于1，σs =σt 可以假定。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023133510.png" class="" title="image-20211023133510">

<p>地球上不同类型的云。(图片由Valentin de Bruyn提供。)</p>
<p><strong>云渲染的一个经典方法是使用alpha混合在天空上合成一个全景纹理。这在渲染静态天空时很方便。Guerrette提出了一种视觉流动技术，它给出了云在天空中运动的错觉，受全球风向的影响。这是一种有效的方法，改进了全景云纹理静态集的使用。然而，它将不能表示云形状和光照的任何变化。</strong></p>
<h4 id="Clouds-as-Particles-云作为粒子"><a href="#Clouds-as-Particles-云作为粒子" class="headerlink" title="Clouds as Particles 云作为粒子"></a>Clouds as Particles 云作为粒子</h4><p><strong>Harris将云渲染成粒子和视点替用器的体积。参见第557页第13.6.2节和图13.9。</strong></p>
<p><strong>另一种基于粒子的云绘制方法由Yusov提出。他使用被称为体积粒子的渲染原语。每一个都由一个四维LUT表示，允许检索散射光和透光率在面向视图的四粒子上作为太阳光线和视图方向的函数。参见下图。这种方法非常适合渲染层积云。参见上图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023133722.png" class="" title="image-20211023133722">

<p>以粒子体积呈现的云。(图片由Egor Yusov提供)</p>
<p><strong>当将云渲染为粒子时，可以看到离散化和弹出伪影，特别是当围绕云旋转时。这些问题可以通过使用体积感知混合来避免。这种能力是通过使用一种称为光栅化顺序视图的GPU特性实现的(章节3.8)。体积感知混合使每个原语的资源上的像素着色操作同步，允许震撼性自定义混合操作。最接近的n个粒子的深度层以与渲染目标相同的分辨率保存在一个缓冲区中。这缓冲区被读取并用于混合当前渲染的粒子，通过考虑交集深度，然后最后再次写入下一个要渲染的粒子。结果如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023133751.png" class="" title="image-20211023133751">

<p>在左边，云粒子以通常的方式呈现。在右边，粒子渲染与体积感知混合。(图片由Egor Yusov提供。)</p>
<h4 id="Clouds-as-Participating-Media-云作为参与媒体"><a href="#Clouds-as-Participating-Media-云作为参与媒体" class="headerlink" title="Clouds as Participating Media 云作为参与媒体"></a>Clouds as Participating Media 云作为参与媒体</h4><p><strong>Bouthors等人认为云是孤立的元素，他们将云分为两部分:一是网格，显示其整体形状;二是超纹理，在网格表面下添加高频细节，使其在云内部达到一定深度。使用这种表示方法，云的边缘可以被精细地射线行进以收集细节，而云的内部可以被认为是均匀的。当光线在云结构中行进时，融合辐亮度，并根据散射顺序使用不同的算法收集散射辐亮度。使用14.1节中描述的解析方法对单次散射进行积分。利用位于云表面的圆盘形光收集器的离线预计算转换表，可以加速多重散射评估。最终的结果具有很高的视觉质量，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023134025.png" class="" title="image-20211023134025">

<p>使用网格和超纹理渲染的云。(图片由Bouthors等提供。)</p>
<p><strong>与其将云渲染为孤立的元素，还可以将它们建模为大气中参与介质的一层。Schneider和Vos提出了一种利用射线行进的方法来渲染云。只需要几个参数，就可以在动态的光照条件下渲染复杂的、动画的和详细的云形状，如下图所示。层是使用两级程序噪声构建。第一层给出了云的基本形状。第二层通过侵蚀这个形状来增加细节。在这种情况下，据报道，Perlin和Worley噪声的混合是花椰菜状积云和类似云的良好代表。生成这些纹理的源代码和工具已经公开共享。照明是通过利用沿视图射线分布在云层中的样本来整合来自太阳的散射光来实现的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023134130.png" class="" title="image-20211023134130">

<p>使用Perlin-Worley噪声和动态体光照和阴影的动态云渲染。(Results by Schneider and Vos，版权所有§c 2017 Guerrilla Games。)</p>
<p><strong>体积阴影可以通过评估层内几个样品的透光率来实现，并以二次射线行进的方式对太阳进行测试。对于这些阴影样本，可以对噪声纹理的较低的mipmap级别进行采样，以获得更好的性能，并在只使用少量样本的情况下平滑可见的伪影。避免二次射线在每个样本中移动的另一种方法是使用许多可用的技术之一(第13.8节)，在每帧纹理中编码一次来自太阳的透射曲线。例如，游戏《最终幻想XV》使用了透射函数映射。</strong></p>
<p><strong>如果我们想要捕捉每一个小细节，用光线行进来渲染高分辨率的云会变得非常昂贵。为了获得更好的性能，可以用低分辨率渲染云。一种方法是在每个4X4块中只更新一个像素，然后重新投影之前的帧数据来填充剩余的帧数据。Hillaire提出了一种变化，即始终以固定的较低分辨率呈现，并在视图射线行进起始位置添加噪声。前一帧的结果可以通过指数移动平均重新投影，并与新帧相结合。这种方法渲染的分辨率较低，但收敛速度更快。</strong></p>
<p><strong>云的相位函数是复杂的。在这里，我们提出了两种可用于实时评估它们的方法。可以将函数编码为纹理，并基于θ对其进行采样。如果这样做需要太多的内存带宽，可以通过结合第14.1.4节中的两个Henyey-Greenstein相位函数来近似该函数</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023134317.png" class="" title="image-20211023134317">

<p><strong>其中两个主要散射偏心g0 和g1，以及混合因子可以由一位艺术家创作。这在表示主的时候是很重要的向前和向后散射方向，当远离或朝向光源(如太阳或月亮)时，揭示云中的细节。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023134412.png" class="" title="image-20211023134412">

<p>如Hillaire所述，使用基于物理的参与媒体表示的动态照明和阴影，使用光线行进的云层渲染云。来自BioWare的S¨oren Hesse(上)和Ben McGrath(下)，来自2018EAInc .)</p>
<p><strong>有不同的方法来近似云中周围光线的散射光。一个简单的解决方案是使用一个单一的亮度输入，统一地从天空渲染到一个立方体贴图纹理。一个自下而上的，从暗到光的梯度也可以用来缩放环境光线，以接近云层本身的遮挡。也可以将输入亮度分离为底部和顶部，例如地面和天空。假设介质密度恒定，则环境散射可以解析地对两种贡献进行积分云层。</strong></p>
<h4 id="Multiple-Scattering-Approximation-多次散射近似"><a href="#Multiple-Scattering-Approximation-多次散射近似" class="headerlink" title="Multiple Scattering Approximation 多次散射近似"></a>Multiple Scattering Approximation 多次散射近似</h4><p><strong>云的明亮和白色的外观是光在其中散射多次的结果。如果没有多次散射，厚厚的云层的边缘大部分会被照亮，而其他地方则会显得黑暗。多重散射是使云看起来不烟雾或阴暗的关键组成部分。用路径跟踪来计算多次散射是非常昂贵的。Wreninge提出了一种近似射线行进时这种现象的方法。它集成了o倍频的散射，并将它们相加为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023135640.png" class="" title="image-20211023135640">

<p><strong>当求Lscat时，要做以下替换(例如,使用σ′s而不是σs):σ′s=σsa^n, σ′e=σeb^n和p′(θ)= p(θc^n)，其中a、b、c为在[0,1]中的用户控制参数将让光穿透参与媒体。当这些值接近0时，云看起来更柔和。为了确保这个技术是节能的，当评估Lmultiscat(x, v)时，必须保证a≤b。否则，更多的光会散射，因为方程σt =σa +σs 将不会被遵守，如σs 会比σt大．这个解决方案的优点是，当光线行进时，它可以在飞行中集成每个不同八度的散射光。视觉效果的改善见下图。缺点是，当光线可以向任何方向散射时，它在复杂的多重散射行为上做得很差。然而，云的外观得到了改善，这种方法允许照明艺术家通过一些参数轻松地控制视觉效果，并表达他们的视觉效果，这得益于更广泛的可实现的结果。通过这种方法，光线可以穿透介质，揭示更多的内部细节。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023140030.png" class="" title="image-20211023140030">

<p>使用公式14.18渲染的云作为多次散射的近似。从左到右，n设为1，2，3。这使阳光能穿透云层可信的时尚。(图片由Frostbite提供，§c电子艺界公司.)</p>
<h4 id="Clouds-and-Atmosphere-Interactions-云与大气的相互作用"><a href="#Clouds-and-Atmosphere-Interactions-云与大气的相互作用" class="headerlink" title="Clouds and Atmosphere Interactions 云与大气的相互作用"></a>Clouds and Atmosphere Interactions 云与大气的相互作用</h4><p><strong>当渲染一个有云的场景时，为了视觉上的一致性，考虑与大气散射的交互是很重要的。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023140253.png" class="" title="image-20211023140253">

<p>完全覆盖天空的云被考虑到大气。左:没有大气散射应用于云，导致不连贯的视觉效果。中:有大气散射，但没有西晒时环境显得太亮。右图:云层遮蔽了天空，从而影响了光在大气中的散射从而产生连贯的视觉效果。(图片由Frostbite提供，§c电子艺界公司.)</p>
<p><strong>由于云是大尺度的元素，应该对其应用大气散射。可以对第14.4.1节中提出的大气散射进行评估对于通过云层采集的每个样本，但这样做很快就会变得昂贵。相反，可以根据代表平均云层深度和透光率的单一深度对云应用大气散射。</strong></p>
<p><strong>如果增加云层覆盖率来模拟下雨的天气，云层下面的阳光在大气中的散射应该减少。只有穿过云层的光线才会散射到云层下的大气中。可以通过减少天空的光照对空中透视的贡献，并将散射光添加回大气中来修改光照。可视的改进如上图所示。</strong></p>
<p><strong>综上所述，云渲染可以通过先进的基于物理的材料表示和光照来实现。逼真的云形状和细节可以通过使用程序噪声来实现。最后，如本节所述，为了获得连贯的视觉效果，记住全局也很重要，例如云与天空的相互作用。</strong></p>
<h2 id="Translucent-Surfaces-半透明表面"><a href="#Translucent-Surfaces-半透明表面" class="headerlink" title="Translucent Surfaces 半透明表面"></a>Translucent Surfaces 半透明表面</h2><p><strong>半透明表面通常是指具有高吸收率和低散射系数的材料。这些材料包括玻璃杯、水或592页图14.2所示的葡萄酒。此外，本节还将讨论具有粗糙表面的半透明玻璃。这些主题在许多出版物中也有详细介绍。</strong></p>
<h3 id="Coverage-and-Transmittance-覆盖和透光率"><a href="#Coverage-and-Transmittance-覆盖和透光率" class="headerlink" title="Coverage and Transmittance 覆盖和透光率"></a>Coverage and Transmittance 覆盖和透光率</h3><p><strong>正如第5.5节所讨论的，透明表面可以被视为具有以α为代表的覆盖层，例如，不透明的织物或组织纤维隐藏了其背后部分的百分比。对于玻璃和其他材料，我们想要计算透明度，在固体体积中，每一种波长的百分比都可以通过，作为背景的滤光片，作为透射率Tr的函数14.1.2(部分)。输出颜色为co，表面辐射度cs，底色为cb，透明度即覆盖表面的混合操作是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024134514.png" class="" title="image-20211024134514">

<p><strong>在半透明表面的情况下，混合操作将是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024134616.png" class="" title="image-20211024134616">

<p><strong>其中cs 包含固体表面的镜面反射，即玻璃或凝胶。请注意,Tr 是一个三值透射率色向量。要实现彩色半透明，可以使用任何现代图形API的双源颜色混合特性，以指定这两种输出颜色与目标缓冲色cb混合．Drobot介绍了不同的混合操作，可以使用取决于是否，对于一个给定的表面，反射和透光率是有色与否。</strong></p>
<p><strong>在一般情况下，可以使用共同的混合操作来同时指定覆盖和半透明。在本例中使用的混合函数是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024134806.png" class="" title="image-20211024134806">

<p><strong>当厚度变化时，透射光量可由式14.3计算，可简化为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024134835.png" class="" title="image-20211024134835">

<p><strong>d是通过物质体积的距离。物理消光参数σt 表示光通过介质时衰减的速率。对于艺术家的直观创作，Bavoil设置了目标颜色tc 为某一给定距离d处的透射率，则消光σt 可以恢复为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024135159.png" class="" title="image-20211024135159">

<p><strong>例如，以目标透射率为颜色tc =(0.3, 0.7, 0.1)和距离d = 4.0米，我们有</strong></p>
 <img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024135307.png" class="" title="image-20211024135307">

<p><strong>注意，透光率为0需要作为特殊情况处理。一种解决方法是从Tr的每个分量中减去一个小的值，例如0.000001．滤色效果如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024135434.png" class="" title="image-20211024135434">

<p>通过多层网格的不同吸收因子的半透明。(图片由Louis Bavoil提供。)</p>
<p><strong>在一个空的壳网格的情况下，其表面由一薄层半透明材料组成，背景颜色应该被遮挡作为一个功能光在介质中传播的路径长度d。因此，沿着它的法线或切线观看表面将导致不同数量的背景遮挡作为其厚度t的函数，因为路径长度随角度而变化。Drobot提出了这样一种方法，其中透过率Tr 评估是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024135554.png" class="" title="image-20211024135554">

<p><strong>下图显示了结果。有关薄膜和多层表面的更多细节，请参阅第9.11.2节。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024135710.png" class="" title="image-20211024135710">

<p>彩色透射率是根据视场射线v在厚度为t的透明表面上移动的距离d计算出来的(右图由动视出版公司提供，2018年)。</p>
<p><strong>以固体半透明网格为例，计算光线穿过传输介质的实际距离有很多方法。一种常见的方法是首先渲染视图射线离开体积的表面。这个表面可能是水晶球的背面，也可能是海底。也就是水的尽头)。存储该表面的深度或位置。然后渲染体积的表面。在着色器中访问存储的出口深度，并计算它与当前像素表面之间的距离。然后用这个距离计算应用在背景上的透光率。</strong></p>
<p><strong>如果保证体积是封闭的和凸的，即每个像素有一个入口点和一个出口点，就像水晶球一样。我们的海床例子也适用，因为一旦我们离开水，我们会遇到一个不透明的表面，所以进一步的透光不会发生。对于更精细的模型，例如玻璃雕塑或其他有凹孔的物体，两个或更多独立的跨度可以吸收射入的光线。使用深度剥离，如在第5.5节中讨论的，我们可以以精确的前后顺序渲染体积表面。当每个正面被渲染时，通过体积的距离被计算并用于计算透光率。依次应用每一种方法就可得到适当的最终透过率。注意，如果所有卷都是由如果表面没有反射成分，则同一材料在相同浓度下的透射率可以在最后用求和的距离计算一次。在最近的GPUs上，也可以使用A-buffer或K-buffer方法直接在单次传递中存储对象片段，以提高效率。如上上图所示为多层透光率的例子。</strong></p>
<p><strong>在大规模海水的情况下，场景深度缓冲器可以直接作为背面海床的表示。当渲染透明表面时，必须考虑菲涅尔效应，如第9.5节所述。大多数发射介质的折射率都明显高于空气的折射率。在反光角度，所有的光都会从界面反射回来，没有一个会被传送出去。下图显示了这种效果，当直接往水中看时，水下的物体是可见的，但往更远的地方看，以掠射的角度看，水面基本上隐藏了波浪下面的东西。有几篇文章解释了处理大面积水体的反射、吸收和折射。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024135906.png" class="" title="image-20211024135906">

<p>考虑了透光率和反射效应的水渲染。往下看，因为透光率很高，所以我们可以看到水是浅蓝色的。在地平线附近，由于透光率较低(因为光线必须传播很远)，海底变得不那么可见<br>由于菲涅耳效应，反射以牺牲透射为代价而增加。(图片来自Crytek公司的《孤岛危机》)</p>
<h3 id="Refraction-折射"><a href="#Refraction-折射" class="headerlink" title="Refraction 折射"></a>Refraction 折射</h3><p><strong>对于透光率，我们假设入射光直接来自网格体之外的直线。这是一个合理的假设，当网格的前表面和后表面是平行的，厚度不是很大，例如，窗格的玻璃。对于其他透明介质，折射率起着重要的作用。斯涅尔定律描述了当网格表面遇到时光线如何改变方向，描述在第9.5节。</strong></p>
<p><strong>由于能量守恒，任何未被反射的光都被透射，因此透射光通量与入射光通量的比例为1-f，其中f是反射光的量。然而，透射与入射辐亮度的比例是不同的。由于入射光和透射光的投影面积和立体角不同，所以辐亮度关系为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024143843.png" class="" title="image-20211024143843">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024144043.png" class="" title="image-20211024144043">

<p>折射和透射亮度与入射角θi 的关系透射角θt。</p>
<p><strong>这种行为如上图所示。斯涅尔定律结合上式得到了透射辐亮度的不同形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024144614.png" class="" title="image-20211024144614">

<p><strong>Bec提出了一种计算折射矢量的有效方法。为了便于阅读(因为在斯涅尔公式中n通常被用来表示折射率)，我们定义N为表面法线，l为光线方向:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024144717.png" class="" title="image-20211024144717">

<p><strong>其中n = n1/ n2 是相对折射率，和</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024144827.png" class="" title="image-20211024144827">

<p><strong>得到的折射矢量t被归一化返回。水的折射率约为1.33，玻璃的折射率一般在1.5左右，空气的折射率有效地为1.0。</strong></p>
<p><strong>折射率随波长而变化。也就是说，透明的介质会使每种颜色的光以不同的角度弯曲。这种现象被称为色散，它解释了为什么棱镜将白光扩散成彩虹色的光锥，以及为什么会出现彩虹。色散会引起透镜的问题，称为色差。在摄影中，这种现象被称为紫色边缘，在日光下沿着对比度高的边缘可以特别明显。在计算机图形学中，我们通常忽略这一效应，因为它通常是一个要避免的人工产物。为了正确模拟这种效果，需要进行额外的计算，因为进入透明表面的每一条光线都会生成一组必须被跟踪的光线。因此，通常使用单折射光线。值得注意的是，一些虚拟现实渲染器应用反色差变换，以补偿头戴式的镜头。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024145238.png" class="" title="image-20211024145238">

<p>左:立方体环境地图的玻璃天使折射，地图本身用作天空盒背景。右图:带有色差的玻璃球的反射和折射。(左图来自three.js示例webgl materials cube map refraction，来自Stanford 3D扫描库的Lucy模型，由Humus纹理。右图由Lee Stemkoski提供)</p>
<p><strong>给人一种折射的印象的一般方法是生成一个立方体的环境从折射物体的位置映射(EM)。当这个物体被渲染时，可以通过计算前表面的折射方向来访问EM。上图显示了一个示例。Sousa提出了一种屏幕空间方法，而不是使用EM。首先，场景像往常一样被渲染，没有任何折射物体进入场景纹理s。其次，折射物体被渲染到最初被清除为1的s的alpha通道中。如果像素通过深度测试，则写入一个值0。最后，折射物体被完全渲染，并在像素着色器中根据屏幕上的像素位置采样，扰动偏移来自，例如，缩放表面的法切线xyz分量，模拟折射。在这种情况下，只有当α = 0时，才考虑扰动样本的颜色。这个测试是为了避免使用来自折射物体前面表面的样品，从而使它们的颜色被拉进来，就像它们在后面一样。注意，不需要设置α = 0，场景深度图可以用来比较像素着色器深度与受扰动的场景样本深度。如果中心像素距离较远，则偏移样本距离较近;然后它被忽略并被常规场景样本代替，就好像没有折射一样。</strong></p>
<p><strong>这些技术给人以折射的印象，但与物理现实几乎没有相似之处。当光线进入透明物体时，它会被重定向，但是当光线应该离开物体时，它不会第二次弯曲。这个退出接口永远不起作用。这个缺陷有时并不重要，因为人类的眼睛会原谅正确的外观。</strong></p>
<p><strong>许多游戏都通过一个单层来突出折射。对于粗糙的折射表面，根据材料的粗糙度对背景进行模糊处理，以模拟由微基因组法向分布引起的折射光线方向的扩散。在游戏《毁灭战士》(2016)中，场景首先像往常一样渲染。然后将其降采样到一半分辨率，并进一步降至四个mipmap级别。根据模拟GGX BRDF波瓣的高斯模糊对每个mipmap级别进行下采样。在最后一步中，在全分辨率场景上渲染折射网格。背景是通过对场景的mipmapping纹理采样，并将材质的粗糙度映射到mipmap级别，在表面后面合成的。表面越粗糙，背景就越模糊。Drobot使用一般的材料表示，也提出了相同的方法。McGuire和Mara的统一透明框架中也使用了类似的技术。在这种情况下，高斯点扩散函数是用来采样的背景在一个单一的通过。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024145525.png" class="" title="image-20211024145525">

<p>图像底部的透明玻璃具有基于粗糙度的背景散射。玻璃后面的元素或多或少显得模糊，模拟了折射光线。(图片由Frostbite提供，§c2018年Electronic Arts Inc.)</p>
<p><strong>它也可以处理更复杂的情况下，折射通过多层。每个层都可以用纹理中存储的深度和法线进行渲染。然后，可以使用一个符合地形映射(第6.8.1节)精神的程序来跟踪通过层的光线。存储的深度被视为一个高度场，每条射线走，直到找到交叉点。Oliveira和Brauwers提出了这样一个框架，通过网格的背面处理折射。此外，附近的不透明对象可以转换成颜色和深度地图，提供最后一个不透明层。所有这些图像空间折射方案的一个限制是，屏幕边界之外的东西不能折射或被折射。</strong></p>
<h3 id="Caustics-and-Shadows-焦散线和阴影"><a href="#Caustics-and-Shadows-焦散线和阴影" class="headerlink" title="Caustics and Shadows 焦散线和阴影"></a>Caustics and Shadows 焦散线和阴影</h3><p><strong>评估由折射和衰减光产生的阴影和焦散是一项复杂的任务。在非实时环境中，可以使用多种方法来实现这一目标，如双向路径跟踪或光子映射。幸运的是，许多方法提供了这种现象的实时近似。</strong></p>
<p><strong>焦散是光从直线路径发散出来的视觉结果，例如玻璃或水面。结果是光线在一些区域会散焦，产生阴影，而在另一些区域会集中，光线路径变得更密集，从而产生更强的入射光。这种路径取决于光遇到的曲面。反射的一个经典例子是咖啡杯内的心形腐蚀剂。折射焦散更明显，例如光通过水晶饰品、透镜或一杯水聚焦。参见下图。焦散也可以产生由于光被一个弯曲的水面反射和折射，无论是在上面和下面。当光线汇聚时，会集中在不透明的表面上并产生焦散。当在水面以下时，汇聚光路将在水体积内变得可见。这将产生众所周知的光轴，光子散射穿过水粒子。焦散是一个单独的因素，超出了来自体积边界的菲涅耳相互作用和穿过它时的透射率的光还原。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024145751.png" class="" title="image-20211024145751">

<p>真实世界的焦散来自反射和折射。</p>
<p><strong>为了从水面生成焦散，你可以应用离线生成的焦散动画纹理作为应用在表面上的光贴图，潜在地添加到通常的光贴图上。许多游戏都利用了这种方法，如运行在CryEngine上的《孤岛危机3》。在一个关卡中，水的面积是使用水的体积绘制的。体积的顶部表面可以使用凹凸贴图纹理动画或物理模拟。当垂直投影在水面上和水面下时，可以使用凹凸贴图产生的法线，从它们的方向映射到辐射贡献来生成焦散。距离衰减使用艺术家创作的基于高度的最大影响距离进行控制。水面也可以被模拟，对世界上的物体运动做出反应，从而产生与环境中发生的情况相匹配的焦散事件。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024145837.png" class="" title="image-20211024145837">

<p>演示在水中的腐蚀性效应。(图片来自Evan Wallace提供的WebGL Water演示。)</p>
<p><strong>当在水下时，同样的动态水面也可以用于水介质中的焦散。Lanza提出了一种两步生成光轴的方法。首先，从光的角度渲染光的位置和折射方向，并保存到纹理中。线可以栅格化从水面开始，并延伸到视野中的折射方向。它们通过添加混合来累积，最后一个后期模糊可以用来模糊结果，以掩盖低数量的线条。</strong></p>
<p><strong>Wyman提出了一种用于苛性渲染的图像空间技术。它的工作原理是通过透明物体的正面和背面折射后，首先计算光子的位置和入射方向。这是通过使用14.5.2节介绍的背景折射技术实现的。但是，由于菲涅耳效应，纹理被用来存储场景的交点位置、折射后的入射方向和透射率，而不是存储折射亮度。每个像素存储一个光子，然后可以以正确的强度溅射回视野。为了实现这一目标，有两种可能:在视野空间或光空间中以四倍频散射光子，并伴有高斯衰减。其中一个结果如下图所示。McGuire和Mara提出了一种更简单的方法来处理焦散类阴影，方法是根据透明表面的法线变化透射率，如果垂直于入射面透射率更高，由于菲涅耳效应，否则透射率更低。其他的体积阴影技术将在第7.8节中描述。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024150002.png" class="" title="image-20211024150002">

<p>在左边，佛陀折射附近的物体和周围的天空盒。在右边，焦散是通过本质上类似于阴影图的层次图生成的。(图片由爱荷华大学克里斯·怀曼提供。)</p>
<h2 id="Subsurface-Scattering-次表面散射-1"><a href="#Subsurface-Scattering-次表面散射-1" class="headerlink" title="Subsurface Scattering 次表面散射"></a>Subsurface Scattering 次表面散射</h2><p><strong>次表面散射是一种复杂的现象，存在于具有高散射系数的固体材料中(详见9.1.4节)。这些材料包括蜡、皮肤和牛奶，如图592页的图14.2所示。</strong></p>
<p><strong>一般的光散射理论已在14.1节中解释。在某些情况下，散射的尺度相对较小，如对于光学深度较高的介质，如人类皮肤。散射光被重新发射从表面接近其最初的进入点。这种位置上的偏移意味着地下散射不能被模拟带有BRDF(章节9.9)。也就是说，当散射发生在大于一个像素的距离上时，其更全局的性质是明显的。必须使用特殊的方法来渲染这种效果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024150133.png" class="" title="image-20211024150133">

<p>通过物体散射的光。最初，射入物体的光以折射方向传播，但散射导致它反复改变方向，直到它消失离开了物质。通过材料的每条路径的长度决定了光因吸收而损失的百分比。</p>
<p><strong>上图显示光线通过物体散射。散射使入射光走许多不同的路径。由于单独模拟每个光子是不切实际的(即使是离线渲染)，这个问题必须用概率的方法来解决，通过对可能的路径进行积分或通过近似这样的积分。除了散射，光在这种材料中传播还会被吸收。</strong></p>
<p><strong>区别上图中不同光路的一个重要因素是散射事件的数量。对于某些路径，光在散射一次后离开物质;对于其他人，光被散射两次，三次，甚至更多。散射路径通常分为单散射和多次散射。每个组通常使用不同的渲染技术。对于某些材料来说，单次散射在总效应中是相对较弱的一部分，而多次散射则占主导地位，例如蒙皮。由于这些原因，许多次表面散射技术都侧重于模拟多次散射。在本节中，我们将介绍几种近似次表面散射的技术。</strong></p>
<h3 id="Wrap-Lighting-包裹照明"><a href="#Wrap-Lighting-包裹照明" class="headerlink" title="Wrap Lighting 包裹照明"></a>Wrap Lighting 包裹照明</h3><p><strong>也许最简单的次表面散射方法是包裹照明。382页讨论过这种近似面积光源的方法。当用于近似地下散射时，我们可以添加一个颜色移位。这计算了光通过这种材料时的部分吸收。例如，在渲染皮肤时，可以应用红色移位。</strong></p>
<p><strong>当以这种方式使用时，包裹照明试图在曲面的阴影上模拟多重散射的效果。光线从相邻的点“泄漏”到当前的着色点软化了从亮到暗的过渡区域，在那里表面弯曲远离光源。Kolchin指出，这种效应取决于表面曲率，他得出了一个基于物理的版本。尽管派生表达式的计算代价有点高，但其背后的思想是有用的。</strong></p>
<h3 id="Normal-Blurring-法线模糊"><a href="#Normal-Blurring-法线模糊" class="headerlink" title="Normal Blurring 法线模糊"></a>Normal Blurring 法线模糊</h3><p><strong>Stam指出，多重散射可以模拟为扩散过程。Jensen等人进一步发展了这一想法，推导了解析双向表面散射分布函数(BSSRDF)模型。BSSRDF是BRDF在全局次表面散射情况下的推广。扩散过程对出射亮度有空间模糊作用。</strong></p>
<p><strong>这种模糊只适用于漫反射。镜面反射发生在材料表面，不受次表面散射的影响。由于法线映射通常编码小规模的变化，一个有用的地下散射技巧是只对镜面反射应用法线映射。平滑的，无扰动的法线用于漫反射。由于不需要额外的成本，因此在使用其他地下散射方法时，通常值得应用这种技术。</strong></p>
<p><strong>对于许多材料，多次散射发生在一个相对较小的距离。皮肤是一个重要的例子，大多数散射发生在几毫米的距离。对于这类材料，不扰动漫反射线的技术本身可能就足够了。Ma等人在实测数据的基础上扩展了这种方法。他们确定了散射物体的反射光，并发现，虽然镜面反射是基于几何表面法线，但次表面散射使漫反射表现为使用模糊表面法线。此外，模糊的数量可以在可见光谱上变化。他们提出了一种实时着色技术，使用独立获取的法线贴图来获取镜面反射和漫反射的R、G和B通道。对每个通道使用不同的法线贴图会导致颜色出血。因为这些分散的法线贴图通常类似于镜面映射的模糊版本,直接修改该技术使用一个单一的法线贴图,调整产生的水平,但代价是失去正常以来颜色转变为每个通道都是一样的。</strong></p>
<h3 id="Pre-Integrated-Skin-Shading-预先集成的皮肤着色"><a href="#Pre-Integrated-Skin-Shading-预先集成的皮肤着色" class="headerlink" title="Pre-Integrated Skin Shading 预先集成的皮肤着色"></a>Pre-Integrated Skin Shading 预先集成的皮肤着色</h3><p><strong>Penner结合了包裹照明和法线模糊的想法，提出了一种预集成的皮肤阴影解决方案。</strong></p>
<p><strong>散射和透射被集成并存储在一个二维查找表中。LUT的第一个轴基于n·l索引，第二个轴为基于1/r =||∂n/∂p||索引，表示曲面曲率。曲率越高，对透射色和散射色的影响越大。因为每个三角形的曲率都是常数，所以这些值必须离线进行烘焙和平滑处理。</strong></p>
<p><strong>为了处理次表面散射对小表面细节的影响，Penner对Ma等人的技术进行了修正，该技术在前一节中讨论过。Penner没有为R、G和B的漫反射获取单独的法线贴图，而是根据每个颜色通道的地下材料的扩散剖面，模糊原始法线贴图来生成它们。由于使用四个独立的非普通映射是内存密集型的，作为优化，他使用一个平滑的普通映射每个颜色通道与顶点法线混合的映射。</strong></p>
<p><strong>这种技术将忽略光线在阴影边界的扩散，因为默认情况下它只依赖于曲率。为了使散射轮廓跨越阴影边界，可以使用阴影半影轮廓对LUT坐标进行偏置。因此，这种快速技术能够近似于下一节中提出的高质量方法。</strong></p>
<h3 id="Texture-Space-Diffusion-纹理空间扩散"><a href="#Texture-Space-Diffusion-纹理空间扩散" class="headerlink" title="Texture-Space Diffusion 纹理空间扩散"></a>Texture-Space Diffusion 纹理空间扩散</h3><p><strong>模糊的漫射法线解释了一些视觉效果的多重散射，但不为其他，如软化阴影边缘。纹理空间扩散的概念可以用来解决这些限制。这个想法是由Lensch等人作为另一种技术的一部分提出的，但Borshukov和Lewis提出的版本影响最大。他们将多重散射的概念形式化为模糊过程。首先，表面辐照度(漫射照明)被渲染成纹理。这是通过使用纹理坐标作为栅格化的位置来实现的。真实的位置被分别插入用于阴影。这个纹理是模糊的，然后在渲染时用于漫反射着色。滤光片的形状和大小取决于材料和波长。例如，对于皮肤，R通道使用比G或B更宽的过滤器进行过滤，导致阴影边缘附近变红。在大多数材料中，用来模拟次表面散射的正确滤波器在中心有一个狭窄的尖峰，底部宽而浅。该技术最初被提出用于离线渲染，但实时GPU实现很快被NVIDIA和ATI的研究人员提出。</strong></p>
<p><strong>d’Eon和Luebke的介绍代表了该技术最完整的处理方法之一，包括支持模拟多层次表面结构效果的复杂滤波器。Donner和Jensen指出，这种结构产生了最真实的皮肤效果图。由d’Eon和Luebke提供的完整的NVIDIA皮肤渲染系统产生了非常好的结果(参见下图为例)，但是非常昂贵，需要大量的模糊通道。但是，它可以很容易地缩减以提高性能。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024151502.png" class="" title="image-20211024151502">

<p>纹理空间多层扩散。六种不同的模糊使用RGB权重组合。最终的图像是这种线性组合加上一个高光项的结果。(图片由NVIDIA公司提供。)</p>
<p><strong>替代应用多个高斯通道，Hable提出了一个12样本核。过滤器可以应用于纹理空间作为预处理或在像素着色器时栅格在屏幕上的网格。这使得面部渲染非常多速度更快，但代价是一些现实主义。当靠近时，少量的采样可以成为可见的颜色带。然而，从一个中等的距离，质量的差异是不明显的。</strong></p>
<h3 id="Screen-Space-Diffusion-空间内扩散"><a href="#Screen-Space-Diffusion-空间内扩散" class="headerlink" title="Screen-Space Diffusion 空间内扩散"></a>Screen-Space Diffusion 空间内扩散</h3><p><strong>渲染光地图并模糊场景中的所有网格，无论是在计算上还是在内存上，都会很快变得非常昂贵。此外，网格需要渲染两次，一次在光图中，一次在视图中，光图需要有一个合理的分辨率，以便能够代表小规模细节的地下散射。</strong></p>
<p><strong>为了解决这些问题，Jimenez提出了一种屏幕空间方法。首先，场景像往常一样渲染，需要次表面散射的网格，例如人脸，将被记录在模板缓冲区中。然后，在存储的亮度上应用一个双通道屏幕空间过程来模拟地下散射，使用模板测试只在需要的地方应用昂贵的算法，在包含半透明材料的像素中。额外的通道应用两个一维和双边模糊图像，水平和垂直。彩色模糊核是可分离的，但由于两个原因，它不能以完全可分离的方式应用。首先，必须考虑线性视图深度，根据表面距离将模糊拉伸到正确的宽度。二是双向过滤，避免不同深度的材料漏光。在不应该相互作用的表面之间。此外，法线方向必须考虑到模糊过滤器不仅适用于屏幕空间，而且切向表面。最后，这使得模糊核的可分性近似，但仍然是高质量的。随后，提出了改进的可分离滤波器提出了。由于依赖于屏幕上的材料区域，这种算法对于脸部特写来说是昂贵的。然而，这一成本是合理的，因为在这些领域的高质量正是所需要的。当场景中有很多角色时，这种算法尤其有价值，因为他们将同时被处理。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024151825.png" class="" title="image-20211024151825">

<p>高质量的渲染扫描模型的脸。屏幕空间次表面散射使得在许多角色上使用一个后期处理渲染真实的人类皮肤材料成为可能。(左图:由萨拉戈萨大学Jorge Jimenez和Diego Gutierrez提供。扫描场地,XYZRGB Inc.的tesy。右图:由Jorge Jimenez等人、动视出版公司(Activision Publishing, Inc, 2013)和萨拉戈萨大学(universsidad de Zaragoza)提供。Lee Perry-Smith的《无限现实》提供了扫描。)</p>
<p><strong>为了进一步优化过程，可以将线性深度存储在场景纹理的alpha通道中。一维模糊依赖于少量的样本，因此在近距离观察面部时可以看到欠采样。为了避免这个问题，可以每像素旋转内核，这将隐藏带有噪声的重影伪影。这种噪声的可见性可以通过使用时间反锯齿显著降低(章节5.4.2)。当实现屏幕空间扩散时，必须注意只模糊辐照度而不是漫射反照率或镜面照明。实现这一目标的一种方法是将辐照度和镜面照明渲染到单独的屏幕空间缓冲中。如果使用了延迟着色(第20.1节)，那么已经有了漫反射的缓冲区。为了减少内存带宽，Gallagher和Mittring提出使用棋盘格模式在单个缓冲区中存储辐照度和镜面照明。在辐照度被模糊后，最终的图像是由漫反射的倍数合成的反照率与模糊的辐照度，并添加镜面照明在顶部。</strong>         </p>
<p><strong>在这个屏幕空间框架内，也可以渲染大规模的表面下散射现象，例如光通过鼻子或耳朵。呈现网状漫射照明时,提出的技术吉梅内斯等。还增加了地下传输从抽样入射光线沿墙的贡献从另一侧使用否定表面法线的-n。结果是调制的透光率值估计使用由采样深度恢复传统的阴影地图呈现从光的角度来看,同样到下一节介绍的Dachsbacher和Stamminger的方法。为了表示圆锥中的前向散射，可以对阴影图进行多次采样。为了使用每个像素较低的样本计数来降低渲染成本，可以使用每个像素随机偏移或旋转的两个阴影样本。这样做会产生很多不必要的视觉噪音。值得庆幸的是，这种噪声可以被实现半透明的亚表面光扩散所需的屏幕空间亚表面模糊内核自动免费过滤掉。因此，在每个光源只有一个额外的深度图样本的情况下，就有可能渲染高质量的半透明效果，模拟光在一个锥体中通过脸的薄部分的前向散射。</strong></p>
<h3 id="Depth-Map-Techniques-深度贴图技术"><a href="#Depth-Map-Techniques-深度贴图技术" class="headerlink" title="Depth-Map Techniques 深度贴图技术"></a>Depth-Map Techniques 深度贴图技术</h3><p><strong>到目前为止所讨论的技术模拟的是相对较小距离的光散射，例如，皮肤。对于表现出大规模散射的材料，例如光通过手的传播，还需要其他的技术。其中许多聚焦于单次散射，这比多次散射更容易建模。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024152702.png" class="" title="image-20211024152702">

<p>左边是光线进入和离开物体时发生折射的理想状态;所有在离开物体时会适当折射的散射贡献都是通过在材料内行进的光线正确收集的。每个路径的长度将被计算评估灭绝σt。这可以通过路径跟踪或一些实时近似来实现。中间的图像显示了一种计算上更简单的情况，光线只在出射时折射。这是在实时渲染中通常做的近似，因为根据折射，从样本点(黄色)找到入口点(红色)并不简单。右图显示的是一个近似值，因此它更快，这里只考虑一条射线，而不是沿着折射射线的多个样本。</p>
<p><strong>在上图的左边可以看到大尺度单次散射的理想模拟。由于折射，光路在进入和离开物体时改变方向。所有路径的效果需要相加，以阴影一个单一的表面点。吸收也需要考虑在内——路径上的吸收量取决于它在材料内部的长度。即使对离线渲染器来说，计算单个阴影点的所有这些折射光线也很昂贵，所以通常忽略进入材料时的折射，只考虑出材料时方向的变化。由于光线投射总是在光线的方向上，Hery指出，通常用于阴影的光空间深度映射可以被访问，而不是执行光线投射。见上图的中间部分。对于按相位函数散射光的介质，散射角也影响散射光的量。</strong></p>
<p><strong>执行深度图查找比光线投射快，但是需要多个样本使得Hery的方法对于大多数实时渲染应用程序来说太慢。Green提出了一种更快的近似方法，如上图所示。尽管这种方法不是基于物理的，但它的结果是令人信服的。一个问题是，物体背面的细节可以显示出来，因为物体厚度的每一个变化都会直接影响着色颜色。尽管如此，格林的近似法还是非常有效，足以被皮克斯用于制作《料理鼠王》(Ratatouille)等电影。皮克斯将这种技术称为gummi lights。Hery实现的另一个问题是深度图不应该包含多个对象，或者高度非凸的对象。这是因为我们假设在阴影点(蓝色)和交点(红色)之间的整个路径都在物体内部。皮克斯通过使用一种深度阴影地图来解决这个问题。</strong></p>
<p><strong>实时建模大尺度多次散射是相当困难的，因为每个表面点都可能受到来自任何其他表面点的光的影响。Dachs- bacher和Stamminger提出了阴影映射的扩展，称为分阴影映射，用于建模多重散射。其他信息，如辐照度和表面法线，存储在光空间纹理中。从这些纹理中提取几个样本，包括深度图，并结合起来形成散射辐亮度的估计。NVIDIA的皮肤渲染系统使用了一种改进的技术。Mertens等人提出了类似的方法，但在屏幕空间中使用纹理而不是光空间。</strong>     </p>
<p><strong>树上的叶子也表现出强烈的次表面散射效应，当光线从后面射入时呈现出明亮的绿色。除了反照率和普通纹理，还有一个纹理代表透射率Tr 通过叶卷可以映射到表面上。然后，一个特别的模型可以用来近似来自光的额外地下贡献。由于叶片是薄元素，负法线可用作对边法线n的近似。背光贡献可计算为(l•-n)+•(-v•l)+，其中l为光方向，v为视图方向。然后，它可以与表面反照率相乘，并添加到直接光的贡献之上。</strong></p>
<p><strong>以类似的方式，Barr´e-Brisebois和Bouchard出了一种廉价的、特别的网格大规模次表面散射近似方法。首先，对于每个网格，它们生成一个存储平均局部厚度的灰度纹理，即1减去从面向内的法向量−n计算的环境遮挡。这种纹理叫做tss，被认为是一个近似的透光率，可以应用于从表面的另一边来的光。次表面散射添加到常规表面照明的评估为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024153223.png" class="" title="image-20211024153223">

<p><strong>其中l和v分别是归一化的光和视图向量，p是近似相位函数的指数(如图599页的图14.10所示)，css 为地下反照率。然后将这个表达式与光的颜色、强度和距离衰减相乘。这个模型不是基于物理或节能，但它能够快速渲染看似合理的地下照明效果在一次通过。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024153302.png" class="" title="image-20211024153302">

<p>在左边，为Hebe雕像生成的局部厚度纹理。中间是用它可以达到的次表面光散射效果。在右边，另一个使用相同技术渲染的半透明立方体场景。(图片由Colin Barr´e-Brisebois和<br>马克·布沙尔)。</p>
<h2 id="Hair-and-Fur-头发和毛发"><a href="#Hair-and-Fur-头发和毛发" class="headerlink" title="Hair and Fur 头发和毛发"></a>Hair and Fur 头发和毛发</h2><p><strong>毛发是从哺乳动物的真皮层中生长出来的蛋白质丝。就人类而言，头发分散在身体的不同部位，包括头顶、胡须、眉毛和睫毛。其他哺乳动物通常被皮毛覆盖(密集的、长度有限的毛发)，动物身体不同部位的皮毛属性往往不同。头发可以是直的、波状的或卷曲的，每一种都有不同的强度和粗糙度。发缕可以是自然的黑色、棕色、红色、金色、灰色或白色，并且可以染成(不同的成功)彩虹的所有颜色。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025132823.png" class="" title="image-20211025132823">

<p>一根头发的纵向切割，呈现出不同的材料组成它，以及沿着方向ω入射光产生的照明组件ωi．</p>
<p><strong>毛发和皮毛的结构基本相同。由三层组成，如上图所示:</strong></p>
<pre><code>**•外面是角质层，代表纤维的表面。这个表面不是光滑的，而是由倾斜约为α = 3◦的重叠鳞片组成与头发的方向相比，头发的方向是向根部倾斜的。**

**•中间是皮层，含有黑色素，使纤维具有颜色。其中一种色素是真黑色素，表示棕色用σa,e  =(0.419, 0.697, 1.37)，另一种是褐黑素，表示红发用σa,p =(0.187, 0.4, 1.05)。**

**•内部是髓质。它很小，在建模人类头发时经常被忽略。然而，它在动物皮毛中占毛体积的比例较大，具有更大的意义。**
</code></pre>
<p><strong>我们可以把头发纤维看作类似于粒子的东西，看作是体积的离散化，但是用曲线代替点。用双向散射分布函数(BSDF)描述了头发纤维的光相互作用。这相当于一个BRDF，但是光在一个球体上积分，而不仅仅是一个半球。BSDF通过不同的纤维层聚集了发生在头发纤维内部的所有相互作用。在14.7.2节中有详细描述。光在纤维中散射，但也会从许多纤维中反弹，从而产生复杂的彩色辐射。此外，由于纤维吸收光作为其材料和色素的功能，它也很重要的代表体积的自我阴影，发生在头发体积。在这一节中，我们将描述最近的技术如何允许我们渲染短头发，如胡须，头发，最后，毛皮。</strong></p>
<h3 id="Geometry-and-Alpha-几何和Alpha"><a href="#Geometry-and-Alpha-几何和Alpha" class="headerlink" title="Geometry and Alpha 几何和Alpha"></a>Geometry and Alpha 几何和Alpha</h3><p><strong>头发线可以被渲染为挤压的头发四边形使用顶点着色器代码周围的头发引导曲线由艺术家绘制，产生了一条丝带的四边形遵循指导。每个四色丝带遵循其匹配的头发引导曲线，根据皮肤和代表一团头发的指定方向。这种方法非常适合胡须或短而静态的头发。它也是有效的，因为大的四边形可以导致更多的视觉覆盖，因此更少的丝带将需要覆盖头部，这反过来提高了性能。如果需要更多的细节，例如在物理模拟的细长长发的情况下，它是可能使用更细的四带和渲染数以千计的他们。在这种情况下，最好也使用沿着头发曲线切线的圆柱体约束来将生成的四边形朝向视图。即使头发模拟只使用了一些头发指南，新的头发也可以通过插入周围头发指南的属性来实例化。</strong></p>
<p><strong>所有这些元素都可以被渲染为阿尔法混合几何体。如果使用，头发的排列顺序必须正确，以避免出现透明的伪影(第5.5节)。为了缓解这个问题，可以使用预先排序的索引缓冲区，将靠近头部的头发重新排序，最后再将外层头发重新排序。这种方法对于短而无生气的头发很有效，但对于交错而有生气的长发就不适用了。依靠深度测试来修复排序问题可以使用alpha测试。然而，这可能导致高频几何和纹理严重的混叠问题。可以使用MSAA，对每个样本进行alpha测试，但要付出额外的样本和内存带宽的代价。另外，也可以使用任意顺序无关的透明方法，例如在第5.5节中讨论的方法。例如，TressFX存储k = 8最近的片段，更新在像素着色器中，以保持仅前7层有序，从而实现多层 alpha混合。</strong></p>
<p><strong>另一个问题是由mmap alpha小型化产生的alpha测试工件(章节6.6)。解决这个问题的两种方法是执行更智能的alpha mipmap生成或使用更高级的哈希alpha测试。当染细长发时，也可以根据它的像素覆盖来修改头发的不透明度。</strong></p>
<p><strong>像胡须、睫毛和眉毛这样的小头发比整头的头发更容易渲染。睫毛和眉毛甚至可以是几何形状的皮肤，以匹配头部和眼睑的运动。这些小元素上的毛发表面可以使用不透明的BRDF材料照明。也可以通过使用BSDF来遮蔽发丝，如下节所述。</strong></p>
<h3 id="Hair-头发"><a href="#Hair-头发" class="headerlink" title="Hair 头发"></a>Hair 头发</h3><p><strong>Kajiya和Kay开发了BRDF模型，以渲染由组织和无限小的圆柱形纤维组成的体积。这个模型，在9.10.3节中讨论，最初是通过光线穿过一个表示表面上密度的体纹理来渲染毛茸茸的元素。BRDF用于表示高射光和漫射光响应与体积，也可以用于头发。</strong></p>
<p><strong>Marschner等人的开创性工作测量了人类头发纤维中的光散射，并基于这些观察提出了一个模型。在一根发丝中观察到不同的散射成分。这些都在上图中描述。首先，一个R分量表示光在角质层的空气/纤维界面的反射，这导致白色镜面峰向根方向偏移。第二，TT分量表示光通过头发纤维的传播，一次从空气传输到头发材料，第二次从头发传输到空气。最后，第三个TRT组件表示光在头发纤维中通过被传输，被纤维的另一侧反射，然后传输回毛发材料之外。变量名中的“R”表示一个内部反射。TRT组件被认为是一个次级镜面高光，与R相比发生了偏移，并且由于光在穿过纤维材料时被吸收而被着色。</strong></p>
<p><strong>视觉上，R分量被认为是头发上无色的镜面反射。当大量头发从后面被点燃时，TT组件被认为是一个明亮的高光。TRT组件是至关重要的渲染现实的头发，因为它将导致闪烁的头发与偏心，即。在现实生活中，头发的横截面不是一个完美的圆形，而是一个椭圆形。闪光对于可信度很重要，因为这会让头发看起来不一样。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025133608.png" class="" title="image-20211025133608">

<p>路径跟踪参考金色(左)和棕色(右)头发渲染的高光闪烁导致纤维偏心。(图片由d ‘Eon等人提供。)</p>
<p><strong>Marschner等人提出了将R、TT和TRT组件分别作为毛发BSDF的一部分进行功能建模，该BSDF代表了毛发纤维对光的响应。该模型恰当地考虑了透射和反射时的菲涅耳效应，但忽略了其他更复杂的光路，如TRRT、TRRRT和更长的光路。</strong></p>
<p><strong>然而，这个原始模型并不是节能的。这已经在d ‘Eon等人的工作中进行了研究和确定。通过更好地考虑粗糙度和镜面锥的收缩，对BSDF组件进行了改进，从而节约了能量。组件也被扩展到包括更长的路径，如TR*T。透过率也通过测量黑色素消光系数来控制。与Marschner等人的工作类似，他们的模型能够忠实地渲染带有偏心的线上的闪烁。Chiang等人提出了另一种节能模型。这个模型提供了粗糙度和多重散射颜色的参数化，这对艺术家来说更直观，而不是让他们调整高斯方差或黑色素浓度系数。</strong></p>
<p><strong>艺术家可能想要在角色的头发上创建一个特殊的高光术语，例如，通过改变粗糙度参数。通过物理上的能量守恒和能量守恒模型，散射光在头发的体积也会发生变化。为了更好的艺术控制，可以将前几个散射路径(R, TT, TRT)和多个散射部分分开。这是通过保持第二组BSDF参数来实现的，仅用于多个散射路径。此外，BSDF R、TT和TRT组件可以用简单的数学形状表示，艺术家可以理解并调整这些形状，以进一步优化外观。根据输入和输出方向对BSDF进行归一化，使整套系统仍然保持节能。</strong></p>
<p><strong>上面给出的每个BSDF模型都很复杂，评估成本很高，并且大多用于电影制作路径跟踪环境。值得庆幸的是，存在实时版本。Scheuermann提出了一种特别的BSDF模型，该模型易于实现，渲染速度快，并且在将头发渲染为大的四束缎带时看起来很有说服力。更进一步，可以通过将BSDF存储在LUT纹理中(由进方向和出方向索引)作为参数来实时使用Marschner模型。然而，这种方法很难渲染具有空间变化外观的头发。为了避免这个问题，最近一个基于物理的实时模型用简化的数学方法近似了以前工作中的组件，以获得令人信服的结果。参见下图。然而，与离线结果相比，所有这些实时头发渲染模型的质量存在差距。简化算法通常不具有高级的体积阴影或多重散射。这种效果对于吸收率低的头发尤其重要，比如金发。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025133911.png" class="" title="image-20211025133911">

<p>实时毛发渲染与R, TT，和TRT，以及多重散射组件。(图片来源:Epic Games, Inc.)</p>
<p><strong>在体积阴影的情况下，最近的解决方案依赖于一个透过率值，使用d作为沿光方向从第一根头发接触到当前光纤的距离，根据恒定的吸收计算σa．这种方法是实用和直接的，因为它依赖于在任何引擎中可用的通常阴影贴图。然而，它不能代表由于头发聚集而导致的局部密度变化，这对明亮的头发尤其重要。参见下图。来为了解决这个问题，可以使用体积阴影表示(章节7.8)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025134120.png" class="" title="image-20211025134120">

<p>左:使用与第一个遮光器不同的深度和恒定的消光系数会导致体积阴影过于平滑。中间:使用深阴影图可以实现更多的透射变化，匹配毛发聚集在一起的方式在头发体积内。右图:基于到第一个遮挡器的距离，将深阴影贴图与PCSS相结合，可以获得更平滑的体度量阴影(详见第7.6节)。(图片由USC-HairSalon提供的头发模型渲染。)</p>
<p><strong>当渲染头发时，多重散射是一个昂贵的术语。适合实时实现的解决方案并不多。Karis提出了一个近似多次散射的方法。这个特别的模型使用假法线(类似于弯曲法线)，缠绕漫射照明，头发的基本颜色提高到深度依赖的功率之前，它与照明相乘，在光线分散通过许多股后接近颜色饱和度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025134237.png" class="" title="image-20211025134237">

<p>前两幅图像呈现的头发使用路径跟踪作为三个头发散射组件(R, TT, TRT)的参考，然后添加了多重散射。最后两幅图像采用双散射近似:轨迹跟踪，然后在GPU上实时渲染。(图片由Arno Zinke和Cem Yuksel提供)</p>
<p><strong>Zinke等人提出了一种更先进的双散射技术。参见上图。它是双重的，因为它根据两个因素来评估散射光的数量。第一，全局透射系数Ψ^G 结合被阴影像素与光线位置之间遇到的每根发丝的BSDF进行评估。因此, Ψ^G给出在阴影位置入射辐射的透射率。这个值可以在GPU上通过计算头发的数量和计算光路径上的平均线方向来计算，后者会影响BSDF和透光率。这些数据的累积可以使用深度不透明度映射或占用地图来实现。第二，局部散射分量 Ψ^L 近似地说明在阴影位置的透射辐亮度将分散在电流周围的毛发纤维中并对辐亮度作出贡献。这两个术语都被添加为Ψ^G + Ψ^G Ψ^L 并通过像素链BSDF馈入，积累光源贡献。这种技术更昂贵，但它是一个准确的实时近似光多重散射现象在头发体积。它也可以用于本章介绍的任何BSDFs。</strong></p>
<p><strong>环境照明是另一个复杂的输入，以评估动画半透明材料。简单地从球面谐波中取样辐照度是很常见的。照明也可以通过非定向预集成的双向闭塞计算从头发在其休息位置。用同样的假对于多重散射，Karis提出了一种特别的环境照明模型。</strong></p>
<p><strong>欲了解更多信息，Yuksel和Tariq提供了一个全面的实时头发绘制课程。在阅读研究论文和学习更多细节之前，本课程将教你所有关于头发渲染的许多领域，如模拟，碰撞，几何，BSDF，多重散射，和体积阴影。头发在实时应用中看起来很有说服力。然而，仍然需要大量的研究来更好地逼近物理环境照明和头发中的多重散射。</strong></p>
<h3 id="Fur-皮毛"><a href="#Fur-皮毛" class="headerlink" title="Fur 皮毛"></a>Fur 皮毛</h3><p><strong>与毛发不同，皮毛通常被认为是短而半有组织的，通常是在动物身上发现的。与使用纹理层进行体绘制方法相关的一个概念是体纹理，它是由二维、半透明纹理层表示的体描述。</strong></p>
<p><strong>例如，Lengyel等人使用一组8种纹理来代表表面上的皮毛。每个纹理代表了从表面给定距离通过一组毛发的切片。模型被渲染了8次，每次都用一个顶点着色程序沿着顶点法线向外移动每个三角形。通过这种方法，每个连续的模型都描绘了地表以上不同的高度。以这种方式创建的嵌套模型称为shell。这种渲染技术沿着物体轮廓的边缘分解，因为毛发随着层的扩散而分解成点。为了隐藏这个人工制品，皮毛也通过在轮廓边缘生成的鳍上应用不同的头发纹理来表示。参见下图和图19.28。轮廓鳍挤压的想法可以用于创建其他类型的模型的视觉复杂性。例如，Kharlamov等人使用鳍和地形映射来提供具有复杂轮廓的树网格。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025134727.png" class="" title="image-20211025134727">

<p>毛皮使用体积纹理。模型被渲染了8次，每次经过时表面向外扩张少量。左边是八次传球的结果。注意头发的轮廓。中间是鳍的渲染图。右边是最终渲染，使用鳍和壳。(图片来自NVIDIA SDK 10样本“毛皮外壳和鳍”，由NVIDIA公司提供。)</p>
<p><strong>几何着色器的引入使得用皮毛挤压表面的polyline毛发成为可能。《失落的星球》使用了这种技术。表面被渲染，值被保存在每个像素上:毛皮颜色、长度和角度。几何着色器然后处理这个图像，把每个像素变成半多边形-父折线。通过创建每个像素覆盖一根头发，细节水平自动保持。毛皮渲染分两步进行。在屏幕空间中指向下方的皮毛首先呈现，从屏幕底部到顶部排序。通过这种方式，混合被正确地执行，从后到前。在第二步中，剩下的毛发从上到下被渲染，再次正确地混合。随着GPU的发展，新技术成为可能并有利可图。</strong></p>
<p><strong>也可以使用前面几节中介绍的技术。股可以被渲染为四边形挤压作为几何体从一个皮肤表面，如星球大战前线游戏中的楚巴卡或TressFX鼠演示。Ling-Qi等人在将发丝描绘成细丝时证明，仅仅将头发模拟成均匀的圆柱体是不够的。对于动物的皮毛，髓质相对于毛发半径要深得多，也大得多。这减少了光散射的影响。因此，提出了一种双圆柱纤维BSDF模型，可以模拟更大范围的毛发和毛皮。它考虑了更详细的路径，如TttT、TrRrT、TttRttT等等，其中小写字母表示与髓质的交互。这种复杂的方法会产生更逼真的视觉效果，特别是对粗糙皮毛和精细的散射效果的模拟。这样的皮毛呈现技术包括许多链实例的栅格化，任何有助于减少渲染时间的方法都是受欢迎的。Ryu[1523]提出，根据运动幅度和距离，将大量的链实例渲染为一个细节级别方案。这种方法被用于离线电影渲染，在实时应用中似乎很容易应用。</strong></p>
<h2 id="Unified-Approaches-统一的方法-1"><a href="#Unified-Approaches-统一的方法-1" class="headerlink" title="Unified Approaches 统一的方法"></a>Unified Approaches 统一的方法</h2><p><strong>我们已经达到了一个点，体积渲染已经成为负担得起的实时应用。在未来可能实现什么?</strong></p>
<p><strong>在本章的开头，我们说过“一切都是分散的”。“看看参与的介质材料，有可能使用高散射系数σs 以实现不透明的媒介。这，加上复杂的各向异性相位函数驱动漫反射和镜面反射，将导致不透明的表面材料。鉴于此，是否有一种方法来统一实体和体积材料表示?</strong></p>
<p><strong>到今天为止，体积渲染和不透明材质渲染是分开的，因为GPU当前的计算能力迫使我们使用特定的方法，在某些用例中是有效的。我们为不透明的表面使用网格，为透明材料使用阿尔法混合网格，为烟雾量使用粒子广告牌，为参与媒体中的一些体积照明效果使用光线行进。</strong></p>
<p><strong>正如Dupuy等所暗示的，使用统一的表示来表示实体和参与的媒体是可能的。一种可能的表示方法是使用对称GGX (SGGX)，它是9.8.1节中给出的GGX正态分布函数的扩展。在这种情况下，微片理论表示在一个体积内的定向片粒子取代microfacet理论用于表面正态分布表示。从某种意义上说，与网格相比，细节级别将变得更加实用，因为它可以简单地成为对材料属性的体积过滤。这可能导致更连贯的照明和大细节世界的表现，同时保持照明，形状，遮挡，或应用在背景上的透光率。例如,如下图,呈现一片森林与体积过滤树表示将消除可见树网LOD切换,提供一个平滑滤波的薄几何和避免混叠树枝造成的,同时也提供正确的闭塞价值的背景考虑底层树几何在每个体素。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025134947.png" class="" title="image-20211025134947">

<p>在顶部使用SGGX渲染的森林，从左到右的细节层次减少。底部部分显示了未经过滤的原始体素。(图片由Eric Heitz等人提供。)</p>
<h1 id="15-Non-Photorealistic-Rendering-非真实渲染"><a href="#15-Non-Photorealistic-Rendering-非真实渲染" class="headerlink" title="15 Non-Photorealistic Rendering 非真实渲染"></a>15 Non-Photorealistic Rendering 非真实渲染</h1><p><strong>真实感渲染是指使图像与照片难以区分。非真实感渲染(NPR)，也称为风格化渲染，有广泛的目标。某些形式的NPR的一个目标是创建类似于技术插图的图像。只有那些与特定应用程序的目标相关的细节阳离子是应该显示的。例如，在向客户销售汽车时，一张闪亮的法拉利引擎的照片可能很有用，但要修复引擎，一张带有相关部件的简化线条图可能更有意义(打印成本也更低)。</strong></p>
<p><strong>NPR的另一个领域是模拟绘画风格和自然媒体，如钢笔和墨水，木炭和水彩。这是一个巨大的领域，它允许自己拥有同样巨大的各种算法，试图捕捉各种媒体的感觉。下图中显示了一些示例。两本较老的书提供了技术上和绘画上的NPR算法的覆盖。考虑到这一广度，我们将重点放在绘制笔画和线条的技术上。我们的目标是实时给出一些用于NPR的算法。本章以详细讨论实现卡通渲染风格的方法开始，然后讨论NPR领域中的其他主题。本章以各种线绘制技术结束。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026133638.png" class="" title="image-20211026133638">

<p>应用于咖啡研磨机的各种非逼真的渲染风格。(使用LiveArt从Viewpoint DataLabs生成。)</p>
<h2 id="Toon-Shading-卡通阴影"><a href="#Toon-Shading-卡通阴影" class="headerlink" title="Toon Shading 卡通阴影"></a>Toon Shading 卡通阴影</h2><p><strong>就像不同的字体会给文本带来不同的感觉一样，不同的渲染风格也有自己的情绪、含义和词汇。有一个特别形式的NPR, cel或卡通渲染已经给予了大量的关注。由于这种风格被认为是卡通风格，它有幻想和童年的内涵。最简单的方法是，用实线将不同的纯色区域分隔开来。这种风格流行的一个原因是McCloud在他的经典著作《理解漫画》中所说的“简化放大”。通过简化和剔除杂乱，人们可以放大与演示相关的信息的效果。对于卡通人物，更广泛的观众会认同那些风格简单的人物。</strong></p>
<p><strong>卡通渲染风格已经在计算机图形学中使用了几十年，用于集成三维模型和二维cel动画。与其他NPR风格相比，它易于定义，因此很适合计算机自动生成。许多电子游戏都很好地利用了它。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026134145.png" class="" title="image-20211026134145">

<p>一个来自游戏Okami的实时NPR渲染的例子。(图片来源:Capcom Entertainment, Inc.)</p>
<p><strong>物体的轮廓通常用黑色渲染，这样可以放大卡通的效果。寻找和渲染这些轮廓将在下一节中处理。有几种不同的方法来处理椿象表面的阴影。两种最常见的方法是用纯色(非光照)填充网格区域，或者使用双色调方法，代表光照和阴影区域。双色方法，有时称为硬着色，是简单地在像素着色器中执行，当着色法和光源方向的点积高于某个值时使用较浅的颜色，如果不是，则使用较深的色调。当光照较复杂时，另一种方法是对最终图像本身进行量化。也称为色调转换，这是一个过程，取一个连续的值范围，并转换为几个色调，每个色调之间有一个急剧的变化。参见下图。量化RGB值会导致不愉快的色调变化，因为每个单独的通道的变化方式与其他的不密切相关。工作的色调,保留颜色空间，如HSV、HSL或Y’cbcr是更好的选择。或者，可以定义一维函数或纹理，将强度级别重新映射到特定的色调或颜色。纹理也可以使用量化或其他过滤器进行预处理。665页的图15.16显示了另一个带有更多颜色级别的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026134331.png" class="" title="image-20211026134331">

<p>左边的基本渲染依次使用了实填充、色调分离和铅笔着色技术。(Quidam的Jade2模型，wismo发布，Creative Commons 2.5署名许可。)</p>
<p><strong>Barla等人通过使用二维地图代替一维阴影纹理来添加依赖视图的效果。第二个维度是通过表面的深度或方向来获得的。例如，当远处或快速移动时，这允许物体平滑地软化对比。这种算法，结合各种其他阴影方程和绘制纹理，被用于游戏《军团要塞2》中，以混合卡通和现实风格。卡通着色器的变化可以用于其他目的，如在表面或地形上可视化特征时夸大对比。</strong></p>
<h2 id="Outline-Rendering-轮廓渲染"><a href="#Outline-Rendering-轮廓渲染" class="headerlink" title="Outline Rendering 轮廓渲染"></a>Outline Rendering 轮廓渲染</h2><p><strong>用于cel边缘绘制的算法反映了NPR的一些主要主题和技术。我们在这里的目标是提出一种算法，为该领域提供一种风味。使用的方法可以大致分为基于表面阴影、程序几何、图像处理、几何边缘检测或这些的混合方法。</strong></p>
<p><strong>有几种不同类型的边缘可以在卡通渲染中使用:</strong> </p>
<pre><code>**•边界或边沿不是两个三角形共用的，例如一张纸的边沿。实心物体通常没有边界边。 **

**•折痕、硬边或特征边是两个三角形共享的边，两个三角形之间的角(称为二面角)大于某个预定义值。一个好的默认折痕角是60度。例如，一个立方体有折痕边。折痕边可以进一步细分为脊边和谷边。**

**•当共享材质的两个三角形材质不同或导致材质变化时，材质边就会出现。它也可以是艺术家希望一直显示的一条边，例如，额头的线条或分隔同一颜色的裤子和衬衫的线条。**

**•轮廓边是两个相邻三角形相对于某个方向向量(通常是来自眼睛的方向向量)面向不同方向的边。** 

**•轮廓边是沿着物体轮廓的轮廓边，即它将物体从图像平面的背景中分离出来。** 
</code></pre>
<p><strong>参见下图。这种分类是基于文献中的常见用法，但也有一些变化，例如，我们称为折痕和材料边有时被称为边界边。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026134917.png" class="" title="image-20211026134917">

<p>顶部打开的盒子，正面有条纹。边界(B)，折痕(C)，材料(M)和轮廓(S)边缘显示。在给定的定义中，没有一条边界边被认为是剪影边，因为这些边只有一个相邻的多边形。</p>
<p><strong>我们在这里区分轮廓边和轮廓边。两者都是沿着表面的一部分面向观察者，另一部分面向外的边缘。轮廓边是轮廓边的子集，轮廓边将物体从另一个物体或背景中分离出来。例如，在头部的侧视图中，耳朵形成轮廓边缘，即使它们出现在头部轮廓内。上上图中的其他例子包括鼻子、两个弯曲的手指和毛发部分。在一些早期的文献中，等高线边缘被称为轮廓，但等高线边缘的全部类别通常是指。此外，等高线边缘不应与地形图上使用的等高线混淆。</strong></p>
<p><strong>请注意，边界边与轮廓边或剪影边不同。轮廓线和剪影边由视图方向定义，而边界边与视图无关。暗示性轮廓是由几乎是原始视点轮廓的位置构成的。它们提供额外的边来帮助传达物体的形状。参见下图。而我们这里的重点主要是检测-轮廓边缘的绘制和绘制，已经为其他类型的笔画做了大量的工作。我们还主要关注于为多边形模型寻找这样的边。B´enard等人讨论了寻找由细分曲面或其他高阶定义组成的模型轮廓的方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026135148.png" class="" title="image-20211026135148">

<p>从左到右:轮廓、轮廓、轮廓以及暗示性轮廓边缘。(图片由Doug DeCarlo、Adam Finkelstein、Szymon Rusinkiewicz和Anthony Santella提供。)</p>
<h3 id="Shading-Normal-Contour-Edges-着色法线轮廓边缘"><a href="#Shading-Normal-Contour-Edges-着色法线轮廓边缘" class="headerlink" title="Shading Normal Contour Edges 着色法线轮廓边缘"></a>Shading Normal Contour Edges 着色法线轮廓边缘</h3><p><strong>类似于第15.1节中的表面着色器，着色法线和眼睛方向之间的点积可以用来给出轮廓边缘。如果这个值接近于零，那么该表面几乎是与眼睛的边缘重合，因此很可能接近轮廓边缘。将这些区域涂成黑色，随着点积的增加逐渐变为白色。参见下图。在可编程着色器之前，该算法是使用带有黑色环的球形环境地图实现的，或将mipmap金字塔纹理的最顶层着色为黑色。今天这种类型的着色是直接在像素着色器中实现的，当屏幕法线变得垂直于视图方向时变为黑色。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026135529.png" class="" title="image-20211026135529">

<p>轮廓边缘的阴影通过暗表面，因为它的阴影法线成为垂直于视图方向。通过扩大跌落角，显示较厚的边缘。(图片由肯尼霍夫提供。)</p>
<p><strong>这种阴影在某种意义上与边缘照明相反，边缘照明照亮物体的轮廓;在这里，场景从眼睛的位置照明，下降是夸张的，使边缘变暗。它也可以被认为是图像处理中的阈值过滤器，当图像表面低于一定强度时，图像被转换为黑色，否则转换为白色。</strong></p>
<p><strong>这种方法的一个特点或缺点是，等高线的宽度是可变的，取决于曲面的曲率。这种方法适用于没有折痕边缘的曲面模型，例如，沿着轮廓的区域，通常会有法线指向几乎垂直于视图方向的像素。</strong></p>
<p><strong>该算法在模型上失败，如立方体，因为表面面积附近的折痕边缘将没有这个性质。即使在曲面上，它也会破裂，看起来也很糟糕，因为当物体距离较远时，轮廓边缘附近的一些法线采样可能不是几乎垂直的。Goodwin等人注意到这个基本概念作为视觉线索是如何有效的，并讨论了如何结合光照、曲率和距离来确定笔画厚度。</strong></p>
<h3 id="Procedural-Geometry-Silhouetting-程序几何轮廓"><a href="#Procedural-Geometry-Silhouetting-程序几何轮廓" class="headerlink" title="Procedural Geometry Silhouetting 程序几何轮廓"></a>Procedural Geometry Silhouetting 程序几何轮廓</h3><p><strong>最早的实时轮廓边缘绘制技术之一是由Rossignac和van Emmerik提出的，后来由Raskar和Cohen提炼出来。一般的想法是渲染正面正常，然后渲染背面的方式，使他们的轮廓边缘可见。呈现这些背面有各种各样的方法，每种方法都有自己的优点和缺点。每个方法的第一步都是绘制正面。然后打开正面剔除，关闭背面剔除，这样只渲染背面。</strong></p>
<p><strong>渲染轮廓的一种方法是只绘制背面的边缘(而不是正面)。使用偏倚或其他技术(第15.4节)确保有些线恰好画在正面的前面。这样，只有正面和背面的边缘是可见的。</strong></p>
<p><strong>使这些线条更宽的一种方法是将背面自己渲染成黑色，同样是向前倾斜。Raskar和Cohen给出了几种偏倚方法，如按固定的量进行平移，或按补偿z-depth非线性性质的量进行平移，或使用深度-斜率偏差调用，如OpenGL的glPolygonOffset。Lengyel讨论了如何通过修改透视矩阵来提供更精细的深度控制。所有这些方法的一个问题是，它们不能创建宽度一致的线条。要做到这一点，向前移动的量不仅取决于背面，也取决于相邻的正面。参见下图。背面的斜度可以用来使多边形向前倾斜，但线条的粗细也取决于正面的角度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026140052.png" class="" title="image-20211026140052">

<p>轮廓的z偏置方法，通过将背面向前平移来完成。如果正面是在不同的角度，如右图所示，不同数量的背面是可见的。(Raskar和Cohen的插图。)</p>
<p><strong>Raskar和Cohen解决了这个邻居依赖问题，方法是将每个背面三角形沿其边缘增粗，以确保看到一条始终很粗的线。也就是说，三角形的斜率和与观察者的距离决定了三角形的扩展程度。一种方法是将每个三角形的三个顶点沿其平面向外展开。绘制三角形的一种更安全的方法是将三角形的每条边向外移动并连接这些边。这样做可以避免让顶点远离原始三角形。参见下图。注意，这种方法不需要偏移，因为后面的面扩展到前面面的边缘之外。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026140212.png" class="" title="image-20211026140212">

<p>三角形边缘增粗。在左边，背面三角形沿其平面展开。每个边缘在世界空间中移动不同的数量，从而使结果边缘在屏幕空间中具有相同的厚度。对于细三角形来说，当一个角被拉长时，这种方法就失效了。在右侧，将三角形的边展开并连接，形成斜接角，避免了这个问题。</p>
<p><strong>三种方法的结果见下图。这种增肥技术更具可控制性和一致性，并已成功应用于《波斯王子》和《非洲武士》等电子游戏中的角色轮廓。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026140326.png" class="" title="image-20211026140326">

<p>使用厚线、z偏斜和增厚三角形算法绘制的背面边缘渲染轮廓边缘。由于小特征上的偏置问题，背面边缘技术使线之间的连接差和不均匀的线。由于依赖于正面的角度，z偏置技术给出了非均匀的边宽。(图片由Raskar和Cohen提供。)</p>
<p><strong>在刚才给出的方法中，背面三角形沿原平面展开。另一种方法是通过沿共享顶点法线移动它们的顶点向外移动，并与它们到眼睛的z-距离成比例。这被称为外壳或光晕方法，因为移动的背面形成外壳围绕原始对象。想象一个球体。正常渲染球体，然后扩展球体半径，相对于球体的中心宽度为5像素。也就是说，如果移动球体的中心一个像素相当于在世界空间中移动3毫米，那么将球体的半径增加15毫米。只渲染这个扩展版本的背面为黑色。轮廓边缘宽度为5像素。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026140503.png" class="" title="image-20211026140503">

<p>三角形壳技术通过沿顶点法线移动曲面来创建第二个曲面。</p>
<p><strong>对顶点着色器来说，沿着法线向外移动顶点是一个完美的任务。这种类型的展开有时被称为shell映射。该方法实现简单，效率高，鲁棒性好，性能稳定。参见下图。力场或晕轮效应可以通过进一步扩大和阴影这些背面取决于他们的角度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026140522.png" class="" title="image-20211026140522">

<p>一个来自游戏Cel Damage的实时卡通风格渲染的例子，使用背面外壳扩展来形成轮廓边，以及显式的折痕边绘制。(图片由Pseudo Interactive Inc.提供)</p>
<p><strong>这种shell技术有几个潜在的缺陷。想象一下，正面看一个立方体，只有一个面是可见的。形成轮廓边的四个背面都将向对应的立方体面方向移动，因此在角上留下缝隙。这是因为虽然每个角上都有一个顶点，但每个面都有不同的顶点法线。问题是，展开的立方体并没有真正形成壳层，因为每个角顶点都在不同的方向展开。一种解决方案是强迫相同位置的顶点共享一个新的平均顶点法线。另一种技术是在折痕处创建退化的几何图形，然后将其扩展成三角形。Lira等人使用一个额外的阈值纹理来控制每个顶点移动多少。</strong></p>
<p><strong>壳和增粗技术浪费了一些填充物，因为所有的背面都被送进了管线。所有这些技术的其他限制是，几乎没有控制边缘的外观，半透明的表面很难正确渲染，这取决于使用的透明算法。</strong></p>
<p><strong>这类几何技术的一个有价值的特点是在绘制过程中不需要连接信息或边列表。每个三角形都独立于其他三角形进行处理，因此这种技术适合GPU实现。</strong></p>
<p><strong>这类算法只渲染轮廓边缘。Raskar提出了一种聪明的解决方案，可以在变形模型上绘制山脊折痕边，而无需创建和访问边连接数据结构。这个想法是沿着被渲染的三角形的每条边生成一个额外的多边形。这些边多边形通过用户定义的临界二面角从三角形的平面弯曲，这决定了折痕何时应该可见。如果在任何给定时刻，两个相邻三角形的折痕角大于此折痕角，则边缘多边形将可见，否则它们将被三角形隐藏。参见下图。谷边也可以使用类似的技术，但需要一个模板缓冲区和多个通道。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026140732.png" class="" title="image-20211026140732">

<p>一个侧面的两个三角形连接在一个边缘，每个都有一个小的“鳍”连接。当两个三角形沿着边缘弯曲时，鳍就会变得清晰可见。在右边的鳍是暴露的。漆成黑色，这些看起来像山脊边缘。</p>
<h3 id="Edge-Detection-by-Image-Processing-图像处理的边缘检测"><a href="#Edge-Detection-by-Image-Processing-图像处理的边缘检测" class="headerlink" title="Edge Detection by Image Processing 图像处理的边缘检测"></a>Edge Detection by Image Processing 图像处理的边缘检测</h3><p><strong>上一节中的算法有时被归类为基于图像的，因为屏幕分辨率决定了它们是如何执行的。另一种算法是更直接地基于图像，因为它完全操作存储在图像缓冲区中的数据，而不修改(甚至不直接知道)场景中的几何形状。</strong></p>
<p><strong>Saito和Takahashi首先介绍了G-buffer的概念，它也用于延迟着色(章节20.1)。Decaudin扩展了G缓冲器的使用来执行卡通渲染。其基本思想很简单:NPR可以通过在不同的信息缓冲区上执行图像处理算法来实现。通过寻找相邻z缓冲区的不连续点，可以找到许多等高线的位置。相邻表面法线值的不连续通常是轮廓和边界边缘位置的信号。渲染场景在环境颜色或与目标识别值可以用来检测材料，边界，和真实的剪影边缘。</strong></p>
<p><strong>这些边缘的检测和绘制由两部分组成。首先，渲染场景的几何图形，使用像素着色器保存深度、法线、对象IDs或其他所需的数据到各种渲染目标。然后以类似于第12.1节所述的方式执行后处理过程。后处理通过对每个像素周围的邻域进行采样，并基于这些样本输出结果。例如，假设我们对场景中的每个对象都有一个唯一的识别值。在每个像素上，我们可以对这个ID进行采样，并将其与测试像素角上的四个相邻像素ID值进行比较。如果任何一个IDs与测试像素的IDs不同，则输出黑色，否则输出白色。对所有8个相邻像素进行采样更简单，但采样代价更高。这种简单的测试可以用来绘制大多数对象的边界和轮廓边缘(真正的轮廓)。材质IDs可以用来寻找材质边缘。</strong></p>
<p><strong>轮廓边缘可以通过在正常和深度缓冲区上使用各种过滤器来找到。例如，如果相邻像素之间的深度差超过某个阈值，则可能存在轮廓边缘，因此像素被染黑。不是简单地判断相邻像素是否与样本匹配，而是需要其他更复杂的边缘检测操作符。我们在这里不讨论各种边缘检测滤波器的优缺点，如Roberts cross、Sobel和Scharr，因为图像处理文献广泛地涵盖了这些。因为这些操作符的结果不一定是布尔值，所以我们可以调整它们的阈值，或者在某些区域中在黑白之间淡出。注意，法线缓冲区也可以检测折痕边缘，因为法线之间的巨大差异可以表示轮廓或折痕边缘。Thibault和Cavanaugh讨论了他们如何使用这种技术为《无主之地》添加深度缓冲。在其他技术中，他们修改了Sobel滤波器，使其创建单像素宽的轮廓和深度计算，以提高精度。参见下图。也可以往另一个方向去，只在阴影周围添加轮廓，忽略相邻深度差异很大的边缘。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026141322.png" class="" title="image-20211026141322">

<p>修改了《无主之地》中的Sobel边缘检测。最终发布的版本(这里没有显示)进一步改进了前景中草的边缘。(图片由Gearbox Software, LLC提供)</p>
<p><strong>膨胀算子是一种形态算子，用于加厚检测到的边缘。边缘图像生成后，应用一个单独的通道。在每个像素，像素的值和它周围的值在一些半径内被检查。找到的最暗像素值作为输出返回。这样，一条细的黑线将被搜索区域的直径加粗。多个通过可以应用于进一步加粗的线条，其代价是额外通过的成本被每一通过所需的样品大大减少所抵消。不同的结果可以有不同的厚度，例如，轮廓边可以比其他轮廓边更厚。相关的侵蚀运算符可用于减薄线或其他影响。一些结果见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026141501.png" class="" title="image-20211026141501">

<p>法线图(左上)和深度图(中上)的值采用了Sobel边缘检测，结果分别显示在左下和中下。右上方的图像是经过膨胀处理的增厚复合图像。在右下角的最终渲染是通过使用Gooch着色和在边缘合成来实现的。(图片由ATI技术公司的Drew Card和Jason L. Mitchell提供)</p>
<p><strong>这种算法有几个优点。它可以处理所有类型的表面，不管是平面还是曲面，这与大多数其他技术不同。网格不需要连接，甚至不需要一致，因为该方法是基于图像的。</strong></p>
<p><strong>这种技术的缺陷相对较少。对于接近边缘的表面，z深度比较滤波器可以错误地检测出整个表面的轮廓边缘像素。z-depth比较的另一个问题是，如果差异很小，则可能会错过轮廓边缘。例如，桌子上的一张纸通常会缺边。同样，法线贴图过滤器也会忽略这张纸的边缘，因为法线是相同的。这仍然不是万无一失的;例如，一张纸折叠起来会产生无法检测到的边缘，这些边缘重叠在一起。生成的线显示阶梯混叠，但不同第5.4.2节中描述的形态反锯齿技术可以很好地处理这种高对比度输出，以及posterization等技术，以改善边缘质量。</strong></p>
<p><strong>检测也可能以相反的方式失败，在本不存在边缘的地方创建边缘。确定什么构成边并不是一种万无一失的操作。例如，想象玫瑰的茎，一个薄圆筒。关闭，我们的样本像素附近的干法线没有变化那么多，所以没有检测到边缘。当我们远离玫瑰时，法线将在像素间快速变化，直到在某个点，由于这些差异，可能会在边缘附近发生假边缘检测。同样的问题也会发生在从深度图中检测边缘时，视角对深度的影响是一个需要补偿的额外因素。Decaudin提供了一种改进的方法，通过处理法线和深度图的梯度来寻找变化，而不仅仅是值本身。决定不同的像素差异如何转化为颜色变化是一个经常需要针对内容进行调整的过程。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026141611.png" class="" title="image-20211026141611">

<p>各种边缘的方法。褶皱等特征边是纹理本身的一部分，由艺术家提前添加。人物的轮廓是通过背面挤压产生的。采用图像处理的边缘检测方法生成不同权重的轮廓边缘。左边图像的权重太小，所以这些边缘很模糊。中间显示轮廓，特别是鼻子和嘴唇的轮廓边缘。右边显示的是来自太大重量的伪影。(Afro Samurai R &amp; c 2006冈崎隆，GONZO / Samurai项目。Program c 2009 BANDAI NAMCO Entertainment America Inc.)</p>
<p><strong>一旦产生了笔画，就可以按照需要进行进一步的图像处理。由于笔画可以在单独的缓冲区中创建，它们可以自己修改，然后在表面上合成。例如，可以使用噪声函数分别磨损和晃动线条和表面，在两者之间创建小的间隙，并给出一个手绘的外观。纸张的高度场可以用来影响渲染效果，固体材料如在凸起处沉积的木炭或在山谷中聚集的水彩画。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026141722.png" class="" title="image-20211026141722">

<p>左边的鱼模型通过边缘检测、posterization、噪声扰动、模糊和混合在纸张顶部呈现在右边。(图片由Autodesk, Inc.提供)</p>
<p><strong>我们在这里重点讨论了使用几何或其他非图形数据(如法线、深度和IDs)来检测边缘。自然地，图像处理技术发展为图像，这种边缘检测技术可以应用于色彩缓冲。一种方法叫做差分高斯滤波器(DoG)，图像用两个不同的高斯滤波器处理两次，其中一个减去另一个。这种边缘检测方法已经被发现可以为NPR产生特别令人满意的结果，用于生成各种艺术风格的图像，如铅笔阴影和粉彩。</strong></p>
<p><strong>图像后处理操作员在许多NPR技术模拟艺术媒体，如水彩画和丙烯酸颜料突出。在这个领域有相当多的研究，对于交互式应用程序来说，最大的挑战是尝试用最少的纹理样本做最多的事情。可以在GPU上使用双边、均值偏移和Kuwahara过滤器来保留边缘和平滑区域，使其看起来就像绘制的。Kyprianidis等人对该领域的图像处理效果进行了全面回顾和分类。Montesdeoca等人的工作是一个很好的例子，将许多直接的技术结合到以交互速率运行的水彩画效果中。水彩样式渲染的模型如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026141912.png" class="" title="image-20211026141912">

<p>在左边，一个标准的现实渲染。在右侧，水彩风格通过均值移位颜色匹配软化纹理，并增加对比度和饱和度，以及其他技术。(水彩图片由Autodesk, Inc.提供)</p>
<h3 id="Geometric-Contour-Edge-Detection-几何轮廓边缘检测"><a href="#Geometric-Contour-Edge-Detection-几何轮廓边缘检测" class="headerlink" title="Geometric Contour Edge Detection 几何轮廓边缘检测"></a>Geometric Contour Edge Detection 几何轮廓边缘检测</h3><p><strong>到目前为止给出的方法的一个问题是，边缘的风格化充其量是有限的。我们不能轻易地使线条看起来虚线，更不用说看起来手绘或像笔触。对于这种操作，我们需要找到轮廓边缘并直接渲染它们。有了独立的边缘实体，就有可能创建其他效果，比如在网格冻结时，轮廓突然跳跃。</strong></p>
<p><strong>等高线是指两个相邻三角形中的一个面向观者，另一个远离观者。测试是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026142214.png" class="" title="image-20211026142214">

<p><strong>其中n₀ 和n₁ 是两个三角形的法线，v是从眼睛到边缘的视图方向(即到任何一个端点)。为了使该测试正确工作，表面必须保持一致的朝向(第16.3节)。</strong></p>
<p><strong>在模型中寻找轮廓边缘的蛮力方法是遍历边缘列表并进行测试。Lander指出，一个有价值的优化是识别并忽略平面多边形内部的边。也就是说，给定一个连通三角形网格，如果一条边的两个相邻三角形位于同一平面上，那么这条边就不可能是一条等高线。在一个简单的时钟模型上实现这个测试将边缘数从444条下降到256条。此外，如果模型定义的是实心物体，则凹边永远不可能是轮廓边。Buchanan和Sousa通过对每个单独的面重复使用点积测试，避免了对每条边进行单独的点积测试。</strong></p>
<p><strong>从头开始检测每一帧的轮廓边缘代价很高。如果摄像机视图和物体在帧与帧之间移动很少，则可以合理地假设前一帧的轮廓边缘仍然是有效的轮廓边缘。Aila和Miettinen为每条边关联一个有效距离。这个距离是观察者可以移动，但轮廓边缘仍然保持其状态。在任何实体模型中，每个单独的轮廓总是由一个封闭的曲线组成，称为轮廓环，或者更恰当地说，轮廓环。对于对象边界内的轮廓，循环的某些部分可能会被遮挡。甚至实际的轮廓也可能由几个环组成，部分环在轮廓内或被其他表面隐藏。由此可知，每个顶点的等高线边必须是偶数。参见下图。注意，当跟随网格边缘时，循环在三维空间中经常是锯齿状的，z深度变化非常明显。如果需要形成平滑曲线的边缘，例如根据距离改变厚度，可以进行额外的处理，在三角形的法线之间插值，以近似三角形内部的真实轮廓边缘。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026142416.png" class="" title="image-20211026142416">

<p>轮廓循环。左边是相机的模型视图。中间用蓝色显示背对镜头的三角形。右侧显示的是脸部一个区域的特写。注意复杂性和一些轮廓环是如何隐藏在鼻子后面的。(模型由Chris Landreth提供，图片由Pierre B´enard和Aaron Hertzmann提供。)</p>
<p><strong>从一帧到另一帧跟踪循环位置可能比从头开始创建循环更快。Markosian等人从一组循环开始，并使用随机搜索算法在摄像机移动时更新这组循环。轮廓环也会随着模型方向的改变而被创建和破坏。Kalnins等人指出，当两个循环合并时，需要采取纠正措施，否则从一帧到下一帧会出现明显的跳跃。他们使用像素搜索和“投票”算法，试图保持帧与帧之间的轮廓一致性。</strong></p>
<p><strong>这种技术可以极大地提高性能，但可能并不精确。线性方法是精确但昂贵的。分层方法利用摄像机获取轮廓边缘，结合了速度和精度。对于非动画模型的正投影视图，Gooch等人使用高斯图的层次结构来确定轮廓边缘。Sander等人使用n元树的标准锥体(章节19.3)。Hertzmann和Zorin使用了模型的双空间表示，允许他们在模型的边缘施加层次。</strong></p>
<p><strong>所有这些显式边缘检测方法都是CPU密集型的，缓存一致性差，因为形成轮廓的边缘分散在边缘列表中。为了避免这些代价，顶点着色器可以用来检测和渲染轮廓边缘。其思想是将模型的每条边作为两个三角形沿管道向下，形成一个退化的四边形，两个相邻的三角形法线连接到每个顶点。当发现一条边是等高线的一部分时，四边线的点被移动，使其不再退化(即可见)。然后画出这个薄薄的四边形鳍。该技术基于与为阴影体创建寻找轮廓边缘(章节7.3)相同的思想。如果几何着色器是管线的一部分，这些额外的鳍四边形不需要存储，但可以在飞行中生成。一个幼稚的实现将在鳍之间留下裂缝和缝隙，可以通过修改鳍的形状来修正。</strong></p>
<h3 id="Hidden-Line-Removal-移除隐藏线"><a href="#Hidden-Line-Removal-移除隐藏线" class="headerlink" title="Hidden Line Removal 移除隐藏线"></a>Hidden Line Removal 移除隐藏线</h3><p><strong>一旦找到等高线，线条就被渲染出来。明确地找到边缘的一个好处是，您可以将这些样式化为钢笔笔触、绘画笔触或任何您想要的其他媒介。笔触可以是基本线条、纹理视点替用特效(第13.6.4节)、原语集或任何你想尝试的东西。</strong></p>
<p><strong>尝试使用几何边的一个更复杂的问题是，并不是所有的边都是可见的。绘制表面以建立z缓冲区可以掩盖隐藏的几何边，这对于简单的样式(如虚线)可能已经足够了。Cole和Finkelstein通过沿着直线本身的脊取样z-深度，将这种方法推广到代表直线的四边形上。然而，使用这些方法，直线上的每个点都是独立呈现的，因此没有预先知道明确定义的开始和结束位置。对于轮廓环或其他边缘，线段是用来定义笔触或其他连续对象的，我们需要知道每个笔触首次出现和消失的时间。确定每个线段的可见性称为隐藏线段呈现，其中处理一组线段以获取可见性，并返回一组较小的(可能是剪切的)线段。</strong></p>
<p><strong>Northrup和Markosian通过绘制所有对象的三角形和轮廓边，并为每个对象分配不同的识别码来解决这个问题。这个ID缓冲区被读回，可见的轮廓边缘由它确定。这些可见的部分然后检查重叠和链接在一起形成平滑的笔画路径。如果屏幕上的线段很短，这种方法是有效的，但它不包括线段本身的剪辑。然后沿着这些重建路径渲染程式化的笔画。笔画本身可以用许多不同的方式进行程式化，包括锥度、光晕、摆动、过冲和褪色的效果，以及深度和距离提示。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026142826.png" class="" title="image-20211026142826">

<p>使用诺斯鲁普和马尔科斯混合技术生成的图像。找到轮廓边缘，构建成链，并呈现为笔画。(图片由Lee Markosian提供。)</p>
<p><strong>Cole和Finkelstein提出了一种边缘集的可见性计算方法。它们将每个线段存储为两个世界空间坐标值。一系列通道运行一个像素着色器在整个片段集合，剪辑和确定长度在每个像素中，然后为每个潜在像素位置创建一个图集并确定可见性，然后使用这个图集创建可见的笔画。虽然复杂，但这个过程在GPU上相对较快，并提供了一组已知起始和结束位置的可见笔画。</strong></p>
<p><strong>程式化通常包括应用一个或多个预先制作的纹理到线四边。Rougier讨论了一种不同的方法，程序化地渲染虚线模式。每个线段访问存储所需的所有虚线图案的纹理。每个模式都被编码为一组命令，这些命令指定虚线模式以及使用的端点和连接类型。使用四边形的纹理坐标，每个图案控制着色器对四边形中每个点上的线覆盖像素的多少进行一系列测试。</strong></p>
<p><strong>确定轮廓的边缘，将它们连接成连贯的链，然后确定每个链的可见性来形成一个笔画是很难完全平行的。在制作高质量的线条程式化时，另一个问题是，在下一帧中，每个笔画将再次绘制，改变长度或可能首次出现。B´enard等人提出了一项绘制方法的综述，该方法为沿边缘和表面图案的笔画提供了时间连贯性。这不是一个已解决的问题，而且可以计算，因此研究仍在继续。</strong></p>
<h2 id="Stroke-Surface-Stylization-尝试表面风格化"><a href="#Stroke-Surface-Stylization-尝试表面风格化" class="headerlink" title="Stroke Surface Stylization 尝试表面风格化"></a>Stroke Surface Stylization 尝试表面风格化</h2><p><strong>虽然卡通渲染是一种流行的风格，试图模拟，有无限多种其他风格应用到表面。效果可以从修改现实纹理，使算法程序生成从帧到帧的几何装饰。在本节中，我们将简要介绍与实时渲染相关的技术。</strong></p>
<p><strong>Lake等人讨论了使用漫反射阴影术语来选择在表面上使用的纹理。当漫反射变暗时，就会使用带有深色印象的纹理。纹理应用于屏幕空间坐标，以提供一个手绘的外观。为了进一步增强草图的外观，纸的纹理也被应用到屏幕空间的所有表面。参见下图。这类算法的一个主要问题是淋浴门效果，在动画期间，物体看起来像是通过有图案的玻璃观看的。物体感觉就像在纹理中游泳一样。Breslav等人通过确定什么样的图像变换最匹配一些底层模型位置的移动来保持二维纹理查找。这可以保持与基于屏幕的填充模式的连接，同时给予与对象更强的连接。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027130404.png" class="" title="image-20211027130404">

<p>使用纹理调色板、纸张纹理和轮廓边缘渲染生成的图像。(转载由亚当·雷克和卡尔·马歇尔，英特尔公司的许可，版权为英特尔公司2002。)</p>
<p><strong>一个解决方案是显而易见的:直接将纹理应用到表面。挑战是，基于笔画的纹理需要保持一个相对统一的笔画厚度和密度，以看起来令人信服。如果纹理被放大，笔画显得太粗;如果它被缩小，笔画要么是模糊的，要么是薄和噪声(取决于是否使用mipmapping)。Praun等人提出了一种实时生成笔画纹理mipmaps的方法，并将这些纹理平滑地应用到表面上。这样做可以保持屏幕上的描边密度作为对象的距离的变化。第一步是形成要使用的纹理，称为色调艺术地图(TAMs)。这是通过在mipmap级别中绘制笔触来实现的。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027130522.png" class="" title="image-20211027130522">

<p>色调艺术地图(TAMs)。笔画被绘制到mipmap级别中。每一个mipmap级别包含所有的笔画从纹理到它的左边和上面。通过这种方式，mip级别和相邻纹理之间的插值是平滑的。(图片由普林斯顿大学Emil Praun提供。)</p>
<p><strong>Klein等人在他们的“艺术地图”中使用了一个相关的概念来维护NPR纹理的笔画大小。有了这些纹理，模型通过插值每个顶点所需的色调来渲染。这种技术产生的图像具有手绘的感觉。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027130621.png" class="" title="image-20211027130621">

<p>使用色调艺术地图(TAMs)渲染的两个模型。样本显示了用于渲染每个纹理的重叠纹理模式。(图片由普林斯顿大学Emil Praun提供。)</p>
<p><strong>Webb等对TAMs进行了两种扩展，获得了更好的结果，一种是使用体积纹理，允许使用颜色，另一种是使用阈值方案，改进了抗锯齿。Nuebel给出了一种相关的木炭渲染方法。他使用了一个从黑暗到光明的噪音纹理一个轴。强度值沿着这个轴访问纹理。Lee等人使用TAMs和其他技术生成令人印象深刻的图像，看起来像是用铅笔绘制的。</strong></p>
<p><strong>至于笔画，除了已经讨论过的操作外，还有许多其他可能的操作。为了获得草图效果，边缘可以抖动或超调其原始位置，如图651页图15.1的右上和中下图像所示。</strong></p>
<p><strong>Girshick等人讨论了沿着曲面上的主曲线方向线绘制笔画。也就是说，从曲面上任意一点，都有一个指向最大曲率方向的第一个主方向切向量。第二个主要方向是垂直于第一个矢量的切向量，它给出了曲面弯曲最小的方向。这些方向线在感知曲面时很重要。对于静态模型，它们还具有只需生成一次的优点，因为这些笔画独立于光照和阴影。Hertzmann和Zorin讨论了如何清理和平滑主方向。大量的研究和开发已经探索了使用这些方向和其他数据在任意表面上应用纹理，在驾驶模拟动画和其他应用。以Vaxman等人的报告为起点。</strong></p>
<p><strong>嫁接的想法是可以根据需要在表面添加几何或贴花纹理，以产生特定的效果。它们可以由所需的细节水平、表面对眼睛的方向或其他因素来控制。这些也可以用来模拟钢笔或毛笔的笔触。下图显示了一个示例。几何移植物是一种程序建模形式。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027130955.png" class="" title="image-20211027130955">

<p>两种不同的嫁接方式造就了斯坦福兔。(图片由布鲁斯·古奇和马特·卡普兰，犹他大学提供)</p>
<p><strong>这一章仅仅触及了NPR研究所采取的几个方向。请参阅末尾的“进一步阅读和参考资料”部分，了解更多信息。在这个领域中，我们通常很少或根本没有可以作为基本真理的物理正确答案。这既是问题，也是解放。技术给出了速度和质量之间的权衡，以及实现成本。在交互渲染速率的时间约束下，大多数方案在一定条件下会发生弯曲和断裂。在应用程序中，确定哪些工作很好或足够好是使该领域成为一个迷人的挑战的原因。</strong></p>
<p><strong>我们的大部分注意力都集中在一个特定的主题上，轮廓边缘检测和渲染。最后，我们将把注意力转向线条和文本。这两种非写实的原语使用频率很高，也有自己的一些挑战，所以值得单独报道。</strong></p>
<h2 id="Lines-线"><a href="#Lines-线" class="headerlink" title="Lines 线"></a>Lines 线</h2><p><strong>渲染简单的实心“硬”线通常被认为是相对无趣的。然而，它们在CAD等领域非常重要，用于查看底层模型面和识别对象的形状。它们在突出显示选定对象和技术插图等领域也很有用。此外，所涉及的一些技术也适用于其他问题。</strong></p>
<h3 id="Triangle-Edge-Rendering-三角形边缘渲染"><a href="#Triangle-Edge-Rendering-三角形边缘渲染" class="headerlink" title="Triangle Edge Rendering 三角形边缘渲染"></a>Triangle Edge Rendering 三角形边缘渲染</h3><p><strong>在填充的三角形上正确地渲染边缘比它最初看起来要困难得多。如果一条直线与三角形处于完全相同的位置，我们如何确保直线总是呈现在前面呢?一个简单的解决方法是用固定的偏置渲染所有的线条。也就是说，每一条线都被渲染得比实际更接近，这样它就会在表面之上。如果固定偏差太大，应该隐藏的部分边缘就会出现，破坏效果。如果偏置过小，接近边的三角形面会隐藏部分或全部边。正如在第15.2.2节中提到的，API调用，比如OpenGL的glPolygonOffset，可以根据它们的斜率，将曲面向后移动到线条下方。这种方法相当有效，但并不完美。</strong></p>
<p><strong>Herrell等人的一个方案完全避免了偏见。它使用一系列步骤来标记和清除模板缓冲区，以便正确地在三角形上绘制边。除了最小的三角形集合外，这种方法对任何三角形都是不切实际的，因为每个三角形都必须单独绘制，并且为每个三角形清除模板缓冲区，这使得这个过程非常耗时。</strong></p>
<p><strong>Bærentzen等人提出了一种可以很好地映射到GPU的方法。他们使用一个像素着色器，使用三角形的重心坐标来确定到最近边缘的距离。如果像素接近边缘，则使用边缘颜色绘制。边缘厚度可以是任何想要的值，并可以受距离或保持不变。参见下图。它的主要缺点是轮廓线的厚度只有内线的一半，因为每个三角形都是内线厚度的一半。在实践中，这种不匹配往往不明显。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027131255.png" class="" title="image-20211027131255">

<p>像素着色器生成线。左边是抗锯齿的单像素宽边缘;右边是带有光晕的可变粗细线。(图片由J. Andreas b . ærentzen提供。)</p>
<p><strong>Celes和Abraham对这一观点进行了扩展和简化，并对之前的工作进行了全面的总结。他们的想法是为每个三角形边使用一组一维的纹理坐标，1.0为定义边的两个顶点，0.0为另一个顶点。他们利用纹理映射和mip链来提供恒定宽度的边缘。这种方法易于编码，并提供一些有用的控件。例如，可以设置最大密度，这样稠密的网格就不会完全被边缘填充，从而变成纯色。</strong></p>
<h3 id="Rendering-Obscured-Lines-渲染模糊线条"><a href="#Rendering-Obscured-Lines-渲染模糊线条" class="headerlink" title="Rendering Obscured Lines 渲染模糊线条"></a>Rendering Obscured Lines 渲染模糊线条</h3><p><strong>在普通的线框图中，没有绘制表面，模型的所有边缘都是可见的。为了避免绘制被表面隐藏的线，将所有填充的三角形只绘制到z缓冲区中，然后正常绘制边缘。如果您不能在绘制所有线条之前绘制所有的表面，一个稍微昂贵一点的解决方案是用与背景匹配的纯色绘制表面。</strong></p>
<p><strong>线也可以绘制为部分模糊，而不是完全隐藏。例如，隐藏的线可以显示为浅灰色，而不是根本不画。这可以通过适当设置z-buffer的状态来实现。像以前一样绘制，然后反转z缓冲区的感觉，以便只绘制超出当前像素的z深度的线。同时关闭z缓冲区的修改，这样绘制的线不会改变任何深度值。用模糊的风格再画一遍线。只有那些被隐藏然后被画。对于行的程式化版本，可以使用完整的隐藏行删除过程。</strong></p>
<h3 id="Haloing-光晕"><a href="#Haloing-光晕" class="headerlink" title="Haloing 光晕"></a>Haloing 光晕</h3><p><strong>当两条线交叉时，通常的约定是擦除较远的线的一部分，使顺序明显。这可以相对容易地完成，每条线画两次，一次有一个光晕。此方法通过在其上绘制背景色来消除重叠。首先，在z-buffer中绘制所有的线条，将每条线表示为代表光晕的粗四边形。一个几何着色器可以帮助创建这样的四边形。然后，用正常的颜色画每一条线。被z-buffer绘制所掩盖的区域将隐藏其后面绘制的线。必须使用偏置或其他方法来确保每一条细黑线位于粗z缓冲区四边形的顶部。</strong></p>
<p><strong>相交于顶点的线可能被相互竞争的光晕部分隐藏。缩短产生光晕的四边形会有帮助，但也会导致其他的伪影。Bærentzen等人的线绘制技术也可以用于光晕。参见上图。晕圈是每个三角形产生的，所以没有干涉问题。另一种方法是使用图像后处理(章节15.2.3)来检测和绘制光晕。</strong></p>
<p><strong>下图显示了这里讨论的一些不同的线绘制方法的结果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027131552.png" class="" title="image-20211027131552">

<p>四行渲染样式。从左到右:线框、隐藏线、模糊线和晕线。</p>
<h2 id="Text-Rendering-文本渲染"><a href="#Text-Rendering-文本渲染" class="headerlink" title="Text Rendering 文本渲染"></a>Text Rendering 文本渲染</h2><p><strong>考虑到阅读文本对文明的重要性，人们花费大量的精力来渲染文本也就不足为奇了。与许多其他对象不同，单个像素的变化可以产生显著的差异，例如将“l”变成“1”。本节总结了用于文本渲染的主要算法方法。</strong></p>
<p><strong>眼睛对亮度的差异比对颜色的差异更敏感。这一事实至少在Apple II时代就已经被用于提高感知空间分辨率。这个想法的一个应用是微软的ClearType技术，它是建立在液晶显示(LCD)显示器的一个特性之上的。液晶显示器上的每个像素都由三个垂直的彩色矩形组成，红色、绿色和蓝色——使用液晶显示器上的放大镜，你可以自己看。不考虑这些亚像素矩形的颜色，这种配置提供的水平分辨率是像素的三倍。使用不同的阴影填充不同的亚像素，因此这种技术有时被称为亚像素渲染。眼睛将这些颜色混合在一起，红色和蓝色的条纹变得无法检测。参见下图。这项技术于1998年首次公布，对大型、低DPI LCD显示器有很大帮助。微软在Word 2013中停止使用ClearType，显然是因为混合不同背景颜色的文本存在问题。Excel、各种网络浏览器、Adobe的CoolType、苹果的Quartz 2D以及FreeType和SubLCD等库都使用了这种技术。Shemanarev的一篇古老而深入的文章涵盖了这种方法的各种微妙之处和问题。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027131845.png" class="" title="image-20211027131845">

<p>放大的灰度抗锯齿和亚像素抗锯齿版本的同一个词。当一个彩色像素显示在LCD屏幕上时，组成该像素的相应彩色垂直亚像素矩形被点亮。这样做提供了额外的水平空间分辨率。(图片由Steve Gibson的“Free &amp; Clear”程序生成。)</p>
<p><strong>这种技术是一个很好的例子，说明在清晰地呈现文本上花费了多少精力。一种字体中的字符，称为字形，通常由一系列线段和二次或三次B´ezier曲线来描述。参见第726页的图17.9以获得一个示例。所有字体渲染系统的工作都是确定字形如何影响它重叠的像素。像FreeType和Anti-Grain Geometry这样的库通过为每个符号生成一个小纹理并在需要时重用它们来工作。不同的纹理为每个字体大小和重点，即斜体或粗体。</strong></p>
<p><strong>这些系统假设每个纹理都是像素对齐的，每个像素一个像素，就像它通常用于文档一样。当文本应用于三维表面时，这些假设可能不再成立。使用带有一组符号的纹理是一种简单而流行的方法，但也有一些潜在的缺点。应用程序仍然可以将文本对齐到面向观众，但缩放和旋转将打破每像素一个像素的假设。即使屏幕对齐，字体提示也可能不被考虑在内。提示是调整字形轮廓以与像素单元匹配的过程。例如，一个像素宽的“I”的垂直杆最好是覆盖一列像素而不是半覆盖两个相邻的列。参见下图。所有这些因素都意味着光栅纹理会出现模糊或混叠问题。Rougier全面介绍了纹理生成算法涉及的问题，并展示了FreeType的提示如何在基于OpenGL的符号绘制系统中使用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027132013.png" class="" title="image-20211027132013">

<p>Verdana字体呈现无提示(上)和有提示(下)。(图片由Nicolas Rougier提供。)</p>
<p><strong>Pathfinder库是使用GPU生成符号的最新成果。它具有较低的设置时间和最少的内存使用，并优于竞争对手CPU-based引擎。它使用镶嵌和计算着色器来生成和总结每个像素上的曲线效果，并在性能较差的gpu上使用几何着色器和OpenCL。像FreeType一样，这些符号被缓存和重用。它的高质量反锯齿，再加上高密度显示器的使用，使得暗示几乎过时了。</strong></p>
<p><strong>在不需要精心设计的GPU支持的情况下，以不同大小和方向将文本应用到任意表面上，同时仍然提供合理的抗锯齿。Green提出了这样一个系统，最初是Valve在《军团要塞2》中使用的。该算法采用Frisken等人引入的采样距离场数据结构。每个texel保存符号到符号最近边缘的距离。距离字段试图在纹理描述中编码每个符号的精确边界。双线性插值然后给出一个很好的近似的alpha覆盖的字母在每个样本。如下图所示。尖锐的角可以通过双线性插值来平滑，但可以通过在四个单独的通道中编码更多的距离值来保留。这种方法的一个限制是，创建这些带符号的距离纹理非常耗时，因此需要预先计算和存储它们。然而，一些字体渲染库是基于这种技术的，并且它很好地适应于移动设备。Reshetov和Luebke总结了这些工作，并给出了他们自己的方案，这是基于在放大过程中调整样品的纹理坐标。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027132129.png" class="" title="image-20211027132129">

<p>矢量纹理。在左边，字母“g”在它的距离域中表示。在右边，“禁止侵入”的标志是从远处的区域显示出来的。通过将特定的距离范围映射到轮廓颜色，可以添加文本周围的轮廓。(左图由ARM有限公司提供。右图来自Valve公司的《军团要塞2》。)</p>
<p><strong>例如，即使没有缩放和旋转问题，使用汉字的语言的字体也可能需要数千或更多的字形。高质量的大字符需要更大的纹理。如果以一定角度观察字形，则可能需要对纹理进行各向异性过滤。直接从它的边缘和曲线描述渲染符号将避免任意大纹理的需要，并避免来自采样网格的工件。Loop-Blinn方法使用像素着色器直接评估B´ezier曲线，将在17.1.2节中讨论。这种技术需要一个镶嵌步骤，在加载时执行这个步骤可能会非常昂贵。Dobbie通过为每个字符的边界框绘制一个矩形，并在一次通过中评估所有字形轮廓，避免了这个问题。Lengyel提出了一个健壮的评估器，用于判断一个点是否在符号内，这对于避免伪影至关重要，并讨论了评估优化和效果，如发光、阴影和多种颜色(如表情符号)。</strong></p>
<h1 id="16-Polygonal-Techniques-多边形技术"><a href="#16-Polygonal-Techniques-多边形技术" class="headerlink" title="16 Polygonal Techniques 多边形技术"></a>16 Polygonal Techniques 多边形技术</h1><p><strong>到目前为止，我们已经假设我们渲染的模型以我们需要的格式提供，并且具有适量的细节。在现实中，我们很少有这么幸运的。建模器和数据捕获设备有它们自己的特殊癖好和限制，这会在数据集和呈现中产生歧义和错误。通常需要在存储大小、呈现效率和结果质量之间进行权衡。在本章中，我们讨论了在多边形数据集中遇到的各种问题，以及这些问题的一些修复和变通方法。然后我们将介绍有效渲染和存储多边形模型的技术。</strong></p>
<p><strong>交互式计算机图形中多边形表示的首要目标是视觉的准确性和速度。“准确性”是一个取决于上下文的术语。例如，工程师希望以交互速度检查和修改一个机器部件，并要求物体上的每个斜角和倒角时刻可见。在游戏中，如果帧率足够高，那么在给定帧中出现的小错误或不准确是允许的，因为它们可能不会在注意力集中的地方出现，或者可能在下一帧中消失。在交互图形工作中，了解所解决问题的边界是很重要的，因为这些边界决定了可以应用什么类型的技术。</strong></p>
<p><strong>本章涉及的领域是镶嵌、巩固、优化、简化和压缩。多边形可以有许多不同的形式，通常必须被分割成更易于处理的原语，如三角形或四边形。这个过程叫做三角剖分，或者更通俗地说，镶嵌。整合是我们的术语，它包括将单独的多边形合并成一个网格结构，以及产生新的数据，如用于表面着色的法线。优化意味着在网格中对多边形数据进行排序，从而使其渲染更快。简化就是取一个网格并删除其中不重要的特征。压缩是关于最小化存储空间所需的各种元素描述的网格。</strong></p>
<p><strong>三角剖分确保给定的网格描述正确显示。通过允许共享计算并减少内存中的大小，合并进一步改善了数据显示，并经常提高速度。优化技术可以进一步提高速度。通过删除不必要的三角形，简化可以提供更快的速度。压缩可用于进一步减少总体内存占用，进而通过减少内存和总线带宽提高速度。</strong></p>
<h2 id="Sources-of-Three-Dimensional-Data-三维数据来源"><a href="#Sources-of-Three-Dimensional-Data-三维数据来源" class="headerlink" title="Sources of Three-Dimensional Data 三维数据来源"></a>Sources of Three-Dimensional Data 三维数据来源</h2><p><strong>有几种方法可以创建或生成多边形模型:</strong></p>
<pre><code>**•直接输入几何描述。**

**•编写创建此类数据的程序。这被称为过程建模。**

**•将其他形式的数据转化为表面或体积，例如，将蛋白质数据转化为一组球体和圆柱体。** 

**•使用建模程序建立或雕刻一个对象。**

**•从同一物体的一张或多张照片重建表面，称为摄影测量。**

**•使用三维扫描仪、数字化仪或其他传感设备，在不同的点对真实模型进行采样。** 

**•生成一个等值面，在空间的某些体积中表示相同的值，如CAT或MRI医学扫描的数据，或大气中测量的压力或温度样本。**

**•结合使用这些技术。** 
</code></pre>
<p><strong>在建模领域，有两种主要类型的建模器:基于实体的和基于表面的。基于实体的建模器通常出现在计算机辅助设计(CAD)领域，并且经常强调与实际加工过程相对应的建模工具，如切割、钻孔和刨平。在内部，他们将有一个计算引擎，严格地操作对象的底层拓扑边界。为了显示和分析，这些建模器都有面板。faceter是一种将内部模型表示转换成可以显示的三角形的软件。例如，一个球体在数据库中可以用一个中心点和一个半径来表示，而曲面可以将球体转换成任意数量的三角形或四边形来表示它。有时，最好的渲染加速是最简单的:当使用faceter时，降低所需的视觉精度可以提高速度，并通过生成更少的三角形节省存储空间。</strong></p>
<p><strong>CAD工作中一个重要的考虑因素是所使用的面是否是为图形渲染而设计的。例如，有限元方法(FEM)的面，旨在将表面分割成几乎相等面积的三角形。这种镶嵌是简化的有力候选，因为它们包含了许多在图形上无用的数据。类似地，一些面产生的三角形集合非常适合使用3D打印创建真实世界的对象，但缺乏顶点法线，通常不适合快速图形显示。</strong></p>
<p><strong>像Blender或Maya这样的建模器并不是基于内置的可靠性概念。相反，对象是由它们的表面定义的。像实体建模一样，这些基于表面的系统可以使用内部表示和面来显示物体，如样条或细分曲面(第17章)。它们还允许对曲面进行直接操作，例如添加或删除三角形或顶点。然后，用户可以手动降低模型的三角形计数。</strong></p>
<p><strong>还有其他类型的建模器，如隐式曲面(包括“blobby”metaball)创建系统，它们处理混合、权重和字段等概念。这些建模者可以通过生成由函数f(x, y, z) = 0的解定义的曲面来创建有机形式。然后使用多边形化技术(例如移动立方体)来创建用于显示的三角形集(第17.3节)。</strong></p>
<p><strong>点云是简化技术的有力候选者。这些数据通常是定期采样的，因此，许多采样对形成的表面的视觉感知的影响可以忽略不计。研究人员花了几十年的时间研究从点云中过滤缺陷数据和重建网格的技术。有关该区域的更多信息，请参阅第13.9节。</strong></p>
<p><strong>可以对由扫描数据生成的网格执行任意数量的清理或更高阶的操作。例如，分割技术分析一个多边形模型并试图识别单独的部分。这样做可以帮助创建动画、应用纹理地图、匹配形状和其他操作。</strong></p>
<p><strong>还有许多其他方法可以生成多边形数据来表示表面。关键是要理解数据是如何创建的，以及目的是什么。通常，生成数据不是为了有效的图形显示。此外，有许多不同的三维数据文件格式，在任何两种格式之间进行转换通常都不是无损操作。理解传入数据可能遇到的各种限制和问题是本章的主要主题。</strong></p>
<h2 id="Tessellation-and-Triangulation-镶嵌细分和三角测量"><a href="#Tessellation-and-Triangulation-镶嵌细分和三角测量" class="headerlink" title="Tessellation and Triangulation 镶嵌细分和三角测量"></a>Tessellation and Triangulation 镶嵌细分和三角测量</h2><p><strong>镶嵌是将一个曲面分割成一组多边形的过程。在这里，我们集中在镶嵌多边形表面;曲面镶嵌将在第17.6节中讨论。由于各种原因，可以进行多边形镶嵌。最常见的是所有的图形API和硬件都是为三角形优化的。三角形几乎就像原子一样，任何表面都可以用它们来制作和渲染。把一个复杂的多边形转换成三角形叫做三角剖分。</strong></p>
<p><strong>在划分多边形时有几个可能的目标。例如，要使用的算法可能只处理凸多边形。这种镶嵌称为凸划分。表面可能需要细分(网格)，以使用全局照明技术在每个顶点存储阴影或相互反射的效果。下图显示了这些不同类型的镶嵌的例子。镶嵌的非图形性原因包括一些要求，如没有三角形大于某些给定的面积，或三角形顶点上的角都大于某些最小角。Delaunay三角剖分要求每个三角形的顶点组成的每个圆不包含任何剩余的顶点，这使得最小角度最大化。虽然这些限制通常是非图形应用(如有限元分析)的一部分，但它们也可以改善表面的外观。长而细的三角形通常是值得避免的，因为当在远处的顶点上插入时，它们可能会造成伪影。栅格化也可能效率低下。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028120349.png" class="" title="image-20211028120349">

<p>各种类型的镶嵌。最左边的多边形不镶嵌，下一个被划分为凸区域，下一个被三角化，最右边被均匀网格化。</p>
<p><strong>大多数镶嵌算法在二维空间中工作。他们假设多边形上的所有点都在同一平面上。然而，一些模型创建系统可以生成严重扭曲和非平面的多边形面。这个问题的一个常见的例子是几乎边对边观察的扭曲四边形;这可能会形成所谓的沙漏或蝴蝶结四边形。参见下图。虽然这个特殊的多边形可以简单地通过创建一个对角线边来三角化，但更复杂的扭曲多边形却不容易管理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028120507.png" class="" title="image-20211028120507">

<p>弯曲的四边形，形成一个不明确的领结或沙漏形身材，以及两个可能的三角形。</p>
<p><strong>当可以弯曲多边形时，一个快速的纠正操作是将顶点投影到一个垂直于多边形近似法线的平面上。这个平面的法线通常是通过计算xy, xz, yz三个正交平面上的投影面积得到的。也就是说，去掉x坐标后，在yz平面上的多边形面积就是x分量的值，在xz平面上是y分量，在xy平面上是z分量。这种计算平均法线的方法被称为Newell公式。</strong></p>
<p><strong>投射到这个平面上的多边形可能仍然存在自交问题，即它的两条或多条边交叉。因此需要更精细和计算昂贵的方法。Zou等人讨论了以前基于最小化曲面面积或所得到镶嵌的二面角的工作，并提出了在一个集合中同时优化几个非平面多边形的算法。</strong></p>
<p><strong>Schneider和Eberly、Held、O ‘Rourke和de Berg等人各自对各种三角测量方法进行了概述。最基本的三角剖分算法是检查多边形上任意两个给定点之间的每一条线段，看它是否与多边形的任何边相交或重叠。如果是这样，线段就不能用来分割多边形，所以我们检查下一对可能的点。否则，使用此段将多边形分成两部分，并用相同的方法对这些新多边形进行三角化。这种方法在O(n³)时极其缓慢。</strong></p>
<p><strong>一种更有效的方法是剪耳(ear clipping)，这是O(n²)时，作为两个过程。首先，通过在多边形上寻找耳朵，也就是说，查看顶点索引为i， (i + 1)， (i + 2)(模n)的所有三角形，并检查线段i， (i + 2)是否与任何多边形边相交。如果没有，则三角形(i + 1)形成一个耳朵。参见下图。每个可用的耳朵依次从多边形中移除，顶点i和(i + 2)处的三角形重新检查，看看它们现在是不是耳朵。最后，所有的耳朵都被删除，多边形被三角化。其他更复杂的三角剖分方法是O(n log n)，有些方法对于典型情况是有效的O(n)。Schneider和Eberly给出了用于剪耳和其他更快的三角测量方法的伪代码。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028120834.png" class="" title="image-20211028120834">

<p>剪耳。有潜在耳朵的多边形在v2, v4,v5 处显示。在右边，耳朵在v4 是删除。相邻的顶点v3 和v5 重新检查它们是否形成了耳朵;v5 所做的事。</p>
<p><strong>与三角剖分相比，将多边形划分为凸区域在存储和进一步计算成本方面都更有效。鲁棒凸性代码检验由Schorn和Fisher给出。如第16.4节所述，凸多边形可以很容易地用扇形或三角形条来表示。有些凹多边形可以当作扇形处理(这种多边形称为星形)，但检测这些扇形需要更多的工作。Schneider和Eberly给出了两种凸划分方法，一种是快速脏法，另一种是最优法。</strong></p>
<p><strong>多边形并不总是由单一的轮廓线组成。下图显示了由三个轮廓组成的多边形，也称为循环或等高线。通过在循环之间小心地生成连接边(也称为钥匙孔边或桥边)，这样的描述总是可以转换为单轮廓多边形。Eberly]讨论了如何找到定义这些边的相互可见的顶点。这个转换过程也可以反过来检索单独的循环。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028121114.png" class="" title="image-20211028121114">

<p>一个有三个轮廓的多边形转换成一个单轮廓多边形。连接边用红色表示。多边形内的蓝色箭头表示访问顶点的顺序，以形成单个循环。</p>
<p><strong>编写一个健壮而通用的三角测量器是一项困难的任务。各种微妙的错误、病理情况和精度问题使得创建简单的代码非常棘手。解决三角剖分问题的一种方法是使用图形加速器本身直接渲染一个复杂的多边形。多边形被渲染为一个三角形扇形到模具缓冲区。通过这样做，应该填充的区域绘制奇数次，凹洞和洞绘制偶数次。通过使用模板缓冲区的反转模式，在第一次传递结束时只标记填充的区域。参见下图。在第二次传递中，使用模板缓冲区只允许绘制填充区域，再次渲染三角形扇形。这种方法甚至可以通过绘制每个循环形成的三角形来渲染具有多个轮廓的多边形。主要的缺点是，每个多边形必须使用两个通道渲染，模具缓冲区清除每一帧，深度缓冲区不能直接使用。该技术可以用于显示某些用户交互，例如显示动态绘制的复杂选择区域的内部。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028121155.png" class="" title="image-20211028121155">

<p>光栅化的三角测量，使用奇数/偶数奇偶校验的区域是可见的。左边的多边形作为从顶点0开始的三个三角形组成的扇形绘制到模具缓冲区中。第一个三角形[0,1,2] (左中)填充其区域，包括多边形外的空间。三角形[0,2,3] (右中)填充其区域，将区域A和区域B的奇偶校验变为偶数，从而使它们为空。三角形[0,3,4] (右)填充多边形的其余部分。</p>
<h3 id="Shading-Problems-着色问题"><a href="#Shading-Problems-着色问题" class="headerlink" title="Shading Problems 着色问题"></a>Shading Problems 着色问题</h3><p><strong>有时数据会以四边形网格的形式到达，为了显示，必须将其转换成三角形。在很长一段时间内，一个四边形将是凹的，在这种情况下，只有一种方法来三角化它。否则，我们可以从两者中任选其一对角线分割它。花一点时间选择更好的对角线有时可以得到明显更好的视觉效果。</strong></p>
<p><strong>有几种不同的方法来决定如何分割一个四边形。关键思想是最小化新边顶点的差异。对于顶点上没有额外数据的平面四边形，通常最好选择最短的对角线。对于每个顶点都有颜色的简单烘烤全局照明解决方案，选择颜色之间差异较小的对角线。参见下图。这种由启发式方法确定的连接两个最小不同角的想法，在最小化工件方面通常是有用的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028121455.png" class="" title="image-20211028121455">

<p>左边的图形被渲染成一个四边形;中间是两个三角形，右上和左下角相连;右边显示使用另一条对角线时会发生什么。中间的人比右边的人在视觉上要好。</p>
<p><strong>有时三角形不能正确地捕捉设计师的意图。如果一个纹理被应用到一个扭曲的四边形上，那么任何对角线的分割都不会保留意图。也就是说，在非三角形四边形上进行简单的水平插值。从左边缘到右边缘的插值值也失败了。下图显示了这个问题。出现这个问题是因为应用到表面上的图像在显示时将被扭曲。一个三角形只有三个纹理坐标，所以它可以建立仿射变换，而不是扭曲。三角形上的基本(u, v)纹理最多只能被剪切，不能被扭曲。Woo等人进一步讨论了这个问题。有几种可能的解决方案:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028121550.png" class="" title="image-20211028121550">

<p>左上角显示了设计师的意图，一个带有“R”的方形纹理贴图的扭曲四边形。“右边的两张图片显示了两种三角测量法以及它们的不同之处。底部行旋转所有多边形;非三角形四边形改变了它的外观。</p>
<p><strong>•弯曲纹理，并重新应用这个新图像，新的纹理坐标。</strong> </p>
<p><strong>•将表面镶嵌成更细的网格。这只会减轻问题。</strong></p>
<p><strong>•使用投射纹理在飞行中扭曲纹理。这就产生了表面纹理间距不均匀的不良影响。</strong></p>
<p><strong>•使用双线性映射方案。这可以通过每个顶点的额外数据实现。</strong> </p>
<p><strong>虽然纹理失真听起来像是一种病理情况，但在某种程度上，它会在应用的纹理数据与基础四边形的比例不匹配时发生。，几乎在任何曲面上。一个极端的情况发生在一个常见的原语上:圆锥。当一个圆锥体被纹理化和刻面化时，圆锥体顶端的三角形顶点有不同的法线。这些顶点法线不是由相邻三角形共享的，因此出现着色不连续现象。</strong></p>
<h3 id="Edge-Cracking-and-T-Vertices-边缘开裂和T-顶点"><a href="#Edge-Cracking-and-T-Vertices-边缘开裂和T-顶点" class="headerlink" title="Edge Cracking and T-Vertices 边缘开裂和T -顶点"></a>Edge Cracking and T-Vertices 边缘开裂和T -顶点</h3><p><strong>曲面，在第17章详细讨论，通常被镶嵌成网格来绘制。这种镶嵌是通过沿着样条曲线步进定义曲面，从而计算顶点位置和法线来完成的。当我们使用一个简单的步进方法时，问题可能会发生在样条曲面相遇的地方。在共用边，两个表面的点需要重合。由于模型的性质，有时可能会发生这种情况，但通常情况下，如果没有足够的小心，为一条样条曲线生成的点不会与它的邻居生成的点相匹配。这种效果被称为边缘开裂，当观众透过表面窥视时，它会导致令人不安的视觉伪影。即使观众不能透过裂缝看到，接缝经常是可见的，因为在着色的方式是内插。</strong></p>
<p><strong>修补这些裂缝的过程叫做边缝。目标是确保沿着(曲线)共享边的所有顶点被两个样条曲面共享，这样就不会出现裂缝。参见下图。第17.6.2节讨论了使用自适应镶嵌避免花键表面开裂。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028121851.png" class="" title="image-20211028121851">

<p>左边的图显示了两面相交处的裂缝。中间显示通过匹配边缘点固定的裂缝。右边显示修正后的网格。</p>
<p><strong>连接平面时遇到的一个相关问题是T顶点的问题。当两个模型的边相遇，但不共享它们周围的所有顶点时，就会出现这种问题。即使从理论上讲，边缘应该是完美的，但如果渲染器没有足够的精度来表示屏幕上的顶点位置，裂缝就会出现。现代图形硬件使用亚像素寻址来帮助避免这个问题。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028122023.png" class="" title="image-20211028122023">

<p>在顶部行中，一个表面的底层网格显示了一个着色不连续。顶点b是一个T顶点，因为它属于它左边的三角形，但不是三角形acd的一部分。一个解决方案是将这个T顶点添加到这个三角形中，并创建三角形abd和bcd(没有显示出来)。长而细的三角形更有可能导致其他着色问题，所以重测通常是一个更好的解决方案，如下面一行所示。</p>
<p><strong>更明显的是可能出现的着色伪影，这与精度无关。上图显示了这个问题，可以通过找到这些边并确保与边界面共享公共顶点来解决这个问题。另外一个问题是使用简单的扇形算法生成退化(零面积)三角形的危险。例如，在图中，假设右上方的四边形abcd被三角形化成了三角形abc和acd。三角形abc是一个退化的三角，所以点b是T顶点。Lengyel讨论了如何找到这样的顶点，并提供了适当重新排列凸多边形的代码。Cignoni等人描述了一种方法，在已知T顶点位置时避免创建退化(零面积)三角形。他们的算法是O(n)，并保证最多产生一个三角形带和扇形。</strong></p>
<h2 id="Consolidation-整合"><a href="#Consolidation-整合" class="headerlink" title="Consolidation 整合"></a>Consolidation 整合</h2><p><strong>一旦模型通过了任何需要的镶嵌算法，我们就剩下一组代表模型的多边形。有一些操作可能对显示这些数据有用。最简单的方法是检查多边形本身是否正确形成，它是否至少有三个唯一的顶点位置，以及它们是否共线。例如，如果一个三角形中的两个顶点匹配，那么它就没有面积可以丢弃。请注意，在这一节中，我们真正指的是多边形，而不仅仅是三角形。根据您的目标，存储每个多边形可能更有效，而不是立即将其转换为三角形以供显示。三角剖分会产生更多的边，这又会为后续的操作增加更多的工作量。</strong></p>
<p><strong>一个通常应用于多边形的过程是合并，它在面之间找到共享的顶点。另一种操作叫做定位，在这个操作中，形成一个表面的所有多边形都面向相同的方向。对于不同的算法，如背面剔除、折痕边缘检测和正确的碰撞检测和响应，网格的方向是很重要的。与方向相关的是顶点法向生成，曲面看起来很光滑。我们称所有这些类型的技术为整合算法。</strong></p>
<h3 id="Merging-合并"><a href="#Merging-合并" class="headerlink" title="Merging 合并"></a>Merging 合并</h3><p><strong>一些数据以不连通多边形的形式出现，通常被称为多边形汤或三角形汤。存储单独的多边形会浪费内存，显示单独的多边形效率非常低。由于这些原因和其他原因，单个多边形通常合并到一个多边形网格中。简单地说，一个网格由一组顶点和一组轮廓线组成。每个顶点包含一个位置和其他可选数据，如着色法线、纹理坐标、切线向量和颜色。每个多边形轮廓都有一个整数索引列表。每个索引是一个从0到n−1的数字，其中n是顶点的数量，所以指向列表中的一个顶点。通过这种方式，每个顶点可以只存储一次，并被任意数量的多边形共享。三角形网格是一种只包含三角形的多边形网格。第16.4.5节深入讨论了网格存储方案。</strong></p>
<p><strong>给定一组不相连的多边形，合并可以有几种方法。一种方法是使用哈希。将顶点计数器初始化为零。对于每个多边形，尝试依次将其每个顶点添加到哈希表中，并基于顶点值进行哈希。如果一个顶点不在表中，将它与顶点计数器值一起存储在那里，然后递增;也将顶点存储在最后的顶点列表中。如果找到匹配的顶点，则检索它的存储索引。保存指向顶点的索引多边形。处理完所有多边形后，顶点和索引列表就完成了。</strong></p>
<p><strong>模型数据有时会带有分离多边形的顶点非常接近，但不完全相同的情况。合并这些顶点的过程称为焊接。有效地焊接顶点可以通过使用排序和一个较松的位置相等函数来完成。</strong></p>
<h3 id="Orientation-取向"><a href="#Orientation-取向" class="headerlink" title="Orientation 取向"></a>Orientation 取向</h3><p><strong>一个与模型数据质量相关的问题是面向面。有些模型数据的方向是正确的，表面法线或显式或隐式指向正确的方向。例如，在CAD工作中，标准是顶点在多边形轮廓中，当看到正面时，沿逆时针方向进行。这叫做弯曲方向三角形使用右手定则。想象你右手的手指以逆时针的顺序环绕多边形的顶点。然后你的拇指指向多边形的法线方向。这个方向独立于使用的左手或右手视图空间或世界坐标方向，因为它完全依赖于世界中的顶点的顺序，当观察三角形的前面时。也就是说，如果一个反射矩阵被应用到一个有方向的网格上，每个三角形的法线将与它的缠绕方向相反。</strong></p>
<p><strong>给定一个合理的模型，这里有一个方法来定位多边形网格:</strong></p>
<pre><code>**1.为所有多边形形成边面结构。** 

**2.对边进行排序或散列，以找到匹配的边。** 

**3.找到一组互相接触的多边形。** 

**4.对于每一组，根据需要翻脸以获得一致性。**
</code></pre>
<p><strong>第一步是创建一组半边对象。半边是多边形的一条边，它有一个指向其相关面(多边形)的指针。由于一条边通常由两个多边形共享，因此这种数据结构称为半边。使用排序顺序创建每个半边，将其第一个顶点存储在第二个顶点之前。如果一个顶点的x坐标较小，那么它的排序顺序是在另一个顶点之前。如果x坐标相等，则使用y值;如果匹配，则使用z。例如，顶点(- 3,5,2)在顶点(- 3,6，- 8)之前;−3s匹配，但5 &lt; 6。</strong></p>
<p><strong>目标是找出哪些边是相同的。由于每条边的存储都是为了让第一个顶点小于第二个顶点，所以比较边就是比较第一个顶点和第二个顶点。不需要将一条边的第一个顶点与另一条边的第二个顶点进行比较。哈希表可以用来查找匹配的边。如果所有的顶点之前已经被合并，因此半边使用相同的顶点索引，那么每个半边都可以通过将其放在与其第一个顶点索引相关联的临时列表中进行匹配。一个顶点平均有6条边附加在其上，使得一旦分组后的边匹配非常迅速。</strong></p>
<p><strong>一旦这些边被匹配，相邻多边形之间的连接就被知道了，形成了一个邻接图。对于三角形网格，这可以表示为每个三角形的(最多)三个相邻三角形面的列表。任何没有两个相邻多边形的边都是边界边。由边连接的多边形集合形成一个连续的组。例如，茶壶模型有两组，壶和盖。</strong></p>
<p><strong>下一步是给网格方向一致性，例如，我们通常希望所有的多边形都有逆时针的轮廓。对于每一组连续的多边形，选择一个任意的起始多边形。检查每一个邻近的多边形，确定方向是否一致。如果两个多边形的遍历方向相同，则相邻的多边形必须翻转。看到下图。递归地检查这些邻居的邻居，直到连续组中的所有多边形都被测试一次。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029155452.png" class="" title="image-20211029155452">

<p>选择一个起始多边形S并检查它的邻居。因为S和B共享的边的顶点是以相同的顺序(从x到y)遍历的，所以B的轮廓需要颠倒，以遵循右手法则。</p>
<p><strong>虽然在这一点上所有的面都是正确的方向，但它们都可能是向内的。在大多数情况下，我们希望它们面向外部。一个快速测试是否所有面都应该翻转的方法是计算组的带符号体积并检查符号。如果它是负的，反转所有的循环和法线。通过计算每个三角形的带符号的体积标量三重积来计算这个体积，然后把它们加起来。在realtimerendering.com的在线线性代数附录中查找体积计算。</strong></p>
<p><strong>这种方法适用于固体物体，但并非万无一失。例如，如果物体是一个形成房间的盒子，用户希望它的法线面向相机。如果对象不是实体，而是一个表面描述，那么面向每个表面的问题就会变得难以自动执行。假如，两个立方体沿着一条边接触，并且是同一网格的一部分，那么这条边将被四个多边形共享，从而使方向更加困难。像M¨obius条这样片面的物体永远不能完全朝向，因为内部和外部没有分离。即使是性能良好的表面网格，也很难确定哪一边应该朝外。Takayama等人讨论了以前的工作，并提出了他们自己的解决方案，从每个面投射随机光线，并确定哪个方向从外部更可见。</strong></p>
<h3 id="Solidity-坚固"><a href="#Solidity-坚固" class="headerlink" title="Solidity 坚固"></a>Solidity 坚固</h3><p><strong>非正式地说，如果一个网格是有方向的，并且所有从外部可见的多边形都有相同的方向，那么它就会形成一个实体。换句话说，只有网格的一面是可见的。这种多边形网格被称为封闭的或水密的。</strong></p>
<p><strong>知道一个物体是实心的意味着可以使用背面剔除来提高显示效率，如19.2节中讨论的那样。对于投射阴影的物体(第7.3节)和其他一些算法来说，实心度也是一个关键属性。例如，3D打印机要求打印的网格是固体的。</strong></p>
<p><strong>最简单的实性测试是检查网格中的每个多边形边缘是否恰好由两个多边形共享。这个测试对于大多数数据集来说已经足够了。这样的曲面松散地称为流形，具体地说，是两流形。从技术上讲，一个流形表面是没有任何拓扑不一致的，例如有三个或更多的多边形共享一条边，或两个或更多的角相互接触。形成立体的连续曲面是没有边界的流形。</strong></p>
<h3 id="Normal-Smoothing-and-Crease-Edges-常规平滑和折痕边缘"><a href="#Normal-Smoothing-and-Crease-Edges-常规平滑和折痕边缘" class="headerlink" title="Normal Smoothing and Crease Edges 常规平滑和折痕边缘"></a>Normal Smoothing and Crease Edges 常规平滑和折痕边缘</h3><p><strong>一些多边形网格形成曲面，但是多边形顶点没有法向量，所以它们不能被渲染成曲率的假象。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029155900.png" class="" title="image-20211029155900">

<p>左边的对象没有每个顶点的法线;右边的有。</p>
<p><strong>许多模型格式不提供表面边缘信息。有关各种类型的边，请参阅第15.2节。这些边的重要性有几个原因。它们可以突出显示由一组多边形组成的模型区域，也可以帮助进行非照片渲染。因为它们提供了重要的视觉线索，这样的边缘通常是为了避免被渐进网格算法简化(第16.5节)。</strong></p>
<p><strong>合理的折痕边和顶点法线通常可以成功地从一个有方向的网格中导出。一旦方向一致，并且推导出邻接图，顶点法线就可以通过平滑技术生成。模型的格式可以通过为多边形指定平滑组来提供帮助网。平滑组值用于明确定义组中的哪些多边形属于一起组成曲面。不同平滑组之间的边缘被认为是锐利的。</strong></p>
<p><strong>另一种光滑多边形网格的方法是指定一个折痕角度。这个值与二面角相比较，二面角是两个多边形的平面法线之间的夹角。值的范围通常在20到50度之间。如果两个相邻多边形之间的二面角小于指定的折痕角，则认为这两个多边形属于同一平滑组。这种技术有时被称为边缘保存。</strong></p>
<p><strong>使用折痕角度有时会给一个不适当的平滑，圆角的边缘应该被折痕，或反之亦然。经常需要试验，没有一个单一的角度可以完美地工作一个网格。即使是平滑组也有局限性。举个例子，当你把一张纸夹在中间。这张纸可以被认为是一个单独的平滑组，但是它里面有折痕，一个平滑组会将其平滑。然后建模者需要多个重叠平滑组，或直接在网格上定义折痕边缘。另一个例子是由三角形构成的圆锥。光滑圆锥的整个表面给出了特殊的结果，尖端有一个法线直接指向沿着圆锥的轴线。锥尖是一个奇点。为了完美地表示插值法线，每个三角形需要更像一个四边形，在这个尖端位置有两个法线。</strong></p>
<p><strong>幸运的是，这种有问题的情况通常很少见。一旦找到平滑组，可以计算组内共享顶点的顶点法线。寻找顶点法线的标准教科书解决方案是平均共享顶点的多边形的表面法线。然而，这种方法可能导致不一致的和糟糕的加权结果。Th¨urmer和W¨uthrich提出了一种替代方法，在这种方法中，每个多边形法线的贡献由它在顶点处形成的角度加权。该方法具有无论共享顶点的多边形是否三角化都能得到相同结果的理想特性。如果镶嵌多边形变成了，比如说，两个共享顶点的三角形，平均法将错误地施加两倍于两个三角形的影响，就像它对原始多边形的影响一样。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029160030.png" class="" title="image-20211029160030">

<p>在左边，一个四边形和两个三角形的表面法线被平均给一个顶点法线。在中间，四边形被三角化了。这将导致平均法线移动，因为每个多边形的法线是同等权重的。在右边，Th¨urmer和W¨uthrich的方法用构成它的两条边之间的夹角来加权每个法线的贡献，因此三角剖分不会移动法线。</p>
<p><strong>Max给出了一种不同的加权方法，基于长边构成的多边形对法线的影响较小的假设。当使用简化技术时，这种类型的平滑可能是更好的，因为形成的较大的多边形将不太可能遵循表面的曲率。</strong></p>
<p><strong>Jin等人对这些方法和其他方法进行了全面的调查，得出结论，按角度加权要么是最佳方法，要么是在各种条件下的最佳方法之一。Cignoni实现了Meshlab中的一些方法，并对此进行了注释。他还警告不要用相关三角形的面积来衡量每条法线的贡献。</strong></p>
<p><strong>对于高度场，Shankel展示了如何利用角度加权方法在每个轴上取相邻点的高度差来快速近似平滑。对于给定的点p和四个相邻点p^(x−1) 和在高度场的x轴上为p^(x +1)，在y轴上为p^(y−1) 和p^(y+1), p处(非标准化)法线的近似值为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029160243.png" class="" title="image-20211029160243">

<h2 id="Triangle-Fans-Strips-and-Meshes-三角形、条形和网格体"><a href="#Triangle-Fans-Strips-and-Meshes-三角形、条形和网格体" class="headerlink" title="Triangle Fans, Strips, and Meshes 三角形、条形和网格体"></a>Triangle Fans, Strips, and Meshes 三角形、条形和网格体</h2><p><strong>三角形列表是存储和显示一组三角形的最简单、通常也是效率最低的方法。每个三角形的顶点数据一个接一个地放在一个列表中。每个三角形都有自己独立的三个顶点集合，所以三角形之间不共享顶点数据。提高图形性能的标准方法是通过图形管道发送共享顶点的三角形组。共享意味着对顶点着色器的调用更少，因此需要转换的点和法线更少。在这里，我们描述了共享顶点信息的各种数据结构，从三角形扇形和条形开始，逐步发展到更精细、更高效的曲面渲染形式。</strong></p>
<h3 id="Fans-扇"><a href="#Fans-扇" class="headerlink" title="Fans 扇"></a>Fans 扇</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029160708.png" class="" title="image-20211029160708">

<p>左图说明了三角形扇子的概念。三角形T0 发送顶点v0 (中心顶点)，v1和v2。接下来的三角形Ti (i &gt; 0)，只发送顶点vi+2．右图是一个凸多边形，它总是可以变成一个三角形扇形。</p>
<p><strong>三角形风扇外观如上图所示。这个数据结构展示了我们如何形成三角形，并使每个三角形的存储成本小于3个顶点。所有三角形共享的顶点称为中心顶点，在图中为顶点0。对于开始三角形0，发送顶点0、1和2(按此顺序)。对于后续三角形，中心顶点总是与之前发送的顶点和当前正在发送的顶点一起使用。三角形1是通过发送顶点3而形成的，从而创建一个由顶点0(总是包含)，2(之前发送的顶点)和3定义的三角形。三角形2是通过发送顶点4来构造的，以此类推。请注意，一般的凸多边形用三角形扇形表示是不重要的，因为它的任何点都可以用作起点，中心顶点。</strong></p>
<p><strong>一个有n个顶点的三角形扇形被定义为一个有序的顶点列表</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029160824.png" class="" title="image-20211029160824">

<p><strong>在v0 是中心顶点，带有一个结构强加在列表上，表示三角形i是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029160832.png" class="" title="image-20211029160832">

<p><strong>其中0≤i &lt; n−2。</strong></p>
<p><strong>如果一个三角形扇形由m个三角形组成，则第一个三角形发送3个顶点，其余m-1三角形再发送1个顶点。这意味着顶点的平均数量va，表示为长度为m的连续三角形扇</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029161052.png" class="" title="image-20211029161052">

<p><strong>很容易看出，va→1表示m→∞。这似乎与现实世界的情况没有太大关联，但考虑一个更合理的值。如果m = 5，那么va = 1.4，这意味着，平均而言，每个三角形只有1.4个顶点被发送。</strong></p>
<h3 id="Strips-条"><a href="#Strips-条" class="headerlink" title="Strips 条"></a>Strips 条</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029161306.png" class="" title="image-20211029161306">

<p>可以表示为一个三角形带的三角形序列。注意，在条形图中，三角形的方向会随着三角形的不同而变化，条形图中的第一个三角形会设置所有三角形的方向。在内部，通过遍历顶点[0,1,2]，[1,3,2]，[2,3,4]，[3,5,4]等来保持逆时针顺序。</p>
<p><strong>三角形带就像三角形扇子，之前三角形中的顶点被重用。不是一个中心点和前面的顶点被重用，而是前一个三角形的两个顶点帮助形成下一个三角形。考虑上图。如果这些三角形被视为一条长条，然后可能会有一种更紧凑的方式将它们发送到渲染管道。对于第一个三角形(表示为T0)，所有三个顶点(记为v0, v1v2)，按此顺序发送。对于这个条带中的后续三角形，只需要发送一个顶点，因为其他两个顶点已经与前一个三角形一起发送了。例如，发送三角形T1，只有顶点v3 发送，顶点v1 和v2 从三角形T0 用来构成三角形T1．对于三角形T2，只有顶点v4 发送，以此条的其余部分。</strong></p>
<p><strong>一个有n个顶点的连续三角形带被定义为一个有序的顶点列表，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029161429.png" class="" title="image-20211029161429">

<p><strong>加上一个结构来表示三角形i是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029161442.png" class="" title="image-20211029161442">

<p><strong>其中0≤I &lt; n−2。这种条带被称为连续的，因为顶点是按照给定的顺序发送的。这个定义意味着一个有n个顶点的连续三角形带有n - 2个三角形。</strong></p>
<p><strong>分析长度为m的三角形带的平均顶点数。(由m个三角形组成)，也记为va，与三角形粉丝相同(见公式16.4)，因为它们有相同的启动阶段，然后每个新三角形只发送一个顶点。同理，当m→∞时，va 对于三角形来说，条带自然也倾向于每个三角形的一个顶点。对于m = 20, va = 1.1，比3好很多，接近1.0的极限。与三角形扇形一样，第一个三角形的启动成本(通常需要花费3个顶点)会平摊到后面的三角形上。</strong></p>
<p><strong>三角带的吸引力源于这个事实。根据瓶颈在渲染管道中的位置，有可能保存到三分之二的时间花在渲染简单的三角形列表上。这种加速是为了避免冗余操作，比如将每个顶点两次发送到图形硬件，然后对每个顶点执行矩阵转换、剪切和其他操作。三角形条带对于草的叶片或其他边缘顶点不被其他条带重用的对象很有用。由于它的简单性，当输出多个三角形时，几何着色器使用条带。</strong></p>
<p><strong>在三角形条带上有几种变体，例如不对三角形施加严格的序列，或使用双顶点或重新启动索引值，以便多个断开的条带可以存储在一个缓冲区中。曾经有很多关于如何最好地将任意三角形网格分解成条状的研究。随着索引三角形网格的引入，顶点数据可以更好地重用，这使得显示速度更快，通常需要的内存也更少。</strong></p>
<h3 id="Triangle-Meshes-三角形网格"><a href="#Triangle-Meshes-三角形网格" class="headerlink" title="Triangle Meshes 三角形网格"></a>Triangle Meshes 三角形网格</h3><p><strong>三角形扇形和条形仍然有它们的用途，但所有现代GPU的标准是使用带有单个索引列表的三角形网格(章节16.3.1)用于复杂模型。条形和扇形允许一些数据共享，但网状存储允许更多。在网格中，一个额外的索引数组跟踪哪些顶点构成三角形。这样，一个顶点可以与几个三角形相关联。</strong></p>
<p><strong>连通平面图的Euler-Poincar´e公式有助于确定形成封闭网格的顶点的平均数量:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029161803.png" class="" title="image-20211029161803">

<p><strong>这里v是顶点的数目，e是边的数目，f是面的数目，g是genus。genus是指物体上的孔数。例如，球面的genus为0，环面的genus为1。假设每个面都有一个环。如果面可以有多个循环，公式就变成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029161812.png" class="" title="image-20211029161812">

<p><strong>其中l是循环的个数。</strong></p>
<p><strong>对于一个封闭(实体)模型，每条边有两个面，每条面至少有三条边，因此2e≥3f。如果网格都是三角形，按照GPU的要求，则2e = 3f。假设genus为0，用1.5f代入公式中的e，得到f≤2v−4。如果所有面都是三角形，则f = 2v−4。</strong></p>
<p><strong>对于大型闭合三角形网格，经验法则是三角形的数量大约等于顶点数量的两倍。类似地，我们发现每个顶点平均连接着近6个三角形(因此，6条边)。连接到一个顶点的边的数目称为顶点的价。注意，网格的网络不会影响结果，只有三角形的数量会影响结果。由于条带中每个三角形的平均顶点数接近于1，而顶点是三角形的两倍，如果一个大网格由三角形条表示，每个顶点平均要发送两次。在极限情况下，三角形网格可以向每个三角形发送0.5个顶点。</strong></p>
<p><strong>注意，这种分析只适用于光滑的、封闭的网格。一旦有边界边(两个多边形之间没有共享的边)，顶点与三角形的比率就会增加。Euler-Poincar´e公式仍然成立，但网格的外部边界必须被视为与所有外部边缘接壤的单独的(未使用的)面。类似地，在任何模型中，每个平滑组实际上是它自己的网格，因为GPU需要在两组相交的锐边有不同法线的单独顶点记录。例如，立方体的一个角落将在一个位置上有三个法线，因此将存储三个顶点记录。纹理或其他顶点数据的变化也会导致不同顶点记录的数量增加。</strong></p>
<p><strong>理论预测我们需要处理每个三角形大约0.5个顶点。在实践中，顶点由GPU进行转换，并放入先进先出(FIFO)缓存，或近似于最近使用(LRU)系统。这个缓存保存通过顶点着色器运行的每个顶点的变换后结果。如果一个进入的顶点位于这个缓存中，那么缓存的后转换结果可以在不调用顶点着色器的情况下使用，提供了一个显著的性能提高。如果三角形网格中的三角形以随机顺序向下发送，那么缓存就不太可能有用。三角形带算法优化缓存大小为2，即使用的最后两个顶点。Deering和Nelson首先探索了将顶点数据存储在一个更大的FIFO缓存中的想法，使用一种算法来确定将顶点添加到缓存中的顺序。</strong></p>
<p><strong>FIFO缓存的大小是有限的。例如，PLAYSTATION 3系统包含大约24个顶点，这取决于每个顶点的字节数。新的GPU并没有显著增加这个缓存，32个顶点是典型的最大值。</strong></p>
<p><strong>Hoppe引入了一个衡量缓存重用的重要指标——平均缓存miss比率(ACMR)。这是每个三角形需要处理的顶点的平均数量。它可以从3(每个三角形的每个顶点每次都必须被重新处理)到0.5(在一个大型封闭网格上的完美重用;没有顶点被重新处理)。如果缓存大小与网格本身一样大，则ACMR与理论顶点与三角形的比值相同。对于给定的缓存大小和网格顺序，可以精确地计算ACMR，从而描述针对该缓存大小的任何给定方法的效率。</strong></p>
<h3 id="Cache-Oblivious-Mesh-Layouts-缓参无关网格布局"><a href="#Cache-Oblivious-Mesh-Layouts-缓参无关网格布局" class="headerlink" title="Cache-Oblivious Mesh Layouts 缓参无关网格布局"></a>Cache-Oblivious Mesh Layouts 缓参无关网格布局</h3><p><strong>网格中三角形的理想顺序是最大限度地使用顶点缓存。Hoppe提出了一种最小化网格ACMR的算法，但是缓存的大小必须事先知道。如果假设的缓存大小大于实际的缓存大小，那么得到的网格的好处就会大大减少。解决不同大小的缓存可能会产生不同的最优排序。针对目标缓存大小未知的情况，提出了缓参无关网格布局算法这就产生了无论大小都能正常运行的订单。这种排序有时被称为通用索引序列。</strong></p>
<p><strong>Forsyth和Lin and Yu提供了使用相似原理的快速贪婪算法。顶点根据它们在缓存中的位置和附加在它们上的未处理三角形的数量得到分数。接下来处理组合顶点得分最高的三角形。通过对最近使用的三个顶点的评分稍微低一些，算法避免了简单地制作三角形条，而是创建类似于希尔伯特曲线的模式。通过给仍然连接的三角形较少的顶点更高的分数，该算法倾向于避免留下孤立的三角形。达到的平均缓存miss比率可与那些更昂贵和复杂的算法相媲美。Lin和Yu的方法稍微复杂一些，但使用了相关的思想。当缓存大小为12时，一组30个未优化模型的平均ACMR为1.522;优化之后，平均下降到0.664或更低，具体取决于缓存大小。</strong></p>
<p><strong>Sander等人概述了之前的工作，并介绍了他们自己的更快(虽然不是与缓存大小无关)方法Tipsify。另外，他们还努力将最外面的三角形放在列表的早期，以减少透支(第18.4.5节)。例如，想象一个咖啡杯。通过先绘制杯子外部的三角形，之后的内部三角形可能会被隐藏起来。</strong></p>
<p><strong>Storsj¨o对比和比较了Forsyth和Sander的方法，并提供了这两种方法的实现。他总结道，这些方法提供的布局接近于理论极限。Kapoulkine的一项最新研究比较了三家硬件供应商的GPU上的四种感知缓存的顶点排序算法。他的结论是，英特尔使用128条目的FIFO，每个顶点使用3个或更多条目，而AMD和NVIDIA的系统近似使用16条目的LRU缓存。这种架构差异显著影响算法行为。他发现Tipsify和Forsyth算法在这些平台上的表现相对较好。</strong></p>
<p><strong>综上所述，对三角形网格进行离线预处理可以显著提高顶点缓存性能，且该顶点阶段的总体帧率是瓶颈。它在实践中是快速、有效的O(n)。有几个可用的开源版本。考虑到这样的算法可以自动应用到网格中，并且这样的优化没有额外的存储成本，也不影响工具链中的其他工具，这些方法通常是成熟开发系统的一部分。例如，Forsyth的算法似乎是PLAYSTATION网格处理工具链的一部分。虽然由于现代GPU采用了统一的着色器架构，顶点变换后缓存得到了发展，但避免缓存丢失仍然是一个重要的问题。</strong></p>
<h3 id="Vertex-and-Index-Buffers-Arrays-顶点和索引缓冲区-数组"><a href="#Vertex-and-Index-Buffers-Arrays-顶点和索引缓冲区-数组" class="headerlink" title="Vertex and Index Buffers/Arrays 顶点和索引缓冲区/数组"></a>Vertex and Index Buffers/Arrays 顶点和索引缓冲区/数组</h3><p><strong>提供带有模型数据的现代图形加速器的一种方法是使用DirectX调用顶点缓冲区和OpenGL调用顶点缓冲区对象(VBOs)。我们将在本节中使用DirectX术语。提出的概念具有OpenGL等价物。</strong></p>
<p><strong>顶点缓冲区的思想是将模型数据存储在一个连续的内存块中。顶点缓冲区是一种特定格式的顶点数据数组。格式指定顶点是否包含法线、纹理坐标、颜色或其他特定信息。每个顶点在一个组中都有它的数据，一个顶点接着一个顶点。顶点的字节大小称为它的步幅。这种类型的存储器称为交错缓冲器。或者，可以使用一组顶点流。例如，一个流可以保存一个位置数组{p0p1p2…}和另一个单独的法线数组{n0n1n2…}。在实践中，在GPU上，一个包含每个顶点所有数据的缓冲区通常更有效，但并不需要避免多个流。多流的主要成本是额外的API调用，如果应用程序是CPU绑定的，但在其他方面并不重要的话，可能值得避免。</strong></p>
<p><strong>Wihlidal讨论了多流帮助呈现系统性能的不同方法，包括API、缓存和CPU处理优势。例如，用于CPU上的向量处理的SSE和AVX更容易应用于单独的流。使用多流的另一个原因是为了更有效地更新网格。如果，比如说，只有顶点位置流在随时间变化，那么更新这个属性缓冲区的成本要比形成并发送整个交错流的成本要低。</strong></p>
<p><strong>如何访问顶点缓冲区取决于设备的DrawPrimitive方法。数据可视为:</strong></p>
<pre><code>**1.单个点的列表。** 

**2.不连通线段的列表，即顶点对。** 

**3.一个单一的多段线。** 

**4.一种三角形列表，其中每组三个顶点组成一个三角形，例如，顶点[0,1,2]组成一个，顶点[3,4,5]组成下一个，以此类推。** 

**5.一种三角形扇形，其中第一个顶点与每一对连续的顶点组成一个三角形，例如，[0,1,2]，[0,2,3]，[0,3,4]。** 

**6.一种三角形带，其中每一组连续的顶点构成一个三角形，例如, [0, 1, 2], [1, 2, 3], [2, 3, 4]。**
</code></pre>
<p><strong>在DirectX 10中，三角形和三角形带也可以包含相邻的三角形顶点，用于几何着色器(章节3.7)。</strong></p>
<p><strong>顶点缓冲区可以被索引缓冲区直接使用或引用。索引缓冲区中的索引保存顶点缓冲区中的顶点位置。索引存储为16位无符号整数，如果网格较大且GPU和API支持，则存储为32位整数(章节16.6)。索引缓冲区和顶点缓冲区的组合用于显示与“原始”顶点缓冲区相同类型的绘制原语。不同之处在于索引/顶点缓冲区组合中的每个顶点只需要存储只在顶点缓冲区中执行一次，而不需要索引就可以在顶点缓冲区中执行重复。</strong></p>
<p><strong>三角形网格结构由索引缓冲器表示。存储在索引缓冲区中的前三个索引指定第一个三角形，后三个索引指定第二个三角形，以此类推。这种排列称为索引三角形列表，其中索引本身构成三角形列表。OpenGL将索引缓冲区和顶点缓冲区与顶点数组对象(VAO)中的顶点格式信息绑定在一起。索引也可以按三角形带顺序排列，这样可以节省索引缓冲区空间。这种格式，索引三角形带，很少在实践中使用，因为为大型网格创建这样的带集需要一些努力，所有处理几何的工具也需要支持这种格式。顶点和索引缓冲区结构的例子见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029163105.png" class="" title="image-20211029163105">

<p>定义原语的不同方法，按照从上到下的内存使用的大致顺序:分开的三角形，作为一个顶点三角形列表，作为两个或一个数据流的三角形带，以及作为一个索引缓冲区，列出分开的三角形或按三角形带顺序。</p>
<p><strong>使用哪种结构由原语和程序决定。显示一个简单的矩形很容易，只需要一个顶点缓冲区，使用四个顶点作为一个两个三角形的三角形或扇形。如前所述，索引缓冲区的一个优点是数据共享。另一个优点是简单，三角形可以是任何顺序和配置，而不是三角形带的锁步要求。最后，当使用索引缓冲区时，需要在GPU上传输和存储的数据量通常会更小。包含索引数组的小开销远远大于共享顶点所节省的内存。</strong></p>
<p><strong>索引缓冲区和一个或多个顶点缓冲区提供了一种描述多边形网格的方法。然而，数据存储的目标通常是GPU渲染效率，而不是最紧凑的存储。例如，存储立方体的一种方法是将它的8个角位置保存在一个数组中，将它的6个不同的法线保存在另一个数组中，以及定义它的面的6个四索引循环。然后，每个顶点位置由两个索引描述，一个用于顶点列表，一个用于普通列表。纹理坐标由另一个数组和第三个索引表示。这种紧凑的表示在许多模型文件格式中使用，如Wavefront OBJ。在GPU上，只有一个索引缓冲区可用。一个顶点缓冲区将存储24个不同的顶点，因为每个角位置有三个独立的法线，每个相邻的面。索引缓冲区将存储定义构成曲面的12个三角形的索引。Masserann讨论了如何有效地将这种文件描述转换为紧凑而高效的索引/顶点缓冲区，而不是不共享顶点的未索引三角形列表。更紧凑的方案是可能的，例如将网格存储在纹理映射或缓冲区纹理中，并使用顶点着色器的纹理获取或拉取机制，但它们的性能代价是不能使用转换后的顶点缓存。</strong></p>
<p><strong>为了获得最大的效率，顶点缓冲区中的顶点的顺序应该与索引缓冲区访问它们的顺序相匹配。也就是说，索引缓冲区中第一个三角形引用的前三个顶点应该是顶点缓冲区中的前三个顶点。当索引缓冲区中遇到新顶点时，它应该是顶点缓冲区中的下一个顶点。给出这个顺序可以使变换前的顶点缓存的缓存丢失最小化，而变换前的顶点缓存与变换后的缓存是分开的16.4.4节。对顶点缓存中的数据重新排序是一项简单的操作，但对于性能来说，它与为变换后的顶点缓存找到一个有效的三角形顺序同样重要。</strong></p>
<p><strong>还有一些更高级的方法用于分配和使用顶点和索引缓冲区，以实现更高的效率。例如，一个不改变的缓冲区可以存储在GPU上以使用每一帧，并且一个对象的多个实例和变体可以从同一个缓冲区生成。第18.4.2节将深入讨论此类技术。</strong></p>
<p><strong>使用管线的流输出功能(章节3.7.1)将处理过的顶点发送到一个新的缓冲区的能力允许在GPU上处理顶点缓冲区而不渲染它们。例如，描述三角形网格的顶点缓冲区可以在初始过程中被视为简单的点集。顶点着色器可以用来执行每个顶点的计算，结果通过流输出发送到一个新的顶点缓冲区。在后续的过程中，这个新的顶点缓冲区可以与描述网格连通性的原始索引缓冲区配对，以进一步处理和显示生成的网格。</strong></p>
<h2 id="Simplification-简化"><a href="#Simplification-简化" class="headerlink" title="Simplification 简化"></a>Simplification 简化</h2><p><strong>网格简化，也被称为数据减少或抽取，是一个过程，采取一个详细的模型，减少其三角形计数，同时试图保持其外观。对于实时工作，这个过程是为了减少存储和发送到管道的顶点的数量。这对于使应用程序具有可伸缩性非常重要，因为功能较弱的机器可能需要显示较低数量的三角形。模型数据也可以通过比合理表示所必需的更多的镶嵌来接收。下图给出了如何通过数据简化技术来减少存储的三角形的数量。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029232902.png" class="" title="image-20211029232902">

<p>左上方是用20万个三角形渲染的火山口湖的高度场。右上方的图显示了这个模型简化为1000个三角形不规则网络(TIN)中的三角形。下面的简化网格显示在底部。(图片由迈克尔·加兰提供。)</p>
<p><strong>Luebke指出了三种类型的网格简化:静态的、动态的和依赖视图的。静态简化是指在渲染开始之前创建单独的细节级别(LOD)模型，由渲染器在这些模型中进行选择。本表格涵盖于第19.9节。离线简化也可以用于其他任务，如为细分曲面提供粗网格以细化。动态简化提供了LOD模型的连续谱，而不是少数的离散模型，因此这种方法被称为连续细节水平(continuous level of detail, CLOD)算法。依赖视图的技术适用于模型中细节级别不同的地方。具体来说，地形渲染是一种情况下，附近的区域需要详细的表示，而那些在远处的细节水平较低。本节将讨论这两种类型的简化。</strong></p>
<h3 id="Dynamic-Simplification-动态简化"><a href="#Dynamic-Simplification-动态简化" class="headerlink" title="Dynamic Simplification 动态简化"></a>Dynamic Simplification 动态简化</h3><p><strong>减少三角形数量的一种方法是使用边折叠操作，即通过移动其两个顶点使其重合来删除一条边。请参见下图，以查看该操作的实际示例。对于实体模型，边折叠总共删除了两个三角形、三条边和一个顶点。所以，一个有3000个三角形的封闭模型将会有1500条折边应用到它上，以将它减少到零面。经验法则是，一个有v个顶点的封闭三角形网格大约有2v个面和3v条边。这条规则可以通过Euler-Poincar´e公式导出，该公式为固体表面的f - e + v = 2(第16.4.3节)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029233309.png" class="" title="image-20211029233309">

<p>左边是uv边缘坍塌之前的图形;右图显示了点u坍缩成点v，从而去掉了三角形A和B以及边uv。</p>
<p><strong>边缘坍塌过程是可逆的。通过将边缘折叠的顺序存储，我们可以从简化的模型开始，从简化的模型开始重构复杂的模型。这个特性对于模型的网络传输非常有用，因为数据库的边缘折叠版本可以以有效压缩的形式发送，并在模型接收时逐步建立和显示。由于这个特性，这种简化过程通常被称为独立于视图的渐进式网格划分(VIPM)。</strong></p>
<p><strong>在上图中，u被折叠成v的位置，但v也可以被折叠成u。一个限制于这两种可能性的简化系统是使用子集布局策略。这种策略的一个优点是，如果我们限制可能性，我们可以含蓄地编码所做的选择。这个策略它更快，因为需要评估的可能性更少，但它也可能产生低质量的近似，因为检查了更小的解空间。</strong></p>
<p><strong>当使用最优放置策略时，我们检查了更广泛的可能性。不是将一个顶点压缩成另一个顶点，而是将一条边的两个顶点压缩到一个新的位置。Hoppe研究了u和v同时移动到连接它们的边缘上的某个位置的情况。他指出，为了改进最终数据表示的压缩，搜索可以局限于检查中点。Garland和Heckbert更进一步，解了一个二次方程来找到一个最佳位置，一个可能位于边缘之外的位置。最优布局策略的优势在于，它们倾向于提供更高质量的网格。缺点是需要额外的处理、代码和内存来记录更大范围的可能位置。</strong></p>
<p><strong>为了确定最佳的点位置，我们对局部邻域进行了分析。由于以下几个原因，这种局部性是一个重要而有用的特性。如果边折叠的代价只取决于几个局部变量(例如边长和边附近的面法线)，代价函数很容易计算，而且每次折叠只影响它的几个邻居。例如，假设一个模型有3000条可能的折叠边，这些边在一开始就被计算出来了。执行成本-功能值最低的边缘折叠。因为它只影响附近的几个三角形及其边，只有那些代价函数受这些变化影响的边坍塌可能性需要重新计算(比如，10而不是3000)，并且这个列表只需要少量的诉诸。因为边折叠只影响其他几个边折叠代价值，维护这个代价值列表的一个好的选择是使用堆或其他优先级队列。</strong></p>
<p><strong>无论成本如何，必须避免某些收缩。参见下图中的示例。这些可以通过检查相邻三角形是否由于坍缩而翻转其法线方向来检测。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029233508.png" class="" title="image-20211029233508">

<p>这是一个严重崩溃的例子。左边是顶点u折叠成v之前的网格，右边是折叠之后的网格，显示了现在的边是如何交叉的。</p>
<p><strong>折叠操作本身就是对模型数据库的编辑。用于存储这些崩溃的数据结构有很好的文档记录。用代价函数对每条边的折叠进行分析，并对代价值最小的边进行折叠下一个。最佳成本函数可以也将随模型类型和其他因素而变化。根据所解决的问题，成本函数可以在速度、质量、健壮性和简单性之间进行权衡。它也可以被裁剪以保持表面边界，材料位置，照明效果，沿轴的对称，纹理放置，体积，或其他约束。</strong></p>
<p><strong>我们将提出Garland和Heckbert的二次误差度量(QEM)代价函数，以给出这种函数如何工作的感觉。这个功能在很多情况下都是通用的。相比之下，在早期的研究中，Garland和Heckbert发现使用Hausdorff距离是简化地形的最佳方法，其他人也证实了这一点。这个函数就是简化网格中的顶点与原始网格之间的最长距离。上上图显示了使用此度量的结果。</strong></p>
<p><strong>对于一个给定的顶点，有一组共享它的三角形，每个三角形都有一个与之相关的平面方程。移动顶点的QEM成本函数是每个平面与新位置之间距离的平方和。更正式地,</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029233647.png" class="" title="image-20211029233647">

<p><strong>新位置v和m个平面的成本函数，其中ni 平面i的法线，di 是它与原点的偏移量。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029233923.png" class="" title="image-20211029233923">

<p>左边的图形显示了一个立方体，沿着一条边有一个额外的点。中间的图显示了当点e缩到角c时会发生什么。右边的图显示c缩到角e。</p>
<p><strong>上图显示了同一条边的两个可能收缩的例子。假设这个立方体有两个单位宽。崩溃的成本函数e为c (e→c)将是0,因为点e不离开平面的股票时c。c→e的成本函数是1,因为c远离平面向右转的多维数据集的平方距离1。因为它的成本更低，所以e→c坍塌比c→e更可取。</strong></p>
<p><strong>这个成本函数可以用各种方法修改。想象两个三角形共享一条形成尖锐边缘的边，例如，它们是鱼鳍或涡轮机叶片的一部分。在这条边上坍缩顶点的代价函数很低，因为沿一个三角形滑动的点不会远离另一个三角形的平面。基本功能的成本值与去除特征的体积变化有关，但不能很好地反映其视觉重要性。有一种方法来保持一条有尖锐折痕的边是添加一个额外的平面，包括这条边，并有一个法线，即两个三角形法线的平均值。现在，远离这条边的顶点将有一个更高的代价函数。一种变化是通过三角形面积的变化来加权代价函数。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029234222.png" class="" title="image-20211029234222">

<p>网格简化。左上显示原始网格13546个面，右上被简化为1000个面，左下为500个面，右下为150个面。(图片c 1996微软。版权所有。)</p>
<p><strong>另一种类型的扩展是使用基于维护其他表面特征的成本函数。例如，模型的折痕和边界边在描绘它时很重要，所以应该尽量减少修改的可能性。参见上图。其他值得保留的表面特征是有材质变化的位置、纹理贴图边缘和每顶点颜色变化的位置。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029234239.png" class="" title="image-20211029234239">

<p>网格简化。顶行:用网格和简单的灰色材质。底部一行:带有纹理。从左到右:模型包含51123、6389和1596个三角形。模型上的纹理被尽可能地维护，尽管一些失真会随着三角形计数的下降而增加。(图片c 2016微软。版权所有。)</p>
<p><strong>大多数简化算法都存在一个严重的问题，即纹理通常会明显偏离其原始外观。当边缘被折叠时，纹理到表面的底层映射可能会被扭曲。此外，纹理坐标值可以在边界上匹配，但属于纹理应用的不同区域，例如，沿着模型镜像的中心边缘。Caillaud等人研究了以前的各种方法，并提出了他们自己的处理纹理接缝的算法。</strong></p>
<p><strong>速度可能是另一个问题。在用户创建自己内容的系统中，例如在CAD系统中，需要动态地创建详细级别模型。使用GPU进行简化已经取得了一些成功。另一种方法是使用更简单的简化算法，如顶点集群。这种方法的核心思想是用三维体素网格或类似的结构覆盖模型。体素中的任何顶点都被移动到该单元格的“最佳”顶点位置。这样做可能会消除一些三角形，当每个三角形的两个或多个顶点落在同一位置时，使其退化。该算法具有较好的鲁棒性，不需要网格间的连通性，且易于对分离的网格进行聚合成一个。然而，基本的顶点集群算法很少能给出完整的QEM方法那样好的结果。Willmott(1890)讨论了他的团队是如何将这种集群方法有效地应用于《孢子》中的用户创造内容。</strong></p>
<p><strong>将表面的原始几何形状转化为凹凸贴图的法线贴图是一个与简化相关的想法。小的特征，如纽扣或皱纹，可以用纹理来表示，在保真度上几乎没有损失。Sander等人讨论了这一领域以前的工作，并提供了解决方案。这种算法通常用于开发交互式应用程序的模型，将高质量的模型烘焙到纹理表示中。</strong></p>
<p><strong>简化技术可以从单个复杂模型生成大量的详细程度(LOD)模型。在使用LOD模型时发现的一个问题是，如果一个模型在一帧和下一帧之间立即替换另一个模型，有时可以看到过渡。这个问题叫做“弹出”。“一种解决方案是使用地貌来增加或减少细节水平。因为我们知道复杂模型中的顶点是如何映射到简单模型的，所以可以创建一个平滑的过渡。有关更多细节，请参阅19.9.1节。</strong></p>
<p><strong>使用与视图无关的渐进式网格的一个优点是，单个顶点缓冲区可以一次性创建，并在相同模型的不同细节级别之间共享。然而，在基本方案下，需要为每个副本创建一个单独的索引缓冲区。另一个问题是效率。由于折叠的顺序决定了三角形的显示顺序，顶点缓存一致性较差。Forsyth讨论了在形成和共享索引缓冲区时提高效率的几种实用解决方案。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029234550.png" class="" title="image-20211029234550">

<p>对称问题。左边的圆柱体有10个平面(包括顶部和底部)。中间气缸有9个平面，1个平面通过自动减薄消除。右圆柱体有9个平面后被建模的faceter再生。</p>
<p><strong>网格缩减技术可能是有用的，但完全自动化的系统不是万灵药。保持对称的问题如上图所示。一个天才的模型制作者可以创造出低三角数的物体，质量比由自动化程序生成的。例如，眼睛和嘴巴是脸部最重要的部分。一个幼稚的算法会把这些当成无关紧要的事情处理掉。Retopology是在使用建模、平滑或简化技术时，将边缘添加到模型中以保持不同的特征分离的过程。与简化相关的算法将继续发展并尽可能实现自动化。</strong></p>
<h2 id="Compression-and-Precision-压缩和精度"><a href="#Compression-and-Precision-压缩和精度" class="headerlink" title="Compression and Precision 压缩和精度"></a>Compression and Precision 压缩和精度</h2><p><strong>三角形网格数据可以以各种方式压缩其数据，并可以获得类似的好处。正如PNG和JPEG图像文件格式使用无损和有损压缩纹理，各种算法和格式已经开发用于三角形网格数据的压缩。</strong></p>
<p><strong>压缩最小化了数据存储所花费的空间，以花费在编码和解码上的时间为代价。传输较小表示所节省的时间必须超过用于解压缩数据的额外时间。当在互联网上传输时，缓慢的下载速度意味着可以使用更复杂的算法。使用MPEG-4中采用的TFAN可以压缩和有效解码网格连接性。像Open3DGC、OpenCTM和Draco这样的编码器可以创建模型文件，与仅使用gzip压缩相比，这些文件的大小可以是四分之一或更小。使用这些方案的解压缩是一次性的操作，速度相对较慢——每秒几百万个三角形，但节省了传输数据的时间，这比支付成本还划算。Maglo等人对算法进行了全面的回顾。在这里，我们主要关注与GPU本身直接相关的压缩技术。</strong></p>
<p><strong>本章的大部分内容都是关于最小化三角形网格存储的各种方法。这样做的主要动机是提高渲染效率。在几个三角形之间重用顶点数据，而不是重复，将会减少缓存丢失。删除几乎没有视觉影响的三角形可以节省顶点处理和内存。更小的内存会导致更低的带宽成本和更好的缓存使用。GPU在内存中存储的东西也有限制，所以数据缩减技术可以让更多的三角形被显示出来。</strong></p>
<p><strong>顶点数据可以使用固定速率压缩，原因与纹理压缩类似(章节6.2.6)。通过固定速率压缩，我们指的是最终压缩存储大小已知的方法。每个顶点都有一个自包含的压缩形式，这意味着解码可以在GPU上进行。Calver提出了各种使用顶点着色器进行解压的方案。Zarge指出，数据压缩还可以帮助将顶点格式对齐到高速缓存行。Purnomo等人将简化和顶点量化技术结合起来，使用图像空间度量对给定的目标网格尺寸进行网格优化。</strong></p>
<p><strong>在索引缓冲区的格式中可以找到一种简单的压缩形式。索引缓冲区由一个无符号整数数组组成，该数组给出顶点缓冲区中顶点的数组位置。如果小于等于2^16 顶点缓冲区中的顶点，那么索引缓冲区就可以使用unsigned short而不是unsigned long。一些API对小于2^8的网格支持无符号字节顶点，但是使用这些会导致昂贵的对齐问题，所以通常是避免的。值得注意的是，OpenGL ES 2.0，未扩展的WebGL 1.0，以及一些旧的台式机和笔记本电脑GPU都有不支持无符号长索引缓冲区的限制，所以必须使用无符号短索引缓冲区。</strong></p>
<p><strong>另一个压缩机会是使用三角形网格数据本身。作为一个基本的例子，一些三角形网格为每个顶点存储一个或多个颜色，以表示内置光照、模拟结果或其他信息。在典型的监视器上，颜色由红色、绿色和蓝色的8位表示，因此数据可以以3个无符号字节而不是3个浮点数存储在顶点记录中。GPU的顶点着色器可以将这个字段转换成单独的值，然后在三角遍历期间进行插值。但是，应该注意许多体系结构。例如，苹果建议iOS将3字节的数据字段填充为4字节，以避免额外处理。参见下图中的中间插图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029235006.png" class="" title="image-20211029235006">

<p>顶点数据的典型固定速率压缩方法。(来自Cigolle等，由Morgan McGuire提供。)</p>
<p><strong>另一种压缩方法是不存储任何颜色。例如，如果颜色数据显示温度结果，则温度本身可以存储为一个数字，然后转换为一维纹理中的颜色索引。更好的是，如果不需要温度值，那么可以使用一个无符号字节来引用这个颜色纹理。</strong></p>
<p><strong>即使温度本身被储存，它可能只需要几个小数点后的位置。浮点数的总精度为24位，比7位小数稍多一点。注意，16位几乎给出了5个精确的十进制数字。温度值的范围可能非常小，因此浮点格式的指数部分是不必要的。通过使用最小值作为偏移量和最高值减去最低值作为一个尺度，值可以在有限的范围内均匀分布。例如，如果值的范围从28.51到197.12，那么一个无符号短值将被转换为温度，首先将其除以2^16−1，然后乘以(197.12−28.51)的比例因子，最后加上偏移量28.51。通过存储数据集的比例和偏移因子，并将这些传递给顶点着色程序，数据集本身可以存储在一半的空间中。这种类型的变换称为标量量化。</strong></p>
<p><strong>顶点位置数据通常是这种缩减的一个很好的候选数据。单个网格在空间中跨度很小，所以为整个场景使用一个比例和偏移向量(或4 × 4矩阵)可以节省相当大的空间，而不会显著降低保真度。对于某些场景，可能会为每个对象生成一个比例和偏移量，从而增加每个模型的精度。然而，这样做可能会导致分离网格接触处出现裂缝。顶点最初在相同的世界位置，但在单独的模型可能被缩放和偏移到稍微不同的位置。当所有模型相对于场景整体来说都比较小时，一种解决方案是对所有模型使用相同的比例并对齐偏移量，这样可以增加一些精度。</strong></p>
<p><strong>有时，即使是顶点数据的浮点存储也不足以避免精度问题。一个经典的例子是在地球上空渲染的航天飞机。航天飞机模型本身可以精确到毫米尺度，但地球表面距离地球超过10万米，因此在尺度上相差8位。当航天飞机的世界空间位置相对于地球计算时，生成的顶点位置需要更高的精度。当没有采取任何纠正措施时，当观众靠近它时，梭子会在屏幕周围抖动。虽然航天飞机的例子是这个问题的一个极端版本，但如果在整个游戏中使用单一的坐标系统，大型多人游戏世界也会受到同样的影响。边缘上的物体会失去足够的精度，问题就会变得可见——动画的物体会晃动，单个顶点会在不同的时间被捕捉，阴影贴图的像素会随着相机的轻微移动而跳跃。一种解决方案是重做转换管道，这样，对于每个以原点为中心的对象，世界和摄像机的平移首先被连接在一起，所以基本上抵消了。另一种方法是分割世界并重新定义原点，使其位于每个部分的中心，然后将挑战从一个部分转移到另一个部分。Ohlarik和Cozzi and Ring对这些问题和解决方法进行了深入探讨。</strong></p>
<p><strong>其他顶点数据可能具有与之相关的特定压缩技术。纹理坐标通常被限制在[0.0,1.0]的范围内，因此通常可以安全地减少为无符号短裤，隐式偏移量为0，比例因子为2^16−1。通常有成对的值，可以很好地容纳两个unsigned short，甚至仅仅3字节，这取决于精度要求。</strong></p>
<p><strong>不同于其他坐标系，法线通常是标准化的，所以所有标准化法线的集合形成一个球体。由于这个原因，研究人员研究了球面到平面上的变换，以有效地压缩法线。Cigolle等人分析了各种算法的优势和权衡，并给出了代码样本。他们得出结论，八分仪和球面投影是最实用的，在有效解码和编码的同时最小化误差。Pranckeviˇcius和Pesce讨论了在为延迟着色生成G缓冲区时的正常压缩(第20.1节)。</strong></p>
<p><strong>其他数据可能具有可用于减少存储的属性。例如，法线、切线和双切线向量通常用于法线映射。当这三个向量相互垂直(不倾斜)，并且如果旋向是一致的，那么只有两个向量可以存储，第三个向量可以由叉乘导出。更紧凑的是，一个4字节的四元数用一个惯用位加上一个7位w可以表示基形成的旋转矩阵。为了更精确，可以省略四个四元数中最大的值，其他三个值以10位的方式存储。剩下的2位标识四个值中哪个没有被存储。由于四元数的平方和为1，我们可以从其他三个值推导出第四个值。Doghramachi等人使用正切/双正切/法线方案存储轴和角度。它也是4字节，与四元数存储相比，需要大约一半的着色器指令来解码。</strong></p>
<p><strong>一些固定速率压缩方法的总结见上图。</strong></p>
<h1 id="17-Curves-and-Curved-Surfaces-曲线和曲面"><a href="#17-Curves-and-Curved-Surfaces-曲线和曲面" class="headerlink" title="17 Curves and Curved Surfaces 曲线和曲面"></a>17 Curves and Curved Surfaces 曲线和曲面</h1><p><strong>三角形是一个基本的原子渲染原语。它是图形硬件调优后快速转换成阴影片段并放入framebuffer中的内容。然而，在建模系统中创建的对象和动画路径可以有许多不同的底层几何描述。曲线和曲面可以用方程精确地描述。对这些方程进行评估，然后创建一组三角形，并将其发送到管线中进行渲染。</strong></p>
<p><strong>使用曲线和曲面的好处至少有四:(1)它们具有比一组三角形更紧凑的表示，(2)它们提供可伸缩的几何原语，(3)它们提供比直线和平面三角形更平滑和更连续的原语，(4)动画和碰撞检测可能变得更简单和更快。</strong></p>
<p><strong>紧凑曲线表示为实时渲染提供了几个优势。首先，节省了模型存储的内存(从而提高了内存缓存效率)。这对于游戏机尤其有用，因为游戏机通常没有PC那么大的内存。变换曲面通常涉及的矩阵乘法比变换曲面的网格要少。如果图形硬件可以直接接受这样的曲面描述，主机CPU必须发送到图形硬件的数据量通常比发送一个三角形网格要少得多。</strong></p>
<p><strong>曲线模型描述，如PN三角形和细分曲面，有价值的性质，一个模型与少数多边形可以使更有说服力和现实。单个多边形被视为曲面，因此在曲面上创建更多的顶点。更高的顶点密度的结果是更好的光照表面和轮廓边缘与更高的质量。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031102405.png" class="" title="image-20211031102405">

<p>这是《使命召唤:高级战争》中的一个场景，角色Ilona的脸是使用Catmull-Clark细分曲面，使用第17.6.3节中的自适应四分树算法渲染的。(图片来源:动视出版公司2018年《使命召唤》)</p>
<p><strong>曲面的另一个主要优点是它们是可伸缩的。一个曲面描述可以变成2个三角形或2000个三角形。曲面是细节建模的一种自然形式:当曲面物体靠近时，对解析表示进行更密集的采样，生成更多的三角形。为在动画中，曲面的优点是需要动画的点数量要少得多。这些点可以用来形成一个曲面，然后可以生成一个光滑的镶嵌。此外，碰撞检测可能会更加高效和准确。</strong></p>
<p><strong>曲线和曲面的主题一直是整本书的主题。我们的目标是覆盖实时渲染中常见的曲线和表面。</strong></p>
<h2 id="Parametric-Curves-参数曲线"><a href="#Parametric-Curves-参数曲线" class="headerlink" title="Parametric Curves 参数曲线"></a>Parametric Curves 参数曲线</h2><p><strong>在这一节中，我们将介绍参数曲线。它们在许多不同的上下文中使用，并使用许多不同的方法实现。对于实时图形，参数曲线通常用于沿着预定义的路径移动查看器或某些对象。这可能包括改变位置和方向。然而，在本章中，我们只考虑位置路径。有关方向插值的信息，请参见第4.3.2节。另一个用途是渲染头发，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031102739.png" class="" title="image-20211031102739">

<p>使用镶嵌立方曲线绘制头发。(图片来自NVIDIA公司的“Nalu”演示。)</p>
<p><strong>假设您想要在一定的时间内将摄像机从一个点移动到另一个点，这与底层硬件的性能无关。举个例子，假设相机在这些点之间移动需要一秒钟，而渲染一帧需要50毫秒。这意味着我们将能够在这一秒内渲染20帧。在更快的计算机上，一帧可能只需要25毫秒，相当于每秒40帧，所以我们想要把摄像机移到40个不同的位置。用参数曲线可以找到任意一组点。</strong></p>
<p><strong>使用一些公式参数曲线描述点参数t的函数,在数学上,我们写成p (t),这意味着这个函数提供一个点的每个值t。参数t可能属于一些间隔,称为域,例如,t∈[a, b]。生成的点是连续的，即ε→0，则p(t + ε)→p(t)。松散地说，这意味着如果ε是一个很小的数字，那么p(t)和p(t + ε)是两个非常接近的点。</strong></p>
<p><strong>在下一节中，我们将从B´ezier曲线(一种常见的参数曲线形式)的直观和几何描述开始，然后将其放入数学设置中。然后讨论了如何使用分段B´ezier曲线，并解释了曲线连续性的概念。在17.1.4和17.1.5节中，我们将介绍另外两条有用的曲线，即三次Hermite和Kochanek-Bartels样条。最后，我们将在17.1.2节中介绍使用GPU渲染B´ezier曲线。</strong></p>
<h3 id="B´ezier-Curves-贝塞尔曲线"><a href="#B´ezier-Curves-贝塞尔曲线" class="headerlink" title="B´ezier Curves 贝塞尔曲线"></a>B´ezier Curves 贝塞尔曲线</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031103448.png" class="" title="image-20211031103448">

<p>两点之间的线性插值是直线上的路径(左)。对于7个点，线性插值显示在右上角，一些更平滑的插值显示在右下角。使用线性插值最令人反感的是线段之间连接处的不连续变化(突然的抖动)。</p>
<p><strong>线性插值在两点p之间画出一条路径，这是一条直线p0 和p1．这再简单不过了。参见上图中的左边插图。给定这些点，下面的函数描述了一个线性插值点p(t)，其中t是曲线参数，t∈[0,1]:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031103537.png" class="" title="image-20211031103537">

<p><strong>参数t控制点p(t)在直线上的位置;p (0) = p0， p(1) = p1， 0 &lt; t &lt; 1是p0 和p1之间直线上的一个点．如果我们想把摄像机从p0到p1 一秒内20步线性，然后我们用ti = i/(20−1)，其中i是帧号(从0开始到19结束)。</strong></p>
<p><strong>当你只在两点之间进行插值时，线性插值可能就足够了，但如果在一条路径上有更多的点，通常就不行了。例如，当插入几个点时，连接两段的点(也称为关节)上的突然变化是不可接受的。如上图右侧所示。</strong></p>
<p><strong>为了解决这个问题，我们进一步采用了线性插值的方法，并进行了多次线性插值。通过这样做，我们得到了B´ezier(发音为beh-zee-eh)曲线的几何结构。作为一个历史笔记，B´ezier曲线是由Paul de Casteljau和Pierre B´ezier独立开发的，用于法国汽车工业。它们被称为B´ezier曲线，因为B´ezier能够在de Casteljau之前公开他的研究，尽管de Casteljau在B´ezier之前写了他的技术报告。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031103925.png" class="" title="image-20211031103925">

<p>重复线性插值给出了B´ezier曲线。曲线被定义为三个控制点,a, b和c。如果我们想要找到曲线上的点的参数t = 1/3,我们第一次线性插入a和b之间d。接下来,e是插值b和c。最后一点,p (1/3) = f 是在d和e之间的插值。</p>
<p><strong>首先，为了能够重复插值，我们必须添加更多的点。例如，可以使用三个点，a、b和c，称为控制点。我们想求出p(1/3)也就是t = 1/3时，曲线上的点。我们使用t = 1/3，通过a &amp; b和b &amp; c的线性插值计算两个新点d和e。参见上图。最后，我们用d和e的线性插值来计算t = 1/3。我们定义p(t) = f，利用这种方法，我们得到如下关系:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031104042.png" class="" title="image-20211031104042">

<p><strong>这是一条抛物线，因为t的最大次数是2。事实上，给定n + 1个控制点，曲线的自由度是n。这意味着更多的控制点会给曲线更多的自由度。一阶曲线称为直线(称为线性曲线)，二阶曲线称为二次曲线，三阶曲线称为三次曲线，四阶曲线称为四次曲线，以此类推。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031104212.png" class="" title="image-20211031104212">

<p>从五个点重复线性插值得到四度(四次)B´ezier曲线。曲线位于控制点的凸包(绿色区域)内，用黑点标记。同样，在第一点，曲线与第一点和第二点之间的直线相切。这同样适用于曲线的另一端。</p>
<p><strong>这种重复或递归线性插值通常被称为de Casteljau算法。上图显示了使用5个控制点时的示例。为了一般化，不像本例中那样使用a-f点，而是使用以下符号。控制点用pi表示，所以在这个例子中，p0 = a, p1 = b, p2 = c，然后线性插值k次，得到中间控制点pi^k。在我们的例子中,我们有p₀¹ = d, p₁¹ = e, p₀² = f。n + 1个控制点的B´ezier曲线可以用下面的递归公式描述，其中pi⁰ = pi 是最初的控制点:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031104616.png" class="" title="image-20211031104616">

<p><strong>注意曲线上的一个点用p(t) = p0^n (t)来描述.这并不像看起来那么复杂。再考虑一下，当我们从三个点p0，p1和p2，相当于p₀⁰ , p₁⁰ 和p₂⁰。三个控制点表示n = 2。为了简化公式，有时把“(t)”从p中去掉。第一步k = 1，得到p10 =(1−t)p0 + tp1， p11 =(1−t)p1 + tp2．最后，对于k = 2，我们得到p₀² =(1−t)p₀¹ + tp₁¹，这和求p(t)是一样的。下图展示了其工作原理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031105050.png" class="" title="image-20211031105050">

<p>说明重复线性插值如何工作的B´ezier曲线。在本例中，给出了四次曲线的插值。这意味着有5个控制点，pi⁰ ， I = 0, 1, 2, 3, 4，如下所示。图应该是自下而上的阅读,也就是说,p₀¹由p₀⁰加权构成权重为1−t和加权p₁⁰以t加权。这继续,直到曲线的点p (t)获得。(高盛之后的插图。)</p>
<p><strong>现在我们已经掌握了B´ezier曲线的基本原理，我们可以看看对相同曲线的更数学的描述。</strong></p>
<h4 id="Bezier-Curves-Using-Bernstein-Polynomials-使用Bernstein多项式的贝塞尔曲线"><a href="#Bezier-Curves-Using-Bernstein-Polynomials-使用Bernstein多项式的贝塞尔曲线" class="headerlink" title="Bezier Curves Using Bernstein Polynomials 使用Bernstein多项式的贝塞尔曲线"></a>Bezier Curves Using Bernstein Polynomials 使用Bernstein多项式的贝塞尔曲线</h4><p><strong>如公式17.2所示，二次B´ezier曲线可以用代数公式来描述。原来每一条B´ezier曲线都可以用这样一个代数公式来描述，这意味着你不需要做重复的插值。如下式17.4所示，得到的曲线与式17.3所描述的曲线相同。这种B´ezier曲线的描述被称为Bernstein形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031122705.png" class="" title="image-20211031122705">

<p><strong>该函数包含Bernstein多项式，有时也称为B´ezier基函数，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031122735.png" class="" title="image-20211031122735">

<p><strong>这个方程的第一项二项式系数在第一章的式1.6中定义。Bernstein多项式的两个基本性质如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031122751.png" class="" title="image-20211031122751">

<p><strong>第一个公式表示Bernstein多项式在0到1之间当t也在0到1之间。第二个公式表示方程17.4中所有Bernstein多项式项对曲线的所有不同度求和为1(如下图所示)。松散地说，这意味着曲线将保持“接近”控制点pi．事实上，整个B´ezier曲线将位于控制点的凸包(参见我们的在线线性代数附录)，它遵循方程17.4和17.6。当计算曲线的边界面积或体积时，这是一个有用的属性。参见上上图中的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031122919.png" class="" title="image-20211031122919">

<p>n = 1, n = 2, n = 3的伯恩斯坦多项式(从左到右)。左图为线性插值，中间为二次插值，右图为三次插值。这些是B´ezier曲线的Bernstein形式中使用的混合函数。因此，要计算某一特定t值的二次曲线(中间图)，只需在x轴上找到t值，然后垂直移动，直到遇到三条曲线，这就给出了三个控制点的权重。注意，当t∈[0,1]时，Bin(t)≥0，以及这些混合函数的对称性:Bi^n(t) = Bn−i^n(1−t)。</p>
<p><strong>上图给出了n = 1, n = 2, n = 3时的Bernstein多项式。这些也被称为混合函数。n = 1(线性插值)的情况是有说明意义的，因为它显示了y = 1−t和y = t的曲线。这意味着当t = 0时，p(0) = p0，当t增大时，p0 减小，而p1 增加相同的数量，保持权重的总和等于1。最后，当t = 1时，p(1) = p1．一般情况下，对于p(0) = p0 p(1) = pn的所有B´ezier曲线均成立，端点被插值(即在曲线上)。曲线与向量p1 −p0相切也是正确的从t = 0到t = 1时pn −pn−1 。另一个有用的特性是，可以先旋转控制点，然后再计算曲线上的点，而不是先计算B´ezier曲线上的点，然后再旋转曲线。在曲线上通常控制点比生成的点要少，所以先对控制点进行变换效率更高。</strong></p>
<p><strong>以Bernstein版本的B´ezier曲线为例，假设n = 2，即一条二次曲线。则式17.4为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031123314.png" class="" title="image-20211031123314">

<p><strong>与17.2式相同。注意，上面的混合函数(1−t)²,2t(1−t)和t²是上图中间显示的函数。用同样的方法，将三次曲线简化为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031123439.png" class="" title="image-20211031123439">

<p><strong>方程可以写成矩阵形式</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031123449.png" class="" title="image-20211031123449">

<p><strong>这在做数学化简时很有用。</strong></p>
<p><strong>通过收集形式为t^k 的项由式17.4可以看出，每条B´ezier曲线都可以写成如下形式，称为幂次形式，其中ci 是通过收集条款而产生的观点:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031123537.png" class="" title="image-20211031123537">

<p><strong>为了得到B´ezier曲线的导数，可以直接对方程17.4进行微分。重组和收集项后的结果如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031123604.png" class="" title="image-20211031123604">

<p><strong>实际上，导数也是一条B´ezier曲线，但比p(t)低一度。</strong></p>
<p><strong>B´ezier曲线的一个潜在缺点是，它们不能通过所有的控制点(除了端点)。另一个问题是，随着控制点的增加，这种程度也在增加，使得评价变得越来越昂贵。解决这个问题的方法是在每一对后续控制点之间使用一条简单的低度曲线，并确保这种分段插值具有足够高的连续性。这是17.1.3-17.1.5节的主题。</strong></p>
<h4 id="Rational-Bezier-Curves-有理贝塞尔曲线"><a href="#Rational-Bezier-Curves-有理贝塞尔曲线" class="headerlink" title="Rational Bezier Curves 有理贝塞尔曲线"></a>Rational Bezier Curves 有理贝塞尔曲线</h4><p><strong>虽然B´ezier曲线可以用于许多事情，但它们没有那么多的自由度——只有控制点的位置可以自由选择。同时，并不是每一条曲线都能用B´ezier曲线来描述。例如，圆通常被认为是一个简单的形状，但它不能由一条或一组B´ezier曲线定义。一种选择是理性的B´ezier曲线。这种类型的曲线由式17.12所示的公式描述:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031125606.png" class="" title="image-20211031125606">

<p><strong>分母是Bernstein多项式的加权和，分子p(t) = Pi=0</strong></p>
<p><strong>是标准B´ezier曲线的加权版本(公式17.4)。对于这种类型的曲线，用户拥有权值wi，作为额外的自由度。关于这些曲线的更多信息可以在Hoschek和Lasser的和Farin的书中找到。Farin还描述了如何用三条有理B´ezier曲线来描述圆。</strong></p>
<h3 id="Bounded-B´ezier-Curves-on-the-GPU-GPU上有界贝塞尔曲线"><a href="#Bounded-B´ezier-Curves-on-the-GPU-GPU上有界贝塞尔曲线" class="headerlink" title="Bounded B´ezier Curves on the GPU GPU上有界贝塞尔曲线"></a>Bounded B´ezier Curves on the GPU GPU上有界贝塞尔曲线</h3><p><strong>本文将介绍在GPU上绘制B´ezier曲线的方法。具体来说，目标是“有界B´ezier曲线”，即填充曲线和第一个和最后一个控制点之间的直线之间的区域。有一种非常简单的方法可以做到这一点，即使用专门的像素着色器渲染一个三角形。</strong></p>
<p><strong>我们用二次方程，也就是二度，B´ezier曲线，控制点p0,p1和p2．如果我们设置这些顶点的纹理坐标为t0 = (0,0)， t1 = (0.5, 0) ，t2 =(1,1)，纹理坐标将在渲染三角形∆p0p1p2时像往常一样被插值．我们还计算每个像素在三角形内的标量函数，其中u和v是插值的纹理坐标:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031130152.png" class="" title="image-20211031130152">

<p><strong>像素着色器然后确定像素是在内部(f(u, v) &lt; 0)还是在外部。如下图所示。当使用这个像素着色器渲染透视投影三角形时，我们将得到相应的投影B´ezier曲线。Loop和Blinn给出了证明。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031130302.png" class="" title="image-20211031130302">

<p>有界B´ezier曲线渲染。左:曲线显示在标准纹理空间。右:曲线在屏幕空间中呈现。如果使用条件f(u, v)≥0来杀死像素，则渲染会产生浅蓝色区域。</p>
<p><strong>例如，这种技术可以用于渲染TrueType字体。如下图所示。Loop和Blinn还演示了如何渲染有理二次曲线曲线和三次曲线，以及如何使用这种表示来抗锯齿。由于文本呈现的重要性，这一领域的研究仍在继续。相关算法请参见第15.5节。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031130443.png" class="" title="image-20211031130443">

<p>一个e由几条直线和二次B´ezier曲线(左)表示。在中间，这个表示被“镶嵌”成几个有边界的B´ezier曲线(红色和蓝色)和三角形(绿色)。最后一个字母显示在右边。(经微软公司许可转载)</p>
<h3 id="Continuity-and-Piecewise-B´ezier-Curves-贝塞尔曲线"><a href="#Continuity-and-Piecewise-B´ezier-Curves-贝塞尔曲线" class="headerlink" title="Continuity and Piecewise B´ezier Curves 贝塞尔曲线"></a>Continuity and Piecewise B´ezier Curves 贝塞尔曲线</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031131233.png" class="" title="image-20211031131233">

<p>该图从左到右显示了两条三次B´ezier曲线(各有四个控制点)之间C⁰、G¹和C¹的连续性。上面一行显示控制点，下面一行显示曲线，左边曲线有10个样本点，右边曲线有20个样本点。以下时间点对用于本示例：(0.0, q0), (1.0, q3)和 (3.0, r3)．与C⁰ 连续性，在连接处有一个突然的震动(q³ = r⁰)。G¹改进了这一点，使连接处的切线平行(长度相等)。然而，由于3.0−1.0 ≠ 1.0−0.0，这并没有给C¹连续性。这可以在连接处看到，在那里有一个突然的加速度的样本点。实现C¹，连接点的右切线必须是左切线的两倍长。</p>
<p><strong>假设我们有两条三次B´ezier曲线，也就是说，每条曲线由四个控制点定义。第一条曲线由qi定义，第二个是ri， i = 0,1,2,3。为了连接这些曲线，我们可以设置q3 = r0．这个点叫做关节(joint)。然而，如上图所示，使用这种简单的技术，关节不会平滑。由若干条曲线(本例为两条)组成的复合曲线称为分段B´ezier曲线，这里用p(t)表示。更进一步，假设我们想要p(0) = q0， p(1) = q3 = r0， p(3) = r3．因此，当我们到达q0的时候,q3 = r0和r3,t0 = 0.0,t1 = 1.0, t2 = 3.0。参见上图的表示法。从上一节我们知道B´ezier曲线被定义为t∈[0,1]，所以这对于由qi定义的第一个曲线段来说是很好的从q0 是0.0,到q3 是1.0时间。但是当1.0 &lt; t≤3.0时会发生什么呢?答案很简单:我们必须使用第二段曲线，然后从[t1，t2]开始平移和缩放参数区间到[0,1]。这可以使用下面的公式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031132131.png" class="" title="image-20211031132131">

<p><strong>因此，它是t′ 输入由r定义的B´ezier曲线段i的年代。这很容易推广到将几个B´ezier曲线拼接在一起。</strong></p>
<p><strong>连接曲线的一个更好的方法是，在B´ezier曲线的第一个控制点，切线平行于q1 −q0 (部分17.1.1)。同样，在最后一个控制点，三次曲线与q3−q2相切。这种行为是显而易见的如图17.5所示。所以，为了使两条曲线在关节处相切，第一条曲线和第二条曲线的切线应该在这里平行。更正式的说法是:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031132242.png" class="" title="image-20211031132242">

<p><strong>这简单地说就是输入的切线 q3 −q2，在关节处的方向应该与向外的切线r1 −r0方向相同．</strong></p>
<p><strong>有可能达到比这更好的连续性，在上式中使用由下式定义的c:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031132449.png" class="" title="image-20211031132449">

<p><strong>这也显示在上图中。如果我们设t2 = 2.0，则c = 1.0，因此当各曲线段的时间间隔相等时，则入射和输出的切向量应该相同。然而，当t2 = 3.0。曲线看起来是相同的，但是p(t)在复合曲线上的移动速度将不是平滑的。方程17.16中的常数c处理了这个问题。</strong></p>
<p><strong>使用分段曲线的一些优点是可以使用低阶曲线，并且生成的曲线将经过一组点。在上面的例子中，三级，即为两个曲线段的每一个使用立方。三次曲线通常用于此，因为这些是最低度曲线，可以描述一个S形曲线，称为拐点。得到的曲线p(t)插值，即经过点q0,q3 = r0和r3．</strong></p>
<p><strong>在这一点上，通过实例介绍了两个重要的连续性措施。下面是曲线连续性概念的一个稍微数学化的表述。对于一般的曲线，我们用C^n 区分关节处不同类型的连续性的符号。这意味着所有的n阶导数在曲线上都是连续的非零的。C⁰的连续性意味着线段应该在同一点上连接，所以线性插值满足这个条件。本节中的第一个示例就是这样。C¹的连续性意味着，如果我们在曲线上的任何一点(包括关节)推导一次，结果也应该是连续的。这是本节中的第三个示例的情况，其中使用了方程17.16。</strong></p>
<p><strong>还有一个度量，表示为G^n。让我们以G¹(几何)连续性为例。因此，在一个关节处相交的曲线段的切向量应该是平行的，并且有相同的方向，但是没有关于长度的假设。换句话说，G¹的连续性比C¹弱，而C¹的曲线总是G¹，除非两条曲线在相交点的速度为零且在相交点之前有不同的切线。几何连续性的概念可以推广到高维空间。上图中间的插图显示了G¹连续性。</strong></p>
<h3 id="Cubic-Hermite-Interpolation-立方Hermite插值"><a href="#Cubic-Hermite-Interpolation-立方Hermite插值" class="headerlink" title="Cubic Hermite Interpolation 立方Hermite插值"></a>Cubic Hermite Interpolation 立方Hermite插值</h3><p><strong>B´ezier曲线很好地描述了平滑曲线构建背后的理论，但有时无法预测使用。在本节中，我们将介绍三次埃尔米特插值，这些曲线往往更容易控制。原因是，三次埃尔米特曲线不是用四个控制点来描述三次B´ezier曲线，而是用起点和终点 p0 和p1来定义三次埃尔米特曲线，开始和结束切线 m0 和m1．Hermite插值，p(t)，其中t∈[0,1]，为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031133337.png" class="" title="image-20211031133337">

<p><strong>我们也称p(t)为埃尔米特曲线段或三次样条曲线段。这是一个三次插值，因为在上面的公式中，t³是混合函数的最高指数。对于这条曲线，下面是成立的:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031133454.png" class="" title="image-20211031133454">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031133623.png" class="" title="image-20211031133623">

<p>埃尔米特三次插值的混合函数。注意切线混合函数的不对称性。对混合函数t³−t²和m1求反在公式17.17中会给出一个对称的外观。</p>
<p><strong>这意味着埃尔米特曲线插值p0 和p1，这些点的切线是m0 和m1．式17.17中的混合函数如上图所示，可以由式17.4和17.18推导得到。三次Hermite插值的一些例子如下图所示。所有这些例子都插值相同的点，但有不同的切线。还要注意不同的长度的切线给出不同的结果;更长的切线对整体形状有更大的影响。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031133722.png" class="" title="image-20211031133722">

<p>埃尔米特插值。曲线由两个点定义，p0和p1，以及一个切线m0 和m1，在每个点。</p>
<p><strong>在Nalu演示中使用Cubic Hermite插值来渲染头发。参见图17.2。粗控制毛发用于动画和碰撞检测，计算切线，立方曲线被镶嵌和渲染。</strong></p>
<h3 id="Kochanek-Bartels-Curves-Kochanek-Bartels曲线"><a href="#Kochanek-Bartels-Curves-Kochanek-Bartels曲线" class="headerlink" title="Kochanek-Bartels Curves  Kochanek-Bartels曲线"></a>Kochanek-Bartels Curves  Kochanek-Bartels曲线</h3><p><strong>当在两个以上的点之间进行插值时，可以连接几条埃尔米特曲线。然而，当这样做时，在选择提供不同特性的共享切线时有一定的自由度。在这里，我们将介绍一种计算切线的方法，称为Kochanek-Bartels曲线。假设有n个点p0，…pn−1，需要用n−1条埃尔米特曲线段进行插值。我们假设在每个点上只有一条切线，然后我们开始考虑“内切线”m1，…,mn−2．pi 点的切线可以计算为两个和弦的组合:pi −pi−1和pi+1 −pi，如下图中左侧所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134135.png" class="" title="image-20211031134135">

<p>计算切线的一种方法是使用和弦的组合(左)。右上一行为三条不同张力参数的曲线(a)，左图为a≈1，表示张力高;中间曲线a≈0，为默认张力;右曲线为a≈−1，即低张力。右边两条曲线的底部一行显示了不同的偏差参数。左边的曲线有负偏倚，右边的曲线有正偏倚。</p>
<p><strong>首先，引入了一个张力参数a，它改变了切向量的长度。这控制了在关节处曲线的尖锐程度。正切计算为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134008.png" class="" title="image-20211031134008">

<p><strong>上图右上一行显示了不同的张力参数。默认值是a = 0;较高的值会有更尖锐的弯曲(如果&gt; 1，将会有一个在关节处的环)，和负值给出较少的紧曲线附近的关节。其次，引入了一个影响切线方向(以及间接影响切线长度)的偏置参数b。同时使用张力和偏差</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134307.png" class="" title="image-20211031134307">

<p><strong>其中，默认值是b = 0。正偏置使弯曲更倾向于弦pi −pi−1，而一个负的偏向则使一个弯更倾向于另一个弦:pi+1 −pi．如上图中右下角所示。用户既可以设置张力和偏差参数，也可以让它们具有默认值，这就产生了通常所说的卡特穆尔-罗姆(Catmull-Rom)样条。第一个和最后一个点的切线也可以用这些公式计算，其中一个弦的长度被简单地设为零。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134445.png" class="" title="image-20211031134445">

<p>Kochanek-Bartels曲线的进出切线。在每个控制点pi，是时间ti 也显示了，其中ti &gt; ti−1对于所有的i。</p>
<p><strong>此外，控制关节行为的另一个参数可以纳入正切方程。然而，这需要在每个关节处引入两个切线，一个进入的切线，记为si (表示源)和一个输出，记为di (目的地)。参见上图。注意，pi 和pi+1 用切线di 和si+1．切线计算如下，其中c为连续性参数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134455.png" class="" title="image-20211031134455">

<p><strong>同样，c = 0是默认值，这使得si = di．设置c =−1给出si = pi −pi−1和di = pi+1 −pi，在关节处产生一个尖角，也就是C⁰．增加c的值等于si 和di 越来越像了。对于c = 0，那si = di．当c = 1时，得到si = pi+1 −pi和di = pi −pi−1．因此，连续性参数c是给用户更多控制的另一种方法，如果需要，它可以在关节处得到尖角。</strong></p>
<p><strong>张力、偏差和连续性的组合，其中默认参数值为a = b = c = 0，为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134942.png" class="" title="image-20211031134942">

<p><strong>只有当所有曲线段使用相同的时间间隔长度时，方程17.20和17.22才有效。为了考虑曲线段的不同时间长度，必须调整切线，类似于第17.1.3节所做的。调整过的切线，记为s′i 和d′i,都是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134952.png" class="" title="image-20211031134952">

<p><strong>其中，∆i = ti+1−ti。</strong></p>
<h3 id="B-Splines-B样条"><a href="#B-Splines-B样条" class="headerlink" title="B-Splines B样条"></a>B-Splines B样条</h3><p><strong>在这里，我们将简要介绍B样条的主题，我们将特别关注三次均匀B样条。一般来说，B样条与B´ezier曲线非常相似，可以表示为t(使用移位基函数)的函数βn (由控制点加权)，ck:例如,</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031140132.png" class="" title="image-20211031140132">

<p><strong>在这个例子中，这是一条曲线，其中t是x轴，sn(t)是y轴，控制点是均匀间隔的y值。要了解更广泛的报道，请参阅the Killer B ‘s、Farin和Hoschek and Lasser的文章。</strong></p>
<p><strong>在这里，我们将遵循rujters等人的介绍，并介绍均匀三次B样条的特殊情况。基函数，β3(t)，由三片拼接在一起:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031140342.png" class="" title="image-20211031140342">

<p><strong>这个基础函数的构造如下图所示。这函数处处具有C²连续性，这意味着如果将几个b样条曲线段拼接在一起，复合曲线也是C²。三次曲线具有C²连续性，n次曲线具有C^(n−1)连续性。一般来说，基本函数的创建如下所示。β0(t)是一个“平方”函数，即， |t| &lt; 0.5时为1，|t| = 0.5时为0.5，其他地方为0。下一个基函数，β1(t)由β0(t)积分得到给出了一个帐篷函数。之后的基函数是通过对β1(t)积分得到的给出了一个更平滑的函数，即C¹．这个过程重复得到C²，等等。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031140921.png" class="" title="image-20211031140921">

<p>左:β3(t)基函数表示为一条肥黑曲线，由两个分段三次函数(红色和绿色)构成。当|t| &lt; 1时，使用绿色曲线，红色曲线当1≤|t| &lt; 2，其他地方曲线为零。右:使用四个控制点ck， k∈{i−1,i, i + 1, i + 2}来创建曲线段，我们只会得到一条在ci 和ci + 1的t坐标之间的曲线。将α输入到w函数中以评估基函数，然后将这些值乘以相应的控制点。最后，所有的值加在一起，就得到了曲线上的一个点。参见下图。(rujters等人后右侧插图。)</p>
<p><strong>如何计算曲线段如上图中右侧所示，其公式为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031141218.png" class="" title="image-20211031141218">

<p><strong>注意，任何时候只会使用四个控制点，这意味着曲线有局部支持，即需要有限数量的控制点。函数wk(α)用β3()定义</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031141306.png" class="" title="image-20211031141306">

<p><strong>rujters等人表明这些可以重写为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031141335.png" class="" title="image-20211031141335">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031141411.png" class="" title="image-20211031141411">

<p>控制点ck (绿色圆圈)在这个例子中定义一个均匀三次样条。只有两条胖曲线是分段B样条曲线的一部分。左边(绿色)曲线是正确的 由最左边的四个控制点决定，右边(红色)曲线由最右边的四个控制点决定点。曲线在t = 1处相交，具有C²连续性。</p>
<p><strong>在上图中，我们展示了将两条均匀三次B样条曲线拼接成一条的结果。一个主要的优点是这些曲线是连续的，与三次B样条的基函数β(t)具有相同的连续性，β(t)是C²。从图中可以看出，并不能保证曲线将通过任何一个控制点。注意，我们还可以为x坐标创建B样条，它将给出平面上的一般曲线(而不仅仅是函数)。得到的二维点将是(s3^x (i + α)， s3^y (i + α))，即简单的对方程17.26的两个不同的计算，一个对x，一个对y。</strong></p>
<p><strong>我们已经展示了如何只使用均匀的B样条。如果控制点之间的间距是非均匀的，方程就会变得更复杂，但也更灵活。</strong></p>
<h2 id="Parametric-Curved-Surfaces-参数曲面"><a href="#Parametric-Curved-Surfaces-参数曲面" class="headerlink" title="Parametric Curved Surfaces 参数曲面"></a>Parametric Curved Surfaces 参数曲面</h2><p><strong>参数曲线的自然扩展是参数曲面。一个类比是，三角形或多边形是线段的延伸，我们从一到二维度。参数曲面可以用来建模带有曲面的物体。参数曲面由少量控制点定义。参数曲面的镶嵌是在几个位置评估曲面表示的过程，并将这些连接起来形成近似真实曲面的三角形。这样做是因为图形硬件可以有效地渲染三角形。在运行时，曲面可以被分割成尽可能多的三角形。因此，参数化表面是在质量和速度之间进行权衡的完美选择，因为更多的三角形需要更多的时间来渲染，但会提供更好的阴影和轮廓。参数曲面的另一个优点是控制点可以被动画化，然后曲面可以被镶嵌。这与直接动画一个大的三角形网格相反，后者可能更昂贵。</strong></p>
<p><strong>本节首先介绍B´ezier 贴片，这是带有矩形域的曲面。这些也被称为张量积B´ezier曲面。然后给出了具有三角域的B´ezier三角形，然后在第17.2.3节讨论了连续性。在17.2.4和17.2.5节中，有两种方法将每个输入三角形替换为B´ezier三角形。这些技术分别被称为PN三角形和Phong镶嵌。最后，在第17.2.6节给出了B样条贴片。</strong></p>
<h3 id="B´ezier-Patches-贝塞尔贴片"><a href="#B´ezier-Patches-贝塞尔贴片" class="headerlink" title="B´ezier Patches 贝塞尔贴片"></a>B´ezier Patches 贝塞尔贴片</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144005.png" class="" title="image-20211031144005">

<p>使用四个点的双线性插值。</p>
<p><strong>在17.1.1节中介绍的B´ezier曲线的概念可以从使用一个参数扩展到使用两个参数，从而形成曲面而不是曲线。让我们从线性插值扩展到双线性插值开始。现在，我们不再使用两个点，而是使用四个点，称为a、b、c和d，如上图所示。我们不再使用一个叫做t的参数，而是使用两个参数(u, v)。使用u线性插值a &amp; b和c &amp; d得到e和f:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144050.png" class="" title="image-20211031144050">

<p><strong>接下来，线性插值点e和f在另一个方向上线性插值，使用v。这就产生了双线性插值:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144214.png" class="" title="image-20211031144214">

<p><strong>注意，这与用于纹理映射的双线性插值的方程类型相同(第179页的方程6.1)。式17.30描述了最简单的非平面参数曲面，其中(u, v)的不同值生成了曲面上的不同点。有效值集为(u, v)∈[0,1]×[0,1]，即u和v都属于[0,1]。当域是矩形时，得到的曲面通常称为贴片。</strong></p>
<p><strong>为了从线性插值扩展B´ezier曲线，添加更多的点并重复插值。同样的策略也可以用于补丁。假设使用了9个点，排列在3 × 3的网格中。如下图所示，其中还显示了符号。为了从这些点形成一个双二次B´ezier patch，我们首先需要双线性插值4次，以创建4个中间点，如下图所示。接下来，曲面上的最后一点是由先前创建的点进行双线性插值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144403.png" class="" title="image-20211031144403">

<p>左:一个双二次B´ezier曲面，由9个控制点定义，pij ．右:在B´ezier曲面上生成一个点，四个点p¹ij 首先从最近的控制点使用双线性插值创建。最后，点曲面p(u, v) = p²00是由这些创建的点进行双线性插值。</p>
<p><strong>上面描述的重复双线性插值是de Castel- jau算法在贴片上的扩展。现在我们需要定义一些符号。曲面的度数是n，控制点是pi,j ，其中i和j属于[0…n]。因此，(n + 1)² 控制点用于度n的贴片。注意控制点应该上标一个0，即p⁰i,j ，但这经常被省略，有时我们使用下标 ij 而不是 i,j 当没有混乱的时候。使用de Casteljau算法的B´ezier补丁描述如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144643.png" class="" title="image-20211031144643">

<p><strong>与B´ezier曲线相似，B´ezier贴片上的(u, v)点为p^n 0,0(u, v)。B´ezier patch也可以用Bernstein多项式的Bernstein形式来描述，如式17.32所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144735.png" class="" title="image-20211031144735">

<p><strong>注意，在17.32式中，有两个参数m和n表示曲面的度。“复合”度有时用m × n表示，通常m = n，这使实现稍微简化了一点。m &gt;n的结果是，首先双线性插值n次，然后线性插值m - n次。如下图所示。对17.32式的另一种解释是将其改写为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144820.png" class="" title="image-20211031144820">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144835.png" class="" title="image-20211031144835">

<p>不同的方向有不同的度。</p>
<p><strong>其中<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144953.png" class="" title="image-20211031144953">从公式17.33的下面一行可以看出，当我们固定v值时，这只是一条B´ezier曲线。假设v = 0.35，点qi(0.35)可由B´ezier曲线计算得到，则式17.33描述了B´ezier曲面上的B´ezier曲线，此时v = 0.35。</strong></p>
<p><strong>接下来，我们将介绍B´ezier贴片的一些有用特性。通过在公式17.32中设置(u, v) = (0,0)， (u, v) = (0,1)， (u, v) =(1,0)和(u, v) =(1,1)，很容易证明B´ezier patch插值，即通过拐角控制点p0,0，p0,n，pn,0和pn,n．并且，每个贴片的边界都由边界上的控制点形成的n度B´ezier曲线来描述。因此，拐角控制点的切线是由这些边界B´ezier曲线定义的。每个角控制点都有两条切线，分别在u和v方向上。与B´ezier曲线的情况一样，贴片也位于其控制点的凸包内，并且</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031145148.png" class="" title="image-20211031145148">

<p><strong>(u, v)∈[0,1]×[0,1]。最后，旋转控制点并在贴片上生成点在数学上与在贴片上生成点然后旋转这些点是相同的(尽管通常比这更快)。</strong></p>
<p><strong>部分微分式17.32可得:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031145248.png" class="" title="image-20211031145248">

<p><strong>可以看出，贴片的程度在分化方向上减少了1。非归一化法向量的形式为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031145321.png" class="" title="image-20211031145321">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031145403.png" class="" title="image-20211031145403">

<p>左:一个3 × 3度的4 × 4b´ezier贴片的控制网格。在表面生成的四边形。右图:着色B´ezier贴片。</p>
<p><strong>在上图中，显示了控制网格和实际的B´ezier贴片。移动控制点的效果如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031145425.png" class="" title="image-20211031145425">

<p>这组图像显示当一个控制点被移动时，B´ezier贴片会发生什么。大部分更改都在移动的控制点附近。</p>
<h4 id="Rational-Bezier-Patches-有理贝塞尔贴片"><a href="#Rational-Bezier-Patches-有理贝塞尔贴片" class="headerlink" title="Rational Bezier Patches 有理贝塞尔贴片"></a>Rational Bezier Patches 有理贝塞尔贴片</h4><p><strong>正如B´ezier曲线可以扩展为有理B´ezier曲线(章节17.1.1)，从而引入更多的自由度，B´ezier 贴片也可以扩展为有理B´ezier 贴片:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031145745.png" class="" title="image-20211031145745">

<p><strong>查阅Farin的书和PHochek Pand Lasser的书了解这种类型的贴片。类似地，有理B´ezier三角形是B´ezier三角形的扩展，接下来处理。</strong></p>
<h3 id="B´ezier-Triangles-贝塞尔三角形"><a href="#B´ezier-Triangles-贝塞尔三角形" class="headerlink" title="B´ezier Triangles 贝塞尔三角形"></a>B´ezier Triangles 贝塞尔三角形</h3><p><strong>尽管三角形通常被认为是比矩形更简单的几何元素，但当涉及到B´ezier曲面时，情况并非如此:B´ezier三角形不像B´ezier patches那样简单。这种类型的补丁是值得展示的，因为它用于形成PN三角形和Phong镶嵌，这是快速和简单的。请注意，有些游戏引擎，如Unreal Engine、Unity和Lumberyard，支持Phong镶嵌和PN三角形。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031150128.png" class="" title="image-20211031150128">

<p>三次B´ezier三角形的控制点。</p>
<p><strong>控制点位于三角形网格中，如上图所示。B´ezier三角形的度数是n，这意味着每条边有n + 1个控制点。这些控制点用p⁰i,j,k表示有时缩写为pijk．注意，对于所有控制点，i + j + k = n，并且i, j, k≥0。因此，控制点总数为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031150359.png" class="" title="image-20211031150359">

<p><strong>毫无疑问，B´ezier三角形也是基于重复插值的。但是，由于域的三角形形状，必须使用重心坐标(章节22.8)进行插值。回想一下，三角形∆p0p1p2中的一个点 ，可以描述为p(u, v) = p0 + u (p1 −p0) + v (p2 −p0) =(1−u−v) p0 +up1 +vp2，其中(u, v)为质心坐标。对于三角形内部的点，以下必须保持:u≥0,v≥0，和1−(u + v)≥0 &lt;=&gt; u + v≤1。基于此，针对B´ezier三角形的de Casteljau算法是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031150804.png" class="" title="image-20211031150804">

<p><strong>B´ezier三角形的最后一点(u, v)是p^n 000(u, v)伯恩斯坦形式的B´ezier三角形是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031150849.png" class="" title="image-20211031150849">

<p><strong>Bernstein多项式现在同时依赖于u和v，因此计算方法不同，如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031150924.png" class="" title="image-20211031150924">

<p><strong>偏导数是:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031151018.png" class="" title="image-20211031151018">

<p><strong>B´ezier三角形的一些不足为奇的特性是，它们插值(通过)三个角控制点，每个边界都是由边界上的控制点描述的B´ezier曲线。曲面位于控制点的凸包内。一个B´ezier三角形如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031151045.png" class="" title="image-20211031151045">

<p>左:B´ezier三角形的线框。右:着色表面和控制点。</p>
<h3 id="Continuity-连续性"><a href="#Continuity-连续性" class="headerlink" title="Continuity 连续性"></a>Continuity 连续性</h3><p><strong>当从B´ezier表面构造一个复杂的物体时，人们经常想把几个不同的B´ezier表面缝在一起，形成一个复合表面。为了得到好看的结果，必须注意确保表面的合理连续性。这与第17.1.3节中描述曲线的精神是相同的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031151330.png" class="" title="image-20211031151330">

<p>如何用C¹把两个B´ezier贴片缝在一起连续性。加粗线上的所有控制点必须共线，并且它们在两个线段长度之间的比例必须相同。请注意,a3j = b0j 以获得贴片之间的共享边界。在下图的右侧也可以看到这一点。</p>
<p><strong>假设两个双三次B´ezier贴片应该拼接在一起。它们各有4 × 4个控制点。如上图所示，左边的贴片有控制点aij ，右边是控制点bij ，对于0≤i, j≤3。确保C⁰ 连续性，这些贴片必须在边界上共享相同的控制点，也就是说，a3j = b0j。</strong></p>
<p> <strong>然而，这并不足以得到一个好看的复合表面。相反，我们将提出一种简单的技术，使C¹具有连续性。为了实现这一点，我们必须约束最接近共享控制点的两行控制点的位置。这些行是a2j 和b1j ．对于每个j，点a2j,b0j和b1j 一定是共线的，也就是说，它们一定在一条直线上。而且，它们必须具有相同的比例，即||a2j −b0j | | = k | | b0j −b1j | |。这里k是常数，对于所有j k必须是相同的。示例如上图和下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031151713.png" class="" title="image-20211031151713">

<p>左列显示了两个B´ezier贴片，只有C⁰连续性。很明显，在这些斑块之间有一个不连续性的着色。右列为类似的斑块连接C¹连续性，看起来更好。在顶部一行中，虚线表示两个连接贴片之间的边界。在右上方，黑线表示连接贴片的控制点的共线性。</p>
<p><strong>这种构造使用了设置控制点的许多自由度。这一点在把共用一个角落的四个补丁拼接在一起时可以看得更清楚。其结构如下图所示。结果显示在该图的右侧，其中显示了共享控制点周围的8个控制点的位置。这9个点必须在同一平面上，并形成一个双线性贴片，如图17.17所示。如果满足角的G1连续性(且仅在那里)，就足以使9个点共面。它使用更少的自由度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031151946.png" class="" title="image-20211031151946">

<p>(a)将F、G、H和I四个贴片缝合在一起，所有贴片共享一个角落。(b)在垂直方向上，三组三点(每条粗体线上)必须使用相同的比例k。这个关系在这里没有显示;见最右边的图。对于(c)也进行了类似的处理，其中，在水平方向上，两个贴片必须使用相同的比例l。(d)当缝合在一起时，所有四个补丁必须垂直使用比例k，水平使用比例l。(e)结果显示，最接近(和包括)共用控制点的9个控制点的比率得到正确计算。</p>
<p><strong>B´ezier三角形的连续性通常更复杂，以及B´ezier 贴片和三角形的G¹条件。当构建一个包含许多B´ezier曲面的复杂物体时，通常很难看到它能够跨越所有边界获得合理的连续性。解决这个问题的一个方法是转向细分表面，在17.5节中讨论过。</strong></p>
<p><strong>请注意C¹连续性对于跨边界的好看纹理是必需的。对于反射和着色，G¹连续性得到了一个合理的结果。C¹或更高会得到更好的结果。如上上图所示。</strong></p>
<p><strong>在接下来的两个小节中，我们将介绍两种方法，利用三角形顶点的法线来推导每个输入(平面)三角形的B´ezier三角形。</strong></p>
<h3 id="PN-Triangles-PN三角形"><a href="#PN-Triangles-PN三角形" class="headerlink" title="PN Triangles PN三角形"></a>PN Triangles PN三角形</h3><p><strong>给定一个在每个顶点上都有法线的输入三角形网格，Vlachos等人的PN三角形方案的目标是构建一个比仅使用三角形更好看的表面。字母“PN”是“点和法线”的缩写，因为这是生成曲面所需的所有数据。它们也被称为N-patches。这个方案试图通过创建一个曲面来代替每个三角形来改善三角形网格的阴影和轮廓。镶嵌硬件能够动态地生成每个曲面，因为镶嵌是由每个三角形的点和法线生成的，不需要邻居信息。如下图所示。本文提出的算法建立在van Overveld和Wyvill的基础上。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031154759.png" class="" title="image-20211031154759">

<p>这些列显示了同一模型的不同级别的详细信息。左边显示的是原始三角形数据，由414个三角形组成。中间的模型有3726个三角形，右边的模型有20286个三角形，都是用该算法生成的。注意轮廓和阴影是如何改善的。下面一行显示了线框中的模型，这表明每个原始三角形生成相同数量的子三角形。模型由id软件提供。图片来自ATI技术公司演示。)</p>
<p><strong>假设有一个顶点为p300，p030和p003 的三角形与法线n200，n020和n002．基本的想法是使用这些信息为每个原始三角形创建一个立方体B´ezier三角形，并从B´ezier三角形生成尽可能多的三角形。</strong></p>
<p><strong>为了简化符号，将使用w = 1−u−v。一个三次B´ezier三角形由</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031154928.png" class="" title="image-20211031154928">

<p><strong>参见图17.22。为了保证两个PN三角形之间的边界上的C⁰连续性，可以通过角控制点和角上的法线来确定边上的控制点。(假设相邻三角形共享法线)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031155030.png" class="" title="image-20211031155030">

<p>B´ezier如何指向p210 是用在p300的法向量n200 和两个角点p300 和p030 来计算的，．</p>
<p><strong>假设我们想计算p210 使用控制点p300，p030 以及法向量n200 在p300，如上图所示。简单地取点2/3p300+ 1/3p030 然后投影到法向量n200的方向上，到由p300 和n200定义的切平面上。假设标准化的法线，点p210 是计算</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031155405.png" class="" title="image-20211031155405">

<p><strong>其他边界控制点也可以类似地计算，因此只剩下计算内部控制点p111．这如下面的方程所示，这个选择遵循一个二次多项式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031155417.png" class="" title="image-20211031155417">

<p><strong>Vlachos等选择插值法向，而不是使用方程17.42计算曲面上的两条切线，然后计算法线一个二次方案，如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031155512.png" class="" title="image-20211031155512">

<p><strong>这可以被认为是一个2度的B´ezier三角形，其中控制点是6个不同的法线。在17.46式中，度的选择，即因为导数比实际的B´ezier三角形低一度，而且法线的线性插值无法描述拐点。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031155605.png" class="" title="image-20211031155605">

<p>这个图说明了为什么法线的二次插值是需要的，为什么是线性插值是不够的。左列显示了当使用法线的线性插值时会发生什么。当法线描述一个凸面(顶部)时，这种方法可以很好地工作，但当表面有一个弯曲(底部)时，这种方法就失效了。右列表示二次插值。(van Overveld和Wyvill的插图。)</p>
<p><strong>为了能够使用方程17.46，法向控制点n110，n101和n011 需要计算。一个直观但有缺陷的解决方案是使用n200 和n020 (原三角形顶点的法线)的平均值来计算n110．然而,当n200 = n020，则再次遇到上图左下角所示的问题。相反,n110 是通过先取n200 和n020的平均值来构造的，然后在下图所示的π平面上反射这条法线。这个平面的法线平行于端点p300 和p030之间的差．由于只有法向量会在π上反射，我们可以假设π通过原点，因为法向量与平面上的位置无关。另外，注意每个法线都应该标准化。数学上，n110 的非标准化版本表示为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031155943.png" class="" title="image-20211031155943">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031160000.png" class="" title="image-20211031160000">

<p>n110 构造为PN三角形。虚线法线是n200 n020和n110的平均值是在π平面上反射的法线。π平面有一条平行于p030−p300的法线。</p>
<p><strong>最初，van Overveld和Wyvill在这个等式中使用了3/2而不是2。从图像中很难判断哪个值是最好的，但使用2可以很好地解释平面上的真实反射。</strong></p>
<p><strong>此时，三次B´ezier三角形的所有B´ezier点和二次插值的所有法向量都已经计算出来了。它只剩下在B´ezier三角形上创建三角形，以便它们可以被渲染。这种方法的优点是表面得到更好的轮廓和形状相对较低的成本。</strong></p>
<p><strong>指定详细级别的一种方法如下。原始三角形数据被认为LOD 0。然后LOD数随着三角形边上新引入的顶点数的增加而增加。因此，LOD 1为每条边引入了一个新顶点，因此在B´ezier三角形上创建了四个子三角形，LOD 2为每条边引入了两个新顶点，生成了9个子三角形。一般而言，LOD n生成(n + 1)² 子三角形。为了防止B´ezier三角形之间的裂缝，网格中的每个三角形必须用相同的LOD镶嵌。这是一个严重的缺点，因为一个小三角形会像一个大三角形一样被镶嵌。可以使用自适应镶嵌(第17.6.2节)和分数形镶嵌(第17.6.1节)等技术来避免这些问题。</strong></p>
<p><strong>PN三角形的一个问题是，折痕很难控制，通常需要在想要的折痕附近插入额外的三角形。B´ezier三角形之间的连续性只有C⁰，但在许多情况下，它们看起来仍然是可以接受的。这主要是因为法线在三角形之间是连续的，所以一组PN三角形模拟了G¹表面。Boubekeur等人提出了一个更好的解决方案，顶点可以有两条法线，这两个连通的顶点生成一条折痕。注意，为了获得好看的纹理，需要跨越三角形(或贴片)之间的边界的C¹连续性。同样值得知道的是，如果两个相邻的三角形不共享相同的法线，就会出现裂缝。Gr¨un描述了一种进一步提高PN三角形连续性质量的技术。Dyken等人提出了一种受PN三角形启发的技术，只有从观察者那里看到的轮廓是自适应镶嵌的，因此变得更弯曲。这些剪影曲线的推导方法与PN三角形曲线相似。为了获得平滑的过渡，它们混合了粗糙的轮廓和镶嵌的轮廓。为了改进连续性，F¨unzig等人提出了PNG1三角形，它是具有G¹的PN三角形的修正连续性无处不在。McDonald和Kilgard提出了PN三角形的另一种扩展，它可以处理相邻三角形上的不同法线。</strong></p>
<h3 id="Phong-Tessellation-冯氏镶嵌"><a href="#Phong-Tessellation-冯氏镶嵌" class="headerlink" title="Phong Tessellation 冯氏镶嵌"></a>Phong Tessellation 冯氏镶嵌</h3><p><strong>Boubekeur和Alexa提出了一种名为Phong tesselation的表面构造，它与PN三角形有许多相似之处，但评估更快，实现更简单。称底边三角形的顶点为p0，p1和p2，并设相应的标准化法线为n0，n1和n2．首先，回想一下在底边三角形的重心坐标(u, v)处的一个点被计算为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031160631.png" class="" title="image-20211031160631">

<p><strong>在Phong着色中，法线被插值到平面三角形上，同样使用上面的方程，但是用法线代替点。Phong镶嵌尝试使用重复插值创建一个Phong着色法线插值的几何版本，结果是一个B´ezier三角形。对于这个讨论，我们将参考下图。第一步是创建一个函数，将一个点q投影到一个点和一条法线所定义的切平面上。这是这样做的</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031160724.png" class="" title="image-20211031160724">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031160737.png" class="" title="image-20211031160737">

<p>用曲线代替曲面说明了Phong镶嵌结构，这意味着p(u)只是u的函数而不是(u, v)，对于ti也是类似的．注意，p(u)首先投影到切平面上，生成t0 和t1．在那之后,p* (u)由t0 和t1的线性插值得到．作为最后一步，形状因子α被用来混合基三角形和,p* (u)在这个例子中，我们使用α = 0.75。</p>
<p><strong>不是使用三角形顶点进行线性插值(方程17.48)，而是使用函数ti进行线性插值，其结果是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031161034.png" class="" title="image-20211031161034">

<p><strong>为了增加一些灵活性，添加了一个形状因子α，在基础三角形和方程17.50之间插入，这导致了Phong镶嵌的最终公式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031161043.png" class="" title="image-20211031161043">

<p><strong>其中α = 0.75是推荐设置。生成这个曲面所需的唯一信息是基础三角形的顶点和法线以及用户提供的α，使这个表面的评估快速。得到的三角路径是二次的，即小于PN三角形的度。法线是简单的线性插值，就像标准的Phong着色。如下图所示的例子说明了Phong镶嵌应用于网格的效果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031161159.png" class="" title="image-20211031161159">

<p>Phong嵌应用于怪物青蛙。从左到右:带有平着色的基础网格，带有Phong着色的基础网格，最后，Phong镶嵌应用到基础网格。注意改进的轮廓。在这个例子中，我们使用α = 0.6。(使用Tamy Boubekeur的演示程序生成的图片。)</p>
<h3 id="B-Spline-Surfaces-B样条曲面"><a href="#B-Spline-Surfaces-B样条曲面" class="headerlink" title="B-Spline Surfaces B样条曲面"></a>B-Spline Surfaces B样条曲面</h3><p><strong>第17.1.6节简要介绍了B样条曲线，在这里我们将以同样的方式介绍B样条曲面。第732页的公式17.24可以推广到B样条贴片为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031161352.png" class="" title="image-20211031161352">

<p><strong>这与B´ezier贴片公式相当相似(式17.32)。请注意,sn(u, v)是平面上的三维点。如果这个函数用于纹理过滤，方程17.52将是一个高度场和ck,l 是一维的，也就是高度。</strong></p>
<p><strong>对于双三次B样条贴片， β3(t)函数将用在17.52式中。共4×4控制点，ck,l，式17.52所描述的实际表面贴片位于最内层2 × 2控制点的内部。如下图所示。注意，双三次B样条贴片对于Catmull-Clark细分曲面(章节17.5.2)也是必不可少的。有很多关于B样条曲面的好书。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031161640.png" class="" title="image-20211031161640">

<p>双三次B样条的设置，它有4 × 4个控制点，ck,l．(u, v)的定义域是右边所示的单位平方。</p>
<h2 id="Implicit-Surfaces-隐式曲面"><a href="#Implicit-Surfaces-隐式曲面" class="headerlink" title="Implicit Surfaces 隐式曲面"></a>Implicit Surfaces 隐式曲面</h2><p><strong>到此为止，只讨论了参数曲线和曲面。隐式曲面是表示模型的另一个有用类。而不是使用一些参数，比如u和v，用来显式地描述曲面上的一个点，使用了下面的形式，称为隐函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101103146.png" class="" title="image-20211101103146">

<p><strong>这是解释如下:点p是隐式表面如果结果是0点时插入到隐函数f。隐式表面往往与射线相交测试使用(章节22.6 - -22.9),因为他们可能比相应的简单相交(如果有的话)参数表面。隐式曲面的另一个优点是构造立体几何算法可以很容易地应用于它们，也就是说，物体之间可以相互减去，逻辑上可以与对方进行AND:ed或OR:ed。此外，对象可以很容易地混合和变形。</strong></p>
<p><strong>一些位于原点的隐式曲面的例子如下</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101103253.png" class="" title="image-20211101103253">

<p><strong>这些都需要一些解释。球面就是从p到原点的距离减去半径，所以是fs(p, r)等于0，如果p在半径为r的球面上。否则，返回一个有符号的距离，其中负表示p在球面内，正表示在球面外。因此，这些函数有时也称为带符号距离函数(SDFs)。平面fxz(p)就是p的y坐标，即y轴为正的一侧。对于圆角框的表达式，我们假设每个分量计算绝对值(|p|)和向量的最大值。同样，d是方框半边的向量。见下图圆形框;这个公式在说明文字中作了说明。要得到一个非圆角框，只需设置r = 0。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101103651.png" class="" title="image-20211101103651">

<p>左:一个非圆角框，其带符号的距离函数为|| max(|p|−d, 0)||，其中p为待测点，d分量为如图所示的半边。注意|p|使其余的计算发生在右上象限(2D)。减去d等于|px|−dx 如果p沿x在方框内，则为负，其他轴也是如此。只有正值被保留，而负值被max()固定为零。因此，|| max(|p|−d, 0)||计算到框边的最近距离，这意味着如果在计算max()后有多个值为正值，则框外的带符号距离字段将四舍五入。右:圆角方框由非圆角方框减去r得到，非圆角方框向四面扩展r。</p>
<p><strong>隐式曲面的法线由偏导数描述，称为梯度，并记为∇f:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101103819.png" class="" title="image-20211101103819">

<p><strong>为了能够准确地计算它，方程17.55中的f必须是可微的，因此也是连续的。在实践中，人们经常使用一种叫做中心差分的数值技术，它使用场景函数f进行采样:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101103856.png" class="" title="image-20211101103856">

<p><strong>∇fy 和∇fz也是如此．回想一下,ex = (1,0,0)， ey = (0,1,0)， ez = (0,0,1)， ε是一个小数字。</strong></p>
<p><strong>要使用公式17.54中的原语构建场景，需要使用联合操作符∪。例如，f(p) = fs(p, 1)∪fxz(p)是由一个球体和一个平面组成的场景。联合运算符是通过取其两个操作数中最小的一个来实现的，因为我们想要找到离p最近的曲面。fs(p - t, 1)是一个被t平移的球体。将反变换应用到p上。使用r = mod(p, c)−0.5c而不是p作为带符号距离函数的参数，也可以直接在整个空间中重复一个对象。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101104114.png" class="" title="image-20211101104114">

<p>左:一对球体混合不同的增加(从左到右)混合半径和一层由重复的圆形盒子组成。右:三个球体混合在一起。</p>
<p><strong>隐式曲面的混合是一个很好的特征，可以用于通常被称为斑点建模、软对象或元球。一些示例请参见上图。基本思想是使用几个简单的原语，例如将它们平滑地混合在一起。每一个物体都可以看作一个原子，混合后得到原子的分子。混合可以有很多不同的方法。一种常用的混合两个距离的方法d1 和d2，半径为rb,是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101104212.png" class="" title="image-20211101104212">

<p><strong>其中d为混合距离。虽然这个函数只混合到两个对象的最短距离，但是这个函数可以重复使用来混合更多的对象(见上图的右半部分)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101104428.png" class="" title="image-20211101104428">

<p>Ray marching用带符号的距离场行进。虚线表示从它们的中心到最近的表面的距离。一个位置可以沿着射线前进到先前位置的圆的边界。</p>
<p><strong>要将一组隐函数形象化，通常使用的方法是射线行进。一旦你可以射线穿过一个场景，它也可能产生阴影，重新弯曲、环境遮挡和其他效果。上图说明了射线在带符号的距离域内行进。在射线上的第一点p处，求值到现场的最短距离d。因为这表明周围是一个球体半径d，p没有其他对象更近,我们可以把雷d单元沿射线方向等等,直到我们到达表面内一些,或者当一个预定义的ray-march步骤已经满足,在这种情况下,我们可以假设背景是打击。下图中显示了两个很好的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101104441.png" class="" title="image-20211101104441">

<p>雨林(左)和蜗牛(右)用带符号的距离函数和射线行进程序创建。树是用带有程序噪声的椭球体生成的。(图像由Shadertoy生成，使用I ~ nigo Quilez程序。)</p>
<p><strong>每个隐式曲面也可以变成由三角形组成的曲面。有几种算法可用于执行该操作。一个众所周知的例子是移动立方体算法，见第13.10节。使用Wyvill和Bloomenthal算法执行多边形化的代码可以在web上找到，de Ara´ujo等人对隐式曲面多边形化的最新技术进行了综述。Tatarchuk和Shopf描述了一种他们称之为行进四面体的技术，在这种技术中，GPU可以用来在三维数据集中寻找等值面。第48页的图3.13显示了一个使用几何着色器的等值面提取的例子。Xiao等人提出了一个流体模拟系统，在该系统中，GPU计算100k粒子的位置，并使用它们来显示等值面，所有这些都以交互速率进行。</strong></p>
<h2 id="Subdivision-Curves-细分曲线"><a href="#Subdivision-Curves-细分曲线" class="headerlink" title="Subdivision Curves 细分曲线"></a>Subdivision Curves 细分曲线</h2><p><strong>细分技术用于创建平滑的曲线和表面。在建模中使用它们的一个原因是，它们在离散曲面(三角形网格)和连续曲面(例如，B´ezier patches的集合)之间搭建了桥梁，因此可以用于细节级别技术(章节19.9)。在这里，我们将首先描述细分曲线如何工作，然后讨论更流行的细分曲面方案。</strong></p>
<p><strong>细分曲线最好用一个使用切角的例子来解释。参见下图。最左边的多边形的角被切掉，创建一个新的多边形有两倍的顶点。然后这个新多边形的角被切掉，以此类推直到无穷远(或者，更实际一点，直到我们看不到任何区别)。由此得到的曲线称为极限曲线，它是光滑的，因为所有的角都被截断了。这个过程也可以被认为是低通滤波器，因为所有尖角(高频)被去除。这个过程通常写成P0 →P1 →P2 ···→p∞, P0 是起始多边形，也称为控制多边形，P∞ 是极限曲线。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101110809.png" class="" title="image-20211101110809">

<p>Chaikin的细分计划正在实施。初始控制多边形P0 再次细分为P1和P2。可以看到，在细分的过程中，每个多边形的圆角pi都被切掉了。经过无穷次细分，得到了极限曲线P∞。这是一个近似方案，因为曲线不经过初始点。</p>
<p><strong>这个细分过程可以用许多不同的方法来完成，每一种方法都有一个细分方案。上图所示的方案称为Chaikin方案，其工作原理如下:假设一个多边形的n个顶点为P0 = {p₀⁰，…, p⁰n−1}，其中上标表示细分级别。Chaikin的方案在原多边形的每一对后续顶点之间创建两个新顶点，如pi^k 和 pi+1^k</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101111242.png" class="" title="image-20211101111242">

<p><strong>可以看出，上标从k到k + 1，这意味着我们从一个细分层到下一个细分层，即Pk →Pk+1．在这个细分步骤完成后，原始的顶点被丢弃，新的点被重新连接。这种行为可以从上图中看到，其中新点被创建，距离原始顶点1/4，距离相邻顶点。细分方案的美妙之处在于快速生成光滑曲线的简单性。然而，您并不会立即得到第17.1节中所述的曲线的参数形式，尽管可以证明Chaaikin算法生成了二次B样条。到目前为止，所提出的方案适用于(闭合)多边形，但大多数方案也可以扩展到开放折线。在Chaikin的例子中，唯一的区别是折线的两个端点在每个细分步骤中都被保留(而不是被丢弃)。这使得曲线经过端点。</strong></p>
<p><strong>有两种不同的细分方案，即近似和插值。一般来说，Chaaikin的格式是近似的，就像极限曲线一样不在初始多边形的顶点上。这是因为顶点被丢弃(或者更新，对于某些方案)。相反，插值格式保留了之前细分步骤中的所有点，因此极限曲线P∞ 通过P0P1P2的所有点，等等。这意味着该方案将插值初始多边形。如下图所示，使用与上图相同的多边形。该方案使用最近的四个点创建一个新点:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101111435.png" class="" title="image-20211101111435">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101111453.png" class="" title="image-20211101111453">

<p>4点细分方案。这是曲线经过初始点时的插值格式，一般是曲线Pi+1 经过P点i．注意，上上图中使用了相同的控制多边形。</p>
<p><strong>方程17.59中的第一行简单地表示，我们保留了前一步中的点，而不改变它们(即:第二行用于在pi^k 和 pi+1^k之间创建一个新点。重量w称为张力参数。当w = 0时，结果是线性插值，但当w = 1/16时，我们得到的行为如上图所示。可以看出，当0 &lt; w &lt; 1/8，得到的曲线为C¹。对于开放折线，我们会在端点处遇到问题因为我们需要在新点的两边都有两个点，而我们只有一个。如果端点旁边的点跨端点反射，就可以解决这个问题。对于折线的开始，p1 通过p0 反射获得p−1．然后在细分过程中使用这一点。p−1 的产生如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101111815.png" class="" title="image-20211101111815">

<p>反射点p−1的建立，用于开放折线。反射点计算为:p−1 = p0−(p1−p0) = 2p0−p1。</p>
<p><strong>另一种近似方案使用以下细分规则:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101111904.png" class="" title="image-20211101111904">

<p><strong>第一行更新已有的点，第二行计算相邻两点之间线段上的中点。该方案生成三次B样条曲线(第17.1.6节)。参考SIGGRAPH关于细分的课程，Killer B的书，Warren和Weimer的细分书，或者Farin的CAGD书了解更多关于这些曲线的信息。</strong></p>
<p><strong>给定点p及其相邻点，有可能直接将该点“推”到极限曲线，即确定p在p∞上的坐标．这对于切线也是可能的。例如，乔伊在网上对这个话题的介绍。</strong></p>
<p><strong>细分曲线的许多概念也适用于细分曲面，下面将介绍。</strong></p>
<h2 id="Subdivision-Surfaces-细分曲面"><a href="#Subdivision-Surfaces-细分曲面" class="headerlink" title="Subdivision Surfaces 细分曲面"></a>Subdivision Surfaces 细分曲面</h2><p><strong>细分曲面是定义具有任意拓扑的网格的光滑、连续、无裂纹曲面的强大范例。与本章中的所有其他表面一样，细分表面也提供了无限层次的细节。也就是说，您可以生成任意多的三角形或多边形，并且原始的表面表示是紧凑的。下图显示了一个被细分的曲面的例子。另一个优点是细分规则简单且易于执行。缺点是表面连续性的分析往往涉及数学问题。然而，这类分析往往只对那些希望创建新的细分方案的人感兴趣，超出了本书的范围。关于这些细节，可以参考Warren和Weimer的书和SIGGRAPH关于细分的课程。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101112132.png" class="" title="image-20211101112132">

<p>左上角的图像显示了控制网格，即这个原始的网格，是描述最终细分曲面的唯一几何数据。下面的图像被细分为一、二、三次。可以看到，越来越多的多边形被生成，表面变得越来越光滑。这里使用的方案是Catmull-Clark方案，见第17.5.2节。</p>
<p><strong>一般来说，曲面(和曲线)的细分可以被认为是一个两阶段的过程。从一个多边形网格开始，称为控制网格或控制笼，第一个阶段，称为细化阶段，创建新的顶点并重新连接以创建新的、更小的三角形。第二个阶段称为平滑阶段，通常为网格中的一些或所有顶点计算新的位置。如下图所示。这两个阶段的细节就是细分方案的特征。在第一阶段，一个多边形可以以不同的方式分割，而在第二阶段，细分规则的选择给出了不同的特征，如连续性水平，曲面是近似还是插值，这些特性在第17.4节中描述。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101112231.png" class="" title="image-20211101112231">

<p>细分为细化和平滑。细化阶段创建新的顶点并重新连接以创建新的三角形，平滑阶段为顶点计算新的位置。</p>
<p><strong>细分方案的特征可以是平稳的或非平稳的，均匀的或非均匀的，是基于三角形的还是基于多边形的。静态方案在每个细分步骤使用相同的细分规则，而非平稳可能会根据当前正在处理的步骤改变规则。下面处理的方案都是固定的。统一方案对每个顶点或边使用相同的规则，而非统一方案可能对不同的顶点或边使用不同的规则。例如，曲面边界上的边通常使用一套不同的规则。基于三角形的方案只作用于三角形，因此只生成三角形，而基于多边形的方案作用于任意多边形。</strong></p>
<p><strong>接下来介绍了几种不同的细分方案。接下来，介绍了两种扩展细分曲面使用的技术，以及细分法线、纹理坐标和颜色的方法。最后给出了一些实用的细分和绘制算法。</strong></p>
<h3 id="Loop-Subdivision-循环细分"><a href="#Loop-Subdivision-循环细分" class="headerlink" title="Loop Subdivision 循环细分"></a>Loop Subdivision 循环细分</h3><p><strong>Loop方法是第一个三角形细分方案。它类似于第17.4节中的最后一个方案，因为它是近似的，它更新每个现有的顶点，并为每条边创建一个新顶点。这个方案的连通性如下图所示。可以看到，每个三角形被细分为四个新的三角形，所以经过n个细分步骤，一个三角形被细分为4^n个三角形。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101112935.png" class="" title="image-20211101112935">

<p>两个细分步骤的连通性，如Loop方法。每个三角形生成四个新三角形。</p>
<p><strong>首先，让我们关注一个已经存在的顶点p^k，其中k为细分步骤的个数。这意味着p⁰是控制网格的顶点。</strong></p>
<p><strong>经过一个细分步骤，p⁰变成了p¹。一般为p⁰→p¹→p2→···→p∞，其中p∞为极限值。如果p^k有n个相邻顶点，则 pi^k, i∈{0,1，…， n−1}，则我们说p^k的价为n。上面描述的表示法见下图。此外，价为6的顶点被称为正顶点或普通顶点。否则就被称为不规则的或不寻常的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101113310.png" class="" title="image-20211101113310">

<p>用于循环的细分方案的符号。左邻域被细分为右邻域。中心点p^k被 p^(k+1)更新替换，对于 p^k和 pi^k之间的每条边，都创建一个新点( pi^(k+1), i∈1，…, n)。</p>
<p><strong>下面给出Loop方案的细分规则，其中第一个公式是将现有顶点p^k更新为 p^(k+1)的规则，第二个公式是创建新顶点 pi^(k+1), p^k和每一个 pi^k之间。n是 p^k的价</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101113708.png" class="" title="image-20211101113708">

<p><strong>注意，我们假设下标是以n为模计算的，所以如果i = n−1，那么对于i + 1，我们使用下标0，同样地，当i = 0时，对于i−1，我们使用下标n−1。这些细分规则可以很容易地可视化为蒙版，也称为模板。参见下图。它们的主要用途是，只用一个简单的插图就可以传达几乎整个细分方案。注意，两个掩码的权重总和都是1。这是一个对所有细分方案都适用的特征，其基本原理是一个新点应该位于加权点的邻域内。在17.61式中，常数β实际上是n的函数，由</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101113807.png" class="" title="image-20211101113807">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101113821.png" class="" title="image-20211101113821">

<p>Loop的细分方案的掩码(黑色圆圈表示更新/生成的顶点)。掩码显示了每个相关顶点的权重。例如，当更新一个已存在的顶点时，权值1- nβ用于已存在的顶点，权值β用于所有相邻的顶点，称为1环。</p>
<p><strong>对于β函数，Loop的建议给出了一个在每个正则顶点上的C²连续曲面，以及在其他地方的C¹连续曲面，即在所有不规则顶点上。由于在细分过程中只创建规则顶点，因此曲面在我们在控制网格中有不规则顶点的地方。下图是一个用Loop方法细分网格的例子。公式17.62的一个变体，避免了三角函数，由Warren和Weimer给出:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101113945.png" class="" title="image-20211101113945">



<p>用Loop的<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101113957.png" class="" title="image-20211101113957">细分方案对蠕虫进行了三次细分。</p>
<p><strong>对于规则的价，这里有一个C²面，还有其他的C¹面。由此产生的表面很难与常规的环路表面区分。对于一个没有闭合的网格，我们不能使用所提供的细分规则。相反，这些边界必须使用特殊的规则。对于Loop格式，可以使用公式17.60的反射规则。这也将在17.5.3节中讨论。</strong></p>
<p><strong>经过无穷多个细分步骤的曲面称为极限曲面。极限曲面点和极限切线可以用封闭形式表达式计算。用公式17.61第一行的公式计算顶点的极限位置，将β(n)替换为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101114127.png" class="" title="image-20211101114127">

<p><strong>顶点p^k的两个极限切线可以通过相邻顶点的权值计算，称为1环或1邻域，如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101114225.png" class="" title="image-20211101114225">

<p><strong>法线是n = tu ×tv．注意，这通常比第16.3节中描述的方法便宜，后者需要计算相邻三角形的法线。更重要的是，这给出了该点的确切法线。</strong></p>
<p><strong>近似细分方案的一个主要优点是得到的曲面趋于均匀。公平，松散地说，与曲线或表面弯曲的平滑程度有关。更高的公平性意味着更平滑的曲线或表面。另一个优点是近似格式比插值格式收敛得快。然而，这意味着形状通常会收缩。这对于小的凸网格是最显著的，如下图所示的四面体。减少这种效果的一种方法是在控制网格中使用更多的顶点。，建模时必须小心。Maillot和Stam提出了一个结合细分方案的框架，以便控制收缩。一个有时可以用来发挥巨大优势的特性是，Loop曲面包含在原始控制点的凸包内。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101114322.png" class="" title="image-20211101114322">

<p>一个四面体用循环细分五次√3，和改性蝴蝶（MB）方案。循环和√3-方案都是近似的，而MB是插值的，后者意味着初始顶点位于最终曲面上。我们只包括由于其在游戏和离线渲染中的流行性，本书中采用了近似方案。</p>
<p><strong>循环细分方案生成一个广义的三向四次箱样条。因此，对于只包含规则顶点的网格，我们实际上可以将曲面描述为一种样条曲面。但是，这种描述对于不规则的设置是不可能的。能够从任意顶点网格生成光滑的表面是细分方案的一大优点。对于使用Loop方案的细分曲面的不同扩展，请参见17.5.3和17.5.4节。</strong></p>
<h3 id="Catmull-Clark-Subdivision-Catmull-Clark细分"><a href="#Catmull-Clark-Subdivision-Catmull-Clark细分" class="headerlink" title="Catmull-Clark Subdivision Catmull-Clark细分"></a>Catmull-Clark Subdivision Catmull-Clark细分</h3><p><strong>两种最著名的可以处理多边形网格(而不仅仅是三角形)的细分方案是catmula - clark和Doo-Sabin。在这里，我们只简单介绍前者。Catmull-Clark的表面被用于皮克斯的短片《盖里的游戏》，《玩具总动员2》，以及皮克斯的所有后续故事片。这种细分方法也经常用于制作游戏模型，并且可能是最受欢迎的方法。正如DeRose等、Catmull-所指出的克拉克表面倾向于产生更对称的表面。例如，一个长方形的盒子会产生一个对称的椭球面，这与直觉是一致的。相反，基于三角形的细分方案将每个立方体面视为两个三角形，因此根据正方形的分割方式产生不同的结果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102142142.png" class="" title="image-20211102142142">

<p>Catmull-Clark细分的基本思想。每个多边形生成一个新点，每条边生成一个新点。然后像右边显示的那样连接起来。这里没有显示原始点的权重。</p>
<p><strong>上图显示了Catmull-Clark曲面的基本思想，757页图17.41显示了一个Catmull-Clark细分的实际例子。可以看出，该方案只生成四个顶点的面。事实上，在第一个细分步骤之后，只生成了价4的顶点，因此这些顶点被称为普通或规则(与三角方案的价6相比)。</strong></p>
<p><strong>按照Halstead等人的表示法，让我们关注顶点v^k 有n个周边边点ei^k，其中i = 0…n−1。参见下图。对于每一个面，都有一个新的面点f^(k+1) 为面形质心，即面上各点的平均值。鉴于此，细分规则为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102142421.png" class="" title="image-20211102142421">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102142704.png" class="" title="image-20211102142704">

<p>在细分之前，我们有蓝色顶点和相应的边和面。经过一步Catmull-Clark细分，我们得到红色顶点，所有新面都是四边形。(参见Halstead等人的插图。)</p>
<p><strong>可以看出，顶点v^(k+1)的计算方式为考虑的顶点的权重、边缘点的平均值和新创建的面点的平均值。另一方面，新的边缘点是通过考虑的顶点、边缘点和两个新创建的以边缘为邻居的面点的平均值来计算的。</strong></p>
<p><strong>Catmull-Clark曲面描述了一种广义双三次B样条曲面。因此，对于只由规则顶点组成的网格，我们实际上可以将曲面描述为双三次B样条曲面(章节17.2.6)。然而，这对于不规则的网格设置是不可能的，能够使用细分曲面处理这些是该方案的优点之一。极限位置和切线也可以使用显式公式计算，即使参数值是任意的。Halstead等人描述了一种计算极限点和法线的不同方法。</strong></p>
<p><strong>有关使用GPU渲染Catmull-Clark细分曲面的一组有效技术，请参见17.6.3节。</strong></p>
<h3 id="Piecewise-Smooth-Subdivision-分段平滑细分"><a href="#Piecewise-Smooth-Subdivision-分段平滑细分" class="headerlink" title="Piecewise Smooth Subdivision 分段平滑细分"></a>Piecewise Smooth Subdivision 分段平滑细分</h3><p><strong>从某种意义上说，曲面可能被认为是无趣的，因为它们缺乏细节。改进这种表面的两种方法是使用凹凸贴图或位移贴图(章节17.5.4)。这里描述了第三种方法，分段平滑细分。基本的想法是改变细分规则，使省道，角落，折痕可以使用。这增加了可以建模和表示不同表面的范围。Hoppe等人首先对Loop的细分曲面进行了描述。下图是标准Loop细分曲面和分段平滑细分曲面的比较。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102144725.png" class="" title="image-20211102144725">

<p>顶部的行显示了一个控制网格，以及使用标准Loop细分方案的极限曲面。下面一行显示了使用Loop方案的分段平滑细分。左下角的图像显示了带有标记边缘(锐)的控制网格，用浅灰色显示。由此产生的表面显示在右下角，带有角落、飞镖和折痕。(图片由Hugues Hoppe提供。)</p>
<p><strong>为了能够在表面上使用这些特征，我们想要锐利的边缘首先被标记，所以我们知道在哪里细分不同。锋利边缘的数量在一个顶点表示s。然后顶点分为:光滑(s = 0),飞镖(s = 1),折痕(s = 2),和角落(s &gt; 2)。因此,折痕表面是一条曲线,曲线是C⁰连续性。飞镖是一个非边界顶点，其中折痕结束并平滑地融入曲面。最后，一个角是三个或更多折痕在一起的顶点。边界可以通过将每个边界边缘标记为锐来定义。</strong></p>
<p><strong>在对各种顶点类型进行分类后，Hoppe等人使用一个表来确定对各种组合使用哪个掩码。它们还展示了如何计算极限曲面点和极限切线。Biermann等人提出了几种改进的细分规则。例如，当特殊顶点位于边界上时，前面的规则可能会导致间隙。新规则避免了这种情况。此外，它们的规则使指定顶点的法线成为可能，结果曲面将适应获得该点的法线。DeRose等人提出了一种创建软折痕的技术。它们允许边首先细分为尖锐的多次(包括分数)，然后使用标准细分。</strong></p>
<h3 id="Displaced-Subdivision-置换的细分"><a href="#Displaced-Subdivision-置换的细分" class="headerlink" title="Displaced Subdivision 置换的细分"></a>Displaced Subdivision 置换的细分</h3><p><strong>凹凸贴图(章节6.7)是一种为光滑表面添加细节的方法。然而，这只是一个错觉，改变了每个像素的正常或局部遮挡。不管有没有凹凸贴图，物体的轮廓看起来是一样的。凹凸映射的自然扩展是位移映射，其中表面是位移的。这通常是沿着法线的方向进行的。如果曲面上的点是p，它的标准化法线是n，那么移位曲面上的点是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102145611.png" class="" title="image-20211102145611">

<p><strong>标量d是p点的位移。位移也可以是向量值。</strong></p>
<p><strong>在本节中，将给出位移细分曲面。一般的想法是将一个移位的表面描述为一个粗控制网格，它被细分为一个光滑的表面，然后沿着其法线使用标量场移位。在位移细分曲面的情况下，式17.67中p为粗控制网格细分曲面上的极限点，n为在p处的归一化法线，计算为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102145719.png" class="" title="image-20211102145719">

<p><strong>在方程17.68中，pu 和pv 为细分曲面的一阶导数。因此，他们在p。 Lee等人中描述了两条切线，使用了粗控制网格的Loop细分曲面，其切线可由式17.65计算。注意这里的符号略有不同;我们使用pu 和pv 而不是tu 和tv．方程17.67描述了最终曲面的位移位置，但我们还需要一个法线ns，以便正确地渲染细分表面。分析计算如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102145812.png" class="" title="image-20211102145812">

<p><strong>为了简化计算，Blinn提出，如果位移较小，可以忽略第三项。否则，可使用以下表达式计算nu (同样的nv) :</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102145845.png" class="" title="image-20211102145845">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102150006.png" class="" title="image-20211102150006">

<p>在Loop的细分方案中一个普通顶点的掩模。注意，在使用这些掩码之后，结果的总和应该按如下所示进行分割。(参见Lee等人的插图。)</p>
<p><strong>请注意,n¯u 不是任何新的符号，它仅仅是计算中的一个“临时”变量。对于一个普通顶点(价n = 6)，第一和第二阶导数特别简单。他们的掩码如上图所示。对于一个特殊顶点(价n6 = 6)，方程17.69中第一行和第二行的第三项被省略。下图显示了一个使用带有Loop细分的位移映射的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102150106.png" class="" title="image-20211102150106">

<p>左边是一个粗糙的网格。在中间，它使用Loop的细分方案进行细分。右图显示了移位的细分表面。(图片由Aaron Lee、Henry Moreton和Hugues Hoppe提供。)</p>
<p><strong>当一个被置换的表面远离观察者时，标准凹凸贴图可以用来产生这种置换的错觉。这样做可以节省几何处理。一些凹凸映射方案需要顶点处的切空间坐标系统，可以使用以下方法:(b, t, n)，其中t = pu/ | | pu| |,b = n × t。</strong></p>
<p><strong>Nießner和Loop提出了与Lee等人类似的方法，但他们采用Catmull-Clark曲面，直接求位移函数的导数，速度更快。它们还使用硬件镶嵌管道(第3.6节)进行快速镶嵌。</strong></p>
<h3 id="Normal-Texture-and-Color-Interpolation-法线、纹理和颜色插值"><a href="#Normal-Texture-and-Color-Interpolation-法线、纹理和颜色插值" class="headerlink" title="Normal, Texture, and Color Interpolation 法线、纹理和颜色插值"></a>Normal, Texture, and Color Interpolation 法线、纹理和颜色插值</h3><p><strong>在本节中，我们将介绍不同的策略来处理法线，纹理坐标和每个顶点的颜色。</strong></p>
<p><strong>如第17.5.1节Loop格式所示，极限切线和极限法线可以显式计算。这涉及到三角函数，计算起来可能很昂贵。Loop和Schaefer提出了一种近似技术，其中Catmull-Clark曲面总是用双三次B´ezier曲面来近似(第17.2.1节)。对于法线，导出了两个切线，一个在u方向，一个在v方向。法向量就是这些向量之间的叉乘。一般来说，B´ezier patch的导数是用公式17.35计算的。但是，由于导出的B´ezier patches近似于Catmull-Clark surface，因此切线patches不会形成一个连续的法向场。参考Loop和Schaefer关于如何克服这些问题的论文。Alexa和Boubekeur认为，细分法线可以在每次计算的质量方面更有效，这在阴影中提供了更好的连续性。关于如何细分法线的细节，我们参阅他们的论文。在Ni等人的SIGGRAPH课程中还可以找到更多类型的近似。</strong></p>
<p><strong>假设网格中的每个顶点都有一个纹理坐标和颜色。为了能够使用这些细分表面，我们还必须为每个新生成的顶点创建颜色和纹理坐标。最明显的方法是使用与我们用于细分多边形网格相同的细分方案。例如，您可以将颜色视为四维向量(RGBA)，并将其细分为新的顶点创建新的颜色。这是一种合理的方法，因为颜色将有一个连续的导数(假设细分方案至少为C¹)，从而避免在表面上颜色的突然变化。当然，纹理坐标也可以这样做。然而，当纹理空间有边界时，必须小心。例如，假设我们有两个共享一条边的贴片，但是沿着这条边有不同的纹理坐标。几何图形应该像往常一样用表面规则进行细分，但是纹理坐标应该用边界规则进行细分。</strong></p>
<p><strong>Piponi和Borshukov给出了一种复杂的纹理细分曲面方案。</strong></p>
<h2 id="Efficient-Tessellation-高效曲面细分"><a href="#Efficient-Tessellation-高效曲面细分" class="headerlink" title="Efficient Tessellation 高效曲面细分"></a>Efficient Tessellation 高效曲面细分</h2><p><strong>为了在实时渲染环境中显示曲面，我们通常需要创建曲面的三角形网格表示。这个过程被称为镶嵌。最简单的镶嵌形式叫做均匀镶嵌。假设我们有一个参数B´ezier patch, p(u, v)，如公式17.32所述。我们想要通过计算每个贴片边11个点来镶嵌这个贴片，结果是10 × 10 × 2 = 200个三角形。最简单的方法是对紫外线空间进行均匀采样。因此，我们求p(u, v)对所有(uk, vl) = (0.1k, 0.1l)，其中k和l都可以是任意值0 ~ 10之间的整数。这可以通过两个嵌套的for循环来实现。可以为平面上的四个点p(uk, vl)、p (uk+1, vl)、p (uk+1, vl+1), p (uk, vl+1)．</strong></p>
<p><strong>虽然这很简单，但有更快的方法。比起通过总线从CPU到GPU发送由许多三角形组成的镶嵌曲面，将曲面表示发送给GPU并让它处理数据扩展更有意义。回想一下，镶嵌阶段在第3.6节中有描述。快速浏览，请参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102150659.png" class="" title="image-20211102150659">

<p>管线与硬件镶嵌，其中的新阶段显示在中间的三个(蓝色)框。我们在这里使用DirectX的命名约定，括号里是OpenGL的对应项。壳着色器计算控制点的新位置和计算镶嵌因子，这决定了后续步骤应该生成多少个三角形。镶嵌器在紫外线空间中生成点，在这种情况下是一个单位正方形，并将它们连接成三角形。最后，域着色器使用控制点计算每个uv坐标的位置。</p>
<p><strong>镶嵌器可以使用分数镶嵌技术，这将在下一节中描述。最后，我们描述了如何用镶嵌硬件渲染Catmull-Clark曲面和位移映射曲面。</strong></p>
<h3 id="Fractional-Tessellation-部分镶嵌"><a href="#Fractional-Tessellation-部分镶嵌" class="headerlink" title="Fractional Tessellation 部分镶嵌"></a>Fractional Tessellation 部分镶嵌</h3><p><strong>为了获得参数曲面更平滑的细节水平，Moreton引入了分数阶镶嵌因子。这些因素使自适应镶嵌的有限形式成为可能，因为不同的镶嵌因素可以在参数曲面的不同侧面使用。下面将介绍这些技术的工作原理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102155722.png" class="" title="image-20211102155722">

<p>左:普通镶嵌-一个因子用于行，另一个用于列。右:四条边的独立镶嵌因子。(参考莫尔顿的插图。)</p>
<p><strong>在上图中，左侧为行和列的常量镶嵌因子，右侧为所有四条边的独立镶嵌因子。注意，一条边的镶嵌因子是在那条边上生成的点的数目，减去1。在右边的贴片中，这两条边的内部使用了较大的顶部和底部因子，同样的，左右因子的较大也用于内部。因此，基本镶嵌率为4 × 8。对于因数较小的边，沿边填充三角形。Moreton更详细地描述了这个过程。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102155911.png" class="" title="image-20211102155911">

<p>上图:整数镶嵌。中间:分数镶嵌，分数向右。下:分数镶嵌，分数在中间。这种配置避免了相邻贴片之间的裂缝。</p>
<p><strong>分数阶镶嵌因子的概念如上图所示。对于n的整数镶嵌因子，在k/n处生成n + 1个点，其中k = 0，…对于分数阶镶嵌因子，在k/r处生成r，⌈r⌉点，式中k = 0，…,⌊r⌋。在这里，⌈r⌉计算r的上限，这是最接近+∞的整数，而数组元素⌊r⌋的值则计算下限，这是最接近−∞的整数。然后，最右边的点被“折断”到最右边的端点。从上图中间的插图可以看出，这个模式不是对称的。这就导致了问题，因为相邻的补丁可能会在另一个方向产生点，从而在表面之间产生裂缝。Moreton通过创建对称的点模式解决了这个问题，如上图底部所示。参见下图中的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102160312.png" class="" title="image-20211102160312">

<p>矩形区域被分割成小块的一种贴片。(参考莫尔顿的插图。)</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102160445.png" class="" title="image-20211102160445">

<p>三角形的分数阶镶嵌，镶嵌因子显示。请注意，镶嵌因子可能与实际的镶嵌硬件所产生的不完全一致。(图源自Tatarchuk)</p>
<p><strong>到目前为止，我们已经看到了用矩形域镶嵌曲面的方法，例如，B´ezier patches。然而，三角形也可以用分数进行镶嵌，如上图所示。像四边形一样，也可以为每个三角形的边指定一个独立的分数阶镶嵌率。如前所述，这启用了自适应镶嵌(第17.6.2节)，如下图所示，其中渲染了位移映射的地形。一旦创建了三角形或四边形，就可以将它们转发到管线中的下一个步骤，这将在下一个小节中处理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102160532.png" class="" title="image-20211102160532">

<p>使用自适应分数阶镶嵌的移位地形绘制。从右侧的放大网格可以看出，红色三角形的边缘使用独立的分数形镶嵌率，这给了我们自适应镶嵌。(图片由Advanced Micro Devices, Inc. Game Computing Applications Group提供)</p>
<h3 id="Adaptive-Tessellation-适应性镶嵌"><a href="#Adaptive-Tessellation-适应性镶嵌" class="headerlink" title="Adaptive Tessellation 适应性镶嵌"></a>Adaptive Tessellation 适应性镶嵌</h3><p><strong>当采样率足够高时，均匀镶嵌可以得到较好的结果。然而，在表面的某些区域可能不像在其他区域那样需要高镶嵌。这可能是因为表面在某些区域弯曲得更快，因此可能需要更高的镶嵌，而表面的其他部分几乎是平的或远的，只需要几个三角形来近似它们。解决产生不必要三角形问题的一个方法是自适应镶嵌，这是指根据某些度量来适应镶嵌率的算法(例如曲率，三角形边长，或一些屏幕尺寸测量)。上图显示了地形自适应镶嵌的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102160927.png" class="" title="image-20211102160927">

<p>在左边，两个区域之间可以看到一条裂缝。这是因为右边的镶嵌率比左边的高。问题在于右侧区域已经计算了有黑色圆圈的表面，而左侧区域没有。标准溶液在右边。</p>
<p><strong>必须小心避免在不同的镶嵌区域之间出现裂缝。参见上图。当使用分式镶嵌时，通常基于仅来自边缘本身的信息来确定边缘镶嵌因子，因为所有的边缘数据都是在两个连接的小块之间共享的。这是一个很好的开始，但由于浮点数不准确，仍然可能出现裂缝。Nießner等人讨论了如何使计算完全不漏水，例如，通过确保，对于一条边，无论是否从p0 p1进行镶嵌，返回的是完全相同的点，反之亦然。</strong></p>
<p><strong>在本节中，我们将介绍一些通用的技术，这些技术可以用来计算分数镶嵌率，或者决定何时终止进一步的镶嵌，以及何时将更大的块分割成一组更小的块。</strong></p>
<h4 id="Terminating-Adaptive-Tessellation-终止自适应镶嵌"><a href="#Terminating-Adaptive-Tessellation-终止自适应镶嵌" class="headerlink" title="Terminating Adaptive Tessellation 终止自适应镶嵌"></a>Terminating Adaptive Tessellation 终止自适应镶嵌</h4><p><strong>为了提供自适应镶嵌，我们需要确定何时停止镶嵌，或者等价地如何计算分数阶镶嵌因子。您可以只使用一条边的信息来确定镶嵌是否应该终止，或者使用来自整个三角形或组合的信息。</strong></p>
<p><strong>还应该注意的是，使用自适应镶嵌，如果某条边的镶嵌因素在一帧到下一帧之间变化太多，那么在帧之间就会出现“游泳”或“弹出”的伪影。这也可能是计算镶嵌因子时要考虑的因素。给定一条边(a, b)和一条相关曲线，即我们可以试着估计曲线在a和b之间的平坦程度，见下图。在参数空间中找到a与b之间的中点，并计算其三维对应点c。最后，计算c和它在a和b之间的投影d之间的长度l。这个长度l用来确定那条边上的曲线段是否足够平。如果l足够小，它就被认为是平的。注意，这种方法可能错误地认为s形曲线段是平的。解决这个问题的方法是随机扰动参数采样点。l的另一种用法是比值l/||a−b||，给出一个相对测度。注意，这种技术也可以扩展到考虑一个三角形，您只需计算三角形中间的曲面点，并使用从这个点到三角形平面的距离。为了确定这种类型的算法终止，通常会设置一些可以进行多少细分的上限。当达到这个极限时，再细分就结束了。对于分数镶嵌，从c到d的矢量可以投影到屏幕上，它的(缩放的)长度用作镶嵌率。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102161558.png" class="" title="image-20211102161558">

<p>点a和点b已经在这个曲面上生成了。问题是:应该在曲面上生成一个新的点c吗?</p>
<p><strong>到目前为止，我们已经讨论了如何仅从曲面的形状来确定镶嵌率。其他通常用于动态镶嵌的因素包括顶点的局部邻域是否为:</strong></p>
<p><strong>1.在视图截锥内。</strong></p>
<p><strong>2.朝前的面。</strong></p>
<p><strong>3.占据较大的屏幕空间。</strong></p>
<p><strong>4.接近物体的轮廓。</strong></p>
<p><strong>这些因素将在这里依次讨论。对于视图截锥剔除，可以放置一个球体来包围边缘。然后在视图截锥上测试这个球体。如果它在外面，我们就不进一步细分那条边。</strong></p>
<p><strong>对于表面剔除，在a, b和可能的c处的法线可以从表面描述中计算出来。这些法线，连同a,b,c，定义了三个平面。如果所有的都是背面的，很可能不需要进一步细分的边缘。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102161832.png" class="" title="image-20211102161832">

<p>线段的屏幕空间投影s的估计。</p>
<p><strong>有许多不同的方法可以实现屏幕空间覆盖(请参见第19.9.2节)。所有的方法都将一些简单的物体投射到屏幕上，并估计屏幕空间的长度或面积。一个大的面积或长度意味着镶嵌应该进行。从a到b的线段的屏幕空间投影的快速估计如上图所示。首先，线段被平移，使其中点在视图射线上。然后，假设线段平行于近平面n，屏幕空间投影s从这条线段计算出来。使用图中线段a ‘和b ‘向右的点，屏幕空间投影就完成了</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102161939.png" class="" title="image-20211102161939">

<p><strong>分子就是线段的长度。除以从眼睛到线段中点的距离e。然后将计算得到的屏幕空间投影s与表示屏幕空间中最大边长的阈值t进行比较。重写前一个方程，避免计算平方根，如果满足以下条件，镶嵌继续:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102162017.png" class="" title="image-20211102162017">

<p><strong>注意，t²是常数，所以可以预先计算。对于分数镶嵌，可以使用公式17.71中的s作为镶嵌率，可能还应用了比例因子。另一种测量投影边长的方法是将一个球体置于边缘的中心，使半径为边缘长度的一半，然后利用球体的投影作为边缘镶嵌因子。这个测试与面积成正比，而上面的测试与边长成正比。</strong></p>
<p><strong>增加轮廓的镶嵌率是很重要的，因为它们对物体的感知质量起着主要作用。通过测试a点的法向量和从眼睛到a的向量之间的点积是否接近于零，可以确定一个三角形是否靠近轮廓边。如果这对a, b或c中的任何一个都成立，就应该做进一步的镶嵌。</strong></p>
<p><strong>对于移位细分，Nießner和Loop对每个基网格顶点v使用下列因素之一，该顶点与n个边向量ei相连，i ∈ {0, 1, . . . , n − 1}:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102162215.png" class="" title="image-20211102162215">

<p><strong>当循环的下标i遍历所有连接到v的n条边ei时，c的位置是和ki 是用户提供的常数。在这里,f1 是简单地基于从摄像机到顶点的距离f2 计算连接v和f3的四边形的面积使用最大的边长。顶点的镶嵌因子是然后计算为该边的两个基顶点的镶嵌因子的最大值。内镶嵌因子的计算是对边的镶嵌因子的最大值(以u和v为单位)。这种方法可以用于本节中介绍的任何边缘镶嵌因子方法。</strong></p>
<p><strong>值得注意的是，Nießner等人建议对字符使用单个全局镶嵌因子，这取决于与字符的距离。细分的数量是⌈log₂f⌉，其中f是每个字符的镶嵌因子，可以使用上面的任何方法计算。</strong></p>
<p><strong>很难说什么方法在所有应用程序中都有效。最好的建议是测试几个给出的启发式方法，以及它们的组合。</strong></p>
<h4 id="Split-and-Dice-Methods-分割法"><a href="#Split-and-Dice-Methods-分割法" class="headerlink" title="Split and Dice Methods 分割法"></a>Split and Dice Methods 分割法</h4><p><strong>Cook等人引入了一种叫做分割和骰子的方法，其目标是对曲面进行镶嵌，使每个三角形都变成像素大小，以避免几何混叠。为了实时目的，镶嵌阈值应该增加到GPU能够处理的范围。每个patch首先被递归地分割成一组子patch，直到估计如果对某个子patch使用均匀镶嵌，三角形将具有所需的大小。因此，这也是一种自适应镶嵌。</strong></p>
<p><strong>想象一下，一块大的土地被用作景观。一般来说，分数镶嵌是不可能适应的，例如，在靠近相机的地方镶嵌率更高，在离相机较远的地方镶嵌率更低。因此，分割和骰子的核心可能对实时渲染有用，即使在我们的情况下，目标镶嵌率是拥有比像素大小更大的三角形。</strong></p>
<p><strong>接下来，我们描述了在实时图形场景中分割和骰子的一般方法。假设使用矩形补丁。然后用整个参数域开始一个递归例程，即从(0,0)到(1,1)的平方。使用刚才描述的自适应终止准则，测试曲面是否足够镶嵌。如果是，则终止镶嵌。否则，将这个域分割成四个大小相同的不同的正方形，并递归地为每一个子正方形调用例程。继续递归，直到曲面被足够镶嵌或达到预定义的递归级别。这种算法的本质意味着在镶嵌过程中递归地创建四叉树。然而，如果相邻的子方块被镶嵌到不同的水平，就会产生裂缝。标准的解决方法是确保两个相邻的子平方至多只在一个水平上不同。这叫做受限四叉树。然后使用如图17.59中右侧所示的技术来填充裂缝。这种方法的缺点是簿记比较复杂。</strong></p>
<p><strong>Liktor等人提出了一种用于GPU的分裂和骰子的变体。问题是，避免游泳和弹出伪影的影响突然决定再次分裂，因为，例如，相机已经移动到一个表面更近。为了解决这个问题，他们使用了分数分割方法，这是受到分数镶嵌的启发。如下图所示。由于分裂是平滑地引入从一边的曲线中心，或向中心的贴片的一面，游泳和弹出的伪影。当自适应镶嵌的终止准则为，每个剩余的子patch也使用分数镶嵌由GPU进行镶嵌。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102162837.png" class="" title="image-20211102162837">

<p>分数分裂应用于三次B´ezier曲线。每条曲线的镶嵌率t被显示出来。分裂点是一个大的黑色圆圈，它从曲线的右侧向曲线的中心移动。为了分割三次曲线，黑点被平滑地移向曲线的中心，原始曲线被两个三次B´ezier分段代替，它们一起生成原始曲线。在右边，同样的概念演示了一个patch，它被分成了四个更小的子patch，其中1.0表示分裂点在边缘的中心点，0.0表示它在patch的角落。(参考Liktor等的插图。)</p>
<h3 id="Fast-Catmull-Clark-Tessellation-快速卡特穆尔-克拉克镶嵌"><a href="#Fast-Catmull-Clark-Tessellation-快速卡特穆尔-克拉克镶嵌" class="headerlink" title="Fast Catmull-Clark Tessellation 快速卡特穆尔-克拉克镶嵌"></a>Fast Catmull-Clark Tessellation 快速卡特穆尔-克拉克镶嵌</h3><p><strong>Catmull-Clark曲面(章节17.5.2)经常用于建模软件和故事片渲染，因此能够使用图形硬件高效地渲染这些曲面是很有吸引力的。卡特莫尔-克拉克曲面的快速镶嵌方法是近年来研究的热点。在这里，我们将展示其中的一些方法。</strong></p>
<h4 id="Approximating-Approaches-近似的方法"><a href="#Approximating-Approaches-近似的方法" class="headerlink" title="Approximating Approaches 近似的方法"></a>Approximating Approaches 近似的方法</h4><p><strong>Loop和Schaefer提出了一种技术，将Catmull-Clark曲面转换为一种可以在域着色器中快速评估的表示，而不需要知道多边形的邻居。</strong></p>
<p><strong>如17.5.2节所述，Catmull-Clark曲面可以描述为许多小B样条曲面，且所有顶点都是普通的。Loop和Schaefer将原始Catmull-Clark细分网格中的四边形(quad)多边形转换为双立方B´ezier曲面(章节17.2.1)。这对于非四边形是不可能的，所以我们假设没有这样的多边形(回想一下，在细分的第一步之后，只有四边形多边形)。当一个顶点的效价不同于4时，就不可能创建一个与Catmull-Clark曲面相同的双三次B´ezier贴片。因此，本文提出了一种近似表示方法，该方法适用于具有四个顶点的四边形，并且在其他地方与Catmull-Clark曲面很接近。为此，使用了几何小块和切线小块，下面将对此进行描述。</strong></p>
<p><strong>几何贴片只是一个带有4 × 4控制点的双三次B´ezier贴片。我们将描述如何计算这些控制点。一旦完成，贴片可以镶嵌和域着色器可以快速评估B´ezier贴片在任意坐标(u,v)。所以，假设我们有一个网格，只包含顶点为4的四边形，我们想要计算网格中特定四边形的相应B´ezier patch的控制点。为此，需要院子周围的社区。这样做的标准方法如下图所示，其中显示了三个不同的掩码。这些可以旋转和反射，以创建所有16个控制点。注意，在实现中，掩码的权重总和应该为1，为了清晰起见，这里省略了这个过程。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102163542.png" class="" title="image-20211102163542">

<p>左:一个四边形网格的一部分，我们想为灰色四边形计算一个B´ezier补丁。注意，灰色四边形的顶点只有值为4。蓝色的顶点是相邻四边形的顶点，绿色的圆圈是B´ezier补丁的控制点。下面的三个插图显示了用于计算绿色控制点的不同掩码。例如，要计算一个内部控制点，需要使用右中蒙版，并且用蒙版中显示的权重对四边形的顶点进行加权。</p>
<p><strong>上述技术为普通情况计算一个B´ezier补丁。当至少有一个特殊顶点时，我们计算一个特殊patch。用于此的遮罩如下图所示，其中灰色四边形中的左下角顶点是一个特殊顶点。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102163725.png" class="" title="image-20211102163725">

<p>左:一个B´ezier补丁的灰色四边形的网格将被生成。灰色四边形的左下角顶点是不寻常的，因为它的效价是n≠4。蓝色的顶点是相邻四边形的顶点，绿色的圆圈是B´ezier补丁的控制点。下面的三个插图显示了用于计算绿色控制点的不同掩码。</p>
<p><strong>注意，这导致了一个patch，近似于Catmull-Clark细分表面，并且，它只是C⁰ 沿着顶点特殊的边。当添加着色时，这通常看起来会分散注意力，因此建议使用类似于N-patches(第17.2.4节)的技巧。然而，为了减少计算复杂度，有两个导出了切块:一个在u方向，一个在v方向。法向量就是这些向量之间的叉乘。一般来说，B´ezier patch的导数是用公式17.35计算的。但是，由于导出的B´ezier patches近似于Catmull-Clark surface，因此切线patches不会形成一个连续的法向场。参考Loop和Schaefer关于如何克服这些问题的论文。下图显示了可能出现的工件类型的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102163911.png" class="" title="image-20211102163911">

<p>左:网格的四边形结构。白色四边形很普通，绿色四边形有一个特别的顶点，蓝色四边形有不止一个顶点。中左:几何贴片近似。中右:带有切线块的几何块。注意，明显的(红色圆圈)着色效果消失了。右图:卡特莫尔-克拉克表面。(图片由Charles Loop和Scott Schaefer提供，经微软公司许可转载。)</p>
<p><strong>Kovacs等人描述了如何将上述方法扩展到同样处理折痕和拐角(章节17.5.3)，并在Valve的Source引擎中实现这些扩展。</strong></p>
<h4 id="Feature-Adaptive-Subdivision-and-OpenSubdiv-特征自适应细分和OpenSubdiv"><a href="#Feature-Adaptive-Subdivision-and-OpenSubdiv-特征自适应细分和OpenSubdiv" class="headerlink" title="Feature Adaptive Subdivision and OpenSubdiv 特征自适应细分和OpenSubdiv"></a>Feature Adaptive Subdivision and OpenSubdiv 特征自适应细分和OpenSubdiv</h4><p><strong>皮克斯提出了一个叫做OpenSubdiv的开源系统，它实现了一套叫做特征自适应细分(FAS)的技术。基本方法与前面讨论的技术有很大不同。这项工作的基础在于，对于正则面，细分等价于双三次B样条patch(章节17.2.6)，即:四边形中每个顶点都是规则的，这意味着顶点有四价。因此，细分只递归地继续为非规则面，直到达到某个最大的细分级别。如下图所示。FAS还可以处理折痕和半光滑折痕，FAS算法还需要围绕这些折痕进行细分，如下图的右侧所示。双三次B样条贴片可以直接用镶嵌流水线进行渲染。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102164234.png" class="" title="image-20211102164234">

<p>左:围绕一个特殊顶点的递归细分，即中顶点有三条边。随着递归的继续，它会在后面留下一组规则的补丁(有四个顶点，每个顶点有四条进入的边)。右:围绕中间粗线表示的平滑折痕进行细分。(图接Nießner等。)</p>
<p><strong>该方法首先使用CPU创建一个表。该表对顶点的索引进行编码，这些顶点在细分到指定级别时需要被访问。因此，基础网格可以是动画的，因为索引独立于顶点位置。一旦生成了一个双三次B样条补丁，就不需要继续递归了，这意味着表通常会变得相对较小。将基础网格、索引表、附加价和折痕数据上传到GPU一次。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102164453.png" class="" title="image-20211102164453">

<p>红色方块是过渡补丁，每个都有四个直接邻居，它们要么是蓝色(当前细分级别)，要么是绿色(下一个细分级别)。这张图展示了五种可能出现的配置，以及它们是如何拼接在一起的。(图接Nießner等。)</p>
<p><strong>要细分网格一步，首先计算新的面点，然后是新的边缘点，最后更新顶点，每个类型使用一个计算着色器。在渲染方面，我们区分了完整补丁和过渡补丁。一个完整的patch (FP)只与相同细分级别的patch共享边，而一个规则的FP使用GPU镶嵌流水线直接渲染为一个双三次B样条patch。否则继续细分。自适应细分过程保证相邻块之间最多存在一个细分级别的差异。一个过渡patch (TP)与至少一个邻居的细分水平存在差异。为了得到无裂纹的渲染图，每个TP被分成几个子patch，如上图所示。用这种方法，镶嵌的顶点沿着每条边的两边匹配。每种类型的子补丁都使用不同的外壳和实现插值变体的域着色器进行渲染。例如，上图中最左边的情况被渲染为三个三角形B样条补丁。在特殊顶点周围，使用另一个域着色器，使用Halstead等人的方法计算极限位置和极限法线。下图显示了一个使用OpenSubdiv的Catmull-Clark表面渲染的例子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102164509.png" class="" title="image-20211102164509">

<p>左图:绿色和红色线条的控制网格，灰色表面(8k顶点)，使用一个细分步骤生成。中间:网格再细分两个步骤(102k顶点)。右:使用自适应镶嵌生成的表面(28k顶点)。(使用OpenSubdiv的dxViewer生成的图像。)</p>
<p><strong>FAS算法处理折痕、半光滑折痕、层次细节和自适应细节水平。详见FAS论文和Nießner博士论文。Sch¨afer等人提出了FAS的一种变体，称为DFAS，它甚至更快。</strong></p>
<h4 id="Adaptive-Quadtrees-自适应四叉树"><a href="#Adaptive-Quadtrees-自适应四叉树" class="headerlink" title="Adaptive Quadtrees 自适应四叉树"></a>Adaptive Quadtrees 自适应四叉树</h4><p><strong>Brainerd等人提出了一种称为自适应四叉树的方法。它类似于Loop和Schaefer的近似方案，每个原始基网格的四瓣都提交一个单一的镶嵌基元。此外，它预计算一个细分计划，这是一个四叉树，从一个输入面编码层次细分(类似于特征自适应细分)，直到某个最大细分级别。细分计划还包含细分面所需控制点的模板掩码列表。</strong></p>
<p><strong>在绘制过程中，遍历四叉树，使得将(u, v)坐标映射到细分层次结构中的一个patch成为可能，这个patch可以直接被求值。四叉树叶是原始人脸域的子区域，该子区域内的曲面可以直接使用模板中的控制点进行计算。在域着色器中使用迭代循环遍历四叉树，其输入是参数(u, v)坐标。遍历需要继续，直到到达(u, v)坐标所在的叶节点。根据四叉树中到达的节点类型，将采取不同的操作。例如，当到达一个可以直接评估的子区域时，它对应的双三次B样条补丁的16个控制点被检索，着色器继续评估该补丁。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102164844.png" class="" title="image-20211102164844">

<p>左图:根据特征自适应细分(FAS)的分层细分，其中每个三角形和四边形被渲染为一个单独的镶嵌基元。右图:使用自适应四叉树进行分层细分，整个四叉树被渲染为一个单一的镶嵌基元。(Brainerd等人的插图。)</p>
<p><strong>参见第718页的图17.1，以获得使用这种技术呈现的示例。这种方法是迄今为止最快的精确渲染卡特穆尔-克拉克细分曲面的方法，并处理折痕和其他拓扑特征。与FAS相比，使用自适应四叉树的另一个优势如上图所示，并进一步如下图所示。自适应四叉树还提供了更统一的镶嵌，因为在每个提交的四叉树和镶嵌基元之间存在一对一的映射。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102164901.png" class="" title="image-20211102164901">

<p>使用自适应四叉树细分补丁。每个patch，对应一个基本网格面，被黑色曲线包围在表面上，细分步骤在每个patch内部分层说明。可以看到，在中间有一块颜色一致的斑块。这意味着它被渲染为一个双三次B样条补丁，而其他(特殊顶点)清楚地显示它们的底层自适应四叉树。(图片由Wade Brainerd提供。)</p>
<h1 id="18-Pipeline-Optimization-管线优化"><a href="#18-Pipeline-Optimization-管线优化" class="headerlink" title="18 Pipeline Optimization 管线优化"></a>18 Pipeline Optimization 管线优化</h1><p><strong>在这本书中，算法已经在质量、内存和性能权衡的背景下被提出。在本章中，我们将讨论与特定算法无关的性能问题和机会。瓶颈检测和优化是重点，从进行小的、本地化的更改开始，到构建整个应用程序以利用多处理功能的技术结束。</strong></p>
<p><strong>正如我们在第二章中看到的，渲染图像的过程是基于流水线架构的，有四个概念阶段:应用程序、几何处理、光栅化和像素处理。总有一个阶段是瓶颈——管道中最慢的进程。这意味着这个瓶颈阶段为吞吐量设置了限制，即总的渲染性能，因此是一个主要的候选优化。</strong></p>
<p><strong>优化渲染流水线的性能类似于优化流水线处理器(CPU)，它主要由两个步骤组成。首先，确定管线的瓶颈。第二，这个阶段在某种程度上是优化的;在那之后，如果没有达到性能目标，就重复第一步。注意，在优化步骤之后，瓶颈可能位于，也可能不在同一个位置。最好只花足够的精力来优化瓶颈阶段，使瓶颈转移到另一个阶段。在此阶段再次成为瓶颈之前，可能需要对其他几个阶段进行优化。因此，不应该把精力浪费在过度优化阶段上。</strong></p>
<p><strong>瓶颈的位置可能在一帧中改变，甚至在一个draw调用中。在某一时刻，几何阶段可能是瓶颈，因为许多小三角形被渲染。之后的帧像素处理可能会成为瓶颈，因为重量级程序着色器在每个像素处进行评估。在像素着色器中，执行可能会因为纹理队列已满而暂停，或者在到达特定循环或分支时花费更多时间。所以，当我们谈到，比如说，应用阶段是瓶颈，我们的意思是在这一帧的大部分时间里都是瓶颈。瓶颈很少只有一个。</strong></p>
<p><strong>另一种利用流水线结构的方法是认识到，当最慢的阶段不能进一步优化时，其他阶段可以像最慢的阶段一样工作。这不会改变性能，因为最慢阶段的速度不会改变，但额外的处理可以用来改善图像质量。例如，假设瓶颈在应用阶段，该阶段生成一帧需要50毫秒，而其他阶段生成一帧需要25毫秒。这意味着不改变渲染管线的速度(50毫秒等于20帧每秒)，几何和光栅化阶段也可以在50毫秒内完成他们的工作。例如，我们可以使用更复杂的照明模型，或者使用阴影和反射来增加真实感，假设这不会增加应用阶段的工作量。</strong></p>
<p><strong>计算着色器也改变了我们对瓶颈和未使用资源的看法。例如，如果正在渲染阴影地图，顶点和像素着色器很简单，如果固定功能阶段(如光栅化或像素合并)成为瓶颈，GPU计算资源可能未得到充分利用。使用异步计算着色器重叠这些绘制可以在这些条件出现时保持着色器单元繁忙。本章的最后一节将讨论基于任务的多处理。</strong></p>
<p><strong>管线优化是一个过程，在这个过程中，我们首先最大化渲染速度，然后允许不是瓶颈的阶段消耗和瓶颈一样多的时间。也就是说，这并不总是一个简单的过程，因为GPU和驱动程序可以有自己的特性和快速路径。当阅读这一章时，格言</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211103110256.png" class="" title="image-20211103110256">

<p>知道你的架构</p>
<p><strong>应该始终牢记于心，因为优化技术对于不同的架构有很大的不同。也就是说，要谨慎地基于特定GPU的功能实现进行优化，因为硬件可能也会随着时间的推移而变化。一个相关的格言，简单地说，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211103110306.png" class="" title="image-20211103110306">

<p>测量，测量，测量</p>
<h2 id="Profiling-and-Debugging-Tools-分析和调试工具"><a href="#Profiling-and-Debugging-Tools-分析和调试工具" class="headerlink" title="Profiling and Debugging Tools 分析和调试工具"></a>Profiling and Debugging Tools 分析和调试工具</h2><p><strong>分析和调试工具对于发现代码中的性能问题是非常有用的。能力各不相同，可以包括:</strong></p>
<pre><code>**•帧捕获和可视化。通常一步一步的帧重放是可用的，显示使用中的状态和资源。**

**•分析CPU和GPU花费的时间，包括调用图形API的时间。**

**•着色器调试，并可能热编辑，以查看更改代码的效果。**

**•在应用程序中使用调试标记，以帮助识别代码区域。**
</code></pre>
<p><strong>分析和调试工具因操作系统、图形API以及GPU供应商而异。大多数组合都有工具，这就是为什么神创造了谷歌。也就是说，我们将提到几个包的名称专门为交互式图像，让你开始你的任务:</strong></p>
<pre><code>**•RenderDoc是一个用于DirectX, OpenGL和Vulkan的高质量Windows调试器，最初由Crytek开发，现在是开源的。**

**•GPU PerfStudio是AMD的图形硬件套件，适用于Windows和Linux。一个值得注意的工具是静态着色分析器，它可以在不运行应用程序的情况下给出性能评估。AMD的Radeon GPU Profiler是一个独立的相关工具。**

**•NVIDIA Nsight是一个性能和调试系统，具有广泛的功能。它集成了Windows上的Visual Studio和Mac OS和Linux上的Eclipse。**

**•Xbox开发人员长期使用微软的PIX，并已在Windows上的DirectX 12中重新启用。Visual Studio的图形诊断功能可以用于DirectX的早期版本。**

**•来自微软的GPUView使用了Windows事件跟踪(ETW)，一个有效的事件日志系统。GPUView是ETW会话的几个消费者程序之一。重点研究了CPU与GPU之间的交互，指出了哪个是瓶颈。**

**•图形性能分析仪(GPA)是一套来自英特尔的套件，不专门针对其图形芯片，专注于性能和帧分析。**

**•OSX上的Xcode提供了Instruments，它有几个用于计时、性能、网络、内存泄漏等的工具。值得一提的是OpenGL ES Analysis，它检测性能和正确性问题并提出解决方案，以及Metal System Trace，它提供来自应用程序、驱动程序和GPU的跟踪信息。**
</code></pre>
<p><strong>这些是已经存在了几年的主要工具。也就是说，有时没有工具可以完成这项工作。定时器查询调用被内置在大多数API中，以帮助分析GPU的性能。一些供应商也提供了访问GPU计数器和线程跟踪的库。</strong></p>
<h2 id="Locating-the-Bottleneck-定位瓶颈"><a href="#Locating-the-Bottleneck-定位瓶颈" class="headerlink" title="Locating the Bottleneck 定位瓶颈"></a>Locating the Bottleneck 定位瓶颈</h2><p><strong>优化管线的第一步是找出最大的瓶颈。找到瓶颈的一种方法是设置多个测试，每个测试都减少特定阶段执行的工作量。如果其中一个测试导致每秒帧数增加，则发现瓶颈阶段。测试一个阶段的相关方法是减少其他阶段的工作负载，而不减少被测试阶段的工作负载。如果性能没有改变，那么瓶颈就是工作负载没有改变的阶段。性能工具可以提供关于哪些API调用是昂贵的详细信息，但不一定确切地指出管道中的哪个阶段减慢了其他阶段的速度。即使他们这样做了，理解每个测试背后的想法也是很有用的。</strong></p>
<p><strong>下面是一些用于测试不同阶段的想法的简要讨论，以便对这种测试是如何完成的有一个大致的了解。统一着色器架构的出现是理解底层硬件重要性的一个完美例子。从2006年底开始，它形成了许多GPU的基础。其理念是，顶点、像素和其他着色器都使用相同的功能单位。GPU负责负载平衡，改变分配给顶点和像素着色的单位比例。例如，如果渲染一个较大的四边形，只有少数着色器单元可以被分配到顶点变换，而大块则被分配到碎片处理的任务。确定瓶颈是在顶点着色阶段还是像素着色阶段并不明显。无论是作为一个整体着色处理还是另一个阶段仍然是瓶颈，然而，所以我们轮流讨论每个可能性。</strong></p>
<h3 id="Testing-the-Application-Stage-测试应用阶段"><a href="#Testing-the-Application-Stage-测试应用阶段" class="headerlink" title="Testing the Application Stage 测试应用阶段"></a>Testing the Application Stage 测试应用阶段</h3><p><strong>如果所使用的平台附带一个实用工具来测量处理器上的工作负载，则可以使用该实用工具来查看您的程序是否使用了100%(或接近100%)的CPU处理能力。如果CPU经常被使用，那么您的程序很可能是CPU有限的。这并不总是万无一失的，因为应用程序有时可能会等待GPU完成一帧。我们说一个程序受到CPU或GPU的限制，但是瓶颈在一帧的生命周期中会发生变化。</strong></p>
<p><strong>测试CPU限制的一个更聪明的方法是向下发送数据，导致GPU做很少或不做工作。对于某些系统，这可以通过简单地使用一个空驱动程序(一个接受调用但什么也不做的驱动程序)而不是一个真正的驱动程序来实现。这有效地设置了整个程序运行速度的上限，因为您不使用图形硬件，也不调用驱动程序，因此，CPU上的应用程序始终是瓶颈。通过执行此测试，您可以了解在应用程序阶段中不运行的基于GPU的阶段还有多少改进空间。也就是说，要注意，使用空驱动程序也可以隐藏由于驱动程序处理本身以及CPU和GPU之间的通信造成的任何瓶颈。驱动程序通常是CPU端瓶颈的原因，我们将在后面深入讨论这个话题。</strong></p>
<p><strong>另一种更直接的方法是降低CPU的时钟，如果可能的话。如果性能下降与CPU速率成正比，则应用程序至少在一定程度上是CPU绑定的。同样的降频方法也可以用于GPU。如果GPU速度变慢，性能下降，那么至少在某些时候应用程序是GPU绑定的。这些降频方法可以帮助识别瓶颈，但有时会导致之前不是瓶颈的阶段变成瓶颈。另一种选择是超频，但这里没有提到。</strong></p>
<h3 id="Testing-the-Geometry-Processing-Stage-测试几何处理阶段"><a href="#Testing-the-Geometry-Processing-Stage-测试几何处理阶段" class="headerlink" title="Testing the Geometry Processing Stage 测试几何处理阶段"></a>Testing the Geometry Processing Stage 测试几何处理阶段</h3><p><strong>几何学阶段是最难测试的阶段。这是因为如果这个阶段的工作负载发生了变化，那么其他阶段的一个或两个工作负载通常也会发生变化。为了避免这个问题，Cebenoyan给出了一系列光栅化阶段的测试。</strong></p>
<p><strong>在几何阶段有两个主要的瓶颈:顶点获取和处理。要查看瓶颈是否由于对象数据传输，请增加顶点格式的大小。例如，这可以通过向每个顶点发送几个额外的纹理坐标来实现。如果性能下降，这个区域就是瓶颈。</strong></p>
<p><strong>顶点处理由顶点着色器完成。对于顶点着色器瓶颈，测试包括使着色器程序更长。必须小心确保编译器没有优化掉这些额外的指令。</strong></p>
<p><strong>如果你的管道也使用几何着色器，它们的性能是输出大小和程序长度的函数。如果你使用镶嵌着色器，同样，程序长度影响性能，以及镶嵌因子。改变这些元素中的任何一个，同时避免在其他阶段执行的工作中发生变化，可以帮助确定是否有任何一个是瓶颈。</strong></p>
<h3 id="Testing-the-Rasterization-Stage-测试栅格化阶段"><a href="#Testing-the-Rasterization-Stage-测试栅格化阶段" class="headerlink" title="Testing the Rasterization Stage 测试栅格化阶段"></a>Testing the Rasterization Stage 测试栅格化阶段</h3><p><strong>这个阶段包括三角形设置和三角形遍历。使用极其简单的像素着色器的阴影地图生成，可能会在光栅化或合并阶段遇到瓶颈。虽然通常很少见，但三角形设置和栅格化可能成为镶嵌或草或树叶等物体的小三角形的瓶颈。然而，小三角形也可以增加顶点和像素着色器的使用。在一个给定的区域中，更多的顶点显然会增加顶点着色器的负载。像素着色器负载也增加了，因为每个三角形是由一组2 × 2的四边形光栅化的，所以每个三角形外的像素数量增加。这有时被称为四角遮蔽(第23.1节)。为了找出光栅化是否是真正的瓶颈，通过增加顶点和像素着色器的程序大小来增加它们的执行时间。如果每帧渲染时间没有增加，那么瓶颈就在光栅化阶段。</strong></p>
<h3 id="Testing-the-Pixel-Processing-Stage-测试像素处理阶段"><a href="#Testing-the-Pixel-Processing-Stage-测试像素处理阶段" class="headerlink" title="Testing the Pixel Processing Stage 测试像素处理阶段"></a>Testing the Pixel Processing Stage 测试像素处理阶段</h3><p><strong>像素着色程序的效果可以通过改变屏幕分辨率来测试。如果较低的屏幕分辨率导致帧率明显上升，那么像素着色器很可能是瓶颈，至少在某些时候是这样。如果有一个详细的系统，就必须小心。更小的屏幕还可能简化显示的模型，减轻几何阶段的负担。</strong></p>
<p><strong>降低显示分辨率还会影响三角遍历、深度测试和混合以及纹理访问等方面的成本。为了避免这些因素并隔离瓶颈，有一种方法与使用顶点着色程序相同，即添加更多指令以查看对执行速度的影响。同样，确定这些额外的指令没有被编译器优化掉是很重要的。如果帧渲染时间增加，像素着色器就会成为瓶颈(或者至少在执行成本增加时成为瓶颈)。或者，像素着色器可以简化到最少的指令数，这在顶点着色器中通常很难做到。如果总体渲染时间减少，就会发现瓶颈。纹理缓存失败的代价也很高。如果将纹理替换为1 × 1分辨率的版本能够获得相当快的性能，那么纹理内存访问将成为一个瓶颈。</strong></p>
<p><strong>着色器是独立的程序，有自己的优化技术。Persson介绍了几个低级的着色器优化，以及关于图像硬件如何发展和最佳实践如何改变的细节。</strong></p>
<h3 id="Testing-the-Merging-Stage-测试归并阶段"><a href="#Testing-the-Merging-Stage-测试归并阶段" class="headerlink" title="Testing the Merging Stage 测试归并阶段"></a>Testing the Merging Stage 测试归并阶段</h3><p><strong>在此阶段，将进行深度和模具测试，进行混合，并将幸存的结果写入缓冲区。改变这些缓冲区的输出位深度是改变这个阶段的带宽成本的一种方法，看看它是否会成为瓶颈。为不透明对象打开alpha混合或使用其他混合模式也会影响内存访问和光栅操作执行的处理数量。</strong></p>
<p><strong>这个阶段可能是后期处理通道、阴影、粒子系统渲染的瓶颈，在较小程度上，也可能是毛发和草的渲染，因为顶点和像素着色器很简单，所以几乎不需要做什么工作。</strong></p>
<h2 id="Performance-Measurements-性能度量"><a href="#Performance-Measurements-性能度量" class="headerlink" title="Performance Measurements 性能度量"></a>Performance Measurements 性能度量</h2><p><strong>为了优化，我们需要测量。这里我们讨论GPU速度的不同度量。图形硬件制造商过去常常呈现峰值速率，如每秒的顶点数和每秒的像素数，这是很难达到的。此外，由于我们处理的是流水线系统，真正的性能并不像列出这些类型的数字那么简单。这是因为瓶颈的位置可能从一个时间移动到另一个时间，不同的管道阶段在执行期间以不同的方式交互。由于这种复杂性，GPU的性能部分取决于它们的物理属性，比如核心的数量和时钟速率、内存大小、速度和带宽。</strong></p>
<p><strong>综上所述，GPU计数器和线程跟踪，如果可用的话，在使用得当的情况下，是重要的诊断工具。如果已知某个给定部件的峰值性能，且计数较低，那么该区域不太可能成为瓶颈。一些供应商提供计数器数据作为每个阶段的利用率百分比。这些值是在瓶颈可以移动的给定时间范围内的，因此并不完美，但在查找瓶颈方面有很大帮助。</strong></p>
<p><strong>越多越好，但即使是看起来简单的物理测量也很难进行精确的比较。例如，同一GPU的时钟速率在IHV合作伙伴之间可能会有所不同，因为每个合作伙伴都有自己的冷却解决方案，所以会超时其GPU到它认为安全的程度。即使是在单个系统上进行FPS基准比较，也并不总是像听起来那么简单。NVIDIA的GPU Boost和AMD的PowerTune技术都是我们格言“了解你的架构”的好例子。“英伟达的GPU Boost之所以出现，部分原因是一些综合基准同时运行GPU管道的许多部分，从而将功耗推到了极限，这意味着英伟达不得不降低其基本时钟速率，以防止芯片过热。许多应用程序不会在这种程度上执行管道的所有部分，因此可以安全地以较高的时钟速率运行。GPU Boost技术跟踪GPU的功率和温度特性，并相应地调整时钟速率。AMD和英特尔的GPU也有类似的功率/性能优化。这种可变性可能会导致相同的基准以不同的速度运行，这取决于GPU的初始温度。为了避免这个问题，微软在DirectX 12中提供了一种锁定GPU核心时钟频率的方法，以获得稳定的计时。其他API也可以检查功率状态，但要复杂得多。</strong></p>
<p><strong>在衡量CPU的性能时，趋势是避免IPS(每秒指令数)、FLOPS(每秒浮点操作数)、千兆赫和简单的短期基准测试。相反，首选的方法是测量一系列不同的、真实的程序的挂钟时间，然后比较这些程序的运行时间。随着这一趋势的发展，大多数独立的图像基准会测量特定场景的实际帧率，以及各种不同的屏幕分辨率，以及抗锯齿和质量设置。许多需要大量图像的游戏都包含一个基准测试模式，或者有一个由第三方创建的基准测试模式，这些基准测试通常用于比较gpu。</strong></p>
<p><strong>虽然FPS是比较GPU运行基准的有用缩写，但在分析一系列帧率时应该避免使用它。FPS的问题在于，它是一种相互度量，而非线性度量，因此可能导致分析错误。例如，假设您发现应用程序在不同时间的帧率分别是50fps、50fps和20fps。如果你将这些值平均，你将得到40 FPS。这个价值充其量是误导。这些帧速率转换为20、20和50毫秒，因此平均帧时间为30毫秒，即33.3 FPS。同样，在衡量单个算法的性能时，毫秒也是非常必要的。对于特定的基准测试情况在给定的测试和给定的机器上，可能会说某些特定的阴影算法或后处理效果“成本”为7 FPS，基准测试的运行速度要慢得多。然而，概括这句话是没有意义的，因为这个值还取决于处理帧中其他所有内容所花费的时间，因为你不能将不同技术的FPS相加(但你可以添加时间)。</strong></p>
<p><strong>为了能够看到管道优化的潜在效果，在禁用双缓冲的情况下测量每帧的总渲染时间是很重要的。在单缓冲模式下，关闭垂直同步。这是因为启用了双重缓冲后，缓冲区的交换只发生在与监视器频率同步的情况下，正如2.1节中的示例所解释的那样。De Smedt讨论了分析帧时间来发现和修复CPU工作负载峰值造成的帧断断续续问题，以及其他优化性能的有用技巧。使用统计分析通常是必要的。也可以使用GPU时间戳来了解帧内发生了什么。</strong></p>
<p><strong>原始速度很重要，但对于移动设备来说，另一个目标是优化功耗。故意降低帧率，但保持应用程序的交互性可以显著延长电池寿命，对用户体验几乎没有影响。Akenine-M¨oller和Johnsson注意到，每瓦特的性能就像每秒帧数，与FPS有相同的缺点。他们认为一个更有用的度量是焦耳每任务，例如，焦耳每像素。</strong></p>
<h2 id="Optimization-优化"><a href="#Optimization-优化" class="headerlink" title="Optimization 优化"></a>Optimization 优化</h2><p><strong>一旦找到了瓶颈，我们希望优化该阶段以提高性能。在本节中，我们将介绍应用、几何、光栅化和像素处理阶段的优化技术。</strong></p>
<h3 id="Application-Stage-应用阶段"><a href="#Application-Stage-应用阶段" class="headerlink" title="Application Stage 应用阶段"></a>Application Stage 应用阶段</h3><p><strong>应用程序阶段通过使代码更快和程序的内存访问更快或更少来优化。这里我们将介绍一些适用于CPU的代码优化的关键元素。</strong></p>
<p><strong>对于代码优化，定位代码中花费时间最多的位置是至关重要的。一个好的代码分析器对于查找这些代码热点非常关键，因为大部分时间都花在这些代码热点上。然后在这些地方进行优化工作。程序中的这些位置通常是内部循环，即每一帧执行多次的代码片段。</strong></p>
<p><strong>优化的基本规则是尝试各种策略:重新检查算法、假设和代码语法，尽可能地尝试变体。CPU架构和编译器性能通常会限制用户对如何编写最快代码的直觉形成的能力，所以请质疑您的假设，并保持开放的心态。</strong></p>
<p><strong>第一步是对编译器的优化标志进行试验。通常有许多不同的旗子可以尝试。对于所使用的优化选项，尽量少做假设。例如，将编译器设置为使用更积极的循环优化可能导致代码变慢。此外，如果可能的话，尝试不同的编译器，因为这些编译器以不同的方式进行了优化，有些编译器明显更好。你的分析工具可以告诉你任何变化的影响。</strong></p>
<h4 id="Memory-Issues-内存问题"><a href="#Memory-Issues-内存问题" class="headerlink" title="Memory Issues 内存问题"></a>Memory Issues 内存问题</h4><p><strong>几年前，算术指令的数量是衡量算法效率的关键;现在关键是内存访问模式。处理器速度的增长比DRAM的数据传输速率要快得多，因为DRAM的数据传输速率受到引脚数的限制。从1980年到2005年，CPU性能每两年翻一番，DRAM性能每6年翻一番。这个问题被称为冯·诺伊曼瓶颈或记忆墙。面向数据的设计将缓存一致性作为一种优化手段。</strong></p>
<p><strong>在现代GPU上，重要的是数据传输的距离。速度和动力成本与这个距离成正比。缓存访问模式可以造成数量级的性能差异。高速缓存是一个小的快速存储区域，因为通常在一个程序中有很多一致性，高速缓存可以利用。也就是说，内存中邻近的位置往往是一个接一个地被访问(空间局部性)，而代码通常是按顺序访问的。此外，内存位置往往被重复访问(时间局域性)，缓存也利用了这一点。处理器缓存访问起来很快，速度仅次于寄存器。许多快速算法的工作是尽可能地在本地访问数据。</strong></p>
<p><strong>寄存器和本地缓存形成内存层次结构的一端，它扩展到动态随机访问内存(DRAM)，然后存储在SSDs和硬盘上。顶部是少量快速而昂贵的内存，底部是大量缓慢而廉价的存储。在每个层次之间，速度下降了一些明显的因素。参见下图。例如，处理器寄存器通常在一个时钟周期内被访问，而L1缓存存储器则在几个周期内被访问。通过这种方式，级别的每一次更改都会增加延迟。正如第3.10节所讨论的，有时延迟可以被架构隐藏，但它始终是必须记住的一个因素。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104111448.png" class="" title="image-20211104111448">

<p>内存层次结构。速度和成本随着金字塔的下降而下降。</p>
<p><strong>在分析器中很难直接检测到糟糕的内存访问模式。好的模式需要从一开始就嵌入到设计中。下面是在编程时应该考虑的指针列表。</strong></p>
<pre><code>**•在代码中顺序访问的数据也应该顺序存储在内存中。例如，当渲染一个三角形网格时，将纹理坐标#0、法向量#0、颜色#0、顶点#0、纹理坐标#1和法向量#1按顺序存储在内存中。这也可以是在GPU上非常重要，就像变换后的顶点缓存(章节16.4.4)一样。为什么存储单独的数据流是有益的，请参见第16.4.5节。**

**•避免指针间接、跳转和函数调用(在代码的关键部分)，因为这些可能会显著降低CPU性能。当你沿着一个指针指向另一个指针时，你会得到指针间接指向，以此类推。现代的CPU尝试投机性地执行指令(分支预测)和获取内存(缓存预取)，以保持所有的功能单元忙于运行代码。当代码流在循环中保持一致时，这些技术非常有效，但在分支数据结构(如二叉树、链表和图)时就失败了;尽可能使用数组。McVoy和Staelin给出了一个通过指针跟随链表的代码示例。这将导致数据在缓存之前和之后都没有缓存，并且他们的例子使CPU的延迟时间比跟随指针所花费的时间长100倍以上(如果缓存可以提供指针的地址)。Smits指出，将基于指针的树扁平化为带有跳过指针的列表，可以显著改善层次遍历。使用van Emde Boas布局是避免缓存遗漏的另一种方法，请参阅19.1.4节。高分枝树通常比二叉树更可取，因为它们减少了树的深度，从而减少了间接的数量。**

**•将经常使用的数据结构对齐到缓存线大小的倍数可以显著提高整体性能。例如，64字节高速缓存线在Intel和AMD处理器上很常见。编译器选项可能会有帮助，但明智的做法是在设计数据结构时使用对齐(称为填充)。Windows和Linux的VTune和CodeAnalyst、Mac的Instruments以及Linux的开源Valgrind等工具可以帮助识别缓存瓶颈。对齐也会影响GPU着色器的性能。**

**•尝试不同的数据结构组织。例如，Hecker展示了如何通过测试一个简单矩阵乘法器的各种矩阵结构来节省惊人的大量时间。一组结构，**
</code></pre>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104111916.png" class="" title="image-20211104111916">

<p><strong>或者数组结构，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104111929.png" class="" title="image-20211104111929">

<p><strong>对于给定的架构可能会更好。第二种结构更适合使用SIMD命令，但是随着顶点数量的增加，缓存丢失的几率也会增加。随着数组大小的增加，一个混合方案，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104111947.png" class="" title="image-20211104111947">

<p><strong>可能是最好的选择。</strong></p>
<pre><code>**•通常在启动时为相同大小的对象分配一个大的内存池，然后使用你自己的分配和空闲例程来处理池中的内存。Boost等库提供池分配。一组连续的记录比那些由单独分配创建的记录更可能是缓存一致的。也就是说，对于使用垃圾收集的语言，如C#和Java，池实际上会降低性能。**
</code></pre>
<p><strong>虽然与内存访问模式没有直接关系，但避免在呈现循环中分配或释放内存是值得的。只使用一次池和分配一次临时空间，让堆栈、数组和其他结构只增长(使用变量或标志来说明哪些元素应该被视为已删除)。</strong></p>
<h3 id="API-Calls-API调用"><a href="#API-Calls-API调用" class="headerlink" title="API Calls API调用"></a>API Calls API调用</h3><p><strong>在本书中，我们根据硬件的一般趋势给出了建议。例如，索引顶点缓冲对象通常是为加速器提供几何数据的最快方法(章节16.4.5)。这一节是关于如何最好地调用图形API本身。大多数图形API都有类似的架构，并且有行之有效的方法来有效地使用它们。</strong></p>
<p><strong>理解对象缓冲区分配和存储是高效渲染的基础。对于一个有CPU和独立的GPU的桌面系统，每个CPU通常都有自己的内存。图形驱动程序通常控制对象驻留的位置，但它可以得到最好存储对象的提示。一个常见的分类是静态缓冲区和动态缓冲区。如果缓冲区的数据每一帧都在变化，最好使用动态缓冲区，它不需要GPU上的永久存储空间。控制台、集成了低功耗GPU的笔记本电脑和移动设备设备通常有统一的内存，其中GPU和CPU共享相同的物理内存。即使在这种情况下，在正确的资源池中分配资源也很重要。正确地将资源标记为仅CPU或仅GPU仍然可以带来好处。一般来说，如果一个内存区域必须同时被两个芯片访问，那么当一个芯片向它写入数据时，另一个芯片必须使它的缓存失效——这是一个昂贵的操作——以确保不会得到过时的数据。</strong></p>
<p><strong>如果一个对象没有变形，或者变形完全可以通过着色程序(如蒙皮)执行，那么将对象的数据存储在GPU内存中是有益的。该对象的不变性质可以通过将其存储为静态缓冲区来表示。通过这种方式，它不需要在每一帧渲染时都通过总线发送，从而避免了管线这一阶段的任何瓶颈。GPU上的内部内存带宽通常比CPU和GPU之间的总线高得多。</strong></p>
<h4 id="State-Changes-状态改变"><a href="#State-Changes-状态改变" class="headerlink" title="State Changes 状态改变"></a>State Changes 状态改变</h4><p><strong>调用API有几个相关的成本。在应用程序方面，更多的调用意味着花费更多的应用程序时间，而不管调用实际做什么。这种成本可以是最小的，或者是显而易见的，空驱动程序可以帮助识别它。依赖于GPU值的查询函数可能会由于与CPU同步时的延迟而使帧率减半。在这里，我们将深入研究优化一个常见的图形操作，准备管道来绘制一个网格。这个操作可能涉及到改变状态，例如，设置着色器及其制服，附加纹理，改变混合状态或使用的颜色缓冲，等等。</strong></p>
<p><strong>应用程序提高性能的一个主要方法是通过将具有相似呈现状态的对象分组来最小化状态更改。因为GPU是一个极其复杂的状态机，可能是计算机科学中最复杂的，改变状态可能是昂贵的。虽然一小部分成本涉及GPU，但大部分成本来自驱动程序在CPU上的执行。如果GPU能够很好地映射到API上，那么状态改变的成本是可以预测的，尽管仍然是巨大的。如果GPU有严格的功率限制或有限的硅足迹，如一些移动设备，或有一个硬件缺陷，驱动程序可能不得不执行英雄壮举，导致意外的高成本。状态改变的成本主要在CPU方面，在驱动程序中。</strong></p>
<p><strong>一个具体的例子是PowerVR架构如何支持混合。在较早的API中，混合是使用固定函数类型的接口指定的。PowerVR的混合是可编程的，这意味着他们的驱动程序必须将当前的混合状态添加到像素着色器中。在这种情况下，更高级的设计不能很好地映射到API，因此会在驱动程序中产生巨大的设置成本。在这一章中，我们注意到硬件架构和运行它的软件会影响各种优化的重要性，对于状态更改成本来说尤其如此。甚至特定的GPU类型和驱动程序发布也可能会有影响。阅读时，请在本节的每一页上用红色大字标出“你的里程可能不同”这句话。</strong></p>
<p><strong>Everitt和McDonald指出，不同类型的状态变化在成本上差别很大，并给出了一个粗略的概念，即在NVIDIA OpenGL驱动程序上每秒可以执行多少次。以下是他们2014年的顺序，从最贵到最低:</strong></p>
<pre><code>**•渲染目标(framebuffer对象)，约60k/秒。**

**• 着色程序, ∼300 k /秒。**

**• 纹理绑定, ∼1.5米/秒。**

**•顶点格式。**

**•统一缓冲对象(UBO)绑定。**

**•顶点绑定。**

**• 统一更新, ∼10米/秒。**
</code></pre>
<p><strong>这个近似的成本顺序是由其他人证实的。一个更昂贵的改变是GPU的渲染模式和计算着色模式之间的切换。避免状态改变可以通过按着色器对要显示的对象进行排序来实现，然后按使用的纹理等按成本顺序进行分组。按状态排序有时称为批处理。</strong></p>
<p><strong>另一种策略是重构对象的数据，以便进行更多的共享。最小化纹理绑定更改的常见方法是将多个纹理图像放入一个大纹理中，或者更好的是将其放入纹理数组中。如果API支持它，那么无绑定纹理是避免状态更改的另一个选项(章节6.2.5)。与更新制服相比，改变着色程序通常是相对昂贵的，所以在一个使用“if”语句的单一着色器中，材质类的变化可能会更好地表示。你也可以通过共享着色器来制作更大的批量。然而，让着色器更复杂也会降低GPU的性能。通过测量来了解什么是有效的，这是唯一的万无一失的方法。</strong></p>
<p><strong>对图形API进行更少、更有效的调用可以获得额外的节省。例如，通常可以将多个统一缓冲区对象定义并设置为一个组，因此绑定一个统一缓冲区对象的效率要高得多。在DirectX中，这些被称为常量缓冲区。正确使用这些函数可以节省每个函数的时间，也可以节省在每个API调用中检查错误的时间。</strong></p>
<p><strong>现代驱动程序通常将设置状态推迟到遇到第一个平局调用时。如果在此之前进行了多余的API调用，驱动程序将过滤掉这些调用，从而避免了执行状态更改的需要。通常，dirty标志用于表示需要更改状态，因此在每次draw调用之后返回基本状态可能会变得非常昂贵。例如，您可能希望假定状态X在大约时默认为关闭画一个物体。实现这一点的一种方法是“Enable(X); Draw(M1); Disable(X);“ 然后”Enable(X); Draw(M2); Disable(X);”这样在每次抽完之后恢复状态。然而，在两个draw调用之间再次设置状态也可能会浪费大量时间，即使它们之间没有发生实际的状态更改。</strong></p>
<p><strong>通常，应用程序对于何时需要状态更改具有更高层次的知识。例如，将不透明表面的“替换”混合模式更改为透明表面的“过渡”模式通常需要在帧期间完成一次。在渲染每个对象之前使用混合模式是很容易避免的。Galeano显示了忽略这种过滤和发出不必要的状态调用将如何使WebGL应用程序的成本高达将近2毫秒/帧。然而，如果驱动程序已经有效地进行了这种冗余过滤，那么在应用程序中每次调用执行相同的测试可能是一种浪费。过滤API调用的工作量主要取决于底层驱动程序。</strong></p>
<h4 id="Consolidating-and-Instancing-巩固和实例化"><a href="#Consolidating-and-Instancing-巩固和实例化" class="headerlink" title="Consolidating and Instancing 巩固和实例化"></a>Consolidating and Instancing 巩固和实例化</h4><p><strong>有效地使用API可以避免CPU成为瓶颈。API的另一个问题是小批量问题。如果忽略这一点，这将成为影响现代API性能的一个重要因素。简单地说，几个三角形填充的网格比许多小的、简单的网格渲染效率更高。这是因为每个draw调用都有固定成本开销，处理原语的成本，无论大小如何。</strong></p>
<p><strong>早在2003年，Wloka就指出，每批绘制两个(相对较小的)三角形距离GPU测试的最大吞吐量是375倍。2在2.7 GHz的CPU上，每秒的三角形数不是1.5亿个，而是40万个。对于由许多小而简单的对象(每个对象只有几个三角形)组成的渲染场景，性能完全受API的CPU限制;GPU没有能力增加它。也就是说，CPU上绘制调用的处理时间大于GPU实际绘制网格的时间，所以GPU很紧张。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104124949.png" class="" title="image-20211104124949">

<p>使用NVIDIA G80 GPU，运行DirectX 10的Intel Core 2 Duo 2.66 GHz CPU的批量性能基准。不同大小的批次在不同的条件下运行和计时。“低”条件是指只有位置和固定颜色像素着色器的三角形;另一组测试是合理的网格和阴影。“单”是多次渲染单个批次。“实例化”重用网格数据，并将每个实例的数据放在一个单独的流中。” Constants “是一个DirectX 10方法，实例数据被放在常量内存中。可以看到，小批量会损害所有方法，但是实例化的性能要快得多。在几百个三角形时，性能就会下降，因为瓶颈变成了从顶点缓冲区和缓存中检索顶点的速度。(图表由英伟达公司提供)</p>
<p><strong>Wloka的经验法则是“你每帧可以获得X批。“这是你每一帧的最大绘制调用数，纯粹是因为CPU是限制因素。在2003年，API成为瓶颈的断点大约是每个对象130个三角形。上图显示了断点是如何在2006年上升到每个网格510个三角形的。时代已经变了。我们做了很多工作来改善这个draw call问题，CPUs变得更快了。2003年的建议是每帧300个调用;在2012年，每帧16,000个抽签是一个球队的上限。尽管如此，对于一些复杂的场景来说，这个数字还是不够的。使用DirectX 12、Vulkan和Metal等现代API，驱动程序本身的成本可能会降到最低——这是它们的主要优势之一。然而，GPU在每个网格上有自己的固定成本。</strong></p>
<p><strong>减少绘制调用次数的一种方法是将几个对象合并到一个网格中，这只需要一个绘制调用来渲染集合。对于使用相同状态且静态的对象集合，至少相对于其他对象而言，可以进行一次合并，批处理可以重用每个帧。能够整合网格是考虑使用公共着色器和纹理共享技术避免状态变化的另一个原因。整合节省的成本不仅仅是避免API调用。应用程序本身处理更少的对象也可以节省开支。然而，如果批量比需要的大得多，那么其他算法(如截锥剔除)的效率就会降低。一种做法是使用边界卷层次结构来帮助查找和分组彼此相邻的静态对象。合并的另一个问题是选择，因为所有静态对象在一个网格中都是无差别的。一个典型的解决方案是在网格中的每个顶点存储一个对象标识符。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104125446.png" class="" title="image-20211104125446">

<p>植被实例化。下面图像中所有相同颜色的对象都在一个单独的绘制调用中进行渲染。(图片来自Crytek提供的CryEngine1)</p>
<p><strong>最小化应用程序处理和API成本的另一种方法是使用某种形式的实例化。大多数API支持拥有一个对象，并在单个调用中多次绘制它。这通常是通过指定一个基本模型并提供一个独立的数据结构来保存关于所需的每个特定实例的信息来实现的。除了位置和方向，其他属性也可以在每个实例中指定，比如叶子颜色或由于风的曲率，或任何其他可以被着色程序用来影响模型的属性。丰富的丛林场景可以创建通过自由使用实例。参见上图。人群场景是一个很好的例子，每个角色通过从一系列选择中选择不同的身体部位而呈现出独特的效果。进一步的变化可以通过随机着色和贴花添加。实例化也可以与细节水平技术相结合。参见下图中的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104125501.png" class="" title="image-20211104125501">

<p>人群场景。使用实例化最小化了需要的绘制调用的数量。细节级别技术也被使用，例如渲染远处模型的视点替用特效。(图片由Jonathan Ma¨ım、Barbara Yersin、Mireille Clavien和Daniel Thalmann提供。)</p>
<p><strong>将合并和实例化结合在一起的概念称为合并实例化，其中合并的网格包含可以被实例化的对象。</strong></p>
<p><strong>理论上，几何着色器可以用于实例化，因为它可以创建传入网格的重复数据。在实践中，如果需要许多实例，这种方法可能比使用实例化API命令慢。几何着色器的目的是执行局部、小规模的数据放大。此外，对于一些架构，如马里的基于瓦片的渲染器，几何着色器是在软件中实现的。引用马里的最佳实践指南:“找到解决问题的更好办法。几何着色器不是你的解决方案。”</strong></p>
<h3 id="Geometry-Stage-几何阶段"><a href="#Geometry-Stage-几何阶段" class="headerlink" title="Geometry Stage 几何阶段"></a>Geometry Stage 几何阶段</h3><p><strong>几何阶段负责变换、逐顶点光照、剪切、投影和屏幕映射。其他章节讨论了减少流经管道的数据量的方法。高效的三角形网格存储、模型简化和顶点数据压缩(第16章)都节省了处理时间和内存。像截锥和遮挡剔除(第19章)这样的技术避免了将完整的原语本身发送到管线中。在CPU上添加这样大规模的技术可能会完全改变应用程序的性能特征，因此值得在开发早期进行尝试。在GPU上，这样的技术并不常见。一个值得注意的例子是，计算着色器可以用来执行各种类型的剔除。</strong></p>
<p><strong>光照元素的效果可以根据每个顶点、每个像素(在像素处理阶段)或两者计算。光照计算可以通过几种方式进行优化。首先，应该考虑所用光源的类型。所有三角形都需要照明吗?有时一个模型只需要纹理，在顶点上使用颜色纹理，或者只是在顶点上使用颜色。</strong></p>
<p><strong>如果光源相对于几何是静态的，那么漫反射和环境光照可以被预先计算并存储为顶点的颜色。这样做通常被称为在灯光上“烘焙”。预照明的一个更精细的形式是预计算场景中漫反射的全局照明(章节11.5.1)。这样的光照可以存储为顶点的颜色或强度，或者作为光照地图。</strong></p>
<p><strong>对于正向渲染系统，光源的数量会影响几何舞台的性能。更多的光源意味着更多的计算。减少工作的常见方法是禁用或削减局部照明，而使用环境地图(章节10.5)。</strong></p>
<h3 id="Rasterization-Stage-光栅化阶段"><a href="#Rasterization-Stage-光栅化阶段" class="headerlink" title="Rasterization Stage 光栅化阶段"></a>Rasterization Stage 光栅化阶段</h3><p><strong>栅格化可以通过几种方法进行优化。对于封闭(实体)对象和永远不会显示其背面的对象(例如，房间里的墙的背面)，应该打开背面剔除(章节19.3)。这减少了大约一半要栅格化的三角形数量，从而减少了三角形遍历的负载。此外，当像素着色计算很昂贵时，这尤其有用，因为背面永远不会着色。</strong></p>
<h3 id="Pixel-Processing-Stage-像素处理阶段"><a href="#Pixel-Processing-Stage-像素处理阶段" class="headerlink" title="Pixel Processing Stage 像素处理阶段"></a>Pixel Processing Stage 像素处理阶段</h3><p><strong>优化像素处理通常是有利可图的，因为通常要着色的像素比顶点多得多。也有一些明显的例外。顶点总是需要处理的，即使绘制结束时没有生成任何可见的像素。渲染引擎中无效的剔除可能会导致顶点着色成本超过像素着色。太小的三角形不仅会导致更多的顶点着色评估需要的，但也可以创建更多的部分覆盖四方，造成额外的工作。更重要的是，只覆盖几个像素的纹理网格通常线程占用率很低。正如在章节3.10中讨论的，采样纹理会有很大的时间开销，GPU通过切换到其他片段上执行着色程序来隐藏纹理，然后在获取纹理数据后返回。低占用率会导致较差的延迟隐藏。使用大量寄存器的复杂着色器也可以通过允许更少的线程同时可用来减少占用(章节23.3)。这种情况称为高寄存器压力。还有其他微妙之处，例如，频繁切换到其他扭曲可能会导致更多的缓存丢失。Wronski讨论了各种占用问题和解决方案。</strong></p>
<p><strong>首先，使用原生纹理和像素格式，即使用图形加速器内部使用的格式，以避免从一种格式到另一种格式的可能昂贵的转换。另外两种与纹理相关的技术是只加载所需的mipmap级别(章节19.10.1)和使用纹理压缩(章节6.2.6)。通常，更小和更少的纹理意味着更少的内存使用，这反过来意味着更低的传输和访问时间。纹理压缩也可以提高缓存性能，因为相同数量的缓存内存被更多的像素所占用。</strong></p>
<p><strong>细节技术的一个层次是使用不同的像素着色程序，这取决于物体与观察者的距离。例如，在一个场景中有三个飞碟模型，最接近的可能有一个复杂的凹凸贴图来显示表面的细节，而远处的两个则不需要。此外，为了简化计算和减少“萤火虫”，最远的飞碟可能会简化或完全删除高光。，因为取样不足而产生的闪光伪影。在简化模型中每个顶点使用一种颜色可以带来额外的好处，即不需要因为纹理变化而改变状态。</strong></p>
<p><strong>当三角形栅格化时片段是可见的，像素着色器才会被调用。GPU的早期z测试(章节23.7)根据z缓冲区检查碎片的z深度。如果不可见，碎片被丢弃，没有任何像素着色器评估，节省了相当多的时间。虽然z深度可以通过像素着色器修改，但这样做意味着早期z测试无法执行。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104130555.png" class="" title="image-20211104130555">

<p>左边场景的深度复杂性显示在右边。(使用NVIDIA公司的NVPerfHUD创建的图像。)</p>
<p><strong>为了理解程序的行为，特别是像素处理阶段的负载，可视化深度复杂性是很有用的，深度复杂性是指覆盖一个像素的表面的数量。上图显示了一个示例。生成深度复杂度图像的一个简单方法是使用类似OpenGL的glBlendFunc(GL One,GL One)的调用，禁用z缓冲。首先，图像被清除为黑色。场景中的所有物体都用颜色渲染(1/ 255,1 / 255,1 /255)。混合函数设置的效果是，对于每个渲染的原语，所写像素的值将增加一个强度级别。深度复杂度为0的像素为黑色，深度复杂度为255的像素为全白(255,255,255)。</strong></p>
<p><strong>像素透支的数量与实际渲染的表面数量有关。像素着色器被评估的次数可以通过再次渲染场景找到，但是启用了z缓冲区。透支是努力的数额浪费计算一个表面的着色，然后被后面的像素着色器调用隐藏。延迟渲染(第20.1节)和光线追踪的一个优点是，着色是在所有可见性计算完成后执行的。</strong></p>
<p><strong>假设两个三角形覆盖一个像素，所以深度复杂度是2。如果较远的三角形先绘制，则较近的三角形将对其进行透支，透支量为1。如果先画较近的三角形，则较远的三角形没有通过深度测试而不画，因此没有透支。对于覆盖一个像素的随机不透明三角形集合，绘制的平均次数为谐波级数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104130711.png" class="" title="image-20211104130711">

<p><strong>这背后的逻辑是，第一个三角形渲染是一个绘图。第二个三角形在第一个三角形的前面或后面，概率是50/50。与前两个三角形相比，第三个三角形可以有三个位置中的一个，有三分之一的机会是最前面的。当n趋于无穷时，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104130737.png" class="" title="image-20211104130737">

<p><strong>式中γ = 0.57721，…是欧拉-马斯切罗尼常数。当深度复杂性较低时，透支会迅速上升，但很快就会逐渐消失。例如，深度复杂度为4的玩家平均抽到2.08次，11的玩家平均抽到3.02次，但深度复杂度为12,367的玩家平均抽到10.00次。</strong></p>
<p><strong>所以，透支不一定像看起来那么糟糕，但我们仍然希望在不花费太多CPU时间的情况下最小化它。粗略排序，然后按照大致的前后顺序(从近到远)绘制场景中的不透明对象，是减少透支的常用方法。稍后绘制的闭塞对象将不会写入颜色或z-缓冲区(即减少透支)。此外，像素碎片可以在到达之前被遮挡剔除硬件拒绝像素着色程序(第23.5节)。排序可以通过任意数量的方法来完成。基于所有不透明对象的质心沿视图方向的距离的显式排序是一种简单的技术。如果一个边界体层次结构或其他空间结构已经被用于截锥剔除，我们可以选择更近的子层首先被遍历，沿着层次结构向下。</strong></p>
<p><strong>另一种技术可以用于复杂的像素着色程序的表面。执行z- preass首先将几何图形渲染到z-buffer中，然后整个场景正常渲染。这消除了所有的透支着色器评估，但以整个独立运行的所有几何为代价。Pettineo写道，他的团队在电子游戏中使用深度预估的主要原因是为了避免透支。然而，大致的从前到后的顺序可以提供很多相同的好处，而不需要额外的工作。一种混合方法是识别并首先绘制几个可能带来最大好处的大、简单的遮挡器。正如McGuire所指出的，在他的特殊系统中，全抽签预赛并不能帮助表现。度量是了解哪种技术(如果有的话)对您的应用程序最有效的唯一方法。</strong></p>
<p><strong>之前我们建议通过shader和纹理进行分组，以最小化状态变化;这里我们讨论的是按距离排序的渲染对象。这两个目标通常会给出不同的目标绘制顺序，从而产生冲突。对于给定的场景和视角，总是有一些理想的绘制顺序，但这很难事先找到。混合方案是可能的，例如，根据深度对附近的对象进行排序，而根据材料对其他所有东西进行排序。一个常见的、灵活的解决方案是为每个对象创建一个排序键，通过给每个对象分配一组位来封装所有相关的标准。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104131031.png" class="" title="image-20211104131031">

<p>示例排序键绘制顺序。键是由低到高排序的。设置透明度位意味着对象是透明的，因为透明对象是在所有不透明对象之后渲染的。物体到相机的距离存储为一个精度较低的整数。对于透明对象，距离是反向或负的，因为我们希望对象按前后顺序排列。着色器和纹理都有一个唯一的标识号。</p>
<p><strong>我们可以选择通过距离进行排序，但通过限制存储深度的比特数，我们可以允许在给定距离范围内的对象通过着色器进行分组。即使只有两到三个深度分区，对draw进行排序也是很常见的。如果某些对象具有相同的深度和使用相同的着色器，则使用纹理标识符对对象进行排序，然后将具有相同纹理的对象组合在一起。</strong></p>
<p><strong>这是一个简单的例子，并且是视情况而定的，例如，渲染引擎本身可能会将不透明和透明的对象分开，因此不需要透明度位。其他字段的位数当然随最大值而变化着色器和纹理的数量。可以添加或替换其他字段，例如一个用于混合状态，另一个用于z缓冲区读写。最重要的是架构。例如，移动设备上的一些基于瓦片的GPU渲染器不能从前后排序中获得任何好处，所以状态排序是唯一需要优化的重要元素。这里的主要思想是，将所有属性放在一个整数键中，可以让您执行有效的排序，从而尽可能减少透支和状态更改。</strong></p>
<h3 id="Framebuffer-Techniques-帧缓冲区技术"><a href="#Framebuffer-Techniques-帧缓冲区技术" class="headerlink" title="Framebuffer Techniques 帧缓冲区技术"></a>Framebuffer Techniques 帧缓冲区技术</h3><p><strong>渲染一个场景通常会引起对帧缓冲区的大量访问和许多像素着色器的执行。为了减少缓存层次结构的压力，一个常见的建议是减少framebuffer中每个像素的存储大小。虽然每个颜色通道的16位浮点值提供了更多的准确性，但8位值的大小是前者的一半，这意味着在准确性足够的情况下，访问速度会更快。在JPEG和MPEG等图像和视频压缩方案中，色度经常被下采样。由于人类的视觉系统对亮度比对色度更敏感，这通常可以忽略不计的视觉效果。例如，Frostbite游戏引擎就使用了色度子采样的想法，以减少后续处理每通道16位图像的带宽成本。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104131231.png" class="" title="image-20211104131231">

<p>左:4 × 2像素，每个存储4个颜色组件(RGBA)。右:一种替代表示，其中每个像素存储亮度Y和第一个(Co)或第二(Cg )颜色成分，在棋盘图案中。</p>
<p><strong>Mavridis和Papaioannou提出，在栅格化过程中，使用有损YCoCg变换来实现颜色缓冲的类似效果，如197页所述。它们的像素布局如上图所示。与RGBA相比，这一半的颜色缓冲存储需求(假设A不需要)，并经常提高性能，这取决于架构。由于每个像素只有一个色度分量，在显示前将每个像素转换回RGB之前，需要一个重建滤波器来推断出完整的YCoCg。对于缺少Co-value的像素，例如，最接近的四个Co-values的平均值可以使用。然而，这并不能像期望的那样重建边缘。因此，我们使用了一种简单的边缘感知滤波器，实现为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104131513.png" class="" title="image-20211104131513">

<p><strong>对于没有Co的像素,其中Co,i 和Li 为当前像素的左、右、上、下的值，L为当前像素的亮度，t为边缘检测的阈值。Mavridis和Papaioannou使用t = 30/255。如果x &lt; 0, step(x)函数为0，否则为1。因此，滤波器权重为wi 是0或1，当亮度梯度|Li −L|，大于t。WebGL演示和源代码可以在网上找到。</strong></p>
<p><strong>由于显示分辨率的不断提高和着色器执行成本的节省，使用棋盘模式渲染已经在几个系统中使用。对于虚拟现实应用程序，Vlachos使用棋盘模式来表示视图周围的像素，而Answer将每个2 × 2的四边形减少1到3个样本。</strong></p>
<h3 id="Merging-Stage-合并阶段"><a href="#Merging-Stage-合并阶段" class="headerlink" title="Merging Stage 合并阶段"></a>Merging Stage 合并阶段</h3><p><strong>确保只在有用的时候启用混合模式。理论上，“over”合成可以设置为每个三角形，不透明的或透明的，因为不透明的表面使用“over”将完全覆盖像素中的值。然而，这比简单的“替换”光栅操作成本更高，所以用裁剪纹理和透明材质跟踪对象是值得的。或者，有一些光栅操作不需要额外的成本。例如，当z-buffer被使用时，在某些系统中访问模板buffer并不需要额外的时间。这是因为8位的模板缓冲区值与24位的z-depth值存储在同一个单词中。</strong></p>
<p><strong>考虑何时需要使用或清除各种缓冲区是值得的。由于GPU有快速清除机制(章节23.5)，建议总是清除颜色和深度缓冲区，因为这增加了这些缓冲区的内存传输效率。</strong></p>
<p><strong>如果可以的话，你应该避免将渲染目标从GPU读回CPU。CPU对framebuffer的任何访问都会导致整个GPU管线在渲染返回之前被刷新，从而失去所有的并行性。</strong></p>
<p><strong>如果您确实发现合并阶段是您的瓶颈，那么您可能需要重新考虑您的方法。您是否可以使用精度较低的输出目标，比如通过压缩?有没有办法重新调整你的算法来减轻这个阶段的压力?对于阴影，有没有方法缓存和重用没有移动的部分?</strong></p>
<p><strong>在本节中，我们讨论了通过搜索瓶颈和调优性能来很好地使用每个阶段的方法。也就是说，要意识到重复优化算法的危险，因为使用完全不同的技术可能会更好。</strong></p>
<h2 id="Multiprocessing-多处理"><a href="#Multiprocessing-多处理" class="headerlink" title="Multiprocessing 多处理"></a>Multiprocessing 多处理</h2><p><strong>传统APIs已经发展到发出更少的调用，每个调用做更多的事情。新一代的APIs——DirectX 12, Vulkan, Metal——采取了不同的策略。</strong></p>
<p><strong>对于这些APIs，驱动程序是流线型的和最小的，有很多复杂性和责任来验证状态转移到调用的应用程序，以及内存分配和其他功能。这种重新设计在很大程度上是为了减少绘制调用和状态更改的开销，这些开销来自于必须将旧APIs映射到现代GPUs。这些新APIs鼓励的另一个元素是使用多个CPU处理器来调用API。</strong></p>
<p><strong>在2003年左右，由于一些物理问题，如散热和功耗，CPU时钟速度不断上升的趋势在3.4 GHz左右趋于平缓。这些限制导致了多处理CPU的出现，在这种情况下，更多的CPU被放在一个芯片上，而不是更高的时钟速率。事实上，许多小核在单位面积上提供了最好的性能，这是GPU本身如此有效的主要原因。从那时起，创建利用并发性的高效、可靠的程序就一直是一个挑战。在这一节中，我们将讨论CPU核上高效多处理的基本概念，最后讨论图形API是如何进化来支持驱动程序本身的更多并发性的。</strong></p>
<p><strong>多处理器计算机可以大致分为消息传递体系结构和共享内存多处理器。在消息传递设计中，每个处理器都有自己的内存区域，处理器之间发送消息来传递结果。这些在实时渲染中并不常见。共享内存多处理器就像它们的名字一样;所有处理器共享一个逻辑地址空间的内存。大多数流行的多处理器系统使用共享内存，其中大多数都有对称多处理(SMP)设计。SMP意味着所有的处理器都是相同的。多核PC系统是对称多处理体系结构的一个例子。</strong></p>
<p><strong>在这里，我们将介绍两种使用多处理器实时图形的一般方法。第一种方法——多处理器流水线，也称为时间对等——将比第二种并行处理(也称为空间并行)更详细地介绍。这两种方法如下图所示。然后将这两种类型的并行性与基于任务的多处理结合在一起，应用程序创建的作业可以由单独的核心提取和处理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104132322.png" class="" title="image-20211104132322">

<p>使用多处理器的两种不同方式。在顶部，我们展示了如何在一个多处理器管道中使用三个处理器(CPU)，在底部，我们展示了在三个cpu上的并行执行。这两种实现之间的区别之一是，如果使用底部的配置，可以实现更低的延迟。另一方面，使用多处理器管线可能更容易。这两种构型的理想加速都是线性的，即。如果使用n个CPU，则加速为n倍。</p>
<h3 id="Multiprocessor-Pipelining-多处理器管线"><a href="#Multiprocessor-Pipelining-多处理器管线" class="headerlink" title="Multiprocessor Pipelining 多处理器管线"></a>Multiprocessor Pipelining 多处理器管线</h3><p><strong>正如我们所看到的，管线是一种通过将作业划分为并行执行的某些管线阶段来加快执行速度的方法。一个管线阶段的结果被传递到下一个阶段。理想的加速是n个管线阶段的n倍，而最慢的阶段(瓶颈)决定了实际的加速。到目前为止，我们已经看到了使用单个CPU核和GPU并行运行应用程序、几何处理、光栅化和像素处理。当主机上有多个处理器时，也可以使用管线，在这些情况下，它被称为多进程管线或软件管线。</strong></p>
<p><strong>这里我们描述了一种软件流水线。可能有无穷无尽的变化，方法应适合于特定的应用。在本例中，应用阶段分为三个阶段:APP, CULL, DRAW。这是粗粒度的流水线，这意味着每个阶段都相对较长。APP阶段是流程中的第一阶段，因此控制着其他阶段。在这个阶段，应用程序程序员可以添加额外的代码，例如，碰撞检测。这个阶段也更新了视点。CULL阶段可以执行:</strong></p>
<pre><code>**•场景图上的遍历和层次视图截锥剔除(章节19.4)。**

**•细节级别选择(第19.9节)。**

**•状态排序，如18.4.5节所述。**

**•最后(总是执行)，生成一个应该渲染的所有对象的简单列表。**
</code></pre>
<p><strong>DRAW阶段从CULL阶段获取列表，并发出该列表中的所有图形调用。这意味着它只是简单地遍历列表并为GPU提供信息。下图显示了如何使用此管线的一些示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104132651.png" class="" title="image-20211104132651">

<p>多处理器管线的不同配置。粗线表示阶段之间的同步，下标表示帧号。在顶部，显示了单个CPU管线。在中间和底部显示了使用两个CPU的两个不同的管线细分。中间有一个APP和CULL的流水线阶段，一个DRAW的流水线阶段。如果DRAW要做的工作比其他的要多，这是一个合适的细分。在底部，APP有一个管线阶段，其他两个有另一个管线阶段。如果APP比其他APP有更多的工作，这是合适的。注意，底部的两个配置有更多的时间用于APP、CULL和DRAW阶段。</p>
<p><strong>如果一个处理器核心可用，那么所有三个阶段都在该核心上运行。如果有两个CPU核可用，则可以在一个核上执行APP和CULL，在另一个核上执行DRAW。另一种配置是在一个核和CULL上执行APP在另一边画。哪个是最好的取决于不同阶段的工作负载。最后，如果主机有三个可用的核心，那么每个阶段都可以在单独的核心上执行。这种可能性如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104132842.png" class="" title="image-20211104132842">

<p>在顶部，显示了一个三级管线。与上图中的配置相比，该配置为每个管线阶段提供了更多的时间。下面的插图显示了一种减少延迟的方法:CULL和DRAW与FIFO缓冲之间重叠。</p>
<p><strong>这种技术的优点是吞吐量，即渲染速度增加。缺点是，与并行处理相比，延迟更大。延迟，或暂时延迟，是从轮询用户的操作到最终图像所花费的时间。这不应该与帧速率混淆，帧速率是每秒显示的帧数。例如，假设用户正在使用一个头戴显示设备。头部位置的确定可能需要10毫秒到达CPU，然后需要15毫秒渲染帧。从初始输入到显示的延迟是25毫秒。即使帧速率为66.7 Hz(1/0.015秒)，如果没有进行位置预测或其他补偿，交互也会因为向CPU发送位置变化的延迟而感到缓慢。如果忽略由用户交互引起的延迟(这在两个系统中都是一个常量)，多处理比并行处理有更多的延迟，因为它使用了管线。正如下一节将详细讨论的那样，并行处理将框架的工作分解为并发运行的部分。</strong></p>
<p><strong>与在主机上使用单个CPU相比，多处理器流水线提供了更高的帧速率，由于同步的成本，延迟大约相同或略高。延迟随着管道中的阶段数量的增加而增加。对于平衡良好的应用程序，n个CPU的加速是n倍。</strong></p>
<p><strong>减少延迟的一种技术是在APP阶段结束时更新视点和其他延迟关键参数。这将(大约)减少一帧延迟。另一种减少延迟的方法是执行CULL和DRAW重叠。这意味着CULL的结果一旦准备好渲染，就会发送到DRAW。为了使它工作，在这些阶段之间必须有一些缓冲，通常是FIFO。这些阶段在空空如也的情况下停止运转;即当缓冲区满时，CULL必须停止，而当缓冲区空时，DRAW必须饿死。缺点是不能在相同程度上使用状态排序等技术，因为原语必须在CULL处理后立即呈现。上图显示了这种延迟减少技术。</strong></p>
<p><strong>图中的管线最多使用3个CPU，各个阶段有特定的任务。然而，这种技术并不局限于此配置——相反，您可以使用任意数量的CPU并以任何您想要的方式分配工作。关键是对整个工作进行明智的划分，使管道趋于平衡。多处理器流水线技术需要最小的同步，因为它只需要在切换帧时进行同步。还可以使用额外的处理器进行并行处理，这需要更频繁的同步。</strong></p>
<h3 id="Parallel-Processing-并行处理"><a href="#Parallel-Processing-并行处理" class="headerlink" title="Parallel Processing 并行处理"></a>Parallel Processing 并行处理</h3><p><strong>使用多处理器管道技术的一个主要缺点是延迟往往会增加。对于某些应用程序，如飞行模拟器、第一人称射击游戏和虚拟现实渲染，这是不可接受的。当移动视点时，您通常希望立即(下一帧)响应，但当延迟较长时，这将不会发生。也就是说，这要视情况而定。如果多处理将帧速率从30帧每秒(1帧延迟)提高到60帧每秒(2帧延迟)，额外的帧延迟不会有明显的差别。</strong></p>
<p><strong>如果有多个处理器可用，还可以尝试并发运行部分代码，这可能会缩短延迟。要做到这一点，程序的任务必须具有并行性。有几种不同的算法并行化方法。假设有n个处理器可用。使用静态分配，将整个工作包(如加速结构的遍历)划分为n个工作包。然后每个处理器处理一个工作包，所有处理器并行地执行它们的工作包。当所有处理器都完成了它们的工作包时，可能需要合并来自处理器的结果。为了实现这一点，工作负载必须是高度可预测的。</strong></p>
<p><strong>如果不是这样，可以使用适应不同工作负载的动态分配算法。它们使用一个或多个工作池。当生成作业时，它们被放入工作池中。然后，当CPU完成当前任务时，可以从队列中获取一个或多个任务。必须小心，以使只有一个CPU可以获取特定的作业，并使维护队列的开销不会损害性能。较大的作业意味着维护队列的开销变得不那么严重，但是，另一方面，如果作业太大，那么由于系统中的不平衡，性能可能会降低。一个或多个CPU可能会饿死。</strong></p>
<p><strong>对于多处理器流水线，运行在n个处理器上的并行程序的理想加速是n倍。这叫做线性加速。尽管线性加速很少发生，但实际结果有时很接近。</strong></p>
<p><strong>在807页的图18.8中，显示了一个多处理器管线和一个有三个CPU的并行处理系统。暂时假设它们对每一帧做同样的工作，并且两种配置都实现线性加速。这意味着执行速度是串行执行的三倍。在单个CPU上)。此外，我们假设每帧的总工作量需要30毫秒，这意味着单个CPU上的最大帧速率将是1/0.03≈33帧每秒。</strong></p>
<p><strong>多处理器管线(理想情况下)将工作划分为三个大小相同的工作包，并让每个CPU负责一个工作包。然后，完成每个工作包需要10毫秒。如果我们沿着流水线的工作流程，我们将看到流水线中的第一个CPU工作了10毫秒(即10毫秒)。(即任务的三分之一)，然后将其发送到下一个CPU。然后，第一个CPU开始处理下一帧的第一部分。当一帧最终完成时，它需要30毫秒才能完成，但由于工作是在流水线中并行完成的，每10毫秒就会完成一帧。因此，延迟是30毫秒，加速是3倍(30/10)，结果是100帧每秒。</strong></p>
<p><strong>同一个程序的并行版本也将作业划分为三个工作包，但这三个工作包将在三个CPU上同时执行。这意味着延迟将是10毫秒，一帧的工作也将花费10毫秒。结论是，使用并行处理时的延迟要比使用多处理器管线时短得多。</strong></p>
<h3 id="Task-Based-Multiprocessing-基于任务的多处理"><a href="#Task-Based-Multiprocessing-基于任务的多处理" class="headerlink" title="Task-Based Multiprocessing 基于任务的多处理"></a>Task-Based Multiprocessing 基于任务的多处理</h3><p><strong>了解管线和并行处理技术，很自然地结合起来两者都在一个系统中。如果只有几个处理器可用，它可能会有一个简单的系统来显式地将系统分配给特定的核心是有意义的。然而，考虑到许多CPU上有大量的内核，现在的趋势是使用基于任务的多处理。正如一个人可以为自己创建多个任务（也称为作业）作为一个可以并行化的过程，这个想法可以扩展到包括流水线。任何核心生成的任何任务都会在生成时放入工作池。免费的处理器获取要处理的任务。</strong></p>
<p><strong>转换为多处理的一种方法是采用应用程序的工作流和确定哪些系统依赖于其他系统。见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104133634.png" class="" title="image-20211104133634">

<p>Frostbite CPU作业图，一个小的放大部分插入。</p>
<p><strong>如果处理器在等待同步时停止，则意味着基于任务的应用程序版本可能会变得更慢，这是由于这个成本和任务管理开销造成的。然而，许多程序和算法确实有大量的任务可以在同一时间执行，因此可以受益。</strong></p>
<p><strong>下一步是确定每个系统的哪些部分可以分解为任务。如果一段代码是一个很好的候选任务，它的特征包括:</strong></p>
<pre><code>**•任务有明确定义的输入和输出。**

**•任务在运行时是独立的和无状态的，并且总是完成。**

**•它不是一个大任务，它经常成为唯一运行的进程。**
</code></pre>
<p><strong>像C++ 11这样的语言都内置了多线程工具。在英特尔兼容的系统上，英特尔的开源线程构建块(TBB)是一个高效的库，它简化了任务生成、池和同步。</strong></p>
<p><strong>当性能至关重要时，让应用程序创建自己的多处理任务集(如模拟、碰撞检测、遮挡测试和路径规划)是给定的。我们在这里再次注意到，GPU内核有时也会处于空闲状态。例如，这些通常在阴影地图生成或深度预渲染时未被充分使用。在这种空闲时间，计算着色器可以应用到其他任务。根据架构、API和内容，有时候渲染管道不能让所有的着色器都忙起来，这意味着总有一些可用的池来计算着色。我们不会讨论优化这些着色器的话题，因为Lauritzen提出了一个令人信服的论点，即由于硬件差异和语言限制，编写快速和便携的计算着色器是不可能的。如何优化核心渲染管线本身是下一节的主题。</strong></p>
<h3 id="Graphics-API-Multiprocessing-Support-图形API多处理支持"><a href="#Graphics-API-Multiprocessing-Support-图形API多处理支持" class="headerlink" title="Graphics API Multiprocessing Support 图形API多处理支持"></a>Graphics API Multiprocessing Support 图形API多处理支持</h3><p><strong>并行处理通常不会映射到硬件约束。例如，DirectX 10及更早的版本一次只允许一个线程访问图形驱动程序，因此实际绘制阶段的并行处理就比较困难。</strong></p>
<p><strong>图形驱动程序中有两种操作可以使用多个处理器:资源创建和呈现相关调用。创建纹理和缓冲区等资源可以是纯粹的CPU端操作，因此自然是并行的。也就是说，创建和删除也可以阻塞任务，因为它们可能会触发GPU上的操作或需要特定的设备上下文。无论如何，旧API是在消费者级多处理CPU出现之前创建的，因此需要重写以支持这种并发性。</strong></p>
<p><strong>使用的关键结构是命令缓冲区或命令列表，它可以追溯到OpenGL的一个古老的概念，称为显示列表。命令缓冲区(CB)是API状态更改和绘制调用的列表。这样的列表可以被创建、存储和重放为想要的。它们也可以组合成更长的命令缓冲区。只有单个CPU处理器通过驱动程序与GPU通信，因此可以发送一个CB给它执行。但是，每个处理器(包括这个单个处理器)都可以并行地创建或连接存储的命令缓冲区。</strong></p>
<p><strong>例如，在DirectX 11中，与驱动程序通信的处理器将其渲染调用发送到所谓的即时上下文。其他处理器都使用一个延迟上下文来生成命令缓冲区。顾名思义，这些不会直接发送给驱动程序。相反，它们被发送到直接上下文进行呈现。参见下图。另外，可以将命令缓冲区发送到另一个延迟上下文，后者将其插入到自己的CB中。除了向驱动程序发送命令缓冲区以供执行外，直接上下文可以执行而延迟上下文不能执行的主要操作是GPU查询和读回。否则，命令缓冲区管理从任何类型的上下文来看都是相同的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104133950.png" class="" title="image-20211104133950">

<p>命令缓冲区。每个处理器使用其延迟上下文(橙色)来创建和填充一个或多个命令缓冲区(蓝色)。每个命令缓冲区被发送到进程#1，进程#1使用它的直接上下文(显示为绿色)按需要执行这些命令。进程#1可以在等待进程#3的命令缓冲区N的同时执行其他操作。(源自Zink等人。)</p>
<p><strong>命令缓冲区及其前身显示列表的一个优点是，它们可以被存储和回放。命令缓冲区在创建时没有完全绑定，这有助于它们的重用。例如，假设一个CB包含一个视图矩阵。摄像机移动，所以视图矩阵改变。然而，视图矩阵存储在一个常量中缓冲区。常量缓冲区的内容不存储在CB中，只存储对它们的引用。可以在不重建CB的情况下更改常量缓冲区的内容。决定如何最好地最大化并行性涉及选择合适的粒度(每个视图、每个对象、每个材料)来创建、存储和组合命令缓冲区。</strong></p>
<p><strong>在命令缓冲区成为现代api的一部分之前，这种多线程绘制系统已经存在很多年了。API支持使这个过程更简单，并允许更多的工具使用所创建的系统。然而，命令列表确实有相关的创建和内存成本。同样，在DirectX 11和OpenGL中，将API的状态设置映射到底层的GPU仍然是一个昂贵的操作，如18.4.2节所讨论的。在这些系统中，当应用程序成为瓶颈时，命令缓冲区可以起到帮助作用，但当驱动程序成为瓶颈时，命令缓冲区可能是有害的。</strong></p>
<p><strong>这些早期API中的某些语义不允许驱动程序并行化各种操作，这有助于推动Vulkan、DirectX 12和Metal的开发。一个可以很好地映射到现代GPU的瘦的绘图提交接口将这些新API的驱动成本降至最低。命令缓冲区管理、内存分配和同步决策由应用程序而不是驱动程序负责。此外，使用这些较新的API的命令缓冲区在形成时进行一次验证，因此重复播放的开销比使用较早的api(如DirectX 11)的开销更小。所有这些元素结合起来可以提高API的效率，允许多处理，并减少驱动程序成为瓶颈的可能性。</strong></p>
<h1 id="19-Acceleration-Algorithms-加速算法"><a href="#19-Acceleration-Algorithms-加速算法" class="headerlink" title="19 Acceleration Algorithms 加速算法"></a>19 Acceleration Algorithms 加速算法</h1><p><strong>关于计算机的一个伟大的神话是，总有一天我们会有足够的处理能力。即使是在一个相对简单的应用程序中，如文字处理，我们发现额外的功能也可以应用于各种功能，如即时拼写和语法检查、文本抗锯齿显示和听写。</strong></p>
<p><strong>在实时渲染中，我们至少有四个性能目标:每秒更多的帧数，更高的分辨率和采样率，更真实的材料和照明，以及增加几何复杂度。通常认为60-90帧每秒的速度已经足够快了。即使使用运动模糊，可以降低图像质量所需的帧率，在与场景交互时仍然需要一个快速的帧率来最小化延迟。</strong></p>
<p><strong>今天，我们有分辨率为3840×2160的4k显示器;8k分辨率为7680×4320的显示器已经存在，但还不常见。4k显示器通常有每英寸140-150个点(DPI)，有时也称为每英寸像素(PPI)。移动电话显示器的值可达400 DPI左右。如今许多打印机公司都能提供1200 DPI的分辨率，这是4k显示器像素的64倍。即使有屏幕分辨率的限制，抗锯齿也增加了生成高质量图像所需的样本数量。正如在第23.6节中讨论的，每个颜色通道的比特数也可以增加，这就需要更高的精度(因此更昂贵)计算。</strong></p>
<p><strong>正如前面的章节所展示的，描述和计算一个对象的材料可能是计算复杂的。光和表面相互作用的建模可以消耗任意数量的计算能力。这是真的，因为从光源到眼睛的无数路径的光最终会形成图像。</strong></p>
<p><strong>帧率、分辨率和着色总是可以变得更复杂，但增加任何一项都会带来收益递减的感觉。然而，没有场景复杂度的真正上限。波音777的效果图包括132,500个独特的部件和超过3,000,000个紧固件，这产生了一个超过5亿个多边形的多边形模型。参见下图。即使这些物体中的大多数由于体积小或位置小而看不到，也必须做一些工作来确定这是事实。z缓冲和射线追踪都不能处理这样的模型，除非使用技术来减少所需的计算数量。我们的结论是:总是需要加速算法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105120832.png" class="" title="image-20211105120832">

<p>一个“简化”的波音模型，仅用光线追踪渲染了3.5亿个三角形。切片是通过使用用户定义的剪切平面来执行的。图片由萨尔兰大学计算机图形组提供。来源3D数据由波音公司提供并经许可使用。)</p>
<p><strong>在本章中，我们提供了一系列加速计算机图形渲染的算法，特别是大量几何图形的渲染。许多这类算法的核心是基于空间数据结构的，这将在下一节中描述。基于这些知识，我们继续使用剔除技术。这些算法试图快速确定哪些物体是可见的，需要进一步处理。细节级别技术降低了渲染其余对象的复杂性。在本章的最后，我们讨论了渲染大型模型的系统，包括虚拟纹理、流、转码和地形渲染。</strong></p>
<h2 id="Spatial-Data-Structures-空间数据结构"><a href="#Spatial-Data-Structures-空间数据结构" class="headerlink" title="Spatial Data Structures 空间数据结构"></a>Spatial Data Structures 空间数据结构</h2><p><strong>空间数据结构是指组织某个n维空间中的几何结构。本书只使用了二维和三维结构，但这些概念通常可以很容易地扩展到高维。这些数据结构可用于加速查询几何实体是否重叠。这样的查询被用于各种各样的操作，如剔除算法，在交叉测试和光线追踪期间，以及碰撞检测。</strong></p>
<p><strong>空间数据结构的组织通常是分层的。这意味着，松散地说，最高层包含一些子层，每个子层定义自己的子层空间的体积，反过来又包含它自己的子元素。因此，该结构是嵌套的，具有递归性质。这个层次结构中的一些元素引用了几何体。使用层次结构的主要原因是,不同类型的查询得到更快,通常一个进步从O (n) O (log n)。也就是说,与其搜索所有n对象,我们访问一小部分在执行操作,比如寻找最接近的对象在一个给定的方向。空间数据结构的构造时间可能非常昂贵，并且取决于其内部几何形状的数量和所需的数据结构的质量。然而，该领域的重大进展大大减少了施工时间，在某些情况下可以实时完成。使用惰性计算和增量更新，可以进一步减少构建时间。</strong></p>
<p><strong>一些常见的空间数据结构类型是包围体层次结构、二进制空间分区(BSP)树的变体、四叉树和八叉树。BSP树和八叉树是基于空间细分的数据结构。这意味着场景的整个空间被细分并编码在数据结构中。例如，所有叶节点空间的并集等于场景的整个空间。一般情况下，叶节点的体积不重叠，除了一些不太常见的结构，如松散八叉树。BSP树的大多数变体都是不规则的，这意味着空间可以更随意地细分。八叉树是规则的，这意味着空间是以统一的方式分割的。尽管有更多的限制，但这种一致性往往是效率的一个来源。另一方面，包围卷层次结构不是空间细分结构。相反，它包围了几何物体周围的空间区域，因此BVH不需要在每一层包围所有空间。</strong></p>
<p><strong>BVHs、BSP树和八叉树都将在接下来的章节中描述，以及场景图，它是一种更关注模型关系而不是有效渲染的数据结构。</strong></p>
<h3 id="Bounding-Volume-Hierarchies-包围体次结构"><a href="#Bounding-Volume-Hierarchies-包围体次结构" class="headerlink" title="Bounding Volume Hierarchies 包围体次结构"></a>Bounding Volume Hierarchies 包围体次结构</h3><p><strong>包围体(BV)是一个包含一组对象的卷。BV的想法是，它应该是一个比包含的对象更简单的几何形状，因此使用BV的测试可以比使用对象本身更快地完成。BV的例子有球体、轴向包围盒(AABBs)、定向包围盒(OBBs)和k- DOPs。参见第22.2节的定义。BV对渲染的图像没有视觉上的贡献。相反，它被用作一个代理来代替有界对象，以加速呈现、选择、查询和其他计算。</strong></p>
<p><strong>对于三维场景的实时绘制，通常使用包围体层次进行分层视图截锥剔除(章节19.4)。场景组织在一个层次树结构，由一组连接的节点组成。最上面的节点是根节点，它没有父节点。内部节点有指向它的子节点(即其他节点)的指针。因此，根是一个内部节点，除非它是树中唯一的节点。叶节点保存要渲染的实际几何图形没有任何子节点。树中的每个节点(包括叶节点)都有一个包围体，该包围体将几何图形包围在它的整个子树中。还可以决定从叶节点中排除bv，而将它们包含在每个叶节点上方的内部节点中。这个设置就是名称包围卷层次结构的来源。每个节点的BV包含了其子树中所有叶子节点的几何形状。这意味着根具有包含整个场景的BV。下图显示了BVH的一个示例。注意，一些较大的边界圈可以变得更紧，因为每个节点只需要包含其子树中的几何图形，而不需要包含后代节点的bv。对于包围圆(或球体)，形成如此紧密的节点可能是昂贵的，因为它的子树中的所有几何都必须由每个节点检查。在实践中，一个节点的BV通常是通过树“自下而上”形成的，通过创建一个包含其子节点BV的BV。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105125416.png" class="" title="image-20211105125416">

<p>左边部分显示了一个简单的场景，有五个对象，在右侧的包围体层次中使用了包围圈。一个圆包住所有的对象，然后小的圆以递归的方式在大的圆里面。右侧显示了用于表示左侧对象层次结构的包围体层次结构(树)。</p>
<p><strong>BVH的底层结构是树，在计算机科学领域，关于树数据结构的文献是大量的。这里只会提到几个重要的结果。如需了解更多信息，请参见Cormen等人的《算法导论》一书。</strong></p>
<p><strong>考虑一个k-ary树，即每个内部节点都有k个子节点的树。只有一个节点(根)的树被称为高度为0。根的叶节点高度为1，依此类推。平衡树是指所有叶节点高度为h或h−1的树。一般来说，平衡树的高度h是⌊logk n⌋， 其中n是树中节点(内部节点和叶子节点)的总数。注意，k越高，树的高度越低，这意味着遍历树的步骤越少，但在每个节点上也需要做更多的工作。二叉树通常是最简单的选择，并且具有合理的性能。然而,在是证据，较高的k(例如，k = 4或k = 8)为某些应用程序提供更好的性能。使用k = 2, k = 4，或k = 8可以使构造树变得简单;只要沿着k = 2的最长轴细分，k = 4的两个最长轴，以及k = 8的所有轴。更难养成良好的为其他的k值树。树更高的数字,例如,k = 8,每个节点的子节点往往喜欢从性能的角度而言,因为他们减少平均树深度和间接的数量(从父母到孩子指针)。</strong></p>
<p><strong>BVHs非常适合执行各种查询。例如，假设一条射线与场景相交，找到的第一个交集应该返回，就像阴影射线的情况一样。要为此使用BVH，测试从根开始。如果射线错过了它的BV，那么射线就错过了包含在BVH中的所有几何图形。否则，测试将继续递归进行，即测试根的子节点的BV。一旦射线错过了BV, BVH的子树上的测试就会终止。如果射线命中了一个叶节点的BV，射线就会在这个节点的几何体上进行测试。性能提高的部分原因是使用BV测试射线速度很快。这就是为什么像球体和盒子这样的简单物体被用作BV。另一个原因是BV的嵌套，这使得我们可以避免由于在树中提前终止而测试大区域的空间。</strong></p>
<p><strong>往往最接近的路口，不是最先发现的，是最渴望的。唯一需要的额外数据是遍历树时发现的最近对象的距离和身份。在遍历过程中，当前最近的距离也被用来剔除树。如果一个BV是相交的，但是它的距离超过了目前为止找到的最近的距离，那么BV可以被丢弃。当检查父框时，我们交叉所有子BV并找到最近的。如果在这个BV的后代中发现了交集，则使用这个新的最近距离来挑选是否需要遍历其他的后代。我们可以看到，BSP树比普通BVHs更有优势，因为它可以保证从前到后的排序，而不是BVHs提供的这种粗略排序。</strong></p>
<p><strong>BVHs也可以用于动态场景。当包含在BV中的对象移动时，只需检查它是否仍然包含在其父BV中。如果是，则BVH仍然有效。否则，将删除对象节点并重新计算父节点的BV。然后将节点从根递归插入到树中。另一种方法是增大父节点的BV，以便在需要时递归地向上保存子节点。使用任何一种方法，当执行越来越多的编辑时，树都可能变得不平衡和低效。另一种方法是在物体在一段时间内的移动范围周围放置一个BV。这被称为暂时边界体积。例如，一个钟摆可以有一个包围盒，它的运动可以包围整个体积。人们也可以进行自下而上的改装，或者选择树的一部分来改装或重建。</strong></p>
<p><strong>要创建BVH，首先必须能够围绕一组对象计算紧BV。本主题将在第22.3节中讨论。然后，必须创建BV的实际层次结构。参见realtimerendering.com的碰撞检测章节，了解更多关于BV建造策略的内容。</strong></p>
<h3 id="BSP-Trees-BSP树"><a href="#BSP-Trees-BSP树" class="headerlink" title="BSP Trees BSP树"></a>BSP Trees BSP树</h3><p><strong>二进制空间划分树，简称BSP树，在计算机图形学中以两种明显不同的形式存在，我们称之为轴对齐树和多边形对齐树。树是通过使用平面将空间分成两部分，然后将几何图形分类到这两个空间中来创建的。这个除法是递归的。一个有价值的特性是，如果以某种方式遍历BSP树，树的几何内容可以从任何角度从前到后排序。这种排序对于轴对齐的BSPs是近似的，对于多边形对齐的BSP是精确的。注意，轴对齐的BSP树也称为k-d树</strong></p>
<h4 id="Axis-Aligned-BSP-Trees-k-D-Trees-轴向BSP树-k-D树"><a href="#Axis-Aligned-BSP-Trees-k-D-Trees-轴向BSP树-k-D树" class="headerlink" title="Axis-Aligned BSP Trees (k-D Trees)  轴向BSP树(k-D树)"></a>Axis-Aligned BSP Trees (k-D Trees)  轴向BSP树(k-D树)</h4><p><strong>以如下方式创建轴向BSP树。首先，整个场景被包围在一个轴对齐的包围框(AABB)中。接下来的想法是递归地将这个框细分为更小的框。现在，考虑任意递归级别的方框。选择盒子的一个轴，生成一个垂直的平面，将空间分成两个盒子。有些方案确定了这个划分平面，以便将盒子精确地分成两半;另一些允许平面改变位置。通过改变平面位置，称为非均匀细分，得到的树可以变得更加平衡。对于固定的平面位置，称为均匀细分，节点在内存中的位置由其在树中的位置隐式给出。</strong></p>
<p><strong>与平面相交的物体可以用多种方法处理。例如，它可以存储在树的这一层，或者成为两个子框的成员，或者被平面分割成两个独立的对象。在树级别存储的好处是树中只有一个对象的副本，这使得删除对象很简单。然而，被分裂平面相交的小物体会卡在树的上层，这往往是低效的。将相交的对象放置到两个子对象中可以使较大的对象具有更紧密的边界，因为所有对象都向下渗透到一个或多个叶节点，但只有那些它们重叠的叶节点。每个子框包含一定数量的对象，这个平面分割过程重复进行，递归地细分每个AABB，直到满足某个条件停止该过程。下图是轴对齐的BSP树的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105125953.png" class="" title="image-20211105125953">

<p>Axis-aligned BSP树。在这个例子中，空间分区允许位于轴线上的任何位置，而不仅仅是中点。形成的空间体块被标记为A到E。右边的树显示了底层的BSP数据结构。每个叶节点代表一个区域，该区域的内容显示在其下方。注意，这个三角形位于两个区域C和E的对象列表中，因为它重叠了这两个区域。</p>
<p><strong>粗略的前后排序是如何使用轴对齐BSP树的一个例子。这对于遮挡剔除算法是有用的(章节19.7和23.7)，以及通过最小化像素透支来减少像素着色器成本。假设当前遍历一个名为N的节点。这里，N是遍历开始时的根。检查N的分裂平面，然后递归地在查看器所在平面的一侧继续遍历树。因此，只有当整个树的一半被遍历时，我们才开始遍历另一边。由于叶节点的内容没有排序，而且对象可能位于树的许多节点中，因此这种遍历不会给出精确的前后排序。然而，它给出了一个粗略的排序，这通常是有用的。与查看器的位置相比，通过在节点平面的另一侧开始遍历，粗略的前后排序可以被获得。这对于透明排序很有用。BSP遍历也可以用来测试光线对场景几何的影响。射线的来源只是用来交换观察者的位置。</strong></p>
<h4 id="Polygon-Aligned-BSP-Trees-多边形对称BSP树"><a href="#Polygon-Aligned-BSP-Trees-多边形对称BSP树" class="headerlink" title="Polygon-Aligned BSP Trees 多边形对称BSP树"></a>Polygon-Aligned BSP Trees 多边形对称BSP树</h4><p><strong>另一种类型的BSP树是多边形对齐的形式。这种数据结构对于按照精确排序的顺序呈现静态或刚性几何图形特别有用。这种算法在《毁灭战士》(2016)等游戏中很受欢迎，当时还没有硬件z缓冲区。它仍然有偶尔的用途，如碰撞检测和交叉测试。</strong></p>
<p><strong>在该方案中，选择一个多边形作为分隔器，将空间分成两半。也就是说，在根节点，选择一个多边形。多边形所在的平面用于将场景中的其余多边形划分为两个集合。任何被分割平面相交的多边形沿着相交线被分割成两个独立的部分。现在在剖分平面的每个半空间中，选择另一个多边形作为分割器，只分割其半空间中的多边形。这个过程是递归的，直到所有的多边形都在BSP树中。创建高效的多边形对齐BSP树是一个耗时的过程，这样的树通常只计算一次并存储以供重用。这类BSP树如下图所示。一般来说，形成一棵平衡的树是最好的。其中每个叶节点的深度相同，或最多相差1。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105130935.png" class="" title="image-20211105130935">

<p>Polygon-aligned BSP树。多边形A到G如图所示。首先用多边形A分割空间，然后用B和C分别分割每个半空间。由多边形B形成的分割平面与左下角的多边形相交，将其分割成单独的多边形D和E。</p>
<p><strong>多边形对齐的BSP树有一些有用的属性。一个是，对于给定的视图，结构可以严格从后到前(或从前到后)遍历。</strong></p>
<p><strong>这与轴对齐的BSP树相比，后者通常只给出粗略排序的顺序。确定相机位于根平面的哪一边。在这个平面的远侧的多边形集合在近侧的集合之外。现在远侧的设置，采取下一层的划分平面，并确定相机在哪一边。远端的子集也是离摄像机最远的子集。通过继续递归，这个过程建立了严格的前后顺序，可以使用画家的算法来渲染场景。画家的算法不需要z缓冲区。如果所有对象都是按照前后顺序绘制的，那么每一个较近的对象就会被画在它后面的对象的前面，这样就不需要z-depth比较了。</strong></p>
<p><strong>例如，考虑查看器v在上图中看到的内容。不管观察方向和截锥体,v是左边的分裂面形成的,所以C、F和G B, D和E。v C的分裂面比较,我们发现G的对面这个平面,所以它显示。对B平面的测试确定E应该在D之前显示，那么从后到前的顺序是G, C, F, A, E, B, D。注意，这个顺序并不能保证一个物体比另一个物体离观众更近。相反，它提供了一个严格的闭塞顺序，一个微妙的区别。例如，多边形F比多边形E更接近v，尽管它在闭塞顺序上更靠后。</strong></p>
<h3 id="Octrees-八叉树"><a href="#Octrees-八叉树" class="headerlink" title="Octrees 八叉树"></a>Octrees 八叉树</h3><p><strong>八叉树类似于轴对齐的BSP树。一个盒子沿三个轴同时分裂，分裂点必须是盒子的中心。这将创建8个新框——因此命名为八叉树。这使结构变得规则，从而使某些查询更有效。</strong></p>
<p><strong>八叉树是通过将整个场景包围在一个最小的轴对齐框中来构建的。该过程的其余部分本质上是递归的，并在满足停止条件时结束。与轴对齐的BSP树一样，这些标准可以包括达到最大递归深度，或者在一个方框中获得一定数量的原语。如果满足条件，算法将原语绑定到方框并终止递归。否则，它将盒子沿着其主轴使用三个平面细分，从而形成八个大小相同的盒子。每个新盒子都经过测试，并可能再次细分为2 × 2 × 2个更小的盒子。这在下图的二维空间中进行了说明，其中的数据结构称为四叉树。四叉树是二维的八叉树，第三个轴被忽略。在沿着三个轴对数据进行分类没有什么好处的情况下，它们可能很有用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105131314.png" class="" title="image-20211105131314">

<p>四叉树的构造。构造从左侧开始，将所有对象包围在一个包围框中。然后，这些盒子被递归地分成四个大小相同的盒子，直到每个盒子(在本例中)是空的或包含一个对象。</p>
<p><strong>八叉树可以以与轴对齐的BSP树相同的方式使用，因此可以处理相同类型的查询。事实上，BSP树可以给出与八叉树相同的空间分区。如果第一个细胞分裂的中间,说,x轴,然后两个孩子沿中间分割、说,y,最后那些孩子被划分在中间沿z, 8个大小相同的细胞形成的一样由一个应用程序是一个八叉树分裂。八叉树的一个效率来源是它不需要存储更灵活的BSP树结构所需要的信息。例如，分裂平面的位置是已知的，因此不必明确地描述。这种更紧凑的存储方案还通过在遍历期间访问更少的内存位置来节省时间。轴对齐的BSP树仍然更有效，因为获取分裂平面位置所需的额外内存成本和遍历时间可以被更好的平面放置所节省的成本所抵消。没有全面的最佳效率方案;它取决于底层几何结构的性质、结构如何被访问的使用模式，以及运行代码的硬件体系结构，等等。通常，内存布局的缓存友好性的位置和级别是最重要的因素。这是下一节的重点。</strong></p>
<p><strong>在上面的描述中，对象总是存储在叶节点中。因此，某些对象必须存储在多个叶节点中。另一种选择是将对象放置在包含整个对象的最小方框中。例如，图中的星形对象应该放在左边第二个插图的右上方的框中。这有一个明显的缺点，例如，位于八叉树中心的(小)对象将被放置在最上面(最大)的节点中。这是不有效的，因为一个微小的物体被包围在包围整个场景的盒子里。一种解决方案是拆分对象，但这会引入更多的原语。另一种方法是在对象所在的每个叶框中放置一个指向对象的指针，这样会降低效率，并使八叉树编辑更加困难。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105131438.png" class="" title="image-20211105131438">

<p>普通八叉树与松散八叉树的比较。圆点表示框的中心点(在第一个细分中)。在左边，恒星穿过普通八叉树的一个分裂平面。因此，一种选择是把星星放在最大的方框中(根的方框)。右边显示的是k = 1.5的松散八叉树(即盒子大50%)。这些盒子稍微移位了一下，这样就能被认出来。星星现在可以完全放置在左上方的红色方框中。</p>
<p><strong>Ulrich提出了第三种解决方案，松散八叉树。松散八叉树的基本思想与普通八叉树相同，但每个盒子大小的选择是宽松的。如果一个普通盒子的边长是l，那么用kl代替，其中k &gt; 1。上图展示了k = 1.5时的情况，并与普通八叉树进行了比较。注意，盒子的中心点是相同的。通过使用更大的方框，穿过分裂平面的对象的数量就减少了，这样对象就可以被放置在八叉树的更深处。一个对象总是只被插入到一个八叉树节点中，因此从八叉树中删除是很简单的。使用k = 2会产生一些好处。首先，插入和删除对象是O(1)。知道对象的大小意味着立即知道它可以成功插入的八叉树的级别，完全适合于一个松散的盒子。在实践中，有时可以将对象推到八叉树中更深的方框中。同样，如果k &lt; 2，如果对象不适合树，那么它可能不得不向上推。</strong></p>
<p><strong>对象的质心决定了它被放入哪个松散的八叉树盒中。由于这些特性，这种结构很适合绑定动态对象，但会牺牲一些BV效率，并在遍历结构时失去强排序顺序。此外，物体通常只是在帧与帧之间轻微移动，因此前一个盒子在下一帧仍然有效。因此，只有一小部分动画松散八叉树中的对象需要更新每一帧。Cozzi指出，在将每个对象/原语分配给松八叉树后，可以围绕每个节点中的对象计算一个最小的AABB，在那一点上它本质上成为一个BVH。这种方法避免了跨节点分割对象。</strong></p>
<h3 id="Cache-Oblivious-and-Cache-Aware-Representations-支持缓存和缓存无关表示"><a href="#Cache-Oblivious-and-Cache-Aware-Representations-支持缓存和缓存无关表示" class="headerlink" title="Cache-Oblivious and Cache-Aware Representations 支持缓存和缓存无关表示"></a>Cache-Oblivious and Cache-Aware Representations 支持缓存和缓存无关表示</h3><p><strong>由于内存系统的带宽和CPU的计算能力之间的差距每年都在增加，因此在设计算法和空间数据结构表示时考虑缓存是至关重要的。在这一节中，我们将介绍缓存敏感(或缓存敏感)和缓存无关的空间数据结构。感知缓存的表示假设缓存块的大小是已知的，因此我们针对特定的体系结构进行优化。相反，缓参无关算法被设计用于所有类型的缓参大小，因此是平台无关的。</strong></p>
<p><strong>要创建支持缓存的数据结构，您必须首先确定您的体系结构的缓存块的大小。例如，这可能是64字节。然后尽量减少数据结构的大小。例如，Ericson展示了k-d树节点仅使用32位就足够了。这部分是通过占用节点的32位值的两个最低有效位来实现的。这2位可以表示4种类型:叶节点，或者在三个轴之一上分裂的内部节点。对于叶节点，上30位包含一个指向对象列表的指针;对于内部节点，这些表示一个(精度稍低的)浮点分割值。因此，在一个64字节的缓存块中存储一个有15个节点的四层深度二叉树是可能的。第16个节点表示存在哪些子节点以及它们所在的位置。详情请参阅他的书。关键的概念是，通过确保结构整洁地打包到缓存边界，数据访问得到了相当大的改进。</strong></p>
<p><strong>一种流行且简单的对树的缓存无关排序是van Emde Boas布局。假设我们有一棵高度为h的树T，目标是计算树中节点的缓参无关布局或顺序。关键思想是，通过递归地将一个层次结构分解成越来越小的块，在某种程度上，一组块将适合缓存。这些块在树中彼此靠近，因此缓存数据的有效时间将比我们简单地从顶层向下列出所有节点的时间更长。这样的简单清单会导致内存位置之间的大跳转。</strong></p>
<p><strong>我们将T的van Emde Boas布局表示为v(T)。这种结构是递归定义的，树中单个节点的布局就是节点本身。如果T中有一个以上的节点，那么树的高度就会减半，数组元素的值就会减半，⌊h/2⌋ 。数组元素中最顶层的⌊h/2⌋ 值被放在一个表示T0的树中，以及从T0 的叶节点开始的子树是T1，…Tn．树的递归性质被描述为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105132152.png" class="" title="image-20211105132152">

<p><strong>请注意，所有子树Ti, 0 ≤ i≤ n、 也由上面的递归定义。这意味着，例如，T1必须在其高度的一半处拆分，以此类推。下图为示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105132244.png" class="" title="image-20211105132244">

<p>树T的van Emde Boas布局是通过拆分树的高度h创建的一分为二这将创建子树T0，T1，…,Tn，每个子树在同一个树中递归拆分直到每个子树只剩下一个节点为止。</p>
<p><strong>一般来说，创建缓存无关布局包括两个步骤：集群和簇的排序。对于van Emde Boas布局，集群如下所示：子树和顺序隐含在创建顺序中。Yoon等人开发专门为有效包围体积而设计的技术层次结构和BSP树。他们开发了一个概率模型，该模型考虑了父对象与其子对象之间的位置以及空间位置。想法是通过确保孩子们很容易接触到。此外，相互靠近的节点是按顺序更紧密地分组。提出了一种贪婪集群算法具有最高概率的节点。性能得到了大幅提高在不改变底层算法的情况下，它只不过是网络中节点的顺序BVH，是不同的。</strong></p>
<h3 id="Scene-Graphs-场景图"><a href="#Scene-Graphs-场景图" class="headerlink" title="Scene Graphs 场景图"></a>Scene Graphs 场景图</h3><p><strong>BVHs、BSP树和八叉树都使用某种树作为其基本数据结构。信息技术关键在于它们如何划分空间并存储不同的几何体。他们也以分层方式存储几何对象，而不是其他对象。然而，渲染三维场景不仅仅是几何图形。控制动画、可见性和其他元素的显示通常使用场景图执行，在glTF中称为节点层次结构。这是一个面向用户的树结构增加了纹理、变换、细节级别、渲染状态（例如材质本身、领带）、光源以及其他任何合适的内容。它是代表通过一棵树，并以某种顺序遍历该树以渲染场景。例如光源可以放在内部节点上，这只影响其内部节点的内容子树。另一个示例是在树中遇到材质时。材料可以应用于该节点子树中的所有几何图形，也可以由孩子的环境。另请参见第861页图19.34，了解不同的详细程度可以在场景图中支持。从某种意义上说，每个图形应用程序都使用一些形式的场景图，即使图只是一个根节点和一列要显示的子节点。</strong></p>
<p><strong>动画对象的一种方法是改变树中的内部节点的转换。场景图实现然后转换该节点的子树的全部内容。由于转换可以放在任何内部节点中，所以可以进行分层动画。例如，汽车的轮子可以旋转，汽车作为一个整体可以向前移动。</strong></p>
<p><strong>当多个节点指向同一个子节点时，这种树结构称为有向无环图(DAG)。非循环的意思是它不能包含任何循环或循环。有向的意思是，当两个节点由一条边连接时，它们也按照一定的顺序连接，例如从父节点到子节点。场景图通常是DAGs，因为它们允许实例化。，当我们想要复制一个对象的多个副本(实例)而不复制其几何形状时。下图显示了一个示例，其中两个内部节点对它们的子树应用了不同的转换。使用实例可以节省内存，GPU可以通过API调用快速渲染一个实例的多个副本(章节18.4.2)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105132811.png" class="" title="image-20211105132811">

<p>将不同变换M和N应用于内部节点及其各自的子树的场景图。注意，这两个内部节点也指向相同的对象，但由于它们进行了不同的转换，因此出现了两个不同的对象(其中一个是旋转和缩放的)。</p>
<p><strong>当物体在场景中移动时，场景图必须更新。这可以通过对树结构的递归调用来实现。变换在从根到叶的过程中被更新。矩阵在此遍历中相乘并存储在相关节点中。但是，当转换被更新时，任何附加的BVs都是过时的。因此，BVs在从叶向根返回的过程中被更新。过于松散的树形结构使这些任务变得非常复杂，所以通常会避免使用DAGs，或者使用有限形式的DAGs，其中只共享叶节点。有关这个主题的更多信息，请参阅Eberly的书。还需要注意的是，当使用基于JavaScript的APIs(如WebGL)时，将尽可能多的工作转移到GPU，而尽可能少的反馈给CPU是非常重要的。</strong></p>
<p><strong>场景图本身可以提供一些计算效率。场景图中的节点通常都有一个包围体积，因此非常类似于BVH。场景图中的叶子存储几何图形。重要的是要认识到，完全无关的效率方案可以与一个场景图一起使用。这就是空间化的思想，在这种思想中，用户的场景图被一个单独的数据结构(例如，BSP树或BVH)扩充，为不同的任务创建，如更快的挑选或挑选。大多数模型所在的叶节点是共享的，因此额外的空间效率结构的成本相对较低。</strong></p>
<h2 id="Culling-Techniques-剔除技术"><a href="#Culling-Techniques-剔除技术" class="headerlink" title="Culling Techniques 剔除技术"></a>Culling Techniques 剔除技术</h2><p><strong>cull的意思是“从鸟群中移除”，在计算机图形学中，这正是cull技术的作用。鸟群是我们想要渲染的整个场景，而移除仅限于那些被认为对最终图像没有贡献的场景部分。场景的其余部分通过渲染管道发送。因此，术语“可见性剔除”也经常用于渲染上下文中。然而，筛选也可以用于程序的其他部分。例子包括碰撞检测(通过对屏幕外或隐藏物体进行较不精确的计算)，物理计算和AI。这里只介绍与渲染相关的裁剪技术。这些技术的例子有背面剔除、视图截锥剔除和遮挡剔除。如下图所示。背面剔除消除了面对观众的三角形。视图截锥剔除视图截锥外的一组三角形。遮挡剔除剔除被一组其他对象隐藏的对象。这是最复杂的剔除技术，因为它需要计算对象如何相互影响。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105133207.png" class="" title="image-20211105133207">

<p>不同的筛选技术。剔除的几何图形是虚线。(参见Cohen-Or等人的插图。)</p>
<p><strong>实际的剔除理论上可以发生在渲染管道的任何阶段，对于一些遮挡剔除算法，它甚至可以预先计算。对于GPU上实现的剔除算法，我们有时只能禁用/禁用或设置一些参数，剔除功能。最快的三角形渲染是从未发送到GPU的。其次，管道筛选越早发生越好。剔除通常是通过使用几何计算来实现的，但绝不仅限于这些。例如，算法也可以使用帧缓冲区的内容。</strong></p>
<p><strong>理想的剔除算法将只通过管线发送准确的可见集合(EVS)的原语。在本书中，EVS被定义为所有部分或完全可见的原语。允许理想剔除的数据结构之一是方面图，在给定任何观点的情况下，都可以从中提取EVS。创建这样的数据结构在理论上是可能的，但在实践中是不可能的，因为最坏时间的复杂性可能与O(n⁹)一样糟糕。相反，实用的算法试图找到一个集合，称为潜在可见集(PVS)，这是对EVS的预测。如果PVS完全包含EVS，只丢弃不可见的几何形状，则PVS被称为保守型。一个PVS也可能是近似的，其中没有完全包括电动汽车。因此，这种类型的PVS可能生成不正确的图像。目标是让这些错误越小越好。由于保守的PVS总是生成正确的图像，所以通常认为它更有用。通过过高估计或接近EVS，其想法是PVS可以更快地计算。难点在于如何进行这些估计以获得总体性能。例如，一个算法可以处理不同粒度的几何图形，例如。三角形、整体或一组物体。当找到一个PVS时，它将使用z缓冲区进行渲染，这将解析最终的逐像素可见性。</strong></p>
<p><strong>请注意，有一些算法可以重新排序网格中的三角形，以提供更好的遮挡剔除，即减少了透支，同时改进了顶点缓存局部性。虽然这些都与淘汰有一定的关系，但我们将感兴趣的读者参考参考文献。</strong></p>
<p><strong>在19.3-19.8节中，我们处理了背面剔除、视图截锥剔除、门户剔除、细节剔除、遮挡剔除和剔除系统。</strong></p>
<h2 id="Backface-Culling-背面剔除"><a href="#Backface-Culling-背面剔除" class="headerlink" title="Backface Culling 背面剔除"></a>Backface Culling 背面剔除</h2><p><strong>假设你正在一个场景中观察一个不透明的球体。球体的大约一半是看不见的。从这个观察得出的结论是，不可见的东西不需要被渲染，因为它对图像没有贡献。因此，球体的背面不需要处理，这就是背面剔除的思想。这种类型的剔除也可以一次对整个组进行，因此被称为集群背面剔除。</strong></p>
<p><strong>假设相机在外部，并且没有穿透，如果相机是透明物体的一部分，那么所有的背面三角形都可以从进一步的处理中剔除(例如，近夹入)，对象。如果已知投影三角形在屏幕空间中是顺时针方向的，则一个一致方向的三角形(第16.3节)是背向的。这个测试可以通过计算二维屏幕空间中三角形的带符号的面积来实现。带负号的面积表示三角形应该被剔除。这可以在屏幕映射过程发生后立即执行。</strong></p>
<p><strong>另一种确定三角形是否面向背面的方法是创建一个向量，从三角形所在平面上的任意点(其中一个顶点是最简单的选择)到观察者的位置。对于正投影，眼睛位置的矢量被替换为负视图方向，这对于场景是恒定的。计算这个向量和三角形的法向量的点积。负的点积意味着两个向量之间的夹角大于π/2弧度，所以三角形不是面向观众的。这个测试等价于计算从观察者的位置到三角形平面的标记距离。如果符号是正的，三角形是正面的。注意，距离只有在法线被标准化的情况下才能获得，但在这里这并不重要，因为只有符号才是我们感兴趣的。或者，在应用了投影矩阵之后，将顶点ˉv = (vx, vy, vw)，并计算行列式d = |ˉv0, ˉv1, ˉv2|。如果d≤0，则可以剔除三角形。这些剔除技术如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105134214.png" class="" title="image-20211105134214">

<p>确定三角形是否背朝的两个不同的测试。左图显示了测试是如何在屏幕空间中完成的。左边的两个三角形是正面的，右边的三角形是背面的，可以省略。右图显示了如何在视图空间中完成背面测试。三角形A和B是正面的，而C是背面的。</p>
<p><strong>Blinn指出，这两种测试在几何上是相同的。理论上，区分这些测试的是计算测试的空间，而不是其他。在实践中，屏幕空间测试通常更安全，因为在视图空间中看起来稍微向后的边三角形在屏幕空间中可能会稍微向前。这是因为视图空间坐标四舍五入到屏幕空间亚像素坐标。</strong></p>
<p><strong>使用诸如OpenGL或DirectX之类的API，背面剔除通常通过一些功能来控制，这些功能要么启用背面剔除，要么启用正面剔除，要么禁用所有剔除。请注意，镜像转换(即一种负缩放操作)将面向后的三角形变成面向前的三角形，反之亦然(第4.1.3节)。最后，可以在像素着色器中找出一个三角形是否正对。在OpenGL中，这是通过测试gl_FrontFacing来完成的，在DirectX中它被称为SV_IsFrontFace。在此之前，主要方式显示双面对象正确的做法是将它们渲染两次，首先剔除背面，然后剔除正面，并反转法线。</strong></p>
<p><strong>关于标准背面剔除的一个常见误解是，它减少了大约一半的三角形渲染的数量。虽然背面剔除将移除许多物体中大约一半的三角形，但它将为某些类型的模型提供很少的增益。例如，室内场景的墙壁、地板和天花板通常是面向观众的，所以在这些场景中，这些类型的背面相对较少。类似地，在地形渲染中，大多数三角形都是可见的，只有那些在山或峡谷的背面的三角形受益于这种技术。</strong></p>
<p><strong>虽然背面剔除是一种避免对单个三角形进行栅格化的简单技术，但如果可以通过一个测试来决定是否可以剔除整个三角形集合，那么它将会更快。这些技术被称为集群背面剔除算法，我们将在这里回顾其中的一些。许多这样的算法使用的基本概念是法向锥。对于曲面的某些部分，创建一个截锥，它包含所有的法线方向和所有的点。注意，沿着法线的两段距离需要截断圆锥体。参见下图中的示例。可以看出，圆锥是由法线n和半角α和锚点c以及沿法线截断圆锥的一些偏移距离定义的。在下图的右侧，一个法向锥的横截面被显示出来。Shirman和Abi-Ezzi证明，如果观察者位于前面向锥体，那么锥体中的所有面都是前面向的，后面向锥体也是如此。Engel使用了一个类似的概念，称为GPU剔除的排除体积。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105134531.png" class="" title="image-20211105134531">

<p>左:一组三角形及其法线。左中:法线被收集(上)，最小锥(下)，由一个法线n定义，半角α，被构造。中右:圆锥被锚定在点c上，并被截断，以便它也包含三角形上的所有点。右图:截去的圆锥的横截面。顶部的浅灰色区域为前视锥，底部的浅灰色区域为后视锥。点f和点b分别是前锥和后锥的顶点。</p>
<p><strong>对于静态网格，Haar和Aaltonen建议在n个三角形周围计算一个最小的立方体，每个立方体面被分割成r ×r“像素”，每个编码一个n位掩码，表示相应的三角形是否在其上可见“像素。下图说明了这一点。如果相机在立方体外面，就可以找到相机所在的相应截锥，并且可以立即查找它的位掩码并知道哪些三角形是背向的(保守地)。如果摄像机在立方体内部，所有三角形都被认为是可见的(除非有人想要执行进一步的计算)。Haar和altonen在每个立方体面只使用一个位掩码，一次编码n = 64个三角形。通过计算位掩码中设置的比特数，可以有效地为未剔除的三角形分配内存。《刺客信条:大革命》也使用了这种方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105134719.png" class="" title="image-20211105134719">

<p>一组五个静态三角形，从边缘上看，被二维的正方形包围着。左边的方形面被分割成4个“像素”，我们关注从顶部开始的一秒，它在盒子外面的截锥被涂成蓝色。三角形平面形成的正半空间用一个半圆(红色和绿色)表示。所有三角形在其正半空间中没有蓝色截锥的任何部分，都从截锥的所有点保守地向后(标记为红色)。绿色表示那些正面的。</p>
<p><strong>接下来，我们将使用一个未截断的法锥，与上上图中的一个相反，因此它仅由中心点c、法向n和角度α定义。要计算这样一个由多个三角形组成的法锥，取三角形平面的所有法线，将它们放在相同的位置，在包含所有法线的单位球面上计算一个最小圆。作为第一步，假设从点e开始，我们要测试圆锥中共享原点c的所有法线。如果下列条件成立:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105134827.png" class="" title="image-20211105134827">

<p><strong>所有的几何图形都在一个圆心为c，半径为r的球体内，然而，这个测试只在所有几何图形位于c的情况下有效</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105134915.png" class="" title="image-20211105134915">

<p><strong>其中sin β = r/||c−e||。推导这个测试所涉及的几何图形如下图所示。量子化的法线可以存储在8 × 4位，这对于某些应用可能已经足够了。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105134947.png" class="" title="image-20211105134947">

<p>这种情况显示了限制正常的锥时,定义为c, n,α,只是将成为可见e从最关键的点在圆半径和中心c点。这发生在e点的向量之间的夹角等圆,圆的切线向量,法锥的边是π/2弧度。注意，法锥已经从c向下平移，所以它的原点与球面边界重合。</p>
<p><strong>最后，我们注意到，对于运动模糊三角形(每个顶点在一帧上都有一个线性运动)的后端面剔除并不像人们想象的那么简单。一个顶点随时间线性移动的三角形可以在一帧开始时向后转，然后再向后转，所有这些都在同一帧内。因此，如果在帧的开始和结束时由于运动模糊的三角形背向而剔除三角形，将会产生不正确的结果。Munkberg和Akenine-M¨oller提出了一种将标准后端面测试中的顶点替换为线性移动三角形顶点的方法。将检验重写为Bernstein形式，并利用B´ezier曲线的凸性作为保守检验。对于景深，如果整个镜头在三角形的负半空间(换句话说，在它后面)，三角形可以被安全地剔除。</strong></p>
<h2 id="View-Frustum-Culling-视锥剔除"><a href="#View-Frustum-Culling-视锥剔除" class="headerlink" title="View Frustum Culling 视锥剔除"></a>View Frustum Culling 视锥剔除</h2><p><strong>正如在第2.3.3节中看到的，只有完全或部分位于视图截屏内的原语需要被渲染。加速渲染过程的一种方法是将每个对象的边界体积与视图截锥进行比较。如果BV在截锥外，那么它所包含的几何图形可以从渲染中省略。如果BV在截锥内部或与截锥相交，那么BV的内容可能是可见的，必须通过渲染管道发送。参见第22.14节，了解各种边界体与视图截锥之间交集的测试方法。</strong></p>
<p><strong>通过使用空间数据结构，这种选择可以分层应用。对于一个包围体层次，从根开始的预定遍历是否工作。每个具有包围体的节点都在截锥上进行测试。如果节点的BV在截锥外，则该节点不会被进一步处理。树被修剪了，因为BV的内容和子节点都在视图之外。如果BV完全在截锥内部，它的内容必须全部在截锥内部。遍历还在继续，但是对于这个子树的其余部分不需要进一步的截锥测试。如果BV与截锥相交，则遍历将继续进行，并对其子节点进行测试。当一个叶节点被发现相交时，它的内容(即它的几何形状)通过管线发送。叶子的原语不能保证在视图截锥内。视图截锥裁剪的一个例子如下图所示。也可以对一个对象或单元格使用多个BV测试。例如，如果发现单元周围的球体BV与截锥重叠，如果已知这个立方体比球体小得多，则可能值得执行更精确(尽管更昂贵)的OBB截锥测试。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105201316.png" class="" title="image-20211105201316">

<p>一组几何体和它的边界体(球体)显示在左边。这个场景是通过从眼睛的角度剔除视图截锥来渲染的。右侧显示BVH。根的BV与截锥相交，遍历过程继续测试其子的BV。左子树的BV与之相交，并且该子树的一个子树与之相交(因此被渲染)，而另一个子树的BV在外部，因此不会通过管线发送。根的中间子树的BV完全在内部，并立即呈现。根的右子树的BV也完全在里面，因此整个子树不需要进一步的测试就可以渲染。</p>
<p><strong>对于“相交截锥”情况，一个有用的优化方法是跟踪BV完全位于哪个截锥平面内。该信息通常存储为位掩码，然后可以通过交点来测试该BV的子节点。这种技术有时被称为平面掩蔽，因为只有那些与BV相交的平面需要对儿童进行测试。根BV最初将针对所有6个截锥平面进行测试，但随着连续的测试，每个孩子所做的平面/BV测试的数量将下降。Assarsson和M¨oller注意到时间一致性可以也被使用。拒绝BV的截锥平面可以与BV存储在一起，然后在下一帧中作为第一个拒绝测试的平面。Wihlidal指出，如果在CPU上对每个对象进行视图截锥剔除，那么当在GPU上进行更细粒度的剔除时，对左、右、下和上平面执行视图截锥剔除就足够了。此外，为了提高性能，可以使用顶点映射的构造来提供更紧密的边界体积。这在22.13.4节中有更详细的描述。有时在远处使用雾是为了避免物体突然在远处的平面上消失的影响。</strong></p>
<p><strong>对于大型场景或特定的摄像机视图，只有场景的一小部分可能是可见的，而且只有这个部分需要通过渲染管道发送。在这种情况下，速度有望大幅提高。视图截锥裁剪技术利用了场景中的空间相干性，因为彼此靠近的对象可以被包围在一个BV中，而附近的BV可以分层集群。</strong></p>
<p><strong>需要注意的是，有些游戏引擎并不使用分层BVs，而是使用线性BVs列表，每个BVs对应场景中的每个对象。主要的动机是使用SIMD和多线程更容易实现算法，从而提供更好的性能。然而，对于一些应用程序，如CAD，大多数或所有的几何是在截锥内，在这种情况下，应该避免使用这些类型的算法。层次视图截锥裁剪仍然可以应用，因为如果一个节点在截锥内部，它的几何形状可以立即绘制出来。</strong></p>
<h2 id="Portal-Culling-门户剔除"><a href="#Portal-Culling-门户剔除" class="headerlink" title="Portal Culling 门户剔除"></a>Portal Culling 门户剔除</h2><p><strong>对于体系结构模型，有一组称为门户筛选的算法。第一个是由Airey等人介绍的。后来，Teller和S´equin以及Teller和Hanrahan构建了更高效、更复杂的门户筛选算法。所有门户剔除算法的基本原理是墙壁通常在室内场景中充当大型遮挡物。因此，门户剔除是一种遮挡剔除，将在下一节中讨论。这种遮挡算法通过每个入口(如门或窗)使用一个视图截锥剔除机制。当横越门脉时，截锥缩小以紧贴门脉。因此，该算法也可以看作是视图截锥剔除的一种扩展。视图截锥外的门户被丢弃。</strong></p>
<p><strong>门户筛选方法以某种方式对场景进行预处理。场景被划分为若干个单元，通常与建筑中的房间和走廊相对应。连接相邻房间的门窗称为门户。单元格中的每个对象和单元格的壁都存储在与单元格相关联的数据结构中。我们还在邻接图中存储关于相邻单元和连接它们的门户的信息。Teller给出了计算这张图的算法。虽然这项技术在1992年被引入时就已经开始工作了，但对于现代复杂的场景来说，自动化过程是极其困难的。因此，定义单元格和创建图形目前都是手工完成的。</strong></p>
<p><strong>Luebke和Georges使用一种简单的方法，只需要少量的预处理。所需要的唯一信息是与每个单元相关联的数据结构，如上所述。关键思想是，每个门户都定义了进入其房间内外的视图。想象一下，你正从一扇门往一个有三扇窗户的房间里看。门道定义了一个截锥，你可以用它来剔除房间中不可见的对象，然后渲染那些可以看到的对象。你无法通过门口看到两扇窗户，所以通过这些窗户可以看到的细胞可以被忽略。第三扇窗户可以看到，但部分被门框挡住了。只有通过通道和窗口可见的单元格中的内容需要通过管道发送。单元格呈现过程依赖于以递归的方式跟踪这种可见性。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105201728.png" class="" title="image-20211105201728">

<p>门户剔除:从A到H枚举单元，门户是连接单元的开口。只有通过入口看到的几何图形被渲染。例如，F单元格中的星号被剔除。</p>
<p><strong>上图给出了一个示例，说明了门户剔除算法。观察者或眼睛位于单元格E，因此与它的内容一起呈现。邻近的细胞是C、D和F。原始截体无法看到细胞D的入口，因此在进一步处理中省略了。单元格F是可见的，因此视图截屏被缩小，以便它通过连接到F的门户。F的内容随后用缩小的截屏呈现。然后，检查F的邻近细胞——从缩小的截锥看不到G，因此省略，而H是可见的。同样，截锥随着H的入口而缩小，然后呈现H的内容。H没有没有被访问过的邻居，所以遍历到这里就结束了。现在，递归返回到单元C的门户。截锥被缩小以适应C的门户，然后在C中渲染对象，使用截锥剔除。没有更多的门户是可见的，所以呈现完成了。</strong></p>
<p><strong>每个对象在呈现后都可以被标记，以避免多次呈现对象。例如，如果一个房间有两扇窗户，里面的东西房间的各个部分分别针对每个截锥进行裁剪。如果没有标记，一个物体可以通过两个窗口看到，那么它将被渲染两次。这不仅效率低下，还会导致呈现错误，比如当对象是透明的时候。为了避免必须清除每个帧的标签列表，每个对象在访问时都被标记为帧号。只有存储当前帧号的对象已经被访问过。</strong></p>
<p><strong>一个值得实现的优化是使用模板缓冲区进行更精确的筛选。在实践中，门户被高估了AABB;真正的门户很可能会更小。模板缓冲区可用于屏蔽真实门户之外的呈现。类似地，可以为GPU设置一个围绕门户的剪接矩形，以提高性能。使用模板和剪刀功能还避免了执行标记的需要，因为透明对象可能被渲染两次，但只会影响每个门户中的可见像素一次。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105201935.png" class="" title="image-20211105201935">

<p>门户剔除。左图是布鲁克斯住宅的俯视图。右边的图片是从主卧看到的。传送门的筛选框是白色的，镜子是红色的。(图片由北卡罗来纳大学教堂山分校的David Luebke和Chris Georges提供。)</p>
<p><strong>有关门户使用的另一个视图，请参见上图。这种形式的门脉剔除也可以用于平面反射的内容修剪(第11.6.2节)。左边的图片显示了从顶部看到的一座建筑;白线表示截锥随每个门而缩小的方式。红线是通过在镜子上反射锥体而产生的。实际视图显示在右边的图像中，白色的矩形是入口，镜子是红色的。注意，渲染的只是视锥体内部的对象。其他转换可以用来创建其他效果，比如简单的折射。</strong></p>
<h2 id="Detail-and-Small-Triangle-Culling-细节和小三角形剔除"><a href="#Detail-and-Small-Triangle-Culling-细节和小三角形剔除" class="headerlink" title="Detail and Small Triangle Culling 细节和小三角形剔除"></a>Detail and Small Triangle Culling 细节和小三角形剔除</h2><p><strong>细节剔除是一种为了速度而牺牲质量的技术。细节剔除的基本原理是场景中的小细节对渲染效果的贡献很小当观众在运动时的图像。当查看器停止时，细节剔除通常被禁用。考虑一个有边界体的物体，并将这个BV投影到投影平面上。然后以像素估计投影的面积，如果像素的数量低于用户定义的阈值，则该对象将从进一步处理中省略。由于这个原因，细节剔除有时被称为屏幕大小剔除。细节剔除也可以在场景图上分层进行。这些类型的技术通常用于游戏引擎。</strong></p>
<p><strong>在每个像素的中心有一个样本，小三角形很可能落在样本之间。此外，小三角形的栅格化效率很低。一些图形硬件实际上会剔除落在样本之间的三角形，但当使用GPU上的代码进行剔除时(章节19.8)，添加一些代码来剔除小三角形可能是有益的。Wihlidal提出了一种简单的方法，首先计算三角形的AABB。如果以下条件成立，三角形可以在着色器中被剔除:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105202249.png" class="" title="image-20211105202249">

<p><strong>其中min和max表示三角形周围的二维AABB。如果任意一个向量分量为真，函数any将返回真。还记得像素中心位于(x+0.5, y +0.5)，这意味着如果x坐标或y坐标或两者都四舍五入到相同的坐标，则上式为真。下图显示了一些示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105202304.png" class="" title="image-20211105202304">

<p>小三角形剔除使用any(round(min) == round(max))。红色三角形被剔除，而绿色三角形需要渲染。左:绿色三角形与样本重叠，不能剔除。红色三角形都围绕所有AABB坐标到相同的像素角。右:红色三角形可以被剔除，因为AABB坐标中的一个被舍入为相同的整数。绿色三角形没有重叠任何样本，但不能被此测试剔除。</p>
<h2 id="Occlusion-Culling-遮挡剔除"><a href="#Occlusion-Culling-遮挡剔除" class="headerlink" title="Occlusion Culling 遮挡剔除"></a>Occlusion Culling 遮挡剔除</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105202704.png" class="" title="image-20211105202704">

<p>说明遮挡剔除是如何有用的。10个球体被放置在一条直线上，观察者沿着这条直线(左)用透视法观察。中间的深度复杂度图像显示一些像素被写入了几次，尽管最终图像(在右边)只显示了一个球体。</p>
<p><strong>正如我们所看到的，可见性可以通过z缓冲区来解决。尽管它正确地解决了可见性问题，但是z-buffer是相对简单和暴力的，所以并不总是如此最有效的解决方案。例如，想象观众沿着一条有10个球体的线看。如上图所示。从这个视角渲染的图像将只显示一个球体，即使所有10个球体将被栅格化并与z缓冲区进行比较，然后可能写入颜色缓冲区和z缓冲区。上图的中间部分显示了这个场景在给定视角下的深度复杂性。深度复杂性是指一个像素所覆盖的表面的数量。在10个球体的情况下，由于所有10个球体都位于那里，假设进行了背面剔除，所以中间的像素的深度复杂度为10。如果场景由后向前渲染，中间的像素将被像素阴影10倍，即有9个不必要的像素着色执行。即使场景是由前到后渲染，所有10个球体的三角形仍然会被栅格化，深度将被计算，并与z缓冲区中的深度进行比较，即使只生成了一个球体的图像。这种无趣的场景不太可能在现实中找到，但它(从给定的观点)描述了一个人口稠密的模型。这些类型的配置在真实场景中都能找到，比如雨林、引擎、城市和摩天大楼的内部。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105202813.png" class="" title="image-20211105202813">

<p>一个名为Neu Rungholt的《我的世界》场景，通过遮挡剔除显示了观众位于右下角的位置。轻微着色的几何体被剔除，而较暗的被渲染。最后的图像显示在左下角。(转载由Jon Hasselgren, Magnus Andersson和Tomas Akenine-M¨oller和英特尔公司许可，版权为英特尔公司，2016年。Neu Rungholt地图由kescha提供。)</p>
<p><strong>鉴于前面的例子，一种避免这种效率低下的算法方法可能会在性能上获得回报，这似乎是合理的。这种方法被称为遮挡剔除算法，因为它们试图剔除被遮挡的对象，即被场景中其他对象隐藏的对象。最优的遮挡剔除算法将只选择可见的对象。从某种意义上说，z-buffer只选择和渲染那些可见的对象，但并非没有通过大部分管道发送视图截屏内的所有对象。高效遮挡剔除算法背后的思想是在早期执行一些简单的测试来剔除隐藏对象集。在某种意义上，背面剔除是遮挡剔除的一种简单形式。如果我们提前知道一个对象是固体和不透明的，那么背面被正面遮挡，因此不需要渲染。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105202951.png" class="" title="image-20211105202951">

<p>左图显示了基于点的可见性，而右图显示了基于单元格的可见性，其中单元格是一个框。可以看到，从视点左侧的圆圈被遮挡。然而，在右边，圆圈是可见的，因为光线可以从细胞内的某个地方绘制到圆圈，而不与任何遮挡器相交。</p>
<p><strong>遮挡剔除算法主要有两种形式，即基于点的和基于单元的。如上图所示。基于点的可见性只是在渲染中通常使用的，也就是说，从单个视图位置看到的内容。另一方面，基于单元格的可见性是针对单元格进行的，单元格是包含一组观察位置的空间区域，通常是一个盒子或一个球体。基于单元格可见性的不可见对象必须从单元格内的所有点都不可见。的优势基于单元格的可见性是，一旦为单元格计算了它，它通常可以用于几个帧，只要查看器在单元格内。然而，与基于点的可见性相比，计算它通常要花费更多的时间。因此，它通常作为预处理步骤进行。基于点和基于单元的可见性在本质上与点和区域光源相似，在这些光源中，光可以被认为是观看场景。对于一个看不见的物体，这相当于它在本影区，即完全处于阴影之中。</strong></p>
<p><strong>人们还可以将遮挡剔除算法分类为在图像空间、对象空间或光线空间中操作的算法。图像空间算法在经过一些投影后进行二维可见性测试，而物体空间算法则使用原始的三维物体。射线空间方法在双空间中进行测试。每个感兴趣的点，通常是二维的，在这个对偶空间中被转换成射线。对于实时图形，在三种算法中，图像空间遮挡剔除算法是应用最广泛的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105203102.png" class="" title="image-20211105203102">

<p>一个通用的遮挡剔除算法的伪代码。G包含场景中的所有物体，OR 为遮挡表示。P是一组电位闭塞体，合并到OR 当它包含足够多的对象时。</p>
<p><strong>一种类型的遮挡剔除算法的伪代码如上图所示，其中isOccluded函数，通常称为可见性测试，检查对象是否被遮挡。G是要渲染的几何对象集合，OR 是闭塞表示，P是一组潜在闭塞器，可以与OR．取决于特定的算法，OR 表示某种遮挡信息。OR 开始时设置为空。然后，处理所有对象(通过视图截锥剔除测试的对象)。</strong></p>
<p><strong>考虑一个特定的对象。首先，我们测试对象是否相对于遮挡表示OR．如果它被阻塞，那么它就不被处理此外，因为我们知道它不会对图像有贡献。如果不能确定物体被遮挡，那么该物体必须被渲染，因为它可能对图像有贡献(在渲染的那个点上)。然后将对象加入到P中，如果P中的对象数量足够大，则可以将这些对象的遮挡能力合并到OR中．因此，P中的每个对象都可以用作遮挡器。</strong></p>
<p><strong>注意，对于大多数遮挡剔除算法，性能取决于对象绘制的顺序。举个例子，考虑一辆里面装有马达的汽车。如果汽车的引擎盖是先拉的，那么发动机(可能)将被剔除。另一方面，如果电机是首先被拉，那么什么也不会被淘汰。按照粗略的从前到后的顺序排序和渲染可以获得相当大的性能增益。此外，值得注意的是，小物体可能是优秀的遮挡器，因为距离遮挡器决定了它可以遮挡多少。举个例子来说，如果观看者离火柴盒足够近，火柴盒就会挡住金门大桥。</strong></p>
<h3 id="Occlusion-Queries-遮挡查询"><a href="#Occlusion-Queries-遮挡查询" class="headerlink" title="Occlusion Queries 遮挡查询"></a>Occlusion Queries 遮挡查询</h3><p><strong>GPU通过使用一种特殊的渲染模式来支持遮挡剔除。用户可以查询GPU，以确定与z缓冲区的当前内容相比，一组三角形是否可见。三角形通常形成一个更复杂物体的包围体(例如，一个盒子或k-DOP)。如果这些三角形都不可见，那么对象就会被剔除。GPU对查询的三角形进行栅格化，并将它们的深度与z缓冲区进行比较。，它在图像空间中运行。生成了这些三角形可见的像素数n，尽管实际上没有修改像素或任何深度。如果n为零，则所有三角形被遮挡或剪切。</strong></p>
<p><strong>然而，计数为零不足以确定边界卷是否不可见。更准确地说，摄像机截锥的可见近平面的任何部分都不应该在包围体内。假设满足此条件，则整个包围体被完全遮挡，包含的对象可以安全地丢弃。如果n &gt; 0，则有一部分像素没有通过测试。如果n小于阈值像素数，则该对象可能会被丢弃，因为它对最终图像的贡献不大。通过这种方式，速度可以换取可能的质量损失。另一个用途是让n帮助确定对象的LOD(章节19.9)。如果n很小，那么对象(可能)可见的部分就更小，因此可以使用不太详细的LOD。</strong></p>
<p><strong>当发现包围体被遮挡时，我们通过避免通过渲染管道发送潜在的复杂对象来提高性能。然而，如果测试失败，我们实际上会损失一些性能，因为我们花了额外的时间测试这个边界卷，但没有任何好处。</strong></p>
<p><strong>这种测试有多种变体。出于筛选的目的，不需要可见片段的确切数量——只要一个布尔值表示是否至少就足够了一个片段通过了深度测试。OpenGL 3.3和DirectX 11以及之后的版本支持这种类型的遮挡查询ANY_SAMPLES_PASSED ，枚举为OpenGL中通过的任何样本。这些测试可以更快，因为它们可以在一个片段可见时终止查询。OpenGL 4.3及其后续版本还允许该查询的更快变体，称为ANY_SAMPLES_PASSED_CONSERVATIVE。实现可以选择提供一个不那么精确的测试，只要它是保守的，并且错误在正确的一边。例如，硬件供应商可以通过只对粗深度缓冲区(第23.7节)而不是逐像素深度执行深度测试来实现这一点。</strong></p>
<p><strong>查询的延迟通常是相对较长的时间。通常，数百或数千个三角形可以在这个时间内被渲染，参见第23.3节更多关于延迟的内容。因此，这种基于GPU的遮挡剔除方法是值得的，当包围盒包含大量的对象和相对大量的遮挡发生时。GPU使用一个闭塞查询模型，CPU可以向GPU发送任意数量的查询，然后它定期检查是否有可用的结果，也就是说，查询模型是异步的。GPU执行每个查询，并将结果放入队列中。CPU的队列检查非常快，CPU可以继续发送查询或实际的可渲染对象，而不必停止。DirectX和OpenGL都支持断言/条件闭塞查询，其中查询和对应的draw调用的ID都是同时提交的。只有当表明遮挡查询的几何形状是可见的时，对应的绘制调用才会由GPU自动处理。这使得模型更加有用。</strong></p>
<p><strong>一般来说，应该对最有可能被阻塞的对象执行查询。Koval ‘e´ık和Sochor在应用程序运行时，收集每个对象在多个帧上的查询的运行统计信息。一个物体被发现被隐藏的帧数会影响它在未来被测试遮挡的频率。也就是说，可见的对象可能会保持可见，因此可以较少地测试。如果可能，隐藏对象在每一帧都要进行测试，因为这些对象最有可能从遮挡查询中受益。Mattausch等人提出了几种不含谓词/条件渲染的遮挡查询(OCs)优化方法。他们使用批量OCs，将几个OCs组合成一个OC，使用几个边界框而不是一个更大的框，并使用临时抖动采样来调度先前可见的对象。</strong></p>
<p><strong>这里所讨论的方案给出了闭塞剔除方法的潜力和问题。什么时候使用遮挡查询，或者使用大多数遮挡方案，通常都不清楚。如果所有东西都是可见的，遮挡算法只会花费额外的时间，永远不要保存它。一个挑战是迅速确定算法没有帮助，因此减少徒劳的节省时间的尝试。另一个问题是决定使用什么对象集作为遮挡器。截屏内的第一个对象必须是可见的，所以在这些对象上花费查询是很浪费的。在大多数遮挡剔除算法中，决定渲染的顺序和何时测试遮挡都是一个难题。</strong></p>
<h3 id="Hierarchical-Z-Buffering-分层z缓冲"><a href="#Hierarchical-Z-Buffering-分层z缓冲" class="headerlink" title="Hierarchical Z-Buffering 分层z缓冲"></a>Hierarchical Z-Buffering 分层z缓冲</h3><p><strong>分层z缓冲(HZB)对遮挡剔除研究产生了重要影响。虽然原始的CPU端形式很少被使用，但该算法是GPU硬件方法z-剔除(章节23.7)和使用GPU或CPU上运行的软件进行自定义遮挡剔除的基础。我们首先描述基本算法，然后是如何在各种渲染引擎中采用这种技术。</strong></p>
<p><strong>该算法将场景模型保持在八叉树中，帧的z缓冲区作为图像金字塔，我们称之为z金字塔。因此，该算法在图像空间中操作。八叉树使场景中被遮挡区域的分级剔除成为可能，而z金字塔使原语的分级z缓冲成为可能。因此，z金字塔是该算法的遮挡表示。这些数据结构的示例如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105204339.png" class="" title="image-20211105204339">

<p>用HZB算法遮挡剔除的例子，显示了一个深度复杂度高的场景(右下)，对应的z-金字塔(左上)和八叉树细分(右上)。通过从前面到后面遍历八叉树并剔除遇到的被遮挡的八叉树节点，该算法只访问可见的八叉树节点及其子节点(右上角的节点)，并仅在可见框中呈现三角形。在这个例子中，剔除闭塞的八叉树节点将深度复杂度从84降低到2.5。</p>
<p><strong>z金字塔的最精细(最高分辨率)级别只是一个标准的z缓冲区。在所有其他级别上，每个z值是相邻的更细级别对应的2 × 2窗口中最远的z。因此，每个z值表示屏幕正方形区域中最远的z。无论何时z值在z缓冲区中被覆盖，它都会通过z金字塔的粗糙层传播。这是递归地完成的，直到到达图像金字塔的顶部，那里只剩下一个z值。下图显示了金字塔的形成。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105204447.png" class="" title="image-20211105204447">

<p>在左边，显示了一个4 × 4的z缓冲区。数值是实际的z值。这被向下采样到一个2×2的区域，其中每个值都是左边四个2×2区域中最远(最大)的。最后，计算其余四个z值中最远的值。这三个映射组成了一个图像金字塔，称为层次z缓冲区。</p>
<p><strong>八叉树节点的分级剔除方法如下:大致按照从前到后的顺序遍历八叉树节点。使用扩展的遮挡查询(章节19.7.1)在z-金字塔上测试八叉树的包围框。我们从最粗糙的z-金字塔单元格开始测试，该单元格包含盒子的屏幕投影。方框在单元格内最近的深度(znear)然后与z金字塔值进行比较，如果znear 越远，盒子就被遮挡。这个测试递归地沿着z-金字塔向下进行，直到发现盒子被遮挡，或者直到到达z-金字塔的底层，在这一点上盒子是可见的。对于可见的八叉树盒，在八叉树中继续递归地向下进行测试，最终将潜在可见的几何图形呈现到分层的z缓冲区中。这样做是为了在后续测试中使用先前渲染对象的遮挡能力。</strong></p>
<p><strong>完整的HZB算法目前还没有被使用，但它已经被简化并适应了GPU上使用自定义剔除或CPU上使用软件光栅化的计算通道。一般来说，大多数基于HZB的遮挡剔除算法是这样工作的:</strong></p>
<pre><code>**1.使用闭塞器表示生成一个完整的层次z金字塔。**

**2.要测试对象是否被遮挡，将其包围体投影到屏幕空间，并估计z-金字塔中的mip水平。**

**3.测试闭塞对选定的mip水平。如果结果不明确，可选择继续使用更精细的mip水平进行测试。**
</code></pre>
<p><strong>大多数实现不使用八叉树或任何BVH，也不更新z金字塔后，一个对象已经被渲染，因为这被认为是太昂贵的执行。</strong></p>
<p><strong>步骤1可以使用“最佳”闭塞器，它可以被选为n个对象中最近的集合，使用简化的艺术家生成的闭塞器原语，或者使用关于在前一帧可见的对象集合的统计数据。或者，可以使用上一帧的z缓冲区，但这不是保守的，因为有时对象可能会因为不正确的剔除而弹出，特别是在快速相机或对象移动下。Haar和Aaltonen都渲染了最好的遮光器，并将它们与前一帧深度的1/16低分辨率的重新投影相结合。然后使用GPU构建z-金字塔，如上图所示。一些使用AMD GCN架构的HTILE(章节23.10.3)来加速z-金字塔的生成。</strong></p>
<p><strong>在步骤2中，物体的边界体积被投影到屏幕空间。BVs的常见选择是球体、AABBs和OBBs。用投影BV的最长边l(以像素为单位)计算mip水平λ，如</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105204839.png" class="" title="image-20211105204839">

<p><strong>其中n是z-金字塔中mip层的最大数目。马克斯操作符是否存在以避免获得负的mip水平，并且最小值避免访问不存在的mip水平。上方程选择最低的整数mip水平，使投影的BV最多覆盖2 × 2的深度值。这种选择的原因是它使成本可预测—最多需要读取和测试四个深度值。此外，Hill和Collin认为，这种测试可以被视为“概率性的”，因为大物体比小物体更容易被看到，所以没有理由在这些情况下读取更多的深度值。</strong></p>
<p><strong>当到达第3步时，我们知道投影的BV在该mip水平上以一组最大为2 × 2的深度值为界。对于给定大小的BV，它可能完全落在mip水平的一个深度texel内。然而，取决于它如何落在网格上，它可能覆盖所有四个像素。最小深度的BV计算，或精确或保守。对于视图空间中的AABB，这个深度就是盒子的最小深度，对于OBB，可以将所有顶点投影到视图向量上并选择最小的距离。对于球面，Shopf等人计算出球面上最近的点为c−rc/||c||，其中c为视图空间中的球面中心，r为球面半径。注意，如果摄像机在一个BV内，那么BV将覆盖整个屏幕，然后对象被渲染。最小深度zmin，将BV的(最大)2 × 2深度与层次z缓冲区的(最大)2 × 2深度进行比较，如果zmin 总是较大，则BV被遮挡。如果对象没有被检测到被遮挡，可以在这里停止测试并只是渲染对象。</strong></p>
<p><strong>你也可以继续针对金字塔中的下一个更深层次(更高分辨率)进行测试。我们可以通过使用另一个存储最小深度的z形金字塔来验证这种测试是否有效。我们测试最大距离zmax，到BV在这个新缓冲区中对应的深度。如果zmax 比所有这些深度都小，那么BV肯定是可见的，可以立即渲染。否则,zmin 和zmax 在这种情况下，Kaplanyan建议在更高分辨率的mip水平上继续进行测试。请注意，在单一深度的层次z-buffer中测试2 × 2像素与百分比接近滤波非常相似(章节7.5)。事实上，可以使用带有百分比接近滤波的双线性滤波来完成测试，如果测试返回一个正值，那么至少有一个texel是可见的。</strong></p>
<p><strong>Haar和Altonen也提出了一种双通道方法，它总是至少呈现所有可见物体。首先，针对前一帧的z-金字塔对所有对象进行遮挡剔除，并渲染“可见”对象。或者，可以使用最后一帧的可见性列表直接渲染z-金字塔。虽然这是一个近似值，但所有被渲染的对象都可以作为当前帧的“最佳”遮挡器的最佳猜测，特别是在帧与帧之间具有高相干性的场景中。第二步使用这些渲染对象的深度缓冲并创建一个新的z-金字塔。然后，在第一次通过被遮挡剔除的对象进行遮挡测试，如果没有被遮挡则进行渲染。这种方法生成完全正确的图像，即使相机快速移动或物体在屏幕上快速移动。Kubisch和Tavenrath使用了类似的方法。</strong></p>
<p><strong>Doghramachi和Bucci对前一帧的深度缓冲区进行光栅化，该缓冲区已经向下采样并重新弹出。它们迫使着色器使用early-z(章节23.7)，并且对于每个盒子，可见片段将对象标记为缓冲区中可见的位置，这是由对象ID唯一确定的。这提供了更高的剔除率，因为使用了面向框，并且完成了逐像素测试，而不是使用自定义测试，使用19.5式。</strong></p>
<p><strong>Collin使用256 × 144浮点z缓冲区(非分层)，栅格化艺术家生成的复杂度较低的遮挡器。这可以通过使用CPU或SPUs(在PLAYSTATION 3上)的软件实现，这些软件具有高度优化的SIMD代码。为了执行遮挡测试，计算对象的屏幕空间AABB及其zmin 与小z缓冲区中的所有相关深度进行比较。只有那些在淘汰中存活下来的对象才会被发送到GPU。这种方法可以工作，但不是保守正确的，因为使用的分辨率比最终的帧缓冲区的分辨率低。Wihlidal建议也使用低分辨率的z缓冲区来加载zmax-数值进入GPU的HiZ(章节23.7)，例如，启动AMD GCN上的HTILE结构。或者，如果HZB用于计算通道的剔除，则可以使用z-buffer软件来生成z-金字塔。这样，算法利用软件中生成的所有信息。</strong></p>
<p><strong>Hasselgren等人提出了一种不同的方法，其中每个8 × 4贴图每个像素有一个比特和两个zmax-值，导致每像素3位的总成本。通过使用zmax-值时，可以更好地处理深度间断，因为背景对象可以使用其中一个zmax的值和前景对象使用另一个。这种表示称为掩码层次深度缓冲区(MHDB)，是保守的，也可用于zmax剔除。在软件三角形栅格化过程中，每个tile只生成覆盖掩码和一个最大深度值，这使得栅格化到MHDB快速有效。在对三角形进行栅格化的同时，还可以对三角形进行遮挡测试，从而优化了栅格化器。MDHB会针对每个三角形进行更新，这是其他方法所不具备的优势。评估了两种使用模式。第一种方法是使用特殊的遮挡网格，并使用软件光栅化器将这些网格渲染到MDHB上。然后，遍历掩码上方的AABB树，并针对MDHB进行层次测试。这非常有效，特别是当场景中有许多小物体时。对于第二种方法，整个场景存储在AABB树中，并使用堆大致按照从前到后的顺序遍历场景。在每一步中，对MDHB进行截锥剔除和遮挡查询。每当呈现一个对象时，MDHB也会更新。下图19.19中的场景就是使用这种方法渲染的。开源代码对AVX2进行了大量优化。</strong></p>
<p><strong>还有一些中间件包专门用于剔除，特别是用于遮挡剔除。Umbra就是这样一个框架，它已经被广泛地集成到各种游戏引擎中。</strong></p>
<h2 id="Culling-Systems-剔除系统"><a href="#Culling-Systems-剔除系统" class="headerlink" title="Culling Systems 剔除系统"></a>Culling Systems 剔除系统</h2><p><strong>这些年来，筛选系统已经有了相当大的发展，并将继续这样做。在本节中，我们将描述一些概括性的观点，并指出相关文献的细节。一些系统在GPU的计算着色器中有效地执行所有的剔除，而另一些系统结合了CPU上的粗剔除和GPU上稍后的细剔除。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105205445.png" class="" title="image-20211105205445">

<p>一个在三种不同粒度上工作的筛选系统示例。首先，剔除是在每个对象层面上完成的。然后在每个集群级别剔除幸存的对象。最后进行三角形剔除，如下图所示。</p>
<p><strong>典型的扑杀系统可以在许多粒度上工作，如上图所示。一个对象的一组或一组仅仅是该对象的三角形的子集。例如，可以使用带有64个顶点的三角形条，或者由256个三角形组成的组。在每一个步骤中，都可以使用一系列的剔除技术。El Mansouri使用小三角剔除、细节剔除、视锥剔除和物体遮挡剔除。由于集群在几何上比对象小，所以即使对集群使用相同的剔除技术也是有意义的，因为它们更有可能被剔除。例如，可以在集群上使用细节、截锥、集群背面和遮挡剔除。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105205601.png" class="" title="image-20211105205601">

<p>三角形剔除系统，其中一组剔除算法首先应用于所有单独的三角形。能够使用间接绘图，即在没有GPU/CPU循环的情况下，幸存的三角形会被压缩成更短的列表。这个列表是由GPU使用间接绘图渲染的。</p>
<p><strong>在每个集群级别进行剔除后，可以执行一个额外的步骤，在每个三角形级别进行剔除。为了让这种情况完全发生在GPU上，可以使用上图所示的方法。三角形的剔除技术包括除以w后的截锥剔除，即将三角形的范围与±1进行比较，背面测试，退化三角形剔除，小三角形剔除，以及可能的遮挡剔除。然后，所有剔除测试后剩下的三角形被压缩到一个最小列表中，这样做是为了在下一个步骤中只处理幸存的三角形。这个想法是为了指导裁剪计算着色器在这个步骤中从GPU发送一个绘制命令给它自己。这是使用间接绘制命令完成的。这些调用在OpenGL中称为“multi-draw indirect”，在DirectX中称为“execute indirect”。将三角形的数量写入GPU缓冲区中的一个位置，并将其与压缩列表一起用于GPU渲染三角形列表。</strong></p>
<p><strong>有很多方法可以将剔除算法与它们执行的地方结合起来，例如，无论是在CPU上还是在GPU上，每种剔除算法也有许多不同的风格。最终的组合还没有找到，但是可以肯定地说，最佳的方法取决于目标体系结构和要呈现的内容。接下来，我们指出了在CPU/GPU剔除系统领域的一些重要工作，这些工作对该领域产生了巨大的影响。Shopf等人在GPU上对角色进行了所有AI模拟，因此，每个角色的位置只能在GPU内存中使用。这导致他们使用计算着色器探索淘汰和LOD管理，大多数系统都受到了他们的工作的严重影响。Haar 和 Aaltonen描述了他们为《刺客信条:大革命》开发的系统。Wihlidal解释了冻伤引擎中使用的筛选系统。Engel提出了一个筛选系统，它可以帮助改进使用可见性缓冲区的管道(章节20.5)。Kubisch和Tavenrath描述了绘制包含大量零件的大规模模型的方法，并使用不同的剔除方法和API调用进行优化。一个值得注意的方法，他们使用遮挡-剔除框是创建一个边界框的可见边使用几何着色器，然后让early-z快速剔除遮挡的几何。</strong></p>
<h2 id="Level-of-Detail-细节层次"><a href="#Level-of-Detail-细节层次" class="headerlink" title="Level of Detail 细节层次"></a>Level of Detail 细节层次</h2><p><strong>细节层次(LODs)的基本思想是使用对象的简单版本，因为它对渲染图像的贡献越来越小。例如，考虑一辆由上百万个三角形组成的小车。当观众靠近汽车时，可以使用这种表示。当物体较远时，比如只覆盖200像素，我们不需要所有的100万个三角形。相反，我们可以使用一个简化的模型，比如说，只有1000个三角形。由于距离的关系，简化版本看起来与更详细的版本大致相同。参见下图。通过这种方式，可以预期显著的性能提高。为了减少应用LOD技术所涉及的总工作量，最好在剔除技术之后应用LOD技术。例如，LOD选择仅对视图截锥内的对象进行计算。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107140951.png" class="" title="image-20211107140951">

<p>在这里，我们展示了C4炸药模型(上)和猎人模型(下)的三个不同的细节层次。元素在较低的细节级别被简化或删除。小的插入图像显示了简化模型的相对尺寸，在它们可能被使用。(上图由Crytek提供;底部排由Valve公司提供)</p>
<p><strong>LOD技术也可以用于使应用程序在一系列具有不同性能的设备上以所需的帧率工作。在速度较慢的系统上，可以使用不太详细的LOD来提高性能。注意，虽然LOD技术首先有助于减少顶点处理，它们还降低了像素阴影的成本。这是因为模型的所有三角形边长的总和将会更低，这意味着四边形的遮挡减少了(章节18.2和23.1)。</strong></p>
<p><strong>第14章描述的Fog和其他参与媒体可以与LODs一起使用。例如，这允许我们完全跳过对象进入完全不透明雾的渲染。此外，雾化机制可以用于实现时间关键的渲染(章节19.9.3)。通过将远平面移动到更接近观察者的地方，更多的对象可以在早期被剔除，从而提高帧率。此外，在雾中通常可以使用较低的LOD。</strong></p>
<p><strong>一些物体，如球体、B´ezier曲面和细分曲面，作为其几何描述的一部分，具有细节层次。底层几何图形是弯曲的，一个独立的LOD控制决定如何将其镶嵌成可显示的三角形。有关适应参数曲面和细分曲面镶嵌质量的算法，请参见17.6.2节。</strong></p>
<p><strong>LOD算法一般由生成、选择和切换三大部分组成。LOD生成是使用不同数量的细节生成模型的不同表示的部分。可以使用第16.5节中讨论的简化方法来生成所需的LOD数量。另一种方法是手工制作带有不同数量三角形的模型。选择机制根据一些标准选择详细程度模型，比如屏幕上估计的面积。最后，我们需要从一个细节级别切换到另一个，这个过程被称为LOD切换。本节将介绍不同的LOD切换和选择机制。</strong></p>
<p><strong>虽然本节的重点是在不同的几何表示中进行选择，但LOD背后的思想也可以应用到模型的其他方面，甚至是使用的渲染方法。较低细节级别的模型也可以使用较低分辨率的纹理，从而进一步节省内存，并可能改善缓存访问。着色器本身可以根据距离、重要性或其他因素进行简化。Kajiya提出了一个比例层次，显示表面光照模型如何重叠纹理映射方法，而纹理映射方法又重叠几何细节。另一项技术是，较少的骨骼可以用于远处物体的剥皮手术。</strong></p>
<p><strong>当静态对象相对较远时，广告牌和视点替用特效(第13.6.4节)是一种自然的方式，以很少的成本来表示它们。其他的表面渲染方法，如凹凸或浮雕映射，可以用来简化模型的表示。下图给出了一个示例。Teixeira讨论了如何使用GPU将法线贴图烘焙到表面上。这种简化技术最明显的缺陷是轮廓失去了曲率。Lovis- cache提出了一种沿轮廓边缘挤压鳍的方法，以产生弯曲的轮廓。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107141243.png" class="" title="image-20211107141243">

<p>在左边，原始模型由150万个三角形组成。在右边，模型有1100个三角形，表面细节存储为高度场纹理，并使用浮雕贴图进行渲染。(图片由ATI研究公司Natalya Tatarchuk提供)</p>
<p><strong>可以用来表示对象的技术范围的一个例子来自于Lengyel等人。在这项研究中，毛皮在非常近的时候用几何图形表示，在较远的时候用阿尔法混合折线表示，然后用阿尔法混合体积纹理“贝壳”，最后在远处通过纹理贴图。参见下图。知道何时以及如何最好地从一套建模和渲染技术切换到另一套，从而最大化帧率和质量仍然是一门艺术，是一个有待探索的开放领域。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107141404.png" class="" title="image-20211107141404">

<p>从远处看，兔子的皮毛是用体积纹理渲染的。当兔子靠近时，毛发就会被阿尔法混合折线渲染。当靠近时，沿着剪影的皮毛被移植的鳍渲染。(图片由微软研究院Jed Lengyel和Michael Cohen提供。)</p>
<h3 id="LOD-Switching-LOD切换"><a href="#LOD-Switching-LOD切换" class="headerlink" title="LOD Switching LOD切换"></a>LOD Switching LOD切换</h3><p><strong>当从一个LOD切换到另一个LOD时，突然的模型替换往往是显而易见的和令人分心的。这种差异被称为“弹出”。这里将描述几种执行这种切换的不同方法，它们都有不同的弹出特性。</strong></p>
<h4 id="Discrete-Geometry-LODs-离散几何的LODs"><a href="#Discrete-Geometry-LODs-离散几何的LODs" class="headerlink" title="Discrete Geometry LODs 离散几何的LODs"></a>Discrete Geometry LODs 离散几何的LODs</h4><p><strong>在LOD算法最简单的类型中，不同的表示是包含不同数量的原语的同一对象的模型。这种算法非常适合现代图形硬件，因为这些单独的静态网格可以存储在GPU内存中并重用(章节16.4.5)。一个更详细的LOD有更多的原语。对象的三个LOD如图19.26和下图所示。第一个图还显示了不同距离的LOD。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107141731.png" class="" title="image-20211107141731">

<p>悬崖的一部分，有三个不同层次的细节，从左到右有72,200,13,719和7,713个三角形。(图片由Quixel Megascans提供。)</p>
<p><strong>从一个LOD切换到另一个LOD是突然的。也就是说，在当前帧上使用某个LOD，然后在下一帧上，选择机制选择另一个LOD并立即使用它进行渲染。弹出通常是这类LOD方法中最糟糕的，但如果切换发生在距离上，当渲染LOD的差异几乎不可见时，它可以工作得很好。下面将介绍更好的替代方案。</strong></p>
<h4 id="Blend-LODs-混合LODs"><a href="#Blend-LODs-混合LODs" class="headerlink" title="Blend LODs 混合LODs"></a>Blend LODs 混合LODs</h4><p><strong>从概念上讲，切换的一种简单方法是在短时间内在两个LODs之间进行线性混合。这样做肯定会使转换更平稳。为一个对象呈现两个LOD自然比仅呈现一个LOD要昂贵得多，因此这在某种程度上违背了LOD的目的。然而，LOD切换通常只会在很短的时间内发生，而且通常不会同时对场景中的所有对象进行切换，所以提高质量可能是值得的。</strong></p>
<p><strong>假设需要在两个LOD(比如LOD1和lod2)之间进行转换，并且LOD1是当前正在呈现的LOD。问题在于如何以合理的方式渲染和混合两个LODs。使两个LODs都是半透明的将导致在屏幕上呈现一个半透明(尽管有点不透明)的对象，这看起来很奇怪。</strong></p>
<p><strong>Giegl和Wimmer提出了一种混合方法，该方法在实践中工作得很好，而且易于实现。首先在framebuffer中不透明地绘制LOD1(包括颜色和z)，然后将LOD2的alpha值从0增加到1，并使用“over”混合模式。当LOD2已经淡入，因此它是完全不透明的，它会变成当前的LOD，然后LOD1会淡出。褪色的LOD (in或out)应该在启用z-test和禁用z-write的情况下呈现。为了避免后期绘制的遥远对象在渲染褪色LOD的结果上绘制，只需按照所有不透明内容之后的顺序绘制所有褪色LOD，就像通常对透明对象所做的那样。注意，在转换的中间，两个lod都是不透明的，一个在另一个上面。如果转换间隔很短，这种技术效果最好，这也有助于保持较小的渲染开销。Mittring讨论了一种类似的方法，除了screen-door透明度(可能在亚像素级)用于溶解版本之间。</strong></p>
<p><strong>Scherzer和Wimmer通过在每一帧上只更新一个LOD并重用前一帧的另一个LOD来避免渲染两个LOD。前一帧的反投影与使用可见纹理的组合通道一起执行。更快的渲染和更好的转换是主要的结果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107142106.png" class="" title="image-20211107142106">

<p>树枝(和它们的叶子，没有显示)会收缩，然后随着观察者离开树模型而移除。(图片由SpeedTree提供。)</p>
<p><strong>有些对象适合使用其他转换技术。例如，SpeedTree包平滑地移动或缩放其树LOD模型的部分，以避免pop。如上图所示。一组LOD如下图所示，以及用于远处树木的广告牌LOD技术。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107142122.png" class="" title="image-20211107142122">

<p>树LOD模型，近到远。当树在远处时，它会被一组广告牌中的一个所代表，如图所示。每个广告牌都是从不同的角度渲染树，由颜色和法线贴图组成。选择最面向观众的广告牌。实际上形成了8到12个广告牌(这里显示了6个)，透明部分被修剪掉，以避免浪费时间丢弃完全透明的像素(章节13.6.2)。(图片由SpeedTree提供。)</p>
<h4 id="Alpha-LODs-阿尔法LODs"><a href="#Alpha-LODs-阿尔法LODs" class="headerlink" title="Alpha LODs 阿尔法LODs"></a>Alpha LODs 阿尔法LODs</h4><p><strong>避免突然弹出的一个简单方法是使用我们称为alpha LOD的方法。这种技术可以单独使用，也可以与其他LOD切换技术结合使用。它用于最简单的可见LOD，如果只有一个LOD可用，则可以是原始模型。当用于LOD选择的度量(例如，到这个对象的距离)增加时，对象的整体透明度增加(α减少)，当它达到完全透明(α = 0.0)时，对象最终消失。发生这种情况当度量值大于用户定义的不可见阈值时。当达到不可见阈值时，只要度量值保持在阈值以上，对象就不需要通过渲染管道发送。当一个物体已经不可见，并且它的指标低于不可见阈值时，它的透明度就会降低，并重新开始可见。另一种方法是使用第19.9.2节中描述的迟滞法。</strong></p>
<p><strong>单独使用这种技术的好处是，它比离散几何LOD方法更连续，因此避免了弹出。此外，由于对象最终完全消失，不需要渲染，可以预期一个显著的加速。缺点是对象完全消失，只有在这一点上才能获得性能的提高。下图显示了alpha LOD的一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107142546.png" class="" title="image-20211107142546">

<p>中间的圆锥体使用alpha LOD渲染。圆锥的透明度随着距离的增加而增加，最终消失。左边的图像从相同的距离显示，以方便查看，而右边的图像以不同的尺寸显示。</p>
<p><strong>使用alpha透明度的一个问题是，需要按深度排序，以确保透明对象正确混合。为了淡化远处的植被，Whatley讨论了如何使用噪声纹理来提高屏风门的透明度。这有一个溶解的效果，随着距离的增加物体上更多的像素消失。虽然质量不如真正的阿尔法淡出，屏幕门的透明度意味着没有分类或混合是必要的。</strong></p>
<h4 id="CLODs-and-Geomorph-LODs-CLODs-和-地形LODs"><a href="#CLODs-and-Geomorph-LODs-CLODs-和-地形LODs" class="headerlink" title="CLODs and Geomorph LODs CLODs 和 地形LODs"></a>CLODs and Geomorph LODs CLODs 和 地形LODs</h4><p><strong>网格简化过程可用于从单个复杂对象创建各种LOD模型。执行这种简化的算法将在第16.5.1节中讨论。一种方法是创建一组离散LOD，并像前面讨论的那样使用它们。然而，边缘折叠方法有一个属性，允许其他方式在LOD之间进行转换。在这里，我们提出两种利用这些信息的方法。这些是有用的背景，但目前很少在实践中使用。</strong></p>
<p><strong>一个模型每执行一次边折叠操作后，会少两个三角形。在边折叠中，边会收缩直到它的两个端点相遇，然后消失。如果这个过程是动画的，那么在原始模型和稍微简化的模型之间就会发生平滑的过渡。对于每条边的折叠，一个顶点与另一个顶点连接在一起。在一系列的边缘折叠过程中，一组顶点移动到其他顶点之间。通过存储一系列折叠的边缘，这个过程可以被逆转，因此一个简化的模型可以随着时间的推移变得更加复杂。边缘折叠的反转称为顶点分裂。因此，改变对象细节级别的一种方法是精确地以LOD选择值上可见的三角形数量为基础。在100米之外，模型可能由1000个三角形组成，移动到101米，它可能会下降到998个三角形。这种方案称为连续细节级别(CLOD)技术。因此，可供展示的模型并不是一组离散的模型，而是一组巨大的模型，每一个模型都比它更复杂的邻居少两个三角形。</strong></p>
<p><strong>虽然很吸引人，但在实践中使用这样的方案也有一些缺点。并非CLOD流中的所有模型看起来都很好。三角形网格的渲染速度比单个三角形要快得多，使用CLOD技术比使用静态模型要困难得多。如果场景中有多个相同对象的实例，那么每个CLOD对象都需要指定自己特定的三角形集合，因为它不匹配任何其他对象。Forsyth讨论了这些问题和其他问题的解决方案。虽然大多数CLOD技术在本质上是相当串行的，但它们并不适合在GPU上实现。因此，Hu等人提出了一种更适合GPU并行特性的CLOD修改。他们的技术也依赖于视图，因为如果一个物体与视图截锥的左侧相交，截锥外可以使用更少的三角形，连接到内部密度更高的网格。</strong></p>
<p><strong>在顶点分割中，一个顶点变成两个。这意味着一个复杂模型上的每个顶点都来自于一个简单模型上的某个顶点。地形LOD是一组通过简化而建立的离散模型，保持顶点之间的连通性。当从一个复杂模型切换到一个简单模型时，复杂模型的顶点被插入到它们的原始位置和那些简单模型的顶点之间。当转换完成时，将使用更简单的细节级别模型来表示对象。参见下图以获得一个转换示例。地貌有几个优点。为了保证模型的质量，可以提前选择单独的静态模型，并且可以很容易地转换成三角形网格。与CLOD一样，通过平滑过渡也可以避免弹出。主要的缺点是每个顶点都需要插值;CLOD技术通常不使用插值，因此顶点位置集本身不会改变。另一个缺点是，物体似乎总是在变化，这可能会分散注意力。对于纹理对象尤其如此。Sander和Mitchell描述了一个系统，其中地貌与静态的、GPU驻留的顶点和索引缓冲区结合使用。也可以将Mittring(如上所述)的屏蔽门透明度与地貌相结合，以实现更平滑的过渡。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107144703.png" class="" title="image-20211107144703">

<p>左边和右边的图像显示了一个低细节模型和一个高细节模型。中间的图像显示了在左右模型中间插入的地貌模型。注意，中间的奶牛和右边的模型有同样多的顶点和三角形。(使用Melax的“Polychop”简化演示生成的图像。)</p>
<p><strong>GPU支持一种被称为小数镶嵌的相关思想。在这种方案中，曲面的镶嵌因子可以设置为任意的浮点数，从而避免了弹出。例如，分数阶镶嵌可以用于B´ezier补丁和位移映射原语。有关这些技术的更多信息，请参见17.6.1节。</strong></p>
<h3 id="LOD-Selection-LOD选择"><a href="#LOD-Selection-LOD选择" class="headerlink" title="LOD Selection LOD选择"></a>LOD Selection LOD选择</h3><p><strong>考虑到一个对象存在不同的细节级别，必须选择渲染哪个，或者混合哪个。这是LOD选择的任务，这里将介绍一些不同的技术。这些技术也可以用于选择好的遮挡剔除算法。</strong></p>
<p><strong>通常，一个指标(也称为受益函数)会根据当前的视点和对象的位置进行评估，这个指标的值会选择一个适当的LOD。这个度量可能基于，例如，物体的边界体积的投影面积或从视点到物体的距离。收益函数的值在这里用r表示。参见17.6.2节如何快速估计直线在屏幕上的投影。</strong></p>
<h4 id="Range-Based-基于范围"><a href="#Range-Based-基于范围" class="headerlink" title="Range-Based 基于范围"></a>Range-Based 基于范围</h4><p><strong>选择LOD的常用方法是将对象的不同LOD与不同的距离范围相关联。最详细的LOD范围从零到一些用户定义的值r1，这意味着当到物体的距离小于r1时，LOD是可见的．下一个LOD的范围从r1到r2 其中r2 &gt; r1．如果到物体的距离大于等于r1 并且小于r2，则使用此LOD，以此类推。下图给出了四种不同LOD及其范围的示例，以及在场景图中使用的相应LOD节点。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107145420.png" class="" title="image-20211107145420">

<p>图的左侧显示了基于范围的lod是如何工作的。注意，第四个LOD是一个空对象，所以当对象距离r3更远时，什么也不会画出来，因为对象对图像的贡献不够大，不值得这样做。右边部分显示了场景图中的LOD节点。LOD节点中只有一个子节点是基于r下行的。</p>
<p><strong>如果用于确定要使用哪个LOD的度量在不同帧之间围绕某个值r而变化，就会发生不必要的弹出i．关卡之间可能会出现快速循环。这可以通过在ri附近引入一些滞后来解决。下图显示了基于范围的LOD，但适用于任何类型。这里，LOD范围的上一行仅在r增加时使用。当r减小时，使用范围的底部行。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107145541.png" class="" title="image-20211107145541">

<p>彩色区域表示LOD技术的滞后区域。</p>
<p><strong>在过渡范围内混合两个LODs如下图所示。然而，这不是理想的，因为对象的距离可能停留在过渡范围很长一段时间，这增加了渲染的负担，因为混合两个LODs。相反，Mittring在有限的时间内，当对象达到一定的过渡范围时，执行LOD切换。为了获得最好的结果，这应该与上面的迟滞方法相结合。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107145644.png" class="" title="image-20211107145644">

<p>彩色区域说明了在两个最近的LOD之间进行混合的范围，其中b01表示在LOD0和LOD1之间进行混合，而LODk表示只有LODk在相应的范围内进行渲染。</p>
<h4 id="Projected-Area-Based-基于投影面积"><a href="#Projected-Area-Based-基于投影面积" class="headerlink" title="Projected Area-Based 基于投影面积"></a>Projected Area-Based 基于投影面积</h4><p><strong>另一个用于LOD选择的常见度量是边界体的投影面积，或者它的估计。这里，我们将展示它的像素数面积，称为屏幕空间覆盖，可以估计球体和盒子的透视视图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107150304.png" class="" title="image-20211107150304">

<p>这张图显示了当距离增加一倍时，没有任何厚度的物体的投影大小减半。</p>
<p><strong>从球体开始，这个估计是基于这样一个事实，即物体的投影尺寸随着与观察者的距离沿观察方向的减小而减小。如上图所示，它说明了如果距离观众的距离加倍，投影的大小就会减半，这对于面向观众的平面物体来说也是如此。我们通过球的中心点c和半径r来定义一个球。观察者沿着标准化方向向量d位于v处。沿着视图方向从c到v的距离就是球的中心在视图向量上的投影:d·(v−c).我们还假设从观看者到视锥近平面的距离为n。近平面用于估计，以便位于近平面上的物体返回其原始尺寸。然后估计出投影球面的半径</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107150356.png" class="" title="image-20211107150356">

<p><strong>投影的像素面积为πp²wh，其中w×h为屏幕分辨率。较高的值选择更详细的LOD。这是近似值。事实上,三维球体的投影是椭圆，如Mara和McGuire所示。他们还导出了一种计算保守边界多边形的方法，即使在球面与近平面相交的情况下。</strong></p>
<p><strong>通常的做法是简单地在对象的边界框周围使用一个边界球。另一个估计是使用边界框的屏幕边界。然而，薄的或平的物体在实际覆盖的投影面积上可以有相当大的变化。例如，想象一根意大利面条的一端在屏幕的左上角，另一端在右下角。它的边界球体将覆盖屏幕，它的边界框的最小和最大二维屏幕边界也是如此。</strong></p>
<p><strong>Schmalstieg和Tobler提出了一种快速计算方框投影面积的程序。这个想法是将相机的视点相对于盒子进行分类，并使用这个分类来确定哪些投影顶点包含在投影盒子的剪影中。这个过程是通过查找表完成的。使用这些顶点，可以计算视图中的面积。分类分为三个主要的案例，如下图所示。实际上，这种分类是通过确定视点位于边界框平面的哪一边来完成的。为了提高效率，将视点转换为方框的坐标系，只需要比较即可进行分类。比较的结果被放入位掩码中，该位掩码用作LUT的索引。这个LUT决定了从视点看到的轮廓中有多少个顶点。然后，使用另一个查找来实际找到轮廓顶点。当它们被投影到屏幕上后，轮廓的面积就被计算出来了。为了避免(有时剧烈的)估计错误，有必要将形成的多边形裁剪到视图截锥的侧面。源代码可以在网上找到。Lengyel对该方案进行了优化，可以使用更紧凑的LUT。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107150537.png" class="" title="image-20211107150537">

<p>立方体投影的三个例子，显示(从左到右)一个，两个，三个正面。轮廓线分别由4个、6个和6个顶点组成，每个轮廓线的面积将针对所形成的每个多边形进行计算。(参考Schmalstieg和Tobler的插图。)</p>
<p><strong>仅仅根据距离或投影来选择LOD并不总是一个好主意。例如，如果一个物体有一个AABB，其中有一些大三角形和一些小三角形，那么小三角形可能会混淆严重，并由于四边形遮挡而降低性能。如果另一个物体具有完全相同的AABB，但带有介质以及其中的大三角形，那么基于距离和基于投影的选择方法都会选择相同的LOD。为了避免这种情况，Schulz和Mader使用几何平均值g来帮助选择LOD:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107150635.png" class="" title="image-20211107150635">

<p><strong>其中ti是物体的三角形的大小。使用几何平均值而不是算术平均值的原因是，即使有几个大三角形，许多小三角形也会使g变小。对于最高分辨率的模型，该值是离线计算的，并用于预先计算第一个开关应该发生的距离。随后的开关距离是第一个距离的简单函数。这允许他们的系统更频繁地使用低LODs，从而提高性能。</strong></p>
<p><strong>另一种方法是计算每个离散LOD的几何误差。估计简化后的模型与原始模型最多偏离多少米。然后可以投影这个距离，以确定屏幕空间中使用LOD的效果。然后选择最低的LOD(也满足用户定义的屏幕空间错误)。</strong></p>
<h4 id="Other-Selection-Methods-其他的选择方法"><a href="#Other-Selection-Methods-其他的选择方法" class="headerlink" title="Other Selection Methods 其他的选择方法"></a>Other Selection Methods 其他的选择方法</h4><p><strong>基于范围和基于投影区域的LOD选择通常是最常用的度量。然而，还有许多其他的可能性，我们将在这里提到一些。除了投影面积，Funkhouser和S´equin还建议使用物体的重要性(例如，墙壁比墙上的时钟更重要)、运动、迟滞(切换LOD时，好处降低)和聚焦。最后一点，观众的注意力焦点，可能是一个重要因素。例如，在体育游戏中，控制球的人物是用户最关注的地方，所以其他角色的细节级别相对较低。类似地，当在虚拟现实应用程序中使用眼球追踪时，应该在观察者看到的地方使用更高的LOD。</strong></p>
<p><strong>根据应用程序的不同，其他策略也可能是有效的。可以使用整体能见度，例如，通过浓密的树叶看到的附近的物体可以用较低的LOD渲染。更多的全局度量是可能的，例如限制使用的高度详细LOD的总体数量，以保持在给定的三角形预算之内。有关这个主题的更多信息，请参阅下一节。其他因素包括能见度、颜色和纹理。感知指标也可以用来选择LOD。</strong></p>
<p><strong>McAuley提出了一个植被系统，其中树干和叶子集群在成为视点之前有三个LODs。他从不同的角度和不同的距离对每个对象的簇之间的可见性进行预处理。由于树后面的集群可能被更近的集群完全隐藏，因此即使树很近，也可以为这样的集群选择较低的LOD。对于草地渲染，通常使用靠近观察者的几何图形，广告牌稍微远一点，以及在显著距离上使用简单的地面纹理。</strong></p>
<h3 id="Time-Critical-LOD-Rendering-时间关键的LOD渲染"><a href="#Time-Critical-LOD-Rendering-时间关键的LOD渲染" class="headerlink" title="Time-Critical LOD Rendering 时间关键的LOD渲染"></a>Time-Critical LOD Rendering 时间关键的LOD渲染</h3><p><strong>一个渲染系统通常需要一个恒定的帧率。事实上，这就是所谓的“硬实时”或时间关键渲染。这样的系统被赋予了一个特定的时间量，比如16毫秒，并且必须在这个时间内完成它的任务(例如，渲染图像)。当时间到了，系统必须停止处理。如果场景中的物体由LOD表示，那么硬实时渲染系统将能够在每一帧向用户展示更多或全部场景，而不是在分配的时间内只绘制几个非常详细的模型。</strong></p>
<p><strong>Funkhouser和S´equin提出了一种启发式算法，该算法对场景中所有可见物体的细节级别进行选择，以满足恒定帧率的要求。该算法是预测性的，它选择的LOD可见对象的基础上的期望帧率和对象是可见的。这种算法与反应式算法形成对比，后者基于渲染前一帧所花费的时间进行选择。</strong></p>
<p><strong>一个对象被称为O，并在一个名为L的细节级别上呈现，它为对象的每个LOD给出(O, L)。然后定义了两个启发式。一种启发式方法估计在特定细节水平上渲染对象的成本:Cost (O, L)。另一种方法估计在特定细节水平上渲染对象的效益:Benefit (O, L)。效益函数估计在特定LOD上对对象图像的贡献。</strong></p>
<p><strong>假设在视图截锥内或相交的对象被称为S，算法背后的主要思想是使用启发式选择函数优化对象S的LODs选择。具体来说，我们想要最大化</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107151336.png" class="" title="image-20211107151336">

<p><strong>约束条件下</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107151346.png" class="" title="image-20211107151346">

<p><strong>其中T是目标帧时间。</strong></p>
<p><strong>换句话说，我们想要为对象选择在理想的帧率内提供“最佳图像”的细节级别。然后我们描述了成本和效益函数的估计方法，并给出了上述方程的优化算法。</strong></p>
<p><strong>成本函数和效益函数都很难定义，所以它们在所有情况下都能工作。成本函数可以通过用不同的观看参数对LOD的渲染进行多次计时来估计。有关不同的利益函数，请参见第19.9.2节。在实践中，对象的BV的投影面积可以作为一个效益函数。</strong></p>
<p><strong>最后，我们将讨论如何为场景中的对象选择细节级别。首先，我们注意到以下几点:对于某些视点，场景可能过于复杂而无法跟上所需的帧率。为了解决这个问题，我们可以定义一个LOD每个对象在其最低细节级别，这只是一个没有原语的对象——即我们避免渲染对象-。使用这个技巧，我们只渲染最重要的对象，而忽略不重要的对象。</strong></p>
<p><strong>为了为一个场景选择“最佳”LOD，需要在如式19.9所示的约束条件下对式19.8进行优化。这是一个NP—完全问题，这意味着要正确地解决它，唯一要做的就是测试所有不同的组合，并选择最好的。这对任何算法来说都是不可行的。一种更简单、更可行的方法是使用贪婪算法，试图最大化每个对象Value = Benefit(O, L)/Cost(O, L)。该算法处理视图截屏内的所有对象，并选择按降序渲染对象，即也就是值最高的那个。如果一个对象在多个LOD中具有相同的值，则选择效益最高的LOD进行渲染。这种方法最能“物有所值”。“对于视图截屏内的n个对象，算法运行时间为O(n log n)，它产生的解决方案至少是最好的一半。也可以利用帧对帧的一致性来加快值的排序。</strong></p>
<p><strong>关于LOD管理以及LOD管理与门户筛选结合的更多信息可以在Funkhouser的博士论文中找到。Maciel和Shirley结合LOD和视点替用特效，提出了一种近似恒定时间的室外场景渲染算法。一般的想法是使用对象的不同表示的层次结构(例如，一组LOD和分层视点替用器)。然后以某种方式遍历树，给出给定时间内的最佳图像。Mason和Blake提出了一种增量层次LOD选择算法。同样，对象的不同表示可以是任意的。Eriksson等人提出了层次细节层次(HLODs)。使用这些，场景也可以用恒定的帧率渲染，或者渲染到渲染错误是有限的。与此相关的是功率预算。Wang等人提出了一个优化框架，选择好的参数来降低功耗，这对手机和平板电脑很重要。</strong></p>
<p><strong>与时间关键渲染相关的是另一组适用于静态模型的技术。当相机不移动时，整个模型被渲染，累积缓冲可以用于抗锯齿、景深和软阴影，并进行渐进式更新。而当相机移动时，可以降低所有物体的细节水平，并使用细节剔除来完全剔除小物体，以满足一定的帧率。</strong></p>
<h2 id="Rendering-Large-Scenes-渲染大场景"><a href="#Rendering-Large-Scenes-渲染大场景" class="headerlink" title="Rendering Large Scenes 渲染大场景"></a>Rendering Large Scenes 渲染大场景</h2><p><strong>到目前为止，已经暗示要渲染的场景适合装入计算机的主存储器。情况可能并不总是如此。例如，一些主机只有8GB的内存，而一些游戏世界可以包含数百GB的数据。因此，我们提出了流和转码的方法纹理，一些通用的流技术，最后是地形渲染算法。请注意，这些方法几乎总是与剔除技术和详细程度方法相结合，本章前面已经描述过了。</strong></p>
<h3 id="Virtual-Texturing-and-Streaming-虚拟纹理和流"><a href="#Virtual-Texturing-and-Streaming-虚拟纹理和流" class="headerlink" title="Virtual Texturing and Streaming 虚拟纹理和流"></a>Virtual Texturing and Streaming 虚拟纹理和流</h3><p><strong>想象一下，你想要使用一个分辨率非常高的纹理来渲染一个巨大的地形数据集，而这个纹理太大了，无法放入GPU内存中。例如，《RAGE》中的一些虚拟纹理的分辨率为128k×128k，这将消耗64 GB的GPU内存。当CPU上的内存有限时，操作系统使用虚拟内存进行内存管理，根据需要将数据从驱动器交换到CPU内存。这种功能正是稀疏纹理所提供的，它使得分配巨大的虚拟纹理成为可能，也被称为megatexture。这些技术有时被称为虚拟纹理或部分驻留纹理。应用程序决定每个mipmap级别的哪些区域(瓷砖)应该驻留在GPU内存中。一个贴图通常是64 kB，它的纹理分辨率取决于纹理格式。在这里，我们介绍了虚拟纹理和流技术。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107172359.png" class="" title="image-20211107172359">

<p>在虚拟纹理中，一个具有mipmap层次结构的大型虚拟纹理被划分为每个128 × 128像素的tiles(左图)。只有一小部分(在这个例子中是3 × 3的贴图)能够容纳物理内存(右)。为了找到虚拟纹理贴图的位置，需要从虚拟地址转换到物理地址，这是通过页表完成的。注意，为了减少混乱，并不是物理内存中的所有贴图都有来自虚拟纹理的箭头。(伊朗巴斯曼火山的图像纹理。来自NASA的“可见地球”项目。)</p>
<p><strong>关于使用mipmapping的高效纹理系统的关键观察是，理想情况下所需的像素数应该与最终渲染图像的分辨率成正比，而不依赖于纹理本身的分辨率。因此，我们只要求物理GPU内存中可见的像素，与整个游戏世界中的所有像素相比，这是一个相当有限的集合。主要的概念如上图所示，其中整个mipmap链被划分为虚拟内存和物理内存中的tiles。这些结构有时被称为虚拟mipmaps或clipmaps，后者指的是较大的mipmap中的一小部分被剪掉以供使用。由于物理内存的大小比虚拟内存小得多，只有一小部分虚拟纹理块可以装入物理内存。几何图形使用全局uv参数化到虚拟纹理中，并且在像素着色器中使用这些uv坐标之前，它们需要被转换为纹理坐标，指向物理纹理内存。这是使用GPU支持的页面表(如上图所示)或间接纹理完成的，如果在GPU上的软件中完成。任天堂GameCube的GPU支持虚拟纹理。最近，PLAYSTATION 4、Xbox One和许多其他GPU都支持硬件虚拟纹理。当贴图映射和未映射到物理内存时，间接纹理需要用正确的偏移量进行更新。使用一个巨大的虚拟纹理和一个小的物理纹理效果很好，因为远处的几何图形只需要加载一些高级的mipmap贴图到物理内存中，而靠近相机的几何图形可以加载一些低级的mipmap贴图。注意，虚拟纹理可以用于流从磁盘的巨大纹理，但也用于稀疏的阴影映射，例如。</strong></p>
<p><strong>由于物理内存有限，所有使用虚拟纹理的引擎都需要一种方法来确定哪些贴图应该驻留。，位于物理内存中。有几种这样的方法。Sugden和Iwanicki使用了一种反馈渲染方法，在第一个渲染通道中写下所有需要的信息，以知道碎片将访问哪个纹理贴图。当传递完成时，纹理被读回CPU并分析哪些贴图是需要的。不驻留的瓦片被读取并映射到物理内存，物理内存中不需要的瓦片被取消映射。他们的方法不适用于阴影、反射和透明度。然而，屏蔽门技术(第5.5节)可以用于透明效果，效果相当好。van Waveren和Hart也使用了反馈渲染。注意，这样的通道可以是一个单独的渲染通道，也可以与z- preass结合使用。当使用单独的通道时，可以使用只有80 × 60像素的分辨率作为近似，以减少处理时间。Hollemeersch等人使用计算通道而不是将反馈缓冲区读入CPU。结果是在GPU上创建一个紧凑的平铺标识符列表，并发送回CPU进行映射。</strong></p>
<p><strong>在GPU支持的虚拟纹理中，驱动程序负责创建和销毁资源，映射和取消贴图，并确保物理分配得到虚拟分配的支持。对于GPU硬件虚拟纹理，sparseTexture查找除了返回过滤后的值(用于常驻贴图)外，还返回一个代码，指示对应的贴图是否常驻。有了软件支持的虚拟纹理，所有这些任务都由开发者来完成。我们参考van Waveren的报告了解更多关于这个主题的信息。</strong></p>
<p><strong>为了确保所有内容都适合物理内存，van Waveren调整全局纹理LOD偏差，直到工作集适合。此外，当只有更高级别的mipmap块可用时，就需要使用更高级别的mipmap块，直到更低级别的mipmap块可用为止。在这种情况下，更高级别的mipmap贴图可以立即升级并使用，然后新的贴图可以随着时间的推移混合在一起，以便在它变得可用时实现平滑过渡。</strong></p>
<p><strong>Barb相反，总是加载所有小于或等于64kb的纹理，因此，一些纹理总是可以完成的，尽管如果还没有加载更高分辨率的mipmap级别，质量会更低。他使用离线反馈渲染来预计算，对于不同的位置，在名义纹理和屏幕分辨率下，每个mipmap级别覆盖了每个材质在玩家周围的多少立体角度。在运行时，这些信息被输入，并根据每种材质的纹理分辨率和最终屏幕分辨率进行调整。这将产生每个纹理、每个mipmap的重要值。然后将每个重要值除以对应的mipmap级别的像素数，生成一个合理的最终度量，因为它是不变的，即使一个纹理被细分为更小的、相同的映射纹理。更多信息请参见Barb的介绍。下图显示了一个示例渲染。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107172752.png" class="" title="image-20211107172752">

<p>在《毁灭战士》(2016)中使用纹理流访问巨大的图像数据库的高分辨率纹理映射。(图片来自游戏《毁灭战士》，由id Software提供)</p>
<p><strong>Widmark描述了如何将流与过程纹理生成相结合，以获得更多样化和更详细的纹理。Chen扩展了Widmark的方案来处理更大数量级的纹理。</strong></p>
<h3 id="Texture-Transcoding-纹理转码"><a href="#Texture-Transcoding-纹理转码" class="headerlink" title="Texture Transcoding 纹理转码"></a>Texture Transcoding 纹理转码</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107172949.png" class="" title="image-20211107172949">

<p>一个使用带有转码的虚拟纹理的纹理流系统。(van Waveren和Hart的插图。)</p>
<p><strong>为了使虚拟纹理系统工作得更好，可以将其与转码结合起来。这是一个从磁盘读取通常使用可变速率压缩方案(如JPEG)压缩的图像，对其进行解码，然后使用GPU支持的纹理压缩方案之一对其进行编码的过程(章节6.2.6)。上图展示了一个这样的系统。反馈渲染通道的目的是确定当前帧需要哪些贴图，章节19.10.1中描述的任何一种方法都可以在这里使用。取取步骤通过存储层次获取数据，从光存储或硬盘驱动器(HDD)，通过一个可选的磁盘缓存，然后通过一个由软件管理的内存缓存。Unmapping指的是释放常驻贴图。当新的数据被读取时，它被转换编码并最终映射到一个新的常驻tile。</strong></p>
<p><strong>使用转码的优点是当纹理数据存储在磁盘上时可以使用更高的压缩比，并且当通过纹理采样器访问纹理数据时使用GPU支持的纹理压缩格式。这既需要对可变速率压缩格式进行快速解压缩，也需要快速压缩到GPU支持的格式。也可以对已经压缩的纹理进行压缩以进一步减小文件大小。这种方法的优点是，当纹理从磁盘读取并解压缩时，它已经是GPU可以使用的纹理压缩格式。使用免费源代码的crunch库使用了类似的方法，结果为每像素1-2位。参见下图中的示例。其继承者称为基，是一种对块具有可变位压缩的专有格式，它可以快速地转换为纹理压缩格式。对于BC1/BC4、BC6H/BC7和PVRTC， GPU上的快速压缩方法是可用的。Sugden和Iwanicki使用Malvar压缩方案的变体来实现磁盘上的可变速率压缩方案。对于法线，他们达到40:1压缩-对于反照率纹理60:1使用YCoCg变换(在第197页的公式6.6中描述)。Khronos正在开发一种用于纹理的标准通用压缩文件格式。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107173125.png" class="" title="image-20211107173125">

<p>转码质量的说明。从左到右:原始的部分鹦鹉图像、眼睛放大后的原始图像(每像素24位)、ETC压缩图像(每像素4位)和压缩后的ETC图像(每像素1.21位)。(图片由Unity压缩。)</p>
<p><strong>当需要高纹理质量且纹理加载时间需要很小时，Olano等人使用可变速率压缩算法将压缩纹理存储在磁盘上。纹理也会在GPU内存中被压缩，直到它们被需要，这时GPU会使用自己的算法来解压缩它们，之后，它们就会以未压缩的形式被使用。</strong></p>
<h3 id="General-Streaming-通用流"><a href="#General-Streaming-通用流" class="headerlink" title="General Streaming 通用流"></a>General Streaming 通用流</h3><p><strong>例如，在模型比物理内存大的游戏或其他实时渲染应用程序中，实际几何体、脚本、粒子和AI也需要流系统。平面可以通过使用三角形、正方形或六边形的正凸多边形进行平铺。因此，这些也是流系统的常见构建块，其中每个多边形都与该多边形中的所有资产相关联。如下图所示。需要注意的是，正方形和六边形最常用，可能是因为它们的近邻比三角形少。查看器位于下图中的深蓝色多边形中，流系统确保直接邻居(浅蓝色和绿色)被加载到内存中。这是为了确保周围的几何图形是可渲染的，并确保当观察者移动到邻近的多边形时数据是存在的。注意，三角形和正方形有两种邻居:一种共享一条边，另一种只共享一个顶点。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107175453.png" class="" title="image-20211107175453">

<p>使用三角形(左)、正方形(中)和六边形(右)的正多边形对二维平面进行平铺。从上方看，贴图通常覆盖在游戏世界上，多边形内的所有资产都与该多边形相关联。假设查看器位于深蓝色的多边形中，相邻的多边形的资源也会被加载。</p>
<p><strong>Ruskin使用六边形，每个六边形都有一个低和高分辨率的几何LOD。由于低分辨率LOD的内存占用很小，所以整个世界的低分辨率LOD都一直在加载。因此，只有高分辨率的LOD和纹理会进出内存。Bentley使用正方形，每个正方形占地100 × 100平方米。高分辨率的mipmaps与其他资产分离。这个系统使用1-3 LODs用于近中距离观看，然后烘培视点替用用于远距离观看。至于赛车游戏，泰克多代替了它随着赛车前进，沿着赛道装载数据。他将使用zip格式压缩的数据存储在磁盘上，并将数据块加载到压缩的软件缓存中。然后根据需要将块解压缩，并由CPU和GPU的内存层次结构使用。</strong></p>
<p><strong>在某些应用中，可能需要平铺三维空间，而不是像上面描述的那样仅仅使用二维平铺。请注意，立方体是唯一的正多面体，也瓷砖三维空间，所以它是这样的应用程序的自然选择。</strong></p>
<h3 id="Terrain-Rendering-地形渲染"><a href="#Terrain-Rendering-地形渲染" class="headerlink" title="Terrain Rendering 地形渲染"></a>Terrain Rendering 地形渲染</h3><p><strong>地形渲染是许多游戏和应用的重要组成部分，例如谷歌Earth和Cesium的大型世界渲染开源引擎。下图显示了一个示例。我们描述了几种在当前GPU上表现良好的流行方法。需要注意的是，这些都可以添加分形噪声，以便在放大地形时提供高水平的细节。此外，许多系统会在加载游戏或关卡时自动生成地形。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107180239.png" class="" title="image-20211107180239">

<p>由航空摄影测量拍摄的钱伯林山50厘米地形和25厘米图像。(图片由Cesium和Fairbanks Fodar提供。)</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107180346.png" class="" title="image-20211107180346">

<p>左:几何剪贴图结构，在每个分辨率级别缓存一个大小相等的正方形窗口。右图:几何图形的俯视图，观察者在中间紫色区域。注意，最精细的关卡渲染整个正方形，而其他关卡则是中空的。(Asirvatham和Hoppe的插图。)</p>
<p><strong>其中一种方法是几何剪贴图。它与texture clipmaps相似，使用了与mipmapping相关的层次结构，即几何体被过滤成一个由越来越粗糙的层次组成的金字塔。如上图所示。在绘制庞大的地形数据集时，只有n × n个样本，即高度，缓存在内存中为查看器周围的每一层。当查看器移动时，上图中的窗口会相应地移动，并加载新的数据，旧的数据可能会被移除。为了避免水平之间的裂缝，每两个连续水平之间使用一个过渡区域。在这样一个过渡级别中，几何和纹理都被平滑地插值到下一个粗糙级别中。这在顶点和像素着色器中实现。Asirvatham和Hoppe提出了一种高效的GPU实现，其中地形数据存储为顶点纹理。顶点着色器访问这些以获得地形的高度。普通地图用于增强地形上的视觉细节，当近距离放大时，Losasso和Hoppe还添加了分形噪声位移以获得进一步的细节。参见下图中的示例。Gollent在《巫师3》中使用了一种几何剪贴图的变体。Pangerl和Torchelsen等人给出了几何剪贴图的相关方法，这些方法也非常适合GPU的能力。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107180457.png" class="" title="image-20211107180457">

<p>几何clipmapping。左:线框渲染，不同的mipmap层次清晰可见。右图:蓝色过渡区域表示水平之间发生插值。(使用微软的“使用几何剪贴图渲染地形”程序生成的图像。)</p>
<p><strong>有几个方案专注于创建tiles和渲染它们。一种方法是将高度场数组分解为每个17 × 17个顶点的tiles。对于一个非常详细的视图，可以渲染一个瓷砖，而不是向GPU发送单独的三角形或小扇子。一个贴图可以有多个细节层次。例如，在每个方向上只使用其他顶点，就可以形成一个9×9贴图。使用第四个顶点得到一个5 × 5的贴图，每8个顶点得到一个2 × 2的贴图，最后四个角得到一个由两个三角形组成的1 × 1的贴图。需要注意的是，原来的17 × 17顶点缓冲区可以存储在GPU上并重复使用;只需要提供不同的索引缓冲区来更改呈现的三角形的数量。接下来介绍一种使用此数据布局的方法。</strong></p>
<p><strong>另一种在GPU上快速绘制大型地形的方法叫做分块LOD。这个想法是使用n个离散的细节层次来表示地形，其中每个更细的LOD与其父LOD相比被分割4倍，如下图所示。然后将该结构编码到四叉树中，并从根遍历以进行呈现。当一个节点被访问时，如果它的屏幕空间错误(将在下面的描述)低于某个像素错误阈值τ，它将被渲染。否则，将递归访问四个子节点。这将在需要的地方产生更好的分辨率，例如，靠近查看器。在一个更高级的变体中，地形四元根据需要从磁盘加载。遍历与上面描述的方法类似，不同之处在于，只有当子节点已经(从磁盘)加载到内存中时，才会递归地访问它们。如果未加载，则将它们排队等待加载，并呈现当前节点。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107180624.png" class="" title="image-20211107180624">

<p>地形的分块LOD表示。(图片由撒切尔·乌尔里希提供。)</p>
<p><strong>Ulrich将屏幕空间错误计算为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107180650.png" class="" title="image-20211107180650">

<p><strong>w是屏幕的宽度,d是相机的距离地面瓷砖,θ是弧度的水平视野,ǫ是几何误差在同一单位作为几何误差项,d。经常使用两个网格之间的Hausdorf距离。对于原始网格上的每个点，找到其在简化网格上最近的点，并将这些距离中最小的称为d1．现在对简化后的网格上的每个点执行相同的过程，找到原始网格上最近的点，并将距离的最小值称为d2．Hausdorff距离为ε = max(d1,d2)．如下图所示。注意，从o点到简化网格的最近点是s，而从s点到原始网格的最近点是a，这就是为什么必须在两种组合中进行测量的原因，从原始网格到简化网格，反之亦然。直观上，Hausdorff距离是用简化网格代替原始网格时的误差。如果应用程序无法计算Hausdorff距离，则可以使用为每次简化而手工调整的常数，或者查找简化过程中的错误。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107181018.png" class="" title="image-20211107181018">

<p>原始网格与简化网格之间的Hausdorff距离。(参考Sellers等人的插图。)</p>
<p><strong>为了避免在从一个LOD切换到另一个LOD时产生弹出效果，Ulrich提出了一种简单的变形技术，即从高分辨率贴图中的顶点(x, y, z)与顶点(x, y′，z)线性插值，这是从父贴图近似得到的(例如，使用双线性插值)。线性插值因子计算为2sτ−1，固定在[0,1]。注意，在变形过程中只需要高分辨率的贴图，因为下一个低分辨率的贴图的顶点也在高分辨率的贴图中。</strong></p>
<p><strong>启发法，如公式19.10中的启发法，可以用来确定每个贴图的细节级别。瓷砖方案的主要挑战是裂纹修复。例如，如果一个砖块的分辨率是33 × 33，而它的相邻砖块的分辨率是9 × 9，那么它们相遇的边缘就会出现裂缝。一种矫正措施是沿着边缘去除高度细节化的三角形，然后形成一组恰当地连接两个瓷砖之间的三角形。当两个相邻区域的细节水平不同时，就会出现裂缝。Ulrich描述了一种使用额外的带状几何的方法，如果τ被设置为小于5像素，这是一个合理的解决方案。Cozzi和Bagnell使用屏幕空间的后处理通道填充裂缝，其中裂缝周围的碎片，而不是裂缝内部的碎片，使用高斯核加权。Strugar采用了一种优雅的方法来避免裂缝，无需使用屏幕空间方法或额外的几何形状。如下图所示，可以用一个简单的顶点着色器实现。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107181030.png" class="" title="image-20211107181030">

<p>使用Strugar的分块LOD系统来避免裂纹。左上角显示了一个高分辨率的贴图，它在右上方变成了一个低分辨率的地形贴图。在这两者之间，我们展示了两个插值和变形的变体。实际上，当LOD发生改变时，这是以一种平滑的方式发生的，这在底部的屏幕截图中显示。(下图由Filip Strugar的程序生成。)</p>
<p><strong>为了提高性能，Sellers等人将分块LOD与视图截锥剔除和水平剔除结合起来。Kang等人提出了一种类似于分块LOD的方案，最大的区别是他们使用基于GPU的镶嵌对节点进行镶嵌，并确保边缘镶嵌因子匹配以避免裂缝。它们还展示了具有特征保留地图的几何图像是如何实现的用于渲染带有悬垂的地形，这是基于高度场的地形无法处理的。Strugar提出了分块LOD方案的扩展，三角形的分布更好、更灵活。与Ulrich的方法(使用每个节点的LOD)不同，Strugar使用具有单个细节级别的每个顶点的变形。虽然他只使用距离作为确定LOD的衡量标准，但也可以使用其他因素，如附近有多少深度变化，这可以生成更好的轮廓。</strong></p>
<p><strong>源地形数据通常用均匀高程网格表示。可以对这些数据使用与视图无关的简化方法，如图705页的图16.16所示。对模型进行简化，直到满足某一极限准则。小的表面细节可以通过颜色或凹凸贴图纹理捕获。生成的静态网格通常称为不规则三角网(TIN)，当地形面积较小且各区域相对平坦时，它是一种有用的表示方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107181325.png" class="" title="image-20211107181325">

<p>地形贴图的一种受限四叉树，其中每个贴图最多可以与相邻的贴图在细节层次上高一点或低一点。每个贴图有5 × 5个顶点，除了左上角，那里有2 × 2个更高分辨率的贴图。其余的地形由三个低分辨率的贴图填充。在左侧，左上方的贴图边缘上的顶点与相邻的低分辨率贴图上的顶点不匹配，这将导致开裂。在右侧，更详细的贴图的边缘被修改以避免这个问题。每个贴图在一个单独的绘制调用中呈现。(Andersson后面的插图)</p>
<p><strong>Andersson使用受限四叉树来弥补缺口，并降低大型地形所需的draw调用总数。他使用的不是以不同分辨率呈现的瓷砖的统一网格，而是瓷砖的四叉树。每个贴图都有相同的33 × 33分辨率，但每个贴图可以覆盖不同数量的区域。受限四叉树的理念是，每个贴图的邻居之间的细节差异不能超过一个层次。参见上图。这种限制意味着相邻贴图的分辨率不同的情况是有限的。与其创建间隙并渲染额外的索引缓冲区来填充这些间隙，我们的想法是存储所有可能的索引缓冲区的排列，从而创建一个包含间隙过渡三角形的平铺。每个索引缓冲区由全分辨率构成边(一条边上有33个顶点)和较低层次的细节边(只有17个顶点，因为四叉树是受限制的)。下图显示了一个现代地形渲染的例子。Widmark描述了一个完整的地形渲染系统，在Frostbite 2引擎中使用。它有有用的功能，如贴花，水，地形装饰，使用艺术家生成的或程序生成的遮罩的不同材质着色器的组成，和程序地形位移。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107181339.png" class="" title="image-20211107181339">

<p>地形渲染在许多层次的细节在行动。(Courtesy of DICE, c 2016 Electronic Arts Inc.)</p>
<p><strong>一种用于海洋渲染的简单技术是使用统一的网格，将每一帧转换到相机空间。如下图所示。鲍尔斯提供了许多克服某些质量问题的技巧。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107181513.png" class="" title="image-20211107181513">

<p>左:一个统一的网格。右图:网格转化为摄像机空间。请注意转换后的网格是如何让查看者更接近更高的细节的。</p>
<p><strong>除了上述的地形技术(它倾向于减少需要随时保存在内存中的数据集的大小)，还可以使用压缩技术。Yusov使用四叉树数据结构压缩顶点，使用一个简单的预测方案，其中只有差异被编码(使用少量位)。Schneider和Westermann使用由顶点着色器解码的压缩格式，并探索细节层次之间的地貌，同时最大化缓存一致性。Lindstrom和Cohen使用具有线性预测和残差编码的流编解码器进行无损压缩。此外，它们使用量化来进一步提高压缩率，尽管结果是有损的。解压可以使用GPU完成，压缩率从3:1到12:1。</strong></p>
<p><strong>还有许多其他的地形渲染方法。Kloetzli在《文明V》中使用自定义计算着色器为地形创建自适应镶嵌，然后将其提供给GPU进行渲染。另一种技术是使用GPU的镶嵌器来处理每个补丁的镶嵌。注意，许多用于地形渲染的技术也可以用于水渲染。例如，Gonzalez- Ochoa和Holder在《神秘海域3》中使用了一种适合于水的几何剪辑地图。他们通过在关卡之间动态添加三角形来避免T形连接。随着GPU的发展，这方面的研究还将继续。</strong></p>
<h1 id="20-Efficient-Shading-高效着色"><a href="#20-Efficient-Shading-高效着色" class="headerlink" title="20 Efficient Shading 高效着色"></a>20 Efficient Shading 高效着色</h1><p><strong>对于简单的场景——相对较少的几何图形，基本的材质，少量的灯光——我们可以使用标准的GPU管线来渲染图像，而不用担心保持帧率。只有当一个或多个元素变得昂贵时，我们才需要使用更复杂的技术来控制成本。在前一章中，我们重点讨论了从后续处理中剔除三角形和网格。在这里，我们专注于在评估材料和灯光时降低成本的技术。对于许多这些方法，有额外的处理费用，希望这笔费用由所节省的费用弥补。另一些则在带宽和计算之间进行权衡，经常转移瓶颈。与所有此类方案一样，最佳方案取决于硬件、场景结构和许多其他因素。</strong></p>
<p><strong>评估一个材质的像素着色器是很昂贵的。这个成本可以通过各种着色器级别的细节简化技术来降低，如第19.9节所述。当有几个光源影响一个表面时，可以采用两种不同的策略。一个是创建一个支持多个光源的着色器，这样只需要一个通道。另一个是多通道着色，我们为一个光创建一个简单的单光像素着色器，并对它进行评估，将每个结果添加到帧缓冲区中。因此，对于三盏灯，我们会绘制三次原语，为每一次评估改变灯光。第二种方法可能比单通道系统更有效，因为每个着色器使用更简单和更快。如果一个渲染器有许多不同类型的光，一个一次性的像素着色器必须包括它们所有，并测试每一个是否被使用，使一个复杂的着色器。</strong></p>
<p><strong>在第18.4.5节中，我们讨论了通过最小化或消除透支来避免不必要的像素着色器评估。如果我们可以有效地确定一个表面对最终图像没有影响，那么我们就可以节省花在着色上的时间。一种技术执行z- preass，其中渲染不透明的几何图形，只写入z-depth。几何图形再次完全着色，第一次通过的z-buffer会剔除所有不可见的片段。这种类型的通过是一个尝试去耦的过程，从发现什么几何体是可见的操作，随后着色该几何体。将这两个过程分离的想法是贯穿本章的一个重要概念，并且被一些替代的渲染方案所采用。</strong></p>
<p><strong>例如，使用z- preass的一个问题是，你必须渲染几何图形两次。与标准渲染相比，这是一种额外的开销，而且花费的时间可能比节省的时间要多。如果网格是通过镶嵌、蒙皮或其他一些涉及的过程形成的，这一添加通道的成本可能是相当大的。带有剪切alpha值的对象需要在每次通过时都获得其纹理的alpha值，这增加了成本，或者必须完全忽略并只在第二次通过时进行渲染，这可能会浪费像素着色器的评估。由于这些原因，有时在这个初始过程中只绘制大的遮挡(屏幕或世界空间)。其他屏幕空间效果(如环境遮挡或反射)也可能需要执行完整的预渲染。在本章中介绍的一些加速技术需要一个精确的z- preass，然后用来帮助筛选光的列表。</strong></p>
<p><strong>即使没有透支，为可见表面评估大量动态光源也会产生巨大的费用。假设你在一个场景中有50个光源。一个多通道系统可以成功渲染场景，但代价是每个对象经过50个顶点和着色器。降低成本的一种技术是将每个局部光源的效果限制在一个半径一定的球体、一定高度的圆锥或其他有限形状上。假设每一种光的作用在超过一定距离后就变得微不足道。在本章的剩余部分，我们将把灯的体积称为球体，同时理解其他形状也可以使用。通常光的强度是决定其半径的唯一因素。Karis讨论了有光泽的镜面材料的存在将如何增加这个半径，因为这样的表面受光线的影响更明显。对于非常光滑的表面，这个距离可能会无穷大，因此可能需要使用环境地图或其他技术。</strong></p>
<p><strong>一个简单的预处理是为每个网格创建一个影响它的光的列表。我们可以把这个过程看作是在网格和光线之间执行碰撞检测，发现那些可能重叠的。当给网格着色时，我们使用这个灯光列表，从而减少应用的灯光数量。这种方法存在一些问题。如果物体或灯光移动，这些变化会影响列表的组成。为了提高性能，共享相同材质的几何体通常被合并到更大的网格中(章节18.4.2)，这可能导致单个网格在其列表中包含场景中的一些或所有灯光。也就是说，网格可以合并，然后在空间上进行分割，以提供更短的列表。</strong></p>
<p><strong>另一种方法是将静态光烘烤到世界空间数据结构中。例如，在《Just Cause 2》的照明系统中，世界空间自上而下的网格存储场景的照明信息。网格单元格代表一个4米× 4米的区域。每个细胞都以像素的形式存储在RGBα纹理中，因此拥有一个最多4个光源的列表。当渲染一个像素时，检索其区域内的列表并应用相关的光。缺点是存储数量有一个固定的限制影响给定区域的灯光。虽然可能对精心设计的室外场景有用，但有许多层的建筑可以迅速压倒这种存储方案。</strong></p>
<p><strong>我们的目标是以一种有效的方式处理动态网格和灯光。同样重要的是可预测的性能，在视图或场景中的一个小变化不会导致渲染成本的大变化。《毁灭战士》(2016)中的某些关卡有300个可见光;《奇点灰烬》中的一些场景有10000个。参见下图和第913页的图20.15。在一些渲染器中，大量的粒子可以被视为小光源。其他技术使用光探头(第11.5.4节)照亮附近的表面，可以认为是短程光源。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108124656.png" class="" title="image-20211108124656">

<p>一个复杂的照明情况。注意肩膀上的小光源和建筑结构上的每个亮点都是光源。右上方远处的灯光是光源，它们被渲染为该距离的点精灵。(图片来自雪崩工作室提供的《正当防卫3》。)</p>
<h2 id="Deferred-Shading-延迟渲染"><a href="#Deferred-Shading-延迟渲染" class="headerlink" title="Deferred Shading 延迟渲染"></a>Deferred Shading 延迟渲染</h2><p><strong>到目前为止，在本书中，我们已经描述了前向着色，即每个三角形沿管线向下发送，在其旅行的最后，屏幕上的图像将更新其着色值。延迟着色背后的想法是在执行任何材料照明计算之前执行所有可见性测试和表面属性评估。该概念最早于1988年在硬件架构中引入，后来作为实验性PixelFlow系统的一部分，并作为离线软件解决方案，通过图像处理帮助生成非照片真实风格。Calver在2003年中期的文章中阐述了基本的在GPU上使用延迟着色的想法。Hargreaves和Harris和Thibieroz在第二年推广了它的使用，当时书写多个渲染目标的能力正变得越来越普遍。</strong></p>
<p><strong>在前向着色中，我们使用一个着色器和一个网格来计算最终的图像。通道获取材质属性——常量、插值参数或纹理中的值——然后对这些值应用一组光。前向渲染的z- preass方法可以被看作是几何渲染和着色的轻度解耦，因为第一个几何通道的目的只是确定可见性，而所有的着色工作，包括材料参数检索，被推迟到第二个几何通道执行，以着色所有可见像素。对于交互式渲染，延迟着色特别意味着所有与可见对象相关的材质参数都是通过初始几何通道生成和存储的，然后使用后处理将光线应用到这些存储的表面值。保存在第一个通道的值包括位置(存储为z-depth)、法线、纹理坐标和各种材质参数。这个通道为像素建立了所有的几何和材料信息，所以对象不再需要，即模型的几何形状的贡献已经完全从照明计算中分离出来。注意，在这个初始过程中可能会发生透支，不同的是着色器的执行是相当少的将值传输到缓冲区，而不是评估一组光对材质的影响。在正向着色中也有更少的额外成本，有时2×2四边形中的所有像素都在三角形的边界内，但所有像素都必须完全着色(章节23.8)。这听起来像是一个小效果，但想象一个网格，其中每个三角形覆盖一个像素。将生成四个完全着色的样本，其中三个用正向着色丢弃。使用延迟着色，每个着色器调用的代价更低，因此丢弃的样本的影响相当低。</strong></p>
<p><strong>用来存储表面属性的缓冲器通常被称为G -缓冲器，是“几何缓冲器”的缩写。这种缓冲区有时也被称为深度缓冲区，尽管这个术语也可以指每个像素存储多个表面(碎片)的缓冲区，所以我们在这里避免使用它。下图显示了一些G -buffer的典型内容。一个G缓冲区可以存储任何程序员想要它包含的东西，例如来完成所需的后续光照计算。每个G-buffer都是一个单独的渲染目标。通常情况下，3到5个渲染目标被用作G缓冲区，但系统已经高达8个。拥有更多的目标将使用更多的带宽，这将增加该缓冲区成为瓶颈的可能性。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108134114.png" class="" title="image-20211108134114">

<p>用于延迟着色的几何缓冲，在某些情况下转换为颜色以实现可视化。左列，从上到下:深度映射，正常缓冲区，粗糙度缓冲区，和阳光遮挡。右栏:纹理颜色(也就是反照纹理)，光强度，镜面强度和接近最终的图像(没有运动模糊)。(图片来自Guerrilla BV提供的《杀戮地带2》。)</p>
<p><strong>创建G -buffer之后，使用一个单独的进程来计算光照效果。一种方法是一个接一个地应用每个光，使用G缓冲器来计算它的效果。对于每个光源，我们绘制一个屏幕填充四边形(章节12.1)，并访问G缓冲区作为纹理。在每个像素上，我们可以确定最近的表面的位置，以及它是否在光线的范围内。如果是，我们计算光的效果，并将结果放入输出缓冲区。我们依次为每个光做这个，通过混合添加它的贡献。最后，我们应用了所有灯光的贡献。</strong></p>
<p><strong>这个过程是使用G缓冲区最低效的方式，因为每个存储的像素都被访问每个光，类似于基本的正向渲染将所有的光应用到所有的表面碎片。由于写入和读取G缓冲区的额外成本这种方法最终可能会比前向着色慢。作为一个开始为了提高性能，我们可以确定一个轻体(球体)的屏幕边界，并用它们绘制一个覆盖图像较小部分的屏幕空间四边形。以这种方式，像素处理被减少，通常是显著的。绘制一个代表球体的椭圆可以进一步修剪光线体积之外的像素处理。我们还可以使用第三个屏幕尺寸，z深度。通过绘制一个包含体积的粗略球体网格，我们可以进一步修剪球体的效果区域。例如，如果球体被深度缓冲隐藏，光的体积就在最近的表面后面，所以没有效果。概括地说，如果球体在一个像素处的最小深度和最大深度没有重叠最近的表面，那么光线就不能影响这个像素。Hargreaves和Valient讨论了有效、正确地确定这种重叠的各种选项和注意事项，以及其他优化方法。我们将看到在前面的几个算法中测试表面和光线之间的深度重叠。哪种效率最高取决于具体情况。</strong></p>
<p><strong>对于传统的正向渲染，顶点和像素着色程序检索每个光和材料的参数，并计算一个对另一个的影响。前向着色需要一个复杂的顶点和像素着色器来覆盖所有可能的材质和灯光组合，或者更短的、专门的着色器来处理特定的组合。带有动态分支的长着色器通常运行得相当慢，所以大量较小的着色器可以更高效，但也需要更多的工作来生成和管理。由于所有的着色功能都是在一个单一的过程中通过正向着色完成的，当下一个物体被渲染时，着色器很可能需要改变，这导致了交换着色器的效率低下(章节18.4.2)。</strong></p>
<p><strong>渲染的延迟着色方法允许光照和材质定义之间的强烈分离。每个着色器专注于参数提取或照明，但不是两者。较短的着色器运行得更快，这是由于长度和优化它们的能力。着色器中使用的寄存器的数量决定了占用率(章节23.3)，这是有多少着色器实例可以并行运行的关键因素。灯光和材质的解耦也简化了材质系统的管理。例如，这种分离使得实验变得容易，因为只需要为一个新的光源或材料类型添加一个新的着色器到系统中，而不是为每个组合添加一个。这是可能的，因为材料评估在第一次通过，然后照明应用到这个存储的表面参数集在第二次通过。</strong></p>
<p><strong>对于单通道前向渲染，所有的阴影贴图通常必须同时可用，因为所有的灯光都是一次性评估的。由于每个光都被完全处理在一个单通道中，延迟着色允许在内存中一次只有一个阴影贴图。然而，这种优势随着我们后面介绍的更复杂的光分配方案而消失，因为光是分组评估的。</strong></p>
<p><strong>基本的延迟着色只支持一个单一的材质着色器和一组固定的参数，这限制了什么材质模型可以被描绘。支持不同材质描述的一种方法是存储每个像素的材质ID或蒙版一些给定的字段。然后着色器可以根据G缓冲区的内容执行不同的计算。这种方法还可以根据ID或掩码值修改G缓冲区中存储的内容。例如，一种材料可能使用32位存储第二层颜色和混合因子在G缓冲区，而另一种材料可能使用这些相同的位存储它需要的两个切向量。这些方案需要使用更复杂的着色器，这可能会有性能影响。</strong></p>
<p><strong>基本的延迟着色还有其他一些缺点。G-buffer的显存需求可能非常大，重复访问这些缓冲区的相关带宽成本也是如此。我们可以通过存储精度较低的值或压缩数据来降低这些成本。下图显示了一个示例。在第16.6节中，我们讨论了网格的世界空间数据压缩。G-buffers可以包含世界空间或屏幕空间坐标中的值，这取决于渲染引擎的需要。Pesce讨论了G缓冲区在压缩屏幕空间和世界空间法线时的权衡，并提供了指向相关资源的指针。世界空间的八面体法线映射是一种常见的解决方案，因为它具有高精度和快速的编码和解码时间。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108134440.png" class="" title="image-20211108134440">

<p>一个可能的G缓冲布局的例子，在彩虹6围攻中使用。除了深度和模具缓冲，四个渲染目标(RTs)也被使用。可以看到，任何东西都可以放到这些缓冲区中。RT0中的“GI”字段为“GI正常偏置(A2)”。(以El Mansouri为例。)</p>
<p><strong>延迟着色的两个重要技术限制涉及透明度和抗锯齿。基本的延迟着色系统不支持透明度，因为每个像素只能存储一个表面。一种解决方案是在不透明表面使用延迟着色后对透明对象使用前向渲染。对于早期的延迟系统，这意味着场景中的所有灯光都必须应用到每个透明物体上，这是一个昂贵的过程，或者必须执行其他简化操作。正如我们将在接下来的章节中探索的那样，改进的GPU能力已经导致了对延迟着色和前向着色剔除光的方法的开发。虽然现在可以存储像素的透明表面列表，并使用纯延迟方法，但规范是混合延迟和前向着色，以满足透明度和其他效果的需要。</strong></p>
<p><strong>正演方法的一个优点是容易支持诸如MSAA这样的抗锯齿方案。对于N× MSAA，正向技术只需要每个像素存储N个深度和颜色样本。延迟着色可以将每个元素的所有N个样本存储在G -buffer中以执行反锯齿，但内存成本、填充率和计算量的增加使这种方法代价高昂。为了克服这个限制，Shishkovtsov使用边缘检测方法来逼近边缘覆盖计算。其他形态学后处理方法用于抗走样(章节5.4.2)也可以使用，以及时间反走样。几种延迟MSAA方法通过检测哪些像素或瓦片有边缘来避免计算每个样本的着色。只有那些有边缘的需要对多个样本进行评估。Sousa基于这种方法，使用模板识别需要更复杂处理的多个样本像素。Pettineo描述了一种跟踪此类像素的新方法，使用计算着色器将边缘像素移动到线程组内存中的列表中，以实现高效的流处理。</strong></p>
<p><strong>Crassin等人的抗锯齿研究注重高质量的结果，并总结了该领域的其他研究。他们的技术执行深度和法向几何学预压，并将类似的子样品分组在一起。然后，他们生成G缓冲，并对每组子样本使用的最佳值进行统计分析。然后使用这些深度边界值为每个组着色，并将结果混合在一起。虽然在撰写本文时，这种以交互速度进行的处理对于大多数应用程序来说是不切实际的，但这种方法可以让我们了解到能够并将用于改善图像质量的计算能力的数量。</strong></p>
<p><strong>即使有这些限制，延迟着色仍然是商业程序中使用的一种实用的渲染方法。它自然地从阴影中分离几何，从材料中分离照明，这意味着每个元素都可以自行优化。一个特别感兴趣的领域是贴花渲染，它对任何渲染管线都有影响。</strong></p>
<h2 id="Decal-Rendering-贴花渲染"><a href="#Decal-Rendering-贴花渲染" class="headerlink" title="Decal Rendering 贴花渲染"></a>Decal Rendering 贴花渲染</h2><p><strong>贴花是一些设计元素，如图片或其他纹理，应用在表面的顶部。在电子游戏中，贴花通常以轮胎印、弹孔或玩家标签等形式出现。贴花用于应用标识、注释或其他内容的其他应用。例如，对于地形系统或城市，贴花可以让艺术家通过在细节纹理上分层或以不同方式重新组合各种图案来避免明显的重复。</strong></p>
<p><strong>贴花可以通过多种方式与底层材料混合。它可能会修改潜在的颜色，但不会修改凹凸贴图，比如纹身。或者，它可能只是替换凹凸贴图，比如浮雕logo。它可以定义一种完全不同的材料，例如，在车窗上贴一个贴纸。多个贴花可以应用到相同的几何图形上，例如路径上的脚印。一个贴花可能跨越多个模型，比如地铁车厢表面的涂鸦。这些变化对正向和延迟遮阳系统存储和处理贴花的方式有影响。</strong></p>
<p><strong>首先，贴花必须像其他纹理一样映射到表面。由于多个纹理坐标可以存储在每个顶点，它可以绑定一些贴花到一个单一的表面。这种方法是有限的，因为值的数量每个顶点可以保存的相对较低。每个贴花需要它自己的一组纹理坐标。大量的小贴花应用到一个表面意味着在每个顶点保存这些纹理坐标，即使每个贴花只影响网格中的几个三角形。</strong></p>
<p><strong>要将贴花渲染到网格上，一种方法是让像素着色器采样每个贴花，并将一个贴花混合在另一个贴花之上。这使着色器变得复杂，如果贴花的数量随时间变化，可能需要频繁的重新编译或其他措施。另一种保持着色器独立于贴花系统的方法是为每一个贴花再次渲染网格，分层和混合每一个通道在前一个。如果一个贴花仅仅跨越了几个三角形，那么可以创建一个单独的、较短的索引缓冲区来渲染这个贴花的子网格。另一种贴花方法是修改材料的纹理。如果只在一个网格上使用，比如在一个地形系统中，修改这个纹理提供了一个简单的“设置它然后忘记它”的解决方案。如果材质纹理被用在一些物体上，我们需要创建一个新的材质和贴花合成在一起。这个烘焙解决方案避免了着色器的复杂性和浪费的透支，但代价是纹理管理和内存使用。分别渲染贴花是一种规范，因为不同的分辨率可以应用到相同的表面，并且基础纹理可以重复使用，而不需要在内存中添加额外的修改副本。</strong></p>
<p><strong>这些解决方案对于计算机辅助设计包来说是合理的，用户可以只添加一个标识，其他的就很少了。它们也用于贴花应用到动画模型，其中贴花需要在变形前被投影，这样它就像对象一样拉伸。然而，这种技术变得效率低下和繁琐的超过几个贴花。</strong></p>
<p><strong>对于静态或刚性物体，一种流行的解决方案是将贴花处理为通过有限体积投影的纹理。一个有方向的盒子被放置在场景中，贴花从盒子的一个面投射到另一个面，就像电影放映机一样。参见下图。盒子的表面被栅格化，作为一种驱动像素着色器执行的方法。任何几何发现在这个卷有贴花应用在其材料。这是通过将表面的深度和屏幕位置转换为体积中的一个位置来完成的，然后为贴花提供一个(u, v)纹理坐标。另外，贴花可以是一个真正的卷纹理。通过分配ID、分配模板位或依赖于渲染顺序，贴花只能影响体积中的某些对象。它们也经常褪色或夹紧到表面和投影方向的角度，以避免在表面变得更接近边缘的地方产生贴花拉伸或扭曲。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108134929.png" class="" title="image-20211108134929">

<p>一个方框定义了一个贴花投影，在该方框内的表面应用贴花。盒子被用夸张的厚度显示，以显示投影仪及其效果。在实践中，盒子被做得尽可能的薄和紧的表面，以减少在贴花应用过程中测试的像素数量。</p>
<p><strong>延迟遮光在渲染这类贴花方面很出色。与标准的前向着色不同的是，贴花的效果可以应用到G -缓冲器上。例如，如果一个轮胎的胎面标记的贴花取代了表面上的阴影法线，这些变化是直接对适当的G缓冲。每个像素随后仅使用G -buffer中的数据进行灯光着色，从而避免了前向着色时发生的着色透支。自贴花的效果可以完全被G缓冲存储器捕获，贴花在遮光期间就不需要了。这种集成还避免了多通道前向着色的问题，即一个通道的表面参数可能会影响另一个通道的光照或着色。这种简单性是决定Frostbite 2引擎从正向着色切换到延迟着色的主要因素，例如贴花可以被认为与灯光相同，因为它们都是通过渲染空间来确定其在封闭表面上的效果。正如我们将在第20.4节中看到的，通过使用这一事实，经过修改的前向着色形式可以利用类似的效率和其他优势。</strong></p>
<p><strong>Lagarde和de Rousiers描述了延迟设置中贴花的几个问题。在管线的合并阶段，混合操作受限于可用的操作。如果材料和贴花都有法线贴图，实现适当的混合结果可能是困难的，如果使用一些凹凸纹理过滤技术就更难了。可以出现黑色或白色边缘工件，如第6.5节所述。有符号距离场等技术可以用来对这些材料进行精确分割，尽管这样做可能会导致混叠问题。另一个问题是贴花的轮廓边缘，这是由于将屏幕空间的信息投影回世界空间而导致的梯度误差造成的。一种解决方案是限制或忽略此类贴花的mipmapping;Wronski讨论了更详细的解决方案。</strong></p>
<p><strong>贴花可以用于动态元素，如刹车痕迹或弹孔，但也可以用于给不同的位置一些变化。下图显示了一个应用于建筑墙壁和其他地方的贴花场景。墙壁纹理可以重复使用，而贴花提供定制的细节，给每个建筑一个独特的特点。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108135211.png" class="" title="image-20211108135211">

<p>在顶部的图像中，颜色和凹凸贴花重叠的区域用棋盘显示。中间是没有贴花的建筑。下面的图片显示了应用了大约200个贴花的场景。(图片由IO Interactive提供。)</p>
<h2 id="Tiled-Shading-平铺着色"><a href="#Tiled-Shading-平铺着色" class="headerlink" title="Tiled Shading 平铺着色"></a>Tiled Shading 平铺着色</h2><p><strong>在基本的延迟着色中，每个光源被分别计算，结果被添加到输出缓冲区中。这是早期GPU的一个特性，由于着色器复杂性的限制，评估多个光源是不可能的。延迟着色可以处理任意数量的灯光，代价是每次都要访问G -buffer。对于成百上千的光源，基本的延迟着色变得非常昂贵，因为所有的光源都需要为每个重叠的像素处理，并且每个像素上的光源都需要单独的着色器调用。在一个着色器调用中评估几个光源更有效。在接下来的章节中，我们将讨论几种算法，用于在交互速率下快速处理大量的光，包括延迟着色和前向着色。</strong></p>
<p><strong>多年来，人们开发了各种混合G缓冲系统，在材料和光存储之间实现了平衡。例如，想象一个带有漫反射和高光术语的简单着色模型，其中材质的纹理只影响漫反射术语。我们可以先分别计算每个光的漫反射和镜面条件，然后存储这些结果，而不是从G缓冲中获取每个光的纹理颜色。这些累积的项被加在基于光的G缓冲器中，有时也被称为L缓冲器。最后，我们检索纹理的颜色一次，乘以漫反射项，然后添加镜面。纹理的效果被排除在等式之外，因为它只对所有的光使用一次。通过这种方式，每次光访问更少的G缓冲区数据点，节省了带宽。一个典型的存储方案是累积漫反射颜色和镜面强度，这意味着四个值可以通过加性混合输出到一个缓冲区。Engel讨论了几种早期延迟照明技术，也被称为预照明或光预压方法。Kaplanyan比较了不同的方法，旨在最小化G缓冲区的存储和访问。Thibieroz也强调了较浅的G缓冲器，对比了几种算法的优缺点。Kircher描述了使用低分辨率的G缓冲器和L缓冲器进行照明，它们在最后的前向着色过程中进行上采样和双边滤波。这种方法在某些材质上效果很好，但如果光照的效果变化很快，就会产生伪影，例如，将粗糙度或法线贴图应用到反射表面上。Sousa等人使用了子采样和反照率纹理的Y ‘CbCr颜色编码的思想，以帮助降低存储成本。反照率影响扩散分量，而扩散分量不太容易受到高频变化的影响。</strong></p>
<p><strong>还有很多这样的方案，每个方案都不同，比如哪些组件被存储和分解，执行哪些通道，以及如何渲染阴影、透明度、抗锯齿和其他现象。所有这些技术的一个主要目标是相同的——高效地渲染光源——这种技术至今仍在使用。一些方案的一个限制是，它们可能需要更严格的材料和照明模型。例如，Shulz指出，向基于物理的材料模型移动意味着需要存储镜面反射率，以根据光照计算菲涅尔项。光照预压要求的增加帮助他的团队从光照预压系统转移到完全延迟的着色系统。</strong></p>
<p><strong>即使每光访问少量的G -buffer也会产生巨大的带宽成本。更快的方法是在一次通过中只评估影响每个像素的光。Zioma是最早探索创建前向着色光源列表的人之一。在他的方案中，光体被渲染，光的相对位置、颜色和衰减因子被存储在每个重叠像素上。深度剥离用于存储重叠相同像素的光源信息。然后使用存储的光表示来渲染场景的几何图形。虽然可行，但这个方案受限于任何像素可以重叠的光线数量。Trebilco进一步提出了每像素创建光列表的想法。他执行z- preass，以避免透支和剔除隐藏的光源。光体被渲染并存储为每个像素的ID值，然后在正向渲染过程中访问这些值。他给出了几种在单个缓冲区中存储多个光源的方法，包括位移和混合技术，该技术允许在不需要多次深度剥离通道的情况下存储四个光源。</strong></p>
<p><strong>2008年，Balestra和Engstad在《Uncharted: Drake’s Fortune》中首次提出了贴图着色，随后又介绍了它在Frostbite engine和PhyreEngine中的使用情况。平铺底纹的核心思想是将光源分配给像素平铺，从而限制每个表面需要评估的光源数量，以及所需的工作量和存储空间。这些每个平铺的光源列表然后在一个着色器调用中被访问，而不是延迟的着色方法为每个光源调用一个着色器。</strong></p>
<p><strong>用于灯光分类的贴图是屏幕上的一组方形像素，例如，大小为32 × 32像素。注意，还有其他方法可以用于交互式渲染;例如，移动处理器通过处理贴图来渲染图像，GPU架构使用屏幕贴图来完成各种任务(第23章)。在这里，tiles是由开发人员选择的构造，通常与底层硬件关系不大。光体的平铺渲染有点像场景的低分辨率渲染，可以在CPU上执行，也可以在GPU上的计算着色器中执行。</strong></p>
<p><strong>可能影响贴图的灯光记录在一个列表中。当执行渲染时，给定平铺中的像素着色器使用平铺对应的灯光列表来给表面着色。下图的左侧说明了这一点。可以看到，不是所有的灯光都与每个贴图重叠。贴图的屏幕空间边界形成了一个不对称的截锥，用于确定重叠。每个光的球形体积效果可以在CPU上快速测试，或者在计算着色器中与每个贴图的截锥重叠。只有当有重叠时，我们才需要为贴图中的像素进一步处理光线。通过存储每个贴图而不是每个像素的光列表，我们错误地倾向于保守——一个光的体积可能不会重叠整个贴图——以大大减少处理、存储和带宽成本。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108140004.png" class="" title="image-20211108140004">

<p>瓷砖的插图。左图:画面被划分为6 × 6的贴图，3个光源(1-3)照亮了这个场景。观察A - C瓦片，我们可以看到A瓦片受到灯光1和2的影响，B瓦片受到灯光1 - 3的影响，C瓦片受到灯光3的影响。右图:从上方可以看到左边的黑色线条。对于平铺B，深度边界用红线表示。在屏幕上，砖块B似乎与所有灯光重叠，但只有灯光1和2与深度边界重叠。</p>
<p><strong>为了确定光线是否与贴图重叠，我们可以对球体使用截锥测试，这在22.14节中有描述。这里的测试假定一个大而宽的截锥和相对较小的球体。然而，由于这里的截锥来自屏幕空间贴图，它通常是又长又细且不对称的。这降低了筛选的效率，因为报告的交叉点的数量可以增加(即假阳性)。参见下图的左侧部分。相反，在对截锥的平面进行测试之后，可以添加一个球/箱测试(章节22.13.2)，如下图中的右侧所示。Mara和McGuire对投影球体进行了替代测试，包括他们自己的GPU高效版本。Zhdan指出，这种方法在聚光灯下效果不佳，并讨论了使用分层剔除、栅格化和代理几何的优化技术。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108140133.png" class="" title="image-20211108140133">

<p>左:在简单的球体/截锥测试中，这个圆会被报告为相交的，因为它与截锥的底部和右侧平面重叠。中间:左边的测试说明，这里的截锥已经增长，圆的原点(加号)只针对黑色的厚平面进行测试。绿色区域报告了虚假相交。右:在截锥周围放置一个用虚线表示的盒子，在中间的平面测试之后添加一个球/盒子测试，形成所示的粗轮廓形状。注意这个测试是如何在它的绿色区域产生其他假交叉的，但是两个测试都应用了，这些区域会减少。由于球体的原点在形状的外面，球体被正确地报告为不重叠截锥。</p>
<p><strong>这种光线分类过程可以用于延迟着色或前向渲染，Olsson和Assarsson对此进行了详细描述。对于平铺延迟着色，G缓冲器是像往常一样建立的，每个光源的体积被记录在它重叠的平铺中，然后这些列表被应用到G缓冲器中来计算最终结果。在基本的延迟着色中，每个光源都是通过渲染一个代理对象(如一个四边形)来应用，以迫使像素着色器对该光源进行评估。使用平铺着色，一个计算着色器或为屏幕或每个平铺渲染的四边形用于驱动每个像素的着色器评估。当一个片段被评估时，该tile列表中的所有灯光都会被应用。申请灯光清单有几个优点，包括:</strong></p>
<pre><code>**•对于每个像素，G -buffer最多读取一次，而不是每个重叠光读取一次。**

**•输出图像缓冲区只写入一次，而不是累积每个光的结果。**

**•着色器代码可以在渲染方程中分解出任何通用术语并计算一次，而不是每光。**

**•贴图中的每个片段评估相同的光源列表，确保GPU扭曲的一致性执行。**

**•在所有不透明对象渲染后，透明对象可以使用前向着色，使用相同的光列表。**
</code></pre>
<p><strong>•由于所有灯光的效果都是在单一通道中计算的，如果需要的话，帧缓冲区的精度可以很低。</strong></p>
<p><strong>最后一项，帧缓冲区精度，在传统的延迟着色引擎中非常重要。每一种光都被应用在一个单独的通道中，所以如果结果在一个每个颜色通道只有8位的帧缓冲区中积累，最终的结果可能会受到条带和其他伪影的影响。也就是说，能够使用较低的精度与许多现代渲染系统无关，因为这些系统需要更高精度的输出来执行色调映射和其他操作。</strong></p>
<p><strong>平铺灯光分类也可以用于正向渲染。这种类型的系统被称为平铺前向着色或前向+。首先，几何体的z预压被执行，既避免在最终通过透支，又允许进一步的光剔除。一个计算着色器按瓷砖分类灯。第二个几何通道然后执行前向着色，每个着色器访问基于碎片的屏幕空间位置的光列表。</strong></p>
<p><strong>平铺前向着色已经被用于像《秩序:1886》这样的游戏中。Pettineo提供了一个开源测试套件，用于比较延迟和前向分类的平铺底纹实现。为了抗锯齿，在使用延迟着色时，每个样本都被存储。结果是混合的，每个方案优于其他在各种测试条件下。在没有反锯齿的情况下，当光照数量增加到1024时，延迟在许多GPU上往往会胜出，而前向在抗锯齿级别增加时表现更好。Stewart和Thomas通过更广泛的测试分析了一个GPU模型，发现了相似的结果。</strong></p>
<p><strong>z-pre - ass还可以用于另一个目的，通过深度筛选光。这个想法如上图20.6中所示。第一步是找到贴图中物体的最小和最大深度zmin 和zmax．这些都是通过执行一个reduce操作来决定的，在这个操作中，一个着色器被应用到tile的数据zmin 和zmax 数值是通过一次或多次采样来计算的。例如，Harada等人使用一个计算着色器和无序访问视图来有效地执行截锥剔除和减少贴图。这些值可以用来快速剔除贴图中不重叠此范围的任何灯光。空瓷砖，例如，只有天空可见，也可以忽略。场景的类型和应用程序影响是否值得计算和使用最小值、最大值或两者都使用。这种方法也可以应用于平铺延迟着色，因为深度在G -buffer中。</strong></p>
<p><strong>因为深度界限是在不透明的表面上找到的，所以透明度必须单独考虑。为了处理透明表面，Neubelt和Pettineo渲染了一组额外的通道来创建每个瓷砖的灯，用于光和阴影只透明表面。首先，透明表面被渲染在不透明几何体的z- preass缓冲区之上。zmin ，而zmax 的不透明表面用于盖锥的远端。第二次通过执行一个单独的光分类通过，其中生成新的每个贴图的光列表。第三个通道只发送透明的表面通过渲染器，类似于平铺前着色。所有这些表面都被新的光列表遮蔽和照亮。</strong></p>
<p><strong>对于有大量灯光的场景，有效z值的范围对于从进一步处理中剔除大部分是至关重要的。然而，这种优化对于深度不连续这种常见情况没有什么好处。例如，一个瓷砖包含一个附近的人物，以远处的山为背景。两者之间的z范围是巨大的，所以基本上是无用的筛选光。这个深度范围问题会影响场景的很大一部分，如下图所示。这个例子不是一个极端的例子。在森林中，或者有高草或其他植被的场景中，瓷砖的不连续率可能更高。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108140645.png" class="" title="image-20211108140645">

<p>存在较大深度不连续的瓦片的可视化。(图片来自雪崩工作室提供的《正义事业3》。)</p>
<p><strong>一种解决方法是在zmin 和zmax的中间做一次分割．这种测试被称为双峰簇或HalfZ，它将相交的光分类为与中点相比的更近、更远或全范围的重叠。这样做会直接攻击贴图中的两个对象，一个是近的，一个是远的。它不能解决所有的问题，例如，轻量既不重叠物体，也不重叠两个以上的物体在不同深度重叠。尽管如此，它可以提供一个明显的减少照明计算的整体。</strong></p>
<p><strong>Harada等人提出了一种更精细的称为2.5D剔除的算法，其中每个贴图的深度范围为zmin 和zmax，沿深度方向分为n个单元。这个过程如下图所示。创建一个n位的几何位掩码，有几何位的每个位都设置为1。为了提高效率，他们使用n = 32。迭代所有的光，并创建一个光位掩码为每个光重叠的平铺截锥。光位掩码指示光位于哪个单元格中。几何位掩码是AND:ed，带有光掩码。如果结果是零，那么光线不会影响贴图中的任何几何形状。如下图中的右侧所示。否则，灯光将被附加到贴图的灯光列表中。对于一个GPU架构，Stewart和Thomas发现，当光的数量上升到512以上时，HalfZ的表现开始优于基本的平铺延迟，当光的数量上升到2300以上时，2.5D淘汰开始占据主导地位，尽管不是很明显。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108140914.png" class="" title="image-20211108140914">

<p>左图:蓝色的圆台，黑色的几何图形，黄色的光源。中间:用平铺剔除zmin 和zmax 红色的值用于剔除不与灰色区域重叠的光源。右:对于聚集淘汰，z之间的区域min 和zmax 被分割为n个单元格，在本例中n = 8。使用像素的深度计算几何位掩码(10000001)，并为每个光计算光位掩码。如果这些之间的位AND是0，那么光不会被认为是进一步的瓷砖。最上面的光有11000000，所以是唯一的光将被处理为照明计算，因为11000000 AND 10000001给出10000000，这是非零。</p>
<p><strong>Mikkelsen通过使用不透明物体的像素位置进一步简化了光列表。对于每个16 × 16像素的贴图，将生成一个列表，每个光源的屏幕空间边界矩形以及zmin 和zmax 剔除的几何边界。然后这个列表被进一步剔除，让64个计算着色器线程中的每个线程比较贴图中的4个像素对每个光。如果在一个贴图中没有一个像素的世界空间位置在光的体积内，那么光就会从列表中剔除。得到的光集可以相当精确，因为只有那些保证影响至少一个像素的光才会被保存。Mikkelsen发现，在他的场景中，使用z轴的进一步筛选程序会降低整体性能。</strong></p>
<p><strong>随着灯光放置到列表中并作为一个集合进行评估，延迟系统的着色器复杂性可以变得相当复杂。一个着色器必须能够处理所有的材料和所有的光类型。Tiles可以帮助降低这种复杂性。这个想法是在每个像素中存储一个位掩码，每个位与材质在那个像素中使用的着色器特征相关联。对于每个贴图，这些位掩码用OR:ed在一起，以确定该贴图中使用的最小特征数量。位遮罩也可以AND:ed在一起，以找到所有像素使用的特征，这意味着着色器不需要一个“如果”测试来检查是否执行这段代码。一个满足这些要求的着色器被用于平铺中的所有像素。这个着色器专门化是重要的，不仅因为需要执行的指令更少，而且因为生成的着色器可能达到更高的占用率(章节23.3)，否则着色器必须为最坏情况的代码路径分配寄存器。除了材质和灯光之外的属性可以被跟踪并用于影响着色器。例如，在《Split/Second》这款游戏中，Knight等人根据砖块是否完全或部分处于阴影中，是否包含需要抗锯齿的多边形边缘，以及其他测试对4 × 4砖块进行分类。</strong></p>
<h2 id="Clustered-Shading-集群着色"><a href="#Clustered-Shading-集群着色" class="headerlink" title="Clustered Shading 集群着色"></a>Clustered Shading 集群着色</h2><p><strong>平铺灯光分类使用平铺的二维空间范围和可选的几何深度边界。集群的着色将视图截锥分割开来形成一组三维细胞，称为细胞簇。不像z-depth方法用于平铺着色，这个细分是在整个视图锥面上执行的，独立于场景中的几何形状。所得到的算法随着摄像机位置的变化性能变化较小，当贴图包含深度不连续时性能更好。集群着色可以应用于前向和延迟着色系统。</strong></p>
<p><strong>由于透视图，贴图的横截面面积会随着距离相机的距离增加而增加。统一的细分方案将为瓦片的截锥创建压扁的或长而薄的体素，这不是最优的。为了补偿，Olsson等人在视图空间中以指数方式集群几何，而不依赖于几何的zmin 和zmax，使集群更立方体化。例如，《Just Cause 3》的开发者使用64 × 64像素的贴图，带有16个深度切片，并在每个轴上尝试了更大的分辨率，以及使用固定数量的屏幕贴图(不管分辨率如何)。Unreal Engine使用相同大小的贴图和典型的32个深度切片。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108201842.png" class="" title="image-20211108201842">

<p>平铺和集群着色，显示在二维。视锥被细分，场景的光体根据重叠区域进行分类。平铺着色在屏幕空间中细分，而聚集也通过z-depth切片进行划分。每一卷都包含一个灯光列表;长度为2或2以上的列表将显示值。如果zmin 并且zmax不计算场景几何体的平铺着色(未显示)，光列表可能包含大量不需要的光。聚集着色不需要渲染的几何体来剔除它的列表，尽管这样一个通道可以帮助。(参见Persson。)</p>
<p><strong>光根据它们重叠的簇进行分类，然后形成列表。通过不依赖于场景几何的z深度，集群可以仅从视图和灯光集计算。每个表面，不透明或透明，然后使用它的位置来检索相关的光列表。集群提供了一个有效的、统一的照明解决方案，适用于场景中的所有对象，包括透明和体积的对象。</strong></p>
<p><strong>与平铺方法一样，使用集群的算法可以与前向着色或延迟着色相结合。例如，Forza Horizon 2在GPU上计算其集群，然后使用前向着色，因为这提供了MSAA支持，而没有任何额外的工作。虽然在单次前向着色时可以实现透支，但其他方法，如粗略的前到后排序或仅对对象的子集执行预处理，可以避免在没有第二次完整几何通过的情况下大量透支。Pettineo发现，即使使用这样的优化，使用单独的z- preass也更快。另外，可以对不透明表面执行延迟着色，使用相同的光列表结构，然后用于透明表面的前向着色。在Just Cause 3中使用了这种方法，它在CPU上创建了light列表。Dufresne也在CPU上并行地生成集群光列表，因为这个过程不依赖于场景中的几何形状。</strong></p>
<p><strong>集群光照分配为每个列表提供更少的光照，并且与平铺方法相比具有更少的视图依赖性。由tiles定义的长而薄的frusta可以从相机的微小移动中产生相当大的内容变化。例如，一排笔直的街灯就可以填满一块瓷砖。即使使用z-depth细分方法，每个贴图的近距离和远距离也会因为单个像素的变化而发生剧烈的变化。集群不太容易受到此类问题的影响。</strong></p>
<p><strong>如前所述，Olsson等人和其他人探索了集群着色的几种优化。一种技术是为光线形成一个BVH，然后用它来快速确定哪些光线体积重叠在给定的簇上。这个BVH需要重建只要至少有一个光移动。一种可用于延迟着色的选项是使用量子化的法线方向剔除集群中的表面。Olsson等人将表面法线按方向分类为一个结构，在一个立方体上每个面拥有3× 3个方向集，共54个位置，以形成一个法锥(第19.3节)。在创建集群列表时，可以使用这个结构进一步剔除光源。也就是集群中所有表面后面的那些。对于大量的光源来说，排序可能会变得非常昂贵，van Oosten探索了各种策略和优化。</strong></p>
<p><strong>当可见的几何位置是可用的，如延迟着色或从z- preass，其他优化是可能的。不包含几何图形的集群可以从处理中消除，从而提供一个需要更少处理和存储的稀疏网格。这样做意味着必须首先对场景进行处理，以找出哪些集群被占用。因为这需要访问深度缓冲区数据，所以集群形成必须在GPU上执行。与星团的体积相比，星团的几何重叠程度可能较小。通过使用这些样品形成一个紧密的AABB来测试，可以筛选出更多的光。优化后的系统可以处理超过100万个光源，并且随着光源数量的增加，其规模也会扩大，同时对少数光源也很有效。</strong></p>
<p><strong>没有必要使用指数函数来细分屏幕z轴，这种细分可能会对有许多远处灯光的场景产生负面影响。在指数分布下，星团体积随深度增加而增加，这可能导致遥远星团的光列表过长。限制了集群集合的最大距离，即光集群的“远平面”，是一种解决方案，更远处的光会逐渐消失，以粒子或眩光表示，或在中烘培。更简单的着色器，lightcuts，或其他层次的细节技术也可以使用。相反地，距离观众最近的音量可能相对较少，但被大量细分。一种方法是将分类截锥的“近平面”强迫到某个合理的距离，并将比这个深度更近的光进行分类，使其落入第一个深度切片。</strong></p>
<p><strong>在《毁灭战士》(2016)中，开发人员使用Olsson等人和Persson的集群方法组合实现了他们的正向着色系统。他们首先执行z-prepass，这大约需要0.5毫秒。他们的列表构建方案可以被认为是剪切空间体素化。光源、环境光探头和贴花通过测试每个单元与代表每个单元的AABB的交集来插入。添加贴花是一个显著的改进，因为集群前向系统获得了延迟着色对这些实体的优势。在前进遮阳引擎循环通过所有贴花发现在一个细胞。如果贴花与表面位置重叠，它的纹理值将被检索并融合。贴花可以以任何想要的方式与底层表面混合，而不是仅限于混合阶段可用的操作，如延迟着色。与群集向前着色贴花也可以呈现在透明的表面。然后应用单元中所有相关的光。</strong></p>
<p><strong>CPU可以用来构建光列表，因为场景的几何形状不是必需的，而且分析测试光体积球体和集群盒的重叠是不贵的。然而，如果涉及到聚光灯或其他光体形状，在它周围使用球形包围体可能会导致在许多没有影响的星团中添加这样的光，而且精确的解析交叉测试可能会很昂贵。沿着这些思路，Persson提供了一种将球体体素化成一组簇的快速方法。</strong></p>
<p><strong>GPU的栅格化流水线可以用来对光体进行分类，以避免这些问题。Ortegren¨和Persson描述了建立光列表的两步过程。在壳层通道中，每个光都由一个低分辨率的网格包围。保守栅格化(章节23.1.2)用于将这些壳渲染到集群网格中，记录每个重叠的最小和最大集群。在填充通道中，计算着色器将光线添加到这些边界之间的每个集群的链表中。使用网格而不是球体的边界为聚光灯提供了更紧密的边界，几何体可以直接遮挡光的可见性，进一步剔除列表。当保守光栅化不可用时，Pettineo描述了一种使用表面梯度保守估计每个像素上三角形的z边界的方法。例如，如果在一个像素处需要距离最远的距离，则使用x和y深度梯度来选择像素的哪个角距离最远，并计算该点的深度。因为这些点可能不在三角形上，所以他也将光源的z深度范围作为一个整体，以避免一个接近边对的三角形将估计的z深度抛得很远。Wronski探索了各种各样的解决方案，他的想法是在周围放置一个边界球一个网格单元，对锥体进行交叉测试。这种测试是快速评估和良好的工作时，细胞是近立方，当拉长。</strong></p>
<p><strong>Drobot描述了网格是如何用于在《使命召唤:无限战争》中插入灯光的。想想静态聚光灯。它在空间中形成一个体积，比如一个锥体。如果不进行进一步的处理，这个锥体可以延伸相当大的距离，既可以延伸到场景的范围，也可以延伸到为光线定义的最大距离。现在想象一下这个聚光灯的阴影贴图，在场景中使用静态几何生成。这个地图定义了光照射的每个方向的最大距离。在烘焙过程中，这个阴影贴图变成了一个低分辨率的网格，然后作为光的有效体积。网格是保守的，在每个阴影贴图区域使用最大深度形成，因此它完全包围了被光照亮的空间体积。这种聚光灯的表现可能会比原始锥的体积重叠更少。</strong></p>
<p><strong>与此过程无关的是，光列表存储和访问方法(称为z- binning)比聚集着色所占用的内存要少得多。在它中，灯光是根据屏幕z深度排序的，并基于这些深度给出ID。一组z-slices，每一个都是相同的深度厚度，而不是指数，然后用来分类这些灯。每个z-slice只存储重叠的灯光的最小和最大ID。参见下图。平铺底纹列表也会生成，几何体剔除是可选的。然后，每个表面位置访问这个二维平铺结构和每个切片的一维z-bin ID范围。平铺列表给出了平铺中可能影响像素的所有灯光。像素的深度检索可能重叠z-slice的ID范围。这两者的重叠是在飞行中计算，并给出有效的光列表的集群。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108202632.png" class="" title="image-20211108202632">

<p>使用z-bin，每个灯都根据它的z深度得到一个ID。生成每个贴图的列表。每个z-bin存储一个最小和最大ID，一个可能重叠切片的保守光源范围。对于标记单元格中的任何像素，我们检索两个列表并找到重叠。</p>
<p><strong>该算法不需要为三维网格中的每个集群创建和存储列表，而只需要为每个二维贴图创建一个列表，并为z片集创建一个固定大小的小数组。需要更少的存储、带宽使用和预计算，但要确定每个像素上的相关光需要多做一些工作。使用z-bin可能会导致一些灯光被错误地分类，但Drobot发现，在人造环境中，xy屏幕坐标和z-深度的灯光之间通常很少有重叠。使用像素和计算着色器，该方案能够在深度不连续的瓷砖中给出近乎完美的剔除。</strong></p>
<p><strong>用于访问对象的三维数据结构通常可以归类为与体积相关的，其中网格或八叉树被施加在空间上;与对象相关，其中形成了包围卷层次结构;或混合，例如在网格单元格的内容周围使用包围体。Bezrati在一个计算着色器中执行平铺着色以形成一个增强的光列表，其中每个光包括它的最小和最大z深度。通过这种方式，一个碎片可以迅速拒绝任何不重叠它的光。O’donnell和Chajdas展示了在CPU一侧形成的平铺光树。他们为每个光源使用带有深度边界的平铺光源列表，并形成一个边界间隔层次。也就是说，他们没有像Olsson等人所做的那样，为所有光源形成一个单独的三维层次，而是从贴图中每个光源的z区创建一个更简单的一维层次。这种结构可以很好地映射到GPU的架构中，并且能够更好地处理大量光照落在一个贴图中的情况。他们还提供了一种混合算法，可以选择将贴图划分为单元格(通常的集群着色方法)还是使用光树。光树在细胞与其光线的平均重叠度较低的情况下工作得最好。</strong></p>
<p><strong>本地灯光列表的想法可以用在移动设备上，但有不同的限制和机会。例如，在移动设备上，以传统的延迟方式一次渲染一盏灯可能是最有效的方法，因为移动设备将G缓冲区保存在本地内存中的独特属性。平铺前向着色可以在支持OpenGL ES 2.0的设备上实现，这在移动GPU上几乎是给定的。通过OpenGL ES 3.0和一个称为像素本地存储的扩展，ARM GPU中可用的基于瓦片的渲染系统可以有效地生成和应用光列表。更多信息请参见billetter的介绍。Nummelin讨论了Frostbite引擎从桌面到移动设备的转换，包括轻分类方案的权衡，因为计算着色器在移动硬件上的支持较少。由于移动设备使用基于平铺的渲染，为延迟着色生成的G缓冲区数据可以在本地内存中维护。Smith和Einig描述了使用framebuffer获取和像素本地存储来实现这一点，发现这些机制将总带宽成本降低了一半以上。</strong></p>
<p><strong>总之，平铺、聚集或其他光列表剔除技术可以用于延迟或向前着色，每种技术也可以应用于贴花。光体剔除算法专注于最小化每个片段的光数，而解耦几何和着色的想法可以用来平衡处理和带宽成本，以最大化效率。就像截锥剔除将花费额外的时间，如果所有对象总是在视图中，那么有些技术在各种条件下提供的好处很少。如果太阳是唯一的光源，则不需要进行光剔除预处理。如果有一点表面透支和少数灯光，延迟着色可能花费更多的时间。对于有许多照明效果有限的场景，无论是使用正向着色还是延迟着色，花时间创建局部光照列表都是值得的。当几何体处理复杂或表面渲染昂贵时，延迟着色提供了一种方法，以避免透支，最小化驱动成本，如程序和状态切换，并使用更少的调用来渲染更大的合并网格。请记住，在渲染单个帧时，可以使用这些方法中的几个。什么使技术的最佳组合不仅取决于场景，而且也可以根据每个对象或每个光的基础而变化。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108203117.png" class="" title="image-20211108203117">

<p>对于典型的桌面GPU，比较传统的单通道前向、延迟和使用延迟和前向阴影的平铺/聚集光分类。</p>
<p><strong>为了总结这一节，我们在上表中总结了不同方法之间的主要差异。“透明度”行中的右箭头表示延迟着色应用于不透明的表面，透明的表面需要前向着色。“小三角形”注意到延迟着色的一个优势，即四倍着色(章节23.1)在正向渲染时效率很低，因为所有四个样本都被充分评估了。“注册压力”指的是涉及着色器的总体复杂性。在着色器中使用许多寄存器意味着形成的线程更少，导致GPU的扭曲未得到充分利用。如果使用着色器流线型方法，那么对于平铺和集群延迟技术，它可能会变得较低。阴影映射重用通常不像以前那么重要，当时GPU内存更有限。</strong></p>
<p><strong>当存在大量光源时，阴影是一个挑战。一种应对方法是忽略除最近和最亮的光和太阳以外的所有光的阴影计算，以冒着从次要光源漏出光线的风险。Harada等人讨论了他们如何在平铺前向系统中使用光线投射，为每个可见表面像素生成一条射线到每个附近的光源。Olsson等人讨论了使用被占用的网格单元作为几何体的代理来生成阴影地图，并根据需要创建样本。他们还提供了一个混合系统，将这些有限的阴影贴图与光线投射结合在一起。</strong></p>
<p><strong>使用世界空间而不是屏幕空间来生成光线列表是另一种构建聚集着色空间的方法。这种方法在某些情况下是合理的，但是对于大的场景，由于内存不足，还是值得避免的约束，并且由于远处的簇将是像素大小的，从而影响性能。Persson提供了一个基本的集群前向系统的代码，其中静态光存储在一个三维世界空间网格中。</strong></p>
<h2 id="Deferred-Texturing-延迟纹理"><a href="#Deferred-Texturing-延迟纹理" class="headerlink" title="Deferred Texturing 延迟纹理"></a>Deferred Texturing 延迟纹理</h2><p><strong>延迟着色避免了透支和计算碎片着色的成本，然后丢弃这些结果。但是，在形成G -buffer时，仍然会发生透支。一个对象被栅格化并检索其所有参数，在此过程中执行多个纹理访问。如果稍后绘制的另一个对象遮挡了这些存储的样本，那么用于绘制第一个对象的所有带宽都被浪费了。一些延迟着色系统执行部分或全z- preass，以避免稍后被另一个对象绘制的表面的纹理访问。然而，如果可能的话，许多系统都会避免额外的几何通道。带宽用于纹理获取，也用于顶点数据访问和其他数据。对于详细的几何图形，一个额外的通道可以使用更多的带宽，而不是它可能节省纹理访问成本。</strong></p>
<p><strong>形成和访问的G缓冲区的数量越多，内存和带宽成本就越高。在一些系统中，带宽可能不是一个问题，因为瓶颈可能主要是在GPU的处理器中。正如在第18章中详细讨论的那样，瓶颈总是存在的，而且它随时都可能改变。为什么会有如此多的效率方案，主要原因是每个方案都是针对特定的平台和场景类型开发的。其他因素，如实现和优化系统的难度、编写内容的便利性以及各种各样的其他人为因素，也可以决定构建什么。</strong></p>
<p><strong>虽然GPU的计算能力和带宽能力都随着时间的推移而提高，但它们的增长速度不同，计算能力的增长速度更快。这一趋势，加上GPU上的新功能，意味着一种防止系统未来的方法是将瓶颈瞄准GPU计算，而不是缓冲区访问。</strong></p>
<p><strong>一些不同的方案已经开发出来，使用单一的几何通道，避免检索纹理，直到需要。Haar和Aaltonen描述了虚拟延迟纹理是如何在《刺客信条:大革命》中使用的。他们的系统管理本地8192 × 8192的可见纹理图集，每个图集的分辨率都是128 × 128，都是从更大的纹理集中选择的。这个图集大小允许存储(u, v)纹理坐标，可以用来访问图集中的任何texel。有16位用来存储坐标;8192个位置需要13位，这就剩下3位，即8级，亚像素精度。32位的切线基也被存储，编码为四元数(章节16.6)。这样做意味着只需要一个64位G缓冲区。由于没有在几何通道中执行纹理访问，透支可以是非常便宜的。在这个G缓冲区建立之后，在着色过程中访问虚拟纹理。梯度是mipmapping所需要的，但不存储。相反，将检查每个像素的邻居，并使用那些与(u, v)值最接近的在飞行中计算梯度。材质ID也来自于确定哪个纹理贴图被访问，通过将纹理坐标值除以128来完成，即纹理分辨率。</strong></p>
<p><strong>在这个游戏中使用的另一种降低阴影成本的技术是在四分之一分辨率下渲染，并使用特殊形式的MSAA。在使用AMD GCN的控制台，或使用opengl4.5、OpenGL ES 3.2或其他扩展的系统上，MSAA采样模式可以根据需要设置。Haar和altonen将网格模式设置为4× MSAA，使每个网格样本直接对应于全屏像素的中心。通过四分之一分辨率的渲染，他们可以利用MSAA的多次采样特性。(u, v)和切线基可以在没有损失的情况下在表面上插值，并且8× MSAA(相当于每像素2× MSAA)也是可能的。当渲染场景有相当大的透支，如树叶和树木，他们的技术显著减少了着色器调用的数量和G缓冲区的带宽成本。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108203452.png" class="" title="image-20211108203452">

<p>在可见性缓冲区的第一步中，只有三角形和实例ID被渲染并存储在一个G缓冲区中，这里每个三角形都有不同的颜色。(图片来源:Graham Wihlidal-Electronic Arts )</p>
<p><strong>只存储纹理坐标和基础是非常简单的，但其他方案也是可行的。Burns和Hunt描述了他们所谓的可见性缓冲区，其中存储了两部分数据，一个三角形ID和一个实例ID。参见上图。几何通道着色器非常快，没有纹理访问，只需要存储这两个ID值。所有三角形和顶点数据——位置、法线、颜色、材质等等——都存储在全局缓冲区中。在延迟着色过程中，为每个像素存储的三角形和实例id用于检索这些数据。该像素的视图射线与三角形相交，以找到重心坐标，用于插值三角形的顶点数据。其他通常不太频繁的计算也必须按像素执行，例如顶点着色器计算。纹理梯度值也是从头计算每个像素，而不是插值。然后，所有这些数据都被用来给像素着色，并使用任何所需的分类方案进行光照。</strong></p>
<p><strong>虽然这一切听起来都很昂贵，但请记住，计算能力的增长速度要快于带宽能力。这项研究倾向于一个计算量很大的管道，以最大限度地减少由于透支造成的带宽损失。如果场景中有少于64k的网格，并且每个网格有少于64k的三角形，那么每个ID长度为16位，g缓冲区可以小到每像素32位。更大的场景将这个数字推到48或64位。</strong></p>
<p><strong>Stachowiak描述了可见性缓冲区的一种变体，它使用了GCN架构上可用的一些功能。在初始通过过程中，三角形上位置的重心坐标也会被计算并按像素存储。一个GCN片段(即着色器可以廉价地计算重心坐标，相比之下，之后执行单个射线/每个像素的三角形相交。虽然需要额外的存储空间，但这种方法有一个重要的优点。对于动画网格，原始的可见性缓冲区方案需要将任何修改过的网格数据流输出到缓冲区，以便在延迟着色期间可以检索到修改过的顶点位置。保存转换后的网格坐标会消耗额外的带宽。通过在第一次传递中存储重心坐标，我们就完成了顶点位置的处理，不需要再次获取顶点位置，这是原始可见性缓冲区的一个缺点。然而，如果需要与相机的距离，这个值也必须在第一次通过时存储，因为以后无法重建。</strong></p>
<p><strong>这个管线可以解耦几何和阴影频率，类似于以前的方案。Aaltonen指出，MSAA网格采样方法可以应用于每一种方法，从而进一步减少所需的平均内存数量。他还讨论了这三种方案中存储布局的变化以及计算成本和能力的差异。Schied和Dachsbacher走了相反的方向，建立在可见性缓冲区上，并使用MSAA功能来减少内存消耗和阴影计算，以实现高质量的抗锯齿。</strong></p>
<p><strong>Pettineo指出，无绑定纹理功能(章节6.2.5)的可用性使得延迟纹理的实现更加简单。他的延迟纹理系统创建了一个更大的G缓冲区，存储深度、单独的材质ID和深度梯度。绘制了Sponza模型，将该系统的性能与带有和不带有z- preass的集群前向方法进行了比较。当关闭MSAA时，延迟纹理总是比前向着色快，而当应用MSAA时则慢。正如在第5.4.2节中所提到的，随着屏幕分辨率的提高，大多数电子游戏都不再使用MSAA，而是依赖于时间抗锯齿，所以在实践中这种支持并不是那么重要。</strong></p>
<p><strong>Engel指出，由于在DirectX 12和Vulkan中暴露了API特性，可见性缓冲区的概念变得越来越有吸引力。裁剪三角形集(第19.8节)和其他使用计算着色器执行的移除技术减少了栅格化的三角形数量。DirectX 12的ExecuteIndirect命令可以是用于创建一个等效的优化索引缓冲区，只显示那些没有被剔除的三角形。当与高级的剔除系统一起使用时，他的分析表明，在San Miguel场景的所有分辨率和抗锯齿设置下，可见缓冲的性能都优于延迟着色。随着屏幕分辨率的提高，性能差距也在增大。GPU的API和功能的未来变化可能会进一步提高性能。Lauritzen讨论了可见性缓冲区，以及如何发展GPU以改进在延迟设置中访问和处理材质着色器的方式。</strong></p>
<p><strong>Doghramachi和Bucci详细讨论了他们的延迟纹理系统，他们称之为延迟+。他们的系统很早就集成了侵略性的淘汰技术。例如，对前一帧的深度缓冲进行下采样和重投影，为当前场景中的每个像素提供保守的剔除深度。这些深度有助于测试在绘制截锥中可见的所有网格的边界体时的遮挡，如19.7.2节中简要讨论的那样。他们注意到，如果有alpha切割纹理，必须在任何初始通道中访问(或者任何z- preass)，这样切割后的对象就不会被隐藏。剔除和栅格化过程的结果是一组G缓冲器，其中包括深度、纹理坐标、切线空间、梯度和材质ID，这些用于遮蔽像素。虽然它的G缓冲区的数量比其他延迟纹理方案更高，但它确实避免了不必要的纹理访问。对于《杀出重头戏:人类分裂》中的两个简化场景模型，他们发现延迟+比聚集向前着色运行得更快，并相信更复杂的材料和照明将进一步扩大差距。他们还指出，翘曲的使用明显更好，这意味着小三角形造成的问题更少，所以GPU镶嵌性能更好。他们的延迟纹理实现比延迟着色还有其他几个优点，比如能够更有效地处理更广泛的材质。主要的缺点是在大多数延迟方案中常见的，与透明性和抗锯齿有关。</strong></p>
<h2 id="Object-and-Texture-Space-Shading-物体和纹理空间着色"><a href="#Object-and-Texture-Space-Shading-物体和纹理空间着色" class="headerlink" title="Object- and Texture-Space Shading 物体和纹理空间着色"></a>Object- and Texture-Space Shading 物体和纹理空间着色</h2><p><strong>将几何图形采样速率与阴影值计算速率解耦的想法是本章中反复出现的主题。在这里，我们将介绍几种不同的方法，它们不容易归入到目前为止所介绍的类别中。特别地，我们讨论了利用Reyes批处理渲染器中首次看到的概念的混合方法，该方法被皮克斯和其他公司用于制作他们的电影多年。现在，工作室主要使用一些形式的光线或路径跟踪来渲染，但在当时，Reyes以一种创新和有效的方式解决了几个渲染问题。</strong></p>
<p><strong>雷耶斯的关键概念是微多边形的概念。每一个表面都被切成一个极其精细的四边形网格。在原来的系统中，切丁是完成的对于眼睛，其目标是使每个微多边形的宽度和高度约为像素的一半，以便维持奈奎斯特限制(第5.4.1节)。截锥外的四边形或面向眼睛外的四边形被剔除。在这个系统中，微多边形被着色，并分配一个单一的颜色。这种技术发展到对微多边形网格中的顶点进行着色。我们在这里的讨论集中在最初的系统上，因为它探索了一些想法。</strong></p>
<p><strong>每个微多边形被插入到一个像素-亚采样z缓冲区中一个抖动的4 × 4样本网格中。抖动是为了通过产生噪声来避免混叠。因为在栅格化之前，着色与微多边形的覆盖有关，这种技术被称为基于对象的着色。将其与前向着色(在栅格化期间，着色在屏幕空间中发生)和延迟着色(在栅格化之后发生)进行比较。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108225002.png" class="" title="image-20211108225002">

<p>雷耶斯渲染管线。每个对象被镶嵌成微多边形，然后分别着色。每个像素的一组抖动样本(红色)与微多边形进行比较，结果用于渲染图像。</p>
<p><strong>物体空间中的着色的一个优点是材质纹理通常直接与它们的微多边形相关。也就是说，几何对象可以细分，这样每个微多边形的像素数都是2的幂。在着色过程中，精确过滤的mipmap样本可以被微多边形检索，因为它直接与表面着色面积相关。原始的Reyes系统还意味着缓存相干访问纹理发生，因为微多边形是按顺序访问的。这种优势并不适用于所有的纹理，例如，用作反射贴图的环境纹理必须用传统的方法进行采样和过滤。</strong></p>
<p><strong>动态模糊和景深效果也可以很好地配合这种安排。对于运动模糊，每个微多边形在帧间隔的抖动时间沿其路径分配一个位置。因此，每个微多边形将在移动方向上有不同的位置，从而产生模糊。景深以类似的方式实现，基于混沌圆分布微多边形。</strong></p>
<p><strong>Reyes算法有一些缺点。所有的物体都必须能够被镶嵌，并且必须被切得很细。着色影在z缓冲区的遮挡测试之前发生，所以可能会由于透支而浪费。在奈奎斯特极限取样并不意味着高频现象如尖锐的镜面高光被捕获，而是取样足以重建较低的频率。</strong></p>
<p><strong>通常，每个对象必须是“图表”，换句话说，必须有(u, v)纹理值的顶点，给每个不同的区域一个独特的texel模型。示例请参见第23页的图2.9和第173页的图6.6。基于对象的着色可以被认为是第一次在着色中烘焙，使用相机来确定依赖于视图的效果，并可能限制为每个表面区域所花费的精力。在GPU上执行基于对象的着色的一个简单方法是将对象细分到一个精细的亚像素级，然后在网格上着色每个顶点。这样做可能会很昂贵，因为每个三角形的设置成本并没有在多个像素上平摊。由于四元渲染(章节23.1)，单像素三角形会生成4个像素着色器调用。gpu被优化以渲染覆盖相当数量像素的三角形，例如，16或更多(章节23.10.3)。</strong></p>
<p><strong>Burns等人通过在确定哪些物体位置是可见的后执行物体空间着色来探索物体空间着色。他们用一个“多边形网格”来确定这些对象，这个对象被切分、尽可能剔除，然后栅格化。然后使用一个独立的物体空间“着色网格”来遮蔽可见区域，每个texel对应于表面的一个区域。阴影网格可以是一个不同的分辨率比多边形网格。他们发现，精细的镶嵌几何表面几乎没有什么好处，因此将两者分离可以更有效地利用资源。他们只在模拟器上实现了他们的工作，但他们的技术已经影响了新的研究和发展。</strong></p>
<p><strong>从Reyes获得灵感的大量研究已经在GPU上针对各种现象检测了更快的着色方法。Ragan-Kelley等人提出了一种基于解耦采样的硬件扩展，将他们的思想应用于运动模糊和景深。样本有五个维度:两个是亚像素位置，两个是镜头位置，一个是时间。能见度和着色分别采样。“解耦映射”决定了给定可见性样本所需的着色样本。Liktor和Dachsbacher提出了一个类似的延迟着色系统，其中着色样本在计算和使用随机栅格化时被缓存。像运动模糊和景深这样的效果不需要高采样率，所以着色计算可以重复使用。Clarberg等人提出了在纹理空间中计算着色的硬件扩展。这样就消除了四边形的遮蔽问题，从而允许更小的三角形。由于着色是在纹理空间中计算的，当从纹理中查找着色时，像素着色器可以使用双线性过滤器或更复杂的过滤器。这可以通过降低纹理分辨率来降低着色成本。对于低频项，这种技术通常工作得很好，因为可以使用滤波。</strong></p>
<p><strong>Andersson等人采用了一种不同的方法，称为纹理空间着色。对每个三角形进行截锥和背面剔除测试，然后将其绘制的表面应用到输出目标的相应区域，基于其(u, v)参数化对这个三角形进行着色。同时，使用一个几何着色器，每个可见三角形的大小在相机的视图被计算。这个大小值用于确定将在哪个类mipmap级别插入三角形。通过这种方式，对一个对象执行的着色量与它的屏幕覆盖有关。参见下图。他们使用随机栅格化来渲染最终的图像。生成的每个片段都向上查找它的着色颜色从纹理。同样，计算出的着色值可以用于运动模糊和景深效果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108225412.png" class="" title="image-20211108225412">

<p>对象空间纹理着色。左边是最终渲染，包括动态模糊。图表中间显示了可见的三角形。在右侧，每个三角形都根据三角形的屏幕覆盖率以适当的mipmap级别插入，以便在最终的基于相机的光栅化过程中使用。(转载由M. Andersson和英特尔公司许可，版权为英特尔公司，2014年。)</p>
<p><strong>Hillesland和Yang基于纹理空间着色概念，以及类似Liktor和Dachsbacher的缓存概念。他们将几何图形绘制到最终视图，使用计算着色器填充基于对象的纹理结果的类似于mipmap的结构，并再次渲染几何图形以访问这个纹理并显示最终的着色。一个三角形ID可见缓冲区也被保存在第一个通道中，以便他们的计算着色器可以稍后访问顶点属性进行插值。他们的系统包括随时间的一致性。由于材质是在物体空间中，所以对于每一帧，相同的区域与相同的输出纹理位置相关联。如果在给定的mipmap级别上的表面积的着色是以前计算过的，并且不是太旧，那么它将被重用，而不是重新计算。结果会随着材质、光照和其他因素的变化而变化，但他们发现每隔60帧重复使用一个着色样本会导致可以忽略的错误。他们还确定，mipmap级别不仅可以通过屏幕大小来选择，还可以通过其他因素的变化来选择，比如在一个区域上的法向变化。更高的mipmap级别意味着每个屏幕片段计算的阴影更少，他们发现这可以带来可观的节省。</strong></p>
<p><strong>Baker描述了Oxide Games为游戏《Ashes of the Singularity》设计的渲染器。它是受Reyes的启发，尽管实现细节是相当不同的，并为每个模型作为一个整体使用纹理空间着色。物体表面可以覆盖任意数量的材料，通过使用遮罩来区分。他们的流程是:</strong></p>
<pre><code>**•几个大4k × 4k，每个通道16位-“主”纹理被分配用于着色。**

**•对所有对象进行评估。如果在视图中，则计算物体在屏幕上的估计面积。**

**•这个区域用于为每个对象分配一个主纹理的比例。如果请求的总面积大于纹理空间，则按比例缩小以使请求适合。**

**•基于纹理的着色是在计算着色器中执行的，每个附加到模型的材质依次应用。每个材质的结果都累积在指定的主纹理中。**

**•根据需要计算主纹理的Mipmap级别。**

**•对象被栅格化，主纹理用于遮蔽它们。**
</code></pre>
<p><strong>使用多个材料每个对象允许这样的效果，如有一个单一的地形模型，包括泥土，道路，地面覆盖，水，雪，和冰，每一个都有自己的材料BRDF。如果需要的话，抗锯齿在像素级和着色级都可以工作，因为在着色过程中可以获得关于物体表面面积和它与主纹理关系的完整信息。例如，这种能力允许系统稳定地处理具有极高反射能力的模型。因为着色结果是作为一个整体附加到对象上的，无论能见度如何，着色也可以以不同于栅格化的帧率计算。30帧/秒的着色已经足够了，光栅化在60帧/秒，或者虚拟现实系统在90帧/秒。拥有异步着色意味着即使着色器负载变得太高，几何图形的帧率也可以保持。</strong></p>
<p><strong>在实施这样一个系统时，有几个挑战。由于每个对象的“材料四边形”在对象着色步骤中都是用计算着色器处理的，然后在栅格化过程中绘制对象，所以与典型的游戏引擎相比，发送的批大约是前者的两倍。然而，大多数批处理都很简单，像DirectX 12和Vulkan这样的API有助于减少开销。如何根据对象的大小分配主纹理对图像质量有很大的影响。在屏幕上较大的物体，或者不同的像素密度(如地形)，都可能有问题。执行额外的拼接过程用于在主纹理中保持不同分辨率的地形块之间的平滑过渡。屏幕空间技术，如环境遮挡，是一个挑战实现。像原来的可见性缓冲区一样，影响物体形状的动画必须做两次，用于着色和栅格化。物体被遮蔽，然后被遮挡，这是一种浪费。对于具有较低深度复杂性的应用程序，如实时策略游戏，这种成本可能相对较低。每个材质都很容易评估，不像复杂的延迟着色器，而且着色是在整个对象的图表上完成的。带有简单着色器的物体，如粒子和树，从这项技术中得到的好处很少。为了提高性能，这些效果可以用正向着色来代替渲染。如下图所示，能够处理许多灯光可以使渲染的场景更加丰富。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108225646.png" class="" title="image-20211108225646">

<p>奇点的灰烬被大约一千盏灯照亮的场景。这包括每辆车和每颗子弹至少有一个光源。(图片由Oxide Games和Stardock Entertainment提供。)</p>
<p><strong>关于高效着色的讨论到此结束。我们只是触及了一整套专门技术，以提高速度和质量的结果使用不同的应用程序。我们的目标是提出常用的算法来加速着色，并解释它们是如何和为什么产生的。随着图形硬件功能和API的发展，以及屏幕分辨率、美术工作流程和其他元素的变化，高效的着色技术将继续以新的、可能是意想不到的方式被研究和开发。</strong></p>
<p><strong>如果您已经通读了本书，那么您现在已经掌握了现代交互式渲染引擎的主要算法的工作知识。我们的目标之一是让您快速了解该领域的最新文章和演示。如果您希望了解这些元素如何协同工作，我们强烈推荐您阅读Courr’eges和anagnosto关于不同商业渲染器的优秀文章。在此之后，接下来的章节将深入探讨几个领域，如虚拟现实和增强现实的渲染、交集和碰撞检测的算法，以及图形硬件的架构特性。</strong></p>
<h1 id="21-Virtual-and-Augmented-Reality-虚拟现实与增强现实"><a href="#21-Virtual-and-Augmented-Reality-虚拟现实与增强现实" class="headerlink" title="21 Virtual and Augmented Reality 虚拟现实与增强现实"></a>21 Virtual and Augmented Reality 虚拟现实与增强现实</h1><p><strong>虚拟现实(VR)和增强现实(AR)是试图以现实世界的方式刺激你的感官的技术。在计算机图形学领域，增强现实技术将合成对象与我们周围的世界整合在一起;虚拟现实完全取代了世界。参见下图。本章重点介绍特定于这两种技术的渲染技术，这两种技术有时使用“XR”组合在一起，其中X可以代表任何字母。本文的重点将主要放在虚拟现实技术上，因为在撰写本文时，虚拟现实技术的应用更为广泛。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211110125037.png" class="" title="image-20211110125037">

<p>前三位作者使用了各种VR系统。托马斯使用HTC Vive手机;Eric在Birdly - fly-like-a-bird模拟器;Naty使用Oculus Rift。</p>
<p><strong>渲染只是这些领域的一小部分。从硬件的角度来看，使用了某些类型的GPU，这是系统中很容易理解的一部分。创造准确和舒适的头部追踪传感器，有效的输入设备(可能带有触觉反馈或眼球追踪控制)，舒适的头饰和光学设备，以及令人信服的音频，是系统创造者面临的挑战。平衡性能、舒适度、移动自由度、价格和其他因素，使其成为一个苛刻的设计空间。</strong></p>
<p><strong>我们专注于交互渲染以及这些技术影响图像生成的方式，首先简要介绍了目前可用的各种虚拟和增强现实系统。然后讨论了一些系统的sdk和api的功能和目标。我们以特定的计算机图形技术结束，这些技术应该避免或修改，以提供最佳的用户体验。</strong></p>
<h2 id="Equipment-and-Systems-Overview-设备与系统概述"><a href="#Equipment-and-Systems-Overview-设备与系统概述" class="headerlink" title="Equipment and Systems Overview 设备与系统概述"></a>Equipment and Systems Overview 设备与系统概述</h2><p><strong>除了中央处理器(CPU)和图形处理器(GPU)，虚拟现实和增强现实图形设备也可以分为传感器和显示器。传感器包括跟踪器，可以检测用户的旋转和位置，以及大量的输入方法和设备。在显示方面，一些系统依赖于使用手机屏幕，而手机屏幕在逻辑上分为两部分。专用系统通常有两个独立的显示器。显示器是用户在虚拟现实系统中看到的全部内容。对于增强现实，虚拟是通过特殊设计的光学设备与真实世界的视图相结合的。</strong></p>
<p><strong>虚拟现实和增强现实是一个古老的领域，最近经历了新、低成本系统的爆炸式增长，这在很大程度上是直接或间接地由于各种移动和主机技术的可用性。手机可以用于沉浸式体验，有时效果惊人。移动电话可以放置在头戴式显示器(HMD)中，从简单的显示器(如谷歌)到免提并提供额外输入设备(如GearVR)的显示器。手机的重力、磁北和其他机制的方向传感器可以确定显示器的方向。方向，也称为姿态，有三个自由度，例如偏航、俯仰和滚转，如4.2.1.1节所讨论的，API可以以一组欧拉角、一个旋转矩阵或一个四元数返回方向。真实世界的内容，如固定视角的全景图和视频，可以很好地在这些设备上运行，因为为用户呈现正确的二维视图的成本相当低。</strong></p>
<p><strong>移动设备相对适中的计算能力，以及GPU和CPU硬件扩展使用的功率需求，限制了它们的功能。在虚拟现实设备中，用户的头戴式耳机通过一组电线与固定的计算机相连，这限制了机动性，但允许使用更强大的处理器。</strong></p>
<p><strong>我们将简要介绍两个系统的传感器，Oculus Rift和HTC Vive。两者都提供六自由度(6-DOF)跟踪:方向和位置。Rift通过多达三个独立的红外摄像机跟踪HMD和控制器的位置。当耳机的位置由固定的外部传感器确定时，这被称为由外而内跟踪。耳机外部的一组红外发光二极管可以跟踪它。Vive使用了一对“灯塔”，以快速的间隔将不可见的光线照射到房间里，耳机里的传感器和控制器通过检测来三角定位它们的位置。这是一种由内而外的跟踪，传感器是HMD的一部分。</strong></p>
<p><strong>手动控制器是一种标准设备，与鼠标和键盘不同，它具有可追踪性，能够随用户移动。基于各种技术，许多其他类型的输入设备已经为VR开发出来。这些设备包括手套或其他肢体或身体追踪设备、眼球追踪设备，以及那些模拟原地运动的设备，如压力垫、单向或全方位跑步机、固定自行车和真人大小的仓鼠球，等等。除了光学系统，基于磁、惯性、机械、深度探测和声学现象的跟踪方法已经被探索。</strong></p>
<p><strong>增强现实被定义为计算机生成的内容与用户的真实世界视图相结合。任何提供在图像上覆盖文本数据的平视显示器(HUD)的应用程序都是增强现实的基本形式。2009年推出的Yelp Monocle可以在摄像头的视角上覆盖企业用户的评级和距离。谷歌Translate的移动版本可以用翻译后的等价物替换符号。《Pok´emon GO》等游戏将虚拟生物覆盖在真实环境中。Snapchat可以检测面部特征，并添加服装元素或动画。</strong></p>
<p><strong>混合现实(MR)是增强现实的子集，其中真实世界和三维虚拟内容实时混合和交互。混合现实的一个经典用例是在手术中，病人器官的扫描数据与外部身体的摄像机视图合并。这个场景假设一个具有相当计算能力和精度的系绳系统。另一个例子是与一只虚拟袋鼠“捉迷藏”，现实世界的墙壁可以隐藏你的对手。在这种情况下，移动性更重要，而注册或其他影响质量的因素则不那么重要。</strong></p>
<p><strong>在这个领域使用的一项技术是在HMD的前面安装一个摄像机。例如，每个HTC Vive都有一个前置摄像头，开发者可以使用。这个世界的视图被发送到眼睛，合成图像可以与它合成。这有时被称为通过AR或VR，或中介现实，在这种情况下，用户不能直接观看环境。使用这种视频流的一个优点是，它允许更多地控制虚拟对象与真实对象的合并。不利的一面是，人们对现实世界的感知存在一定的滞后。Vrvana的Totem和Occipital的Bridge都是使用这种安排的头戴式显示器的AR系统的例子。</strong></p>
<p><strong>在本书写作之时，微软的HoloLens是最著名的混合现实系统。这是一个不受束缚的系统，CPU、GPU和微软所说的HPU(全息处理单元)都内置在耳机中。HPU是一种定制芯片，由24个数字信号处理核心组成，功耗小于10瓦。这些核心用于处理来自kinect摄像机的世界数据。这种视图，连同其他传感器，如加速度计，执行由内到外的跟踪，还有一个额外的优势，即不需要灯塔，QR码(又称基准)或其他外部元素。HPU用于识别一组有限的手势，这意味着不需要额外的输入设备基本交互。在扫描环境的同时，HPU还可以提取深度并导出几何数据，如表示世界表面的平面和多边形。这个几何图形可以用于碰撞检测，例如，让虚拟对象坐在真实世界的桌面。</strong></p>
<p><strong>通过创建真实世界的路径点(称为空间锚点)，使用HPU进行跟踪，可以在世界任何地方有效地实现更大范围的运动。然后相对于特定的空间锚设置虚拟对象的位置。该设备对这些锚定位置的估计也可以随着时间的推移而提高。这些数据可以共享，这意味着少数用户可以在相同的位置看到相同的内容。还可以定义锚，以便不同位置的用户可以在同一模型上协作。</strong></p>
<p><strong>一对透明屏幕可以让用户看到世界以及投影到这些屏幕上的任何东西。请注意，这不同于手机使用的增强现实技术，后者的世界景色是由相机捕捉的。使用透明屏幕的一个优点是，世界本身不会有延迟或显示问题，也不会消耗处理能力。这种类型的显示系统的一个缺点是虚拟内容只能增加用户对世界的看法的亮度。例如，一个黑暗的虚拟物体不会遮挡它后面更亮的真实物体，因为光线只能增加。这可以给虚拟对象一个半透明的感觉。全息透镜还有一个液晶调光器，可以帮助避免这种影响。通过适当的调整，该系统可以有效地显示与现实相融合的三维虚拟对象。</strong></p>
<p><strong>苹果的ARKit和谷歌的ARCore帮助开发者为手机和平板电脑开发增强现实应用。标准是显示单一(不是立体)视图，设备与眼睛保持一定距离。物体可以是完全不透明的，因为它们被覆盖在摄像机的视野中。参见下图。对于ARKit来说，由内到外的跟踪是通过使用设备的动作感应硬件以及摄像头可见的一系列显著功能来实现的。逐帧跟踪这些特征点有助于精确确定设备的当前位置和方向。与HoloLens一样，水平和垂直表面被发现，并确定范围，然后将这些信息提供给开发商。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211110130022.png" class="" title="image-20211110130022">

<p>来自ARKit的图像。接地面被检测到并显示为蓝色网格。最近的豆袋椅是一个添加在地面上的虚拟物体。它缺少阴影，尽管可以为物体添加阴影，并在场景中混合。(图片由Autodesk, Inc.提供)</p>
<p><strong>英特尔的Project Alloy是一种不系绳的头戴式显示器，像HoloLens一样，它有一个传感器阵列，可以探测房间里的大型物体和墙壁。与HoloLens不同，HMD不能让用户直接看到世界。然而，它感知周围环境的能力赋予了英特尔所谓的“合并现实”，即现实世界中的物体可以在虚拟世界中具有令人信服的存在感。例如，用户可以在虚拟世界中触摸控制台，在现实世界中触摸桌子。</strong></p>
<p><strong>虚拟和增强现实传感器和控制器正在经历快速发展，令人着迷的技术以惊人的速度出现。它们承诺提供更少干扰的耳机，更多的移动性和更好的体验。例如，谷歌的Daydream VR和高通的Snapdragon VR头盔都是不系线的，使用的是由内到外的位置跟踪，不需要外部传感器或设备。惠普、Zotac和MSI公司的系统将计算机安装在你的背部，使其成为提供更多计算能力的不受束缚的系统。英特尔的WiGig线-less网络技术使用短距离90ghz无线电将图像从个人电脑发送到耳机。另一种方法是在云上进行昂贵的光照计算，然后将压缩后的信息发送给耳机中较轻、功能较弱的GPU进行渲染。软件方法，如获取点云，体素化这些，并以交互速率渲染体素化表示，为虚拟和真实的融合开辟了新的途径。</strong></p>
<p><strong>本章的大部分内容都集中在显示器及其在VR和AR中的使用上。我们首先浏览了图像如何在屏幕上显示的一些物理机制以及涉及的一些问题。本章继续介绍sdk和硬件系统为简化编程和增强用户对场景的感知提供了什么。本节之后是关于这些不同因素如何影响图像生成的信息，并讨论了需要如何修改或可能完全避免某些图形技术。最后，我们讨论了渲染方法和硬件增强，以提高效率和参与者的体验。</strong></p>
<h2 id="Physical-Elements-物理原理"><a href="#Physical-Elements-物理原理" class="headerlink" title="Physical Elements 物理原理"></a>Physical Elements 物理原理</h2><p><strong>本节介绍现代VR和AR系统的各种组件和特性，特别是与图像显示相关的组件和特性。这些信息为理解供应商提供的工具背后的逻辑提供了一个框架。</strong></p>
<h3 id="Latency-延迟"><a href="#Latency-延迟" class="headerlink" title="Latency 延迟"></a>Latency 延迟</h3><p><strong>缓解延迟的影响在VR和AR系统中尤其重要，这通常是最关键的问题。我们在第3章讨论了GPU如何隐藏内存延迟。这种类型的延迟是由纹理获取等操作引起的，是整个系统的一小部分所特有的。这里我们指的是整个系统的“运动到光子”延迟。也就是说，假设你开始把头转向左边。从你的头朝向某一特定方向，到从该方向产生的图像被显示，需要多长时间?从检测用户输入(例如，头部方向)到响应(显示的新图像)，链中每一块硬件的处理和通信成本加起来需要几十毫秒的延迟。</strong></p>
<p><strong>带有常规显示监视器的系统中的延迟(例如。最坏的情况下，它会让人恼火，破坏互动和联系的感觉。对于增强现实和混合现实应用，较低的延迟将有助于提高“像素粘性”，即场景中的虚拟对象与现实世界的贴合程度。系统中的延迟越长，相对于真实世界中的对应对象，虚拟对象看起来越像在游动或漂浮。在沉浸式虚拟现实中，显示器是唯一的视觉输入，延迟可以创造一组更激烈的效果。虽然不是真正的疾病，但它被称为模拟病，会导致出汗、头晕、恶心和更糟的情况。如果你开始感到不适，立即摘下HMD——你无法“通过”这种不适，只会变得更糟糕。引用卡马克的话说，“不要强迫。我们不需要在演示室里清理病人。“在现实中，真正的呕吐很少见，但其影响可能很严重，使人虚弱，可以持续一天。</strong></p>
<p><strong>在虚拟现实中，当显示的图像与用户的期望或其他感官(如内耳平衡和运动的前庭系统)的感知不匹配时，就会出现“模拟病”。头部运动与显示图像匹配的时间差越小越好。一些研究指出15毫秒是难以察觉的。超过20毫秒的延迟肯定可以被感知到，并且会产生有害的影响。相比之下，从鼠标移动到显示，电子游戏通常有50毫秒或更多的延迟，如果没有垂直同步，则有30毫秒(章节23.6.2)。在VR系统中，90 FPS的显示率是很常见的，即帧时间为11.1 ms。在一个典型的桌面系统上，通过电缆扫描帧到显示器大约需要11毫秒，所以即使你能在1毫秒内渲染，你仍然会有12毫秒的延迟。</strong></p>
<p><strong>有许多以应用为基础的技术可以预防或改善不适。这些方法包括最小化视觉流(游戏邦注:如在前进过程中不让用户看向侧面或避免爬楼梯)，以及更多心理学方法，如播放环境音乐或呈现一个代表用户鼻子的虚拟物体。更柔和的颜色和更暗的灯光也可以帮助避免模拟病。使系统的响应与用户的操作和期望相匹配是提供一个愉快的虚拟体验。让所有的物体响应头部的运动，不要缩放相机或改变视野，适当缩放虚拟世界，不要让相机远离用户，这些都是一些指导方针。在用户周围有一个固定的视觉参考，如汽车或飞机驾驶舱，也可以减少模拟器晕机。应用于用户的视觉加速可能会引起不适，所以使用恒定的速度是最好的。硬件解决方案也可能被证明是有用的。例如，三星(Samsung)的Entrim 4D耳机会发出微小的电脉冲，影响前庭系统，从而使用户能够根据自己的平衡感判断所看到的东西。时间会证明这项技术的有效性，但这是一个迹象，表明有多少研究和开发正在做，以减轻模拟病的影响。</strong></p>
<p><strong>跟踪姿势，或简单的姿势，是方向和，如果可能，观众的头部在现实世界的位置。姿态用于形成渲染所需的相机矩阵。在一帧开始时，可以使用对姿态的粗略预测来进行模拟，例如角色和环境元素的碰撞检测。当渲染即将开始时，一个更新的姿态预测可以在那一刻被检索并用于更新相机的视图。这种预测将更准确，因为它稍后被检索并且持续时间更短。当图像即将显示时，另一个更准确的姿态预测仍然可以被检索，并用于扭曲图像，以更好地匹配用户的位置。每一个后来的预测都不能完全弥补先前不准确预测的计算，但尽可能地使用它们可以大大提高整体体验。各种钻机的硬件增强提供了在需要时快速查询和获取更新头部姿态的能力。</strong></p>
<p><strong>除了视觉效果之外，还有其他元素能够让玩家在虚拟环境中进行更有说服力的互动，但如果图像设计不当，玩家的体验将会非常糟糕。减少延迟和提高应用程序的真实感可以帮助实现沉浸感或在场感，在这种情况下，界面会消失，参与者会觉得自己是虚拟世界的一部分。</strong></p>
<h3 id="Optics-光学"><a href="#Optics-光学" class="headerlink" title="Optics 光学"></a>Optics 光学</h3><p><strong>设计精确的物理光学来将头戴式显示器的内容映射到视网膜上的相应位置是一项昂贵的任务。让虚拟现实显示系统价格合理的是，GPU生成的图像在单独的后处理过程中被扭曲，以便正确地到达我们的眼睛。</strong></p>
<p><strong>VR系统的镜头向用户呈现的是一个具有针垫变形的大视场图像，图像的边缘似乎向内弯曲。如下图中右侧所示，通过使用桶形失真对每个生成的图像进行扭曲，可以抵消这一效果。光学系统通常也会受到色差的影响，镜片会导致颜色分离，就像棱镜一样。这个问题也可以由厂商的软件来弥补，生成的图像具有倒色分离。另一种是色差方向。“当通过虚拟现实系统的光学系统显示时，这些不同的颜色会恰当地结合在一起。这种校正可以在扭曲的一对图像边缘的橙色边缘上看到。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211110130550.png" class="" title="image-20211110130550">

<p>原始的渲染目标(左)和它们的扭曲版本(右)显示在HTC Vive上。(图片由Valve提供)</p>
<p><strong>有两种类型的显示，滚动和全局。对于这两种类型的显示，图像以串行流的形式发送。在滚动显示中，该流被接收后立即逐行显示。在全局显示中，一旦接收到整个图像，它就会以单个短脉冲显示。在虚拟现实系统中，每种显示器都有其各自的优点。与全局显示(在显示之前必须等待整个图像出现)相比，滚动显示可以最小化延迟，因为结果会在可用时立即显示。例如，如果图像是以条带生成的，那么每个条带都可以在显示之前以渲染的方式发送，“与光束赛跑”。缺点是不同的像素在不同的时间被照亮，所以根据视网膜和显示器之间的相对运动，图像会被认为是不稳定的。这种不匹配对于增强现实系统来说尤其令人不安。好消息是，排字器通常通过在一组扫描线上插值预测的头部姿势来进行补偿。这主要解决了在快速头部旋转时可能发生的抖动或剪切，尽管不能纠正场景中移动的物体。</strong></p>
<p><strong>全局显示没有这种类型的时间问题，因为图像必须在显示之前完全形成。相反，挑战是技术上的，因为单个短时间脉冲排除了几个显示选项。有机发光二极管(OLED)显示器是目前全球显示器的最佳选择，因为它的速度足以跟上VR使用中流行的90 FPS的显示速度。</strong></p>
<h3 id="Stereopsis-立体观测"><a href="#Stereopsis-立体观测" class="headerlink" title="Stereopsis 立体观测"></a>Stereopsis 立体观测</h3><p><strong>如上图所示，两张图像被偏移，每只眼睛的视角不同。这样做会刺激立体视觉，即有两只眼睛对深度的感知。立体视觉虽然是一个重要的影响，但它会随着距离的增加而减弱，这并不是我们感知深度的唯一方式。例如，在标准显示器上看图像时，我们根本不用它。物体大小、纹理模式变化、阴影、相对运动(视差)和其他视觉深度提示只需要一只眼睛就可以完成。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211110130746.png" class="" title="image-20211110130746">

<p>两眼旋转多少才能看到一个物体就是收敛。会聚是眼睛向内聚焦于某一物体的运动，如左眼。散度是向外的运动当它们转向看远处的物体时，远离页面的右边。观察远处物体的视线实际上是平行的。</p>
<p><strong>眼睛必须调整多少形状以使某物聚焦被称为适应性需求。例如，Oculus Rift的光学功能相当于观看距离用户1.3米远的屏幕。眼睛需要向内转动多少才能聚焦在一个物体上，这被称为收敛需求。参见上图。在现实世界中，眼睛会改变晶状体的形状，同时向内转动，这种现象被称为调节——收敛反射。对于显示器，适应需求是恒定的，但随着眼睛聚焦在不同感知深度的物体上，收敛需求会发生变化。这种不匹配会导致眼睛疲劳，所以Oculus建议用户将看到的任何物体放置在0.75到3.5米之外。这种不匹配在一些增强现实系统中也会产生感知效果，例如，用户可能会聚焦在现实世界中一个遥远的物体上，但随后必须重新聚焦在一个相关的虚拟广告牌上，该广告牌位于眼睛附近的固定深度。一些团队正在研究和开发一种硬件，这种硬件可以根据用户的眼球运动来调整感知到的焦距，有时也被称为自适应聚焦或可变聚焦显示器。</strong></p>
<p><strong>为VR和AR生成立体图像对的规则与单显示系统的规则不同，在单显示系统中，某些技术(偏光镜头、快门眼镜、多视角显示光学)从同一屏幕向每只眼睛呈现不同的图像。在虚拟现实技术中，每只眼睛都有一个独立的显示器，这意味着每只眼睛的位置必须保证投射到视网膜上的图像与现实非常匹配。眼与眼之间的距离称为瞳孔间距离(IPD)。在一项对4000名美国陆军士兵的研究中发现，IPD的范围从52毫米到78毫米，平均为63.5毫米。VR和AR系统都有校准方法来确定和调整用户的IPD，从而提高图像质量和舒适度。该系统的API控制一个包含IPD的摄像机模型。最好避免为了达到效果而修改用户的感知IPD。例如，增加眼间距可以增强深度感知，但也会导致眼疲劳。</strong></p>
<p><strong>头戴式显示器的立体渲染很难从头开始。好消息是，为每只眼睛设置和使用适当的摄像机转换的大部分过程都是由API处理的，这是下一节的主题。</strong></p>
<h2 id="APIs-and-Hardware-接口和硬件"><a href="#APIs-and-Hardware-接口和硬件" class="headerlink" title="APIs and Hardware 接口和硬件"></a>APIs and Hardware 接口和硬件</h2><p><strong>让我们从一开始就说:始终使用系统供应商提供的VR软件开发工具包(SDK)和应用程序编程接口(API)，除非你有很好的理由不这样做。例如，你可能认为自己的失真着色器更快，看起来也差不多。然而，在实践中，它可能会引起严重的用户不适——如果没有广泛的测试，您不一定会知道这是否正确。由于这个和其他原因，应用程序控制的失真已经从所有主要API中删除;获得正确的VR显示是一个系统级的任务。为了优化性能和保持质量，你需要做很多细致的工程。本节讨论各种供应商的SDK和API提供的支持。</strong></p>
<p><strong>将三维场景的渲染图像发送到耳机的过程非常简单。在这里，我们将使用大多数虚拟和增强现实API的常见元素来讨论它，并在此过程中注意特定于供应商的功能。首先，确定将要渲染的帧将被显示的时间。通常支持帮助您估计这个时间延迟。这个值是必需的，这样SDK就可以估算出在看到帧的那一刻眼睛所处的位置和方向。考虑到这个估计的延迟，API会查询姿势，其中包含关于每个眼睛的相机设置的信息。如果传感器也能跟踪这一信息，这至少包括头部的方向和位置。OpenVR API还需要知道用户是站着还是坐着，这可能会影响将哪个位置作为原点，例如跟踪区域的中心或用户头部的位置。如果预测是完美的，那么渲染的图像将显示在头部到达预测的位置和方向的时刻。这样，延迟的影响可以被最小化。</strong></p>
<p><strong>给定每只眼睛的预测姿态，你通常会将场景渲染到两个独立的目标。这些目标被作为纹理发送到SDK的合成器。排字人员负责将这些图像转换成在头戴式显示器上观看效果最好的形式。排字器还可以将不同的层合成在一起。例如，如果需要单眼平视显示，其中的视图对两个眼睛是相同的，可以提供一个包含该元素的单一纹理，作为一个单独的层，在每个眼睛的视图上合成。纹理可以是不同的分辨率和格式，由合成器负责转换到最终的眼睛缓冲。这样做可以实现优化，如动态降低三维场景的层的分辨率以节省渲染时间，同时保持其他层的高分辨率和质量。一旦为每个人组成了图像眼睛、畸变、色差和任何其他需要的过程都由SDK执行，然后显示结果。</strong></p>
<p><strong>如果您依赖于API，那么您不需要完全理解这些步骤背后的算法，因为供应商为您做了很多工作。然而，了解一些这方面的知识仍然是值得的，只要你意识到最明显的解决方案并不总是最好的。首先，考虑合成。最有效的方法是首先将所有图层组合在一起，然后在这张图像上应用各种校正措施。相反，Oculus首先对每一层分别进行这些校正，然后将这些扭曲的层合成，形成最终的显示图像。一个优点是，每一层的图像都是按照自己的分辨率进行扭曲的，这样可以提高文本的质量，比如单独处理文本，意味着在扭曲过程中重新采样和过滤只关注文本的内容。</strong></p>
<p><strong>用户感知到的视场大致是圆形的。这意味着我们不需要在每个图像的边缘，靠近角落渲染一些像素。虽然这些像素会出现在显示器上，但它们几乎无法被观众察觉。为了避免浪费时间生成这些，我们可以首先渲染一个网格，将这些像素隐藏在我们生成的原始图像中。这个网格作为蒙版呈现到模板缓冲区中，或者呈现到前面的z缓冲区中。在评估之前，这些区域的后续渲染片段将被丢弃。Vlachos报告称，这将使HTC Vive的填充率降低约17%。参见下图。Valve的OpenVR API将这种预渲染蒙版称为“隐藏区域网格”。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111103704.png" class="" title="image-20211111103704">

<p>在左侧，显示图像中的红色区域显示了经过渲染和扭曲的像素，但对HMD用户不可见。注意，黑色区域在经过转换的渲染图像的边界之外。在右侧，这些红色区域在渲染开始时被红色边缘的网格预先掩盖掉，导致渲染(预扭曲)的图像需要更少的像素进行着色。将右侧图像与原始图像进行比较，如图21.3中的左侧。(图片由Valve提供)</p>
<p><strong>一旦我们有了渲染后的图像，它需要被扭曲以补偿系统光学的失真。其概念是定义原始图像到所需显示形状的重新映射，如图21.3所示。换句话说，给定传入的渲染图像上的一个像素样本，这个样本在显示的图像中移动到哪里?光线投射方法可以给出精确的答案，并根据波长进行调整，但对大多数硬件来说是不切实际的。一个方法是将渲染后的图像作为纹理处理，并绘制一个填充屏幕的四边形来运行后处理。像素着色器计算这个纹理上对应于输出显示像素的确切位置。然而，这种方法可能是昂贵的，因为这个着色器必须评估每个像素的失真方程。</strong></p>
<p><strong>将纹理应用到三角形网格中会更有效。这个网格的形状可以通过变形方程修改和渲染。扭曲网格仅仅一次不会纠正色差。三组独立的(u, v)坐标用于扭曲图像，每个颜色通道对应一组。也就是说，网格中的每个三角形都被渲染一次，但是对于每个像素，渲染后的图像在略微不同的位置被采样三次。这些红色、绿色和蓝色通道值构成输出像素的颜色。</strong></p>
<p><strong>我们可以将规则间隔的网格应用到渲染的图像上，并将扭曲应用到显示的图像上，反之亦然。将网格网格应用于显示图像并将其弯曲回渲染图像的一个优点是，由于不会显示细三角形，因此生成的2 × 2四边形可能更少。在这种情况下，网格位置不是扭曲的，而是作为一个网格渲染，只有顶点的纹理坐标被调整，以扭曲应用到网格上的图像。一个典型的网格是48 × 48个四边形每只眼睛。参见下图。纹理坐标通过使用每个通道的显示-渲染图像变换计算一次。通过在网格中存储这些值，在着色器执行期间不需要复杂的转换。GPU支持纹理的各向异性采样和滤波，可用于生成清晰的可显示图像。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111103845.png" class="" title="image-20211111103845">

<p>在左边，显示最终显示的图像的网格。在实践中，这个网格可以被修剪回右边剔除的版本，因为绘制黑色三角形不会增加最终图像。(图片由Valve提供)</p>
<p><strong>上上图中右侧渲染的立体对被显示网格扭曲。在该图像中心被移除的切片对应于扭曲转换生成可显示图像的方式—请注意，在上上图左侧显示的版本中，该切片是如何从图像的交汇处丢失的。通过将显示的翘曲网格修剪到仅可见的区域，如上图中右侧所示，我们可以减少最终失真通过的成本约15%。</strong></p>
<p><strong>综上所述的优化，我们首先绘制一个隐藏区域网格，以避免评估碎片在我们知道将无法检测或未使用的区域(如中间部分)。我们用眼睛来渲染这个场景。然后我们将这个渲染图像应用到一个网格网格中，这个网格已经被修剪，只包含相关的渲染区域。将这个网格渲染到一个新的目标上，我们就可以看到要显示的图像。虚拟和增强现实系统的API支持中内置了部分或全部这些优化。</strong></p>
<h3 id="Stereo-Rendering-立体渲染"><a href="#Stereo-Rendering-立体渲染" class="headerlink" title="Stereo Rendering 立体渲染"></a>Stereo Rendering 立体渲染</h3><p><strong>渲染两个独立的视图看起来是渲染单个视图的两倍。然而，正如Wilson所指出的那样，即使是简单的实现也不是这样。阴影地图生成、模拟和动画以及其他元素都是视图无关的。像素着色器调用的数量不会增加一倍，因为显示本身在两个视图之间被分割成两半。同样，后处理效果也依赖于分辨率，所以这些成本也不会改变。然而，依赖视图的顶点处理增加了一倍，因此许多人已经探索了降低这一成本的方法。</strong></p>
<p><strong>截锥剔除通常在任何网格被发送到GPU的管线之前执行。单个视锥可以用来包含两个眼视锥。因为剔除发生在呈现之前，所以在剔除发生之后可以检索到要使用的确切呈现视图。然而，这意味着在剔除过程中需要一个安全裕度，因为该检索到的视图对可以查看被截锥删除的模型。Vlachos建议将视野增加约5度用于预测剔除。Johansson讨论了如何将截锥剔除和其他策略(如实例化和遮挡剔除查询)结合起来用于大型建筑模型的VR显示。</strong></p>
<p><strong>渲染两个立体视图的一种方法是在一个系列中完成，先渲染一个视图，然后再渲染另一个视图。实现起来很简单，但这有一个明显的缺点，即状态更改也会加倍，这是需要避免的(第18.4.2节)。对于基于贴图的渲染器，频繁更改视图和渲染目标(或剪接矩形)将导致糟糕的性能。一个更好的选择是渲染每个对象两次，切换相机转换之间。然而，API绘制调用的数量仍然增加了一倍，导致了额外的工作。想到的一种方法是使用几何着色器复制几何，为每个视图创建三角形。例如，DirectX 11支持几何着色器将生成的三角形发送到分离的目标。不幸的是，这种技术已经被发现降低了三倍或更多的几何吞吐量，因此没有在实践中使用。一个更好的解决方案是使用实例化，在实例化中，每个对象的几何图形都通过一个draw调用绘制两次。用户定义的剪辑平面被设置为保持每个眼睛的视图分离。使用实例化比使用几何着色器快得多，并且是一个很好的解决方案，排除任何额外的GPU支持。另一种方法是在渲染一只眼睛的图像时，形成一个命令列表(章节18.5.4)，将引用的常量缓冲区移位到另一只眼睛的变换中，然后重放这个列表来渲染第二只眼睛的图像。</strong></p>
<p><strong>有几个扩展可以避免在管道中发送两次(或更多)几何图形。在一些手机上，OpenGL ES 3.0扩展多视图增加了对只发送一次几何图形并将其渲染到两个或多个视图的支持，并对屏幕顶点位置和任何与视图相关的变量进行调整。扩展提供了更多的自由实现一个立体渲染器。例如，最简单的扩展可能会在驱动程序中使用实例化，发出两次几何图形，而需要GPU支持的实现可能会将每个三角形发送到每个视图。不同的实现有不同的优点，但是由于API成本总是降低的，所以这些方法中的任何一种都可以帮助CPU绑定的应用程序。例如，更复杂的实现可以提高纹理缓存效率，只对视图无关的属性执行一次顶点着色。理想情况下，可以为每个视图设置整个矩阵，也可以为每个视图设置任意顶点属性。为了让硬件实现使用更少的晶体管，GPU可以实现这些特性的子集。</strong></p>
<p><strong>AMD和NVIDIA提供了针对VR立体渲染的多GPU解决方案。对于两个GPU，每个渲染一个单独的眼睛的视图。使用关联掩码，CPU为所有接收特定API调用的GPU设置一个位。通过这种方式，呼叫可以被发送到一个或多个GPU。如果在左眼和右眼视图之间调用不同，那么通过关联掩码，API仍然需要调用两次。</strong></p>
<p><strong>另一种由厂商提供的渲染风格是NVIDIA所称的“广播”，在这种渲染方式下，只需要一个draw调用即可实现双眼的渲染。，它被广播到所有GPU。固定缓冲区用于发送不同的数据，例如，眼睛位置，到不同的GPU。广播创建两眼的图像，几乎没有比单个视图更多的CPU开销，因为唯一的成本是设置第二个常量缓冲区。</strong></p>
<p><strong>单独的GPU意味着单独的目标，但是排字器通常需要一个单独的渲染图像。有一个特殊的子矩形传输命令可以在一毫秒或更短的时间内将渲染目标数据从一个GPU转移到另一个GPU。它是异步的，这意味着传输可以在GPU做其他工作时发生。如果两个GPU并行运行，它们也可以分别创建渲染所需的阴影缓冲区。这是重复的工作，但比尝试并行处理和GPU之间的传输更简单，通常更快。这整个两个GPU设置的结果是大约30到35%的渲染加速。对于已经针对单个GPU进行了调优的应用程序，多个GPU可以将它们的额外计算应用于额外的示例，以获得更好的抗锯齿结果。</strong></p>
<p><strong>立体声视差对附近的模型很重要，但对远处的物体则可以忽略不计。Palandri和Green在移动GearVR平台上利用了这一点，他们使用了一个垂直于视图方向的分离平面。他们发现，大约10米的平面距离是一个很好的默认距离。较近的不透明物体以立体声呈现，而较远的物体则用放置在两个立体声摄像机之间的单向度摄像机呈现。为了最小化overdraw，首先绘制立体视图，然后使用它们的深度缓冲区的交集来初始化z-buffer，用于单单渲染。然后合成这幅遥远物体的图像每个立体视图。每个视图最后呈现的是透明内容。虽然更复杂，而且跨越分离平面的物体需要额外的通道，但这种方法在质量和深度感知方面没有损失，总体节约了约25%。</strong></p>
<p><strong>从下图中可以看出，由于光学所需要的畸变，使得每只眼睛的图像周围产生了更高的像素密度。此外，外围通常不那么重要，因为用户在相当多的时间里会看向屏幕的中心。由于这些原因，人们开发了各种技术，以减少对眼睛周围像素的处理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111104431.png" class="" title="image-20211111104431">

<p>左边是一只眼睛的渲染图像。右边是要显示的扭曲图像。注意中间的绿色椭圆是如何保持相同的面积的。在外围，渲染图像中较大的区域(红色轮廓)与较小的显示区域相关联。(图片由NVIDIA公司提供。)</p>
<p><strong>一种沿外围降低分辨率的方法是NVIDIA称为多分辨率着色和AMD称为可变速率着色。其想法是将屏幕划分为，例如，3 × 3的区域，并以较低的分辨率渲染周边区域，如下图所示。NVIDIA从其Maxwell架构开始就支持这种分区方案，但是在使用Pascal时，支持一种更通用的投影类型。这被称为同步多投影(SMP)。几何图形可以通过多达16个独立的投影乘以2个独立的眼睛位置来处理，允许一个网格复制多达32次，而不需要额外的应用成本。第二眼位置必须与第一眼位置沿x轴的偏移量相等。每个投影可以独立地倾斜或绕轴旋转。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111104601.png" class="" title="image-20211111104601">

<p>假设我们想要以较低分辨率渲染左边的视图。我们可以根据需要降低任何区域的分辨率，但通常在共享边缘保持相同的分辨率更好。在右边，我们展示了蓝色区域如何减少50%的像素，红色区域减少75%。视场保持不变，但是外围区域的分辨率降低了。</p>
<p><strong>使用SMP，可以实现镜头匹配着色，其目标是更好地匹配渲染的分辨率。参见上上图。四个墩柱渲染倾斜的平面，如下图中的左边所示。这些经过修改的投影在图像中心提供了更多的像素密度，而在外围提供了更少的像素密度。这比多分辨率着色提供了一个更平滑的过渡部分。有一些缺点，例如，花朵的效果需要重新制作，以显示正确。Unity和Unreal Engine 4已经将这种技术集成到他们的系统中。Toth等人对这些算法和其他多视图投影算法进行了正式的比较和对比，并使用每只眼睛最多3 × 3个视图来进一步减少像素阴影。注意，SMP可以同时应用于双眼，如下图中右侧所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111104722.png" class="" title="image-20211111104722">

<p>左:同时多投影(SMP)使用四个投影平面为一只眼睛。右图:SMP使用四只眼睛的投影平面。</p>
<p><strong>为了节省片段处理的时间，一种称为径向密度掩蔽的应用程序级方法以棋盘式四边形模式呈现外围像素。换句话说，其他的2×2四元组片段不会被渲染。然后使用一个后处理通道从它们的邻居重建缺失的像素。这种技术可以对于一个只有一个低端GPU的系统来说，这是非常有价值的。使用这种方法渲染将减少像素着色器调用，但如果跳过并执行重建过滤器的成本太高，可能不会给你带来任何好处。索尼伦敦工作室在这一过程中走得更远，从2 × 2的集合中减少1、2或3个四边形，在靠近图像边缘的地方增加数量。缺失的四边形以类似的方式填充，每帧抖动模式都会改变。应用时间反锯齿也可以帮助隐藏阶梯的伪影。索尼系统节省了大约25%的GPU时间。</strong></p>
<p><strong>另一种方法是为每只眼睛绘制两张独立的图像，一张是中央的圆形区域，另一张是形成外围的环形区域。然后，这两幅图像可以被合成和扭曲，形成那只眼睛的显示图像。外围的图像可以以较低的分辨率生成，以节省像素着色器调用，代价是发送几何图形以形成四个不同的图像。这种技术与GPU支持发送几何图形到多个视图，以及为具有两个或四个GPU的系统提供一个自然的工作分工相吻合。虽然这是为了减少由于HMD所涉及的光学而导致的外围过多的像素着色，但Vlachos称这种技术为固定凹点渲染。这个术语是一个更高级的概念，凹点渲染。</strong></p>
<h3 id="Foveated-Rendering-漏斗状渲染"><a href="#Foveated-Rendering-漏斗状渲染" class="headerlink" title="Foveated Rendering 漏斗状渲染"></a>Foveated Rendering 漏斗状渲染</h3><p><strong>为了理解这种渲染技术，我们必须对我们的眼睛有更多的了解。中央凹是我们每只眼睛视网膜上的一个小凹陷，它充满了高密度的视锥细胞，视锥细胞是与色觉相关的感光细胞。我们的视觉灵敏度在这一区域最高，我们转动眼睛来利用这一能力，比如追踪飞行中的鸟，或者阅读页面上的文字。视力迅速下降，在前30度，从中央凹每2.5度下降约50%，越往远处下降越陡。我们的眼睛有水平114度的双目视野(两眼可以看到同一物体)。第一代消费者头戴式耳机的视场略小，双眼水平视度约为80至100度，而且可能还会上升。从2016年开始，中央20度视角的区域覆盖HMD显示器的3.6%，预计在2020年左右下降到2%。在此期间，显示分辨率可能会上升一个数量级。</strong></p>
<p><strong>在低视敏度区域，由于显示器像素的巨大优势，这就提供了使用凹点渲染来执行更少工作的机会。这个想法是为了渲染眼睛所指向的区域具有高分辨率和高质量，而在其他方面花费的精力更少。问题是眼睛会移动，所以知道要渲染的区域会改变。例如，当研究一个物体时，眼睛会进行一系列的快速移动，称为扫视，以每秒900度的速度移动。在90帧/秒的系统中，可能每帧10度。精确的眼球追踪硬件可以通过减少中央凹区域外的渲染工作，从而潜在地提高性能，但是这样的传感器是一个技术上的挑战。此外，在外围渲染“更大”的像素往往会增加混叠问题。通过尝试保持对比度，避免随着时间的推移而发生大的变化，使得外围区域在感知上更容易被接受，从而可以以较低分辨率绘制外围区域。Stengel等人讨论了以前的凹点渲染方法，以减少着色器调用的次数并呈现自己的方法。</strong></p>
<h2 id="Rendering-Techniques-渲染技术"><a href="#Rendering-Techniques-渲染技术" class="headerlink" title="Rendering Techniques 渲染技术"></a>Rendering Techniques 渲染技术</h2><p><strong>适用于单一世界观的东西不一定适用于两种世界观。即使在立体声技术中，在单一的固定屏幕上所使用的技术与在随观众移动的屏幕上所使用的技术之间也存在相当大的差异。在这里，我们将讨论一些特定的算法，这些算法可能在单个屏幕上运行良好，但在VR和AR上却存在问题。我们借鉴了Oculus、Valve、Epic Games、微软等公司的专业知识。这些公司的研究继续被收录到用户手册中，并在博客中进行讨论，因此我们建议访问他们的网站，了解当前的最佳实践。</strong></p>
<p><strong>正如上一节所强调的，供应商希望您理解他们的SDK和API，并适当地使用它们。视图是至关重要的，所以遵循供应商提供的头部模型，得到完全正确的相机投影矩阵。应该避免频闪灯等效果，因为闪烁会导致头痛和眼睛疲劳。在视野边缘附近闪烁会导致模拟器病。闪烁效应和薄条纹等高频纹理也会引发一些人癫痫发作。</strong></p>
<p><strong>基于显示器的电子游戏通常使用带有关于生命值、弹药或剩余燃料的叠加数据的抬头显示器。然而，对于VR和AR来说，双目视觉意味着距离观看者更近的物体在两眼之间有更大的偏移-收敛(章节21.2.3)。如果将HUD放置在屏幕的同一部分，则感知提示HUD必须离屏幕较远，如图21.4所示。然而，HUD被绘制在所有东西的前面。这种感知上的不匹配使得用户很难融合两幅图像并理解他们所看到的，这可能会导致不适。将HUD内容以接近眼睛的深度渲染解决了这个问题，但仍以屏幕面积为代价。参见下图。如果附近的墙比十字线更近，那么仍然存在深度冲突的风险，因为十字线图标仍然以给定的深度呈现在顶部。投射一条光线并找到给定方向上最近的表面深度可以用各种方法来调整这个深度，要么直接使用它，要么如果需要的话平滑地将它移动到更近的地方。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111105241.png" class="" title="image-20211111105241">

<p>一个繁忙的抬头显示，主导的观点。注意HUD元素必须针对每只眼睛进行移动，以避免令人困惑的深度线索。更好的解决方案是考虑将这些信息放入虚拟世界或玩家角色的设备或显示器中，因为用户可以倾斜或转头。要想看到立体效果，靠近并放置一张小而硬的纸，垂直于页面，让一只眼睛看着每一个图像。(图片由Oculus VR, LLC提供)</p>
<p><strong>在某些情况下，凹凸贴图在任何立体视觉系统中都工作得很糟糕，因为它是被看到的，在平面上绘制着色。它可以处理精细的表面细节和远处的物体，但对于表示更大的几何形状和用户可以接近的法线地图，这种错觉很快就会消失。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111105434.png" class="" title="image-20211111105434">

<p>对于较小的表面特征，比如左边和中间的两个纹理，法线贴图在VR中可以很好地工作。凹凸纹理代表了相当大的几何特征，例如右边的图像，在立体视觉中近距离观察时将无法令人信服。(图片由Valve提供)</p>
<p><strong>参见上图。基本视差映射的游动问题在立体声中更加明显，但可以通过一个简单的校正因子来改善。在某些情况下，可能需要更昂贵的技术，如陡视差映射、视差遮挡映射(第6.8.1节)或位移映射，以产生令人信服的效果。</strong></p>
<p><strong>广告牌和视点替用在立体视觉中有时不能令人信服，因为这些缺乏表面z-深度。体积技术或网格可能更合适。天空盒的大小需要让它们呈现在“无穷大”或附近，即眼睛位置的差异不应影响他们的渲染。如果使用色调映射，则应该对渲染后的两幅图像同样使用色调映射，以避免眼睛疲劳。屏幕空间环境遮挡和反射技术会产生不正确的立体差异。类似的，后期处理效果，如花华或耀斑，需要以一种尊重每个眼睛的z深度的方式生成，以便图像适当融合。水下或热雾变形效果也需要重新制作。屏幕空间反射技术产生的反射可能存在匹配问题，因此反射探头可能更有效。即使是高光高光也需要修改，因为立体视觉会影响到材料的光泽度。这两幅眼睛图像的高光位置可能有很大的差异。研究人员发现，修改这种差异可以使图像更容易融合，更有说服力。换句话说，当计算光泽成分时，眼睛的位置可能会移动得更近一些。相反，远处物体的高光差异可能在图像之间难以察觉，这可能导致共享着色计算。如果计算完成并存储在纹理空间中，就可以在眼睛图像之间共享着色。</strong></p>
<p><strong>VR对显示技术的要求非常高。代替,比如使用监视器和50度水平的视野,导致每度也许大约50像素,110度的视野在VR显示结果在大约每度15像素Vive的1080×1200像素显示为每只眼睛。从渲染图像到显示图像的转换也使重新采样和正确滤波的过程复杂化。用户的头部不断移动，即使只是一点点，也会增加时间混叠。由于这些原因，高质量的抗走样是提高图像质量和融合的实际要求。时间反锯齿经常被推荐，因为可能会模糊，尽管至少有一个团队在索尼已经成功地使用了。他们发现两者之间存在权衡，但去除闪烁的像素比提供更清晰的图像更重要。然而，对于大多数VR应用来说，MSAA提供的更清晰的视觉效果是首选。请注意，4× MSAA很好，8×更好，抖动超采样更好，如果你买得起的话。这种对MSAA的偏好与使用各种延迟渲染方法相抵触，因为对于每个像素多个样本来说，延迟渲染方法的成本很高。</strong></p>
<p><strong>在VR显示器上，颜色在阴影表面缓慢变化的条带(章节23.6)可以特别明显。这个伪影可以通过添加一点抖动噪声来掩盖。</strong></p>
<p><strong>不应该使用运动模糊效果，因为它们会使图像变得模糊，超出任何由于眼球运动而产生的伪影。这种效果与运行在90帧/秒的VR显示器的低持久性是不一致的。因为我们的眼睛确实在大视野中移动，通常是快速的扫视，所以景深技术应该避免。这种方法使得场景外围的内容看起来模糊，没有真正的原因，并可能导致模拟病。</strong></p>
<p><strong>混合现实系统带来了额外的挑战，比如将类似的光照应用到虚拟物体上，就像现实环境中一样。在某些情况下，现实世界的照明可以控制和转换为虚拟照明提前。当这是不可能的，您可以使用各种光估计技术来捕捉和近似环境的飞行照明条件。Kronander等人对各种照明捕获和表示方法进行了深入研究。</strong></p>
<h3 id="Judder-颤抖"><a href="#Judder-颤抖" class="headerlink" title="Judder 颤抖"></a>Judder 颤抖</h3><p><strong>即使虚拟世界和现实世界之间有完美的跟踪和适当维护的通信，延迟仍然是一个问题。生成45至120帧/秒的图像需要有限的时间，这是一系列VR设备的更新速率。</strong></p>
<p><strong>当图像没有及时生成并发送到排字器并显示时，就会出现丢弃帧。对Oculus Rift早期发行游戏的调查显示，它们的帧数下降了约5%。掉落的帧可以增加颤抖的感觉，这是VR头盔中最明显的涂抹和频闪伪影，当眼睛相对于显示器移动时。参见下图。如果像素在帧的持续时间内被照亮，眼睛的视网膜上就会接收到污迹。降低持久度，即在一帧中显示器照亮像素的时间长度，可以减少模糊效果。然而，它可能会导致频闪，如果帧之间有很大的变化，多个独立的图像被感知。Abrash深入讨论了抖动和它与显示技术的关系。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111105905.png" class="" title="image-20211111105905">

<p>颤抖。连续显示四帧，CPU和GPU尝试为每一帧计算图像。第一个帧的图像(以粉红色显示)被及时计算并发送给该帧的排字器。下一个图像(蓝色)没有在第二帧中显示完成，因此必须再次显示第一个图像。绿色的第三张图片也没有及时准备好，所以(现在已经完成的)第二张图片被发送到第三帧的排字器。橙色的第四幅图像是及时完成的，因此显示。注意，第三帧的渲染计算结果永远不会显示出来。(源自Oculus的插图。)</p>
<p><strong>供应商提供的方法可以帮助最小化延迟和抖动效果。其中一组技术被Oculus称为时间翘曲和空间翘曲，对生成的图像进行翘曲或修改，以更好地匹配用户的方向和位置。首先，假设我们没有丢弃帧，我们检测到用户正在旋转他们的头部。我们使用检测到的旋转来预测每只眼睛的位置和视野方向。有了完美的预测，我们生成的图像就完全符合需要。</strong></p>
<p><strong>相反地，假设用户正在旋转他们的头部并正在减速。对于这种情况，我们的预测将会超出预期，生成的图像在显示时间应该提前一点。除了速度外，估计旋转加速度有助于改进预测。</strong></p>
<p><strong>更严重的情况是帧被丢弃。在这里，我们必须使用前一帧的图像，因为有些东西需要放到屏幕上。给定我们对用户视图的最佳预测，我们可以修改该图像以近似缺失帧的图像。我们能做的一个操作是二维图像扭曲，也就是Oculus所说的时间扭曲。它只补偿头部的旋转姿势。这种扭曲操作是一种快速的纠正措施，比什么都不做要好得多。Van Waveren讨论了各种时间扭曲实现的权衡，包括在CPU和数字信号处理器(DSP)上运行的时间扭曲实现，得出的结论是GPU是目前为止完成这项任务最快的。大多数GPU可以在不到半毫秒的时间内完成这个图像扭曲过程。旋转先前显示的图像会导致显示图像的黑色边框在用户的周边视觉中变得可见。渲染比当前帧需要的更大的图像是避免这个问题的一种方法。然而，在实践中，这一边缘区域几乎不引人注意。</strong></p>
<p><strong>除了速度，纯旋转扭曲的一个优势是场景中的其他元素都是一致的。用户实际上处于环境天空盒的中心(章节13.3)，只改变视图的方向和方向。这种技术速度很快，而且效果很好。缺失帧已经够糟糕的了，但由于间歇性的帧丢失而导致的可变且不可预测的延迟似乎更迅速地导致了模拟病。为了提供更流畅的帧率，Valve在检测到帧下降时启用了交错重投影系统，将渲染率降至45 FPS，并每隔一帧进行扭曲。类似地，PLAY STATION上的一个VR版本有120赫兹的刷新率，其中渲染以60赫兹执行，重新投影以填充交替帧。</strong></p>
<p><strong>仅仅为了旋转而修正是不够的。即使用户没有移动或移动他们的位置，当头部旋转或倾斜时，眼睛确实改变了位置。例如，当仅仅使用图像扭曲时，眼睛之间的距离会显得更小，因为新图像是使用眼睛分离，眼睛指向不同的方向。这是一个很小的影响，但如果不适当地补偿位置变化，可能会导致用户迷失方向和生病，如果有物体靠近观看者，或如果观看者向下看一个纹理地平面。要调整位置变化，可以执行完全三维重投影(第12.2节)。图像中的所有像素都有一个与它们相关的深度，所以这个过程可以被认为是将这些像素投影到它们在世界中的位置，移动眼睛的位置，然后将这些点重新投影到屏幕上。Oculus称这个过程为位置时间扭曲。除了费用高昂之外，这种方法还有几个缺点。一个问题是，当眼睛移动时，一些表面可能进入或离开视野。这可以以不同的方式发生，例如，一个立方体的表面可以变得可见，或视差可以导致一个物体在前景中相对于背景移动，以便在那里隐藏或显示细节。重投影算法试图识别不同深度的物体，并使用局部图像扭曲来填补发现的任何缺口。这样的技术可以造成解除遮挡的痕迹，当一个物体从他们面前经过时，扭曲使得远处的细节似乎发生了变化和动画。透明度不能通过基本的重投影来处理，因为只有一个表面的深度是已知的。例如，这种限制会影响粒子系统的出现。</strong></p>
<p><strong>图像扭曲和重投影技术的一个问题是碎片的颜色是根据旧位置计算的。我们可以改变这些碎片的位置和可见性，但任何高光或反射都不会改变。掉落的帧可以显示这些表面高光的抖动，即使表面本身被完美地平移。即使没有任何头部运动，这些方法的基本版本也无法补偿场景中的物体运动或动画。我们只知道表面的位置，不知道它们的速度。因此，对于一个外推图像，物体不会自己在帧到帧之间移动。对象的移动可以在速度缓冲区中捕获，如12.5节所述。这样做允许重新投影技术也根据这些更改进行调整。</strong></p>
<p><strong>旋转和位置补偿技术通常在一个独立的、异步的过程中运行，作为防止帧掉落的一种形式。Valve称之为异步重投影，Oculus称之为异步时间扭曲和异步空间扭曲。《Spacewarp》通过分析之前的帧来推断缺失的帧，并考虑到摄像机和头部的平移以及动画和控制器的运动。深度缓冲器在空间曲速中不使用。除了正常的渲染，外推图像是独立地计算在同一时间。由于是基于图像的，这个过程需要相当多的时间，这意味着如果渲染不能及时完成，重新投影的图像通常是可用的。因此，不用再决定是继续尝试完成画面，还是使用时间扭曲或空间扭曲重新投影，两者都完成了。如果框架没有及时完成，那么空间曲速结果是可用的。硬件需求是有限的，这些扭曲技术主要是作为对功能较差的系统的辅助。Reed和Beeler讨论了GPU共享的不同方式以及如何有效地使用异步翘曲，Hughes等人也做了同样的研究。</strong></p>
<p><strong>旋转和定位技术是互补的，每一种都有自己的改进。旋转扭曲可以完美地适应头部旋转时，观看遥远的静态场景或图像。位置重投影对附近的动画对象很好。相对于位置偏移，方向的变化通常会引起更严重的配准问题，因此即使只是旋转校正也能提供相当大的改进。</strong></p>
<p><strong>我们在这里讨论的是这些补偿过程背后的基本思想。当然，关于这些方法的技术挑战和限制有更多的文章，我们请感兴趣的读者参考相关参考文献。</strong></p>
<h3 id="Timing-时机"><a href="#Timing-时机" class="headerlink" title="Timing 时机"></a>Timing 时机</h3><p><strong>虽然异步时间翘曲和空间翘曲技术可以帮助避免抖动，但保持质量的最佳建议是应用本身尽可能避免掉帧。即使没有抖动，我们注意到用户在显示时的实际姿势可能与预测的姿势不同。因此，一种称为晚方向扭曲的技术可能有助于更好地匹配用户应该看到的内容。这个想法是得到姿势并像往常一样生成帧，然后在帧中检索更新后的姿势预测。如果这个新的姿态不同于渲染场景的原始姿态，那么在这个帧上执行旋转扭曲(时间扭曲)。由于翘曲通常只需要不到半毫秒的时间，这种投资通常是值得的。在实践中，这种技术通常是排字本身的责任。</strong></p>
<p><strong>通过使用延迟锁存(late latching)技术，可以使这个进程运行在单独的CPU线程上，从而最小化获取这个稍后方向数据所花费的时间。这个CPU线程定期将预测的姿态发送到GPU的私有缓冲区，GPU会在扭曲图像之前的最后可能时刻获取最新的设置。延迟锁定可以用来直接向GPU提供所有头部姿态数据。这样做有一个限制，即每个眼睛的视图矩阵在那个时候对应用程序是不可用的，因为只有GPU提供了这个信息。AMD有一个改进的版本叫做最新数据锁存器，它允许GPU在需要这些数据的时候抓取最新的姿态。</strong></p>
<p><strong>你可能已经注意到在图21.12中CPU和GPU有相当长的停机时间，因为CPU直到排字完成才开始处理。这是单个CPU系统的简化视图，其中所有的工作都发生在单个帧中。正如在第18.5节中讨论的，大多数系统都有多个CPU，它们可以以各种方式保持工作。在实际操作中，cpu通常负责碰撞检测、路径规划或其他任务，并为GPU在下一帧渲染准备数据。流水线已经完成，GPU可以在CPU在上一帧设置的任何地方工作。为了有效，CPU和GPU每帧的工作应该少于一帧。参见下图。排字师通常使用一种方法来知道GPU何时完成。它被称为fence，由应用程序作为命令发出，当所有GPU调用都在它完全执行之前发出信号。fence对于知道GPU什么时候用完各种资源很有用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111110337.png" class="" title="image-20211111110337">

<p>管线。为了最大限度地利用资源，cpu在一帧内执行任务，GPU用于渲染下一帧。通过使用运行开始/自适应队列，底部显示的间隙可以被添加到每一帧的GPU执行时间中。</p>
<p><strong>图中所示的GPU持续时间表示绘制图像所花费的时间。一旦合成器完成了创建和显示最后一帧，GPU就准备开始渲染下一帧了。CPU需要等待合成完成后才能向GPU发出下一帧的命令。然而，如果我们一直等到图像显示出来，那么应用程序在CPU上生成新命令时就会花费一些时间，这些命令会被驱动程序解释，最终命令会发布给GPU。在这段时间里，GPU是空闲的，这段时间可能高达2毫秒。Valve和Oculus通过提供调用的支持来避免这种停机时间分别在前面运行启动和自适应队列。这种技术可以在任何系统上实现。其目的是让GPU在完成前一帧后立即开始工作，通过计时前一帧预期完成的时间并在此之前发出命令。大多数VR API都提供了一些隐式或显式的机制来发布应用程序，以便在有规律的节奏下运行下一帧，并有足够的时间来最大化吞吐量。在这一节中，我们提供了管线和这个缺口的简化视图，以便让人们了解这种优化的好处。参见Vlachos和Mah的演讲，深入讨论流水线和计时策略。</strong></p>
<p><strong>我们在这里结束对虚拟现实和增强现实系统的讨论。鉴于写作和出版之间的时间差，我们预计会出现许多新技术，并取代这里介绍的技术。我们的主要目标是在这个快速发展的领域提供渲染问题和解决方案的感觉。最近研究探索的一个迷人的方向是使用光线投射进行渲染。例如，Hunt讨论了这种可能性，并提供了一个开源的CPU/GPU混合射线投射器，它可以评估每秒超过100亿射线。光线投射直接解决了光栅化系统面临的许多问题，如宽视场和镜头失真，同时也适用于凹点渲染。McGuire指出，光线可以在滚动显示器显示之前投射到像素上，从而将系统这部分的延迟降低到几乎为零。这与其他许多研究项目一起，使他得出结论，我们将在未来使用VR，但不称之为VR，因为它将只是每个人的计算界面。</strong></p>
<h1 id="22-Intersection-Test-Methods-交叉测试法"><a href="#22-Intersection-Test-Methods-交叉测试法" class="headerlink" title="22 Intersection Test Methods 交叉测试法"></a>22 Intersection Test Methods 交叉测试法</h1><p><strong>交叉测试是计算机图形学中常用的测试方法。我们可能希望确定两个物体是否发生碰撞，或者找到到地面的距离，这样我们就可以保持相机在一个恒定的高度。另一个重要的用途是确定是否应该将对象发送到管道中。所有这些操作都可以通过交集测试来执行。在本章中，我们将介绍最常见的光线/物体和物体/物体相交测试。</strong></p>
<p><strong>在碰撞检测算法中，也建立在层次结构之上，系统必须决定两个原始对象是否发生碰撞。这些对象包括三角形、球体、轴向包围盒(AABBs)、定向包围盒(OBBs)和离散的定向多边形(k-DOPs)。</strong></p>
<p><strong>正如我们在第19.4节中看到的，视图截锥剔除是一种有效地丢弃视图截锥之外几何图形的方法。使用此方法需要决定包围体(BV)是否完全位于锥体外部、内部或部分位于锥体内部的测试。</strong></p>
<p><strong>在所有这些情况下，我们都遇到了需要交叉测试的一类问题。交集测试确定两个物体A和B是否相交，这可能意味着A完全在B内部(或者相反)，A和B的边界相交，或者它们是不相交的。然而，有时可能需要更多的信息，如与某个位置最近的交点，或渗透的数量和方向。</strong></p>
<p><strong>在这一章中，我们重点讨论快速交集测试方法。文中不仅给出了基本算法，而且对如何构造新的、高效的交点测试方法提出了建议。当然，本章所介绍的方法也适用于脱机计算机图形应用。例如，在第22.6至22.9节中介绍的射线相交算法在射线追踪程序中使用。</strong></p>
<p><strong>在简要介绍硬件加速拾取方法之后，本章继续介绍一些有用的定义，然后是形成边界体的算法在原语。然后给出了构造高效交集测试方法的经验法则。最后，本章的大部分内容由交叉测试方法的手册组成。</strong></p>
<h2 id="GPU-Accelerated-Picking-GPU加速筛选"><a href="#GPU-Accelerated-Picking-GPU加速筛选" class="headerlink" title="GPU-Accelerated Picking GPU加速筛选"></a>GPU-Accelerated Picking GPU加速筛选</h2><p><strong>让用户用鼠标或其他输入设备选择(点击)某个对象通常是可取的。当然，这样的操作需要很高的性能。</strong></p>
<p><strong>如果您需要将所有对象集中在屏幕上的一个点或更大的区域，而不考虑能见度，那么CPU端选择解决方案可能是必要的。这种类型的挑选有时会在建模或CAD软件包中看到。它可以在CPU上通过使用包围卷层次结构有效地解决(章节19.1.1)。在像素的位置形成一条射线，从视图截锥的近平面到远平面。然后根据需要测试光线与包围体层次的交集，类似于在全局光照算法中加速追踪光线的做法。对于用户在屏幕上定义矩形所形成的矩形区域，我们将创建一个截锥而不是射线，并在层次结构中测试它。</strong></p>
<p><strong>CPU上的交集测试有几个缺点，这取决于需求。拥有成千上万个三角形的网格，如果一个三角形一个三角形地进行测试，代价会非常昂贵，除非网格本身有一些加速结构，比如层次结构或网格。如果精度很重要，由位移映射或GPU镶嵌生成的几何图形需要由CPU匹配。对于alpha映射的对象，比如树叶，用户不应该选择完全透明的像素。在CPU上需要大量的工作来模拟纹理访问，以及任何其他材质，因为任何原因丢弃像素。</strong></p>
<p><strong>通常情况下，我们只需要屏幕上某个像素或某个区域上可见的内容。对于这种类型的选择，使用GPU管线本身。Hanrahan和Haeberli首先提出了一种方法。为了支持拾取，场景中每个三角形、多边形或网格对象都有一个唯一的标识符值，可以将其视为一种颜色。这个想法与可见性缓冲区的意图相似，形成的图像类似于第906页的图20.12。形成的图像存储在屏幕外，然后用于极其快速的拾取。当用户点击一个像素时，图像中的颜色标识符就会被查找，对象也会立即被识别出来。当使用简单的着色器执行标准渲染时，这些标识符值可以被渲染到一个单独的渲染目标，因此成本相对较低。主要的花费可能是将像素从GPU读取回CPU。</strong></p>
<p><strong>像素着色器接收或计算的任何其他类型的信息也可以存储在屏幕外的目标中。例如，法线或纹理坐标是很明显的候选者。利用这种系统，利用插值也可以找到三角形内点的相对位置。在一个单独的渲染目标中，每个三角形都被渲染为三角形顶点的红色(255, 0,0)，绿色(0,255,0)，蓝色(0,0,255)。假设所选像素的插值颜色是(23,192,40)，这意味着红色顶点贡献因子23/255，绿色顶点贡献因子192/255，红色顶点贡献因子40/255。这些值是重心坐标，将在22.8.1节进一步讨论。</strong></p>
<p><strong>使用GPU拾取最初是作为三维绘图系统的一部分呈现的。这种拾取特别适合于这样的系统，摄像机和物体都不移动，因为整个拾取缓冲器可以生成一次并重复使用。为了选择相机何时移动，另一种方法是将场景再次渲染到一个微小的目标上，例如，3 × 3，使用离轴相机聚焦在屏幕的一小部分。CPU侧截锥剔除应该消除几乎所有的几何图形，只有少数像素被着色，使此通道相对快速。对于选择所有对象(不仅仅是可见对象)，这个小窗口方法可以执行多次，使用深度剥离或简单地不渲染先前选择的对象。</strong></p>
<h2 id="Definitions-and-Tools-定义和工具"><a href="#Definitions-and-Tools-定义和工具" class="headerlink" title="Definitions and Tools 定义和工具"></a>Definitions and Tools 定义和工具</h2><p><strong>本节介绍整个章节中有用的符号和定义。</strong></p>
<p><strong>一条射线r(t)由原点o和方向矢量d定义(为方便起见，通常归一化为||d|| = 1)。其数学公式如下式所示，射线的图解如下图所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111225335.png" class="" title="image-20211111225335">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111225351.png" class="" title="image-20211111225351">

<p>一条简单的射线及其参数:o(射线原点)，d(射线方向)，以及在射线上产生不同点的t, r(t) = o + td。</p>
<p><strong>标量t是一个变量，用于在射线上生成不同的点，其中小于零的t值位于射线原点后面(因此不属于射线)，正的t值位于射线原点前面。此外，由于射线方向是标准化的，t值在射线上生成一个点，该点距离射线原点的距离为t单位。</strong></p>
<p><strong>在实践中，我们通常也存储一个交点距离l，这是我们想沿着射线搜索的最大距离。例如，在选择时，我们通常想要沿着射线最近的交点;这个交点以外的物体可以忽略不计。</strong></p>
<p><strong>距离l从∞开始。当物体成功相交时，l用相交距离更新。一旦设置了l，射线就变成了用于测试的线段。在我们将要讨论的光线/物体相交测试中，我们通常不会在讨论中包含l。如果您希望使用l，您所要做的就是执行普通的射线/物体测试，然后检查l与计算出的交点距离，并采取适当的行动。</strong></p>
<p><strong>当讨论曲面时，我们要区分隐式曲面和显式曲面。隐式曲面由下式定义:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111225651.png" class="" title="image-20211111225651">

<p><strong>这里，p是曲面上的任意点。这意味着如果在曲面上有一个点把这个点代入f，那么结果就是0。否则，f的结果将是非零的。隐曲面的一个例子是p²x + p²y + p²z = r²，它描述了一个半径为r的位于原点的球体。很容易看出，这可以重写为f(p) = p²x + p²y + p²z −r² = 0，表示它确实是隐式的。隐式曲面在17.3节中进行了简要介绍，而Gomes等人和de Ara´ujo等人对各种隐式曲面类型的建模和绘制进行了详细介绍。</strong></p>
<p><strong>另一方面，显式曲面由向量函数f和一些参数(ρ， φ)定义，而不是由曲面上的一个点定义。这些参数在表面上的产出点p。一般思路如下下式所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111230001.png" class="" title="image-20211111230001">

<p><strong>显式曲面的一个例子是球面，这一次用球坐标表示，其中ρ是纬度，φ是经度，如下公式所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111230039.png" class="" title="image-20211111230039">

<p><strong>另一个例子，三角形△v0v1v2，可以这样明确地描述:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111230111.png" class="" title="image-20211111230111">

<p><strong>最后，我们将给出除球面外的一些常见边界体的定义。</strong></p>
<p><strong>定义。</strong></p>
<p><strong>轴对齐的边界框(也称为矩形框)，简称AABB，是一个面法线与标准基轴重合的框。例如，AABB A用两个对角相对的点a^min和 a^max来描述，其中 ai^min ≤ ai^max，∀i∈{x, y, z}。</strong></p>
<p><strong>下图包含了一个三维AABB的插图符号。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111230354.png" class="" title="image-20211111230354">

<p>一个三维的AABB, A，及其极点a^min 和 a^max，以及标准基的坐标轴。</p>
<p><strong>定义。</strong></p>
<p><strong>一个有方向的边界框，简称OBB，是一个面法线都是成对正交的框。，它是一个任意旋转的AABB。OBB，B可以用盒子的中心点 b^c和三个标准化的向量( b^u, b^v, b^w)来描述，这三个向量描述了盒子的侧面方向。它们各自的正半长用 hu^B, hv^B ,和hw^B表示，也就是到 b^c 的距离到各自面的中心。</strong></p>
<p><strong>三维OBB及其表示法如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111230721.png" class="" title="image-20211111230721">

<p>一个三维OBB, B，它的中心点，b^c，以及它的正方向的正向量 b^u ,b^v, b^w ．边的半长 hu^B, hv^B ,和hw^B，为从盒子中心到面中心的距离，如图所示。</p>
<p><strong>定义。</strong></p>
<p><strong>k- DOP(离散方向多面体)定义为k/2(其中k是偶数)标准化法线(方向)，ni， 1≤I≤k/2，且每个ni 两个关联的标量值di^min和 di^max,其中 di^min&lt; di^max．每个三元组(ni, di^min, di^max)描述slab, Si也就是两个平面之间的体积 πi^min:ni·x + di^min= 0 和 πi^max:ni ·x + di^max = 0, 其中所有slab的交点 , ∩1≤l≤k/2， Sl为实际k- dop体积。k-DOP被定义为该边界最紧密的slab对象。AABBs和OBBs可以用6- DOPs表示，因为每一个都有三个板定义的6个平面。下图描述了一个二维的8-DOP。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111231846.png" class="" title="image-20211111231846">

<p>一个二维8-DOP茶杯的例子，所有法线，ni，与第一块slab，S1，slab的“尺寸”为:d1^min和 d1^max．</p>
<p><strong>对于凸多面体的定义，利用平面半空间的概念是有用的。正半空间包括n·x + d≥0的所有点x，负半空间是n·x + d≤0。</strong></p>
<p><strong>定义。</strong></p>
<p><strong>凸多面体是由p个平面的负半空间的交点定义的有限体积，其中每个平面的法线都指向多面体。</strong></p>
<p><strong>AABBs, OBBs和k-DOPs，以及任何视图截锥，都是凸多面体的特殊形式。更复杂的k-DOPs和凸多面体主要用于碰撞检测算法，在这种算法中，计算底层网格的精确交点是非常昂贵的。用于形成这些边界体的额外平面可以从对象中修剪额外的体积，因此证明所涉及的额外成本是合理的。</strong></p>
<p><strong>另外两个感兴趣的边界体是线扫球和矩形扫球。它们通常也被分别称为胶囊和含片，示例如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111232258.png" class="" title="image-20211111232258">

<p>直线扫球和矩形扫球，又称胶囊和菱形。</p>
<p><strong>分离轴指定一条线，其中两个不重叠(不相交)的物体在该线上的投影也不重叠。类似地，当一个平面可以插入两个三维物体之间时，平面的法线定义了一个分离轴。接下来是交叉测试的一个重要工具，它适用于凸多面体，如AABBs, OBBs和k-DOPs。这是分离超平面定理的一个方面。</strong></p>
<p><strong>分离轴测试(SAT)。</strong></p>
<p><strong>对于任意两个凸不相交多面体A和B，至少存在一个分离轴，在该轴上形成间隔的多面体的投影也是不相交的。如果一个物体是凹的，这就不成立了。例如，井壁和桶壁可能不接触，但没有平面可以将它们分开。此外，如果A和B是不相交的，那么它们可以被一个正交的轴分开(即。，通过平行平面)与以下任一:</strong></p>
<p><strong>1.A的A面。</strong> </p>
<p><strong>2.A的B面。</strong> </p>
<p><strong>3.每个多面体的边(如叉积)。</strong> </p>
<p><strong>前两个测试表明，如果一个物体完全位于另一个物体的另一侧，它们就不能重叠。前两个测试处理的人脸，最后一个测试基于对象的边缘。为了在第三个测试中分离物体，我们想要在一个平面(其法线是分离轴)中尽可能地靠近两个物体，这样一个平面与物体的距离不能比物体的一条边更近。所以，要测试的分离轴都是由两个对象的边的叉乘形成的。这个测试在下图中演示了两个盒子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111232534.png" class="" title="image-20211111232534">

<p>分离轴。将蓝色框称为A，黄色框称为B。第一张图显示B完全位于A的右表面的右侧，第二张图显示A完全位于B的左下表面的下方。因此，由A的右上边缘和B的左下边缘的叉乘形成的轴定义了分隔两个物体的平面的法线。</p>
<p><strong>注意这里凸多面体的定义是自由的。线段和凸多边形(如三角形)也是凸多面体(虽然退化，因为它们没有包围体积)。线段A没有面，所以第一个测试消失了。该检验用于推导22.12节的三角形/盒重叠检验和22.13.5节的OBB/OBB重叠检验。Gregorius注意到一个重要的优化，任何交叉测试使用分离轴:时间相干。如果在这一帧中发现了一个分离轴，则将此轴存储为下一帧中测试对象对的第一个轴。</strong></p>
<p><strong>回到可以使用的方法的讨论，优化交叉测试的一种常见技术是在早期进行一些简单的计算，以确定射线或物体是否错过了另一个物体。这样的测试称为拒绝测试，如果测试成功，则称交集被拒绝。</strong></p>
<p><strong>本章中经常使用的另一种方法是将三维物体投射到“最佳”正交平面(xy、xz或yz)，并在二维空间中解决问题。</strong></p>
<p><strong>最后，由于数值计算的不精确性，在交点测试中，我们通常使用一个极小的数值。这个数字表示ε (epsilon)，它的值会随着测试的不同而变化。然而，通常会选择适用于程序员的问题情况的epsilon (Press等人称之为“方便的虚构”)，而不是进行仔细的舍入误差分析和调整。在其他设置中使用的这种代码可能会因为条件的不同而中断。Ericson的书在几何计算的背景下深入讨论了数值稳健性的领域。这一点很明确，我们有时确实试图提供对于“普通”数据来说至少是合理的初始值，小规模(比如小于100，大于0.1)，并且在原点附近。</strong></p>
<h2 id="Bounding-Volume-Creation-创建边界体积"><a href="#Bounding-Volume-Creation-创建边界体积" class="headerlink" title="Bounding Volume Creation 创建边界体积"></a>Bounding Volume Creation 创建边界体积</h2><p><strong>给定一个对象集合，寻找一个紧密的拟合包围体对于最小化相交代价非常重要。任意射线击中任意凸物体的概率与该物体的表面积成正比(第22.4节)。最小化这个区域可以提高任何交集算法的效率，因为拒绝永远不会比交集慢。相比之下，在碰撞检测算法中，尽量减小每个BV的体积往往更好。本节简要介绍给定多边形集合的最优或接近最优边界体积的方法。</strong></p>
<h3 id="AABB-and-k-DOP-Creation-AABB和k-DOP创建"><a href="#AABB-and-k-DOP-Creation-AABB和k-DOP创建" class="headerlink" title="AABB and k-DOP Creation AABB和k-DOP创建"></a>AABB and k-DOP Creation AABB和k-DOP创建</h3><p><strong>要创建的最简单的绑定卷是AABB。取多边形顶点集合沿各轴的最小和最大范围，形成AABB。k-DOP是AABB的扩展:将顶点投影到每个法线ni上，这些投影的极值(min,max)存储在di^min 和 di^max中．这两个值定义了该方向最紧的板。所有这些值一起定义了一个最小k-DOP。</strong></p>
<h3 id="Sphere-Creation-球体创造"><a href="#Sphere-Creation-球体创造" class="headerlink" title="Sphere Creation 球体创造"></a>Sphere Creation 球体创造</h3><p><strong>边界球的形成不像确定板的范围那么简单。有许多算法可以执行此任务，它们在速度和质量之间进行权衡。一种快速、常数时间的单通道算法是为多边形集形成一个AABB，然后使用这个盒子的中心和对角线来形成球体。这有时会给一个贫穷的健康,可能被另一个通过改进:从中心的AABB球体的中心BV,再次遍历所有顶点,找到一个最远的从这个中心(比较对距离的平方,避免以平方根)。这是新的半径。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113115332.png" class="" title="image-20211113115332">

<p>球体边界框。最简单的是，在左边，一个物体可以在它的边界框周围有一个边界球。如果物体没有延伸到边界框的任何角落，那么可以通过使用框的中心并遍历所有顶点来找到最远的距离来设置球体的半径，就像中间的图像一样。通过移动球体的中心可以得到更小的半径，如右图所示。</p>
<p><strong>如果要在父球体中嵌套子球体，则只需要对这两种技术进行轻微的修改。如果所有的子球体都有相同的半径，这些中心可以被视为顶点，并且这个子球体半径会在任何一个过程结束时被添加到父球体的半径中。如果半径变化，AABB边界可以通过在边界计算中包含这些半径来找到一个合理的中心。如果执行了第二次传递，将每个半径加到点到父节点中心的距离上。</strong></p>
<p><strong>Ritter提出了一个简单的算法，可以创建一个接近最优的边界球。其思想是沿着每一个x, y, z轴找到最小的顶点和最大的顶点。对于这三对顶点，找出它们之间距离最大的那对。使用这一对来形成一个球体，其中心在它们之间的中点，半径等于到它们的距离。遍历所有其他顶点，检查它们到圆心的距离d。如果顶点在球体半径r之外，将球体的中心向顶点移动(d - r)/2，设置半径为(d + r)/2，然后继续。这个步骤的效果是将顶点和现有的球体包围在一个新的球体中。在第二次遍历列表之后，边界球体保证包围所有顶点。</strong></p>
<p><strong>Welzl提出了一种更复杂的算法，该算法由Eberly和Ericson等人通过网络代码实现。其思想是找到定义球体的支撑点集。一个球体可以由其表面上的两个、三个或四个点组成。当一个顶点被发现在当前球体之外时，它的位置被添加到支持集中(可能旧的支持顶点从支持集中移除)，新的球体被计算，整个列表再次运行。这个过程重复，直到球体包含所有顶点。虽然比以前的方法更复杂，但该算法保证找到最优的边界球。</strong></p>
<p><strong>Ohlarik比较了Ritter和Welzl算法变体的速度。Ritter的简化版只比基本版贵20%，但有时效果会更差，所以两者都运行是值得的。Eberly的Welzl算法的实现对于随机的点列表是线性的，但是运行速度要慢一个数量级左右。</strong></p>
<h3 id="Convex-Polyhedron-Creation-创建凸多面体"><a href="#Convex-Polyhedron-Creation-创建凸多面体" class="headerlink" title="Convex Polyhedron Creation 创建凸多面体"></a>Convex Polyhedron Creation 创建凸多面体</h3><p><strong>包围体的一种一般形式是凸多面体。凸物可配合分离轴试验使用。AABBs,k-DOPs和OBBs都是凸多面体，但可以找到更紧密的边界。正如k-DOPs可以被认为是通过添加额外的平面对从一个物体上剪去更多的体积一样，凸多面体可以由任意的平面集定义。通过削减额外的体积，更昂贵的测试涉及到封闭的多边形对象的整个网格可以避免。我们想要“收缩”我们的多边形对象，并找到这组平面，它们形成了凸包。下图显示了一个示例。凸包可以用Quickhull算法来找到。尽管名称如此，但该过程比线性时间慢，因此通常作为复杂模型的离线预处理执行。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113115812.png" class="" title="image-20211113115812">

<p>使用Quickhull计算出茶壶的凸壳。</p>
<p><strong>可以看出，这个过程可能会产生大量的平面，每个平面都由凸包上的一个多边形定义。在实践中，我们可能不需要这种精度。首先创建原始网格的简化版本，可能向外扩展以完全包含原始网格，将产生一个不太精确但更简单的凸包。还需要注意的是，对于k-DOPs，随着k的增加，BV越来越类似于凸包。</strong></p>
<h3 id="OBB-Creation-OBB创建"><a href="#OBB-Creation-OBB创建" class="headerlink" title="OBB Creation  OBB创建"></a>OBB Creation  OBB创建</h3><p><strong>一个物体可能有一个自然的OBB，因为它从一个AABB开始，然后经历一个旋转，从而使AABB成为OBB。然而，随后使用的OBB可能不是最优的。想象一个旗杆模型以一定角度从建筑延伸出来。围绕它的AABB不像沿其长度延伸的OBB那样紧。对于没有明显最佳轴的模型，基方向任意的OBB形成比寻找合理的边界球更为复杂。</strong></p>
<p><strong>在为这个问题创建算法方面已经做了大量的工作。O’rourke从1985年开始的精确解在O(n³)时间内运行。Gottschalk提出了一种更快、更简单的方法，它给出了最佳OBB的近似。它首先计算多边形网格的凸壳，以避免模型顶点在这个体积内可能导致结果偏差。然后利用线性时间的主成分分析(PCA)找到合理的OBB轴。这种方法的缺点是盒子有时是松散的。埃伯利描述了一种使用极小化技术计算最小体积OBB的方法。他为方框取样一组可能的方向，并使用OBB最小的轴作为数值最小化器的起点。然后使用Powell方向集方法来寻找最小体积盒。Eberly在网上有这个操作的代码。还有其他的算法;Chang等人对之前的工作给出了合理的概述，并提出了他们自己的最小化技术，即使用遗传算法来帮助搜索解空间。</strong></p>
<p><strong>在这里，我们提出了Larsson和K¨allberg的一种算法，一种不需要凸包并在线性时间内执行的近似最优方法。它通常提供比Gottschalk基于PCA的方法更好的质量，执行速度相当快，适合SIMD并行化，并且有作者提供的代码。首先，为对象形成一个k-DOP，并保存一对(任意一对)接触到每个k-DOP板的相对边的顶点。所有这些顶点对一起称为对象的极值点。例如，一个26-DOP生成13对点，其中一些点可能指定同一个顶点，可能给出一个较小的整体集合。“最佳OBB”被初始化为围绕对象的AABB。然后，该算法通过寻找可能提供更好匹配的OBB方向继续进行。一个大的基础三角形被构造出来，两个四面体从它的表面延伸出来。这就形成了一组7个三角形，产生了潜在的接近最优的OBBs。</strong></p>
<p><strong>这对彼此距离最远的点构成了底边三角形的一条边。离这条边最远的剩余极值点的顶点构成三角形的第三个点。每个三角形的边和在三角形的平面上的边的法线被用来形成一个潜在的新OBB的两个轴。剩余的极值点投影到这些轴上，以找到三个OBBs在平面上的二维边界。参见下图。用最小的周围二维矩形从三个OBB中选出最佳OBB。因为这三个OBB的高度、沿三角形法线的距离都是相同的，所以每个OBB周围的二维边界框足以决定哪一个是最好的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113120251.png" class="" title="image-20211113120251">

<p>算法形成方向包围盒;记住，所有的点都是三维的。对于每个k-DOPs的slab(由一对彩色线标记)，在其极限处有一对点，用黑色标记;底部的两个顶点都是两个平板的顶点。其他用灰色标记的顶点在以下步骤中不使用。在这四对中，相隔最远的两个顶点构成一条边。从这条边的直线最远的极值点被用来与这条边形成一个三角形。形成了三个盒子，每个盒子使用三角形边来定义它的轴，其余的极值点来定义它的边界。在这三个盒子中，最好的盒子被保存了下来。</p>
<p><strong>剩余的极值点被用来通过与三角形法线的投影来找到这个OBB在三维空间中的范围。这个完全形成的OBB与最初的AABB进行检查，看哪个更好。在这个过程中发现的两个极值点，一个在高度最大值，一个在高度最小值，然后形成两个四面体，每个四面体的基础都是原来的大三角形。每个四面体依次形成三个额外的三角形，对每个三角形的三个候选OBB进行评估，就像对原始三角形进行评估一样。对于每个三角形，最好的二维OBB也像之前一样沿着其高度展开，但只是为了得到候选OBB的最终大小，而不是形成更多的三角形。总共形成7个三角形，并生成一个完整的OBB，并从每个OBB进行比较。</strong></p>
<p><strong>一旦找到最佳OBB，原始物体中的所有点都投影到它的轴线上，根据需要增加它的大小。最后对原来的AABB进行检查，看看这个OBB是否真的更适合。这整个过程比以前的技术更快，并且受益于对大多数步骤使用一组极小的极值点。值得注意的是，作者更喜欢基于表面积而不是体积来优化包围框，原因我们将在下一节介绍。</strong></p>
<h2 id="Geometric-Probability-几何概率"><a href="#Geometric-Probability-几何概率" class="headerlink" title="Geometric Probability 几何概率"></a>Geometric Probability 几何概率</h2><p><strong>常见的几何运算包括平面或光线是否与物体相交，以及物体内部是否有点。一个相关的问题是点、射线或平面与物体相交的相对概率是多少。空间中一个随机点在物体内部的相对概率是相当明显的:它与物体的体积成正比。因此，1×2×3盒子包含随机选择点的概率是1× 1× 1盒子的6倍。</strong></p>
<p><strong>对于空间中的任意一条射线，射线与物体相交的相对概率是多少?这个问题与另一个问题有关:当使用正交投影时，任意方向的对象覆盖的像素的平均数量是多少?正射影可以被认为是视图体中的一组平行光线，光线通过每个像素。给定一个随机方向的对象，所覆盖的像素数等于与该对象相交的射线数。</strong></p>
<p><strong>答案非常简单:任何凸面实体的平均投影面积是其表面积的四分之一。对于屏幕上的球面来说，这显然是正确的，它的正投影总是一个面积为πr²的圆，它的表面积是4πr²。同样的比例适用于任何其他任意方向的凸物体，如框或k-DOP的平均投影。参见Nienhuys的文章以获得非正式的证明。</strong></p>
<p><strong>球体、方框或其他凸对象在每个像素处都有一个正面和一个背面，因此深度复杂度为2。概率测度可以推广到任意多边形，因为(双面)多边形的深度复杂度总是为1。因此，任何多边形的平均投影面积是其表面积的一半。</strong></p>
<p><strong>在光线追踪文献中，这个度量被称为曲面面积启发式(SAH)，它对于形成有效的数据集可见性结构非常重要。一个用途是比较边界体积效率。例如,一个球面被射线击中的相对概率为1.57 (π/2)。即四角与球体接触的立方体)。类似地，一个立方体被击中的相对概率是1.91 (6/π)，相对于它里面的球面。</strong></p>
<p><strong>这种类型的概率测量在细节水平计算等领域是有用的。例如，想象一个又长又细的物体所覆盖的像素比一个圆形物体少得多，但两者都有相同的边界球大小。从它的边界框的面积提前知道命中率，长而细的物体可能被认为是相对不那么重要的视觉冲击。</strong></p>
<p><strong>我们现在有一个点的包围概率与体积有关，一条射线的交点概率与表面积有关。平面与方框相交的概率与方框在三维空间中的范围和成正比。这个总和称为对象的平均宽度。例如，边长为1的立方体的平均宽度为1 + 1 + 1 = 3。盒子的平均宽度与它被飞机击中的几率成正比。一个1 × 1 × 1的方框的尺寸是3，一个1 × 2 × 3的方框的尺寸是6，这意味着第二个方框与任意平面相交的可能性是另一个的两倍。</strong></p>
<p><strong>然而，这个总和比真正的几何平均宽度要大，真正的几何平均宽度是物体在所有可能的方向上沿着固定轴的平均投影长度。对于平均宽度的计算，不同的凸对象类型之间没有简单的关系(如表面积)。一个直径为d的球体的几何平均宽度为d，因为球体在任何方向上都具有相同的长度。我们将离开这个主题，简单地说，乘一个盒子的尺寸的总和(即。它的几何平均宽度是0.5，可以直接与球体的直径进行比较。因此，测量为3的1 × 1 × 1盒子的几何平均宽度为3 × 0.5= 1.5。包围此盒体的球体的直径为√3= 1.732。因此一个球体的边界立方体是1.732/1.5=1.155，可能与任意平面相交。</strong></p>
<p><strong>这些关系有助于确定各种算法的优点。截锥剔除是一个主要的选择，因为它涉及到与边界体相交的平面。另一个用途是确定是否以及在哪里最好分割包含对象的BSP节点，以便截锥剔除性能变得更好(章节19.1.2)。</strong></p>
<h2 id="Rules-of-Thumb-经验法则"><a href="#Rules-of-Thumb-经验法则" class="headerlink" title="Rules of Thumb 经验法则"></a>Rules of Thumb 经验法则</h2><p><strong>在我们开始研究特定的交集方法之前，这里有一些经验法则，可以导致更快、更健壮、更精确的交集测试。在设计、发明和实现交叉例程时，应该牢记这些原则:</strong></p>
<pre><code>**•在早期执行计算和比较，可能琐碎地拒绝或接受各种类型的交叉，以获得一个早期逃避进一步的计算。**

**•如果可能，利用之前测试的结果。**

**•如果使用了多个拒绝或验收测试，那么试着改变它们的内部顺序(如果可能的话)，因为可能会产生更有效的测试。不要认为看似微小的变化不会产生影响。**

**•推迟昂贵的计算(尤其是三角函数、平方根和除法)，直到真正需要时(第22.8节，延迟昂贵的除法的例子)。**

**•通过降低问题的维度(例如，从三维到二维甚至一维)，交叉问题通常可以大大简化。参见22.9节中的示例。**

**•如果一条射线或一个物体在同一时间与许多其他物体进行比较，请在测试开始前寻找可以只做一次的预计算。**

**•当交叉测试很昂贵时，通常最好先在物体周围放置一个球体或其他简单的BV来快速拒绝。**

**•养成在电脑上进行计时比较的习惯，并使用真实数据和测试情况进行计时。**

**•利用前一帧的结果，例如，如果发现某个轴在前一帧分离两个对象，那么在下一帧尝试该轴可能是一个好主意。**

**•最后，试着让你的代码健壮。这意味着它应该适用于所有特殊情况，并且对尽可能多的浮点精度错误不敏感。要意识到它的局限性。更多关于数值和几何鲁棒性的信息，请参阅Ericson的书。**
</code></pre>
<p><strong>最后，我们强调这样一个事实:对于一个特定的测试，很难确定是否有一个“最佳”的算法。在评估时，通常使用一组不同的、预先确定的命中率的随机数据，但这只显示了部分事实。该算法将在真实场景中使用，例如在游戏中，最好在该情境下进行评估。使用的测试场景越多，对性能问题的理解就越好。一些体系结构，如GPUs和宽SIMD实现，可能会由于需要执行多个拒绝分支而导致性能下降。最好避免做假设，而是创建一个可靠的测试计划。</strong></p>
<h2 id="Ray-Sphere-Intersection-光线-球体交叉"><a href="#Ray-Sphere-Intersection-光线-球体交叉" class="headerlink" title="Ray/Sphere Intersection 光线/球体交叉"></a>Ray/Sphere Intersection 光线/球体交叉</h2><p><strong>让我们从一个数学上简单的交点检验开始，即射线和球体之间的交点检验。正如我们稍后将看到的，如果我们开始考虑所涉及的几何学，直接的数学解可以更快地得到。</strong></p>
<h3 id="Mathematical-Solution-数学方法"><a href="#Mathematical-Solution-数学方法" class="headerlink" title="Mathematical Solution 数学方法"></a>Mathematical Solution 数学方法</h3><p><strong>一个球体可以由一个中心点c和一个半径r来定义。更紧凑的隐式，计算球体的公式（与前面介绍的公式相比）</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113122359.png" class="" title="image-20211113122359">

<p><strong>p是球面上的任意点。为了求解射线与球体的交点，射线r(t)只需将上方程中的p替换产出</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113122450.png" class="" title="image-20211113122450">

<p><strong>利用22.1式，r(t) = o + td，将上式简化为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113122519.png" class="" title="image-20211113122519">

<p><strong>最后一步来自于假设d是标准化的事实，即 d·d = ||d||² = 1。毫不奇怪，得到的方程是一个二阶多项式，这意味着，如果射线与球面相交，它最多在两点处相交。参见下图。如果方程的解是虚的，那么光线就会错过球面。如果不是，两个解t1 和t2 可以插入到射线方程中来计算球面上的交点。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113122639.png" class="" title="image-20211113122639">

<p>左边的图像显示了一条错过球体的射线，因此b²−c &lt; 0。中间的图像显示了一条射线与球体相交于两点(b²−c &gt; 0)，这两点由标量t1 和t2决定．右图说明了b²−c = 0的情况，这意味着两个交点重合。</p>
<p><strong>得到的上方程可以写成二次方程:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113122803.png" class="" title="image-20211113122803">

<p><strong>其中b = d·(o−c)， c = (o−c)·(o−c)−r²。二阶方程的解如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113122838.png" class="" title="image-20211113122838">

<p><strong>注意，如果b²−c &lt; 0，则射线错过了球体，可以拒绝相交并避免计算√ (例如，平方根√和一些补充)。如果这个测试通过，两个t0 =−b−√(b²−c)和t1 =−b + √(b²−c)可计算。为了找到的最小正值，需要进行额外的比较t0 和t1．请参阅realtimerendering.com上的碰撞检测章节，以获得解决这个二次方程的另一种方法，它在数值上更稳定。</strong></p>
<p><strong>如果从几何角度来看待这些计算，就可以发现更好的拒绝测试。下一小节将描述这样一个例程。</strong></p>
<h3 id="Optimized-Solution-优化解决方案"><a href="#Optimized-Solution-优化解决方案" class="headerlink" title="Optimized Solution 优化解决方案"></a>Optimized Solution 优化解决方案</h3><p><strong>对于光线/球面相交问题，我们首先观察到光线原点后面的相交是不需要的。例如，这通常是在拣选的情况下。为了尽早检查这种情况，我们首先计算一个向量l = c−o，它是从射线原点到球体中心的向量。下图中描述了所有使用的符号。同时,这个向量的长度的平方计算,l² = l·l。现在如果l² &lt; r²,这意味着光线起源是在球体,这反过来,意味着雷保证了球体,我们只能退出如果我们要检测是否射线击中球;否则,我们继续。接下来，计算l在射线方向d上的投影:s = l·d。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113123336.png" class="" title="image-20211113123336">

<p>优化的射线/球体相交的几何符号。在左图中，射线与球体相交两点，距离为t = s±q。中间的情况表明，当球在射线原点后面时，会产生排斥。最后，在右边，射线原点在球内，在这种情况下射线总是击中球。</p>
<p><strong>现在，第一个排斥检验:如果s &lt; 0且射线原点在球面外面，那么球面在射线原点后面，我们可以排斥交集。否则，从球心到投影的距离的平方用勾股定理计算:m² = l²−s²。第二个拒绝测试甚至比第一个更简单:如果m² &gt; r²射线肯定会错过球体，其余的计算可以安全地省略。如果球体和射线通过了最后的测试，那么射线肯定会击中球体，我们可以退出，如果这是我们感兴趣的。</strong></p>
<p><strong>要找到真正的交点，还需要做一些工作。首先，计算距离q² = r²−m²的平方。参见上图。自从m² ≤ r²,q²大于等于0，这意味着q = √q²是可以计算出来的。最后，到交叉口的距离为t = s±q，其解与上一数学求解部分得到的二阶方程的解非常相似。</strong></p>
<p><strong>如果我们只对第一个正交点感兴趣，那么对于光线原点在球之外的情况，我们应该用t1 = s - q，当射线原点在内部时t2= s + q。将t值(s)插入到射线方程(方程22.1)中，得到真交点(s)。</strong></p>
<p><strong>下面的框中显示了优化版本的伪代码。例程返回一个布尔值，如果射线没有击中球体，则返回REJECT，否则相交。如果射线与球面相交，那么从射线原点到交点的距离t，以及交点p，也会返回。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113124043.png" class="" title="image-20211113124043">

<p><strong>注意，在第3行之后，我们可以测试p是否在球面内，如果我们只想知道射线和球面是否相交，则程序可以终止。同样，在第6行之后，射线保证会击中球体。如果我们做一个计数运算(计数加、乘、比较和相似)，我们发现几何解，在完成之后，近似等于前面给出的代数解。重要的区别在于拒绝测试在过程的早期就完成了，这使得该算法的总体成本平均较低。</strong></p>
<p><strong>优化的几何算法存在于计算射线与其他一些二次曲面和混合对象之间的交点。如圆柱体、圆锥体、椭球体、胶囊、菱形等。</strong></p>
<h2 id="Ray-Box-Intersection-光线-盒体交叉"><a href="#Ray-Box-Intersection-光线-盒体交叉" class="headerlink" title="Ray/Box Intersection 光线/盒体交叉"></a>Ray/Box Intersection 光线/盒体交叉</h2><p><strong>下面给出了三种确定射线是否与实心方框相交的方法。第一个处理AABBs和OBBs。第二种变体通常更快，但只处理更简单的AABB。第三个是基于947页的分离轴测试，只处理线段与AABBs。这里，我们使用第22.2节中BVs的定义和符号。</strong></p>
<h3 id="Slabs-Method-板方法"><a href="#Slabs-Method-板方法" class="headerlink" title="Slabs Method 板方法"></a>Slabs Method 板方法</h3><p><strong>射线/AABB相交的一种方案是基于Kay和Kajiya的slab方法，而该方法又受到Cyrus-Beck线裁剪算法的启发。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113133500.png" class="" title="image-20211113133500">

<p>左图显示的是由两个板组成的二维OBB，而右图显示的是测试与OBB相交的两条射线。所有的t值都显示出来了，绿色的u和橙色的v用下标表示。极端的t值用盒子标记。左射线在t^min &lt; t^max时击中OBB，右射线在 t^max &lt; t^min时错过。</p>
<p><strong>我们扩展了这个方案来处理更一般的OBB量。它返回最接近的正t值(即从射线原点o到交点的距离(如果有的话)。AABB的优化将在我们介绍一般情况后进行处理。这个问题是通过计算射线和OBB表面的所有平面的t值来解决的。盒子被认为是一组三个板，如上图左侧的二维图所示。对于每个板，有一个最小和最大的t值，这些被称为ti^min和 ti^max，∀i∈{u, v, w}。下一步是计算公式中的变量:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113133603.png" class="" title="image-20211113133603">

<p><strong>现在，有一个聪明的测试:如果t^min≤ t^max，则射线定义的直线与方框相交;否则错过。换句话说，我们找到了每个平板的近和远的交点距离。如果找到的最远的距离小于或等于最近的距离，那么射线定义的线就会击中方框。您应该通过查看上图右侧的插图来确信这一点。这两个距离定义了直线的交点，所以如果最近的“远”距离不是负的，射线本身就会击中方框，即盒子不在光线后面。</strong></p>
<p><strong>在OBB (A)和射线(由方程22.1描述)之间，射线/OBB相交测试的伪代码如下。代码返回一个布尔值，指示射线是否与OBB相交(INTERSECT或REJECT)，以及到交点的距离(如果存在)。回想一下，对于OBB A，中心是a^c, a^u, a^v和 a^w 为箱体规格化的侧面方向;h^u, h^v和 h^w 为正半长(从中心到盒面)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113133822.png" class="" title="image-20211113133822">

<p><strong>第7行检查射线方向是否不垂直于当前被测试板的法线方向。换句话说，它测试光线是否不平行于平板，从而与平板相交。注意，ε在这里是一个很小的数字，在10^( - 20)的顺序上，只是为了避免在除法发生时溢出。第8行和第9行表示除f;在实践中，计算1/f一次并乘以这个值通常更快，因为除法通常很昂贵。第10行确保t1 和t2的最小值储在t1中，因此，它们的最大值存储在t2中．在实践中，交换不一定是必须的;相反，分支可以重复第11行和第12行，而t1 和t2 可以在那里改变位置。如果第13行返回，则射线错过了方框，类似地，如果第14行返回，则方框在射线原点的后面。如果射线平行于平板(所以不能与平板相交)，则执行第15行;它测试光线是否在平板外面。如果是，则射线错过了盒子，测试终止。对于更快的代码，Haines讨论了一种展开循环的方法，从而避免了一些代码。</strong></p>
<p><strong>伪代码中没有显示一个额外的测试，值得在实际代码中添加。当我们定义射线时，我们通常想要找到最近的物体。因此，在第15行之后，我们还可以测试t^min是否≥l，其中l是当前射线的长度。这有效地将射线视为一条线段。如果新的十字路口不靠近，这个十字路口就会被拒绝。这个测试可以推迟到整个射线/OBB测试完成之后，但是在循环中尝试早期拒绝通常更有效。</strong></p>
<p><strong>对于OBB的特殊情况，也就是AABB，还有其他的优化。第5行和第6行改为e = pi,f = di，这使得测试速度更快。通常情况下,a^min 和a^max AABB的角在第8行和第9行使用，因此避免了加减运算。Kay和Kajiya和Smits注意到，第7行可以通过允许除0和正确解释处理器的结果来避免。Kensler给出了这个测试的最小版本的代码。Williams等人提供了正确处理除以0的实现细节，以及其他优化。Aila等人展示了如何在一些NVIDIA架构上的单个GPU操作中执行最大最小值测试，或者反之亦然。也可以使用SAT对射线和方框进行测试，但交点距离不是结果的一部分，这通常是有用的。</strong></p>
<p><strong>平板方法的推广可用来计算光线与k-DOP、截锥或任何凸多面体的交点;代码可在web上获得。</strong></p>
<h3 id="Ray-Slope-Method-射线斜率法"><a href="#Ray-Slope-Method-射线斜率法" class="headerlink" title="Ray Slope Method 射线斜率法"></a>Ray Slope Method 射线斜率法</h3><p><strong>2007年，Eisemann等人提出了一种比以前的方法更快的相交方框的方法。射线不是三维测试，而是通过盒子在二维空间的三个投影来测试。关键思想是，对于每个二维测试，都有两个方框角来定义光线“看到”的极端范围，类似于模型的轮廓边缘。要与方框的投影相交，射线的斜率必须在由射线原点和这两点定义的两个斜率之间。如果这个测试通过了所有三个投影，射线必须击中盒子。这个方法非常快，因为有些比较项完全依赖于射线的值。通过一次计算这些项，射线就可以有效地与大量的盒子进行比较。这种方法可以只返回是否击中了盒子，或者还可以返回交集距离，只需要一点额外的成本。</strong></p>
<h2 id="Ray-Triangle-Intersection-光线-三角形交叉"><a href="#Ray-Triangle-Intersection-光线-三角形交叉" class="headerlink" title="Ray/Triangle Intersection 光线/三角形交叉"></a>Ray/Triangle Intersection 光线/三角形交叉</h2><p><strong>在实时图形库和API中，三角形几何通常存储为一组具有相关着色法线的顶点，每个三角形由三个这样的顶点定义。三角形所在平面的法线通常不存储，在这种情况下，如果需要，必须计算它。射线/三角形相交测试有很多，其中很多都是先求射线与三角形平面的交点。然后，交点和三角形顶点投影到轴向平面(xy, yz，或xz)，在这里三角形的面积是最大的。通过这样做，我们将问题简化为二维，我们只需要确定(二维)点是否在(二维)三角形内。有几种这样的方法存在，Haines对它们进行了审查和比较，代码可以在网上找到。参见第22.9节，了解使用这种技术的一个流行算法。对于不同的CPU架构、编译器和命中率，已经评估了大量的算法，不能得出结论说在所有情况下都有一个最佳的测试。</strong></p>
<p><strong>在这里，重点将放在一个算法，不假定法线是预先计算的。对于三角形网格，这可以节省大量内存。对于动态几何，我们不需要每一帧都重新计算三角形的平面方程。不是在三角形的平面上测试一条射线，然后检查相交点是否包含在一个二维的三角形中，而是只对三角形的顶点进行检查。M¨oller和Trumbore讨论了该算法及其优化，本文将使用他们的演示。Kensler和Shirley指出，大多数直接在三维空间中运行的射线/三角形测试在计算上是等价的。他们开发了新的测试方法，使用SSE测试三角形上的四道射线，并使用遗传算法在这个等效测试中找到操作的最佳顺序。性能最好的测试代码在他们的论文中。请注意，有许多不同的方法可以实现此目的。例如，Baldwin和Weber提供了一种不同的空间速度权衡方法。这类测试的一个潜在问题是，一条恰好与三角形的边或顶点相交的射线可能被判定为错过三角形。这意味着光线可以通过接触两个三角形共享的边来穿过网格。Woop等人提出了在边和顶点上都是水密的射线/三角形相交测试。性能会稍微低一些，这取决于使用哪种类型的遍历。</strong></p>
<p><strong>方程22.1中的光线用于测试与由三个顶点p1, p2, p3所定义的三角形的交即△p1p2p3。</strong></p>
<h3 id="Intersection-Algorithm-交集算法"><a href="#Intersection-Algorithm-交集算法" class="headerlink" title="Intersection Algorithm 交集算法"></a>Intersection Algorithm 交集算法</h3><p><strong>三角形上的点f(u, v)由显式公式给出</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114123600.png" class="" title="image-20211114123600">

<p><strong>式中(u, v)为两个重心坐标，必须满足u≥0,v≥0和u + v≤1。注意，(u, v)可以用于纹理映射、法线或颜色插值等操作。也就是说，u和v是衡量每个顶点对特定位置贡献的权重，w =(1−u−v)是第三个权重。这些坐标在其他著作中常表示为α、β和γ。我们在这里使用u v和w是为了可读性和符号的一致性。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133043.png" class="" title="image-20211114133043">

<p>三角形的重心坐标，以及示例点的值。在三角形内u,v,w的值都在0到1之间变化，这三个的和在整个平面上总是1。这些值可以用作三个顶点上的数据如何影响三角形上任何点的权重。注意，在每个顶点上，一个值是1，其他值是0，沿着边，一个值总是0。</p>
<p><strong>计算射线r(t)和三角形f(u, v)的交点，就等于r(t) = f(u, v)，就得到</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133203.png" class="" title="image-20211114133203">

<p><strong>重新安排条件</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133242.png" class="" title="image-20211114133242">

<p><strong>这意味着质心坐标(u, v)和从射线原点到交点的距离t可以通过解这个线性方程组得到。</strong></p>
<p><strong>这种操作可以从几何上理解为将三角形平移到原点，并将其转换为y和z方向的单位三角形，射线方向与x对齐。如下图所示。如果M =(−d p1−p0 p2−p0)为22.13式中的矩阵，将22.13式与M^−1相乘求解。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133451.png" class="" title="image-20211114133451">

<p>射线原点的基底的平移和变化。</p>
<p><strong>表示e1 = p1 −p0,e2 = p2 −p0， s = o−p0式22.13的解采用Cramer法则:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133650.png" class="" title="image-20211114133650">

<p><strong>因此，上方程可以重写为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133739.png" class="" title="image-20211114133739">

<p><strong>q = d × e2和r = s × e1．这些因素可以用来加速计算。</strong></p>
<p><strong>如果您能够负担一些额外的存储空间，可以重新制定这个测试，以减少计算的数量。上式可以改写为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133923.png" class="" title="image-20211114133923">

<p><strong>其中n = e1 ×e2 是三角形的非标准化法线，因此是常量(对于静态几何)，m = s × d。如果我们保存p0,e1,e2，和每个三角形n，我们可以避免许多射线三角形相交的计算。大部分的收益来自于避免叉乘。需要注意的是，这违背了算法的原始思想，即用三角形存储最小的信息。然而，如果速度是最受关注的，这可能是一个合理的选择。需要权衡的是，额外的内存访问是否超过了节省的计算。只有仔细的测试才能最终显示什么是最快的。</strong></p>
<h3 id="Implementation-实现"><a href="#Implementation-实现" class="headerlink" title="Implementation 实现"></a>Implementation 实现</h3><p><strong>算法在下面的伪代码中进行了总结。除了返回射线是否与三角形相交，算法还返回前面描述的三重(u, v, t)。代码不剔除面向后的三角形，它返回t值为负的交点，但如果需要，这些交点也可以被剔除。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114134401.png" class="" title="image-20211114134401">

<p><strong>有几行可能需要一些解释。第4行计算a，它是矩阵M的行列式，接下来是一个避免行列式接近于零的测试。通过适当调整ε的值，该算法非常健壮。对于浮点精度和“正常”条件，ε = 10^−5 工作很好。在第9行中，将u的值与三角形(u = 0)的一条边进行比较。</strong></p>
<p><strong>该算法的C-code(包括剔除和非剔除版本)可在web上找到。C代码有两个分支:一个有效地剔除所有面向后的三角形，另一个对双面三角形执行交叉测试。所有的计算都被延迟到需要的时候。例如，v的值是直到发现u的值在允许范围内时才计算(这也可以在伪代码中看到)。</strong></p>
<p><strong>单侧交例程消去了行列式值为负的所有三角形。这个程序允许航线唯一的除法操作被延迟，直到一个交点被确认。</strong></p>
<h2 id="Ray-Polygon-Intersection-光线-多边形交叉"><a href="#Ray-Polygon-Intersection-光线-多边形交叉" class="headerlink" title="Ray/Polygon Intersection 光线/多边形交叉"></a>Ray/Polygon Intersection 光线/多边形交叉</h2><p><strong>尽管三角形是最常见的绘制原语，但是计算光线和多边形之间的交点的程序是有用的。一个有n个顶点的多边形由一个有序的顶点列表定义{v0, v1，…, vn−1}，其中顶点vi 与vi+1形成一条边当0≤I &lt; n−1时，多边形被来自vn−1 的边关闭到v0．多边形的平面πp : np ·x + dp = 0。</strong></p>
<p><strong>我们首先计算射线(方程22.1)与πp的交点，这很容易做到，用射线代替x。解决方案如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114134932.png" class="" title="image-20211114134932">

<p><strong>如果分母是|np ·d| &lt; ε，其中ε为极小值，则认为射线平行于多边形平面，不发生相交。在这种计算中，可以使用10^−20或更小的，因为目的是避免在除法时溢出。我们忽略光线在多边形平面上的情况。</strong></p>
<p><strong>否则，求出光线与多边形平面的交点p: p = o+td，其中t值为上式。然后，决定p是否在多边形内的问题从三维降为二维。这是通过将所有顶点和p投影到xy、xz或yz平面上来实现的，在这些平面上投影多边形的面积最大。也就是说，可以跳过max(|np,x|， |np,y|， |np,z|)对应的坐标分量，其余的保留为二维坐标。例如，给定一个法线(0.6，−0.692,0.4)，y分量的幅值最大，因此所有y坐标都被忽略。选择最大的幅值是为了避免投影到一个可能会产生退化、零面积三角形的平面上。请注意，为了提高效率，此组件信息可以预先计算一次并存储在多边形中。在这个投影过程中，多边形和交点的拓扑是守恒的(假设多边形确实是平的;有关此主题的更多信息，请参阅第16.2节)。投影程序如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114135127.png" class="" title="image-20211114135127">

<p>多边形顶点与交点p在xy平面上的正交投影，在xy平面上投影的多边形面积最大。这是一个使用降维来获得更简单计算的例子。</p>
<p><strong>剩下的问题是二维射线/平面交点p是否包含在二维多边形中。在这里，我们将回顾一个比较有用的算法——“交叉”测试。Haines和Schneider and Eberly提供了二维点对多边形策略的广泛研究。一种更正式的处理方法可以在计算几何文献中找到。Lagae和Dutr´e提供了一种基于M¨oller和Trumbore射线/三角形测试的射线/四边形相交的快速方法。Walker提供了一种快速测试10个以上顶点的多边形的方法。Nishita等人讨论了曲线边形状的点包含测试。</strong></p>
<h3 id="The-Crossings-Test-交叉测试"><a href="#The-Crossings-Test-交叉测试" class="headerlink" title="The Crossings Test 交叉测试"></a>The Crossings Test 交叉测试</h3><p><strong>交叉检验基于约当曲线定理，这是拓扑的结果。如果一条光线从该点沿平面任意方向穿过奇数条多边形边，则该点在多边形内。约当曲线定理实际上局限于非自交的循环。对于自相交的循环，这个射线测试使一些明显在多边形内部的区域被认为是在外部。如下图所示。这种检验也称为奇偶检验或偶奇检验。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114135533.png" class="" title="image-20211114135533">

<p>一个自相交的凹多边形，但它所有的封闭区域都不考虑在内(只有棕色区域在里面)。顶点用大的黑点标记。三个被测试的点和它们的测试射线被显示出来。根据约当曲线定理，如果与多边形的边相交的次数为奇数，则点在内。因此，最上面和最下面的点都在里面(分别是1和3个交叉点)。每个中间的两个点穿过两条边，因此被认为是在多边形的外面。</p>
<p><strong>交叉算法的工作原理是，从p点在x正方向(或任何方向;x方向的编码效率很高)。然后计算多边形边与这条射线之间的交叉数。正如约当曲线定理所证明的那样，奇数个交叉点表示该点在多边形内。</strong></p>
<p><strong>测试点p也可以被认为是在原点，而(平移)边则是针对正x轴进行测试。这个选项如下图所示。如果多边形边的y坐标具有相同的符号，则该边不能穿过x轴。否则，它可以，然后检查x坐标。如果两者都是正的，那么交叉的数量就会增加，因为测试射线必须到达这条边。如果它们的符号不同，则必须计算边与x轴交点的x坐标，如果x坐标为正，则交叉点的数量增加。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114135704.png" class="" title="image-20211114135704">

<p>多边形已经被−p (p是测试多边形中是否包含的点)翻译，因此与正x轴相交的次数决定了p是否在多边形内。边e0,e2,e3和e4 不要穿过x轴。边e的交点1 必须计算x轴，但不会产生交点，因为交点的x分量是负的。边e7 和e8 将增加交叉的数量，因为每条边的两个顶点有正的x分量和一个负的和一个正的y分量。最后，边e5 和e6 共享一个y = 0和x &gt;的顶点，它们将一起增加交叉点的数量1。通过考虑x轴上的顶点在射线e5 被归类为穿过射线，e6被归类为高于射线。</p>
<p><strong>在上图中，所有封闭区域都可以被分类为内部区域。这个变体测试找出圈数，即多边形循环绕测试点的次数。治疗方法见海恩斯的文章。</strong></p>
<p><strong>当测试射线与顶点相交时，可能会出现问题，因为可能会检测到两个相交点。这些问题可以通过考虑射线上方无穷小的顶点来解决，在实践中，可以通过将y≥0的顶点解释为也位于x轴(射线)上方来解决。代码变得更加简单和快速，因为没有顶点被相交。</strong></p>
<p><strong>下面是交叉测试的有效形式的伪代码。它的灵感来自Joseph Samosky和Mark hahigh - hutchinson的工作，代码可以在网上找到。一个二维测试点t和顶点为v0的多边形P 通过vn−1 进行了比较。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114135926.png" class="" title="image-20211114135926">

<p><strong>第3行检查多边形中最后一个顶点的y值是否大于或等于测试点t的y值，并将结果存储在布尔值y0．换句话说，它测试我们要测试的第一条边的第一个端点是在x轴之上还是之下。第7行测试端点是否为e0 和e1 在测试点形成的x轴的不同侧面。如果是，那么第8行测试x-截距是否为正。实际上，它要比这个快一些:为了避免计算截距通常需要的除法，我们在这里执行一个消号操作。通过内部倒置，第9行记录发生了交叉。第10行到第12行继续到下一个顶点。</strong></p>
<p><strong>在伪代码中，我们没有在第7行之后执行测试，以查看与测试点相比，两个端点的x坐标是更大还是更小。尽管我们提出的算法使用快速接受或拒绝这些类型的边，基于伪代码提出的代码通常运行更快，没有这个测试。一个主要的因素是被测试多边形的顶点数——如果顶点数更多，首先检查x坐标的差异会更有效。</strong></p>
<p><strong>交叉测试的优点是相对快速和健壮，不需要对多边形进行额外的信息或预处理。这种方法的一个缺点是，除了表示是否，它不会产生任何结果一个点在多边形的内部或外部。其他方法，如第22.8.1节中的射线/三角形测试，也可以计算重心坐标，用于插值关于测试点的附加信息。注意，重心坐标可以扩展到处理三个以上顶点的凸多边形和凹多边形。Jim´enez等人提供了一种基于重心坐标的优化算法，旨在包括多边形边缘的所有点，并与交叉测试竞争。</strong></p>
<p><strong>更普遍的问题是，确定一个点是否在由线段和B´ezier曲线组成的封闭轮廓内!B´ezier可以以类似的方式执行，计算射线交叉。Lengyel给出了一种鲁棒的算法来处理这一过程，将其用于像素着色器中来渲染文本。</strong></p>
<h2 id="Plane-Box-Intersection-平面-盒体交叉"><a href="#Plane-Box-Intersection-平面-盒体交叉" class="headerlink" title="Plane/Box Intersection 平面/盒体交叉"></a>Plane/Box Intersection 平面/盒体交叉</h2><p><strong>我们可以通过将点插入到平面方程(π: n·x + d = 0)中来知道点到平面的距离。结果的绝对值就是到平面的距离。平面/球面测试很简单:将球面的中心插入到平面方程中，看看其绝对值是否小于或等于球面的半径。</strong></p>
<p><strong>确定方框是否与平面相交的一个方法是将方框的所有顶点插入到平面方程中。如果同时得到一个正的和一个负的结果(或0)，那么顶点位于平面的两边(或上)，因此，一个交点已经被检测到。有一些更聪明、更快的方法来做这个测试，在接下来的两节中介绍，一节用于AABB，一节用于OBB。</strong></p>
<p><strong>这两种方法背后的想法是，八个角中只有两个需要插入到平面方程中。对于任意方向的方框，无论是否与平面相交，方框上对角相对的两个角是最大的距离，当沿着平面的法线测量时。每个盒子有四条对角线，由它的角组成。取每个对角线方向与平面法线的点积，最大的值表示这两个最远点的对角线。通过测试这两个角，整个盒子将在一个平面上进行测试。</strong></p>
<h3 id="AABB"><a href="#AABB" class="headerlink" title="AABB"></a>AABB</h3><p><strong>假设我们有一个AABB, B,定义为一个中心点,c,和正的一半对角向量,h。注意,可以很容易地将c和h来源于最小和最大的角落,B中的b^min和 b^max,也就是说,c = (b^max + b^min) / 2和h = (b^max− b^min) / 2。</strong></p>
<p><strong>现在，我们要在n·x + d = 0的平面上测试B。有一种非常快的方法来执行这个测试。理论上，可以通过将盒子的所有8条不同的对角线投影到法线上，并选择最长的一条来实现。然而，在实践中，这可以迅速实现</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114140749.png" class="" title="image-20211114140749">

<p><strong>为什么这等价于找到八个不同的半对角线投影的最大值?这8条半对角线是组合 g^i = (±hx, ±hy, ±hz)，我们要计算所有8个i的 g^i·n。当 g^i·n中的每一项都是正数时，它将达到最大值。对于x项，这发生在nx 和hx^i的符号相同，但既然我们知道hx 是正的，我们可以计算出最大项为hx| nx｜．对y和z也这样做得到方程22.18。</strong></p>
<p><strong>接下来，我们计算从中心点c到平面的带符号的距离s。这是通过:s = c·n + d完成的。s和e都在下图中说明。假设平面的“外部”是正的半空间，我们可以简单地测试是否s - e &gt; 0，这表明盒子完全在平面外部。类似地，s+e &lt; 0表示盒子完全在里面。否则，方框与平面相交。这一技术是基于Ville Miettinen的想法和巧妙的实现。伪代码如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114141125.png" class="" title="image-20211114141125">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114141212.png" class="" title="image-20211114141212">

<p>圆心为c，对角线为正的半对角线为h的轴对齐方框与平面π进行测试。这个想法是计算从方框中心到平面的带符号距离s，并将其与方框的“范围”e进行比较。向量g^i 是这个二维方框的不同对角线吗，其中h等于g¹ 在这个例子中。还要注意，带符号的距离s是负的，它的大小大于e，表明方框在平面内(s + e &lt; 0)。</p>
<h3 id="OBB"><a href="#OBB" class="headerlink" title="OBB"></a>OBB</h3><p><strong>对平面进行OBB测试与上一节的AABB/平面测试仅略有不同。它只是计算的“范围”的盒子需要改变，这是做</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114141511.png" class="" title="image-20211114141511">

<p><strong>回想一下(b^u, b^v, b^w)是OBB的坐标系轴(见章节22.2中OBB的定义)，( hu^B,hv ^B, hw^B)是方框沿这些轴的长度。</strong></p>
<h2 id="Triangle-Triangle-Intersection-三角形-三角形交叉"><a href="#Triangle-Triangle-Intersection-三角形-三角形交叉" class="headerlink" title="Triangle/Triangle Intersection 三角形/三角形交叉"></a>Triangle/Triangle Intersection 三角形/三角形交叉</h2><p><strong>由于图形硬件使用三角形作为其最重要的(和优化的)绘图原语，因此对这类数据执行碰撞检测测试也是很自然的。所以，最深层的碰撞检测算法通常有一个程序来决定两个三角形是否相交。给定两个三角形，T1 =△p1p2p3 和T2  =△q1q2q3 位于平面上π1 和π2，我们要确定它们是否相交。</strong></p>
<p><strong>从一个较高的层次，通常从检查T1 与π2相交，是否T2 与π1相交 。如果这些测试中的任何一个失败，就不可能有交集。假设三角形不是共面的，我们知道平面的交点是π1 和π2，将是一条直线L。如下图所示。从图中可以看出，如果三角形相交，它们在L上的交点也会有重叠。否则，就不会有交集。有许多不同的方法来实现这个方法，下面我们将介绍Guigue和Devillers的方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114141830.png" class="" title="image-20211114141830">

<p>三角形和它们所在的平面。在这两幅图中，交点间隔用红色标出。左:沿L线重叠的间隔，以及三角形。右:没有交集;这两个区间不重叠。</p>
<p><strong>在这个实现中，大量使用了来自四个三维向量a、b、c和d的4 × 4行列式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114141933.png" class="" title="image-20211114141933">

<p><strong>在几何上，22.20式有直观的解释。这个叉乘，(b−a) × (c−a)，可以看作是计算一个三角形的法线，∆abc。通过取这个法线和向量a到d之间的点积，我们得到一个正值，如果d在三角形平面的正半空间，∆abc。另一种解释是，行列式的符号告诉我们b - a方向上的螺旋是否与d - c方向相同。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114142030.png" class="" title="image-20211114142030">

<p>螺旋向量b−a在d−c方向上的图解。</p>
<p><strong>我们首先检验T1 相交与π2，反之亦然。这可以用公式22.20中的特殊行列式来完成，方法是计算[q1,q2,q3,p1]、[q1,q2,q3,p2], [q1,q2,q3,p3］．第一个检验等价于计算T2的法线，然后测试哪个半空间与点p1 是在。如果这些行列式的符号相同且非零，那么就没有交集，测试结束。如果全部为零，则三角形共面，并执行一个单独的测试来处理这种情况。否则，继续测试是否T2 与π1相交，使用相同类型的测试。</strong></p>
<p><strong>在这一点，两个间隔，I1 = [i, j] 和 I2 = [k, l]，在l上被计算，其中I1 由T1 和I2 从T2．为了做到这一点，每个三角形的顶点都被重新排序，所以第一个顶点单独位于另一个三角形平面的一边。如果I1 与I2，则这两个三角形相交，这只发生在k≤j和i≤l。要实现k≤j，我们可以使用行列式的符号检验(方程22.20)，注意j是从p1p2推导出来的， k来自q1q2．利用行列式计算的“螺旋检验”的解释，我们可以得出，当[p1, p2, q1, q2]≤0时，k≤j。最后的测试变成了</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114142528.png" class="" title="image-20211114142528">

<p><strong>整个测试从六个决定性测试开始，前三个测试共享第一个参数，因此可以共享许多计算。原则上，行列式可以使用许多较小的2 × 2子行列式计算，当这些发生在多个4 × 4行列式中，计算可以共享。网络上有这个测试的代码，也可以通过扩充代码来计算实际的交点线段。</strong></p>
<p><strong>如果三角形共面，则将它们投影到轴向平面上，在这个平面上三角形的面积最大(第22.9节)。然后，进行了一个简单的二维三角形-三角形重叠测试。首先，测试所有的闭合边(即包括端点)T1 与T2的闭边相交．如果找到任何相交点，三角形就相交。否则，我们必须检验T1 完全包含在T2 反之亦然。这可以通过对T的一个顶点执行三角形内点测试(第22.8节)来完成T1 对T2，反之亦然。</strong></p>
<p><strong>注意，分离轴试验(见第947页)可用于推导三角形/三角形重叠试验。相反，我们提出了Guigue和Devillers的测试，它比使用SAT更快。还有其他算法可以执行三角形/三角形相交。架构和编译器的差异，以及预期命中率的差异，意味着我们不能推荐总是性能最好的单一算法。注意，精度问题可能会出现在任何几何测试中。Robbins和Whitesides使用了Shewchuk的精确算法来避免这种情况。</strong></p>
<h2 id="Triangle-Box-Intersection-三角形-盒体交叉"><a href="#Triangle-Box-Intersection-三角形-盒体交叉" class="headerlink" title="Triangle/Box Intersection 三角形/盒体交叉"></a>Triangle/Box Intersection 三角形/盒体交叉</h2><p><strong>本节介绍一个算法，用于确定一个三角形是否与一个轴对齐的框相交。这样的测试对于体素化和碰撞检测是有用的。</strong></p>
<p><strong>Green和Hatch提出了一种可以确定任意多边形是否与方框重叠的算法。Akenine-M¨oller开发了一种基于分离轴测试的更快的方法(第947页)，我们在这里介绍。三角形/球体测试也可以使用该测试进行，详见Ericson的文章。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114143200.png" class="" title="image-20211114143200">

<p>用于三角形/盒子重叠测试的符号。在左边，显示盒子和三角形的初始位置，而在右边，盒子和三角形已经被平移，使盒子的中心与原点重合。</p>
<p><strong>我们重点测试一个轴对齐的包围盒(AABB)，它由一个中心c和一个半长向量h定义，对应一个三角形∆u0u1u2．为了简化测试，我们首先移动方框和三角形，使方框围绕原点居中，即 vi = ui −c, i∈{0,1,2}。这种转换和使用的符号如上图所示。为了测试一个有方向的盒子，我们将首先通过反盒子变换旋转三角形顶点，然后使用这里的测试。基于分离轴测试(SAT)，我们测试了以下13个轴:</strong></p>
<pre><code>**1.[3 tests]e0 = (1,0,0)， e1 = (0,1,0)， e2 = (0,0,1) (AABB的法线)。换句话说，测试AABB与最小的AABB围绕三角形。**

**2.[1 test]n，∆u0u1u2的法线．我们使用快速平面/AABB重叠测试(第22.10.1节)，它只测试盒子对角线上与三角形法线最接近的两个顶点。**

**3.[9 tests]aij = ei ×fj ，i，j∈&#123;0,1,2&#125;，其中f0 = v1 −v0，f1 = v2 −v1和f2 = v0 −v2,即边向量。这些测试在形式上是相似的，我们只展示i = 0和j = 0情况下的推导(见下文)。**
</code></pre>
<p><strong>一旦找到分离轴，算法就终止并返回“无重叠”。“如果所有测试都通过了，也就是说没有分离轴，则三角形与方框重叠。</strong></p>
<p><strong>这里我们推出了9个测试中的一个，其中i = 0, j = 0，在步骤3中。这意味着a00 = e0 ×f0 =(0,−f0z,f0y）。现在我们需要把三角形顶点投影到a00 (以下称为一个):</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114143758.png" class="" title="image-20211114143758">

<p><strong>通常，我们需要找到min(p0,p1,p2)和max(p0,p1,p2)，但幸运的是p0 = p1，简化了计算。现在只需要求min(p0,p2)和max(p0,p2)，这要快得多，因为条件语句在现代CPUs上开销很大。</strong></p>
<p><strong>在三角形投影到a上之后，我们还需要将盒子投影到a上。我们计算投影在a上的方框的“半径”r</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114144011.png" class="" title="image-20211114144011">

<p><strong>最后一步对于这个轴ax = 0。然后，这个轴测试就变成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114144023.png" class="" title="image-20211114144023">

<p><strong>在网站获得。</strong></p>
<h2 id="Bounding-Volume-Bounding-Volume-Intersection-包围盒-包围盒交叉"><a href="#Bounding-Volume-Bounding-Volume-Intersection-包围盒-包围盒交叉" class="headerlink" title="Bounding-Volume/Bounding-Volume Intersection 包围盒/包围盒交叉"></a>Bounding-Volume/Bounding-Volume Intersection 包围盒/包围盒交叉</h2><p><strong>边界体积的目的是提供更简单的交叉测试和更有效的拒绝。例如，要测试两辆车是否相撞，首先找到它们的BVs并测试它们是否重叠。如果它们没有这样做，那么汽车就可以保证不发生碰撞(我们假设这是最常见的情况)。这样，我们就避免了测试一辆车的每个原语与另一辆车的每个原语，从而节省了计算。</strong></p>
<p><strong>一个基本的操作是测试两个边界体是否重叠。下面将介绍AABB、k-DOP和OBB的重叠测试方法。关于围绕原语形成BVs的算法，请参见第22.3节。</strong></p>
<p><strong>使用比球面和AABB更复杂的bv的原因是，更复杂的BVs通常具有更紧密的配合。如下图所示。当然，其他的边界卷也是可能的。例如，圆柱体和椭球体有时被用作物体的边界体。此外，可以放置几个球体来包围单个物体。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114144233.png" class="" title="image-20211114144233">

<p>一个球体(左)，一个AABB(中左)，一个OBB(中右)，和一个k-DOP(右)显示了一个对象，其中OBB和k-DOP明显比其他的空空间少。</p>
<p><strong>对于胶囊和菱形BVs来说，计算最小距离是一种相对快速的操作。因此，它们经常用于公差验证应用程序，其中需要验证两个(或多个)对象之间至少有一定的距离。Eberly和Larsen等人推导了这些类型的边界体的公式和有效算法。</strong></p>
<h3 id="Sphere-Sphere-Intersection-球-球的交叉"><a href="#Sphere-Sphere-Intersection-球-球的交叉" class="headerlink" title="Sphere/Sphere Intersection 球/球的交叉"></a>Sphere/Sphere Intersection 球/球的交叉</h3><p><strong>对于球体，相交测试是简单和快速的:计算两个球体的中心之间的距离，然后拒绝如果这个距离大于两个球体的半径和。否则,他们相交。在实现这个算法时，最好使用这两个量的距离的平方，因为所需要的只是比较的结果。这样，计算平方根(一个昂贵的避免操作)。Ericson给出了同时测试四对独立球体的SSE代码。</strong></p>
<h3 id="Sphere-Box-Intersection-球体-盒的交叉"><a href="#Sphere-Box-Intersection-球体-盒的交叉" class="headerlink" title="Sphere/Box Intersection 球体/盒的交叉"></a>Sphere/Box Intersection 球体/盒的交叉</h3><p><strong>Arvo首先提出了一种测试球体与AABB是否相交的算法，该算法非常简单。这个想法是找到在AABB上最接近球的中心的点，c。使用一维测试，对AABB的三个轴各一个。在AABB的边界上测试一个轴的球面中心坐标。如果它在边界之外，则计算球体中心和方框之间沿这个轴(一个减法)的距离并平方。在我们沿着三个轴做了这个之后，这些距离的平方之和与半径的平方r²相比较球面的。如果总和小于半径的平方，则最近的点在球体内部，并且盒子重叠。如Arvo所示，该算法可以修改为处理空心框和球体，以及轴向椭球。</strong></p>
<p><strong>Larsson等人提出了该算法的一些变体，包括一个相当快的SSE向量化版本。他们的观点是在早期使用简单的拒绝测试，或者每个轴，或者在一开始就全部使用。拒绝测试是看中心到盒子沿轴的距离是否大于半径。如果是这样，测试可以提前结束，因为球体不可能与盒子重叠。当重叠概率较低时，这种早期拒绝方法明显更快。接下来是他们测试的QRI(快速拒绝交织)版本。早期的输出测试位于第4行和第7行，如果需要可以删除它们。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114144744.png" class="" title="image-20211114144744">

<p><strong>对于快速的矢量化(使用SSE)实现，Larsson等人提出消除大部分分支。思路是使用下面的表达式同时计算第3行和第6行:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114144814.png" class="" title="image-20211114144814">

<p><strong>通常，我们将d更新为d = d+e²。然而，使用SSE，我们可以并行地计算方程22.25中的x、y和z。下面给出了完整测试的伪代码。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114144936.png" class="" title="image-20211114144936">

<p><strong>注意，第1行和第2行可以使用并行的SSE max函数来实现。即使在这个测试中没有提前推出，它仍然比其他技术更快。这是因为已经消除了分支，并且使用了并行计算。SSE的另一种方法是向量化对象对。Ericson给出了SIMD代码来同时比较四个球体和四个AABBs。</strong></p>
<p><strong>对于球/OBB相交，首先将球的中心转换到OBB的空间。也就是说，使用OBB的归一化轴作为转换球体中心的基础。现在这个中心点是相对于OBB的轴线表示的，所以OBB可以被视为AABB。然后使用球面/AABB算法进行交点测试。</strong></p>
<p><strong>Larsson给出了一种椭球体/OBB交会测试的有效方法。首先，两个物体都被缩放，使椭球变成一个球体，OBB成为一个平行六面体。可进行球/板交叉试验，快速验收和拒收。最后，测试球体是否与那些面对它的平行四边形相交。</strong></p>
<h3 id="AABB-AABB-Intersection-AABB-AABB交叉"><a href="#AABB-AABB-Intersection-AABB-AABB交叉" class="headerlink" title="AABB/AABB Intersection AABB / AABB交叉"></a>AABB/AABB Intersection AABB / AABB交叉</h3><p><strong>顾名思义，AABB是一个面与主轴方向对齐的盒子。因此，用两点就足以描述这样一个体积。这里我们使用第22.2节中给出的AABB的定义。</strong></p>
<p><strong>由于其简单性，AABBs通常被用于碰撞检测算法和场景图中节点的包围体。两个AABBs，A和B相交的检验是平凡的，总结如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114145212.png" class="" title="image-20211114145212">

<p><strong>第1行和第2行在x、y和z三个标准轴方向上循环。Ericson提供了SSE代码，用于同时测试四对独立的AABBs。</strong></p>
<h3 id="k-DOP-k-DOP-Intersection-k-DOP-k-DOP交叉"><a href="#k-DOP-k-DOP-Intersection-k-DOP-k-DOP交叉" class="headerlink" title="k-DOP/k-DOP Intersection  k-DOP / k-DOP交叉"></a>k-DOP/k-DOP Intersection  k-DOP / k-DOP交叉</h3><p><strong>一个k-DOP与另一个k-DOP的交集检验只包含k/2区间重叠检验。Klosowski等人的研究表明，对于中等k值，两个k-DOPs的重叠测试比两个OBBs的测试快一个数量级。在第946页的图22.4中，描述了一个简单的二维k-DOP。注意，AABB是一个6-DOP的特殊情况，其中法线是正和负主轴方向。OBBs也是6-DOP的一种形式，但这种快速测试只能在两个OBBs共享同一轴时使用。</strong></p>
<p><strong>下面的交叉测试简单而快速，不精确但保守。如果要测试两个k-DOPs, A和B(上标索引为A和B)是否相交，则测试所有平行平板对(Si^A, Si^B)用于重叠;si =Si^A∩ Si^B是一维区间重叠检验，求解起来比较容易。这是第22.5节中的经验法则所推荐的降维示例。本文将三维平板试验简化为一维区间重叠试验。</strong></p>
<p><strong>如果在任何时候i =∅(即空集)BVs不相交，测试终止。否则，平板重叠测试将继续进行。当且仅当所有si ≠∅,1≤i≤k/2，则认为BVs重叠。根据分离轴测试(第22.2节)，还需要测试一个平行于每个k-DOP的一条边的叉积的轴。然而，这些测试经常被忽略，因为它们的成本高于它们在性能上的回报。因此，如果下面的测试返回k- DOPs重叠，那么它们实际上可能是不相交的。下面是k-DOP/k-DOP重叠测试的伪代码:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114145951.png" class="" title="image-20211114145951">

<p><strong>注意，在k- DOP的每个实例中只需要存储k个标量值(法线ni，对于所有k- DOPs只存储一次，因为它们是静态的)。如果k- DOPs被t^A 和t^B ，则测试会稍微复杂一点。项目t^A 在法线上，ni,例如,pi^A= t^A·ni (注意，这与任何k-DOP无关，因此对于每个t^A 或t^B只需要计算一次 )，在if语句中加上pi^A到 di^(A, min)和 di^(A,max)。同样的方法也适用于 t^B。换句话说，平移改变了k-DOP沿每个法线方向的距离。</strong></p>
<p><strong>Laine 和 Karras提出了k- DOPs的一种扩展，称为顶点映射。这个想法是将一组平面法线映射到k-DOP上的各个点，这样存储的每个点都代表沿着该方向最远的位置。这个点和方向形成了一个平面，在一个半空间内完全包含模型，即点在模型的k-DOP的顶点。在测试过程中，给定方向的顶点可以用于更精确的k- DOPs之间的交叉测试，用于改进截锥剔除，以及在旋转后寻找更紧密的AABBs等。</strong></p>
<h3 id="OBB-OBB-Intersection-OBB-OBB的交叉"><a href="#OBB-OBB-Intersection-OBB-OBB的交叉" class="headerlink" title="OBB/OBB Intersection OBB / OBB的交叉"></a>OBB/OBB Intersection OBB / OBB的交叉</h3><p><strong>在本节中，我们简要概述了一种快速测试两个OBBs, A和B之间交集的方法。该算法使用分离轴测试，比以前使用最接近特征或线性规划的方法快一个数量级。OBB的定义见第22.2节。</strong></p>
<p><strong>测试是在A的中心和轴线组成的坐标系中进行的。这意味着原点是a^c =(0,0,0)这个坐标系的主轴是a^u = (1,0,0)， a^v = (0,1,0)， a^w =(0,0,1)。假设B相对于A，平移t，旋转(矩阵)R。</strong></p>
<p><strong>根据分离轴测试，只要找到一个将A和B分开的轴，就可以保证它们不相交(不重叠)。需要测试15个轴:3个来自A的面，3个来自B的面，3·3 = 9来自A和B的边的组合。这在下图的二维图中显示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114150749.png" class="" title="image-20211114150749">

<p>为了确定两个OBBs是否重叠，可以使用分离轴测试。这里，它是二维的。四个分离轴与两个OBBs的面正交，每个盒子有两个轴。OBBs被投影到坐标轴上。如果两个投影在所有轴上重叠，则OBBs重叠;否则，它们就不会。因此，只要找到一个将投影分开的轴，就可以知道OBBs没有重叠。在本例中，左下角的轴是分隔投影的唯一轴。(参见Ericson。)</p>
<p><strong>作为矩阵a = (a^u a^v a^w)的标准正交性的结果，应该与A的面正交的潜在分离轴仅仅是轴 a^u a^v a^w。B也是如此。剩下的9个势轴，分别由A和B的一条边组成，则 c^ij = a^i ×b^j，∀i∈{u, v, w}和∀j∈{u, v, w}。幸运的是，在线上有对此进行优化的代码。</strong></p>
<h2 id="View-Frustum-Intersection-视锥交叉"><a href="#View-Frustum-Intersection-视锥交叉" class="headerlink" title="View Frustum Intersection 视锥交叉"></a>View Frustum Intersection 视锥交叉</h2><p><strong>正如在第19.4节中所看到的，分层视图截锥剔除对于快速渲染复杂场景至关重要。在边界体积层次剔除遍历过程中调用的少数操作之一是视图截锥和边界体积之间的交集测试。因此，这些操作对于快速执行至关重要。理想情况下，他们应该确定BV是完全在内部(包含)，还是完全在外部(排除)，或者它与截锥相交。</strong></p>
<p><strong>回顾一下，视图截锥是一个被近平面和远平面截断的金字塔(它们是平行的)，使体积有限。事实上，它变成了一个多面体。如下图所示，六个平面的名称，近、远、左、右、上、下也被标记了出来。视图截锥体定义了场景中应该可见的部分，从而进行渲染(以金字塔截锥的视角)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115133303.png" class="" title="image-20211115133303">

<p>左边的插图是一个无限的金字塔，然后被平行的近平面和远平面裁剪来构建一个视图截锥。其他平面的名称也显示出来，摄像机的位置是在金字塔的顶端。</p>
<p><strong>用于层次结构(例如场景图)内部节点和外围几何的最常见的包围体是球体、AABBs和OBBs。因此，锥/球和锥/AABB/OBB测试将在这里讨论和推导。</strong></p>
<p><strong>为了了解为什么我们需要三个返回结果outside/inside/intersect，我们将检查遍历边界体积层次结构时发生了什么。如果一个BV被发现完全在视图截锥之外，那么该BV的子树将不会被进一步遍历，它的任何几何体都不会被渲染。另一方面，如果BV完全在内部，那么就不需要为该子树计算更多的截锥/BV测试，每个可渲染的叶子将被绘制。对于部分可见的BV，即，它与截锥相交，BV的子树被递归地针对截锥进行测试。如果BV是一个叶子，那么这个叶子必须被渲染。</strong></p>
<p><strong>完整检验称为差集/并集/交集检验。有时，第三种状态，交集，可能被认为是太昂贵的计算。在这种情况下，BV被归类为“可能在内部”。“我们称这种简化的算法为差集/并集测试。如果不能成功排除BV，则有两个选择。一种是将“可能在内部”的状态视为包含，这意味着BV内部的所有内容都被渲染。这通常是低效的，因为不执行进一步的筛选。另一种选择是依次测试子树中的每个节点是否排除。这样的测试通常是没有好处的，因为许多子树可能确实在截锥中。因为这两个选择都不是特别好，所以一些快速区分交集和包含的尝试通常是值得的，即使测试并不完美。</strong></p>
<p><strong>重要的是要认识到，快速分类测试不必是精确的场景图剔除，只是保守。为了区分排除和纳入，所需要的只是测试在纳入方面出错。也就是说，实际上应该排除的对象可能会被错误地包括进来。这样的错误只会花费额外的时间。另一方面，应该包含的对象永远不应该被测试快速分类为被排除的对象，否则将发生呈现错误。对于包含和交集，任何一种错误分类通常都是合法的。如果将一个完全包含的BV归为相交，则测试其子树是否存在交集会浪费时间。如果一个相交的BV完全被考虑在内，渲染所有对象会浪费时间，其中一些对象可能已经被剔除。</strong></p>
<p><strong>在介绍截锥与球体(AABB或OBB)之间的试验之前，我们将描述截锥与一般物体之间的交叉试验方法。这个测试如下图所示。其想法是将测试从BV/截锥测试转换为点/体积测试。首先，选择一个相对于BV的点。然后BV沿着截锥的外侧移动，尽可能接近它而不重叠。在这个移动过程中，相对于BV的点被跟踪，它的轨迹形成一个新的体积(下图中有厚边的多边形)。事实上，BV被移动到尽可能接近截锥的位置，这意味着如果相对于BV的点(在其原始位置)位于描出的体积内，那么BV与截锥相交或在截锥内。所以，不是测试BV与截锥的交点，相对于BV的点是测试另一个新的体积，由点描出。以同样的方式，BV可以沿着截锥的内部移动，并尽可能接近截锥。这将绘制出一个新的、更小的截锥，其平面与原始截锥平行。如果相对于物体的点在这个新体积内，那么BV就完全在截锥内。在后面的部分中，将使用此技术导出测试。注意，新体积的创建与实际BV的位置无关——它只依赖于相对于BV的点的位置和BV的形状。这意味着具有任意位置的BV可以用相同的体积进行测试。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115133651.png" class="" title="image-20211115133651">

<p>左上方的图像显示了一个截锥(蓝色)和一个一般的包围体(绿色)，其中一个相对于对象的点p已经被选中。通过追踪物体在截锥的外部(右上)和内部(左下)移动的点p，尽可能接近截锥，截锥/BV可以被重新定义为针对外部和内部体积测试点p。这在右下角显示。如果点p在橙色体积的外面，则BV在截锥的外面。如果p在橙色区域内，则BV与截锥相交，如果p在紫色区域内，则BV完全在截锥内。</p>
<p><strong>只保存父BV与每个子BV的交集状态是一种有用的优化。如果已知父元素完全位于截锥内部，则任何子元素都不需要进一步的截锥测试。平面掩蔽和时间相干技术是一种新的技术在第19.4节中使用的方法也可以显著改进针对边界卷层次结构的测试，尽管对于SIMD实现来说用处不大。</strong></p>
<p><strong>首先，我们推导出截锥的平面方程，因为这类试验需要这些方程。接着介绍了截锥/球面相交，接着解释了截锥/盒体相交。</strong></p>
<h3 id="Frustum-Plane-Extraction-视锥平面提取"><a href="#Frustum-Plane-Extraction-视锥平面提取" class="headerlink" title="Frustum Plane Extraction 视锥平面提取"></a>Frustum Plane Extraction 视锥平面提取</h3><p><strong>为了做视图截锥剔除，需要截锥的六个不同侧面的平面方程。我们在这里提出一种聪明而快速的方法来获得这些。假设视图矩阵为V，投影矩阵为P，则复合变换为M = PV。点s(其中sw = 1)转化为t = ms，此时，t可能有tw ≠ 1，因为，例如，透视投影。因此，t中的所有分量都除以tw 用u得到点uw = 1。对于视图截锥内的点，认为−1≤ui≤1，对于i∈x, y, z，即点u在里面一个单位立方体。这是针对OpenGL类型的投影矩阵(章节4.7)。对于DirectX，同样成立，除了0≤uz ≤1。截体的平面可以直接由复合变换矩阵的行推导出来。</strong></p>
<p><strong>先关注一下单位立方体左侧平面右侧的体积，其中−1≤ux。这一点在下面展开:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115134224.png" class="" title="image-20211115134224">

<p><strong>在推导过程中，mi, 表示M中的第i行。最后一步中(m0, + m3,)·s≥0实际上表示视图截锥左平面的(半)平面方程。这是因为单位立方体中的左平面已经被转换回世界坐标。还要注意sw = 1，使方程成为一个平面。为了使平面的法线点从截锥向外，方程必须被否定(就像描述单位立方体内部的原始方程一样)。这给了−(m3, + m0,·(x, y, z, 1) = 0对于截锥的左平面(这里我们使用(x, y, z, 1)而不是使用形式为:ax + by + cz + d = 0的平面方程)。总而言之，所有的平面都是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115134521.png" class="" title="image-20211115134521">

<p><strong>OpenGL和DirectX中的代码可以在web上找到。</strong></p>
<h3 id="Frustum-Sphere-Intersection-视锥体-球体交叉"><a href="#Frustum-Sphere-Intersection-视锥体-球体交叉" class="headerlink" title="Frustum/Sphere Intersection 视锥体/球体交叉"></a>Frustum/Sphere Intersection 视锥体/球体交叉</h3><p><strong>正射影视图的截锥体是一个盒体，因此在这种情况下的重叠测试是一个球体/OBB相交，可以使用22.13.2节给出的算法来解决。为了进一步测试球体是否完全在盒子内部，我们首先检查球体的中心是否沿着每个轴在盒子边界之间的距离大于它的半径。如果它在所有三个维度之间，它就是完全包含的。关于这个修改过的算法的有效实现，以及代码，请参阅Arvo的文章。</strong></p>
<p><strong>按照推导截锥/BV测试的方法，对于任意截锥，我们选择球的中心作为跟踪点p。如下图所示。如果半径为r的球体，沿着截锥的内部和外部移动，并且尽可能地靠近截锥，那么p的轨迹给了我们重新制定截锥/球体测试所需的体积。实际的体积显示在下图的中间部分。和之前一样，如果p在橙色外面体积，那么球面在截锥外。如果p在紫色区域内，那么球面完全在截锥内。如果点在橙色区域内，则球面与截锥侧面平面相交。这样，精确的测试就可以完成了。然而，为了效率起见，我们使用下图右侧的近似。在这里，为了避免圆角需要的更复杂的计算，橙色的体积被扩展了。注意,外卷由平面的视锥体r移动距离单位向外的方向平截头体平面正常,而内部体积可以创建通过移动平面视锥体r距离单元内的视锥体平面法线的方向。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115134955.png" class="" title="image-20211115134955">

<p>在左边显示了一个截锥和一个球体。精确的截锥/球体测试可以表述为测试p与中间图中的橙色和紫色体积。右边是中间体积的合理近似。如果球体的中心位于圆角外，但在所有外平面内，它将被错误地分类为相交，即使它是在截锥外。</p>
<p><strong>假设截锥的平面方程是这样的:正半空间位于截锥的外面。然后，一个实际的实现将在截锥的六个平面上进行循环，对于每个截锥平面，计算从球体中心到平面的带符号的距离。这是通过将球心插入平面方程来完成的。如果距离大于半径r，那么球面在截锥外。如果到所有六个平面的距离都小于- r，则球体在截锥内;否则球面与它相交。更准确地说，我们说球体与截锥相交，但球体中心可能位于上图中圆角外的一个尖角区域。这意味着球体在截锥的外面，但我们认为它是相交的，保守地说，是正确的。</strong></p>
<p><strong>为了使测试更精确，如果球体在外面，可以添加额外的平面进行测试。然而，为了快速剔除场景图节点，偶尔的错误命中只会导致不必要的测试，而不是算法失败，而且这种额外的测试总体上会花费更多的时间。在第20.3节中描述了另一种更精确(尽管仍然不精确)的方法，这种方法在这些尖角区域非常重要时很有用。</strong></p>
<p><strong>对于有效的着色技术，锥体通常是高度不对称的，一个特殊的方法描述在第895页的图20.7。Assarsson和M¨oller提供了一种方法，通过将截锥分割成八进制并找出物体的中心位于哪个八进制中，从而消除了每个测试中的三个平面。</strong></p>
<h3 id="Frustum-Box-Intersection-视锥体-盒的交叉"><a href="#Frustum-Box-Intersection-视锥体-盒的交叉" class="headerlink" title="Frustum/Box Intersection 视锥体/盒的交叉"></a>Frustum/Box Intersection 视锥体/盒的交叉</h3><p><strong>如果视图的投影是正投影(即通过OBB/OBB交叉测试(章节22.13.5)，可以进行精确的测试。对于一般的截锥/箱交叉测试，有两种常用的方法。一个简单的方法是通过使用截锥的视图和投影矩阵将所有8个方框角转换为截锥的坐标系统。执行沿每个轴延伸[−1,1]的规范视图体积的剪辑测试(章节4.7.1)。如果所有的点都在一个边界之外，盒子就会被拒绝;如果所有的都在，这个盒子就被完全包含了。由于此方法模拟裁剪，它可以用于由一组点分隔的任何对象，如线段、三角形或k-DOP。这种方法的优点是不需要提取截锥平面。它的自包含的简单性使它在计算着色器中高效使用。</strong></p>
<p><strong>一个在CPU上相当有效的方法是使用在22.10节中描述的平面/盒相交测试。像截锥/球体测试一样，OBB或AABB是针对六个视图截锥平面进行检查的。在平面/盒测试中，我们最多检查两个角，而不是计算从平面到所有八个角的标记距离，由飞机的正常状态决定。如果最近的角在平面外面，盒子完全在外面，测试可以提前结束。如果每个平面的最远角在内部，则方框包含在截锥内部。注意，远近平面的点积距离计算是可以共享的，因为这些平面是平行的。第二种方法的唯一额外费用是必须首先得到截锥的平面，如果要测试几个箱子的话，这是一笔微不足道的费用。</strong></p>
<p><strong>与截锥/球体算法一样，测试也需要将实际完全位于外部的交叉框进行分类。这些类型的错误如下图所示。Qu´ılez指出，在固定大小的地形网格或其他大型物体中，这种情况会更频繁地发生。当报告了一个交集时，他的解决方案是随后也测试每个形成边界框的平面上的截锥角。如果所有的点都在一个方框的平面外，截锥和方框就不相交。这个额外的测试相当于分离轴测试的第二部分，其中被测试的轴与第二个对象的面正交。也就是说，这种额外的检测可能比累积的收益更昂贵。对于他的GIS渲染器，Eng发现这种优化每帧消耗2毫秒的CPU时间，只节省了一些绘制调用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115135403.png" class="" title="image-20211115135403">

<p>粗体的黑线是截锥的平面。当使用所提出的算法测试框(左)与截锥时，框可能被错误地分类为相交时，它是在外面。对于图中的情况，当方框的中心位于红色区域时，就会发生这种情况。</p>
<p><strong>Wihlidal使用截锥剔除的另一个方向，只使用四个截锥侧面，而不执行近平面和远平面剔除测试。他指出，这两架平面在电子游戏中并没有多大帮助。近的平面大多是多余的，因为侧面几乎修剪了它所做的所有空间，而远面通常设置为查看场景中的所有物体。</strong></p>
<p><strong>另一种方法是使用分离轴测试(见22.13节)来推导交集例程。一些作者使用分离轴检验来求解两个凸多面体的通解。一个单一的优化测试可以用于线段、三角形、AABBs、OBBs、 k-DOPs、视锥体和凸多面体的任何组合。</strong></p>
<h2 id="Line-Line-Intersection-线-线交叉"><a href="#Line-Line-Intersection-线-线交叉" class="headerlink" title="Line/Line Intersection 线/线交叉"></a>Line/Line Intersection 线/线交叉</h2><p><strong>在本节中，推导和检查了二维和三维的线/线相交测试。线、射线和线段彼此相交，并描述了既快速又优雅的方法。</strong></p>
<h3 id="Two-Dimensions-二维"><a href="#Two-Dimensions-二维" class="headerlink" title="Two Dimensions 二维"></a>Two Dimensions 二维</h3><h4 id="First-Method-方法一"><a href="#First-Method-方法一" class="headerlink" title="First Method 方法一"></a>First Method 方法一</h4><p><strong>从理论的角度来看，计算一对二维线的交点的第一种方法是非常漂亮的。考虑两条直线r1(s)= o1 + sd1 和r2(t) = o2 +td2。自从a·a^⊥ = 0 (perp点积来自章节1.2.1)，r1(s)和r2变得优雅而简单。请注意这部分中的所有向量都是二维的</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115140215.png" class="" title="image-20211115140215">

<p><strong>如果d1 ·d2^⊥ = 0，则两直线平行且不相交。对于无限长的线，所有的s和t值都是有效的，但是对于线段(具有标准化方向)，长度为l1 和l2 (从s = 0开始，t = 0结束于s = l1,t = l2)，当且仅当0≤s≤l1和0≤t≤l2时，我们有一个有效的交集。或者，如果设o1 = p1 和d1 = p2 −p1 (意思是线段从p1 在p2处结束)，同理求r2 起点和终点是q1 和q2，则当且仅当0≤s≤1,0≤t≤1时，存在有效交。对于有原点的射线，有效范围为s≥0,t≥0。交点可以通过把s代入r1 或者把t代入r2得到。</strong></p>
<h4 id="Second-Method-方法二"><a href="#Second-Method-方法二" class="headerlink" title="Second Method 方法二"></a>Second Method 方法二</h4><p><strong>Antonio描述了另一种判断两条线段(即。通过做更多的比较和早期的拒绝，以及避免前面公式中昂贵的计算(除法)，实现了交叉。因此，这种方法更快。再次使用前面的符号，即第一个线段从p1到p2 开始第二个来自q1到q2．这意味着r1(s)= p1 + s (p2 −p1)和r2(t) =q1 + t(q2 −q1）。用22.28式的结果求得一个解r1(s) = r2(t)：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115140816.png" class="" title="image-20211115140816">

<p><strong>在22.29式中，a = q2 −q1， b = p2 −p1， c = p1 −q1， d = c·a^⊥，e = c·b^⊥，f = a·b^⊥。因子s的简化步骤来自以下事实： a^⊥·b =−b^⊥·a和 a·b^⊥= b^⊥·a，如果 a·b^⊥= 0，那么这两条线是共线的。Antonio注意到s和t的分母是相同的，由于s和t不是明确需要的，可以省略除法运算。定义s = d/f和t = e/f。要测试0≤s≤1，使用以下代码:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115141519.png" class="" title="image-20211115141519">

<p><strong>经过检验，保证0≤s≤1。然后对t = e/f执行同样的操作(通过将代码中的d替换为e)。如果例程在测试后没有返回，线段就会相交，因为t值也有效。</strong></p>
<p><strong>这个例程的整数版本的源代码可以在网上找到，并且很容易转换为浮点数使用。</strong></p>
<h3 id="Three-Dimensions-三维"><a href="#Three-Dimensions-三维" class="headerlink" title="Three Dimensions 三维"></a>Three Dimensions 三维</h3><p><strong>假设我们想在三维空间中计算两条直线(由射线定义，方程22.1)的交点。这些线也称为r1(s)= o1 + sd1 和r2(t) = o2 +td2,没有限制的值t。三维对应的补点产品,在这种情况下,叉乘,因为a×a= 0,因此三维版本是一样的推导二维的版本。两条直线的交点推导如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115141855.png" class="" title="image-20211115141855">

<p><strong>第三步是减去o1 (o2)，然后与d2 (d1)，步骤4用d1 ×d2 (d2 ×d1）点乘得到.最后，第5步，解是将等式右边写成行列式(并改变下面方程的一些符号)然后除以s (t)右边的项。</strong></p>
<p><strong>Goldman指出，如果分母是||d1 ×d2||² = 0，那么这两条线平行。他还注意到，如果线是倾斜的(即它们不共面),则s和t参数表示最接近的点。</strong></p>
<p><strong>如果这些线被当作线段，长度为l1 和l2 (假设方向向量d1 和d2 均归一化)，然后检查0≤s≤l1和0≤t≤l2 两种。如果不是，则拒绝交集。</strong></p>
<p><strong>Rhodes对两条直线或线段相交问题给出了深入的解决方案。他给出了处理特殊情况的健壮解决方案，并讨论了优化并提供了源代码。</strong></p>
<h2 id="Intersection-between-Three-Planes-三个平面交叉"><a href="#Intersection-between-Three-Planes-三个平面交叉" class="headerlink" title="Intersection between Three Planes 三个平面交叉"></a>Intersection between Three Planes 三个平面交叉</h2><p><strong>给定三个平面，每个平面由一个标准化的法向量ni描述，以及平面上任意点pi， i = 1, 2，和3，这两个平面的交点p由下方程给出。注意，如果有两个或多个平面平行，则分母，即三个平面法线的行列式为零:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115142645.png" class="" title="image-20211115142645">

<p><strong>该公式可用于计算由一组平面组成的曲面的角。一个例子是k-DOP，它由k个平面方程组成。上方程可以计算凸多面体的角，如果它是由适当的平面提供的。</strong></p>
<p><strong>通常情况下，如果平面以隐式形式给出，即πi : ni ·x +di = 0，那么我们需要找到点pi 为了能够使用这个方程。可以选择平面上的任意点。我们计算离原点最近的点，因为这些计算很便宜。给定一条来自原点的光线，沿着平面的法线，与平面相交，得到离原点最近的点:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115142920.png" class="" title="image-20211115142920">

<p><strong>这个结果不应该让人感到惊讶，因为di 在平面方程中，原点到平面的负距离是垂直的(如果这是真的，法线必须是单位长度)。</strong></p>
<h1 id="23-Graphics-Hardware-图形硬件"><a href="#23-Graphics-Hardware-图形硬件" class="headerlink" title="23 Graphics Hardware 图形硬件"></a>23 Graphics Hardware 图形硬件</h1><p><strong>尽管图形硬件正在快速发展，但在其设计中仍有一些通用的概念和架构。我们在这一章的目标是给一个图形系统的各种硬件元素的理解，以及它们如何相互关联。书的其他部分讨论了它们与特定算法的使用。这里，我们根据硬件本身的条件来介绍硬件。我们首先描述如何栅格化线条和三角形，然后演示GPU的大规模计算能力是如何工作的，任务是如何调度的，包括处理延迟和占用。然后我们讨论内存系统，缓存，压缩，颜色缓冲，以及GPU中与深度系统相关的一切。然后介绍纹理系统的细节，然后介绍GPU的架构类型。在第23.10节中介绍了三种不同体系结构的案例研究，最后简要讨论了光线追踪体系结构。</strong></p>
<h2 id="Rasterization-光栅化-2"><a href="#Rasterization-光栅化-2" class="headerlink" title="Rasterization 光栅化"></a>Rasterization 光栅化</h2><p><strong>任何GPU的一个重要特性就是它绘制三角形和直线的速度。如2.4节所述，光栅化包括三角形设置和三角形遍历。此外，我们将描述如何在三角形上插值属性，这与三角形遍历密切相关。我们以保守光栅化结束，它是标准光栅化的扩展。</strong></p>
<p><strong>回想一下，像素的中心是(x+0.5, y+0.5)，其中x∈[0,W−1]，y∈[0,H−1]为整数，W × H为屏幕分辨率，如3840 × 2160。设非变换顶点为vi，i∈{0,1,2}，变换后的顶点(包括投影但不除w)为qi = Mvi．二维屏幕空间坐标为pi =((qix/qiw + 1)W/2， (qiy/qiw + 1)H/2) ，则执行透视图除以w分量，并将值进行缩放和转换以匹配屏幕分辨率。这个设置如下图所示。是可以如图所示，像素网格被划分为2 × 2像素组，称为四边形。为了能够计算纹理细节级别(第23.8节)所需的导数，对所有三角形中至少有一个像素的四边形计算像素着色(也在第3.8节中讨论)。这是大多数GPU(如果不是全部的话)的核心设计，并影响了许多后续阶段。三角形越小，辅助像素与三角形内像素的比例就越大。这种关系意味着在执行像素着色时，小三角形是昂贵的(与三角形面积成比例)。最糟糕的情况是一个三角形覆盖一个像素，这意味着它需要三个辅助像素。辅助像素的数量有时被称为四边形着色。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116132646.png" class="" title="image-20211116132646">

<p>一个三角形，有三个二维顶点p0,p1和p2 在屏幕空间。屏幕的尺寸是16 × 8像素。注意，像素(x, y)的中心是(x + 0.5, y + 0.5)。底边的法向量(长度按0.25缩放)显示为红色。只有绿色的像素在三角形内。黄色的辅助像素属于正方形(2 × 2像素)，其中至少有一个像素被认为是在里面，而辅助像素的样本点(中心)在三角形外面。使用有限差分计算导数时需要辅助像素。</p>
<p><strong>为了确定一个像素中心或任何其他样本位置是否在一个三角形内，硬件对每个三角形边缘使用一个边缘函数。这些是基于直线方程的，也就是，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116132813.png" class="" title="image-20211116132813">

<p><strong>其中n是一个向量，有时称为边的法向量，与边正交，p是直线上的一点。这样的方程可以写成ax+by +c = 0。接下来，我们将推导出边函数e2(x, y)到p0 和p1．边向量是p1 −p0，法线就是这条边逆时针旋转90度，也就是 n2 =(−(p1y−p0y)， p1x−p0x)，指向三角形内部，如上图所示。通过插入n2 和p0 代入上方程,e2(x, y)变成了</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116132956.png" class="" title="image-20211116132956">

<p><strong>对于边上的点(x, y) e(x, y) = 0。将法线指向三角形内侧意味着e(x, y) &gt; 0表示与法线同边的点。这条边将空间分成两部分，e(x, y) &gt; 0有时被称为正半空间，e(x, y) &lt; 0被称为负半空间。这些属性可以用来确定一个点是否在三角形内。称三角形的边为ei，i∈{0,1,2}。如果一个采样点(x, y)在三角形内或在三角形的边缘，那么它必须保持ei(x, y)对所有i≥0。</strong></p>
<p><strong>图形API规范经常要求将屏幕空间中的浮点顶点坐标转换为定点坐标。这样做是为了以一致的方式定义平局规则(稍后将介绍)。它还可以使样品的内部测试更有效。两个pix 和piy 可以存储，例如，1.14.8位，即1符号位，14位为整数坐标，8位为像素内的小数位置。在这种情况下，这意味着可以有2⁸ 个在一个像素内x和y的可能位置，并且整数坐标必须在[−(2^14−1)， 2^14−1]范围内。在实际操作中，这种接合是在计算边方程之前完成的。</strong></p>
<p><strong>边函数的另一个重要特征是它的增量性质。假设我们在某个像素中心(x, y) = (xi + 0.5,yi + 0.5),其中(xi , yi)为整数像素坐标，即我们求出e(x, y) = ax+by+c。例如，要计算右边的像素，我们需要计算e(x + 1, y)，它可以重写为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116133337.png" class="" title="image-20211116133337">

<p><strong>即这只是在当前像素e(x, y)加上a处计算的边函数。类似的推理可以应用于y方向，这些属性通常被用来快速计算一小块像素中的三个边方程，例如，8 × 8像素，用每个像素一个比特来“戳穿”覆盖掩码，表示该像素是否在内部。稍后将在本节中解释这种层次遍历。</strong></p>
<p><strong>重要的是要考虑当一条边或一个顶点恰好经过一个像素中心时会发生什么。例如，假设两个三角形共享一条边，这条边通过一个像素中心。它应该属于第一个三角形，第二个，还是两个都属于?从效率的角度来看，这两个答案都是错误的，因为像素首先会被一个三角形写入，然后被另一个三角形覆盖。为此，通常使用平局规则，这里我们展示了在DirectX中使用的左上角规则。像素在ei(x, y) &gt; 0，对于所有i∈{0,1,2}，总是被认为在内部。当一条边经过一个像素时，左上角的规则起作用。如果像素的中心位于上边缘或左边缘上，则该像素被认为是内部的。如果一条边是水平的，而其他边在它下面，那么它就是上边。如果一条边是非水平的，并且位于三角形的左侧，那么它就是一条左边，这意味着一个三角形最多可以有两条左边。它可以简单地检测边缘是顶部还是左侧。A上边缘的a = 0(水平)和b &lt; 0，而左边缘的a&gt; 0。确定采样点(x, y)是否在三角形内的整个测试有时被称为内部测试。</strong></p>
<p><strong>我们还没有解释如何穿越线路。一般来说，一条线可以被渲染成一个长方形，像素宽的矩形，它可以由两个三角形组成，也可以为矩形使用一个额外的边方程。这种设计的优点是边方程的硬件同样适用于线。点被画成四边形。</strong></p>
<p><strong>为了提高效率，通常采用分层的方式进行三角遍历。通常，硬件会计算屏幕空间顶点的边界框，然后确定哪些tile位于边界框内，并且与三角形重叠。确定瓦片是否在边缘之外，可以使用第22.10.1节AABB/平面试验的二维版本技术。一般原理如下图所示。为了适应平铺三角形遍历，我们可以首先确定在遍历开始之前，应该用边缘测试哪个平铺角。对于特定边缘的所有瓦片，使用的瓦片角是相同的，因为最近的瓦片角只取决于边缘法线。对这些预定角的边缘方程进行计算，如果这个选定的角在其边缘之外，则整个平铺在外部，硬件不需要在该平铺中执行任何逐像素的内部测试。要移动到相邻的贴图，可以对每递增属性。例如，要向右水平移动8个像素，就需要添加8a。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116133701.png" class="" title="image-20211116133701">

<p>边函数的负半空间e(x, y) &lt; 0总是被认为在三角形外。在这里，4×4像素贴图的角落被投影到边缘的法线上。只有带有黑圆的角需要用这条边来测试，因为它在n上的投影是最大的。然后可以得出结论，这个瓷砖在三角形的外面。</p>
<p><strong>有了贴图/边缘相交测试，就有可能分层遍历三角形。如下图所示。tiles也需要按照一定的顺序进行遍历，这可以采用之字形顺序或使用一些空间填充曲线，这两种方法都倾向于增加一致性。如果需要，还可以添加层次遍历中的其他级别。例如，玩家可以先访问16 × 16的贴图，然后测试每个与三角形重叠的贴图的4 × 4 subtiles。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116133826.png" class="" title="image-20211116133826">

<p>使用4 × 4像素贴图的平铺遍历时可能的遍历顺序。在本例中，遍历从左上角开始，一直到右边。顶部的每一个贴图都与三角形重叠，尽管右上方的贴图没有像素。遍历继续到直接下方的贴图，它完全位于外部，所以这里不需要逐像素的内部测试。然后继续向左遍历，发现下面两个贴图与三角形重叠，而左下方的贴图没有重叠。</p>
<p><strong>平铺遍历的主要优势，比如说，以扫描线顺序遍历三角形，是像素以更一致的方式处理，因此，像素访问也更一致。它还具有在访问颜色和深度缓冲区时更好地利用局部性的优点。例如，考虑一个大三角形以扫描线顺序遍历。texel被缓存，所以最近访问的texel保留在缓存中以供重用。假设mipmapping用于纹理，这增加了缓存中的texels的重用级别。如果我们按照扫描线顺序访问像素，那么当到达扫描线的末端时，在扫描线开始处使用的像素很可能已经从缓存中移除。由于在缓存中重用texel比从内存中重复获取texel更有效，三角形通常在tile中遍历。这为纹理、深度缓冲和颜色缓冲提供了很大的好处。事实上，纹理、深度和颜色缓冲也是出于同样的原因存储在tiles中。这将在第23.4节中进一步讨论。</strong></p>
<p><strong>在三角形遍历开始之前，GPU通常有一个三角形设置阶段。这个阶段的目的是计算三角形上的常数，以便遍历能够有效地进行。例如，边方程中式23.2)常数ai,bi,ci，i∈{0,1,2}，在此计算一次，然后用于当前三角形的整个遍历步骤。三角形设置还负责计算与属性插值相关的常量(章节23.1.1)。随着讨论的继续，我们还将发现在三角形设置中可以一次性计算的其他常数。</strong></p>
<p><strong>由于裁剪可能生成更多的三角形，因此剪辑必须在三角形设置之前完成。在剪辑空间中根据视图体积裁剪一个三角形是一个昂贵的过程，所以GPU避免这样做，如果不是绝对必要的话。对近平面的裁剪总是需要的，这可以产生一个或两个三角。对于屏幕边缘，大多数GPU使用保护带剪切，这是一种更简单的方案，避免了更复杂的完整剪切过程。算法如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116134049.png" class="" title="image-20211116134049">

<p>防护带试图避免完全剪断。假设防护带区域在x和y上都是±16K像素，那么中间的屏幕大约是6500 × 4900像素，这表明这些三角形是巨大的。底部的两个绿色三角形要么作为三角形设置的一部分，要么在前面的步骤中被剔除。常见的情况是中间的蓝色三角形，它与屏幕区域相交，并且完全在防护带内部。不需要完整的剪切操作，因为只处理可见的贴图。红色三角形在保护带之外，并与屏幕区域相交，所以这些需要修剪。注意右边的红色三角形被剪成两个三角形。</p>
<h3 id="Interpolation-插值"><a href="#Interpolation-插值" class="headerlink" title="Interpolation 插值"></a>Interpolation 插值</h3><p><strong>在22.8.1节中，质心坐标是计算射线与三角形相交的副产品。任意顶点属性ai，i∈{0,1,2}，可以用质心坐标(u, v)插值为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116134542.png" class="" title="image-20211116134542">

<p><strong>其中a(u, v)是三角形上(u, v)处的插值属性。质心坐标的定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116134607.png" class="" title="image-20211116134607">

<p><strong>Ai 是下图中左边所示的子三角形的面积。第三个坐标w = A0/ (A0 +A1 +A2)也是定义的一部分，它表明u + v + w = 1，即 w = 1−u−v，这里用1−u−v代替w。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116134742.png" class="" title="image-20211116134742">

<p>左:一个顶点上具有标量属性(a0, a1, a2)的三角形。在p点的重心坐标与带符号的区域(A1,A2,A0）成.中间:说明重心坐标(u, v)在三角形上的变化。右:法线的长度n2 是边p0p1 逆时针旋转90度。这个区域A2 然后bh / 2。</p>
<p><strong>式23.2中的边方程可以用边的法线表示，n2 = (a2, b2)，有</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116135028.png" class="" title="image-20211116135028">

<p><strong>其中p = (x, y)根据点积的定义，这个可以写成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116135113.png" class="" title="image-20211116135113">

<p><strong>α是n2和p−p0之间的夹角．注意，b = ||n2||等于边p0p1的长度,因为n2 是边旋转90度。第二项||p−p0|| cos α的几何解释，是投影p−p0 到n2得到的向量的长度，这个长度正好等于区域A2的子三角形的高h．如上图中的右侧所示。值得注意的是，我们有e2(p) = | | n2|| ||p−p0|| cos α = bh = 2A2，这很好，因为我们需要子三角形的面积，以计算重心坐标。这意味着</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116135432.png" class="" title="image-20211116135432">

<p><strong>三角形设置通常计算1/(A0 +A1 +A2)，因为三角形的面积没有改变，这也避免了每个像素的分割。所以，当我们用边方程遍历一个三角形时，方程23.8中的所有项都是内部测试的副产品。这在插值深度时很有用，正如我们将看到的，或者对于正交投影，但是对于透视投影，重心坐标不会生成预期的结果，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116135520.png" class="" title="image-20211116135520">

<p>左图:在透视中，几何体的投影图像随着距离而缩小。中间:边对三角形的投影。注意三角形的上半部分在投影平面上所覆盖的部分比下半部分要小。右图:带有棋盘纹理的四边形。上面的图像使用重心坐标进行纹理渲染，而下面的图像使用透视校正的重心坐标。</p>
<p><strong>透视校正的重心坐标需要每像素进行除法。这里省略推导，而是总结最重要的结果。由于线性插值并不昂贵，而且我们知道如何计算(u, v)，所以我们希望在屏幕空间中尽可能多地使用线性插值，甚至用于透视校正。有点令人惊讶的是，它证明了在三角形上线性插值a/w和1/w是可能的，其中w是变换后顶点的第四个分量。恢复内插属性a，就是使用这两个插值值，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116135628.png" class="" title="image-20211116135628">

<p><strong>这是前面提到的逐像素划分。</strong></p>
<p><strong>一个具体的例子说明了这种效果。假设我们沿着一个水平三角形的边进行插值，用a0 = 4在左边结束和a1 = 6在右边。这两个端点之间的中点值是多少?对于正投影(或者当端点的w值匹配时)，答案就是a = 5, 中间值在a0 和a1间．</strong></p>
<p><strong>而是说端点的w值是w0 = 1和w1 = 3。在这种情况下，我们需要插值两次，以得到a/w和1/w。对于a/w，左端点是4/1 = 4，右端点是6/3 = 2，所以中点值是3。对于1/w，我们有1/1和1/3，所以中点是2/3。3除以2/3得到a = 4.5透视中点值。</strong></p>
<p><strong>在实践中，我们经常需要在一个三角形上使用透视校正来插值几个属性。因此，通常需要计算透视图校正的重心坐标，我们将其表示为(∽u，∽v)，然后将其用于所有属性插值。为此，我们引入以下辅助函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116135936.png" class="" title="image-20211116135936">

<p><strong>注意，由于e0(x y) = a0x + b0y + c0，三角形设置可以计算和存储a0/ w0 和其他类似的术语，以使每像素计算更快。另外,所有fi函数可以乘以w0w1w2；例如，我们储存w1w2f0(x, y), w0w2f1(x, y)和w0w1f2(x, y)。透视校正的重心坐标是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116140046.png" class="" title="image-20211116140046">

<p><strong>每个像素需要计算一次，然后可以用正确的透视缩短来插值任何属性。注意，这些坐标与子三角形的面积不像(u, v)那样成比例。此外，分母不是常数，就像重心坐标那样，这就是为什么必须按像素进行除法的原因。</strong></p>
<p><strong>最后，请注意，由于深度是z/w，我们可以在23.10式中看到，我们不应该使用这些方程，因为它们已经被w除了。因此，zi/ wi 应该每个顶点计算，然后使用(u, v)进行线性插值。这有几个优点，例如，对于深度缓冲区的压缩(第23.7节)。</strong></p>
<h3 id="Conservative-Rasterization-保守的光栅化"><a href="#Conservative-Rasterization-保守的光栅化" class="headerlink" title="Conservative Rasterization 保守的光栅化"></a>Conservative Rasterization 保守的光栅化</h3><p><strong>从DirectX 11开始，通过在OpenGL中使用扩展，可以使用一种名为保守光栅化(CR)的新型三角形遍历。CR分为高估CR (OCR)和低估CR (UCR)两种。有时它们也被称为外保守光栅化和内保守光栅化。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116140237.png" class="" title="image-20211116140237">

<p>三角形的保守栅格化。使用外保守栅格化时，所有彩色像素都属于三角形。黄色和绿色像素使用标准栅格化在三角形内部，只有绿色像素使用内部保守栅格化生成。</p>
<p><strong>宽泛地说，所有重叠的像素或三角形内的像素都用OCR访问，只有完全在三角形内的像素才用UCR访问。OCR和UCR都可以通过平铺遍历实现，将平铺大小缩小到一个像素。当硬件不支持时，可以使用几何着色器或三角形扩展来实现OCR。有关CR的更多信息，请参阅相应API的规范。CR可以用于图像空间的碰撞检测、遮挡剔除、阴影计算和抗锯齿等算法。</strong></p>
<p><strong>最后，我们注意到所有类型的栅格化都充当几何和像素处理之间的桥梁。为了计算三角形顶点的最终位置和计算像素的最终颜色，GPU需要大量灵活的计算能力。下面将对此进行解释。</strong></p>
<h2 id="Massive-Compute-and-Scheduling-大量计算和调度"><a href="#Massive-Compute-and-Scheduling-大量计算和调度" class="headerlink" title="Massive Compute and Scheduling 大量计算和调度"></a>Massive Compute and Scheduling 大量计算和调度</h2><p><strong>为了提供可用于任意计算的大量计算能力，大多数(如果不是全部的话)GPU架构使用统一的着色器架构，使用多线程的SIMD处理，有时称为 SIMT处理或超线程。有关线程、SIMD处理、扭曲和线程组的详细信息，请参阅第3.10节。请注意，我们使用术语翘曲，这是NVIDIA的术语，但在AMD的硬件上，这些被称为波或波前。在本节中，我们将首先查看GPU中使用的典型统一算术逻辑单元(ALU)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116140540.png" class="" title="image-20211116140540">

<p>左:一个算术逻辑单元的例子，每次只执行一项。分派端口接收有关要执行的当前指令的信息，操作数收集器读取指令所需的寄存器。右图:这里，8 × 4 ALU已经与其他几个硬件单元组装在一起，形成一个称为多处理器的块。32个ALUs，有时称为SIMD通道，将以锁步方式执行相同的程序，即它们构成SIMD引擎。还有一个寄存器文件、一个L1缓存、本地数据存储、纹理单元和用于在ALU中未处理的各种指令的特殊单元。</p>
<p><strong>ALU是为一个实体(如顶点或片段)执行程序而优化的一块硬件。有时我们用SIMD lane来代替ALU。图形处理器的典型ALU显示在上图的左侧。主要的计算单元是浮点(FP)单元和整数单元。FP单元通常遵循IEEE 754 FP标准，并支持FMA指令作为其最复杂的指令之一。ALU通常还包含移动/比较、加载/存储功能和分支单元，以及超越操作，如余弦、正弦和指数。然而，应该注意的是，其中一些可能位于某些架构上的独立硬件单元中，例如，一组小型的，比如说，超越的硬件单元可以操作到服务更多的ALU。对于不像其他操作那样经常执行的操作来说，情况可能就是这样。如上图中右侧所示，这些组合在特殊单元(SU)块中。ALU架构通常使用几个硬件管道阶段来构建，即有几个构建在硅中并并行执行的实际块。例如，当当前指令执行乘法运算时，下一条指令可以获取寄存器。如果有n个管线阶段，理想情况下，吞吐量可以增加n倍。这通常被称为流水线并行性。使用流水线的另一个重要原因是，流水线处理器中最慢的硬件块指示了执行该块的最大时钟频率。增加管道阶段的数量可以使每个管线阶段的硬件块数量更小，这通常可以增加时钟频率。然而，为了简化设计，ALU通常有几个管线阶段，例如4-10。</strong></p>
<p><strong>统一的ALU不同于CPU核心，因为它没有许多附加功能，比如分支预测、寄存器重命名和深度指令流水线。相反，芯片的大部分区域都花在复制ALU上，以提供巨大的计算能力，并增加寄存器文件的大小，以便可以输入和输出扭曲。例如，NVIDIA GTX 1080 Ti有3584个ALU。为了高效地调度分配给GPU的工作，大多数GPU将ALU分组为32个。它们以锁步方式执行，这意味着整个32个ALU集是一个SIMD引擎。不同的供应商使用不同的名称来表示这样的组以及附加的硬件单元，我们使用通用术语多处理器(MP)。例如，NVIDIA使用术语流多处理器，Intel使用执行单元，AMD使用计算单元。上图的右侧显示了MP的一个示例。MP通常有一个调度程序，将工作分派给SIMD引擎，还有一个L1缓存、本地数据存储(LDS)、纹理单元(TX)和一个用于处理未在ALU中执行的指令的特殊单元。MP将指令分派到ALU上，在ALU上指令以锁步方式执行，即SIMD-处理(章节3.10)。请注意MP的确切内容因厂商和架构的不同而不同。</strong></p>
<p><strong>SIMD处理对于图形工作负载是有意义的，因为有许多相同的，例如，顶点和片段，执行相同的程序。在这里，架构利用了线程级的并行性，例如，顶点和碎片可以独立于其他顶点和碎片执行它们的着色器。此外，对于任何类型的SIMD/ simt处理，都可以利用数据级的并行性，因为指令是针对SIMD机器中的所有通道执行的。还有指令级的并行性，这意味着如果处理器可以找到彼此独立的指令，它们就可以同时执行，前提是有资源可以并行执行。</strong></p>
<p><strong>接近MP的是一个(warp)调度器，它接收要在MP上执行的大块工作。经纱调度程序的任务是将经纱中的工作分配给MP，将寄存器文件(RF)中的寄存器分配给经纱中的线程，然后以最好的方式对工作进行优先排序。通常，下游的工作优先级高于上游工作。例如，像素着色位于可编程阶段的末尾，比在流水线中较早的顶点着色具有更高的优先级。这避免了拖延，因为接近尾声的阶段不太可能阻塞早期阶段。请参阅第34页的图3.2，以重新了解图形管线图。MP可以处理数百甚至数千个线程，以隐藏延迟，例如内存访问。调度程序可以在MP上切换当前正在执行(或等待)的曲速，等待一个可以执行的曲速。由于调度器是在专用硬件中实现的，因此通常无需任何开销。例如，如果当前的warp执行了一个纹理加载指令，预计会有很长的延迟，调度程序可以立即切换出当前的warp，用另一个来替换它，并继续执行那个warp。通过这种方式，可以更好地利用计算单元。</strong></p>
<p><strong>注意，对于像素着色工作，warp调度器会分派几个完整的四边形，因为像素是在四边形粒度上着色的，以便计算导数。这已在第23.1节中提到，并将在第23.8节中进一步讨论。所以，如果扭曲的尺寸是32，那么32/4 = 8个四轴可以被安排执行。这里有一个建筑设计选择，你可以选择将整个经线锁定在一个三角形上，或者有可能让经线上的每个四元属于一个不同的三角形。前者更容易实现，但对于较小的三角形，效率会受到影响。后者更复杂，但对于较小的三角形更有效。</strong></p>
<p><strong>通常，MPs也被复制，以获得更高的芯片上的计算密度，因此，GPU通常也有一个更高级别的调度器。它的任务是根据提交给GPU的工作将工作分配给不同的warp调度程序。在一个线程中有许多线程通常也意味着一个线程的工作需要独立于其他线程的工作。当然，在图形处理中经常会出现这种情况。例如，顶点的着色通常不依赖于其他顶点，片段的颜色通常不依赖于其他片段。</strong></p>
<p><strong>请注意，架构之间有许多不同之处。其中一些将在第23.10节重点介绍，其中将介绍一些不同的案例研究。至此，我们知道了光栅化是如何完成的，以及如何使用许多重复的统一ALU来计算着色。剩下的一大块是内存系统、所有相关的缓冲区和纹理。这些是从23.4节开始的以下部分的主题，但首先我们介绍一些延迟和占用的更多信息。</strong></p>
<h2 id="Latency-and-Occupancy-延迟和占用率"><a href="#Latency-and-Occupancy-延迟和占用率" class="headerlink" title="Latency and Occupancy 延迟和占用率"></a>Latency and Occupancy 延迟和占用率</h2><p><strong>一般来说，延迟是进行查询和接收查询结果之间的时间。例如，您可以在内存中的某个地址请求值，而从查询到获得结果所花费的时间就是延迟。另一个例子是从纹理单元请求经过过滤的颜色，从请求时间到该值可用可能需要数百甚至数千个时钟周期。这为了GPU中计算资源的有效使用，需要隐藏延迟。如果不隐藏这些延迟，那么内存访问可以很容易地支配执行时间。</strong></p>
<p><strong>其中一个隐藏机制是SIMD处理的多线程部分，如第33页的图3.1所示。一般来说，MP可以处理的扭曲有一个最大数量。主动翘曲的数量取决于寄存器的使用，也可能取决于纹理采样器、L1缓存、插值和其他因素的使用。这里，我们定义占用率o为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116142158.png" class="" title="image-20211116142158">

<p><strong>其中wmax MP和w上允许的最大曲线数是多少active是当前活动的翘曲数量。也就是说，o是计算资源使用情况的度量。例如，假设wmax = 32，一个着色器处理器有256kB寄存器，一个着色器程序一个线程使用27个32位浮点寄存器，另一个使用150。此外，我们假定寄存器的使用决定了活动翘曲的数量。假设SIMD宽度为32，则这两种情况的翘曲活动次数分别为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116142320.png" class="" title="image-20211116142320">

<p><strong>在第一种情况下，即对于使用27个寄存器的短程序，wactive &gt; 32，所以占用率是o = 1，这是理想的，因此预示着隐藏延迟的好兆头。然而，在第二种情况下，wactive ≈13.65，则o≈13.65/32≈0.43。因为有更少的主动扭曲，占用更低，这可能会阻碍延迟隐藏。因此，重要的是设计一个具有最大扭曲、最大寄存器和其他共享资源数量平衡的体系结构。</strong></p>
<p><strong>有时过高的占用率可能会适得其反，因为如果你的着色器使用了很多内存访问，它可能会使缓存崩溃。另一种隐藏机制是在内存请求之后继续执行相同的warp，如果有一些指令独立于内存访问的结果，这是可能的。虽然这样会使用更多的寄存器，但有时低占用率会更有效。一个例子是循环展开，它为指令级的并行性提供了更多的可能性，因为通常会生成更长的独立指令链，这使得在转换指令之前执行更长的时间成为可能。然而，这也会使用更多的临时寄存器。一般的规则是争取更高的入住率。低占用率意味着当一个着色器请求纹理访问时，切换到另一个扭曲的可能性更小。</strong></p>
<p><strong>另一种延迟是将数据从GPU读回CPU。一个好的思维模式是把GPU和CPU看作是独立的异步运行的计算机，两者之间的通信需要付出一些努力。改变信息流方向带来的延迟会严重影响性能。当从GPU读取数据时，可能必须在读取之前刷新管线。在此期间，CPU等待GPU完成它的工作。为架构，如英特尔的GEN架构，其中GPU和CPU在同一芯片上，并使用共享内存模型，这种类型的延迟大大降低。较低级别的缓存在CPU和GPU之间共享，而较高级别的缓存不共享。共享缓存减少的延迟允许不同类型的优化和其他类型的算法。例如，这个特性被用来加速光线追踪，光线在图形处理器和CPU核心之间来回传输，而不需要任何成本。</strong></p>
<p><strong>不产生CPU延迟的回读机制的一个例子是遮挡查询。看到19.7.1节。对于遮挡测试，其机制是执行查询，然后偶尔检查GPU，看看查询的结果是否可用。在等待结果的同时，其他工作可以同时在CPU和GPU上完成。</strong></p>
<h2 id="Memory-Architecture-and-Buses-内存架构和总线"><a href="#Memory-Architecture-and-Buses-内存架构和总线" class="headerlink" title="Memory Architecture and Buses 内存架构和总线"></a>Memory Architecture and Buses 内存架构和总线</h2><p><strong>在这里，我们将介绍一些术语，讨论几种不同类型的内存体系结构，然后介绍压缩和缓存。</strong></p>
<p><strong>端口是在两个设备之间发送数据的通道，而总线是在两个以上设备之间发送数据的共享通道。带宽是用来描述端口或总线上的数据吞吐量的术语，以字节/秒(B/s)为单位。端口和总线在计算机图形架构中很重要，简单地说，因为它们将不同的构建块粘在一起。同样重要的是，带宽是一种稀缺资源，因此在构建图形系统之前必须进行仔细的设计和分析。由于端口和总线都提供数据传输能力，端口通常被称为总线，这是我们在这里要遵循的约定。</strong></p>
<p><strong>对于许多GPU来说，在图形加速器上有专用的GPU内存是很常见的，这种内存通常被称为显存。访问这种内存通常比让GPU通过总线访问系统内存要快得多，例如，PC上使用的PCI Express (PCIe)。16通道PCIe v3双向带宽为15.75 GB/s, PCIe v4双向带宽为31.51 GB/s。然而，Pascal架构的显存(GTX 1080)提供320gb /s。</strong></p>
<p><strong>传统上，纹理和渲染目标存储在视频内存中，但它也可以存储其他数据。场景中的许多物体在帧与帧之间并没有明显的形状变化。即使是一个人类角色，通常也会使用一组不变的网格进行渲染，这些网格在关节处使用GPU端顶点混合。对于这种类型的数据，纯粹通过建模矩阵和顶点着色程序进行动画，通常使用静态顶点和索引缓冲区，它们被放置在视频内存中。这样做可以让GPU快速访问。对于每一帧由CPU更新的顶点，将使用动态顶点和索引缓冲区，这些缓冲区被放置在可以通过总线(如PCI Express)访问的系统内存中。PCIe的一个很好的特性是查询可以流水线化，这样就可以在返回结果之前请求多个查询。</strong></p>
<p><strong>大多数游戏控制台，例如所有的xbox和PLAYSTATION 4，使用统一的内存架构(UMA)，这意味着图形加速器可以使用主机内存的任何部分的纹理和不同类型的缓冲区。CPU和图形加速器使用相同的内存，因此也使用相同的总线。这显然不同于使用专用显存。Intel还使用了UMA，这样CPU内核和GEN9图形架构之间就可以共享内存，如下图所示。然而，并不是所有的缓存都是共享的。图形处理器有自己的一组L1缓存、L2缓存和L3缓存。最后一级缓存是内存层次结构中的第一个共享资源。对于任何计算机或图形架构来说，拥有一个缓存层次结构是很重要的。如果在访问中存在某种局部性，那么这样做可以减少对内存的平均访问时间。在下一节中，我们将讨论GPU的缓存和压缩。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116143053.png" class="" title="image-20211116143053">

<p>英特尔系统芯片(SoC) Gen9图形架构与CPU核和共享内存模型的内存架构的简化视图。请注意，最后一级缓存(llc)是在图形处理器和CPU内核之间共享的。</p>
<h2 id="Caching-and-Compression-缓存与压缩"><a href="#Caching-and-Compression-缓存与压缩" class="headerlink" title="Caching and Compression 缓存与压缩"></a>Caching and Compression 缓存与压缩</h2><p><strong>缓存位于每个GPU的几个不同部分，但它们的架构不同，我们将在23.10节中看到。通常，向体系结构中添加缓存层次结构的目标是通过利用内存访问模式的局域性来减少内存延迟和带宽使用。也就是说，如果GPU访问一个项目，它很可能会很快访问这个相同的或附近的项目。大多数缓冲区和纹理格式以平铺格式存储，这也有助于增加局部性。假设一条高速缓存线由512位组成，即64字节，而当前使用的颜色格式每像素使用4B。一个设计选择便是将所有像素存储在64B的4 × 4区域(也称为贴图)中。也就是说，整个颜色缓冲将被分割成4 × 4的贴图。一个平铺也可以跨越几条高速缓存线。</strong></p>
<p><strong>为了获得一个高效的GPU架构，我们需要在所有方面都工作以减少带宽的使用。大多数GPU都包含硬件单元，用于动态压缩和解压缩渲染目标，例如，图像正在被渲染。重要的是要认识到这些类型的压缩算法是无损的;也就是说，总是可以精确地再现原始数据。这些算法的核心是我们所说的贴图表，它为每个贴图存储额外的信息。这可以存储在芯片上或通过内存层次结构通过缓存访问。这两种系统的框图如下图所示。一般来说，相同的设置可以用于深度、颜色和模板压缩，有时需要进行一些修改。平铺表中的每个元素存储帧缓冲区中像素平铺的状态。每个贴图的状态可以被压缩、未压缩或清除(后面将讨论)。一般来说，也可以有不同类型的压缩块。例如，一种压缩模式可能压缩到25%，另一种压缩到50%。重要的是要认识到压缩的级别取决于GPU可以处理的内存传输的大小。在特定的架构中，最小的内存传输是32B。如果贴图大小被选择为64B，那么它只能压缩到50%。然而，使用128B的贴图大小，可以压缩到75% (96 B)， 50% (64 B)和25% (32 B)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116143444.png" class="" title="image-20211116143444">

<p>GPU中压缩和缓存渲染目标的硬件技术的框图。左:后缓存压缩，压缩/解压硬件单元位于缓存之后(以下)。右:预缓存压缩，压缩/解压硬件单元位于缓存之前(上面)。</p>
<p><strong>平铺表也经常用于实现渲染目标的快速清除。当系统发出对呈现目标的清除时，表中每个tile的状态都被设置为cleared，并且帧缓冲区本身不受影响。当访问渲染目标的硬件单元需要读取被清除的渲染目标时，解压单元首先检查表中的状态，看看tile是否被清除。如果是这样，渲染目标贴图将被放置在缓存中，所有值都设置为clear值，而不需要读取和解压缩实际的渲染目标数据。就这样，获得了渲染目标本身在清除过程中被最小化，这节省了带宽。如果状态未被清除，则必须读取该贴图的渲染目标。瓦片存储的数据被读取，如果被压缩，则在发送之前通过解压缩器传递。</strong></p>
<p><strong>当访问渲染目标的硬件单元完成了写新值，并且贴图最终从缓存中被驱逐，它被发送到压缩器，在那里尝试压缩它。如果有两种压缩模式，两种都可以尝试，并且使用能压缩最少位元的瓦片的模式。由于API需要无损的呈现目标压缩，所以如果所有压缩技术都失败了，就需要使用未压缩的数据。这也意味着无损渲染目标压缩永远不能在实际渲染目标中减少内存使用——这种技术只能减少内存带宽的使用。如果压缩成功，则将瓦片的状态设置为已压缩，并以压缩形式发送信息。否则，它将以未压缩的方式发送，并且状态设置为未压缩。</strong></p>
<p><strong>请注意，压缩机和解压单元可以在缓存之后(称为后缓存)或在缓存之前(预缓存)，如上图所示。预缓存压缩可以大幅增加有效缓存的大小，但通常也会增加系统的复杂度。对于压缩深度和颜色有具体的算法。后者包括对有损压缩的研究，然而，在我们所知的任何硬件中都没有这种研究。大多数算法编码一个锚值，它表示平铺中的所有像素，然后根据锚值以不同的方式编码差异。对于深度，通常存储一组平面方程或使用差分技术，这两种方法都能得到很好的结果，因为深度在屏幕空间中是线性的。</strong></p>
<h2 id="Color-Buffering-颜色缓存"><a href="#Color-Buffering-颜色缓存" class="headerlink" title="Color Buffering 颜色缓存"></a>Color Buffering 颜色缓存</h2><p><strong>使用GPU进行渲染需要访问几种不同的缓冲区，例如颜色、深度和模板缓冲区。请注意，尽管它被称为“颜色”缓冲区，但任何类型的数据都可以在其中呈现和存储。</strong></p>
<p><strong>根据表示颜色的字节数，颜色缓冲区通常有几种颜色模式。这些模式包括:</strong></p>
<pre><code>**•高颜色- 2字节/像素，其中15或16位用于颜色，分别提供32,768或65,536种颜色。**

**•真颜色或RGB颜色，每像素3或4字节，其中24位用于颜色，提供16777,216≈1680万种不同的颜色。**

**•深颜色——每像素30、36或48位，能提供至少10亿种不同的颜色。**
</code></pre>
<p><strong>高颜色模式有16位的颜色分辨率。通常情况下，这个数量会被分成至少5个比特(红色、绿色和蓝色)，每个颜色通道提供32个关卡。</strong></p>
<p><strong>这就剩下一个比特，通常给绿色通道，导致5-6-5分割。选择绿色通道是因为它对眼睛的亮度影响最大，因此需要更高的精度。高色彩比真实和深颜色有速度优势。这是因为每个像素2个字节的内存访问速度通常比每个像素3个或更多字节的内存访问速度更快。也就是说，高颜色模式的使用在这一点上是相当罕见的。每个通道中只有32或64个颜色级别，就可以很容易地分辨相邻颜色级别的差异。这个问题有时被称为条带化或分割化。人类视觉系统由于一种被称为马赫带的感知现象而进一步放大了这些差异。参见下图。在抖动中，相邻的水平被混合在一起，通过交换空间分辨率来增加有效的颜色分辨率，可以减少效果。即使在24位显示器上，渐变的条带也很明显。向帧缓冲区图像添加噪声可以用来掩盖这个问题。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116161023.png" class="" title="image-20211116161023">

<p>当矩形从白色渐变到黑色时，条纹就出现了。尽管32个灰度条都有一个固定的强度级别，但由于马赫波段错觉，每个灰度条在左边看起来较暗，在右边看起来较浅。</p>
<p><strong>真彩色使用24位RGB颜色，每个颜色通道1字节。在PC系统上，顺序有时被反转为BGR。在内部，这些颜色通常使用每像素32位存储，因为大多数内存系统都优化了访问4字节元素。在一些系统中，额外的8位也可以用来存储alpha通道，给像素一个RGBA值。24位颜色(无alpha)表示也称为打包像素格式，与32位未打包像素格式相比，它可以节省帧缓冲区内存。对于实时渲染来说，使用24位颜色几乎总是可以接受的。它仍然有可能看到颜色的带状，但比只有16位的可能性要小得多。</strong></p>
<p><strong>对于RGB颜色，深颜色使用30,36或48位。例如，10位、12位或16位每个通道。如果加上alpha，这些数字增加到40/48/64。HDMI 1.3支持所有30/36/48模式，DisplayPort标准也支持每通道最多16位。</strong></p>
<p><strong>如23.5节所述，颜色缓冲区经常被压缩和缓存。此外，在23.10节的每个案例研究中，将传入的片段数据与颜色缓冲进行进一步描述。混合由光栅操作(ROP)单元处理，每个ROP通常连接到内存分区，例如使用广义棋盘模式。接下来我们将讨论视频显示控制器，它采用一个彩色缓冲并使其出现在显示器上。然后检查单缓冲、双缓冲和三缓冲。</strong></p>
<h3 id="Video-Display-Controller-视频显示控制器"><a href="#Video-Display-Controller-视频显示控制器" class="headerlink" title="Video Display Controller 视频显示控制器"></a>Video Display Controller 视频显示控制器</h3><p><strong>在每个GPU中，都有一个视频显示控制器(VDC)，也称为显示引擎或显示界面，它负责在显示器上显示一个颜色缓冲。它是GPU中的一个硬件单元，可以支持多种接口，如高清多媒体接口(HDMI)、显示端口(DisplayPort)、数字可视接口(DVI)、视频图形阵列(VGA)等。要显示的颜色缓冲可能位于与CPU用于其任务相同的内存中，在专用的帧缓冲内存中，或在显存中，后者可以包含任何GPU数据，但CPU不能直接访问。每个接口都使用其标准协议来传输颜色缓冲、计时信息，有时甚至是音频。VDC还可以执行图像缩放、降噪、组成多个图像源和其他功能。</strong></p>
<p><strong>显示器，例如LCD，更新图像的速率通常在每秒60到144次(赫兹)之间。这也称为垂直刷新率。大多数观众注意到频率低于72赫兹的闪烁。有关这个主题的更多信息，请参阅12.5节。</strong></p>
<p><strong>监视器技术已经在几个方面取得了进步，包括刷新率、每个组件的位、色域和同步。刷新率过去是60hz，但120hz正变得越来越常见，高达600hz是可能的。为了获得较高的刷新率，图像通常会被显示多次，有时还会插入黑色帧，以最小化由于在帧显示期间眼睛移动而产生的模糊伪影。显示器也可以有超过8位每通道，和HDR显示器可能是下一个重要的显示技术。每个通道可以使用10位或更多。杜比拥有HDR显示技术，使用低分辨率的LED背光阵列来增强其LCD显示器。这样做可以使它们的显示器亮度是普通显示器的10倍，对比度是普通显示器的100倍。更宽色域的显示器也变得越来越普遍。它们可以显示更广泛的颜色范围，通过使纯光谱色调变得可代表，例如，更生动的绿色。有关色域的更多信息，请参阅第8.1.3节。</strong></p>
<p><strong>为了减少撕裂效应，公司开发了自适应同步技术，如AMD的FreeSync和NVIDIA的G-sync。这里的想法是调整显示的更新速率以适应GPU可以产生的结果，而不是使用固定的预定速率。例如，如果一帧渲染需要10毫秒，而下一帧渲染需要30毫秒，那么显示的图像更新将在每个图像完成渲染后立即开始。使用这种技术，渲染看起来更加流畅。此外，如果图像没有更新，那么颜色缓冲就不需要发送到显示器，这样可以节省电力。</strong></p>
<h3 id="Single-Double-and-Triple-Buffering-单、双、三次缓冲"><a href="#Single-Double-and-Triple-Buffering-单、双、三次缓冲" class="headerlink" title="Single, Double, and Triple Buffering 单、双、三次缓冲"></a>Single, Double, and Triple Buffering 单、双、三次缓冲</h3><p><strong>在2.4节中，我们提到了双重缓冲确保图像在渲染完成之前不会显示在显示器上。在这里，我们将描述单缓冲区、双缓冲区甚至三缓冲区。</strong></p>
<p><strong>假设我们只有一个缓冲区。这个缓冲区必须是当前显示在显示器上的那个。当绘制一个帧的三角形时，随着显示器刷新，越来越多的三角形会出现——这是一种不令人信服的效果。即使我们的帧速率等于监视器的更新速率，单缓冲区也有问题。如果我们决定清除缓冲区或绘制一个大三角形，那么当视频显示控制器传输正在绘制的颜色缓冲区区域时，我们将能够简要地看到颜色缓冲区的实际部分变化。有时称为撕裂，因为显示的图像看起来就像被简单地撕成两半，这不是实时图形的理想特性。在一些古老的系统上，比如Amiga，你可以测试光束的位置，从而避免在那里绘制，从而允许单缓冲区工作。现在，单缓冲区很少被使用，除了虚拟现实系统，在虚拟现实系统中，“竞速波束”可能是一种减少延迟的方法。</strong></p>
<p><strong>为避免撕裂问题，常用双缓冲。完成后的图像显示在前缓冲区中，而屏幕外的后缓冲区包含当前正在绘制的图像。后缓冲和前缓冲然后由图形驱动程序交换，通常是在整个图像被转移到显示器之后，以避免撕裂。交换通常是通过交换两个颜色缓冲指针来完成的。对于CRT显示器，这个事件被称为垂直回描，在此期间的视频信号被称为垂直同步脉冲，或简称vsync。对于液晶显示器来说，光束没有物理回描，但我们使用相同的术语来表示整个图像刚刚被转移到显示器上。在渲染完成后立即交换前面和后面的缓冲区对于绘制系统的基准测试是有用的，并且在许多应用中也被使用，因为它最大化了帧率。在垂直同步上不进行更新也会导致撕裂，但是因为有两个完全形成的图像，所以工件并不像单个缓冲那样糟糕。在交换之后，(新的)back缓冲区是图形命令的接收方，而新的front缓冲区则显示给用户。这个过程如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116161602.png" class="" title="image-20211116161602">

<p>对于单个缓冲(顶部)，前端缓冲总是显示。对于双缓冲(中间)，第一个缓冲区0在前面，缓冲区1在后面。然后他们从前面到后面，反之亦然。三重缓冲(底部)也有一个挂起的缓冲区。在这里，首先清除一个缓冲区并开始呈现它(pending)。其次，系统继续使用缓冲区进行渲染，直到图像完成(返回)。最后，显示缓冲区(前面)。</p>
<p><strong>可以用第二个后置缓冲区(我们称之为挂起缓冲区)来扩充双缓冲。这被称为三重缓冲。挂起缓冲区类似于后置缓冲区，因为它也在屏幕外，并且可以在显示前置缓冲区时对其进行修改。挂起缓冲区成为三个缓冲区循环的一部分。在一帧期间，等待的缓冲区可以被访问。在下一次交换时，它成为后置缓冲区，呈现在这里完成。然后它就变成了前台缓冲区并显示给查看器。在下一次交换时，缓冲区再次变成挂起缓冲区。在上图的底部可以看到这一过程。</strong></p>
<p><strong>三倍缓冲比双缓冲有一个主要优点。使用它，系统可以在等待垂直回描时访问挂起的缓冲区。使用双缓冲，在等待垂直回描以便进行交换时，构造必须简单地保持等待。这是因为前缓冲区必须显示给查看器，而后缓冲区必须保持不变，因为其中有一个完成的图像，等待显示。三重缓冲的缺点是延迟增加到一个完整的帧。这种增加延迟了对用户输入的反应，如按键、鼠标或操纵杆移动。控件可能感觉迟钝，因为这些用户事件在挂起缓冲区中的呈现开始后被延迟。</strong></p>
<p><strong>理论上，可以使用三个以上的缓冲区。如果计算一帧的时间变化很大，那么更多的缓冲区会带来更多的平衡和更高的总体显示率，但代价是更多的潜在延迟。概括地说，多重缓冲可以被认为是一个循环结构。有一个呈现指针和一个显示指针，每个指针都指向不同的缓冲区。呈现指针引导显示指针，当当前呈现缓冲区的计算完成时，将移动到下一个缓冲区。唯一的规则是显示指针不应该与呈现指针相同。</strong></p>
<p><strong>实现PC图形加速器附加加速的相关方法是使用SLI模式。早在1998年，3dfx就使用SLI作为扫描线交错的缩写，即两个图形芯片组并行运行，一个处理奇数扫描线，另一个处理偶数扫描线。NVIDIA(收购了3dfx的资产)使用这个缩写来实现一种完全不同的连接两个(或更多)显卡的方式，称为可扩展连接接口。AMD将其称为“CrossFire x”。这种并行方式可以将屏幕分割成两个(或更多)水平部分(每张卡片一个)，或者让每张卡片完全呈现自己的帧，交替输出。还有一个模式，允许卡片加速反锯齿相同的帧。最常见的用法是让每个GPU渲染一个单独的帧，称为交替帧渲染(AFR)。虽然这个方案听起来似乎应该增加延迟，但它往往收效甚微或根本没有效果。假设一个GPU系统的渲染速度是10fps。如果GPU是瓶颈，两个使用AFR的GPU可以以20 FPS渲染，甚至4个以40 FPS渲染。每个GPU渲染帧需要相同的时间，所以延迟不一定会改变。</strong></p>
<p><strong>屏幕分辨率继续增加，给基于逐像素采样的渲染器带来了严峻的挑战。保持帧率的一种方法是自适应地改变屏幕和表面上的像素着色率。</strong></p>
<h2 id="Depth-Culling-Testing-and-Buffering-深度剔除、测试和缓存"><a href="#Depth-Culling-Testing-and-Buffering-深度剔除、测试和缓存" class="headerlink" title="Depth Culling, Testing, and Buffering 深度剔除、测试和缓存"></a>Depth Culling, Testing, and Buffering 深度剔除、测试和缓存</h2><p><strong>在本节中，我们将讨论与深度相关的所有内容，包括分辨率、测试、剔除、压缩、缓存、缓冲和early-z。</strong></p>
<p><strong>深度分辨率很重要，因为它有助于避免渲染错误。例如，假设你制作了一张纸的模型，并把它放在书桌上，稍稍高于书桌表面。通过计算桌子和纸的z-深度的精度极限，桌子可以在纸的各个点戳穿。这个问题有时被称为z-fighting。请注意，如果把纸放在与桌子完全相同的高度，即。如果纸和桌子是共面的，那么如果没有关于它们关系的额外信息，就不会有正确的答案。这个问题是由于建模不好，不能用更好的z精度来解决。</strong></p>
<p><strong>正如我们在2.5.2节中看到的，z缓冲区(也称为深度缓冲区)可以用来解析可见性。这种缓冲区通常每个像素(或样本)有24位或32位，可以使用浮点或定点表示。对于正交观察，距离值与z值成正比，因此得到均匀分布。然而，就透视来看，分布是不均匀的，正如我们在99-102页看到的。在应用了透视变换(式4.74或4.76)之后，需要对w分量进行除法(式4.72)。深度分量就变成了pz =qz/ qw，其中q是乘以投影矩阵后的点。对于定点表示，值pz =qz/ qw 从它的有效范围(例如，DirectX的[0,1])映射到整数范围[0,2^b−1]，并存储在z-buffer中，其中b是比特数。有关深度精度的更多信息，请参阅第99-102页。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116162102.png" class="" title="image-20211116162102">

<p>一个可能实现的深度管线，其中z-interpolate简单地计算深度值使用插值。</p>
<p><strong>硬件深度管线如上图所示。该管道的主要目标是根据深度缓冲区测试光栅化原语时生成的每个传入深度，并可能将传入深度写入深度缓冲区碎片通过深度测试。与此同时，这条管道线需要高效。图的左边部分从粗光栅化开始，即在平铺层面上的光栅化(第23.1节)。此时，只有与原语重叠的贴图才会进入下一个阶段，即HiZ单元，在这里执行z-culling技术。</strong></p>
<p><strong>HiZ单元从一个称为粗深度测试的块开始，这里通常执行两种类型的测试。我们从描述z开始max-culling是对Greene的分级z-buffering算法的简化，见第19.7.2节。这个想法是存储最大值，称为zmax，每个贴图的所有深度。贴图大小与建筑有关，但通常使用8 × 8像素。这些zmax-值可以存储在固定的片上内存或通过高速缓存访问。在上图中，我们将其称为HiZ缓存。简单地说，我们想测试三角形是否完全闭塞在贴图中。为了做到这一点，我们需要计算最小的z值，zmin^tri，在瓷砖内部的三角形上。如果 zmin^tri  &gt;zmax，它可以保证三角形被之前渲染的几何体遮挡。可以终止对贴图中的三角形的处理，这节省了逐像素深度测试。注意，它不保存任何像素着色器执行，因为每个样本深度测试将消除碎片，隐藏在管线稍后。在实践中，我们无法计算出zmin^tri的准确值，因此，取而代之的是一个保守的估计。有几种不同的计算 zmin^tri 的方法是可能的，每一种都有其优缺点:</strong></p>
<pre><code>**1.可以使用三角形三个顶点的最小z值。这并不总是准确的，但是有很少的开销。**

 **2.使用三角形的平面方程计算瓦片四个角的z值，并使用最小值。**
</code></pre>
<p><strong>将这两种策略相结合，可获得最佳的剔除性能。这是通过取两个zmin 值中较大的那个来完成。</strong></p>
<p><strong>另一种粗深度试验是zmin-culling，其思想是存储zmin 所有像素在一个平铺。它有两种用途。首先，它可以用来避免z-buffer读取。如果正在渲染的三角形绝对位于之前渲染过的所有几何图形的前面，则没有必要进行逐像素深度测试。在某些情况下，可以完全避免z-buffer读取，从而进一步提高性能。其次，它可以用于支持不同类型的深度测试。对zmax-culling方法，我们假设标准的“小于”深度测试。然而，如果剔除可以与其他深度测试一起使用，并且如果zmin 和zmax 都可用，所有深度测试都可以使用此筛选过程支持。Andersson博士论文中有关于深度管道的更详细的硬件描述。</strong></p>
<p><strong>上图中的绿色框涉及更新tile的zmax 和zmin 值的不同方法。如果一个三角形覆盖了整个贴图，则可以直接在HiZ单元中进行更新。否则，需要读取整个贴图的每个样本深度，并将其降低到最小和最大值，然后发送回HiZ单元，这将带来一些延迟。Andersson等人提出了一种执行方法这没有来自深度缓存的更昂贵的反馈，仍然能够保持大部分的淘汰效率。</strong></p>
<p><strong>对于通过粗深度测试的瓦片，将确定像素或样本覆盖率(使用第23.1节中描述的边缘方程)，并计算每个样本深度(上图中称为z-interpolate)。这些值被转发到深度单元，如图所示。根据API的描述，像素着色器的评估应该遵循。然而，在某些情况下，可以在不改变预期行为的情况下执行一个名为early-z或early depth的额外测试。Early-z实际上只是在像素着色器之前执行的每个样本深度测试，并且被遮挡的碎片被丢弃。这个过程因此避免了不必要的像素着色器的执行。早期z测试经常与z筛选混淆，但它是由完全独立的硬件执行的。任何一种技术都可以单独使用。</strong></p>
<p><strong>所有的zmax-culling,zmin-culling和early-z在很多情况下会被GPU自动使用。然而，如果像素着色器写入自定义深度，使用丢弃操作，或写入一个值到无序访问视图，这些必须被禁用。如果early-z不能使用，那么深度测试将在像素着色器之后进行(称为后期深度测试)。</strong></p>
<p><strong>在较新的硬件上，可以执行原子的读-修改-写操作，从着色器加载和存储图像。在这些情况下，如果您知道这样做是安全的，您可以显式地启用early-z并覆盖这些约束。当像素着色器输出自定义深度时，可以使用的另一个特征是保守深度。在这种情况下，如果程序员保证自定义深度大于三角形深度，就可以启用early-z。对于这个例子，zmax-也可以启用淘汰，但不是early-z和zmin-culling。</strong></p>
<p><strong>一如既往，遮挡剔除得益于从正面到背面的渲染。另一种名称和意图相似的技术是z-prepass。其理念是，程序员首先渲染场景，同时只写入深度，禁用像素着色，并写入颜色缓冲区。当渲染随后的通道时，会使用“相等”测试，这意味着只有最前面的表面会被着色，因为z缓冲区已经被初始化了。看到18.4.5节。</strong></p>
<p><strong>为了结束本节，我们将简要描述depth管道的缓存和压缩，如上图右下角所示。一般的压缩系统类似于第23.5节中描述的系统。每个贴图可以压缩到一些选择的大小，并且总是有一个回退到未压缩的数据，当压缩未能达到任何选择的大小时使用。在清除深度缓冲区时，使用“快速清除”可以节省带宽占用。由于深度在屏幕空间中是线性的，典型的压缩算法要么存储高精度的平面方程，要么使用delta编码的差分技术，要么使用锚定方法。平铺表和HiZ缓存可以完全存储在片上缓冲区中，或者它们可以通过内存层次结构的其余部分进行通信，就像深度缓存一样。在芯片上存储是昂贵的，因为这些缓冲区需要足够大来处理支持的最大分辨率。</strong></p>
<h2 id="Texturing-纹理"><a href="#Texturing-纹理" class="headerlink" title="Texturing 纹理"></a>Texturing 纹理</h2><p><strong>虽然纹理操作，包括抓取、过滤和解压缩，当然可以在GPU多处理器上运行的纯软件中实现，但已有研究表明，用于纹理的固定功能硬件的速度可以提高40倍。纹理单元执行纹理格式的寻址、过滤、箝位和解压缩(第6章)。它与纹理缓存一起使用以减少带宽的使用。我们首先讨论过滤以及它对纹理单元的影响。</strong></p>
<p><strong>为了能够使用缩小过滤器，如mipmapping和各向异性过滤，纹理坐标在屏幕空间的导数是必需的。也就是说，为了计算纹理级别λ，我们需要∂u/∂x，∂v/∂x，∂u/∂y，和∂v/∂y。它们告诉我们碎片所代表的纹理区域或功能的范围。如果从顶点着色器传递的纹理坐标被用来直接访问纹理，那么可以分析地计算导数。如果使用某些函数对纹理坐标进行转换，例如(u′, v′)= (cosv, sinu)，那么用解析法求导数就变得更复杂了。然而，使用链式法则或符号微分法仍然是可能的。尽管如此，这些方法都没有被图形硬件使用，因为情况可能是任意复杂的。想象计算一个表面上的反射，使用一个环境地图，法线被凹凸贴图。这是很难分析计算，例如，反射向量的导数反弹一个法线地图，然后用于访问环境地图。因此，导数通常是用x和y在四倍基i上的有限差分进行数值计算的。如，除以2×2像素。这也是为什么GPU架构专注于调度四边形的原因。</strong></p>
<p><strong>一般来说，导数计算是在幕后进行的，即它们对用户是隐藏的。实际的实现通常是在一个四轴上使用跨车道指令(shuffle/swizzle)，这样的指令可以被编译器插入。有些GPU使用固定功能的硬件来计算这些导数。对于如何计算衍生品并没有确切的规范。一些常用的方法如下图所示。OpenGL 4.5和DirectX 11都支持粗函数和细函数。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116162949.png" class="" title="image-20211116162949">

<p>说明如何计算导数。箭头表示计算箭头结束处的像素与开始处的像素之间的差异。例如，左上角的水平差被计算为右上角像素减去左上角像素。对于粗导数(左)，一个水平差和一个垂直差用于四元组内的所有四个像素。对于精细的导数(右)，我们使用最接近像素的差异。</p>
<p><strong>所有GPU都使用纹理缓存来减少纹理的带宽占用。有些架构使用专用缓存来纹理，甚至使用两个专用级别的纹理缓存，而其他架构则在所有类型的访问(包括纹理)之间共享缓存。通常使用一个小的片上存储器(通常是SRAM)来实现纹理缓存。这个缓存存储最近纹理读取的结果，访问非常快。替换策略和大小依赖于体系结构。如果相邻的像素需要访问相同或接近位置的texels，它们很可能在缓存中找到这些。正如在第23.4节中提到的，内存访问通常以平铺方式完成，所以像素不是以扫描线顺序存储，而是以小的平铺存储，例如，4 × 4像素，这提高了效率，因为一个平铺Texels是拼凑在一起的。以字节为单位的平铺大小通常与缓存行大小相同，例如，64字节。另一种存储纹理的方法是使用混合图案。假设纹理坐标已经被转换为定点数字:(u, v)，其中每个u和v都有n位。u中编号为i的位记为ui．然后将(u, v)重映射到一个混合的纹理地址A为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116163113.png" class="" title="image-20211116163113">

<p><strong>其中B是纹理的基址，T是一个texel所占用的字节数。这种重新映射的好处是它会产生如下图所示的texel顺序。可以看出，这是一条空间填充曲线，称为莫顿序列（Morton sequence），它可以提高相干性。在这种情况下，曲线是二维的，因为纹理通常也是。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116163209.png" class="" title="image-20211116163209">

<p>纹理混合增加texel内存访问的一致性。注意，这里的texel大小是4字节，texel地址显示在每个texel的左上角。</p>
<p><strong>纹理单元还包含自定义硅来解压几种不同的纹理格式(章节6.2.6)。与软件实现相比，在固定功能的硬件中实现这些功能通常要高效许多倍。注意，当使用纹理作为渲染目标和纹理映射时，会出现其他压缩机会。如果颜色缓冲的压缩是启用的(章节23.5)，那么当访问这样的渲染目标作为纹理时，有两个设计选项。当渲染目标完成渲染后，一个选项是将整个渲染目标从其颜色缓冲压缩格式中解压缩，并将其未压缩存储以供后续纹理访问。第二种选择是在纹理单元中添加硬件支持，以解压颜色缓冲压缩格式。后者是更有效的选择，因为渲染目标可以保持压缩，甚至在访问期间作为纹理。更多关于缓存和压缩的信息可以在23.4节找到。</strong></p>
<p><strong>Mipmapping对纹理缓存局部性很重要，因为它强制一个最大像素比。当遍历一个三角形时，每个新像素代表纹理空间中大约一个像素的一个步骤。Mipmapping是渲染中为数不多的同时提高视觉效果和性能的技术之一。</strong></p>
<h2 id="Architecture-架构"><a href="#Architecture-架构" class="headerlink" title="Architecture 架构"></a>Architecture 架构</h2><p><strong>获得更快图像的最佳方法是利用并行性，这几乎可以在GPU的所有阶段实现。这个想法是同时计算多个结果，然后在稍后的阶段合并这些结果。通常，并行图形体系结构的外观如下图所示。应用程序将任务发送给GPU，经过一些调度后，在几个几何单元中并行地开始几何处理。从几何处理的结果被转发到一组栅格化单元，执行栅格化。然后由一组像素处理单元并行地执行像素着色和混合。最后，生成的图像被发送到显示器以供查看。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116163449.png" class="" title="image-20211116163449">

<p>一种高性能并行计算机图形体系结构的通用体系结构，由几个几何单元(G)、光栅化单元(R)和像素处理单元(P)组成。</p>
<p><strong>对于软件和硬件，重要的是要认识到，如果您的代码或硬件有一个串行部分，它将限制可能的总体性能改进。这由阿姆达尔定律表示，即，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116163531.png" class="" title="image-20211116163531">

<p><strong>其中s是程序/硬件的串行百分比，因此1 - s是可用于并行化的百分比。此外，p是通过并行化程序或硬件可以实现的最大性能改进因子。例如，如果我们最初有一个多处理器，然后增加了三个，那么p = 4。这里，a(s, p)是你从改进中得到的加速因子。如果我们有一个体系结构，比如说，10%是序列化的，也就是说。s = 0.1，我们改进了我们的架构，使其余(非串行)部分可以改进20倍，则a = 1/(0.1 + 0.9/20)≈6.9。可以看到，我们没有得到20的加速，原因是代码/硬件的串行部分严重限制了性能。实际上，当p→∞时，a = 10。是把精力花在改进并行部分还是串行部分上并不总是很清楚，但在并行部分得到实质性改进之后，串行部分将更加限制性能。</strong></p>
<p><strong>对于图形架构，多个结果是并行计算的，但是绘制调用中的原语应该按照CPU提交的顺序进行处理。因此，必须进行某种排序，以便并行单元一起呈现用户想要的图像。具体来说，需要从模型空间到屏幕空间进行排序(章节2.3.1和2.4)。应该注意的是，几何单位和像素处理单位可以映射到相同的单位，即统一的运算器。我们案例研究部分的所有架构都使用统一着色器架构(章节23.10)。即使是这样，理解排序发生的位置也是很重要的。我们提出了并行架构的分类。排序可以发生在管线中的任何地方，这将在并行架构中产生四种不同的工作分配类别，如下图所示。它们被称为优先排序、中间排序、最后排序片段和最后排序图像。请注意，这些架构导致了在GPU的并行单元之间分配工作的不同方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116163714.png" class="" title="image-20211116163714">

<p>并行图形架构的分类。A是应用，G是几何单位，R是光栅化单位，P是像素处理单位。从左到右，体系结构分别是排序优先、排序中间、排序最后的片段和排序最后的映像。</p>
<p><strong>基于排序优先的体系结构在几何阶段之前对原语进行排序。策略是将屏幕划分为一组区域，区域内的原语被发送到“拥有”该区域的完整管道。参见下图。原语的初始处理足以知道它需要发送哪个区域——这就是排序步骤。排序优先是对一台机器探索最少的架构。这种方案确实适用于驱动由多个屏幕或投影仪组成的大屏幕系统，因为每个屏幕都有一台计算机。一个名为Chromium的系统已经开发出来，它可以使用工作站集群实现任何类型的并行绘制算法。例如，排序优先和排序最后可以实现较高的渲染性能。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116163827.png" class="" title="image-20211116163827">

<p>排序优先将屏幕分割成多个单独的块，并为每个块分配一个处理器，如下所示。然后将原语发送给它们重叠的处理器。这与排序中间架构形成了对比，后者需要在几何处理完成后对所有三角形进行排序。只有在所有三角形都被排序后，才能开始逐像素光栅化。</p>
<p><strong>马里建筑(章节23.10.1)属于中等类型。几何处理单元被赋予大约相同数量的几何处理。</strong></p>
<p><strong>然后，转换后的几何图形被分类为不重叠的矩形，称为瓷砖，它们一起覆盖整个屏幕。注意，转换后的三角形可能会与几个贴图重叠，因此可能会被几个光栅化器和像素处理单元处理。这里效率的关键是，每对光栅化和像素处理单元在芯片上都有一个瓦片大小的帧缓冲区，这意味着所有对帧缓冲区的访问都非常快。当所有的几何图形被分类到贴图时，每个贴图的栅格化和像素处理可以开始彼此独立。一些中间排序架构为不透明几何图形的每个tile执行z- preass，这意味着每个像素只着色一次。然而，并不是所有的排序中间架构都这样做。</strong></p>
<p><strong>最后排序片段体系结构在栅格化(有时称为片段生成)之后和像素处理之前对片段进行排序。一个例子是GCN架构，在第23.10.3节中描述。就像中间排序一样，原语尽可能均匀地分布在几何单元中。最后排序片段的一个优点是不会有任何重叠，这意味着生成的片段只被发送到一个像素处理单元，这是最优的。如果一个光栅化单元处理大三角形，而另一个处理小三角形，就会出现不平衡。</strong></p>
<p><strong>最后，最后排序图像结构经过像素处理后进行排序。如下图所示。这个体系结构可以看作是一组独立的管线。原语分布在管线中，每个管线呈现一个具有深度的图像。在最后的合成阶段，所有的图像都是根据它们的z-buffer进行合并。需要注意的是，最后排序的图像系统不能完全实现像OpenGL和DirectX这样的API，因为它们需要原语按发送的顺序排列。PixelFlow是最后排序图像架构的一个例子。PixelFlow架构也值得注意，因为它使用了延迟着色，这意味着它只着色可见的片段。但是，应该注意的是，由于管道末端占用了大量的带宽，目前的体系结构没有使用最后排序图像。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116164107.png" class="" title="image-20211116164107">

<p>在最后排序图像中，场景中的不同对象被发送到不同的处理器。当合成单独的渲染图像时，透明度很难处理，所以透明对象通常被发送到所有节点。</p>
<p><strong>对于大型平铺显示系统来说，纯最后排序图像方案的一个问题是，需要在渲染节点之间传输大量的图像和深度数据。Roth和Reiners通过使用每个处理器结果的屏幕和深度边界来优化数据传输和组成成本。</strong></p>
<p><strong>Eldridge等人提出了Pomegranate，一种到处排序的架构。简单地说，它在几何阶段和光栅单元(R’s)之间、R’s和像素处理单元(P’s)之间以及P’s和显示器之间插入排序阶段。因此，随着系统的扩展(即因为更多的管线被添加)。分拣阶段被实现为具有点对点链接的高速网络。仿真表明，随着管线的增加，性能几乎呈线性增长。</strong></p>
<p><strong>一个图形系统中的所有组件(主机、几何处理、光栅化和像素处理)连接在一起就构成了一个多处理系统。对于这样的系统，有两个众所周知的问题，并且几乎总是与多处理相关:负载平衡和通信。先进先出队列通常被插入到管道中的许多不同位置，以便作业可以排队，以避免管道的某些部分陷入停顿。例如，可以在几何图形和光栅化单元之间放置一个FIFO，这样，如果光栅化单元不能跟上几何图形单元的速度，例如，由于巨大的三角形大小，可以缓冲几何处理的三角形。</strong></p>
<p><strong>所描述的不同排序体系结构具有不同的负载平衡优点和缺点。查阅Eldridge的博士论文或Molnar等人的论文以获取更多信息。程序员也可以影响负载平衡;实现这一目标的技术将在第18章中讨论。如果总线的带宽过低，或者使用不明智，通信可能是一个问题。因此，设计一个应用程序的渲染系统，使瓶颈不发生在任何总线上，例如从主机到图形硬件的总线，是极其重要的。第18.2节介绍了检测瓶颈的不同方法。</strong></p>
<h2 id="Case-Studies-案例研究"><a href="#Case-Studies-案例研究" class="headerlink" title="Case Studies 案例研究"></a>Case Studies 案例研究</h2><p><strong>本节将介绍三种不同的图形硬件架构。首先展示的是ARM Mali G71彩虹桥架构，目标是移动设备和电视。接下来是英伟达的Pascal架构。最后，我们描述了AMD的GCN架构，称为Vega。</strong></p>
<p><strong>请注意，图形硬件公司的设计决策通常基于尚未构建的gpu的广泛软件模拟。也就是说，几个应用程序，例如游戏，通过它们的参数化模拟器运行几个不同的配置。例如，可能的参数是MPs的数量、时钟频率、缓存的数量、光栅引擎/tessellator引擎的数量和ROPs的数量。模拟用于收集有关性能、功率使用和内存带宽使用等因素的信息。在一天结束时，选择在大多数用例中工作得最好的可能配置，并根据该配置构建芯片。此外，模拟可能有助于发现体系结构中的典型瓶颈，然后可以解决这些瓶颈，例如增加缓存的大小。对于特定的GPU，不同的速度和单位数量的原因很简单，“它以这种方式工作得最好。”</strong></p>
<h3 id="Case-Study-ARM-Mali-G71-Bifrost-案例研究-ARM-Mali-G71彩虹桥"><a href="#Case-Study-ARM-Mali-G71-Bifrost-案例研究-ARM-Mali-G71彩虹桥" class="headerlink" title="Case Study: ARM Mali G71 Bifrost 案例研究:ARM Mali G71彩虹桥"></a>Case Study: ARM Mali G71 Bifrost 案例研究:ARM Mali G71彩虹桥</h3><p><strong>Mali产品线包括ARM的所有GPU架构，Bifrost是他们2016年推出的架构。这种架构的目标是移动和嵌入式系统，例如移动电话、平板电脑和电视。2015年，基于马里的GPU出货量为7.5亿台。由于其中许多都是由电池供电的，因此设计一个节能的建筑而不是只关注性能是很重要的。因此，使用排序中间体系结构是有意义的，在这种体系结构中，所有帧缓冲区访问都保存在芯片上，这降低了功耗。马里所有的建筑都是中间建筑，有时被称为瓦片建筑。GPU的高级概述如下图所示。可以看到，G71可以支持多达32个统一着色器引擎。ARM使用术语着色器核心而不是着色器引擎，但我们使用术语着色器引擎以避免与本章的其余部分混淆。一个着色器引擎能够一次执行12个线程的指令。，它有12个ALU。32个着色器引擎的选择是专门为G71，但架构规模超过32个引擎。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116164600.png" class="" title="image-20211116164600">

<p>Bifrost G71 GPU架构，可扩展到32个着色器引擎，每个着色器引擎如下图所示。</p>
<p><strong>驱动软件为GPU提供工作。作业管理器，即然后将工作分配给着色引擎。这些引擎通过GPU fabric连接，GPU fabric是一个总线，引擎可以在此总线上与GPU中的其他单元通信。所有内存访问都通过内存管理单元(MMU)发送，MMU将虚拟内存地址转换为物理地址。</strong></p>
<p><strong>着色器引擎的概述如下图所示。可以看到，它包含三个执行引擎，围绕着四边形执行着色。因此，它们被设计成SIMD宽度为4的小型通用处理器。每一个执行引擎包含4个融合乘加(FMA)单元，用于32位浮点数和4个32位加法器。这意味着有3 × 4个ALU，即每个着色器引擎有12条SIMD通道。用我们这里的术语来说，四轴曲相当于经线。例如，为了隐藏纹理访问的延迟，架构可以在每个着色器引擎中保持至少256个线程。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116164720.png" class="" title="image-20211116164720">

<p>彩虹桥着色器引擎架构，其中的瓦片内存是在芯片上，这使得快速的本地帧缓冲区访问。</p>
<p><strong>注意，着色器引擎是统一的，可以执行计算、顶点和像素着色等操作。执行引擎还包含对许多超越函数的支持，如正弦和余弦函数。此外，在使用16位浮点精度时，性能可达2倍。这些单元还支持绕过寄存器内容的情况下，当一个寄存器的结果只作为输入到后面的指令。这样可以节省电力，因为不需要访问注册文件。此外，当执行纹理或其他内存访问时，例如，单个四元组可以由四元组管理器切换进来，类似于其他架构如何隐藏此类操作的延迟。注意，这是在小粒度级别上发生的，交换4个线程而不是全部12个线程。加载/存储单元负责一般的内存访问、内存地址转换和一致缓存。属性单元处理属性索引和寻址。它将访问发送到加载/存储单元。变化单元执行变化属性的插值。</strong></p>
<p><strong>平铺架构(排序-中间)的核心思想是首先执行所有的几何处理，以便找到要渲染的每个原语的屏幕空间位置。同时，为帧缓冲区中的每个瓦片构建一个多边形列表，其中包含指向重叠瓦片的所有原语的指针。在这一步之后，重叠贴图的原语集就被知道了。因此，可以对平铺中的原语进行栅格化和着色，并将结果存储在片上平铺存储器中。当tile完成了它所有的原语渲染后，tile内存中的数据通过L2缓存写回外部内存。这减少了内存带宽的使用。然后下一个贴图被栅格化，以此类推，直到整个帧被渲染。第一个平铺架构是Pixel-Planes 5，该系统与马里架构有一些高层相似之处。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116164856.png" class="" title="image-20211116164856">

<p>说明几何图形如何流经彩虹桥建筑。顶点着色器由位置着色(被平铺使用)和变化着色(在平铺之后只在需要时执行)组成。</p>
<p><strong>上图可视化了几何处理和像素处理。可以看到，顶点着色器被分割成一个只执行位置着色的部分和另一个称为变化着色的部分，这是在平铺后完成的。与ARM以前的架构相比，这节省了内存带宽。执行装箱所需要的唯一信息是顶点的位置，用来确定一个原语覆盖了哪些块。下图所示的分层方式显示了执行分类的层单元。这有助于使装箱的内存占用更小，更可预测，因为它不再与原始大小成比例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116165004.png" class="" title="image-20211116165004">

<p>彩虹桥结构的分层层。在这个例子中，装箱是在三个不同的层次上完成的，每个三角形都被分配到与单个正方形重叠的层次上。</p>
<p><strong>当贴图完成场景中所有原语的分类后，就可以确切地知道哪些原语与某个tile重叠。因此，只要有可用的着色器引擎可以并行工作，其余的光栅化、像素处理和混合可以对任意数量的贴图并行执行。通常，一个平铺被提交给一个处理平铺中所有原语的着色器引擎。当这个工作完成了所有的瓷砖，它也可以开始与几何处理和下一帧的平铺。这个处理模型意味着在平铺体系结构中可能存在更多的延迟。</strong></p>
<p><strong>在这一点上，光栅化，像素着色器执行，混合和其他逐像素操作。平铺架构最重要的一个特性是，单个平铺的帧缓冲区(例如，包括颜色、深度和模板)可以存储在片上快速内存中，这里称为平铺内存。这是可以承受的，因为贴图很小(16 × 16像素)。当tile中的所有呈现完成后，tile的期望输出(通常是颜色，可能还有深度)被复制到与屏幕大小相同的芯片外帧缓冲区(在外部内存中)。这意味着在逐像素处理期间对帧缓冲区的所有访问实际上都是免费的。避免使用外部总线是非常可取的，因为这种使用带来了很高的能源成本。当将片内块内存的内容逐出片外帧缓冲区时，仍然可以使用帧缓冲区压缩。</strong></p>
<p><strong>彩虹桥支持像素本地存储(PLS)，这是一组通常支持排序-中间架构的扩展。使用PLS，可以让像素着色器访问帧缓冲区的颜色，从而实现自定义混合技术。相反，混合通常是使用API配置的，并且不能在其中编程像素着色器的方法。用户还可以使用贴图内存存储每个像素的任意固定大小的数据结构。这允许程序员有效地实现，例如，延迟着色技术。G缓冲(例如，法线，位置，和漫反射纹理)存储在PLS在第一个通过。第二次通过执行光照计算并在PLS中积累结果。第三次通过使用PLS中的信息来计算最终像素的颜色。请注意，对于单个tile，所有这些计算都是在整个tile内存保存在芯片上时进行的，这使得它非常快。</strong></p>
<p><strong>所有马里架构都是基于多重采样反锯齿(MSAA)设计的，他们实现了第143页描述的旋转网格超采样(RGSS)方案，每像素使用4个样本。排序-中间架构非常适合抗锯齿。这是因为过滤是在贴图离开GPU并被发送到外部内存之前完成的。因此，外部内存中的帧缓冲区只需要为每个像素存储一种颜色。一个标准体系结构需要一个四倍于此大小的帧缓冲区。对于平铺架构，您只需要将芯片上平铺缓冲区增加4倍，或者有效地使用更小的平铺(宽度和高度的一半)。</strong></p>
<p><strong>马里彩虹桥体系结构还可以选择性地选择在一批渲染原语上使用多重采样或超采样。这意味着更昂贵的超采样方法，即对每个样本执行像素着色器，可以在需要时使用。一个例子是用alpha映射渲染一个有纹理的树，在这里你需要高质量的采样以避免视觉工件。对于这些原语，可以启用超采样。当这种复杂的情况结束，需要渲染更简单的对象时，可以切换回使用更便宜的多次采样方法。该建筑还支持8×和16× MSAA。</strong></p>
<p><strong>Bifrost(以及之前称为Midgard的体系结构)还支持一种称为事务消除的技术。这个想法是为了避免场景中不随帧变化的部分从tile内存转移到芯片外内存。对于当前帧，当瓦片被逐出到芯片外帧缓冲区时，将为每个瓦片计算唯一的签名。这个签名是校验和的一种类型。对于下一帧，将为将要被驱逐的块计算签名。如果来自前一帧的签名与当前帧的特定贴图的签名相同，那么架构将避免将颜色缓冲区写入芯片外内存，因为正确的内容已经在那里了。这对于休闲手机游戏(游戏邦注:如《愤怒的小鸟》)尤其有用，因为在这类游戏中，每帧更新的场景比例较小。还要注意，这种类型的技术很难在最后排序架构上实现，因为它们不是按每个贴图操作的。G71还支持智能组合(smart composition)，即应用于用户界面组合的事务消除。它可以避免读取、合成和写入像素块，如果所有的源都与前一帧相同，并且操作相同。</strong></p>
<p><strong>低功耗的技术，如时钟门控和功率门控，也在这个体系结构中大量使用。这意味着管线中未使用或不活动的部分将被关闭或以较低的能耗保持闲置，以减少电力消耗。</strong></p>
<p><strong>为了减少纹理带宽，有一个纹理缓存，为ASTC和ETC提供了专用的解压单元。此外，压缩纹理以压缩的形式存储在缓存中，而不是解压纹理然后将texel放入缓存中。这意味着当请求一个texel时，硬件从缓存中读取块，然后动态地解压缩块的texel。这种配置增加了缓存的有效大小，从而提高了效率。</strong></p>
<p><strong>一般来说，瓦片架构的一个优点是，它天生就设计了瓦片的并行处理。例如，可以添加更多的着色器引擎，其中每个着色器引擎负责一次独立渲染到单个贴图。平铺架构的一个缺点是，整个场景数据需要发送到GPU进行平铺，处理的几何数据流输出到内存。一般来说，排序中间架构不是理想的处理几何放大，如应用几何着色器和镶嵌，因为更多的几何增加了内存传输的数量来回变换几何。对于马里架构，几何着色(章节18.4.2)和镶嵌都是在GPU上的软件中处理的，马里最佳实践指南建议永远不要使用几何着色器。对于大多数内容，中间排序体系结构在移动和嵌入式系统中工作得很好。</strong></p>
<h3 id="Case-Study-NVIDIA-Pascal-案例研究-NVIDIA-Pascal"><a href="#Case-Study-NVIDIA-Pascal-案例研究-NVIDIA-Pascal" class="headerlink" title="Case Study: NVIDIA Pascal 案例研究:NVIDIA Pascal"></a>Case Study: NVIDIA Pascal 案例研究:NVIDIA Pascal</h3><p><strong>Pascal是NVIDIA构建的GPU架构。它既作为图形部分存在，也作为计算部分存在，后者的目标是高性能计算和深度学习应用。在本演示中，我们将主要关注图形部分，特别是称为GeForce GTX 1080的特定配置。我们将以自下而上的方式呈现架构，从最小的统一ALU开始，然后逐步构建到整个GPU。我们将在本节的最后简要介绍一些其他芯片配置。</strong></p>
<p><strong>Pascal图形架构中使用的统一ALU (NVIDIA术语中的cuda核心)与1002页图23.8左侧的ALU具有相同的高级图。ALU的重点是浮点和整数运算，但它们也支持其他运算。为了提高计算能力，将几个这样的ALU组合成一个流多处理器(SM)。在Pascal的图形部分中，SM由4个处理块组成，每个处理块有32个ALU。这意味着SM可以同时执行32个线程的4次翘曲。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116170418.png" class="" title="image-20211116170418">

<p>Pascal流多处理器(SM)具有32 × 2 × 2的统一ALU和SM被封装在一个多态引擎中，共同形成一个纹理处理集群(TPC)。请注意，顶部深灰色的盒子被复制到它下面，但部分复制被省略了。</p>
<p><strong>每个处理块，即是一款宽度为32的SIMT引擎，也有8个负载/存储(LD/ST)单元和8个特殊功能单元(SFUs)。加载/存储单元处理寄存器文件中寄存器的读写值，该文件为16,384 × 4字节，即每个处理块64 kB，每SM加起来等于256 kB。 SFUs处理超越函数指令，如正弦、余弦、指数(以2为底)、对数(以2为底)、倒数和倒数平方根。它们还支持属性插值。</strong></p>
<p><strong>SM中的所有ALU共享一个指令缓存，而每个SIMT引擎都有自己的指令缓冲区，其中包含一组最近加载的指令，以进一步提高指令缓存命中率。翘曲调度程序能够在每个时钟周期内调度两个翘曲指令，例如，工作可以被调度到两个时钟周期，同一时钟周期内的ALU和LD/ST单位。注意，每个SM也有两个L1缓存，每个有24 kB的存储，即48kb / SM。使用两个L1缓存的原因可能是，L1缓存越大，需要的读写端口越多，增加了缓存的复杂性，使得芯片上的实现更大。此外，每个SM有8个纹理单位。</strong></p>
<p><strong>因为着色必须在2 × 2像素四边形中完成，warp调度器找到8个不同像素四边形的工作，并将它们分组在32个SIMT车道中执行。因为这是一个统一的ALU设计，翘曲调度程序可以组一个顶点，像素，原语，或计算着色工作到翘曲。注意，SM可以同时处理不同类型的扭曲(如顶点、像素和原语)。该体系结构在将当前正在执行的翘曲切换到准备执行的翘曲时也没有任何开销。关于接下来要在Pascal上执行什么warp的细节还没有公开，但是之前的NVIDIA架构给了我们一些提示。在2008年的NVIDIA特斯拉架构中，一个记分牌被用来限定每个时钟周期的每个偏差。计分板是一种通用的机制，它允许无序执行而不产生冲突。翘曲调度程序会选择那些已经准备好执行的翘曲，例如，不等待纹理加载返回的翘曲，并选择优先级最高的翘曲。翘曲类型、指令类型和“公平性”是用来选择最高优先级翘曲的参数。</strong></p>
<p><strong>SM与变形引擎(PM)协同工作。这个单元是在费米芯片中首次引入的。PM执行几个几何相关的任务，包括取顶点、镶嵌、同时进行多投影、属性设置和流输出。第一阶段从全局顶点缓存中获取顶点，并将顶点和船体着色的变形发送到SMs。然后是一个可选的镶嵌阶段(第17.6节)，其中新生成的(u, v)补丁坐标被分派到SMs，用于域着色和可选的几何着色。第三阶段处理视口转换和透视校正。此外，这里还执行了一个可选的同步多投影步骤，可以用于高效的VR渲染，例如(章节21.3.1)。接下来是可选的第四个阶段，在这个阶段，顶点被流输出到内存。最后，将结果转发给相关的光栅引擎。</strong></p>
<p><strong>光栅引擎有三个任务，即三角形设置、三角形遍历和z-culling。三角形设置获取顶点，计算边方程，并执行背面剔除。三角形遍历使用分层平铺遍历技术来访问重叠三角形的平铺。它使用边方程来执行平铺测试和内部测试。在费米上，每个光栅化器每个时钟周期最多可以处理8个像素。帕斯卡身上没有公开号码。z-culling单元使用第23.7节中描述的技术来处理每个贴图上的culling。如果一个瓦片被选中，那么对该瓦片的处理将立即终止。对于幸存的三角形，每个顶点的属性被转换成平面方程，以便在像素着色器中进行有效的评估。</strong></p>
<p><strong>与变体引擎耦合的流处理器称为纹理处理集群(TPC)。在更高的层次上，5个TPC被分组到一个图形处理集群(GPC)中，该集群有一个单一的光栅引擎为这5个TPC提供服务。GPC可以被认为是一个小型的GPU，它的目标是为图形提供一套平衡的硬件单元，例如顶点、几何、光栅、纹理、像素和ROP单元。正如我们将在本节最后看到的，创建独立的功能单元可以让设计师更容易地创建具有一系列功能的GPU芯片家族。</strong></p>
<p><strong>至此，我们已经拥有了GeForce GTX 1080的大部分构建块。它由4个GPC组成，这个常规设置如下图所示。请注意，这里还有另一种级别的调度，由GigaThread引擎提供支持，以及到PCIe v3的接口。GigaThread引擎是一个全局工作分配引擎，它将线程块调度到所有的GPC。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116171019.png" class="" title="image-20211116171019">

<p>Pascal GPU在其GTX 1080配置20个SMs，20个 polymorph engines，4个raster engines，8×20 = 160个纹理单元(峰值速率为277.3 Gtexels/s)， 256×20 = 5120 kB的注册文件，以及总共20 × 128 = 2560个统一ALU。</p>
<p><strong>光栅操作单元也显示在上图中，尽管有些隐藏。它们位于图中L2缓存的正下方。每个蓝块为1个ROP单位，共8组，每组8个ROP，共64个ROP。ROP单元的主要任务是将输出写入像素和其他缓冲区，并执行各种操作，如混合。如图左右所示，共有8个32位内存控制器，合计为256位。八个ROP单元绑定到一个内存控制器和256kb的L2缓存。这为整个芯片提供了2MB的L2缓存。每个ROP都绑定到某个内存分区，这意味着一个ROP处理缓冲区中某个像素子集。ROP装置还可以处理无损压缩。有三种不同的压缩模式除了支持未压缩和快速清除。对于2:1压缩(例如，从256 B到128 B)，每个贴图存储一个参考颜色值，并在像素之间编码差异，其中每个差异使用比未压缩形式更少的比特进行编码。然后4:1压缩是2:1模式的扩展，但这种模式只能在差异可以使用更少的位编码的情况下启用，而且它只适用于那些内容平滑变化的块。还有一种8:1模式，它是2 × 2像素块的4:1恒定颜色压缩与上述的2:1模式的组合。8:1模式的优先级高于4:1,4:1模式的优先级高于2:1，即:压缩率最高的模式，也成功地压缩瓷砖总是使用。如果所有这些压缩尝试都失败了，则必须以未压缩的形式传输并存储在内存中。帕斯卡压缩系统的效率如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116171230.png" class="" title="image-20211116171230">

<p>渲染后的图像显示在左边，而压缩结果显示在Maxwell(中间)、Pascal之前的架构和Pascal(右边)。图像越呈紫色，缓冲压缩成功率越高。</p>
<p><strong>显存为GDDRX5，时钟速率为10GHz。上面我们看到8个内存控制器总共提供256位= 32B。这总共提供了320GB /s的内存峰值带宽，但是许多级别的缓存结合压缩技术提供了更高的有效速率。</strong></p>
<p><strong>该芯片的基时钟频率为1607 MHz，当有足够的功率预算时，它可以工作在升压模式(1733 MHz)。峰值计算能力为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116171343.png" class="" title="image-20211116171343">

<p><strong>其中2来自于这样一个事实:一个融合了乘法和加法的运算通常被计算为两个浮点运算，我们已经除以10^6从MFLOPS转换为TFLOPS。GTX 1080 Ti具有3584个ALUs，导致12.3 TFLOPS。</strong></p>
<p><strong>NVIDIA开发最后排序片段架构已经很长时间了。然而，由于Maxwell，它们还支持一种称为平铺缓存的新呈现类型，这种呈现在排序中间和排序最后的片段之间。该架构如下图所示。其思想是利用局部性和L2缓存。几何图形是在足够小的块中处理的，因此输出可以留在这个缓存中。此外，帧缓冲区也保持在L2中，只要几何重叠的平铺还没有完成像素着色。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116171457.png" class="" title="image-20211116171457">

<p>平铺缓存引入了一个binner来将几何图形分类为平铺，并让转换后的几何图形留在L2缓存中。当前处理的贴图也会留在L2中，直到当前块的几何图形完成为止。</p>
<p><strong>在上上上图中有四个光栅引擎，但是我们知道图形API必须(在大多数情况下)遵守原始提交顺序。帧缓冲区是通常使用一般化的棋盘模式分割成多个贴图，每个栅格引擎“拥有”一组贴图。当前三角形被发送到至少有一个与三角形重叠的贴图的每个栅格引擎，这就独立地解决了每个贴图的排序问题。这有利于更好的负载平衡。在GPU架构中通常也有几个FIFO队列，它们是为了减少硬件单元的消耗。这些队列没有显示在我们的图中。</strong></p>
<p><strong>显示器控制器为每色12位，支持BT.2020宽色域。它还支持HDMI 2.0b和HDCP 2.2。对于视频处理，它支持SMPTE 2084，这是一个高动态范围视频的传递函数。Venkataraman描述了英伟达架构如何从费米和之后有一个或多个复制引擎。这些内存控制器可以执行直接内存访问(DMA)传输。DMA传输发生在CPU和GPU之间，这样的传输通常在这两者中任意一个上启动。开始处理单元可以在传输期间继续进行其他计算。复制引擎可以启动CPU和GPU内存之间的DMA数据传输，它们可以独立于GPU的其余部分执行。因此，当信息从CPU传输到GPU时，GPU可以渲染三角形并执行其他功能，反之亦然。</strong></p>
<p><strong>Pascal体系结构也可以配置为非图形化应用程序，例如用于训练神经网络或大规模数据分析。特斯拉P100就是一个这样的配置。与GTX 1080的一些不同之处在于，它使用4096位的高带宽内存2 (HBM2)作为内存总线，提供720 GB/s的总内存带宽。此外，它们具有本地16位浮点数支持，性能是32位浮点数的2倍，双精度处理速度更快。SM配置也不同，寄存器文件设置也不同。</strong></p>
<p><strong>GTX 1080 Ti是一个高端配置。它有3584个ALU, 352位内存总线，484 GB/s的总内存带宽，88个rop, 224个纹理单元，相比之下GTX 1080有2560、256位、320 GB/s、64和160个纹理单元。</strong></p>
<p><strong>它使用6个GPC进行配置，即它有6个光栅引擎，而GTX 1080只有4个。其中4个GPC与GTX 1080完全相同，而剩下的2个稍微小一些，只有4个TPC而不是5个。1080 Ti由120亿个晶体管组成，而1080使用了72亿个晶体管。Pascal架构非常灵活，因为它还可以缩小规模。例如，GTX 1070是GTX 1080减去一个GPC，而GTX 1050由两个GPC组成，每个GPC有三个短信。</strong></p>
<h3 id="Case-Study-AMD-GCN-Vega-案例研究-AMD-GCN-Vega"><a href="#Case-Study-AMD-GCN-Vega-案例研究-AMD-GCN-Vega" class="headerlink" title="Case Study: AMD GCN Vega 案例研究:AMD GCN Vega"></a>Case Study: AMD GCN Vega 案例研究:AMD GCN Vega</h3><p><strong>AMD显卡产品以及Xbox One和PLAYSTATION 4都采用了AMD的GCN架构。在这里，我们描述GCN Vega架构的一般元素，它是这些控制台中使用的架构的演变。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116172001.png" class="" title="image-20211116172001">

<p>维加架构的GCN计算单元。每个向量寄存器文件有64 kB的容量，而标量RF有12.5 kB，本地数据共享有64 kB。注意，对于每个CU中的计算，有四个16 SIMD通道单元(浅绿色)，带有32位浮点数。</p>
<p><strong>GCN架构的核心构建块是计算单元(CU)，如上图所示。CU有四个SIMD单元，每个单元有16个SIMD通道。16个统一的ALU(使用第23.2节的术语)。每个SIMD单元执行64个线程的指令，这被称为波前。每个SIMD单元可以在每个时钟周期内发出一条单精度浮点指令。因为该体系结构每个SIMD单元处理64个线程的波前，在波前完全发出之前需要4个时钟周期。还要注意，CU可以同时运行来自不同内核的代码。由于每个SIMD单元有16个通道，每个时钟周期可以发出一条指令，因此整个CU的最大吞吐量为每个CU 4个SIMD单元×每个单元16个SIMD通道=每个时钟周期64个单精度FP操作。CU还可以执行比单精度FP多一倍的半精度(16位浮点)指令，这对于需要较低精度的情况非常有用。例如，这可以包括机器学习和着色器计算。注意，两个16位FP值被打包成一个32位FP寄存器。每个SIMD单元有一个64 kB的寄存器文件，这相当于每线程65 536/(4·64)= 256个寄存器，因为一个单精度FP使用4字节，每个波前有64个线程。ALU有四个硬件管线阶段。</strong></p>
<p><strong>每个CU都有一个指令缓存(图中没有显示)，最多可以在四个SIMD单元之间共享。相关指令被转发到SIMD单元的指令缓冲区(IB)。每个IB有处理10个波前的存储空间，可以根据需要切换到SIMD单元，以隐藏延迟。这意味着CU可以处理40个波阵面。这相当于40·64 = 2560个线程。因此，上图中的CU调度器一次可以处理2560个线程，它的任务是将工作分配到CU的不同单元。每个时钟周期，当前CU上的所有波前都被考虑为指令问题，每个执行端口最多可以发出一条指令。CU的执行端口包括分支、标量/矢量ALU、标量/矢量内存、本地数据共享、全局数据共享或导出以及特殊指令，即每个执行端口大致对应CU的一个单元。</strong></p>
<p><strong>标量单元是一个64位的ALU，它也在SIMD单元之间共享。它有自己的标量寄存器文件和标量数据缓存(未显示)。标量射频每个SIMD单元有800个32位寄存器，即 800·4·4 = 12.5 kB。执行与波阵面紧密耦合。由于向SIMD单元完全发出一条指令需要四个时钟周期，因此标量单元只能每四个时钟周期为特定SIMD单元提供服务。标量单元处理控制流、指针运算和其他可以在warp中共享的计算。从标量单元发送条件和无条件的分支指令，以便在分支和消息单元中执行。每个SIMD单元都有一个单独的48位程序计数器(PC)，在通道之间共享。这就足够了，因为它们都执行相同的指令。对于获得的分支，程序计数器将被更新。该单元可以发送的消息包括调试消息、特殊图形同步消息和CPU中断。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116172226.png" class="" title="image-20211116172226">

<p>64 CUs的Vega 10 GPU。注意，每个CU包含如上图所示的硬件。</p>
<p><strong>Vega 10架构如上图所示。顶部部分包括一个图形命令处理器，两个硬件调度程序(HWSs)和八个异步计算引擎(ACEs)。GPC的任务是将图形任务调度到GPU的图形管道和计算引擎上。HWSs的缓冲区在队列中工作，它们尽可能快地分配给ACE。ACE的任务是将计算任务调度到计算引擎上。还有两个DMA引擎可以处理复制任务(图中没有显示)。GPC、ACEs和DMA引擎可以并行工作，并将工作提交给GPU，这可以提高利用率，因为任务可以从不同的队列中交错执行。可以从任何队列分派工作，而不需要等待其他工作完成，这意味着独立的任务可以同时在计算引擎上执行。ACE可以通过缓存或内存进行同步。它们可以一起支持任务图，这样一个ACE的任务可以依赖于另一个ACE的任务，或者依赖于图形管道的任务。建议较小的计算和复制任务与较重的图形任务交织。</strong></p>
<p><strong>如上图所示，有4个图形管道和4个计算引擎。每个计算引擎有16个CUs，合计64个CUs。图形管线有两个模块，即几何引擎和绘制流分类光栅(DSBR)。几何引擎包括几何汇编器、镶嵌单元和顶点汇编器。另外，支持一个新的原始着色器。基本着色器的想法是使更灵活的几何处理和更快的剔除基本的。DSBR结合了排序中间和排序最后架构的优点，这也是平铺缓存的目标(章节23.10.2)。图像在屏幕空间中被划分为多个贴图，经过几何处理后，每个原语被分配到它们重叠的贴图上。在平铺的栅格化过程中，所有需要的数据(例如平铺缓冲区)都保存在L2缓存中，这提高了性能。像素着色可以自动延迟，直到一个平铺中的所有几何图形都被处理完。因此，z- preass是在罩下完成的，像素只着色一次。延迟着色可以打开或关闭;例如，对于透明的几何体，它需要关闭。</strong></p>
<p><strong>为了处理深度、模板和颜色缓冲，GCN体系结构有一个称为颜色和深度块(CDB)的构建块。它们处理颜色、深度和模板阅读和写作，除了颜色混合。CDB可以使用23.5节中描述的一般方法压缩颜色缓冲区。使用增量压缩技术，每个贴图存储一个像素的颜色，不压缩，其余的颜色值相对于该像素颜色进行编码。为了提高效率，可以根据访问模式动态选择贴图大小。对于最初使用256字节存储的贴图，最大速率为8:1，即压缩到32字节。压缩后的颜色缓冲区可以作为后续通道中的纹理，在这种情况下，纹理单元将解压缩被压缩的贴图，从而进一步节省带宽。</strong></p>
<p><strong>光栅化器在每个时钟周期内最多可以光栅化四个原语。连接到图形管道和计算引擎的CDB每个时钟周期可以写16个像素。也就是说，小于16像素的三角形会降低效率。栅格化器还处理粗深度测试(HiZ)和分层模板测试。HiZ的缓冲区被称为HTILE，可以由开发人员编程，例如，用于向GPU提供遮挡信息。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116172523.png" class="" title="image-20211116172523">

<p>Vega架构的缓存层次结构。</p>
<p><strong>Vega的缓存层次结构如上图所示。在层次结构的顶端(图中最右边)，我们有寄存器，其次是L1和L2缓存。然后是高带宽内存2 (HBM2)，它也位于显卡上，最后是位于CPU端上的系统内存。Vega的一个新特性是高带宽缓存控制器(HBCC)，如上上图的底部所示。它允许视频内存像最后一级缓存一样运行。这意味着如果进行内存访问，而相应的内容不在显存中，则HBCC将自动通过PCIe总线获取相关的系统内存页，并将其放入显存。因此，视频内存中最近使用较少的页面可能会被换出。HBM2和系统内存之间共享的内存池称为HBCC内存段(HMS)。所有的图形块也通过L2缓存访问内存，这与以前的架构不同。该体系结构还支持虚拟内存(章节19.10.1)。</strong></p>
<p><strong>请注意，所有片上模块，例如HBCC、XDMA (CrossFire DMA)、PCI express、显示引擎和多媒体引擎，都通过一个称为Infinity Fabric (IF)的互连连接进行通信。AMD的CPU也可以连接到IF上。Infinity Fabric可以连接不同芯片芯片上的模块。IF也是一致的，这意味着所有块都可以在内存中看到相同的内容视图。</strong></p>
<p><strong>该芯片的基时钟频率为1677 MHz，即，峰值计算能力密度是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116172656.png" class="" title="image-20211116172656">

<p><strong>其中FMA和TFLOPS的计算与公式23.16相符。该体系结构灵活且可扩展，因此需要更多配置。</strong></p>
<h2 id="Ray-Tracing-Architectures-光线追踪的架构"><a href="#Ray-Tracing-Architectures-光线追踪的架构" class="headerlink" title="Ray Tracing Architectures 光线追踪的架构"></a>Ray Tracing Architectures 光线追踪的架构</h2><p><strong>本节将简要介绍射线追踪硬件。我们不会列出关于这个主题的所有最近的引用，而是提供一组鼓励读者遵循的指针。2002年Schmittler等人开始了这一领域的研究，重点是遍历和交叉，使用固定功能单元计算遮光。这项工作后来被Woop等人跟进，他们提出了一个带有可编程着色器的架构。</strong></p>
<p><strong>在过去的几年中，对这个话题的商业兴趣有了相当大的增长。这一点可以从Imagination Technologies、LG电子和三星等公司提出的实时射线追踪硬件架构中看出。然而，在撰写本文时，只有Imagination Technologies发布了一款商业产品。</strong></p>
<p><strong>在这些体系结构中有几个共同的特点。首先，它们通常使用基于轴对齐的包围盒的包围体层次结构。其次，它们倾向于通过降低射线/盒交叉测试的精度来降低硬件复杂度(第22.7节)。最后，他们使用可编程核心来支持可编程底纹，这或多或少是当今的需求。例如，Imagination Technologies扩展了他们的传统芯片设计，添加了一个光线追踪单元，它可以利用着色器核心进行着色。光线追踪单元由光线相交处理器和相干引擎组成，相干引擎将具有相似性质的光线聚集在一起进行处理，利用局部性实现更快的光线追踪。Imagination Technologies的建筑还包括一个专门用于建造BVHs的单元。</strong></p>
<p><strong>该领域的研究还在继续探索几个领域，包括降低遍历的有效实现精度、BVHs的压缩表示和能效。毫无疑问，还有更多的研究要做。</strong></p>
<h1 id="24-The-Future-未来"><a href="#24-The-Future-未来" class="headerlink" title="24 The Future 未来"></a>24 The Future 未来</h1><p><strong>未来由两部分组成:你和其他一切。这一章是关于两者的。首先，我们将做一些预测，其中一些甚至可能成为现实。更重要的是第二部分，关于你接下来要去哪里。这是一个扩展的进一步阅读和参考资料部分，但是它也讨论了从这里开始的方法—一般的信息源、会议、代码等等。但首先，我们来看一幅图:参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116172911.png" class="" title="image-20211116172911">

<p>通过游戏《Destiny 2》，我们可以瞥见未来。</p>
<h2 id="Everything-Else-其他的一切"><a href="#Everything-Else-其他的一切" class="headerlink" title="Everything Else 其他的一切"></a>Everything Else 其他的一切</h2><p><strong>图形有助于游戏的销售，而游戏则有助于芯片的销售。从芯片制造商的营销角度来看，实时渲染的最佳特性之一是图形处理消耗了大量的处理能力和其他资源。与硬件相关的特性，如帧速率、分辨率和颜色深度也会在一定程度上增加，从而进一步增加负载。虚拟现实应用程序的标准是最低90帧/秒的固定帧率，4k像素的显示器已经在测试图形系统的能力以跟上。</strong></p>
<p><strong>在场景中模拟光线效果的复杂任务本身就足以吸收计算能力。在场景中添加更多的物体或灯光是一种渲染会变得更昂贵的方法。物体的类型(包括固体和体积，如雾)，这些物体表面的描绘方式，以及使用的灯光类型都是一些可能增加复杂性的因素。如果我们能够获取更多的样本，评估更精确的方程，或者仅仅是使用更多的内存，许多算法的质量就会提高。不断增加的复杂性使得图形处理能力几乎成为一个无底洞。</strong></p>
<p><strong>为了解决对长期业绩的担忧，乐观主义者喜欢求助于摩尔定律。这个观察结果给出了每1.5年加速2倍的速度，或者更有用的是每5年加速10倍的速度。然而，处理器速度通常不是瓶颈，而且可能会随着时间的推移而减少。带宽是，因为它每10年增加10倍，而不是5倍。</strong></p>
<p><strong>电影行业的算法经常会在实时渲染中找到自己的方法，因为这两个领域的目标都是生成逼真的图像。看看他们的做法，我们可以看到一些统计数据，比如2016年电影《奇幻森林》的一帧画面中，某些场景中有数百万根头发，渲染时间为30至40小时。虽然GPU是专门为实时渲染而设计的，所以相对于cpu有明显的优势，但从1/(40 × 60 × 60) = 0.00000694 FPS到60 FPS需要7个数量级。</strong></p>
<p><strong>我们承诺了一些预测。“更快更灵活”是一个简单的说法。随着GPU架构的发展，一种可能性是z缓冲区三角形光栅化管道将继续占据主导地位。除了最简单的游戏外，所有游戏都使用GPU进行渲染。即使明天某些不可思议的技术取代了现有的管线，一种速度快一百倍，并且包含下载系统补丁的技术，行业仍需要数年时间才能转向这种新技术。一个问题是，新方法是否可以使用与现有方法完全相同的API。如果没有，领养需要一段时间。一款复杂的游戏需要数千万美元或更多的开发成本，并且需要数年时间才能制作完成。目标平台是在过程的早期选择的，这将决定从算法和使用的着色器，到制作的艺术品的大小和复杂性。除了这些因素之外，还需要制作与这些元素一起工作或生产这些元素所需的工具，用户需要精通这些工具的使用。即使出现了奇迹，目前栅格化流水线背后的动力也给了它几年的寿命。</strong></p>
<p><strong>仍然会发生改变。在现实中，简单的“一个光栅化器统治所有”的想法已经开始消失。在本书中，我们讨论了计算着色器如何能够承担各种任务，证明光栅化几乎不是GPU能提供的唯一服务。如果新技术很有吸引力，那么就会重新调整工作流程，从游戏公司转向商业引擎和内容创造工具。</strong></p>
<p><strong>那么，长期来看呢?用于绘制三角形、访问纹理和混合结果样本的专用固定功能GPU硬件仍然可以极大地提高性能。移动设备的需求改变了这一等式，因为功耗变得和原始性能一样重要。然而，“发射然后忘记”的基本管道概念，即我们将一个三角形发送到管道中，并在该框架中完全完成它，并不是现代渲染引擎中使用的模型。变换、扫描、阴影和混合的基本管道模型已经发展到几乎无法识别的地步。GPU已经成为一个大型的基于流的处理器集群，你可以随心所欲地使用它。</strong></p>
<p><strong>APIi和GPU已经共同进化以适应这一现实。咒语是“灵活性”。方法由研究人员探索，然后由开发人员在现有硬件上实现，确定他们希望的功能。独立的硬件供应商可以利用这些发现和他们自己的研究来开发通用功能，形成一个良性循环。对任何单一算法进行优化都是徒劳的。但在GPU上创建新的、灵活的访问和处理数据的方式却并非如此。</strong></p>
<p><strong>考虑到这一点，我们认为光线/物体相交是一种具有多种用途的通用工具。我们知道，使用路径跟踪的完美无偏采样最终会在场景描述的限制下生成正确的、地面真实的图像。“最终”这个词才是关键所在。正如在第11.7节中所讨论的，作为一种可行的算法，路径跟踪目前面临着严峻的挑战。主要的问题是需要大量的样本来得到一个没有噪声的结果，并且在动画时不会闪烁。也就是说，路径跟踪的纯粹性和简单性使得它非常吸引人。交互呈现的当前状态是多种专门技术为特定情况量身定制，而现在只有一种算法可以完成所有工作。电影制片厂当然已经意识到这一点，因为在过去的十年中，他们已经完全转向光线和路径追踪方法。这样做可以让他们优化一组轻型运输的几何操作。</strong></p>
<p><strong>实时渲染——所有的渲染——最终是关于采样和过滤。除了提高射线发射的效率外，路径跟踪还可以受益于智能采样和滤波。事实上，几乎每一个离线路径追踪者都是有偏见的，不管营销文献。对发送样本射线的位置做出了合理的假设，极大地提高了性能。路径跟踪可以受益的另一个领域是智能过滤。深度学习目前是研究和开发的一个白热化领域，由于2012年的显著进步，它大大超过了图像识别的手工调整算法，人们对它的兴趣开始重新升温。使用神经网络去噪和抗锯齿是令人着迷的发展。参见下图。我们已经看到使用神经网络进行渲染相关任务的研究论文数量大幅上升，更不用说建模和动画了。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116173446.png" class="" title="image-20211116173446">

<p>用神经网络重建图像。左边是用路径跟踪生成的噪声图像。在右侧，图像以交互速率使用GPU加速去噪处理。</p>
<p><strong>可以追溯到1987年AT&amp;T的Pixel Machine，交互式光线追踪长期以来一直适用于小场景、低分辨率、很少的光线，以及只有清晰反射、折射和阴影的组合。微软在DirectX API中添加了射线追踪功能，称为DXR，简化了射线发射的过程，并可能促使硬件供应商增加对射线相交的支持。光线拍摄，通过去噪或其他滤波增强，将首先只是另一种技术，以改善各种元素的渲染质量，如阴影或反射。它将与许多其他算法竞争，每个渲染引擎根据诸如速度、质量和易用性等因素做出选择。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116173531.png" class="" title="image-20211116173531">

<p>这些图像以交互速率呈现，每像素有两道反射射线反射，屏幕位置有一道阴影射线反射，两道环境遮挡射线反射，每像素有七道射线反射。阴影和反射使用去噪滤波器。</p>
<p><strong>在撰写本文时，分层射线拍摄作为一种基本操作并不是主流商业GPU的明确组成部分。我们认为PowerVR的Wizard GPU是一个好兆头，因为一家移动设备公司正在考虑通过分层场景描述测试射线的硬件支持。直接支持光线投射的新型GPU将改变效率方程，并可能创建一个良性循环，使各种渲染效果不再那么定制化和专一化。用于眼射线和光线追踪或计算着色器的栅格化几乎是一种方法，已经在各种DXR演示中使用。随着改进的去噪算法，用于追踪光线的更快的GPU，以及以前的研究和新的研究的重新应用，我们期望很快看到相当于10倍的性能改进。</strong></p>
<p><strong>我们希望DXR在其他方面为开发者和研究人员带来福音。对于游戏来说，投射光线的烘焙系统现在可以在GPU上运行并使用类似的功能或者与在交互式渲染器中找到的相同的着色器，以提高性能为结果。地面真实图像可以更容易地生成，使其更容易测试，甚至自动调整算法。架构改变的想法，允许更灵活的生成GPU任务，例如，着色器创建着色工作，似乎是一个强大的，可能有其他应用程序。</strong></p>
<p><strong>当然，GPU的发展还有其他有趣的可能性。另一种理想的世界观是所有的物质都被体素化了。如第13.10节所述，这种表示对于轻传输和模拟有许多优点。需要大量的数据存储，以及场景中动态对象的困难，使得完全切换的可能性极小。尽管如此，我们相信体素可能会得到更多的关注，因为它们在广泛的领域的使用，包括高质量的体积效果，3D打印，和无约束的对象修改(例如，Minecraft)。当然，考虑到自动驾驶汽车系统、激光雷达和其他传感器产生的大量此类数据，点云将成为未来几年更多研究的一部分。带符号距离域(SDFs)是另一种有趣的场景描述方法。与体素类似，SDFs可以对场景进行无约束的修改，也可以加速光线追踪。</strong></p>
<p><strong>有时，给定应用程序的独特约束允许其开发人员“打破常规”，使用以前认为奇异或不可行的技术。《Media Molecule’s Dreams》和《Second Order’s Claybook》(如下图所示)等游戏可以让我们对可能出现的非正统算法主导的渲染前景有一些有趣的了解。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116173700.png" class="" title="image-20211116173700">

<p>《Claybook》是一款基于物理原理的益智游戏，玩家可以自由塑造粘土世界。粘土世界使用签名距离场建模，并使用光线追踪渲染，包括主光线、光线追踪阴影和AO。在GPU上模拟固体和液体物理。</p>
<p><strong>虚拟和混合现实值得一提。当虚拟现实运行良好时，它是令人惊叹的。混合现实具有与现实世界相融合的合成内容的迷人演示。每个人都想要兼具这两种功能的轻量级眼镜，这在短期内可能会被归入“个人喷气背包、水下城市”一类。但谁知道呢?考虑到这些努力背后的大量研究和开发，可能会有一些突破，可能会改变世界。</strong></p>
<h2 id="You-你"><a href="#You-你" class="headerlink" title="You 你"></a>You 你</h2><p><strong>那么，当你和你孩子们的孩子们在等待奇点的时候，你会做什么呢?当然是程序:发现新的算法，创建应用程序，或者做任何你喜欢的事情。几十年前，一台机器的图形硬件比一辆豪华汽车还贵;现在，它被内置在几乎所有有CPU的设备中，这些设备通常可以放在你的手掌中。图形黑客是廉价和主流的。在本节中，我们将介绍各种资源，这些资源对学习实时渲染领域的更多知识非常有用。</strong></p>
<p><strong>这本书不是凭空出现的;它利用了大量的信息来源。如果您对某个特定的算法感兴趣，请跟踪原始的出版物。我们的网站有一个页面，上面有我们参考的所有文章，所以如果有资源的话，你可以在那里找到链接。大多数研究文章都可以使用谷歌Scholar，作者的网站，或者，如果其他方法都失败了，向作者要一份拷贝——几乎每个人都喜欢别人阅读和欣赏他们的作品。如果没有找到免费的服务，例如ACM数字图书馆有大量的文章可用。如果您是SIGGRAPH的成员，您可以自动免费访问他们的许多图形文章和演讲。有几家杂志发表了技术文章，如ACM图形学报(现在包括了SIGGRAPH的议题)，计算机图形技术杂志(开放获取)，IEEE可视化和计算机图形学报，计算机图形论坛，IEEE计算机图形和应用，等等。最后，一些专业的博客有很好的信息，而且Twitter上的图形开发人员和研究人员经常指出很好的新资源。</strong></p>
<p><strong>学习和认识别人的最快方法之一就是参加会议。另一个人正在做你正在做或可能感兴趣的事情的几率很高。如果资金紧张，联系组织者，询问志愿者机会或奖学金。SIGGRAPH和SIGGRAPH亚洲年度会议是新想法的主要场所，但不是唯一的。其他技术集会，如欧洲图形大会和欧洲图形渲染专题讨论会(EGSR)，交互式3D图形和游戏专题讨论会(I3D)，以及高性能图形(HPG)论坛，都展示并发布了大量与实时渲染相关的材料。还有一些针对开发者的会议，如知名的游戏开发者大会(GDC)。在排队或参加活动时，向陌生人问好。在SIGGRAPH上，尤其要留意在你感兴趣的领域里的“物以类聚”(BOF)。与人面对面地交流想法是有益的，也是充满活力的。</strong></p>
<p><strong>有一些与交互呈现相关的电子资源。特别值得注意的是，《Graphics Codex》是一份高质量的纯电子参考文献，具有不断更新的优势。沉浸式线性代数网站，部分由本书的合著者创建，包括交互式演示，以帮助学习这个主题。雪莉在Kindle上有一系列关于光线追踪的短篇书籍。我们期待有更多这类廉价和快速获取的资源。</strong></p>
<p><strong>印刷书籍仍有一席之地。除了一般文本和特定领域的卷，编辑的文章集包括大量的研究和发展信息，其中许多我们在本书中引用。最近的例子是GPU Pro和GPU Zen书籍。早前的书籍如《Game Programming Gems》、《GPU Gems》(免费在线)和《ShaderX》系列仍然有相关文章——算法不会腐烂。所有这些书籍都允许游戏开发者在不写正式会议论文的情况下呈现自己的方法。这样的收集还允许学者们讨论他们工作的技术细节，这些细节不适合在研究论文中。对于专业开发人员来说，阅读一篇文章中找到的实现细节所节省的一个小时，比阅读整本书所花的钱还多。如果你等不及一本书的投递，可以使用亚马逊上的“查看内部”功能，或者在谷歌Books上搜索文本，可以获得一段摘录，让你开始阅读。</strong></p>
<p><strong>当一切都说了并做了之后，就需要编写代码了。随着GitHub、Bitbucket和类似存储库的兴起，可以利用的存储库越来越多。难点在于知道什么不符合斯特金定律。虚幻引擎等产品的源代码是开放的，因此这是一种不可思议的资源。ACM现在鼓励发布任何技术文章的代码。你所尊敬的作者有时会有他们的代码可用。搜索周围。</strong></p>
<p><strong>一个特别值得注意的地方是Shadertoy，它经常在像素着色器中使用光线行进来展示各种技术。虽然许多程序首先是视觉上的糖果，但该网站有许多教育演示，所有代码都是可见的，并且都可以在浏览器中运行。另一个基于浏览器的演示的来源是three.js库和相关站点。“三”是对WebGL的包装，鼓励实验，因为只需要几行代码就可以生成渲染。在网络上发布演示供任何人运行和分析，只需点击超链接，这对于教育用途和分享想法是非常棒的。本书的一位作者基于three.js为Udacity创建了一个介绍性的图形课程。</strong></p>
<p><strong>我们再次向您推荐我们的网站realtimerendering.com。在那里你会找到许多其他资源，比如推荐书目和新书列表(包括一些免费的高质量书籍)，以及有价值的博客、研究网站、课程介绍和许多其他信息来源的链接。寻找快乐!</strong></p>
<p><strong>我们最后的建议是去学习，去做。实时计算机图形学领域在不断发展，新的思想和特征不断被发明和整合。你可以参与其中。使用的广泛的技术似乎令人生畏，但你不需要执行一长串流行词汇来获得良好的结果。基于应用程序的约束和视觉风格，巧妙地结合少量技术，可以产生独特的视觉效果。在GitHub上分享你的结果，它也可以用来管理博客。参与!</strong></p>
<p><strong>这一领域最好的部分之一就是每隔几年就会进行自我改造。计算机体系结构不断变化和改进。几年前不奏效的做法，现在可能值得一试。每一款新的GPU都有不同的功能、速度和内存。什么是有效的，什么是瓶颈会不断变化和发展。即使是那些看起来古老而完善的地方也值得重游。据说创造是一种扭曲、打破和混合其他想法的过程，而不是从无到有。</strong></p>
<p><strong>这一版本是在1974年(1724年)由Sutherland、Sproull和Schumacker发表的计算机图形学领域的里程碑论文之一《十种隐面算法的特征》44年后出版的。他们55页的论文进行了令人难以置信的全面比较。被描述为“贵得离谱”的算法，甚至连研究者的名字都没有提及的蛮力技术，也只是在附录中提到，现在被称为z缓冲区。公平地说，萨瑟兰是z-buffer发明者埃德·卡特穆尔(Ed Catmull)的顾问，他讨论这一概念的论文将在几个月后发表]。</strong></p>
<p><strong>第十一种隐藏表面技术胜出了，因为它易于在硬件上实现，而且内存密度上升，成本下降。萨瑟兰等人所做的“Ter算法”调查在当时是完全有效的。随着条件的变化，所使用的算法也会发生变化。未来几年将会发生什么令人兴奋。当我们回顾当前的渲染技术时代，会有什么感觉?没有人知道，每个人都可能对未来产生重大影响。没有一定要发生的未来，没有一定要发生的过程。你创建它。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116174031.png" class="" title="image-20211116174031">

<p><strong>What do you want to do next?</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OSkirito"
      src="/images/head_image.png">
  <p class="site-author-name" itemprop="name">OSkirito</p>
  <div class="site-description" itemprop="description">CG技术的记录与分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oskirito" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oskirito" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OSkirito</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
