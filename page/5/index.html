<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CG技术的记录与分享">
<meta property="og:type" content="website">
<meta property="og:title" content="OS&#39;s Blog">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="OS&#39;s Blog">
<meta property="og:description" content="CG技术的记录与分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="OSkirito">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>OS's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OS's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">41</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/05/Real-Time%20Rendering%204th%20edition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_image.png">
      <meta itemprop="name" content="OSkirito">
      <meta itemprop="description" content="CG技术的记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OS's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/05/Real-Time%20Rendering%204th%20edition/" class="post-title-link" itemprop="url">Real-Time Rendering 4th edition</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-05 14:15:51" itemprop="dateCreated datePublished" datetime="2023-05-05T14:15:51+08:00">2023-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-21 17:52:18" itemprop="dateModified" datetime="2023-05-21T17:52:18+08:00">2023-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Introduction-介绍"><a href="#1-Introduction-介绍" class="headerlink" title="1 Introduction 介绍"></a>1 Introduction 介绍</h1><h2 id="Contents-Overview-内容概述"><a href="#Contents-Overview-内容概述" class="headerlink" title="Contents Overview 内容概述"></a>Contents Overview 内容概述</h2><h2 id="Notation-and-Definitions-符号和定义"><a href="#Notation-and-Definitions-符号和定义" class="headerlink" title="Notation and Definitions 符号和定义"></a>Notation and Definitions 符号和定义</h2><h1 id="2-The-Graphics-Rendering-Pipeline-图形渲染管线"><a href="#2-The-Graphics-Rendering-Pipeline-图形渲染管线" class="headerlink" title="2 The Graphics Rendering Pipeline 图形渲染管线"></a>2 The Graphics Rendering Pipeline 图形渲染管线</h1><h2 id="Architecture-体系结构"><a href="#Architecture-体系结构" class="headerlink" title="Architecture 体系结构"></a>Architecture 体系结构</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210906115237.png" class="" title="image-20210906115237">

<p><strong>实时渲染管线粗略划分为四个主要阶段:应用程序、几何处理、光栅化和像素处理。每一个阶段本身通常是一个管线，这意味着它由几个子阶段组成。我们区分这里显示的功能阶段和它们的实现结构。函数阶段有特定的任务要执行，但是没有指定任务在管道中执行的方式。一个给定的实现可以将两个功能阶段合并成一个单元或使用可编程核心执行，而将另一个更耗时的功能阶段划分为几个硬件单元。</strong></p>
<p><strong>绘制速度可以用每秒帧数(FPS)表示，即每秒绘制的图像数量。它也可以用赫兹(Hz)表示，这只是1/秒的符号，即更新频率。还可用毫秒(ms)表示渲染图像所需的时间。生成图像的时间通常是不同的，这取决于每一帧所执行的计算的复杂性。每秒帧数用来表示特定帧的速率，或者表示某一段使用时间内的平均性能。赫兹用于硬件，如显示器，它通常被设置为一个固定的速率。</strong></p>
<p><strong>光栅化和像素处理阶段也完全在GPU上处理。</strong></p>
<h2 id="The-Application-Stage-应用程序"><a href="#The-Application-Stage-应用程序" class="headerlink" title="The Application Stage 应用程序"></a>The Application Stage 应用程序</h2><p><strong>开发人员完全控制在应用程序阶段发生的事情，因为它通常是在CPU上执行的。因此，开发人员可以完全确定实现，并在以后修改它以提高性能。这里的更改也会影响后续阶段的性能。这些cpu通常包括能够并行处理多个执行线程的多个核。这使得cpu能够有效地运行应用程序阶段负责的各种任务。一些传统上在CPU上执行的任务包括碰撞检测、全局加速算法、动画、物理模拟和许多其他任务，这取决于应用程序的类型。加速算法，比如特定的剔除算法，以及其他管道的其他部分无法处理的算法，也在这里实现。</strong></p>
<p><strong>在应用阶段的最后，要渲染的几何图形被输入到几何图形处理阶段。这些是呈现元素，即，点、线和三角形。这是应用阶段最重要的任务。</strong></p>
<p><strong>基于软件实现这一阶段的结果是，它不像几何处理、光栅化和像素处理阶段那样被划分为子阶段。然而，为了提高性能，这一阶段通常在多个处理器核心上并行执行。在CPU设计中，这被称为超标量构造，因为它能够在同一阶段同时执行多个进程。</strong></p>
<h2 id="Geometry-Processing-几何处理"><a href="#Geometry-Processing-几何处理" class="headerlink" title="Geometry Processing 几何处理"></a>Geometry Processing 几何处理</h2><p><strong>它处理变换、投影和所有其他类型的几何处理。这个阶段计算要画什么，应该怎么画，应该在哪里画。几何阶段通常在图形处理单元(GPU)上执行，该单元包含许多可编程核心和固定操作硬件。</strong></p>
<p><strong>GPU上的几何处理阶段负责大部分的三角形和顶点操作。这个阶段进一步分为以下功能阶段:顶点着色、投影、裁剪和屏幕映射。</strong><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210907091653.png" class="" title="image-20210907091653"></p>
<h3 id="Vertex-Shading-顶点着色"><a href="#Vertex-Shading-顶点着色" class="headerlink" title="Vertex Shading 顶点着色"></a>Vertex Shading 顶点着色</h3><p><strong>顶点着色有两个主要的任务，即，计算顶点的位置和计算程序员可能喜欢的任何顶点输出数据，如法线和纹理坐标。传统上，对象的大部分着色是通过对每个顶点的位置和法线应用光照，并仅存储在顶点的结果颜色来计算的。然后这些颜色被插值到三角形中。因此，这个可编程顶点处理单元被命名为顶点着色器。顶点的位置和法线可以用程序员喜欢的任何方式计算。</strong></p>
<h3 id="Projection-投影"><a href="#Projection-投影" class="headerlink" title="Projection 投影"></a>Projection 投影</h3><p><strong>在GPU上它是由顶点着色器完成的。常用的投影方法有两种，即正投影法(也称平行投影法，事实上，正投影只是平行投影的一种。)和透视投影。</strong><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210907095409.png" class="" title="image-20210907095409"></p>
<p><strong>正射视图的视图体积通常是一个矩形框，而正射投影将此视图体积转换为单元立方体。正射影的主要特点是平行线在变换后仍然保持平行。这种转换是平移和缩放的结合。</strong></p>
<p><strong>透视投影稍微复杂一点。在这种类型的投影中，一个物体离相机越远，它在投影后显得越小。此外，平行线可能会聚于地平处。因此，透视变换模仿了我们感知物体大小的方式。几何上，视图体称为截锥，是一个带有矩形基础的截断金字塔。截锥变形了也进入了单元多维数据集。（将视图体积转换为一个单元立方体，其极值点为(−1,1,1)和(1,1,1)。可以使用定义相同体积的不同范围，例如0≤z≤1。单位多维数据集称为规范视图体积。）</strong></p>
<h3 id="Optional-Vertex-Processing-可选顶点处理"><a href="#Optional-Vertex-Processing-可选顶点处理" class="headerlink" title="Optional Vertex Processing 可选顶点处理"></a>Optional Vertex Processing 可选顶点处理</h3><p><strong>每个管线都有刚才描述的顶点处理。一旦这个处理完成了，就可以在GPU上进行一些可选的步骤，按照这个顺序:镶嵌、几何着色和流输出。它们的使用既取决于硬件的能力(并非所有GPU都有)，也取决于程序员的需求。它们彼此独立，通常不常用。</strong></p>
<h4 id="Tessellation-镶嵌细分"><a href="#Tessellation-镶嵌细分" class="headerlink" title="Tessellation 镶嵌细分"></a>Tessellation 镶嵌细分</h4><p><strong>顶点可以用来描述一个曲面，比如一个球。这样的曲面可以由一组补丁（patch）指定，每个补丁由一组顶点组成。细分着色器由多个着色器组成——外壳着色器、细分单元和域着色器——这将这些补丁顶点集转换成(通常)更大的顶点集，然后用来创建新的三角形集。场景中的摄像机可以用来确定生成了多少个三角形:当补丁接近时，生成的三角形很多，当补丁距离较远时，生成的三角形很少。</strong></p>
<h4 id="Geometry-Shader-几何着色器"><a href="#Geometry-Shader-几何着色器" class="headerlink" title="Geometry Shader 几何着色器"></a>Geometry Shader 几何着色器</h4><p><strong>这个着色器比镶嵌着色器更早，所以在GPU上更常见。它就像镶嵌着色器，它通过各种各样的元素，并可以产生新的顶点。这是一个简单得多的阶段，因为创建的范围有限，输出元素的类型也非常有限。几何着色器有几种用途，其中最流行的是粒子生成。想象一下模拟烟花爆炸。每个火球都可以用一个点来表示，一个单一的顶点。几何着色器可以把每个点变成一个正方形(由两个三角形组成)，面向观众，覆盖几个像素，所以为我们提供了一个更有可靠的原始着色。</strong></p>
<h4 id="Stream-Output-流推送"><a href="#Stream-Output-流推送" class="headerlink" title="Stream Output 流推送"></a>Stream Output 流推送</h4><p><strong>这个阶段让我们使用GPU作为几何引擎。此时，我们可以选择性地将这些处理过的顶点输出到数组中以供进一步处理，而不是将处理过的顶点发送到管线的其余部分以呈现到屏幕上。这些数据可以在以后的过程中被CPU或GPU使用。这个阶段通常用于粒子模拟，例如我们的焰火示例。</strong></p>
<p><strong>不管使用的是哪个操作，如果我们继续沿着管线走下去，我们就会有一组具有齐次坐标的顶点，我们将检查摄像机是否会查看它们。</strong></p>
<h3 id="Clipping-裁剪"><a href="#Clipping-裁剪" class="headerlink" title="Clipping 裁剪"></a>Clipping 裁剪</h3><p><strong>只有视图体中全部或部分的元素需要被传递到光栅化阶段(以及随后的像素处理阶段)，然后在屏幕上绘制它们。完全位于视图体内部的元素将按原样传递到下一阶段。完全在视图体之外的元素不会被进一步传递，因为它们不会被渲染。需要裁剪的是部分位于视图体积内的元素。使用投影矩阵意味着转换后的元素被裁剪到单位立方体上。在裁剪之前执行视图转换和投影的优点是它使裁剪问题保持一致;元素总是被剪切到单元立方体上。</strong></p>
<p><strong>裁剪步骤使用由投影产生的四值齐次坐标来执行。值通常不会在透视空间中的三角形上进行线性插值。第四个坐标是必需的，以便在使用透视投影时适当地插值和裁剪数据。最后进行透视划分，将得到的三角形位置放入三维标准化的设备坐标中。正如前面提到的，这个视图体积的范围从(−1, −1, −1) 到 (1, 1, 1)。</strong></p>
<h3 id="Screen-Mapping-屏幕映射"><a href="#Screen-Mapping-屏幕映射" class="headerlink" title="Screen Mapping 屏幕映射"></a>Screen Mapping 屏幕映射</h3><p><strong>当进入这个阶段时，坐标仍然是三维的。每个元素的x和y坐标被转换成屏幕坐标。屏幕坐标和z坐标也称为窗口坐标。假设场景应该被渲染成一个最小角为 (x1, y1))和最大角 (x2, y2),其中x1 &lt; x2 和y1 &lt; y2。屏幕映射是一个转换，然后是缩放操作。新的x和y坐标称为屏幕坐标。z坐标(OpenGL的([−1, +1]和DirectX的 [0, 1])也被映射到 [z1, z2]与z1 = 0 和 z2 = 1作为默认值。但是，这些可以通过API进行更改。</strong></p>
<p><strong>如何将整数和浮点值与像素(和纹理坐标)相关。给定一个水平像素数组并使用笛卡尔坐标，最左边像素的左边缘在浮点坐标中为0.0。OpenGL一直使用这个方案，directx10及往后版本也使用它。这个像素的中心是0.5。因此，像素范围[0,9]涵盖了从[0.0,10.0)到[0.0,10.0]的范围。转换很简单。</strong></p>
<p><strong>d = floor(c),</strong> </p>
<p><strong>c = d + 0.5,</strong></p>
<p><strong>其中d是像素的离散(整数)索引，c是像素内的连续(浮点)值。</strong></p>
<p><strong>虽然所有api的像素位置值从左到右递增，但在OpenGL和DirectX之间，顶部和底部边缘的位置0在某些情况下是不一致的。OpenGL始终支持笛卡尔系统，将左下角视为最低值的元素，而DirectX有时会根据上下文将左上角定义为这个元素。每一个问题都有一个逻辑，它们不同的地方没有正确的答案。例如，(0,0)在OpenGL中位于图像的左下角，而在DirectX中位于左上角。在从一个API迁移到另一个API时，要考虑到这种差异。</strong></p>
<h2 id="Rasterization-光栅化"><a href="#Rasterization-光栅化" class="headerlink" title="Rasterization 光栅化"></a>Rasterization 光栅化</h2><p><strong>给定转换和投影的顶点及其相关的着色数据(都来自几何学处理)，下一阶段的目标是找到原始图(例如，一个三角形)中所有的像素。我们称这个过程为光栅化，它被分为两个功能子阶段:三角形设置(也称为原始装配)和三角形遍历。注意，这些也可以处理点和线，但由于三角形是最常见的，子阶段的名称中有“三角形”。光栅化，也称为扫描转换，是将屏幕空间中的二维顶点(每个顶点都有一个z值(深度值)和与每个顶点相关的各种着色信息)转换为屏幕上的像素。光栅化也可以被认为是几何处理和像素处理之间的同步点，因为在这里三角形由三个顶点组成，并最终被发送到像素处理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210907105939.png" class="" title="image-20210907105939">

<p><strong>三角形是否被认为是重叠的像素取决于你如何设置GPU的管道。例如，您可以使用点抽样来确定，最简单的情况是在每个像素的中心使用一个单点样本，所以如果中心点在三角形内，那么相应的像素也被认为在三角形内。您也可以使用超采样或多次采样反锯齿技术，每个像素使用多个样本。另一种方法是使用保守光栅化，其定义是，如果一个像素至少有一部分与三角形重叠，那么该像素就在三角形的“内部”。</strong></p>
<h4 id="Triangle-Setup-三角形设置"><a href="#Triangle-Setup-三角形设置" class="headerlink" title="Triangle Setup 三角形设置"></a>Triangle Setup 三角形设置</h4><p><strong>在这一阶段，计算三角形的微分、边方程和其他数据。这些数据可用于三角遍历，以及由几何阶段产生的各种着色数据的插值。固定功能硬件被用于此操作。</strong></p>
<h4 id="Triangle-Traversal-三角形遍历"><a href="#Triangle-Traversal-三角形遍历" class="headerlink" title="Triangle Traversal 三角形遍历"></a>Triangle Traversal 三角形遍历</h4><p><strong>在这里，每个像素的中心(或样本)被三角形覆盖，并生成一个碎片部分的像素重叠的三角形。找出哪些样本或像素位于三角形内通常称为三角形遍历。每个三角形片段的属性是通过在三个三角形顶点之间插值数据生成的。这些属性包括片段的深度，以及任何来自几何阶段的着色数据。也是在这里，对三角形进行透视校正插值。然后将元素中的所有像素或样本发送到像素处理阶段。</strong></p>
<h2 id="Pixel-Processing-像素处理"><a href="#Pixel-Processing-像素处理" class="headerlink" title="Pixel Processing 像素处理"></a>Pixel Processing 像素处理</h2><p><strong>像素处理阶段分为像素着色和像素合并。像素处理是对原语内部的像素或样本执行逐像素或逐样本计算和操作的阶段。</strong></p>
<h3 id="Pixel-Shading-像素着色器"><a href="#Pixel-Shading-像素着色器" class="headerlink" title="Pixel Shading 像素着色器"></a>Pixel Shading 像素着色器</h3><p><strong>任何逐像素着色计算都在这里执行，使用插值着色数据作为输入。最终的结果是一个或多个颜色被传递到下一个阶段。不同于三角形设置和遍历阶段，它们通常由专用的、硬线连接的硅执行，像素着色阶段是由可编程的GPU核心执行的。为此，程序员为像素着色器(或片段着色器，在OpenGL中它是已知的)提供一个程序，它可以包含任何所需的计算。这里可以使用各种各样的技术，其中最重要的是纹理。简单地说，纹理一个对象意味着“粘合”一个或多个图像到该对象，以实现各种目的。图像可能是一，二，或三维，其中二维图像是最常见的。最简单的是，最终生成是每个片段的颜色值，这些将被传递到下一个子阶段。</strong></p>
<h3 id="Merging-像素合并"><a href="#Merging-像素合并" class="headerlink" title="Merging 像素合并"></a>Merging 像素合并</h3><p><strong>每个像素的信息存储在颜色缓冲区中，颜色缓冲区是由颜色组成的矩形数组(每种颜色由红色、绿色和蓝色组成)。合并阶段负责将像素着色阶段产生的碎片颜色与当前存储在缓冲区中的颜色相结合。这个阶段也被称为ROP，代表“光栅操作(管线)”或“渲染输出单元”，具体取决于您问的是谁。与着色阶段不同，执行此阶段的GPU子单元通常不是完全可编程的。但是，它是高度可配置的，支持各种效果。</strong></p>
<p><strong>这个阶段还负责解决可见性问题。这意味着当整个场景被渲染时，颜色缓冲应该包含场景中从相机角度可见的元素的颜色。对于大多数甚至所有的图形硬件，这是通过z缓冲区(也称为深度缓冲区)算法来实现的。z缓冲区的大小和形状与颜色缓冲区相同，对于每个像素，它存储当前最近的元素的z值。这意味着当一个元素被渲染到某个像素时，该元素在该像素处的z值将被计算并与相同像素处的z缓冲区的内容进行比较。如果新的z值小于z缓冲区中的z值，那么正在渲染的元素将比之前在该像素处最接近摄像机的元素更接近摄像机。因此，该像素的z值和颜色将更新为所绘制的元素的z值和颜色。如果计算的z值大于z缓冲区中的z值，则颜色缓冲区和z缓冲区将保持不变。z缓冲区算法很简单，有O(n)收敛性(n是被渲染的元素数量)，并且适用于任何可以为每个(相关)像素计算z值的绘制元素。还要注意，该算法允许以任何顺序呈现大多数元素，这是它流行的另一个原因。然而，z缓冲区仅在屏幕上的每个点存储单个深度，因此它不能用于半透明的元素。这些元素必须在所有不透明元素之后呈现，并且按照前后顺序呈现，或者使用独立于顺序的算法。透明度是基本z缓冲区的主要弱点之一。</strong></p>
<p><strong>我们已经提到，颜色缓冲区用于存储颜色，而z缓冲区用于存储每个像素的z值。然而，还有其他通道和缓冲区可以用来过滤和捕获片段信息。alpha通道与颜色缓冲相关联，并为每个像素存储相关的不透明度值。在较早的API中，alpha通道也被用来通过alpha测试特性选择性地丢弃像素。现在，丢弃操作可以被插入到像素着色程序中，任何类型的计算都可以用来触发丢弃。这种类型的测试可以用来确保完全透明的片段不会影响z缓冲区。</strong></p>
<p><strong>模板缓冲区是一个屏幕外缓冲区，用于记录所呈现元素的位置。它通常包含每像素8位。元素可以使用各种函数呈现到模板缓冲区中，然后可以使用缓冲区的内容控制渲染到颜色缓冲和z缓冲。模板缓冲区是生成一些特殊效果的强大工具。管线末尾的所有这些函数都称为光栅操作(ROP)或混合操作。可以将颜色缓冲中当前的颜色与三角形中正在处理的像素的颜色混合。这可以实现诸如透明度或颜色样本积累等效果。如前所述，混合通常是使用API配置的，而不是完全可编程的。然而，一些API支持光栅顺序视图，也称为像素着色顺序，它支持可编程混合功能。</strong></p>
<p><strong>绘图缓冲区通常由系统上的所有缓冲区组成。</strong></p>
<p><strong>当元素达到并通过光栅化阶段时，那些从相机角度可见的元素就显示在屏幕上。屏幕显示颜色缓冲的内容。为了避免让显示器看到被光栅化并发送到屏幕的元素，使用了双重缓冲。这意味着场景的呈现发生在屏幕之外的后台缓冲区中。在后台缓冲区中渲染场景后，后台缓冲区的内容将与之前显示在屏幕上的前台缓冲区的内容交换。交换通常发生在垂直回描期间，此时这样做是安全的。</strong></p>
<h2 id="Through-the-Pipeline-完成管线"><a href="#Through-the-Pipeline-完成管线" class="headerlink" title="Through the Pipeline 完成管线"></a>Through the Pipeline 完成管线</h2><p><strong>点、线和三角形是用来构建模型或对象的渲染原语。假设该应用程序是一个交互式计算机辅助设计(CAD)应用程序，用户正在检查华夫饼机的设计。在这里，我们将遵循这个模型完成整个图形渲染流水线，包括四个主要阶段:应用程序、几何、光栅化和像素处理。场景以透视图呈现在屏幕上的一个窗口中。</strong></p>
<h3 id="Application-应用程序"><a href="#Application-应用程序" class="headerlink" title="Application 应用程序"></a>Application 应用程序</h3><p><strong>CAD应用程序允许用户选择和移动模型的部分。对于要渲染的每一帧，应用程序阶段将摄像机位置、照明和模型的原语提供给管道中的下一个主要阶段——几何阶段。</strong></p>
<h3 id="Geometry-Processing-几何处理-1"><a href="#Geometry-Processing-几何处理-1" class="headerlink" title="Geometry Processing 几何处理"></a>Geometry Processing 几何处理</h3><p><strong>对于透视图，我们假设应用程序已经提供了一个投影矩阵。此外，对于每个对象，应用程序已经计算了一个矩阵，该矩阵描述了视图转换以及对象本身的位置和方向。在几何阶段，对象的顶点和法线用这个矩阵进行变换，将对象放入视图空间。然后使用材质和光源属性计算顶点的着色或其他计算。然后使用一个单独的用户提供的投影矩阵来执行投影，将对象转换为表示人眼所看到的单位立方体空间。立方体之外的所有元素都将被丢弃。所有与这个单元立方体相交的元素都被剪切到立方体上，以获得一组完全位于该单元立方体内部的原语。然后这些顶点被映射到屏幕上的窗口中。在所有这些每个三角形和每个顶点的操作完成之后，得到的数据被传递到光栅化阶段。</strong></p>
<h3 id="Rasterization-光栅化-1"><a href="#Rasterization-光栅化-1" class="headerlink" title="Rasterization 光栅化"></a>Rasterization 光栅化</h3><p><strong>在前一阶段裁剪下来的所有元素都被光栅化，这意味着元素中的所有像素都被找到，并通过管道进一步发送到像素处理。</strong></p>
<h3 id="Pixel-Processing-像素处理-1"><a href="#Pixel-Processing-像素处理-1" class="headerlink" title="Pixel Processing 像素处理"></a>Pixel Processing 像素处理</h3><p><strong>这里的目标是计算每个可见元素的每个像素的颜色。那些与任何纹理(图像)相关联的三角形将根据需要使用这些图像进行渲染。可见性通过z缓冲区算法解决，以及可选的丢弃和模板测试。每个对象都被依次处理，最后的图像就会显示在屏幕上。</strong></p>
<h3 id="Conclusion-总结"><a href="#Conclusion-总结" class="headerlink" title="Conclusion 总结"></a>Conclusion 总结</h3><p><strong>这个管道是几十年来针对实时渲染应用程序的API和图形硬件发展的结果。需要注意的是，这并不是唯一可能的渲染管线;离线渲染管线经历了不同的进化路径。电影制作中的渲染通常是用微多边形管线完成的，但光线追踪和路径追踪最近开始流行。</strong></p>
<p><strong>多年来，应用程序开发人员使用这里描述的过程的唯一方法是通过正在使用的图形API定义的固定函数管线。固定函数管线之所以如此命名，是因为实现它的图形硬件由无法以灵活方式编程的元素组成。上一个大型固定功能游戏机的例子是任天堂(Nintendo)于2006年推出的Wii游戏机。另一方面，可编程GPU可以精确地确定在整个管线的各个子阶段中应用了哪些操作。</strong></p>
<h1 id="3-The-Graphics-Processing-Unit-图形处理单元"><a href="#3-The-Graphics-Processing-Unit-图形处理单元" class="headerlink" title="3 The Graphics Processing Unit 图形处理单元"></a>3 The Graphics Processing Unit 图形处理单元</h1><h2 id="Data-Parallel-Architectures-数据并行架构"><a href="#Data-Parallel-Architectures-数据并行架构" class="headerlink" title="Data-Parallel Architectures 数据并行架构"></a>Data-Parallel Architectures 数据并行架构</h2><p><strong>不同的处理器体系结构使用不同的策略来避免停顿。CPU被优化以处理各种各样的数据结构和大型代码库。CPU可以有多个处理器，但每个处理器主要以串行方式运行代码，限制SIMD向量处理是一个次要的异常。为了最小化延迟的影响，CPU的大部分芯片由快速本地缓存组成，内存中充满了可能需要的数据。CPU还通过使用分支预测、指令重排序、寄存器重命名和缓存预取等技术来避免停顿。</strong></p>
<p><strong>GPU采用不同的方法。GPU的大部分芯片区域都是专门用于一组大型处理器，称为着色器核心，通常有数千个。GPU是一种流处理器，它依次处理相似数据的有序集。由于这种相似性(例如一组顶点或像素)，GPU可以以大规模并行方式处理这些数据。另一个重要的因素是，这些调用尽可能独立，这样它们就不需要从相邻的调用获取信息，也不共享可写内存位置。这条规则有时会被打破，以允许新的和有用的功能，但这种异常的代价是潜在的延迟，因为一个处理器可能会等待另一个处理器完成它的工作。</strong></p>
<p><strong>GPU为吞吐量进行了优化，吞吐量定义为数据可处理的最大速率。然而，这种快速处理是有代价的。由于专用于高速缓存内存和控制逻辑的芯片面积更少，每个着色器核心的延迟通常比CPU处理器遇到的要高得多。</strong></p>
<p><strong>假设一个网格被光栅化了，需要处理两千个像素碎片;一个像素着色程序将被调用2000次。假设是世界上最弱的GPU，只有一个着色器处理器。它开始为2000的第一个片段执行着色程序。着色处理器对寄存器中的值执行一些算术操作。注册是本地的和快速的进入，所以不会发生失速。然后，着色器处理器进入一个指令，例如，对于给定的表面位置，程序需要知道应用到网格上的图像的像素颜色。纹理是一个完全独立的资源，而不是像素程序本地内存的一部分，并且纹理访问可能会涉及一些内容。一次内存获取可能需要数百到数千个时钟周期，在此期间GPU处理器不做任何事情。此时，着色器处理器将暂停，等待纹理的颜色值返回。</strong></p>
<p><strong>为了让这个GPU变得更好，我们需要为每个片段提供一些存储空间用于其本地寄存器。现在，着色处理器可以切换并执行另一个片段，2000中的第2个片段，而不是在获取纹理时停滞不前。这个切换非常快，除了注意哪个指令在第一个指令上执行之外，第一个或第二个片段中没有任何影响。现在执行第二个片段。与第一个相同，执行一些算术函数，然后再次遇到纹理获取。着色器核心现在切换到另一个片段，三号。最终，所有2000个片段都以这种方式处理。此时，着色器处理器返回到片段1。此时纹理颜色已经被获取，可以使用，所以着色程序可以继续执行。处理器以同样的方式继续执行，直到遇到另一条已知会导致执行暂停的指令，或者程序完成。一个单独的片段将花费比如果着色处理器关注它更长的时间来执行，但整体上片段的整体执行时间大大减少。</strong></p>
<p><strong>在这个架构中，通过切换到另一个片段让GPU保持忙碌，可以隐藏延迟。GPU通过将指令执行逻辑与数据分离，将这种设计向前推进了一步。被称为单指令多数据(SIMD)，这种安排在固定数量的着色程序上以锁步的方式执行相同的命令。SIMD的优点是，与使用单独的逻辑和调度单元来运行每个程序相比，用于处理数据和切换的硅(和功率)要少得多。把我们的2000个碎片的例子转换成现代的GPU术语，每个碎片的像素着色器调用被称为线程。这种类型的线程不像CPU线程。它包含一些内存，用于给着色器输入值，以及着色器执行所需的任何寄存器空间。使用相同着色程序的线程被捆绑成组，NVIDIA称之为“warps”，AMD称之为“wavefronts”。warp/wavefront被安排由一些数字GPU着色核执行，从8到64，使用SIMD处理。每个线程都映射到一个SIMD通道。</strong></p>
<p><strong>假设我们有两千个线程要执行。NVIDIA GPU上的warps包含32个线程。这就产生了2000/32 = 62.5条warps，这意味着分配了63条warps，其中一条warp是半空的。warp的执行类似于我们的单一GPU处理器的例子。着色程序在所有32个处理器上执行。当遇到内存获取时，所有线程都同时遇到它，因为对所有线程执行相同的指令。信号表明这个扭曲的线程将停止，所有线程都在等待它们的(不同的)结果。而不是拖延，warp被替换为32个线程的不同warp，然后由32个内核执行。这种交换就像我们的单处理器系统一样快，因为当warp被交换时，每个线程内的数据都不会被接触。每个线程都有自己的寄存器，每个warp跟踪它正在执行的指令。在一个新的warp中，交换只是将一组核心指向另一组要执行的线程;没有其他费用。执行或换出warps，直到全部完成。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210909104537.png" class="" title="image-20210909104537">

<p>简化的着色器执行示例。三角形的碎片，也就是所谓的线程，被聚拢成warps。每条warp显示为四根线程，但实际上有32根线程。要执行的着色程序有5个指令长。四个GPU着色处理器的集合执行这些指令，直到“txr”命令检测到一个暂停条件，这需要时间来获取它的数据。第二个warp被调换，着色程序的前三个指令被应用到它，直到再次检测到失速。在第三次跃迁被交换并停止后，执行继续通过交换第一次跃迁并继续执行。如果此时它的“txr”命令的数据还没有返回，那么执行将真正停止，直到这些数据可用为止。每条warp依次整理。</p>
<p><strong>在我们的简单示例中，为纹理获取内存的延迟可能会导致warp的交换。在现实中，由于交换的成本很低，可以用更短的延迟来交换warp。还有其他一些技术用于优化执行，但warp交换是所有GPU使用的主要延迟隐藏机制。这一过程的工作效率涉及到几个因素。例如，如果线程很少，那么创建很少的warp，从而造成延迟隐藏的问题。</strong></p>
<p><strong>着色程序的结构是影响效率的一个重要特征。一个主要因素是每个线程的寄存器使用量。在我们的例子中，我们假设两千个线程可以同时驻留在GPU上。与每个线程关联的着色程序需要的寄存器越多，驻留在GPU中的线程就越少，因此warp也就越少。缺乏warp可能意味着失速不能通过交换来缓解。常驻的warp被称为“in flight”，这个数字被称为占用率。高占用率意味着有许多可处理的warp，因此空闲处理器的可能性较小。占用率低往往会导致性能不佳。内存获取的频率也会影响需要多少延迟隐藏。</strong></p>
<p><strong>另一个影响整体效率的因素是由“if”语句和循环引起的动态分支。假设在着色程序中遇到了一个“if”语句。如果所有的线程都计算并使用同一个分支，那么warp就可以继续运行而不需要考虑其他分支。然而，如果一些线程，甚至是一个线程，采用了替代路径，那么warp必须执行两个分支，抛弃每个特定线程不需要的结果。这个问题被称为线程发散，在这种情况下，一些线程可能需要执行一个循环迭代或执行一个“if”路径，而在warp中其他线程不需要，这使得它们在这段时间内处于空闲状态。</strong></p>
<p><strong>所有GPU都实现了这些架构思想，导致系统受到严格的限制，但每瓦特的计算能力却是巨大的。了解这个系统是如何运行的，将有助于作为程序员的您更有效地利用它提供的功能。</strong></p>
<h2 id="GPU-Pipeline-Overview-GPU管线概述"><a href="#GPU-Pipeline-Overview-GPU管线概述" class="headerlink" title="GPU Pipeline Overview GPU管线概述"></a>GPU Pipeline Overview GPU管线概述</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210909104608.png" class="" title="image-20210909104608">

<p>GPU实现的渲染管线。这些阶段根据用户对其操作的控制程度用颜色编码。绿色阶段是完全可编程的。虚线表示可选阶段。黄色阶段是可配置的，但不能编程。蓝色阶段的功能是完全固定的。</p>
<p><strong>这里描述的是GPU的逻辑模型，作为程序员的你可以通过API看到它。这个逻辑管道(物理模型)的实现取决于硬件供应商。通过向相邻的可编程阶段添加命令，可以在GPU上执行逻辑模型中具有固定功能的阶段。管道中的单个程序可以被分割成由单独的子单元执行的元素，也可以完全由单独的传递执行。逻辑模型可以帮助你推断什么会影响性能，但它不应该被误解为GPU实际实现管道的方式。</strong></p>
<p><strong>顶点着色器是一个完全可编程的阶段，用于实现几何处理阶段。</strong></p>
<p><strong>几何着色器是一个完全可编程的阶段，操作的顶点的一个基本(点，线，或三角形)。它可以用来执行每个元素的着色操作，销毁元素，或者创建新的元素。</strong></p>
<p><strong>曲面细分阶段和几何着色器都是可选的，并不是所有的GPU都支持它们，特别是在移动设备上。</strong></p>
<p><strong>裁剪、三角形设置和三角形遍历阶段由固定功能的硬件实现。</strong></p>
<p><strong>屏幕映射受窗口和视口设置的影响，在内部形成一个简单的比例和重新定位。</strong></p>
<p><strong>像素着色器阶段是完全可编程的。虽然合并阶段不是可编程的，但它是高度可配置的，可以设置以执行各种各样的操作。它实现了“合并”功能阶段，负责修改颜色、z缓冲区、混合、模板和任何其他输出相关的缓冲区。</strong></p>
<p><strong>随着时间的推移，GPU流水线已经从硬编码操作发展到越来越灵活和控制。可编程着色器阶段的引入是这个发展过程中最重要的一步。</strong></p>
<h2 id="The-Programmable-Shader-Stage-可编程着色器平台"><a href="#The-Programmable-Shader-Stage-可编程着色器平台" class="headerlink" title="The Programmable Shader Stage 可编程着色器平台"></a>The Programmable Shader Stage 可编程着色器平台</h2><p><strong>现代着色程序使用统一的着色器设计。这意味着顶点、像素、几何和细分相关的着色器共享一个共同的编程模型。它们在内部具有相同的指令集体系结构(ISA)。实现这个模型的处理器被称为DirectX中的common-shader core，具有这种内核的GPU被称为具有统一的着色器架构。这种架构背后的想法是，着色处理器可以用于多种角色，GPU可以根据需要分配。拥有独立的顶点和像素着色器核池的GPU意味着保持所有核繁忙的理想工作分布是严格预定的。使用统一的着色器内核，GPU可以决定如何平衡这种负载。</strong></p>
<p><strong>着色器使用类似C的着色语言编程，如DirectX的高级着色语言(HLSL)和OpenGL着色语言(GLSL)。DirectX的HLSL可以编译为虚拟机字节码，也称为中间语言(IL或dxie)，以提供硬件独立性。中间表示法也可以让着色程序离线编译和存储。该中间语言被驱动程序转换为特定GPU的ISA。控制台编程通常避免中间语言步骤，因为那时系统只有一个ISA。</strong></p>
<p><strong>基本的数据类型是32位单精度浮点标量和向量，尽管向量只是着色器代码的一部分，并且在上面概述的硬件中不支持。在现代GPU上，本地也支持32位整数和64位浮点数。浮点向量通常包含位置(xyzw)、法线、矩阵行、颜色(rgba)或纹理坐标(uvwq)等数据。整数最常用于表示计数器、索引或位掩码。还支持聚合数据类型，如结构、数组和矩阵。</strong></p>
<p><strong>一个绘制调用调用图形API来绘制一组元素，以此让图形管线执行和运行它的着色器。每个可编程着色器阶段有两种类型的输入:统一的输入，在整个绘制调用中保持不变的值(但可以在绘制调用之间改变)，和不同的输入，来自三角形顶点或光栅化的数据。纹理是一种特殊的统一输入，它曾经是应用于表面的彩色图像，但现在它可以被认为是任何大的数据数组。</strong></p>
<p><strong>底层虚拟机为不同类型的输入和输出提供了特殊的寄存器。统一虚拟机中可用的常数寄存器的数量要比用于不同输入或输出的寄存器多得多。这是因为不同的输入和输出需要分别存储在每个顶点上或像素，所以需要的数量是有自然限制的。统一输入存储一次，并在draw调用中的所有顶点或像素中重用。虚拟机还有通用的临时寄存器，用于临时存储空间。所有类型的寄存器都可以在临时寄存器中使用整数值进行数组索引</strong>。</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210910125455.png" class="" title="image-20210910125455">

<p>统一的虚拟机架构和注册布局，在Shader Model 4.0下。最大可用数量在每个资源旁边指示。用斜杠分隔的三个数字表示顶点、几何和像素着色器的限制(从左到右)。</p>
<p><strong>图形计算中常见的操作可以在现代GPU上高效地执行。着色器语言通过操作符*和+暴露了这些最常见的操作(如加法和乘法)。其余的通过内在函数暴露，例如，atan()， sqrt()， log()和许多其他的，为GPU优化。函数也存在更复杂的运算，如向量的标准化和反射，叉积，矩阵转置和行列式计算。</strong></p>
<p><strong>术语流控制指的是使用分支指令来更改代码执行流。与流控制相关的指令用于实现高级语言结构，如“if”和“case”语句，以及各种类型的循环。着色器支持两种类型的流量控制。静态流量控制分支基于统一输入的值。这意味着代码流在draw调用中是不变的。静态流量控制的主要好处是允许相同的着色器在不同的情况下使用(例如，不同数量的灯光)。没有线程分歧，因为所有调用都采用相同的代码路径。动态流控制是基于不同的输入值，这意味着每个片段可以以不同的方式执行代码。这比静态流控制更强大，但会降低性能，特别是当代码流在着色器调用之间变化不稳定时。</strong></p>
<h2 id="The-Evolution-of-Programmable-Shading-and-APIs-可编程着色器和API的演变"><a href="#The-Evolution-of-Programmable-Shading-and-APIs-可编程着色器和API的演变" class="headerlink" title="The Evolution of Programmable Shading and APIs 可编程着色器和API的演变"></a>The Evolution of Programmable Shading and APIs 可编程着色器和API的演变</h2><p>可编程着色器框架的想法可以追溯到1984年Cook的着色树。RenderMan着色语言是在20世纪80年代后期从这个想法发展而来的。它今天仍然被用于电影制作渲染，以及其他不断发展的规范，如开放着色语言(OSL)项目。<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210910132418.png" class="" title="image-20210910132418"></p>
<p>着色树是一个简单的镜面着色器。</p>
<p><strong>1996年10月1日，3dfx Interactive首次成功地推出了消费者级图形硬件。他们的Voodoo显卡能够渲染游戏《雷神之锤》的高质量和性能，这使得它很快被采用。这个硬件实现了一个固定功能的管线。在GPU原生支持可编程着色器之前，通过多个渲染通道实现可编程着色操作的尝试很多。1999年《雷神之锤3:竞技场》的脚本语言最先被广泛使用，并取得了商业上的成功。NVIDIA的GeForce256是第一个被称为GPU的硬件，但它不是可编程的。然而，它是可配置的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210910132709.png" class="" title="image-20210910132709">

<p>一些API和图形硬件发布的时间表。</p>
<p><strong>在2001年初，NVIDIA的GeForce 3是第一个支持可编程顶点着色器的GPU，通过DirectX 8.0和OpenGL扩展。这些着色器是用一种类似汇编语言的语言编写的，驱动程序会在运行时将其转换成微码。DirectX 8.0中也包含了像素着色器，但像素着色器缺乏实际的可编程性——受支持的有限的“程序”被驱动程序转换成纹理混合状态，然后将硬件“寄存器组合器”连接在一起。这些“程序”不仅长度有限(12条或更少)，而且缺乏重要的功能。Peercy等人通过对RenderMan的研究发现，依赖纹理读取和浮点数据对真正的可编程性至关重要。</strong></p>
<p><strong>当时的着色器不允许流控制(分支)，所以条件必须通过计算术语和选择或插值结果来模拟。DirectX定义了着色器模型(SM)的概念，以区分具有不同着色器功能的硬件。2002年，DirectX 9.0发布了，其中包括Shader Model 2.0，它以可编程的顶点和像素着色器为特色。OpenGL使用各种扩展也暴露了类似的功能。增加了对任意依赖纹理读取和存储16位浮点值的支持，最终完成了Peercy等人确定的需求集。对材质资源(如指令、纹理和寄存器)的限制增加了，所以材质能够产生更复杂的效果。还添加了对流量控制的支持。着色器不断增长的长度和复杂性使得汇编编程模型越来越麻烦。幸运的是,DirectX 9.0还包括HLSL。这种着色语言是由微软与NVIDIA合作开发的。大约在同一时间，OpenGL ARB(架构审查委员会)发布了GLSL，一种与OpenGL相当相似的语言。这些语言深受C编程语言的语法和设计哲学的影响，并包含了来自RenderMan着色语言的元素。</strong></p>
<p><strong>Shader Model 3.0于2004年推出，并添加了动态流控制，使Shader变得更加强大。它还将可选功能转变为需求，进一步增加了资源限制，并添加了有限的顶点着色器纹理读取支持。2005年末，当新一代游戏机(Mi- crosoft的Xbox 360)和2006年末(索尼电脑娱乐(Sony Computer Entertainment)的PLAYSTATION 3系统)推出时，它们都配备了Shader Model 3.0级GPU。任天堂的Wii游戏机是最后一批引人注目的固定功能GPU之一，最初是在2006年底发布的。纯固定函数的管线早已不复存在。着色器语言已经发展到一个点，各种工具被用来创建和管理它们。</strong></p>
<p><strong>可编程性的下一个大进步也在2006年底出现。Shader Model 4.0，包含在DirectX 10.0中，引入了几个主要功能，如几何着色器和流输出。着色器模型4.0包括一个统一编程模型的所有着色器(顶点，像素，和几何)。资源限制进一步增加，并增加了对整数数据类型(包括位操作)的支持。OpenGL 3.3中引入的GLSL 3.30提供了一个类似的着色器模型。</strong></p>
<p><strong>在2009年DirectX 11和Shader Model 5.0发布，添加了细分着色器和计算着色器，也称为DirectCompute。该版本还关注于更有效地支持CPU多处理。OpenGL在4.0版增加了细分，在4.3版增加了计算着色器。DirectX和OpenGL的发展是不同的。两者都为特定版本版本设置了所需的特定级别的硬件支持。微软控制DirectX API，因此直接与独立硬件供应商(IHVs)，如AMD、NVIDIA和英特尔，以及游戏开发者和计算机辅助设计软件公司合作，以确定要公开哪些特性。OpenGL由一个硬件和软件供应商联盟开发，由非营利组织Khronos Group管理。由于涉及的公司很多，API特性OpenGL的发布版通常会在DirectX之后。然而，OpenGL允许扩展，供应商特定的或更一般的，允许最新的GPU功能在官方支持之前在发布。</strong></p>
<p><strong>API的下一个重大变化是由AMD在2013年引入的Mantle API。《Mantle》是与电子游戏开发商DICE合作开发的，其理念是剥离大部分图像驱动程序的开销，将控制权直接交给开发者。除了重构之外，还进一步支持有效的CPU多处理。这类新的API主要关注于极大地减少CPU在驱动程序中花费的时间，以及更有效的CPU多处理器支持。在Mantle中首创的想法被微软采纳，并于2015年发布为DirectX 12。请注意，DirectX 12并不专注于暴露新的GPU功能——DirectX 11.3暴露了相同的硬件特性。这两个API都可以用来向Oculus Rift和HTC Vive等虚拟现实系统发送图像。然而，DirectX 12是一个彻底的重新设计的API，一个更好地映射到现代GPU的架构。低开销驱动对于CPU驱动成本造成瓶颈的应用程序很有用，或者使用更多的CPU处理器来处理图形可以提高性能。从早期的API移植可能会很困难，而且简单的实现可能会导致较低的性能。</strong></p>
<p><strong>苹果在2014年发布了自己的低开销API Metal。iPhone 5S和iPad Air等移动设备首先可以使用Metal功能，一年后，新版麦金塔电脑也可以通过OS X El Capitan接入。除了效率，降低CPU的使用还可以节省电力，这是移动设备的一个重要因素。这个API有自己的着色语言，适用于图形和GPU计算程序。</strong></p>
<p><strong>AMD将其Mantle工作捐赠给了Khronos集团，后者在2016年初发布了自己的新API Vulkan。与OpenGL一样，Vulkan可以在多种操作系统上运行。Vulkan使用一种新的高级中间语言SPIR- V，它既用于着色器表示，也用于一般的GPU计算。预编译着色器是可移植的，所以可以在任何支持的GPU上使用需要的功能。Vulkan也可以用于非图形GPU计算，因为它不需要显示窗口。Vulkan与其他低功耗驱动程序的一个显著区别是，它适用于从工作站到移动设备的各种系统。</strong></p>
<p><strong>在移动设备上，标准是使用OpenGL ES。“ES”代表嵌入式系统，因为这个API是为移动设备开发的。当时的标准OpenGL在一些调用结构上相当笨重和缓慢，并且需要对很少使用的功能的支持。发布于2003年的OpenGL ES 1.0是OpenGL 1.3的精简版，描述了一个固定功能的管线。虽然DirectX的发布与支持它们的图形硬件同步，但开发移动设备的图形支持并没有以同样的方式进行。例如，2010年发布的第一代iPad就实现了OpenGL ES 1.1。2007年，OpenGL ES 2.0规范发布，提供可编程着色器。它基于OpenGL 2.0，但没有固定功能组件，因此不向后兼容OpenGL ES 1.1。OpenGL ES 3.0于2012年发布，提供了多种渲染目标、纹理压缩、变换反馈、实例化以及更广泛的纹理格式和模式，以及着色器语言的改进。OpenGL ES 3.1增加了计算着色器，3.2增加了几何和镶嵌着色器等功能。</strong></p>
<p><strong>OpenGL ES的一个分支是基于浏览器的API WebGL，通过JavaScript调用。这个API的第一个版本发布于2011年，可以在大多数移动设备上使用，因为它在功能上相当于OpenGL ES 2.0。与OpenGL一样，扩展提供了更高级的GPU特性。WebGL 2假定支持OpenGL ES 3.0。</strong></p>
<p><strong>WebGL特别适合实验功能或在课堂上使用:</strong></p>
<pre><code>**它是跨平台的，可以在所有个人电脑和几乎所有移动设备上运行。**

**驱动程序审批由浏览器处理。即使一个浏览器不支持特定的GPU或扩展，也会有另一个浏览器支持。**

**代码是解释的，而不是编译的，开发只需要一个文本编辑器。**

**大多数浏览器都内置了调试器，可以检查在任何网站上运行的代码。**

**程序可以通过上传到网站或Github来部署。**
</code></pre>
<p><strong>更高级的场景图和效果库，如three.js，可以方便地访问各种更复杂的效果的代码，如阴影算法、后期处理效果、基于物理的着色和延迟渲染。</strong></p>
<h2 id="The-Vertex-Shader-顶点着色器"><a href="#The-Vertex-Shader-顶点着色器" class="headerlink" title="The Vertex Shader 顶点着色器"></a>The Vertex Shader 顶点着色器</h2><p><strong>顶点着色器是函数函数管线中的第一阶段。虽然这是直接由程序员控制的第一阶段，但值得注意的是，在此阶段之前发生了一些数据操作。在DirectX调用的输入汇编器中，几个数据流可以编织在一起，形成沿管线发送的顶点和原语集。输入汇编器将通过创建带有位置和颜色的顶点来创建对象的三角形(或线或点)。第二个对象可以使用相同的位置数组(以及不同的模型转换矩阵)和不同的颜色数组来表示它。在输入汇编程序中也支持执行实例化。这允许一个对象用每个实例的一些变化的数据绘制多次，所有这些都只用一个绘制调用。</strong></p>
<p><strong>三角形网格由一组顶点表示，每个顶点都与模型表面上的特定位置相关联。除了位置之外，每个顶点还有其他可选属性，比如颜色或纹理坐标。表面法线也定义在网格顶点，这似乎是一个奇怪的选择。数学上，每个三角形都有一个明确定义的表面法线，它可能更有意义使用三角形的法线直接进行着色。然而，在渲染时，三角形网格通常被用来表示一个底层曲面，顶点法线被用来表示曲面的方向，而不是三角形网格本身的方向。下图显示了两个代表曲面的三角形网格的侧视图，一个平滑，一个有尖锐的折痕。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210911111517.png" class="" title="image-20210911111517">

<p>三角形网格的侧视图(黑色，顶点法线)表示曲面(红色)。在左边平滑的顶点法线被用来表示平滑的表面。在右边，中间顶点被复制，并给出两条法线，表示一条折痕。</p>
<p><strong>顶点着色器是处理三角形网格的第一阶段。顶点着色器无法获得描述三角形形成的数据。顾名思义，它只处理传入的顶点。顶点着色器提供了一种方法修改、创建或忽略与每个三角形顶点相关的值，如其颜色、法线、纹理坐标和位置。通常顶点着色程序将顶点从模型空间转换到均匀裁剪空间。至少，顶点着色器必须始终输出这个位置。</strong></p>
<p><strong>顶点着色器与前面描述的统一着色器非常相似。每个传入的顶点都由顶点着色程序处理，然后输出一些值，这些值被插入到三角形或直线上。顶点着色器既不能创建也不能销毁顶点，一个顶点生成的结果不能传递到另一个顶点。因为每个顶点都是独立处理的，所以GPU上的任意数量的着色器处理器都可以并行应用于传入的顶点流。</strong></p>
<p><strong>输入装配通常是在执行顶点着色器之前出现的一个过程。在这个例子中，物理模型经常与逻辑模型不同。物理上，获取数据来创建顶点可能会发生在顶点着色器中，驱动程序会悄悄地为每个着色器添加适当的指令，而程序员是看不见的。</strong></p>
<p><strong>顶点着色器的其他用途包括:</strong></p>
<pre><code>**对象生成，只创建一个网格，并让它被顶点着色器变形。**

**使用蒙皮和变形技术制作动画角色的身体和脸。**

**程序变形，如旗帜、布料或水的移动。**

**粒子创建，发送简化(无区域)网格给管线和有这些需要的区域。**

**通过使用整个帧缓冲区的内容作为纹理在屏幕对齐的网格上进行程序变形，镜头失真、热雾、水波纹、页面卷曲和其他效果。**

**使用顶点纹理获取来应用地形高度域。**
</code></pre>
<p><strong>顶点着色器的输出可以用几种不同的方式来使用。通常的路径是每个实例的原语，例如，三角形，然后被生成和栅格化，产生的单个像素碎片被发送到像素着色程序继续处理。在一些GPU上，数据也可以发送到细分阶段或几何着色器或存储在内存中。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210911112605.png" class="" title="image-20210911112605">

<p>左边是一个普通的茶壶。一个简单的剪切操作执行顶点着色程序产生中间的图像。在右边，一个噪声函数创建了一个扭曲模型的场。(图片由FX Composer 2制作，NVIDIA公司提供。)</p>
<h2 id="The-Tessellation-Stage-镶嵌细分阶段"><a href="#The-Tessellation-Stage-镶嵌细分阶段" class="headerlink" title="The Tessellation Stage 镶嵌细分阶段"></a>The Tessellation Stage 镶嵌细分阶段</h2><p><strong>镶嵌细分阶段允许我们渲染曲面。GPU的任务是获取每个表面描述，并将其转换成一组具有代表性的三角形。这个阶段是一个可选的GPU特性，它首先在DirectX 11中可用(并且是必需的)。OpenGL 4.0和OpenGL ES 3.2也支持它。</strong></p>
<p><strong>使用镶嵌细分有几个优点。曲面的描述往往比提供相应的三角形本身更紧凑。除了节省内存，这一特性还可以避免CPU和GPU之间的总线成为动画角色或每帧形状都在变化的对象的瓶颈。通过为给定的视图生成适当数量的三角形，可以有效地渲染表面。例如，如果一个球离相机很远，那么只需要几个三角形。近距离观察，它可能用数千个三角形表现得最好。这种控制细节级别的能力也允许应用程序控制其性能，例如，使用较弱的GPU上的较低质量的网格来维持帧率。通常由平面表示的模型可以转换为三角形细网格，然后根据需要进行弯曲，或者可以对模型进行镶嵌，以减少昂贵的着色计算。</strong></p>
<p><strong>镶嵌细分通常由三个要素组成。使用DirectX的术语，这些是外壳着色器，镶嵌器和域着色器。在OpenGL中，外壳着色器是镶嵌控制着色器，域着色器是镶嵌评估着色器。固定函数tesselator在OpenGL中被称为原始生成器。</strong></p>
<p><strong>首先，外壳着色器的输入是一个特殊的补丁原语。它由几个控制点组成，定义细分曲面、贝塞尔贴片或其他类型的曲面元素。外壳着色器有两个功能。首先，它告诉镶嵌器应该生成多少个三角形，以及在什么配置中。其次，它对每个控制点执行处理。此外，可选的，外壳着色器可以修改传入补丁描述，根据需要添加或删除控制点。船体着色器输出它的控制点集，连同镶嵌控制数据，到域着色器。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210911130526.png" class="" title="image-20210911130526">

<p>镶嵌细分阶段。外壳着色器采用了一个由控制点定义的补丁。它将镶嵌因子(TFs)和类型发送给固定功能镶嵌器。控制点集被转换为所需的外壳着色器，连同TFs和相关的补丁常量，发送到域着色器。镶嵌器创建顶点集及其重心坐标。然后这些被域着色器处理，产生三角形网格(控制点显示为参考)。</p>
<p><strong>镶嵌器是管线中的一个固定功能阶段，只与镶嵌着色器一起使用。它的任务是为域着色器添加几个新的顶点来处理。外壳着色器向镶嵌器发送关于需要哪种类型的镶嵌表面的信息:三角形、四边形或等值线（等值线是一组线条，有时用于头发渲染）。船体着色器发送的其他重要值是镶嵌因子(OpenGL中的镶嵌级别)。这些有两种类型:内边缘和外边缘。这两个内部因素决定了多少镶嵌发生在三角形或四边形内部。外部因素决定每条外部边被分割的程度。通过允许单独的控制，我们可以让相邻曲面的边缘在镶嵌中匹配，而不管内部是如何镶嵌的。匹配的边缘避免了裂缝或其他着色的地方的斑块。顶点被赋以重心坐标，这些值指定了所需曲面上每个点的相对位置。</strong></p>
<p><strong>外壳着色器总是输出一个补丁，一组控制点位置。但是，它可以通过向镶嵌器发送0或更小的外部镶嵌级别(或非数字，NaN)来表示要丢弃补丁。否则，镶嵌器生成一个网格并将其发送到域着色器。曲面的控制点来自于外壳着色器，用于每次调用域着色器来计算每个顶点的输出值。域着色器有一个类似于顶点着色器的数据流模式，每个来自镶嵌器的输入顶点都被处理并生成相应的输出顶点。然后形成的三角形沿着管线传递下去。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210911131217.png" class="" title="image-20210911131217">

<p>改变镶嵌因素的影响。The Utah teapot由32块面片组成。内、外镶嵌因子从左到右分别为1、2、4、8。(图片由Rideout和Van Gelder的演示生成。)</p>
<p><strong>虽然这个系统听起来很复杂，但它的结构是这样的效率，每个着色器都可以相当简单。进入外壳着色器的补丁通常很少或没有修改。这个着色器也可以使用补丁的估计距离或屏幕大小来实时计算镶嵌因子，如地形渲染。另外，外壳着色器可以简单地传递应用程序计算和提供的所有补丁的一组固定值。镶嵌器执行一个复杂但功能固定的过程，生成顶点，给出它们的位置，并指定它们形成的三角形或直线。为了提高计算效率，数据放大步骤在着色器之外执行。域着色器获取每个点生成的重心坐标，并在补丁的评估方程中使用这些坐标来生成位置、法线、纹理坐标和其他所需的顶点信息。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210911132016.png" class="" title="image-20210911132016">

<p>左边是由6000个三角形组成的网格。在右侧，每个三角形使用PN三角形细分进行镶嵌和位移。(图片来自NVIDIA SDK 11样本，由NVIDIA公司提供，模型来自4A Games的Metro 2033。)</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210911132058.png" class="" title="image-20210911132058">

<p>几何着色程序的几何着色输入是一些单一类型:点，线段，三角形。最右边的两个原语包括与直线和三角形对象相邻的顶点。更复杂的补丁类型也是可能的。</p>
<h2 id="The-Geometry-Shader-几何着色器"><a href="#The-Geometry-Shader-几何着色器" class="headerlink" title="The Geometry Shader 几何着色器"></a>The Geometry Shader 几何着色器</h2><p><strong>几何着色器可以将元素转换成其他元素，这是镶嵌阶段做不到的。例如，一个三角形网格可以通过每个三角形创建线边来转换成线框视图。另外，这些线也可以用面向观众的四边形代替，这样就可以制作出边缘较厚的线框图。几何着色器在2006年末的DirectX 10发布时被添加到硬件加速的图形管线中。它位于管线中的镶嵌着色器之后，它的使用是可选的。虽然是Shader Model 4.0的必要部分，但在早期的Shader模型中没有使用。OpenGL 3.2和OpenGL ES 3.2也支持这种类型的着色器。</strong></p>
<p><strong>几何着色器的输入是一个单一的对象及其相关的顶点。物体通常由条状、线段或简单点上的三角形组成。扩展基元可以定义和处理几何着色器。特别地，三角形外的三个额外顶点可以被传递进来，折线上的两个相邻顶点也可以被使用。使用DirectX 11和Shader Model 5.0，你可以通过更复杂的补丁，多达32个控制点。也就是说，镶嵌阶段对生成补丁更有效。</strong></p>
<p><strong>几何着色器处理这个元素并输出零个或多个顶点，这些顶点被视为点、折线或三角形条。注意，任何输出都不能由几何着色器生成。因此，可以通过编辑顶点、添加新元素和删除其他元素来选择性地修改网格。</strong></p>
<p><strong>几何着色器设计用于修改传入数据或制作有限数量的副本。例如，一个用途是生成6个经过转换的数据副本，以同时呈现立方体映射的6个面;它还可以用于高效地创建级联阴影贴图，以生成高质量的阴影。其他利用几何着色器的算法包括从点数据创建可变大小的粒子，沿着轮廓挤压鳍用于皮毛渲染，以及为阴影算法寻找物体边缘。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210912125037.png" class="" title="image-20210912125037">

<p>一些几何着色器(GS)的使用。在左侧，使用GS在飞行中进行元等值面镶嵌。在中间，利用GS完成线段的分形细分并流出，由GS生成广告牌以显示闪电。在右侧，布料模拟是通过使用顶点和几何着色器来完成的。(图片来自NVIDIA SDK 10[1300]样本，由NVIDIA公司提供。)</p>
<p><strong>DirectX 11增加了几何着色器使用实例化的能力，其中几何着色器可以运行在任何给定的原始设定的次数。在OpenGL 4.0使用调用计数来指定。几何着色器也可以输出多达四个流。一个流可以通过呈现管线发送下去进行进一步处理。所有这些流可以被选择性地发送到流输出渲染目标。</strong></p>
<p><strong>几何着色器保证从元素中输出与输入顺序相同的结果。这影响性能，因为如果几个着色器内核并行运行，结果必须保存和顺序。这和其他因素的工作，避免几何着色器在一个单一调用被用于复制或创建大量的几何。</strong></p>
<p><strong>在绘制调用发出后，管线中只有三个地方可以在GPU上创建工作:光栅化、镶嵌阶段和几何着色器。其中，几何着色器的行为是最不可预测的，考虑到资源和内存需要，因为它是完全可编程的。在实践中，几何着色器通常很少使用，因为它不能很好地映射到GPU的优势。在一些移动设备上，它是在软件中实现的，所以在那里它不建议使用。</strong></p>
<h3 id="Stream-Output-流输出"><a href="#Stream-Output-流输出" class="headerlink" title="Stream Output 流输出"></a>Stream Output 流输出</h3><p><strong>GPU管线的标准用法是通过顶点着色器发送数据，然后栅格化生成的三角形，并在像素着色器中处理这些数据。过去，数据总是通过管线传递，中间结果无法访问。在Shader Model 4.0中引入了流输出的思想。顶点着色器(以及可选的镶嵌和几何着色器)处理完顶点后，这些可以在流中输出，例如，一个有序数组，除了被发送到栅格化阶段。栅格化实际上可以完全关闭，然后管线将纯粹用作非图形化流处理器。以这种方式处理的数据可以通过管线发送回来，从而允许迭代处理。这种类型的操作可以用于模拟流动的水或其他粒子效应。它还可以用于模型的皮肤，然后让这些顶点可以重用。</strong></p>
<p><strong>流输出仅以浮点数的形式返回数据，因此它可能有显著的内存消耗。流输出在元素上工作，而不是直接在顶点上工作。如果网格沿着管线发送，每个三角形都会生成自己的一组输出顶点。在原始网格中共享的任何顶点都将丢失。出于这个原因，更典型的用法是将顶点作为点集元素通过管线发送。在OpenGL中，流输出阶段被称为转换反馈，因为它的主要用途是转换顶点并返回它们以进行进一步处理。元素保证按照它们被输入的顺序被发送到流输出目标，这意味着顶点顺序将被保持。</strong></p>
<h2 id="The-Pixel-Shader-像素着色器"><a href="#The-Pixel-Shader-像素着色器" class="headerlink" title="The Pixel Shader 像素着色器"></a>The Pixel Shader 像素着色器</h2><p><strong>在顶点、镶嵌和几何着色器执行它们的操作后，元素被剪切并设置为光栅化。管线的这一部分相对固定在其处理步骤中，即不是可编程的，但可以配置。每个三角形都被遍历以确定它覆盖了哪些像素。栅格化器还可以粗略计算三角形覆盖每个像素的单元面积。这个三角形部分或完全重叠像素的部分称为碎片。</strong></p>
<p><strong>三角形顶点上的值，包括z缓冲区中使用的z值，将为每个像素在三角形的表面上进行插值。这些值被传递给像素着色器，然后处理片段。在OpenGL中，像素着色器被称为碎片着色器，这可能是一个更好的名字。沿着管线发送的点和线元素也会为所覆盖的像素创建碎片。</strong></p>
<p><strong>在三角形上执行的插值类型由像素着色程序指定。通常情况下，我们使用透视校正插值，这样当物体后退时，像素表面位置之间的世界空间距离就会增加。一个例子是渲染延伸到地平线的铁轨。铁轨越远的地方，枕木间距越近，因为每一个接近视界的连续像素所走过的距离就越远。其他插值选项也可用，如屏幕空间插值，其中不考虑透视投影。DirectX 11进一步控制了插值的时间和方式。</strong></p>
<p><strong>在编程方面，顶点着色程序的输出，通过插入三角形(或线)，有效地成为像素着色程序的输入。随着GPU的发展，其他的输入也被暴露出来。例如，在shader Model 3.0或更高版本中，片段的屏幕位置对像素着色器可用。同时,三角形的哪边是可见的是一个输入标志。这个知识对于渲染每个三角形的正面和背面的不同材质是很重要的。</strong></p>
<p><strong>有了输入，像素着色器通常会计算并输出片段的颜色。它也可能产生一个不透明度值和可选地修改它的z深度。在合并期间，这些值用于修改存储在像素上的内容。光栅化阶段产生的深度值也可以通过像素着色器进行修改。模板缓冲区值通常是不可修改的，但它会被传递到合并阶段。DirectX 11.3允许着色器改变这个值。在SM 4.0中，雾计算和alpha测试等操作已经从合并操作转变为像素着色器计算。</strong></p>
<p><strong>像素着色器也有独特的能力来丢弃一个进入的碎片，不产生输出。裁剪平面功能过去是固定功能管线中的一个可配置元素，后来在顶点着色器中指定。随着碎片丢弃可用，这个功能可以在像素着色器中以任何方式实现，如决定裁剪体积是否应该和或在一起。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210912130749.png" class="" title="image-20210912130749">

<p>用户定义的切割面。在左侧，一个水平剪切平面将对象切片。在中间，嵌套的球体被三个平面裁剪。在右边，只有当球体的表面在三个剪切平面之外时，球体的表面才会被剪切。(来自三个.js例子webgl clipping和webgl clipping intersection。)</p>
<p><strong>最初，像素着色器只能输出到合并阶段，以便最终显示。随着时间的推移，像素着色器可以执行的指令数量已经显著增加。这种增加产生了多渲染目标(MRT)的想法。不是将像素着色程序的结果发送到颜色和z缓冲区，而是可以为每个片段生成多个值集，并保存到不同的缓冲区，每个缓冲区称为渲染目标。渲染目标通常具有相同的x和y维度;有些API允许不同的大小，但是渲染区域是最小的。有些架构要求每个渲染目标具有相同的位深，甚至可能具有相同的数据格式。根据GPU，可用的渲染目标数量是4或8个。</strong></p>
<p><strong>即使有这些限制，MRT功能在更有效地执行渲染算法方面是一个强大的帮助。一次渲染可以在一个目标上生成彩色图像，在另一个目标上生成目标标识符，在第三个目标上生成世界空间距离。这种能力也产生了一种不同类型的渲染管道，称为延迟渲染，其中可见性和着色是在单独的通道中完成的。第一个通道存储关于对象的位置和每个像素的材质的数据。连续的通道可以有效地应用照明和其他效果。</strong></p>
<p><strong>像素着色器的限制是，它通常只能在片段位置写入渲染目标，而不能从相邻像素读取当前结果。也就是说，当一个像素着色程序执行时，它不能将其输出直接发送到邻近的像素，也不能访问其他人最近的更改。相反，它计算的结果只影响它自己的像素。然而，这种限制并不像听起来那么严重。在一个通道中创建的输出图像可以在以后的通道中由像素着色器访问其任何数据。相邻像素可以使用图像处理技术进行处理。</strong></p>
<p><strong>对于像素着色器不能知道或影响相邻像素的这一规则，也有例外。一个是在梯度或导数信息的计算过程中，像素着色器可以立即访问相邻碎片的信息(尽管是间接的)。像素着色器提供了沿着x和y屏幕轴每个像素的任何插值值变化的数量。这些值对于各种计算和纹理寻址都很有用。这些梯度对于纹理过滤，在这些操作中，我们想知道图像覆盖了多少像素。所有的现代GPU都是通过2 × 2的分组(称为quad)来实现这一功能的。当像素着色器请求一个梯度值时，将返回相邻片段之间的差异。一个统一的核心有能力访问相邻的数据——保持在同一扭曲的不同线程中——因此可以计算用于像素着色器的梯度。这个实现要求渐变信息不能在受动态流控制影响的部分着色器中访问。一个“if”语句或具有可变迭代次数的循环。一组中的所有片段必须使用同一套指令进行处理，以便所有四个像素的结果对计算梯度都有意义。这是即使在离线渲染系统中也存在的一个基本限制。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210912131427.png" class="" title="image-20210912131427">

<p>在左边，一个三角形被栅格化成2 × 2像素的四边形。然后在右边显示用黑点标记的像素的梯度计算。v的值显示在四元组中的四个像素位置。注意三个像素是如何没有被三角形覆盖的，但它们仍然被GPU处理，以便能够找到梯度。通过使用左下角像素的两个四边形邻居来计算屏幕x和y方向的梯度。</p>
<p><strong>DirectX 11引入了一种缓冲区类型，允许对任何位置的写访问，即无序访问视图(UAV)。最初仅用于像素和计算着色器，在DirectX 11.1中对UAVs扩展到所有着色器。OpenGL 4.3将其称为着色器存储缓冲区对象(SSBO)。这两个名字都有自己的描述性。像素着色器以任意顺序并行运行，并且存储缓冲区在它们之间共享。</strong></p>
<p><strong>通常需要一些机制来避免数据竞争条件(也称为数据危险)，在这种情况下，两个着色程序可能“竞争”影响相同的值导致随机的结果。例如，如果对一个像素着色器的两次调用试图在大约相同的时间添加相同的检索值，就可能发生错误。这两个调用都将检索原始值，都将在本地修改它，但无论最后哪个调用写入其结果，都会删除另一个调用的贡献——只会发生一个添加。GPU通过使用着色器可以访问的专用原子单位来避免这个问题。然而，原子意味着一些着色器可能会暂停，因为他们等待访问的内存位置正在被另一个着色器读/修改/写。</strong></p>
<p><strong>虽然原子可以避免数据危险，但许多算法需要特定的执行顺序。例如，您可能想在用红色透明三角形覆盖它之前绘制一个更远的透明蓝色三角形，将红色混合在蓝色之上。一个像素有可能对一个像素有两个像素着色器调用，每个三角形都有一个，执行的方式是红色三角形的着色器在蓝色三角形之前完成。在标准管线中，片段结果在被处理之前在合并阶段进行排序。在DirectX 11.3中引入了光栅化顺序视图(ROV)来强制执行顺序。这些就像UAVs;它们可以被着色器以同样的方式读取和写入。关键的区别在于，ROV可以保证数据以正确的顺序被访问。这大大增加了这些着色器可访问缓冲区的用处。例如，ROV使像素着色器可以编写自己的混合方法，因为它可以直接访问和写入ROV中的任何位置，因此不需要合并阶段。代价是，如果检测到无序访问，像素着色器调用可能会暂停，直到之前绘制的三角形被处理完成。</strong></p>
<h2 id="The-Merging-Stage-合并阶段"><a href="#The-Merging-Stage-合并阶段" class="headerlink" title="The Merging Stage 合并阶段"></a>The Merging Stage 合并阶段</h2><p><strong>合并阶段是单个片段(在像素着色器中生成)的深度和颜色与帧缓冲相结合的阶段。DirectX将这个阶段称为输出合并;OpenGL将其称为每样例操作。在大多数传统的管线图(包括我们自己的)中，这个阶段是模板缓冲区和z缓冲区操作发生的地方。如果片段是可见的，在这个阶段发生的另一个操作是颜色混合。对于不透明的表面，不涉及真正的混合，因为片段的颜色只是替换先前存储的颜色。片段和存储颜色的实际混合通常用于透明度和合成操作。</strong></p>
<p><strong>假设光栅化生成的片段通过像素着色器运行，然后当z缓冲区被应用时，发现被先前渲染的片段隐藏了。所有在像素着色器中完成的处理都是不必要的。为了避免这种浪费，许多GPU在像素着色器执行之前执行一些合并测试。片段的z深度(以及其他任何正在使用的东西，如模板缓冲或裁剪)用于测试可见性。如果隐藏，碎片将被剔除。这种功能被称为early-z。像素着色器有能力改变碎片的z深度或完全丢弃碎片。如果发现在像素着色程序中存在任何一种类型的操作，early-z通常不能被使用，并被关闭，这通常会降低管线的效率。DirectX 11和OpenGL 4.2允许像素着色器强制启动early-z测试，尽管有一些限制。</strong></p>
<p><strong>合并阶段占据了固定功能阶段之间的中间地带，如三角形设置，和完全可编程的着色阶段。虽然它不是可编程的，但它的操作是高度可配置的。特别是颜色混合，可以进行大量不同的操作。最常见的是涉及颜色和alpha值的乘法、加法和减法的组合，但也可以进行其他操作，如最小和最大值，以及按位逻辑操作。DirectX 10增加了将像素着色器中的两种颜色与帧缓冲区颜色混合的功能。这个功能被称为双源颜色混合，不能与多个渲染目标一起使用。除此之外，MRT支持混合，DirectX 10.1引入了在每个单独的缓冲区上执行不同的混合操作的能力。</strong></p>
<p><strong>正如上一节末尾所提到的，DirectX 11.3提供了一种通过ROVs使混合可编程的方法，尽管在性能上付出了代价。ROVs和合并阶段都保证了绘制顺序，也就是输出不变性。不管像素着色器结果生成的顺序是什么，API要求结果一个对象一个对象，一个三角形一个三角形，按照输入的顺序进行排序并发送到合并阶段。</strong></p>
<h2 id="The-Compute-Shader-计算着色器"><a href="#The-Compute-Shader-计算着色器" class="headerlink" title="The Compute Shader 计算着色器"></a>The Compute Shader 计算着色器</h2><p><strong>GPU不仅可以用于实现传统的图形管线。从计算股票期权的估值到为深度学习训练神经网络，在各个领域都有许多非图形化的应用。以这种方式使用硬件被称为GPU计算。像CUDA和OpenCL这样的平台被用来控制GPU作为一个巨大的并行处理器，不需要或访问图形特定的功能。这些框架通常使用C或C++等带有扩展的语言，以及为GPU制作的库。</strong></p>
<p><strong>在DirectX 11中引入的，计算着色器是GPU计算的一种形式，因为它是一个不锁定在图形管线中的位置的着色器。它与呈现过程紧密相关，因为它是由图形API调用的。它与顶点、像素和其他着色器一起使用。它利用了与管道中使用的相同的统一着色处理器池。它是一个像其他着色器一样的着色器，因为它有一些输入数据集，可以访问缓冲区(如纹理)的输入和输出。Warps和线程在计算着色器中更明显。例如，每次调用都会获得一个可以访问的线程索引。还有一个线程组的概念，在DirectX 11中由1到1024个线程组成。这些线程组由x-， y-和z-坐标指定，主要是为了在着色器代码中简单使用。每个线程组都有少量在线程之间共享的内存。在DirectX 11中，这相当于32 kB。计算着色器是由线程组执行的，因此线程组中的所有线程都保证并发运行。</strong></p>
<p><strong>计算着色器的一个重要优势是它们可以访问在GPU上生成的数据。将数据从GPU发送到CPU会有一定的延迟，因此如果处理和结果能够保留在GPU上，则可以提高性能。后期处理，即以某种方式修改已渲染的图像，是计算着色器的常用用途。共享内存意味着来自采样图像像素的中间结果可以与相邻线程共享。例如，使用计算着色器来确定图像的分布或平均亮度，其运行速度是在像素着色器上执行此操作的两倍。</strong></p>
<p><strong>计算着色器也适用于粒子系统、网格处理，如面部动画、剔除、图像滤波、提高深度精度、阴影、景深，以及任何其他可以使用GPU处理器的任务。Wihlidal讨论了计算着色器如何比镶嵌外壳着色器更有效。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210913125601.png" class="" title="image-20210913125601">

<p>计算着色器的应用。在左边，一个计算着色器用来模拟受风影响的头发，头发本身使用镶嵌阶段渲染。在中间，一个计算着色器执行快速模糊操作。右边是模拟的海浪。(图片来自NVIDIA SDK 11[1301]样本，由NVIDIA公司提供。)</p>
<h1 id="4-Transforms-变换"><a href="#4-Transforms-变换" class="headerlink" title="4 Transforms 变换"></a>4 Transforms 变换</h1><p><strong>变换是一种操作，它采用点、向量或颜色等实体，并以某种方式对它们进行转换。对于计算机图形的实践者来说，掌握变换是极其重要的。使用它们，您可以定位、重塑和动画对象、灯光和相机。您还可以确保所有计算都在相同的坐标系中执行，并以不同的方式将对象投影到一个平面上。</strong></p>
<p><strong>线性变换是保持向量加法和标量乘法的变换。具体地说,</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914093641.png" class="" title="image-20210914093641">

<p><strong>结合线性变换和平移可以使用仿射变换来完成，通常存储为4 × 4矩阵。仿射变换是先执行线性变换再执行平移的变换。为了表示四个元素的向量，我们使用齐次符号，以同样的方式表示点和方向(使用黑体小写字母)。方向向量表示为v = (vx  vy  vz  0）^T 点v = (vx  vy  vz  1）^T。</strong></p>
<p><strong>所有的平移、旋转、缩放、反射和剪切矩阵都是仿射矩阵。仿射矩阵的主要特征是保持直线的平行性，但不一定保持长度和角度。仿射变换也可以是单个仿射变换的串联序列。</strong></p>
<h2 id="Basic-Transforms-基本变换"><a href="#Basic-Transforms-基本变换" class="headerlink" title="Basic Transforms 基本变换"></a>Basic Transforms 基本变换</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914094447.png" class="" title="image-20210914094447">

<p>大多数变换及其表示法、函数和性质，其中正交矩阵的逆矩阵是转置矩阵。</p>
<h3 id="Translation-平移"><a href="#Translation-平移" class="headerlink" title="Translation 平移"></a>Translation 平移</h3><p><strong>从一个位置到另一个位置的变化用一个平移矩阵T来表示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914094917.png" class="" title="image-20210914094917">

<h3 id="Rotation-旋转"><a href="#Rotation-旋转" class="headerlink" title="Rotation 旋转"></a>Rotation 旋转</h3><p><strong>在二维空间中，假设我们有一个向量v = (vx, vy)，我们将其参数化为v = （vx, vy）= （rcos θ， rsin θ）。如果逆时针旋转φ弧度，就得到u = （rcos (θ + φ)，rsin (θ + φ)）这个可以写成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914100616.png" class="" title="image-20210914100616">

<p><strong>在三维空间有，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914101051.png" class="" title="image-20210914101051">

<h3 id="Scaling-缩放"><a href="#Scaling-缩放" class="headerlink" title="Scaling 缩放"></a>Scaling 缩放</h3><p><strong>缩放变换表示为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914101507.png" class="" title="image-20210914101507">

<p><strong>在s的一个或三个分量上取负值，就得到一种反射矩阵，也称为反射矩阵。如果只有两个比例因子为−1，则旋转π弧度。需要注意的是，与反射矩阵连接的旋转矩阵也是反射矩阵。因此，反射矩阵如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914101722.png" class="" title="image-20210914101722">

<p><strong>一个顶点按逆时针顺序排列的三角形，经过反射矩阵变换后将得到顺时针顺序。这个顺序的改变会导致不正确的光照和背面剔除。为了检测给定的矩阵是否以某种方式反映，计算左上方3 × 3元素的行列式。如果该值为负，则矩阵为反射矩阵。</strong></p>
<p><strong>如果需要在其他方向进行缩放，则需要进行复合变换。假设应该沿着标准正交的、右向的向量f x、f y和f z的轴进行缩放。首先，构造矩阵f，以改变基底，如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914101930.png" class="" title="image-20210914101930">

<p><strong>其思想是使三个坐标轴给出的坐标系统与标准坐标轴重合，然后使用标准缩放矩阵，然后再转换回来。第一步是与转置矩阵相乘，即F。然后进行实际的缩放，然后进行回变换。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914101940.png" class="" title="image-20210914101940">

<h3 id="Shearing-裁剪"><a href="#Shearing-裁剪" class="headerlink" title="Shearing 裁剪"></a>Shearing 裁剪</h3><p><strong>另一类变换是剪切矩阵的集合。例如，在游戏中，这些元素可以用来扭曲整个场景以创造迷幻效果或扭曲模型的外观。有六种基本的剪切矩阵，用Hxy(s), Hxz(s), Hyx(s), Hyz(s), Hzx(s), Hzy(s)表示。第一个下标表示被剪切矩阵改变的坐标，第二个下标表示进行剪切的坐标。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914102429.png" class="" title="image-20210914102429">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914102441.png" class="" title="image-20210914102441">

<h3 id="Concatenation-of-Transforms-变换的连接"><a href="#Concatenation-of-Transforms-变换的连接" class="headerlink" title="Concatenation of Transforms 变换的连接"></a>Concatenation of Transforms 变换的连接</h3><p><strong>由于矩阵乘法运算的非交换性，矩阵发生的顺序很重要。因此变换的连接被称为顺序相关的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914103301.png" class="" title="image-20210914103301">

<p>这说明了矩阵相乘时的顺序依赖关系。</p>
<p><strong>将一个矩阵序列连接成一个矩阵序列的明显原因是为了获得效率。例如，假设你有一个拥有数百万个顶点的游戏场景，场景中的所有对象都必须缩放、旋转并最终转换。现在，不是将所有顶点与这三个矩阵中的每一个相乘，而是将这三个矩阵连接成一个矩阵。这个矩阵被应用到顶点上。这个复合矩阵是C = TRS。注意这里的顺序。缩放矩阵S，应该首先应用到顶点上，因此在复合中出现在右边。这个顺序意味着TRSp = (T(R(Sp))，其中p是一个要变换的点。顺便提一下，TRS是场景图系统常用的阶数。</strong></p>
<p><strong>值得注意的是，虽然矩阵连接是顺序相关的，但矩阵可以按需要分组。例如，假设使用TRSp，您希望计算一次刚体运动变换TR。将这两个矩阵组合在一起(TR)(Sp)，并用中间结果替换是有效的。因此，矩阵连接是结合的。</strong></p>
<h3 id="The-Rigid-Body-Transform-刚体变换"><a href="#The-Rigid-Body-Transform-刚体变换" class="headerlink" title="The Rigid-Body Transform 刚体变换"></a>The Rigid-Body Transform 刚体变换</h3><p><strong>当一个人从桌子上拿起一个固体物体，比如一支笔，并把它移到另一个地方，比如衬衫口袋里，只有物体的方向和位置会改变，而物体的形状一般不会受到影响。这种只由平移和旋转串联而成的变换称为刚体变换。它具有保持长度、角度和旋向的特点。</strong></p>
<p><strong>任意刚体矩阵X可表示为平移矩阵T(t)和旋转矩阵r的串联，则X为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914103913.png" class="" title="image-20210914103913">

<p><strong>X的逆为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914104005.png" class="" title="image-20210914104005">

<p><strong>为了计算逆矩阵，将左上3 × 3的R矩阵转置，使T的平移值改变符号。这两个新矩阵以相反的方式乘在一起以得到其逆矩阵。另一种计算X逆的方法是考虑R(使R以3 × 3矩阵的形式出现)和X的表示法</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914104216.png" class="" title="image-20210914104216">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914104255.png" class="" title="image-20210914104255">

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>在图形学中，一个常见的任务是确定相机的方向，使它看到一个特定的位置。在这里，我们将展示gluLookAt()(来自OpenGL实用程序库，简称GLU)的功能。尽管现在这个函数调用本身并不常用，但这个任务仍然很常见。假设相机位于c，我们想让相机注视目标l，相机给定的方向是u ‘。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914104728.png" class="" title="image-20210914104728">

<p><strong>我们要计算一个由三个向量组成的基，{r, u, v}。我们首先计算视图向量v = (c−l)/||c−l||，即从目标到摄像机位置的归一化向量。向右看的向量可以计算为r =−(v × u ‘)/||v × u ‘ ||。u ‘向量通常不能保证是精确的向上，所以最后的向上向量是另一个叉积，u = v × r，它被保证是标准化的，因为v和r都是标准化的，而且通过构造是垂直的。在相机变换矩阵,M,我们将构建,我们的想法是先变换一切所以相机的位置是在原点,(0,0,0),然后修改基础,以便r是符合(1,0,0),u(0,1,0)和v(0 0 1)。这是通过</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914104938.png" class="" title="image-20210914104938">

<h3 id="Normal-Transform-法线变换"><a href="#Normal-Transform-法线变换" class="headerlink" title="Normal Transform 法线变换"></a>Normal Transform 法线变换</h3><p><strong>一个矩阵可以用来一致地转换点、线、三角形和其他几何图形。同样的矩阵也可以变换沿这些直线或三角形表面的切向量。然而，这个矩阵不能总是用来转换一个重要的几何属性，表面法线(和顶点光照法线)。下图显示了如果使用相同的矩阵会发生什么。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914105523.png" class="" title="image-20210914105523">

<p><strong>正确的方法不是乘矩阵本身，而是用矩阵的伴随矩阵的转置。伴随矩阵总是保证存在的。法线在转换后不能保证为单位长度，因此通常需要标准化。</strong></p>
<p><strong>传统的法线变换方法是计算逆矩阵的转置。这种方法通常是有效的。然而，完全的逆并不是必需的，有时也不能创建。它的逆是伴随矩阵除以原始矩阵的行列式。如果这个行列式为零，则矩阵是奇异的，其逆矩阵不存在。</strong></p>
<p><strong>即使只是计算一个完整的4 × 4矩阵的伴随矩阵也很昂贵，而且通常是不必要的。因为法线是一个矢量，所以平移不会影响它。此外，大多数建模转换都是仿射的。它们不会改变传入的齐次坐标的w分量，也就是说。它们不执行投影。在这些(常见的)情况下，所有的正规变换所需要的是计算左上3 × 3分量的伴随矩阵。</strong></p>
<p><strong>通常，甚至这种伴随矩阵的计算也是不需要的。假设我们知道变换矩阵完全由平移、旋转和统一缩放操作(没有拉伸或挤压)的串联组成。变换不影响法线。均匀比例因子只是改变法线的长度。剩下的就是一系列的旋转，它总是产生某种净旋转，仅此而已。</strong></p>
<p><strong>逆矩阵的转置可以用来变换法线。旋转矩阵的定义是它的转置是它的逆。代入得到法变换，两次转置(或两次逆)就得到原来的旋转矩阵。把所有这些放在一起，原始变换本身也可以在这些情况下直接用于变换法线。</strong></p>
<p><strong>最后，使法线完全重正化并不总是必要的。如果只是平移和旋转连接在一起，那么法线在矩阵变换时不会改变长度，因此不需要重正化。如果统一缩放也被连接起来，整体缩放因子可以用来直接对产生的法线进行归一化。例如，如果我们知道应用了一系列缩放使对象变大5.2倍，那么直接由这个矩阵转换的法线将被重归一化，方法是将它们除以5.2。或者，为了创建一个正规的变换矩阵来产生标准化的结果，原始矩阵的3×3左上角可以被这个比例因子除一次。</strong></p>
<p><strong>注意，法线变换不是一个问题，在变换之后，曲面法线由三角形导出(例如，使用三角形的边的叉积)。切向量在本质上不同于法向量，通常是由原矩阵直接变换的。</strong></p>
<h3 id="Computation-of-Inverses-逆变换"><a href="#Computation-of-Inverses-逆变换" class="headerlink" title="Computation of Inverses 逆变换"></a>Computation of Inverses 逆变换</h3><p><strong>在许多情况下都需要逆，例如，在坐标系之间来回变换时。根据有关变换的可用信息，可以使用下列三种计算矩阵逆的方法:</strong></p>
<pre><code>**如果矩阵是给定参数的单个变换或一系列简单变换，那么通过“反参数”和矩阵顺序可以很容易地计算出矩阵。例如,如果M = T (t) R(φ),那么M^−1 = R(−φ)T(−t)。这很简单，并且保持了变换的准确性，这在渲染巨大的世界时是很重要的。**

**如果已知矩阵是正交的，则M^−1 = M^T，即转置就是逆。任何旋转序列都是旋转，所以是正交的。**

**如果什么都不知道，那么可以使用伴随方法、克拉默规则、LU分解或高斯消去法来计算逆。克拉默规则和伴随法具有较少的分支运算，一般较好;在现代架构中，最好避免“if”测试。**
</code></pre>
<p><strong>逆向计算的目的也可以考虑到优化。例如，如果逆矩阵用于变换向量，那么通常只需要对矩阵左上方的3 × 3部分进行逆矩阵(参见前面的内容)</strong></p>
<h2 id="Special-Matrix-Transforms-and-Operations-特殊矩阵变换和运算"><a href="#Special-Matrix-Transforms-and-Operations-特殊矩阵变换和运算" class="headerlink" title="Special Matrix Transforms and Operations 特殊矩阵变换和运算"></a>Special Matrix Transforms and Operations 特殊矩阵变换和运算</h2><h3 id="The-Euler-Transform-欧拉变换"><a href="#The-Euler-Transform-欧拉变换" class="headerlink" title="The Euler Transform 欧拉变换"></a>The Euler Transform 欧拉变换</h3><p><strong>这种转换是一种直观的方法来构建一个矩阵来定位你自己(如相机)或任何其他实体在某个方向上。它的名字来自伟大的瑞士数学家莱昂哈德·欧拉(1707-1783)。</strong></p>
<p><strong>首先，必须建立某种默认的视图方向。大多数情况下，它位于负z轴，头部沿y轴方向，如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914115003.png" class="" title="image-20210914115003">

<p><strong>欧拉变换是三个矩阵的乘积，即图中所示的旋转。更正式地说，变换E为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914115823.png" class="" title="image-20210914115823">

<p><strong>矩阵的顺序可以用24种不同的方式选择;我们提出这个词是因为它很常用。由于E是旋转的串联，它显然也是正交的。因此它的逆可以表示为E^−1 = ET = (RzRxRy）^T ，当然，直接用E的转置更容易。</strong></p>
<p><strong>欧拉角h, p和r表示 head，pitch和 roll应该围绕各自的轴旋转多少。有时角度都被称为“rolls”，例如，我们的“head”是“y-roll”，我们的“pitch”是“x-roll”。此外，“head”有时也被称为“yaw”，比如在飞行模拟中。</strong></p>
<p><strong>这种转换是直观的，因此很容易用外行人的语言来讨论。例如，改变头部角度会让观众摇头表示“不”，改变色调会让观众点头，而滚动则会让观众歪着头。我们讨论的不是围绕x、y和z轴的旋转，而是改变头部、俯仰和滚动。注意，这个变换不仅可以定位相机，还可以定位任何物体或实体。这些变换可以使用世界空间的全局轴或相对于局部参照系来执行。</strong></p>
<p><strong>值得注意的是，一些欧拉角的表示给出了z轴作为初始向上方向。这种差异纯粹是符号上的变化，尽管可能会令人困惑。在计算机图形学中，如何看待世界以及内容如何形成是有区别的:y-向上或 z-向上。大多数制造过程，包括3D打印，认为z方向是向上的世界空间;航空和海上交通工具认为−z向上。建筑和GIS通常使用z-向上，因为建筑平面图或地图是二维的，x和y。与媒体相关的建模系统通常认为y方向在世界坐标中是向上的，这与我们在计算机图形学中描述摄像机屏幕向上的方向相匹配。区别这两个世界上的向量选择只是90◦旋转(可能是一个反射)，但不知道向上方向可能导致问题。除非另有说明，我们使用y-向上世界方向。</strong></p>
<p><strong>我们还想指出，摄像机在其视图空间中的向上方向与世界的向上方向没有特别的关系。转动你的头，视野就会倾斜，它的世界空间向上的方向与世界的方向不同。再举一个例子，假设这个世界使用y-向上，我们的相机直接向下看下面的地形，鸟瞰。这个方向意味着相机已经倾斜90◦向前，所以它在世界空间的向上方向是(0,0,1)。在这个方向中，摄像机没有y分量，而是认为−z在世界空间中是向上的，但是根据定义，“y是向上的”在视图空间中仍然是正确的。</strong></p>
<p><strong>虽然欧拉角对于小角度的变化或观众的方向很有用，但它也有一些其他严重的局限性。两组欧拉角的组合运算是很困难的。例如，在一个集合和另一个集合之间的插值不是一个简单的插值每个角度的问题。事实上，两组不同的欧拉角可以给出相同的方向，所以任何插值都不应该使物体旋转。</strong></p>
<h3 id="Extracting-Parameters-from-the-Euler-Transform-从欧拉变换提取参数"><a href="#Extracting-Parameters-from-the-Euler-Transform-从欧拉变换提取参数" class="headerlink" title="Extracting Parameters from the Euler Transform 从欧拉变换提取参数"></a>Extracting Parameters from the Euler Transform 从欧拉变换提取参数</h3><p><strong>在某些情况下，从正交矩阵中提取欧拉参数h、p和r是有用的。这个过程如公式所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914122252.png" class="" title="image-20210914122252">

<p><strong>这里我们放弃了4 × 4矩阵，改用3 × 3矩阵，因为后者提供了旋转矩阵的所有必要信息。也就是说，等价的4 × 4矩阵的其余部分总是包含0和右下角的1。</strong></p>
<p><strong>将上式中的三个旋转矩阵连接起来得到</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914122843.png" class="" title="image-20210914122843">

<p><strong>由此可见，pitch参数由sin p = e21．同时,将e01除e11，类似地e20除e22，得到的head 和 roll参数提取方程如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914123150.png" class="" title="image-20210914123150">

<p><strong>因此，利用函数atan2(y,x)从矩阵E中提取欧拉参数h(head)、p(pitch)和r(roll)，如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914123336.png" class="" title="image-20210914123336">

<p><strong>但是，有一个特殊情况我们需要处理。如果cos p = 0，我们有万向节锁，旋转角度r和h将围绕同一轴旋转(虽然可能是不同的方向，取决于p旋转角度是−π/2还是π/2)，所以只需要导出一个角度。如果任意设h = 0，得到</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914123530.png" class="" title="image-20210914123530">

<p><strong>因为p不影响第一列的值，当cos p = 0时，我们可以用sin r/ cos r = tan r = e10/ e00，得到r = atan2(e10，e00)。</strong></p>
<p><strong>注意，根据arcsin的定义，−π/2≤p≤π/2，即如果E的值在这个区间外，则无法提取原始参数。h, p，和r不是唯一的，这意味着可以使用不止一组欧拉参数来产生相同的变换。关于欧拉角转换的更多信息可以在Shoemake 1994年的文章中找到。上面概述的简单方法可能会导致数值不稳定的问题，这是可以避免的，但要付出一定的速度代价。</strong></p>
<p><strong>当您使用欧拉变换时，可能会出现万向节锁。当旋转使一个自由度失去时，就会发生这种情况。例如，变换的顺序是x/y/z。假设绕y轴旋转π/2，这是第二次旋转。这样做会旋转局部的z轴，使其与原始的x轴对齐，从而使绕z的最后旋转是多余的。</strong></p>
<p><strong>数学上，我们已经见过万向节锁，其中我们假设cos p = 0，即 p =±π/2 + 2πk，其中k是整数。有了这样的p值，我们就失去了一个自由度，因为矩阵只依赖于一个角度，r + h或r - h(但不能同时同时依赖两个角度)。</strong></p>
<p><strong>在建模系统中，欧拉角通常表现为x/y/z顺序，绕每个局部轴旋转，其他顺序都是可行的。例如，z/x/y在动画中使用，z/x/z在动画和物理中都使用。所有这些都是指定三个独立旋转的有效方法。最后一种顺序，z/x/z，对于某些应用程序可能更优越，因为只有当围绕x旋转π弧度(半旋转)时，万向节锁才会发生。没有一个完美的顺序可以避免万向节锁。尽管如此，欧拉角还是经常被使用，因为动画师更喜欢使用曲线编辑器来指定角度如何随时间变化。</strong></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><strong>约束转换。想象你正握着一个(虚拟的)扳手，它正在抓住一个螺栓。要把螺栓装到位，你必须绕x轴转动扳手。现在，假设你的输入设备(鼠标、VR手套、太空球等)给你一个旋转矩阵，即旋转，用于扳手的运动。问题是，将这个变换应用到扳手上很可能是错误的，它应该只围绕x轴旋转。要将输入变换(称为P)限制为绕x轴旋转，只需使用本节描述的方法提取欧拉角h、P和r，然后创建一个新的矩阵Rx(p)。这是将绕x轴旋转扳手(如果p现在包含这样一个运动)目标的变换。</strong></p>
<h3 id="Matrix-Decomposition-矩阵分解"><a href="#Matrix-Decomposition-矩阵分解" class="headerlink" title="Matrix Decomposition 矩阵分解"></a>Matrix Decomposition 矩阵分解</h3><p><strong>到目前为止，我们一直在假设我们知道我们所使用的变换矩阵的起源和历史的前提下工作。事实往往并非如此。</strong></p>
<p><strong>例如，除了一个连接的矩阵之外，没有什么可以与某个变换对象相关联。从一个连接的矩阵中检索各种变换的任务称为矩阵分解。</strong></p>
<p><strong>检索一组变换的原因有很多。用途包括:</strong></p>
<pre><code>**提取对象的比例因子。**

**寻找特定系统所需的变换。(例如，有些系统可能不允许使用任意的4 × 4矩阵。)**

**确定模型是否只经历了刚体变换。**

**在动画的关键帧之间插入，只有对象的矩阵可用。**

**从旋转矩阵中移除剪切器。**
</code></pre>
<p><strong>我们已经给出了两种分解，一种是推导刚体变换的平移和旋转矩阵，另一种是从正交矩阵推导欧拉角。</strong></p>
<p><strong>正如我们所看到的，检索平移矩阵是很简单的，因为我们只需要4 × 4矩阵的最后一列中的元素。我们还可以通过检查矩阵的行列式是否为负来确定是否发生了反射。将旋转、缩放和剪切分离出来需要更多的努力。</strong></p>
<h3 id="Rotation-about-an-Arbitrary-Axis-绕任意轴旋转"><a href="#Rotation-about-an-Arbitrary-Axis-绕任意轴旋转" class="headerlink" title="Rotation about an Arbitrary Axis 绕任意轴旋转"></a>Rotation about an Arbitrary Axis 绕任意轴旋转</h3><p><strong>有时，使一个实体围绕任意轴旋转一些角度。假设旋转轴r是标准化的，并且应该创建一个围绕r旋转α弧度的变换。</strong></p>
<p><strong>为了做到这一点，我们首先转换到一个空间，在这个空间中，我们想围绕它旋转的轴是x轴。这是通过一个名为M的旋转矩阵完成的，然后执行实际的旋转，我们使用M^−1进行回变换。这个过程如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914131231.png" class="" title="image-20210914131231">

<p>绕任意轴r旋转是通过找到由r, s和t组成的标准正交基来完成的。然后我们将这个基与标准基对齐，使r与x轴对齐。绕x轴旋转是在这里进行的，最后我们变换回来。</p>
<p><strong>为了计算M，我们需要找到两个与r和彼此正交的轴。我们专注于寻找第二轴,s,然后知道第三轴,t,将第一和第二轴的外积,t = r×s。一个数值稳定的方法是找到最小的组件(绝对值)r,并将其设置为0。交换剩下的两个组件，然后对第一个组件求反(事实上，任何一个非零分量都可以被求反)。数学上，这表示为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914131526.png" class="" title="image-20210914131526">

<p><strong>这就保证了¯s正交于r，并且(r, s, t)是一组标准正交基。这三个向量都用于创建旋转矩阵:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914131724.png" class="" title="image-20210914131724">

<p><strong>这个矩阵把向量r变换成x轴，s变换成y轴，t变换成z轴。因此，围绕标准化向量r旋转α弧度的最终变换是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914131846.png" class="" title="image-20210914131846">

<p><strong>换句话说，这意味着首先我们变换使r变成x轴(使用M)，然后我们围绕x轴旋转α弧度(使用(Rx(α))，然后我们用M的逆（在这里就是M^T 因为M正交）进行变换。</strong></p>
<p><strong>Goldman提出了另一种以φ弧度绕任意归一化轴r旋转的方法。这里，我们简单介绍一下他的变换:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210914132110.png" class="" title="image-20210914132110">

<h2 id="Quaternions-四元法"><a href="#Quaternions-四元法" class="headerlink" title="Quaternions 四元法"></a>Quaternions 四元法</h2><p><strong>尽管1843年威廉·罗文·汉密尔顿爵士发明了四元数，作为复数的扩展，但直到1985年，shomake才将四元数引入计算机图形领域。四元数用于表示旋转和方向。它们在许多方面优于欧拉角和矩阵。任何三维方向都可以表示为围绕某一特定轴的单个旋转。考虑到这个轴和角度的表示，转换到四元数是直接的，而在任何方向上的欧拉角转换都是较困难的。四元数可以用于稳定和恒定的方向插值，这是用欧拉角做不好的。</strong></p>
<p><strong>复数有实部和虚部。每一个用两个实数表示，第二个实数乘以√−1。类似地，四元数有四个部分。前三个值与旋转轴密切相关，旋转角度影响所有四个部分。每个四元数由四个实数表示，每个实数与不同的部分相关联。由于四元数有四个分量，我们选择用向量来表示它们，但为了区分它们，我们给它们加了一个帽子:qˆ。我们从四元数的一些数学背景开始，然后用它来构造各种有用的变换。</strong></p>
<h3 id="Mathematical-Background-数学背景"><a href="#Mathematical-Background-数学背景" class="headerlink" title="Mathematical Background 数学背景"></a>Mathematical Background 数学背景</h3><p><strong>四元数qˆ可以用下列方法定义，都是等价的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915111223.png" class="" title="image-20210915111223">

<p><strong>变量qw称为四元数的实部。虚部是qv，i、j、k称为虚数单位。</strong></p>
<p><strong>对于虚部qv，我们可以使用所有的法向量运算，如加法、缩放、点积、叉积等。利用四元数的定义，导出了两个四元数qˆ和ˆr之间的乘法运算如下所示。注意虚单位的乘法是非交换的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915111530.png" class="" title="image-20210915111530">

<p><strong>从这个方程可以看出，我们同时使用叉乘和点乘来计算两个四元数的乘法。</strong></p>
<p><strong>除了四元数的定义外，还需要定义addition, conjugate, norm, identity:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915111839.png" class="" title="image-20210915111839">

<p><strong>当n(ˆq) =√qˆqˆ∗被简化(结果如上所示)时，虚部抵消掉，只剩下实部。norm有时记为||ˆq|| = n(ˆq)。上面的结果是一个乘法的逆，表示为qˆ−1，可以导出。方程qˆ−1qˆ=qˆqˆ−1 = 1对逆必须成立(这是乘法逆的常见情况)。我们从规范的定义推导出一个公式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112116.png" class="" title="image-20210915112116">

<p><strong>这给出了乘法逆矩阵如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112127.png" class="" title="image-20210915112127">

<p><strong>反函数的公式使用了标量乘法，这是由定义中所见的乘法导出：sqˆ = (0, s)(qv, qw) = (sqv, sqw), 且 qˆs = (qv, qw)(0, s) = (sqv, sqw), 这意味着标量乘法是: sqˆ = qˆs = (sqv, sqw)。</strong></p>
<p><strong>下面的规则很容易从定义中推导出来:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112506.png" class="" title="image-20210915112506">

<p><strong>单位四元数，qˆ= (qv,qw)，使n(ˆq) = 1。由此可以得出qˆ可以写成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112601.png" class="" title="image-20210915112601">

<p><strong>对于三维向量uq，使||uq|| = 1，因为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112615.png" class="" title="image-20210915112615">

<p><strong>当且仅当uq ·uq = 1 = ||uq||²。</strong></p>
<p><strong>对于复数，一个二维单位向量可以写成cos φ + isin φ = e^iφ．四元数的等价式是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112717.png" class="" title="image-20210915112717">

<p><strong>单位四元数的对数和幂函数如公式所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915112731.png" class="" title="image-20210915112731">

<h3 id="Quaternion-Transforms-四元数变换"><a href="#Quaternion-Transforms-四元数变换" class="headerlink" title="Quaternion Transforms 四元数变换"></a>Quaternion Transforms 四元数变换</h3><p><strong>现在我们将研究四元数集的一个子类，即单位长度，称为单位四元数。关于单位四元数最重要的是它们可以表示任何三维旋转，而且这种表示是非常紧凑和简单的。</strong></p>
<p><strong>现在我们将描述为何使用单位四元数对旋转和方向如此有用。首先，将一个点或向量p = (px py pz pw）^T ，假设我们有一个单位四元数qˆ= (sin φuq, cosφ)。我们可以证明</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915114358.png" class="" title="image-20210915114358">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915113040.png" class="" title="image-20210915113040">

<p>用单位四元数表示的旋转变换，qˆ= (sin φuq , cosφ)。变换围绕uq轴旋转2φ弧度 。</p>
<p><strong>绕uq轴旋转pˆ(即p点)2φ。请注意，由于ˆq是一个单位四元数，qˆ−1 = qˆ∗。</strong></p>
<p><strong>qˆ的任意非零实倍数也表示相同的变换，即qˆ和−ˆq表示相同的旋转。也就是求坐标轴uq和实部qw，创建一个与原始四元数完全相同的旋转四元数。它还意味着从矩阵中提取四元数可以返回qˆ或−ˆq。</strong></p>
<p><strong>给定两个单位四元数qˆ和ˆr，将qˆ和ˆr串联到四元数pˆ(可以解释为点p)，由式得出:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915114811.png" class="" title="image-20210915114811">
<p> <strong>这里，cˆ=ˆrqˆ是单位四元数，表示单位四元数qˆ和ˆr的连接。</strong></p>
<h4 id="Matrix-Conversion-矩阵变换"><a href="#Matrix-Conversion-矩阵变换" class="headerlink" title="Matrix Conversion 矩阵变换"></a><strong>Matrix Conversion 矩阵变换</strong></h4><p><strong>由于经常需要组合几个不同的变换，而且大多数变换都是矩阵形式，因此需要一种方法将方程</strong></p>
<p><strong><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915114358.png" class="" title="image-20210915114358"></strong></p>
<p><strong>转换为一个矩阵。一个四元数ˆq，可转换为矩阵M^q，如式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915115049.png" class="" title="image-20210915115049">

<p><strong>这里标量 s = 2/(n(qˆ))² ，对于单位四元数，可简化为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915115101.png" class="" title="image-20210915115101">

<p><strong>一旦构建了四元数，就不需要计算三角函数了，因此转换过程在实践中是高效的。</strong></p>
<p><strong>从正交矩阵Mq到单位四元数ˆq的反向转换稍微复杂一些。这个过程的关键是，从上式的矩阵中得到:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915131412.png" class="" title="image-20210915131412">

<p><strong>这些方程的含义是，如果已知qw ，向量vq的值可以计算，从而得到qˆ。M^q的跟踪</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915131551.png" class="" title="image-20210915131551">

<p><strong>这个结果对单位四元数产生以下转换:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915131624.png" class="" title="image-20210915131624">

<p><strong>为了有一个数值稳定的程序，应该避免用小数进行除法。因此，首先设t = qw²−qx²−qy²−qz²，由此可得</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915131645.png" class="" title="image-20210915131645">

<p><strong>这又意味着m00,m11,m22中最大的， u决定qx，qy,qz,qw 中最大的。如果qw ，则使用</strong></p>
<p><img src="C:\Users\86010\AppData\Roaming\Typora\typora-user-images\image-20210915132051014.png" alt="image-20210915132051014"></p>
<p><strong>导出四元数。因此，我们注意到以下成立:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915132104.png" class="" title="image-20210915132104">

<p><strong>然后用上面这些的合适的方程来计算qx,qy,qz的最大值，用</strong></p>
<p><strong><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915131412.png" class="" title="image-20210915131412"></strong></p>
<p><strong>计算qˆ的剩余分量。Sch¨uler提出了一种变体，它没有分枝，但使用了四个平方根。</strong></p>
<h4 id="Spherical-Linear-Interpolation-球形线性插值"><a href="#Spherical-Linear-Interpolation-球形线性插值" class="headerlink" title="Spherical Linear Interpolation 球形线性插值"></a>Spherical Linear Interpolation 球形线性插值</h4><p><strong>球面线性插值是给定两个单位四元数qˆ和ˆr，以及参数t∈[0,1]，计算一个插值四元数的运算。</strong></p>
<p><strong>该运算的代数形式用复合四元数ˆs表示，如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915132448.png" class="" title="image-20210915132448">

<p><strong>然而，对于软件实现来说，下面的形式更合适，其中slerp代表球面线性插值:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915132523.png" class="" title="image-20210915132523">

<p><strong>为了计算公式中所需要的φ，可以用:cos φ = qxrx +qyry +qzrz +qwrw。t∈[0,1],slerp函数,把(unique)四元数插值,共同构成的最短弧四维单位球面上qˆ(t = 0)到ˆr (t = 1)。位于弧圆之间形成的平面qˆ，ˆr,原点,四维单位球体。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915132804.png" class="" title="image-20210915132804">

<p>单位四元数表示为单位球面上的点。利用函数slerp在四元数之间进行插值，插值路径是球面上的一条大圆弧。注意，从qˆ1插值 qˆ2， 从qˆ1插值 qˆ3 ，从qˆ3插值qˆ2 是不一样的，即使它们到达相同的方向。</p>
<p><strong>所计算的旋转四元数以恒定速度绕固定轴旋转。这样的曲线具有恒定的速度，因此加速度为零，称为测地线曲线。球面上的大圆是平面通过原点与球面相交而形成的，这个圆的一部分称为大圆弧。</strong></p>
<p><strong>slerp函数非常适合在两个方向之间插入，并且它表现得很好(固定轴，恒定速度)。这不是用几个欧拉角插值。在实践中，直接计算slerp是一项昂贵的操作，涉及调用三角函数。Malyshau讨论了将四元数集成到渲染管线中。他注意到三角形的方向误差是90度角有最大4度，而不是使用slerp，只是简单地在像素着色器中归一化四元数。在栅格化三角形时，这个错误率是可以接受的。Li提供了更快的增量方法来计算slerps，而且不牺牲任何精度。Eberly提出了一种只用加法和乘法计算slerps的快速技术。</strong></p>
<p><strong>当超过两个方向时，qˆ0qˆ1，…qˆn−1是可得的，我们想从qˆ0插值qˆ1 qˆ2，以此类推，直到qˆn−1，slerp可以直接使用。现在，当我们接近qˆi，我们用qˆi−1 和qˆi 作为已知进行slerp。这将导致方向插补出现突然的抖动。这类似于点是线性插值的情况。</strong></p>
<p><strong>更好的插值方法是使用样条曲线。我们引入四元数ˆai 和aˆi+1 在qˆi 和qˆi+1间。球面三次插值可以定义在四元数集qˆi,aˆi ,aˆi+1,qˆi+1。这些额外的四元数的计算方法如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915133859.png" class="" title="image-20210915133859">

<p><strong>qˆi和aˆi 将使用光滑的三次样条球插值四元数，如公式所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915133950.png" class="" title="image-20210915133950">

<p><strong>如上所述，squad函数是由重复球面插值使用slerp构造而成的。插值将通过初始方向qˆi， I∈[0，…， n - 1]，但不是通过aˆi这些用于指示初始方向的切线方向。</strong></p>
<h4 id="Rotation-from-One-Vector-to-Another-从一个向量到另一个向量的旋转"><a href="#Rotation-from-One-Vector-to-Another-从一个向量到另一个向量的旋转" class="headerlink" title="Rotation from One Vector to Another 从一个向量到另一个向量的旋转"></a>Rotation from One Vector to Another 从一个向量到另一个向量的旋转</h4><p><strong>一个常见的操作是从一个方向s到另一个方向t通过最短路径。四元数的数学大大简化了这一过程，并显示了四元数与这种表示的密切关系。首先对s和t进行归一化，然后计算单位旋转轴u，即u = (s × t)/||s × t||。e = s·t = cos(2φ)， ||s × t|| = sin(2φ)，其中2φ为s与t之间的夹角，则表示s到t旋转的四元数qˆ= (sin φu, cos φ)。实际上，将qˆ= ( sin φ/sin 2φ(s × t)， cos φ)，利用半角关系和三角恒等式，得到</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915141021.png" class="" title="image-20210915141021">

<p><strong>以这种方式直接生成四元数(相对于对叉乘s × t进行归一化)可以避免s和t指向几乎相同方向时的数值不稳定性。当s和t指向相反的方向时，两种方法都会出现稳定性问题，因为会出现除零的情况。当检测到这种特殊情况时，可以使用垂直于s的任意旋转轴来旋转到t。</strong></p>
<p><strong>有时我们需要从s到t的旋转矩阵表示。对</strong></p>
<p><img src="C:\Users\86010\AppData\Roaming\Typora\typora-user-images\image-20210915141155051.png" alt="image-20210915141155051"></p>
<p><strong>进行代数和三角化简后，旋转矩阵为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915141212.png" class="" title="image-20210915141212">

<p><strong>在这个方程中，我们使用了以下中间计算：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915141222.png" class="" title="image-20210915141222">

<p><strong>可以看出，由于化简，所有的平方根和三角函数都消失了，所以这是创建矩阵的一种有效方法。</strong></p>
<p><strong>注意，当s和t平行或接近平行时，必须小心，因为||s × t||≈0。如果φ≈0，则返回单位矩阵。而如果2φ≈π， π弧度就可以绕任意轴旋转。这个轴可以被发现为s与任何其他不平行于s的向量之间的叉积。</strong></p>
<h2 id="Vertex-Blending-顶点混合"><a href="#Vertex-Blending-顶点混合" class="headerlink" title="Vertex Blending 顶点混合"></a>Vertex Blending 顶点混合</h2><p><strong>想象一个数字角色的手臂使用了两个部分，前臂和上臂，如图左边所示。这个模型可以使用刚体转换动画。然而，这两个部分之间的关节将不像一个真正的肘关节。这是因为使用了两个独立的物体，因此，关节由这两个独立物体的重叠部分组成。显然，只使用一个对象会更好。然而，静态模型零件并没有解决使关节灵活的问题。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915142412.png" class="" title="image-20210915142412">

<p>由前臂和上臂组成的手臂使用两个分离的物体的刚体变换到左边动画。肘部看起来不太真实。在右侧，顶点混合用于单个对象。最右边的手臂说明了当简单的皮肤直接连接两部分来覆盖肘部时发生了什么。最右边的手臂说明了使用顶点混合时发生的情况，一些顶点使用不同的权重进行混合:(2/3,1/3)意味着顶点对来自上臂的变换权重为2/3，来自前臂的变换权重为1/3。该图还显示了最右边的插图顶点混合的缺点。这里可以看到肘部内侧的折叠。更多的骨骼和更仔细选择的重量可以达到更好的效果。</p>
<p><strong>顶点混合是解决这个问题的一个常用的方法。这种技术还有其他几个名字，如线性混合蒙皮、包络或骨架子空间变形。定义骨骼和皮肤对变化的反应在计算机动画中是一个古老的概念。在最简单的形式中，前臂和上臂像之前一样是分开活动的，但在关节处，这两个部分通过一个有弹性的“皮肤”连接起来。“所以，这个弹性部分将有一组顶点由前臂矩阵转换，另一组顶点由上臂矩阵转换。这导致三角形的顶点可以由不同的矩阵转换，而不是每个三角形使用一个矩阵。</strong></p>
<p><strong>更进一步，我们可以允许单个顶点由几个不同的矩阵进行变换，得到的位置加权并混合在一起。这是通过为动画对象设置骨骼骨架来实现的，其中每个骨骼的变换可以通过用户定义的权重影响每个顶点。因为整个手臂可能是“有弹性的”，也就是说，所有的顶点可能会受到不止一个矩阵的影响，整个网格通常被称为皮肤(骨头上)。许多商业建模系统都有类似的骨架建模功能。尽管名字叫骨头，但骨头并不一定是坚硬的。例如，Mohr和Gleicher提出了增加额外关节的想法，以实现肌肉膨胀等效果。James和Twigg讨论了使用可以挤压和拉伸的骨骼制作动画皮肤。</strong></p>
<p><strong>数学上，如式所示，其中p为原顶点，u(t)为变换后的顶点，其位置与时间t有关:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915142955.png" class="" title="image-20210915142955">

<p><strong>有n个骨头影响p的位置，p用世界坐标表示。wi的值是顶点p的骨i的权值，矩阵Mi 从初始的骨骼坐标系统转换到世界坐标。一般来说，骨骼的控制关节位于其坐标系的原点。例如，前臂骨将移动它的肘关节到原点，通过一个动画旋转矩阵将手臂的这部分围绕关节移动。Bi(t)矩阵是第i个骨的世界变换，它随时间变化以动画对象，并且通常是几个矩阵的连接，如先前骨变换的层次结构和局部动画矩阵。</strong></p>
<p><strong>维护和更新Bi(t)的一种方法 Woodland深入讨论了矩阵动画函数。每根骨头将一个顶点转换为相对于它自己的参考系的一个位置，并且最终的位置是从计算点集合中插值出来的。矩阵Mi 在一些关于剥皮的讨论中没有明确显示，而是被认为是Bi(t).我们在这里提出它，因为它是一个有用的矩阵，几乎总是矩阵连接过程的一部分。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210915142820.png" class="" title="image-20210915142820">

<p>一个真实的顶点混合的例子。左上方的图像显示了手臂的两个骨头，在一个伸展的位置。在右上角，网格被显示出来，用颜色表示哪个骨骼拥有每个顶点。下:手臂的阴影网格在一个稍微不同的位置。(图片由Jeff Lander提供。)</p>
<p><strong>实际上，矩阵Bi(t)和Mi ^−1为每一帧动画的每一个骨骼连接，每个结果矩阵用于转换顶点。顶点p由不同骨骼的连接矩阵进行变换，然后混合使用权重wi这就是顶点混合的名字。权值是非负的，和是1，所以发生的是，顶点被转换到几个位置，然后在它们之间插入。因此，变换后的点u将位于点Bi(t)Mi ^−1P，对于所有I = 0…n−1(固定t)。法线通常也可以使用上式进行转换。根据所使用的变换(例如，如果骨头被拉伸或压扁相当大)，Bi(t)M^−1 i的逆的转置可能需要。</strong></p>
<p><strong>顶点混合非常适合在GPU上使用。网格中的顶点集可以放置在一个静态缓冲区中，该缓冲区发送给GPU一次并重复使用。在每一帧中，只有骨骼矩阵改变，顶点着色器计算它们对存储网格的影响。通过这种方式，CPU处理和传输的数据量被最小化，允许GPU有效地渲染网格。如果模型的整套骨基质可以一起使用，这是最简单的;否则，模型就必须被拆分，复制一些骨头。另外，骨头变换可以存储在顶点访问的纹理中，这避免了达到寄存器存储限制。通过使用四元数表示旋转，每个变换可以存储在两个纹理中。如果可用，无序访问视图存储允许重用蒙皮结果。</strong></p>
<p><strong>可以指定超出范围[0,1]或总和不为1的权值集。然而，这只有在使用其他混合算法(如morph目标)时才有意义。</strong></p>
<p><strong>基本顶点混合的一个缺点是可能会出现不必要的折叠、扭曲和自交。一个更好的解决方案是使用对偶四元数。这种剥皮技术有助于保持原始变形的刚性，从而避免四肢像糖果包装纸一样扭曲。计算量小于线性蒙皮混合成本的1.5倍，且结果良好，这使得该技术迅速被采用。然而，对偶四元数蒙皮会导致肿胀效应，Le和Hodgins提出旋转中心蒙皮是一种更好的选择。它们依赖于局部变换应该是刚体和具有相似权值的顶点wi，应该有类似的转换。每个顶点的旋转中心都是预先计算好的，而正交(刚体)约束则是为了防止弯头坍塌和包裹扭曲。在运行时，该算法类似于线性混合蒙皮，因为GPU实现在旋转中心执行线性混合蒙皮，然后执行四元数混合步骤。</strong></p>
<h2 id="Morphing-变形"><a href="#Morphing-变形" class="headerlink" title="Morphing 变形"></a>Morphing 变形</h2><p><strong>在执行动画时，从一个三维模型到另一个模型的变形是很有用的。假设一个模型在t0时刻显示,我们希望它在时间t1时变成另一个模型。对于t之间的所有时间t0和t1，利用某种插值方法得到了一个连续的“混合”模型。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210916115814.png" class="" title="image-20210916115814">

<p>顶点变形。每个顶点定义两个位置和法线。在每一帧中，中间位置和法线是由顶点着色器线性插值的。(图片由NVIDIA公司提供。)</p>
<p><strong>变形涉及解决两个主要问题，即顶点对应问题和插值问题。给定两个任意模型，它们可能具有不同的拓扑结构、不同的顶点数量和不同的网格连通性，通常必须首先建立这些顶点对应关系。这是一个难题这一领域已经有了大量的研究。我们向感兴趣的读者推荐Alexa的调查。</strong></p>
<p><strong>然而，如果两个模型之间已经存在一对一的顶点对应关系，那么就可以在每个顶点的基础上进行插值。也就是说，对于第一个模型中的每个顶点，在第二个模型中必须只存在一个顶点，反之亦然。这使得插值变得很容易。例如，线性插值可以直接在顶点上使用。来计算时间t∈[t0, t1]的变形顶点，我们首先计算s = (t−t0) / (t1 −t0)，然后是线性顶点混合，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210916120120.png" class="" title="image-20210916120120">

<p><strong>p0 和p1 对应于同一个顶点，但时间不同，t0 和t1．</strong></p>
<p><strong>变形的一种变体，其中用户有更直观的控制被称为变形目标或混合形状。</strong><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210916123531.png" class="" title="image-20210916123531"></p>
<p>给定两个嘴的姿态，计算一组差分向量来控制插补，甚至外推。在变形目标中，差异向量被用来“添加”运动到中立的面部。如果差分向量的权值为正，我们会得到一个微笑的嘴巴，而负权值则会产生相反的效果。</p>
<p><strong>我们从一个中性模型开始，在这个例子中是一张脸。我们用n表示这个模型。此外，我们还有一组不同的面部姿势。在示例插图中，只有一个姿势，那就是微笑的脸。一般情况下，我们允许k≥1个不同的位姿，表示为Pi, i∈[1，…k)。作为预处理，“差面”计算为:Di = Pi −N,即从每个姿势中减去中性模型。</strong></p>
<p><strong>在这一点上，我们有一个中立模型，N，和一组不同的姿势，Di．则可得到变形模型M，公式如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210916123847.png" class="" title="image-20210916123847">

<p><strong>这是中性模型，在此基础上，我们根据需要添加不同姿势的特征，使用重量wi．在图4.15中，设置w1 = 1给出的正是插图中间的笑脸。使用w1 = 0.5给我们一个半微笑的脸，以此类推。也可以使用负权重和大于1的权重。</strong></p>
<p><strong>对于这个简单的脸部模型，我们可以添加另一张有“悲伤”眉毛的脸。使用负重量的眉毛可以创建“快乐”眉毛。由于位移是附加的，这个眉毛姿势可以与微笑的嘴的姿势一起使用。</strong></p>
<p><strong>变形目标是一种强大的技术，它为动画师提供了大量的控制，因为模型的不同特性可以独立于其他特性进行操作。Lewis等人引入了位姿空间变形，它结合了顶点混合和变形目标。Senior使用预先计算的顶点纹理来存储和检索目标姿态之间的位移。支持流输出的硬件和每个顶点的ID允许在一个模型中使用更多的目标，并且只在GPU上计算效果。使用一个低分辨率的网格，然后通过镶嵌阶段和位移映射生成一个高分辨率的网格，避免了在一个高度详细的模型中蒙皮每个顶点的代价。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210916124022.png" class="" title="image-20210916124022">

<p>在《FAMOUS Second Son》中，Delsin角色的脸是用混合形状制作的。所有这些照片都使用相同的静止姿势脸，然后修改不同的权重，使脸看起来不同。(图片来源:Naughty Dog LLC. inFAMOUS Second Son c 2014索尼互动娱乐有限公司。inFAMOUS Second Son是索尼互动娱乐有限公司的商标，由Sucker Punch Productions LLC开发。)</p>
<p><strong>图显示了一个使用蒙皮和变形的真实示例。Weronko和Andreason在1886年的The Order中使用了剥皮和变形。</strong></p>
<h2 id="Geometry-Cache-Playback-几何缓存回放"><a href="#Geometry-Cache-Playback-几何缓存回放" class="headerlink" title="Geometry Cache Playback 几何缓存回放"></a><strong>Geometry Cache Pl</strong>ayback 几何缓存回放</h2><p><strong>在过场动画中，可能需要使用高质量的动画，例如，对于无法使用上述任何方法表现的动作。一种简单的方法是存储所有帧的所有顶点，从磁盘读取它们并更新网格。然而，对于一个包含30000个顶点的简单模型，在一个简短的动画中，这可能高达50 MB/s。Gneiting提出了几种将存储成本降低到10%左右的方法。</strong></p>
<p><strong>首先，使用量子化。例如，对于每个坐标，位置和纹理坐标使用16位整数存储。这个步骤是有损的，因为在执行压缩后不能恢复原始数据。为了进一步减少数据，进行了空间和时间预测，并对差异进行了编码。对于空间压缩，可以使用平行四边形预测。对于三角形带，下一个顶点的预测位置仅仅是当前三角形在当前三角形边周围的平面上的反映，形成一个平行四边形。然后对这个新位置的差异进行编码。有了良好的预测，大多数值将接近于零，这对许多常用的压缩方案来说是理想的。类似于MPEG压缩，预测也在时间维度。即每n帧进行空间压缩。在这两者之间，预测是在时间维度上完成的，例如，如果某个顶点以delta向量从帧n−1移动到帧n，那么它很可能以与帧n + 1相似的数量移动。这些技术大大减少了存储空间，因此该系统可以用于实时流数据。</strong></p>
<h2 id="Projections-投影"><a href="#Projections-投影" class="headerlink" title="Projections 投影"></a>Projections 投影</h2><p><strong>在真正渲染一个场景之前，场景中所有相关的物体都必须投影到某种平面上或某种简单的体积上。之后，执行裁剪和渲染。</strong></p>
<p><strong>本章到目前为止看到的转换没有影响第四个坐标w分量。也就是说，点和向量在转换后保留了它们的类型。此外，4×4矩阵的底部行一直是(0 0 0 1)。透视投影矩阵是这两种性质的例外:底部行包含向量和点操作数，并且经常需要均匀化过程。也就是说，w通常不是1，所以需要除以w才能得到非齐次点。正投影是一种比较简单的投影，也是常用的投影方法。它不影响w分量。</strong></p>
<p><strong>在本节中，假设观察者沿着相机的负z轴看，y轴向上，x轴向右。这是一个右手坐标系。一些文本和软件，例如DirectX，使用了一个左手系统，在这个系统中，观看者沿着相机的正z轴观看。这两种制度都是同样有效的，最终达到了同样的效果。</strong></p>
<h3 id="Orthographic-Projection-正投影"><a href="#Orthographic-Projection-正投影" class="headerlink" title="Orthographic Projection 正投影"></a>Orthographic Projection 正投影</h3><p><strong>正投影的一个特点是平行线在投影后仍然保持平行。当使用正投影来观察一个场景时，无论距离相机的距离如何，物体都保持相同的大小。矩阵Po，是一个简单的正交投影矩阵，它保持点的x和y分量不变，而将z分量设为零，即它正射向平面z = 0:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917151543.png" class="" title="image-20210917151543">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917151436.png" class="" title="image-20210917151436">

<p><strong>这种投影的效果如图所示。很明显,Po不可逆,因为它的行列式|Po| = 0。换句话说，转换从3维下降到2维，并且没有办法检索下降的维。使用这种直角投影进行观察的一个问题是，它将z值正的点和z值负的点投影到投影平面上。将z值(以及x和y值)限制在一定的区间内通常是有用的，比如从n(近平面)到f(远平面)。这是下一个转换的目的。</strong></p>
<p><strong>执行正投影的一个更常见的矩阵是用六元组表示的(l, r, b, t, n, f)，表示左、右、底、顶、近、远平面。这个矩阵缩放并转换轴向边界框(AABB;(参见第22.2节的定义)由这些平面组成一个轴对齐的立方体，围绕原点。AABB的最小角是(l, b, n)，最大角是(r, t, f)。重要的是要认识到n&gt;f，因为我们是在这个空间的负z轴下看。我们的常识告诉我们，接近值应该比远值低，所以我们可以让用户提供接近值，然后在内部取消它们。</strong></p>
<p><strong>在OpenGL中，轴向立方体的最小角为(−1，−1，−1)，最大角为(1,1,1);在DirectX的边界是(−1，−1,0)到(1,1,1)。这个立方体被称为规范视图体积，这个体积中的坐标被称为标准化设备坐标。转换过程如图所示。转换为规范视图体积的原因是在那里执行裁剪更有效。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917152005.png" class="" title="image-20210917152005">

<p>在规范视图卷上转换轴对齐的框。左边的方框首先被平移，使其中心与原点重合。然后将其缩放以得到规范视图体积的大小。</p>
<p><strong>在转换到规范视图体之后，要渲染的几何体的顶点被剪切到这个立方体上。立方体之外的几何图形最终通过将剩余的单元正方形映射到屏幕来呈现。正投影变换如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917152135.png" class="" title="image-20210917152135">

<p><strong>根据这个方程，Po 可以写成平移矩阵T(t)和缩放矩阵S(s)的串联，其中S = (2/(r - l)， 2/(T - b)， 2/(f - n))且t = (−(r + l)/2, −(t + b)/2, −(f + n)/2)。这个矩阵是可逆的（当且仅当≠ f, l ≠r, t ≠b;否则，不存在逆。），即P^−1 o = T(−t)S((r − l)/2,(t − b)/2,(f − n)/2).</strong></p>
<p><strong>在计算机图形学中，在投影后最常使用的是左坐标系。对于视口，x轴向右，y轴向上，z轴进入视口。由于远值小于我们定义AABB的方法的近值，正射影变换总是包含镜像变换。为了看到这一点，假设原始的AABB与目标，规范视图体积相同。那么AABB的(l, b, n)是(−1，−1,1)且(r, t, f)是(1,1，−1)</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917152611.png" class="" title="image-20210917152611">

<p><strong>这是一个镜像矩阵。正是这种镜像将从右手坐标系(向下看负z轴)转换为左手坐标系。</strong></p>
<p><strong>DirectX将z-depth映射到范围[0,1]，而不是OpenGL的[−1,1]。这可以通过在正字法矩阵之后应用一个简单的缩放和平移矩阵来实现，即，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917152732.png" class="" title="image-20210917152732">

<p><strong>所以，在DirectX中使用的正交矩阵是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917152754.png" class="" title="image-20210917152754">

<p><strong>它通常以转置形式表示，因为DirectX使用行格式来写矩阵。</strong></p>
<h3 id="Perspective-Projection-透视投影"><a href="#Perspective-Projection-透视投影" class="headerlink" title="Perspective Projection 透视投影"></a>Perspective Projection 透视投影</h3><p><strong>透视投影是一种比正投影更复杂的变换，它在大多数计算机图形应用中都很常用。在这里，平行线投影后一般不平行;相反，它们可能会聚到一个极端点。视角与我们感知世界的方式更接近，越远的物体越小。</strong></p>
<p><strong>首先，我们将给出一个投影到平面z =−d, d &gt; 0上的透视投影矩阵的有启发性的推导。我们通过世界空间来简化对世界到视野转换过程的理解。这个推导之后是更传统的矩阵，例如，OpenGL。</strong></p>
<p><strong>假设摄像机(视点)位于原点，我们想将一个点p投影到平面z =−d, d &gt; 0上，产生一个新的点q = (qx,qy，−d)。这个场景如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917153135.png" class="" title="image-20210917153135">

<p>用于推导透视投影矩阵的符号。点p被投影到平面z =−d, d &gt; 0上，得到投影点q。这个投影是从相机的位置的角度进行的，在这个例子中，相机的位置就是原点。在推导过程中使用的类似三角形显示了右边的x分量。</p>
<p><strong>由图中所示的相似三角形，q的x分量可推导为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917153553.png" class="" title="image-20210917153553">

<p><strong>q的其他分量的表达式是qy =−dpy/ pz (类似于qx),qz =−d。加上上面的公式，我们得到了透视投影矩阵Pp，如图所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917153604.png" class="" title="image-20210917153604">

<p><strong>这个矩阵产生正确的透视投影是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917153711.png" class="" title="image-20210917153711">

<p><strong>最后一步是，整个向量除以w分量(在这种情况下，为−pz/d)，在最后的位置得到1。结果的z值总是- d，因为我们投影到这个平面上。</strong></p>
<p><strong>直观上，很容易理解齐次坐标为什么允许投影。对均匀化过程的一种几何解释是，它投射出点(px，py，pz)在w = 1的平面上。</strong></p>
<p><strong>与正投影变换一样，也有透视变换，而不是实际投影到一个平面上(这是不可逆转的)，将视锥体转换为前面描述的标准视图体。这里假设视图平截头体从z = n开始和结束在z = f,且 0 &gt; n &gt; f。矩形在z = n最小的角(b,l,n)和最大的角(r,t,n)。如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917154012.png" class="" title="image-20210917154012">

<p>矩阵Pp 将视图截锥转换为单元立方体，称为规范视图体积。</p>
<p><strong>参数(l, r, b, t, n, f)确定摄像机的视锥。水平视场由截锥的左面和右面(由l和r决定)之间的角度决定。同样，垂直视场由上下平面之间的角度决定(由t和b决定)。视场越大，相机看到的就越多。不对称的视锥体可以由r≠-l或t≠−b创建。例如，不对称视锥用于立体视觉和虚拟现实(章节21.2.3)。</strong></p>
<p><strong>视野是提供场景感的一个重要因素。与电脑屏幕相比，眼睛本身有一个物理视野。这种关系是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917154251.png" class="" title="image-20210917154251">

<p><strong>其中φ为视场，w为物体垂直于视线的宽度，d为到物体的距离。例如，25英寸的显示器大约是22英寸宽。在12英寸外，水平视野是85度;20英寸时，是58度;30英寸，40度。同样的公式可以用于从相机镜头大小转换到视场，例如，一个标准的50mm镜头对一个35mm相机(有一个36mm宽的帧大小)φ = 2 arctan(36/(2.50)) = 39.6度。</strong></p>
<p><strong>与物理设置相比，使用更窄的视野会减少透视效果，因为观察者会被放大到场景中。设置一个更宽的视野会使物体看起来扭曲(像使用广角相机镜头)，特别是靠近屏幕边缘，并会夸大附近物体的比例。然而，更广阔的视野给观众一种物体更大、更令人印象深刻的感觉，并具有给用户更多关于周围环境的信息的优势。</strong></p>
<p><strong>将截锥转换为单位立方体的透视变换矩阵如式所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917154427.png" class="" title="image-20210917154427">

<p><strong>对一个点应用这个变换后，我们会得到另一个点q = (qx,qy,qz,qw）^T ．w分量qw，这个点的值(大多数情况下)是非零且不等于1。为了得到投影点p，我们需要除以qw,也就是说,</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917154607.png" class="" title="image-20210917154607">

<p><strong>矩阵Pp z = f映射到+1,z = n映射到−1。</strong></p>
<p><strong>远平面之外的物体将被裁剪，因此不会出现在场景中。透视投影可以处理远平面的无限大，得方程</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917154710.png" class="" title="image-20210917154710">

<p><strong>综上所述，透视变换(任何形式)，Pp，然后是剪切和均质化(除以w)，结果是标准化的坐标系。</strong></p>
<p><strong>为了得到OpenGL中使用的透视变换，首先与S(1,1，−1,1)相乘，原因与直角变换相同。这只是对Pp第三列中的值求反。在应用了这个镜像变换之后，近距离值和远距离值被输入为正值，0 &lt; n ‘ &lt; f ‘，就像传统上显示给用户的那样。然而，它们仍然表示沿着世界负z轴的距离，这是视图的方向。为了便于参考，下面是OpenGL方程:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917155250.png" class="" title="image-20210917155250">

<p><strong>一个简单的设置是只提供垂直视场，φ，长宽比a = w/h(其中w × h是屏幕分辨率)，n ‘和f ‘。这将导致</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917155353.png" class="" title="image-20210917155353">

<p><strong>式中c = 1.0/ tan(φ/2)。这个矩阵所做的正是旧的gluPerspective()所做的，它是OpenGL实用程序库(GLU)的一部分。</strong></p>
<p><strong>一些API(例如DirectX)将近平面映射为z = 0(而不是z =−1)和远平面映射为z = 1。此外，DirectX使用左手坐标系来定义它的投影矩阵。这意味着DirectX沿着正z轴，并将近值和远值表示为正数。下面是DirectX的等式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917160844.png" class="" title="image-20210917160844">

<p><strong>DirectX在其文档中使用行格式，所以这个矩阵通常以转置形式表示。</strong></p>
<p><strong>使用透视变换的一个效果是，计算的深度值不会随输入线性变化pz 值。使用方程中的任何一个与点p相乘，我们可以得到</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917161152.png" class="" title="image-20210917161152">

<p><strong>省略了vx 和vy ，常数d和f取决于所选的矩阵。那么d = - (f ‘ +n ‘)/(f ‘−n ‘)， e = - 2f ‘ n ‘ /(f ‘−n ‘)，和vx=−pz．为了获得归一化设备坐标(NDC)中的深度，我们需要除以w分量，结果是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917161410.png" class="" title="image-20210917161410">

<p><strong>在zNDC ∈[−1，+1]表示OpenGL投影。可以看出，输出深度为zNDC 与输入深度pz．</strong></p>
<p><strong>例如，如果n′ = 10和f ′ = 110(使用OpenGL)，当pz 是负z轴下60单位(即。归一化的设备坐标深度值为0.833，而不是0。下图显示了改变近平面距离原点的影响。近平面和远平面的位置会影响z缓冲区的精度。这个影响将在第23.7节进一步讨论。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917161546.png" class="" title="image-20210917161546">

<p>改变近平面到原点的距离所产生的影响。距离f ‘−n ‘保持在100。当近平面变得更接近原点时，离远平面更近的点使用更小的归一化设备坐标(NDC)深度空间。这使得z缓冲区在更远的距离上不那么精确。</p>
<p><strong>有几种方法可以提高深度精度。一个常见的方法，我们称之为反向z，是存储1.0−zNDC 可以是浮点深度，也可以是整数。对比下图所示。Reed用模拟来展示使用带反转z的浮点缓冲区提供了最好的精度，这也是整数深度缓冲区(通常每个深度有24位)的首选方法。对于标准映射(即未反向z）Upchurch和Des- brun提出，在变换中分离投影矩阵可以降低错误率。例如，使用P(Mp)可能比使用Tp更好，其中T = PM。此外，在[0.5,1.0]范围内，fp32和int24在精度上非常相似，因为fp32有一个23位尾数。有z的原因NDC 比例为1 / pz 它使硬件更简单，深度压缩更成功，这将在23.7节详细讨论。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917161747.png" class="" title="image-20210917161747">

<p>使用DirectX变换设置深度缓冲区的不同方法，例如:, zNDC ∈(0,+ 1)。左上:标准整数深度缓冲区，这里显示为4位精度(因此y轴上有16个标记)。右上:远平面设置为∞，两个轴上的小移动表明这样做并不会损失太多的精度。左下:有3个指数位和3个尾数位用于浮点深度。注意y轴上的分布是非线性的，这使得x轴上的分布更糟糕。右下:反向浮点深度，即1 - zNDC，结果是更好的分布。(插图由Nathan Reed提供。)</p>
<p><strong>Lloyd建议使用深度值的对数来提高阴影地图的精度。Lauritzen等人使用前一帧的z缓冲区来确定近平面的最大值和远平面的最小值。对于屏幕空间深度，Kemen建议使用以下每个顶点的重映射:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917162211.png" class="" title="image-20210917162211">

<p><strong>其中w是投影矩阵后的顶点的w值，z是顶点着色器的输出z。固定的fc为fc = 2/ log2(f + 1)其中f是远平面。当这个变换只应用于顶点着色器时，深度仍然会被GPU线性插值在顶点的非线性变换深度之间。因为对数是单调的只要分段线性插值和精确的非线性转换深度值之间的差异很小，函数、遮挡剔除硬件和深度压缩技术仍然有效。这对于大多数有足够几何镶嵌的情况是正确的。然而，也可以对每个片段应用转换。这是通过输出每个顶点的值e = 1 + w来完成的，然后由GPU在三角形上插值。像素着色器然后修改片段深度为log2 (ei)fc/2, ei 是e的插值值。当GPU中没有浮点深度以及使用大的深度距离渲染时，这种方法是一个很好的选择。</strong></p>
<p><strong>Cozzi提出使用多个视锥体，这可以有效地提高精度到任何期望的速率。视锥在深度方向上被划分为若干个不重叠的较小次视锥，次视锥的结合就是视锥。子视锥按前后顺序呈现。首先，颜色和深度缓冲都被清除，所有要渲染的对象都被分类到它们重叠的每个子视锥中。对于每个子视锥，它的投影矩阵被建立，深度缓冲区被清除，然后重叠的对象被渲染。</strong></p>
<h1 id="5-Shading-Basics-基本着色器"><a href="#5-Shading-Basics-基本着色器" class="headerlink" title="5 Shading Basics 基本着色器"></a>5 Shading Basics 基本着色器</h1><h2 id="Shading-Models-着色模型"><a href="#Shading-Models-着色模型" class="headerlink" title="Shading Models 着色模型"></a>Shading Models 着色模型</h2><p><strong>决定渲染对象外观的第一步是选择一个着色模型来描述对象的颜色应该如何根据表面方向、视图方向和照明等因素变化。</strong></p>
<p><strong>作为一个例子，我们将使用Gooch着色模型的一个变体。这是一种非写实的渲染形式，也是第15章的主题。Gooch着色模型的设计是为了增加技术插图细节的易读性。</strong></p>
<p><strong>Gooch着色的基本思想是比较表面法线和光的位置。如果法线指向光，则使用暖色调给表面上色;如果它指向远处，则使用较冷的色调。在这些色调之间插入角度，这是基于用户提供的表面颜色。在这个例子中，我们添加了一个程式化的“高亮”效果给模型表面一个闪亮的外观。如图显示了运行中的着色模型。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917164408.png" class="" title="image-20210917164408">

<p>一个程式化的底纹模型结合Gooch着色和高光效果。上面的图像显示了一个表面颜色为中性的复杂物体。下面的图片显示了不同表面颜色的球体。(Chinese Dragon mesh摘自Computer Graphics Archive， original model摘自Stanford 3D Scanning Repository)</p>
<p><strong>着色模型通常有用于控制外观变化的属性。设置这些属性的值是确定对象外观的下一步。我们的示例模型只有一个属性，即表面颜色，如上图底图所示。</strong></p>
<p><strong>像大多数着色模型一样，受相对于视图和光照方向的表面方向的影响。为了遮光，这些方向通常表示为标准化(单位长度)向量，如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917164719.png" class="" title="image-20210917164719">

<p>单位长度矢量输入的着色模型(和大多数其他):表面法线n，视图矢量v，和光方向l。</p>
<p><strong>现在我们已经定义了着色模型的所有输入，我们可以看看模型本身的数学定义:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917165222.png" class="" title="image-20210917165222">

<p><strong>在这个方程中，我们使用了以下中间计算:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917165240.png" class="" title="image-20210917165240">

<p><strong>这个定义中的几个数学表达式经常在其它的定义中找到还有着色模型。clamp操作，典型的clamp到0或clamp在0和1之间，在着色中很常见。这里我们使用1.2节介绍的x+-符号，来表示计算高亮混合因子s时使用的0和1之间的夹紧。点积运算符出现了三次，每次出现在两个单位长度向量之间;这是一种非常常见的模式。两个向量的点积是它们的长度和夹角的余弦值的乘积。所以，两个单位长度向量的点积就是余弦，这是两个向量对齐程度的一个有用度量。在着色模型中，由余弦组成的简单函数通常是描述两个方向(如光方向和表面法线)之间关系的准确的数学表达式。</strong></p>
<p><strong>另一个常见的着色操作是基于0到1之间的标量值在两种颜色之间进行线性插值。该操作的形式为tca + (1 - t)cb 它在c之间插入ca 和cb 当t的值分别在1和0之间移动时。这个模式在这个着色模型中出现了两次，第一次是在cwarm 和ccool 然后在前面的插值结果和c之间进行插值highlight．线性插值经常出现在着色器中，它是一个内置函数，称为lerp或mix，在我们所见过的每一种着色语言中。</strong></p>
<p><strong>行“r = 2 (n·l)n−l”计算反射光矢量，反射l大约n。虽然不像前两种操作那么常见，但对于大多数着色语言来说，这是足够常见的，因此也有一个内置的反射函数。</strong></p>
<p><strong>通过将这些操作以不同的方式与各种数学表达式和着色参数相结合，可以为各种程式化和逼真的外观定义着色模型。</strong></p>
<h2 id="Light-Sources-光源"><a href="#Light-Sources-光源" class="headerlink" title="Light Sources 光源"></a>Light Sources 光源</h2><p><strong>光照对我们例子中的着色模型的影响非常简单;它为着色提供了一个主要方向。当然，现实世界中的照明可能相当复杂。可以有多个光源，每个光源都有自己的大小、形状、颜色，和强度;间接照明增加了更多的变化。正如我们将在第9章中看到的，基于物理的、逼真的着色模型需要考虑所有这些参数。</strong></p>
<p><strong>相比之下，程式化的着色模型可以根据应用程序和视觉风格的需要，以许多不同的方式使用照明。一些高度程式化的模型可能根本没有光照的概念，或者(像我们Gooch着色的例子)可能只使用它来提供一些简单的方向性。</strong></p>
<p><strong>光照复杂性的下一步是让着色模型以二进制的方式对光线的存在或不存在做出反应。一个被这样的模型着色的表面在被光照时将会有一个外观，而在不受光照影响时则会有不同的外观。这意味着一些区分这两种情况的标准:与光源的距离，阴影(将在第7章中讨论)，表面是否面对光源(即表面法线n和光线向量l之间的角度大于90◦)，或这些因素的某种组合。</strong></p>
<p><strong>从光的二元存在或缺失到光强度的连续尺度只有一小步。这可以表示为缺失和完全存在之间的简单插值，这意味着强度的有界范围，可能是0到1，或作为一个以其他方式影响着色的无界量。对于后者，一个常见的选择是将着色模型分解为有光和没有光的部分，光强度为klight 线性缩放被照亮的部分:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918134527.png" class="" title="image-20210918134527">

<p><strong>这很容易扩展到RGB浅色clight，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918134538.png" class="" title="image-20210918134538">

<p><strong>对于多种光源，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918134552.png" class="" title="image-20210918134552">

<p><strong>未点亮的部分funlit(n, v)对应于视光为二进制的着色模型的“不受光线影响时的外观”。它可以有各种形式，取决于所需的视觉风格和应用程序的需要。例如,funlit() =(0,0,0)将使任何不受光源影响的表面变成纯黑色。另一方面，未照明的部分可以表达某种形式的程式化外观，为未照明的物体，类似于Gooch模型的冷颜色面向远离光的表面。通常，这部分的着色模型表达了一些形式的照明，不是直接来自明确放置的光源，如来自天空的光或从周围物体反弹的光。这些其他形式的照明将在第10章和第11章中讨论。</strong></p>
<p><strong>我们前面提到过，如果光源方向l大于90◦ ，则光源不影响表面点从表面法线n，实际上来自在表面。这可以被认为是光的方向，相对于表面，和它对着色的影响之间更普遍关系的一个特殊情况。尽管这种关系是基于物理的，但它可以从简单的几何原理中推导出来，并且对于许多类型的非物理的、程式化的着色模型也很有用。</strong></p>
<p><strong>光照在表面上的效果可以被看作是一组光线，光线的密度与光照强度相对应，以达到表面着色的目的。如图所示，它显示了被照亮表面的横截面。击中表面间距光线沿横截面成反比夹角的余弦值l和n。所以,光线击中的整体密度表面夹角的余弦成正比l和n,这正如我们前面看到的,等于这两个单位长度向量的点积。在这里我们看到了为什么定义光矢量l与光的运动方向相反的;否则我们必须在做点积之前对它进行无效化。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918135025.png" class="" title="image-20210918135025">

<p>图的上一行显示了光在表面上的横截面视图。在左边，光线直直地照射在表面上，在中间，光线以一个角度照射在表面上，在右边，我们看到了向量点积来计算角度余弦。下面的图显示了横截面平面(包括光线和视图向量)与整个表面的关系。</p>
<p><strong>更准确地说，当点积为正时，光线密度(以及光线对着色的影响)与点积成正比。负值对应的是从表面后面来的光线，没有影响。所以，在用光的着色乘以光的点积之前，我们需要先clamp点积为0。使用1.2节中介绍的x+符号，这意味着将负数clamp为零，我们有</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918135453.png" class="" title="image-20210918135453">

<p><strong>支持多个光源的着色模型通常会使用方程</strong></p>
<p><strong><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918134552.png" class="" title="image-20210918134552"></strong></p>
<p><strong>中的一个结构，这是更一般的，或者方程</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918135453.png" class="" title="image-20210918135453">

<p><strong>这是物理模型所需要的。它对程式化的模型也很有好处，因为它有助于确保照明的整体一致性，特别是面对光线或阴影的表面。然而，有些模型并不适合这种结构;这些模型将使用</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918134552.png" class="" title="image-20210918134552">

<p><strong>函数flit()的最简单的选择是使它成为一种恒定的颜色，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918135900.png" class="" title="image-20210918135900">

<p><strong>得到如下着色模型:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918135913.png" class="" title="image-20210918135913">

<p><strong>这个模型中被照亮的部分对应于Lambertian着色模型，以约翰·海因里希·兰伯特命名，他在1760年发表了这个模型。该模型适用于理想的漫反射表面，即完全哑光的表面。我们在这里对Lambert模型作了一些简化的解释，这将在第9章中详细讨论。Lambertian模型本身可以用于简单的着色，它是许多着色模型的关键组成部分。</strong></p>
<p><strong>由上面的式子可知，光源通过两个参数与着色模型相互作用:指向光源的向量l和光源颜色clight．有各种不同类型的光源，主要区别于这两个参数在场景中的变化。</strong></p>
<p><strong>接下来我们将讨论几种常有的类型的光源,有一个共同点:在给定表面位置,每个表面的照明光源,只从一个方向l。换句话说,光源,从表面着色的位置,是一个无限小的点。这对现实世界的光来说并不完全正确，但大多数光源相对于它们与被照表面的距离来说都很小，这是一个合理的近似。在第7.1.2节和10.1节中，我们将讨论从一定范围的方向照亮一个表面位置的光源，即“区域灯”。</strong></p>
<h3 id="Directional-Lights-定向光源"><a href="#Directional-Lights-定向光源" class="headerlink" title="Directional Lights 定向光源"></a>Directional Lights 定向光源</h3><p><strong>定向光是光源的最简单模型。l和clight 都是常数，除了clight 可因阴影而减弱。定向光没有位置。当然，实际的光源在空间中有特定的位置。方向性光源是抽象的，当与光源的距离相对于场景大小较大时，它工作得很好。例如，一个20英尺外的泛光灯照亮一个小的桌面立体模型，可以表示为一个方向灯。另一个例子是任何被太阳照亮的场景，除非这个场景是像太阳系的内行星这样的东西。</strong></p>
<p><strong>方向性光的概念可以扩展到允许改变clight 而光的方向l保持不变。这通常是为了将光线的效果限定在场景的特定部分，以达到表演或创作的目的。例如，一个区域可以定义为两个嵌套的(一个在另一个里面)盒形体，其中clight 等于(0,0,0)(纯黑)在外面的盒子里，等于某个常数在里面的盒子里，然后平滑地在两个盒子之间的区域内插值。</strong></p>
<h3 id="Punctual-Lights-守时的光源"><a href="#Punctual-Lights-守时的光源" class="headerlink" title="Punctual Lights 守时的光源"></a>Punctual Lights 守时的光源</h3><p><strong>守时灯不是指准时赴约的灯，而是指有位置的灯，不像定向光。这种灯也没有尺寸，没有形状或大小，不像现实世界的光源。我们使用“准时”这个词，这个词来自拉丁语“punctus”，意思是“点”，指的是由来自一个单一的、局部的位置的所有照明来源组成的一类。我们用“点光”这个术语来表示一种特定的发射器，它向各个方向均匀地发光。所以，点和聚光灯是两种不同形式的准时照明。光方向向量l的变化取决于当前着色表面点p0 相对于点灯的位置plight：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918141138.png" class="" title="image-20210918141138">

<p><strong>这个等式是向量规范化的一个例子:将一个向量除以它的长度，得到一个指向相同方向的单位长度向量。这是另一个常见的着色操作，就像我们在上一节看到的着色操作一样，它是大多数着色语言中的内置函数。然而，有时需要这个操作的中间结果，这需要在多个步骤中使用更基本的操作显式地执行规范化。将此应用于准时光方向计算得到以下结果:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918141148.png" class="" title="image-20210918141148">

<p><strong>因为两个向量的点积等于两个向量的长度与夹角的余弦值的乘积，以及0◦的余弦值的乘积点积是1一个向量与它自身的平方。为了求任意向量的长度，我们只需要将它与自身作点积然后取结果的平方根。</strong></p>
<p><strong>我们需要的中间值是r，即点状光源和当前着色点之间的距离。除了用于光矢量的归一化，r的值还需要计算光色clight的衰减(变暗)作为距离的函数。这将在下一节中进一步讨论。</strong></p>
<h4 id="Point-Omni-Lights-点光源-泛光灯"><a href="#Point-Omni-Lights-点光源-泛光灯" class="headerlink" title="Point/Omni Lights 点光源/泛光灯"></a>Point/Omni Lights 点光源/泛光灯</h4><p><strong>向各个方向均匀发出光的准时灯被称为点灯光源或泛光灯。对于点光源，clight 变化是距离r的函数，变化的唯一来源是上面提到的距离衰减。下图展示了为什么会出现这种变暗，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918141912.png" class="" title="image-20210918141912">

<p>从点光源发出的光线之间的间距与距离r成比例地增加。由于间距的增加发生在二维空间中，光线密度(和光强度)与1/r成比例地减少2．</p>
<p><strong>使用类似于的余弦因子的几何推理。在给定的表面上，点光源发出的光线之间的间距与从表面到光线的距离成正比。与之前的余弦因子不同，这种间距的增加发生在表面的两个维度上，因此射线密度(以及浅色clight)与距离的平方反比1/r²．这使我们能够指定clight中的空间变异有一个单一的光属性，clight0 ，定义为clight在固定参考距离r0处的值：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918142530.png" class="" title="image-20210918142530">

<p><strong>上式常称为反平方光衰减。虽然从技术上讲，点光源的正确距离衰减，有一些问题使这个方程不太理想的物理着色使用。</strong></p>
<p><strong>第一个问题发生在相对较小的距离。当r的值趋于0时，clight 将以无界的方式增长。当r达到0时，我们有一个除以0的奇点。为了解决这个问题，一个常见的修改是在分母上加一个小值E:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918142650.png" class="" title="image-20210918142650">

<p><strong>E使用的确切值取决于应用程序;例如， Unreal Engine使用E = 1厘米。</strong></p>
<p><strong>在CryEngine和Frostbite游戏引擎中使用的另一种修改是将r clamp到最小值rmin：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918142928.png" class="" title="image-20210918142928">

<p><strong>与前面方法中使用的有点任意的E值不同，rmin 有一个物理解释:发出光的物理物体的半径。r小于rmin 对应于被着色的表面穿透到物理光源内部，这是不可能的。</strong></p>
<p><strong>相反，平方反衰减的第二个问题发生在相对较大的距离上。问题不在于视觉效果，而在于性能。尽管光强随距离不断减小，但它从不趋于0。为了有效的渲染，光在一定距离达到0强度是可取的(第20章)。有许多不同的方法可以修改平方反比方程来达到这个目的。理想情况下，修改应该引入尽可能少的更改。为了避免在光线影响的边界处出现尖锐的截止，修改后的函数的导数和值在相同的距离处达到0也是更好的。一种解决方法是将平方反比方程乘以一个窗函数所需的属性。其中一个功能被Unreal Engine和Frostbite游戏引擎使用:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918173026.png" class="" title="image-20210918173026">

<p><strong>+2的意思是，如果值是负数，则在平方它之前clamp到0。下图显示了一个反平方曲线，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918173146.png" class="" title="image-20210918173146">

<p>这个图显示了一条反平方曲线(使用E方法来避免奇点，E值为1)，方程中描述的窗口函数(rmax 设置为3)，窗口曲线。</p>
<p><strong>方程中的窗口函数，以及两者相乘的结果。</strong></p>
<p><strong>应用要求将影响使用方法的选择。例如，rmax 处的导数为0当距离衰减函数以相对较低的空间频率采样时(例如，在光照贴图或逐顶点)，这一点尤为重要。CryEngine不使用光照贴图或顶点光照，所以它采用了一个更简单的调整，在0.8rmax和rmax之间切换到线性衰减。</strong></p>
<p><strong>对于一些应用程序，匹配反平方曲线不是优先考虑的，所以完全使用其他一些函数。这有效地将上方一系列方程推广为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918173539.png" class="" title="image-20210918173539">

<p><strong>fdist(r)是距离的函数。这样的函数称为距离衰减函数。在某些情况下，非反平方衰减函数的使用是由性能约束驱动的。例如，在《Just Cause 2》中，灯光的计算成本非常低。这要求了一个易于计算的衰减函数，同时也足够平滑，以避免逐顶点光照伪影:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918173619.png" class="" title="image-20210918173619">

<p><strong>在其他情况下，衰减函数的选择可能是由创造性考虑驱动的。例如，虚幻引擎，用于现实和风格游戏，有两种模式的光衰减:反平方模式和指数衰减模式，可以调整以创建各种衰减曲线。《古墓丽影》(2013)的开发者使用样条编辑工具来绘制衰减曲线，从而更好地控制曲线形状。</strong></p>
<h4 id="Spotlights-聚光灯"><a href="#Spotlights-聚光灯" class="headerlink" title="Spotlights 聚光灯"></a>Spotlights 聚光灯</h4><p><strong>与点光源不同，现实世界中几乎所有光源的照明都因方向和距离而变化。这种变化可以表示为一个方向衰减函数fdir(l)，结合距离衰减函数来定义光强的整体空间变化:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918173746.png" class="" title="image-20210918173746">

<p><strong>不同的fdir(l)能产生各种灯光效果。其中一种重要的效应是聚光灯，它将光线投射成一个圆锥体。聚焦方向衰减函数围绕聚焦方向矢量s具有旋转对称性，因此可以表示为角度θs在s和反方向的光矢量−l之间。光矢量需要反转，因为我们在表面定义l指向光，而这里我们需要向量指向光。</strong></p>
<p><strong>大多数聚焦函数使用由θs的余弦函数表达，它(正如我们之前看到的)是着色中最常见的角度形式。聚光灯通常有一个本影角θu，它限制了光线，使所有θs ≥θu，fdir(l)=0．这个角度在类似于最大衰减距离rmax 见过。聚光灯有一个半影角θp也是很常见的，它定义了一个内锥，在那里光线达到最大强度。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918174300.png" class="" title="image-20210918174300">

<p>一个焦点:θs 为从光定义的方向s到向量- l(指向表面的方向)的角度;θp 显示了模糊;和θu 显示为光定义的本影角度。</p>
<p><strong>聚光灯使用了各种方向衰减函数，但它们往往是大致相似的。例如函数fdirF (l)用于Frostbite游戏引擎，函数fdirT (l)用于three.js浏览器图形库:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918174509.png" class="" title="image-20210918174509">

<p><strong>回想一下，x+-是在0和1之间 clamp x的符号，在第1.2节中介绍过。平滑步进函数是一个三次多项式，经常用于光滑插值着色。它是大多数着色语言中的内置函数。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918174628.png" class="" title="image-20210918174628">

<p>此图显示了到目前为止我们已经讨论过的一些类型的光。从左到右:定向光、没有衰减的点光源、有平稳过渡的聚光灯。注意，点光源向边缘变暗是因为光源和表面之间的角度变化。</p>
<h4 id="Other-Punctual-Lights-其他守时的灯"><a href="#Other-Punctual-Lights-其他守时的灯" class="headerlink" title="Other Punctual Lights 其他守时的灯"></a>Other Punctual Lights 其他守时的灯</h4><p><strong>clight 的值可以变化。</strong></p>
<p><strong>fdir(l)函数不局限于上面讨论的简单聚光灯衰减函数;它可以代表任何类型的方向变化，包括从真实世界的光源测量的复杂的表格模式。照明工程协会(IES)已经为这种测量定义了标准文件格式。IES简介可从许多照明制造商，并已用于游戏Killzone: Shadow Fall，以及Unreal和Frostbite游戏引擎等。拉加德很好地总结了与解析和使用该文件格式有关的问题。</strong></p>
<p><strong>《古墓丽影》(2013)中有一种准时光，它适用于x, y和z世界轴上的距离独立衰减函数。在《古墓丽影》中，曲线也可以用来改变光照强度，例如，产生闪烁的手电筒。</strong></p>
<p><strong>在第6.9节中，我们将讨论如何通过使用纹理来改变光的强度和颜色。</strong></p>
<h3 id="Other-Light-Types-其他光源"><a href="#Other-Light-Types-其他光源" class="headerlink" title="Other Light Types 其他光源"></a>Other Light Types 其他光源</h3><p><strong>定向光和守时光的主要特征是如何计算光的方向l。不同类型的光可以通过使用其他方法来计算光的方向来定义。例如，除了前面提到的灯光类型，《古墓丽影》还使用线段作为光源的胶囊灯，而不是点。对于每个着色像素，以线段上最近点的方向作为光方向l。</strong></p>
<p><strong>只要着色器有l和clight 值用于估计着色方程，任何方法都可以用来计算这些值。</strong></p>
<p><strong>到目前为止所讨论的光的类型都是抽象的。在现实中，光源有大小和形状，它们从多个方向照亮表面点。在渲染中，这样的灯被称为区域灯，它们在实时应用中的使用正在稳步增加。区域光渲染技术分为两类:模拟区域光部分闭塞导致阴影边缘的软化(第7.1.2节)和模拟区域光对表面着色的影响(第10.1节)。对于光滑的镜面表面来说，第二种类型的照明是最明显的，在这种表面上，光的形状和大小可以从它的反射中清楚地辨别出来。定向光和守时光不太可能被废弃，尽管它们不再像过去那样无处不在。计算光的面积的近似方法已经开发出来了，实现起来相对简单，因此得到了更广泛的应用。提高的GPU性能也允许比过去更精细的技术。</strong></p>
<h2 id="Implementing-Shading-Models-实现着色模型"><a href="#Implementing-Shading-Models-实现着色模型" class="headerlink" title="Implementing Shading Models 实现着色模型"></a>Implementing Shading Models 实现着色模型</h2><p><strong>为了有用，这些着色和光照方程当然必须在代码中实现。在本节中，我们将讨论设计和编写此类实现时的一些关键考虑因素。我们还将浏览一个简单的实现示例。</strong></p>
<h3 id="Frequency-of-Evaluation-评估频率"><a href="#Frequency-of-Evaluation-评估频率" class="headerlink" title="Frequency of Evaluation 评估频率"></a>Frequency of Evaluation 评估频率</h3><p><strong>当设计一个着色实现时，需要根据计算的频率进行划分。首先，确定给定计算的结果在整个draw调用中是否始终是常量。在这种情况下，计算可以由应用程序执行，通常在CPU上，尽管GPU计算着色器可以用于特别昂贵的计算。结果通过统一的着色器输入传递给图形API。</strong></p>
<p><strong>即使在这个类别中，评估的可能频率也有很大的范围，从“once ever”开始。最简单的例子是着色方程中的常量子表达式，但这可以应用于基于很少变化的因素的任何计算，如硬件配置和安装选项。这样的着色计算可能会在编译着色器时解决，在这种情况下甚至不需要设置一个统一的着色器输入。或者，计算可以在离线预计算过程中执行，在安装时执行，或者在加载应用程序时执行。</strong></p>
<p><strong>另一种情况是，当着色计算的结果在应用程序运行过程中发生变化，但速度很慢，没有必要每一帧都更新它。例如，在虚拟游戏世界中，光照因素取决于一天中的时间。如果计算是昂贵的，它可能是值得摊销在多个帧。</strong></p>
<p><strong>其他情况包括每帧执行一次的计算，如连接视图和透视矩阵;或者每个模型一次，例如更新依赖于位置的模型照明参数;或者每次绘制调用一次，例如，更新模型中每个材质的参数。根据评估频率对统一的着色器输入进行分组有助于提高应用效率，并通过最小化不断更新来帮助GPU提升性能。</strong></p>
<p><strong>如果一个着色计算的结果在绘制调用中发生了变化，它不能通过一个统一的着色器输入传递给着色器。相反，它必须由第3章中描述的可编程着色器阶段之一计算，如果需要，通过不同的着色器输入传递到其他阶段。理论上，着色计算可以在任何可编程阶段执行，每个阶段对应不同的评估频率:</strong></p>
<pre><code>**顶点着色：评估每个预镶嵌细分顶点。**

**外壳着色器：评估每个表面补丁。**

**域着色器：评估每个后镶嵌细分顶点。**

**几何着色器：每个原始元素评估。**

**像素着色器：每像素评估。**
</code></pre>
<p><strong>在实践中，大多数着色计算是按像素执行的。虽然这些通常是在像素着色器中实现的，但计算着色器的实现越来越普遍;一些例子将在第20章中讨论。其他阶段主要用于几何操作，如变换和变形。为了理解为什么会出现这种情况，我们将比较逐顶点和逐像素着色计算的结果。在较早的文献中，它们有时被分别称为Gouraud着色和Phong着色，尽管这些术语现在不常使用。这个比较使用了一个类似于公式</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210917165222.png" class="" title="image-20210917165222">

<p><strong>的着色模型，但是修改了它来处理多个光源。完整的模型将在稍后详细介绍示例实现时给出。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918192859.png" class="" title="image-20210918192859">

<p>对比着色模型的逐像素和逐顶点计算，显示了三个不同顶点密度的模型。左边的列显示逐像素计算的结果，中间的列显示逐顶点计算的结果，右边的列显示每个模型的线框渲染图，以显示顶点密度。(Chinese Dragon mesh摘自Computer Graphics Archive，original model摘自Stanford 3D Scanning Repository)</p>
<p><strong>上图显示了在大范围的顶点密度模型上逐像素和逐顶点着色的结果。对于龙来说，网格非常密，两者之间的差别很小。但在茶壶上，顶点着色评估会导致可见的错误，如在两个三角形平面上出现角形高光，显然是不正确的。造成这些错误的原因是部分着色方程，特别是高光，有非线性变化的值网格曲面。这使得它们不适合顶点着色器，其结果在被提供给像素着色器之前在三角形上进行线性插值。</strong></p>
<p><strong>原则上，在像素着色器中只计算着色模型的高光部分，而可能在顶点着色器中计算其余部分。这可能不会产生视觉伪影，而且理论上可以节省一些计算。在实践中，这种混合实现往往不是最佳的。着色模型的线性变化部分的计算成本最低，并且以这种方式分割着色计算可能会增加开销，例如重复计算和额外的变化输入，从而超过好处。</strong></p>
<p><strong>正如我们之前提到的，在大多数实现中，顶点着色器负责非着色操作，如几何变换和变形。生成的几何表面属性，转换成适当的坐标系统，由顶点着色器写出来，在三角形上进行线性插值，并作为不同的着色器输入传递到像素着色器。这些属性通常包括表面的位置，表面法线，可选的表面切向量，法线映射。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918193802.png" class="" title="image-20210918193802">

<p>在左边，我们看到单位法线在曲面上的线性插值结果是长度小于1的插值向量。在右边，我们看到长度显著不同的法线的线性插值导致插值方向向两个法线的较长的方向倾斜。</p>
<p><strong>注意，即使顶点着色器总是生成单位长度的表面法线，插值也可以改变它们的长度。如图左侧所示。由于这个原因，法线需要在像素着色器重新标准化(缩放到长度1)。然而，顶点着色器生成的法线长度仍然很重要。如果顶点之间的法向长度变化显著，例如，作为顶点混合的副作用，这将使插值偏斜。这可以在图的右侧看到。由于这两种效果，经常在插值前后对插值向量进行归一化，即在顶点和像素着色器。</strong></p>
<p><strong>与表面法线不同的是，指向特定位置的向量，如视图向量和守时灯向量，通常不会被插值。相反，插值的表面位置用于计算像素着色器中的这些向量。除了归一化(我们已经看到在任何情况下都需要在像素着色器中执行)，每个向量都是通过向量减法计算的，这是非常快速的。如果出于某种原因，有必要插入这些向量，不要预先归一化它们。这将产生不正确的结果，如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918194249.png" class="" title="image-20210918194249">

<p>两个光矢量之间的插值。在左边，插值前的归一化导致插值后的方向不正确。在右边，插值非归一化向量得到正确的结果。</p>
<p><strong>之前我们提到过顶点着色器将表面几何转换为“适当的坐标系统”。摄像机和光线的位置，通过统一变量传递给像素着色器，通常由应用程序转换到相同的坐标系统。这将最小化像素着色器所做的工作，以将所有着色模型向量带入相同的坐标空间。但是哪个坐标系才是“合适”的呢？可能包括全局世界空间以及相机的局部坐标系统，或者当前渲染模型的坐标系统。基于系统的考虑(如性能、灵活性和简单性)，通常会对整个渲染系统做出选择。例如，如果渲染场景需要包含大量的光，则可以选择世界空间，以避免改变光的位置。另外，相机空间可能是首选，以更好地优化与视图向量相关的像素着色器操作，并可能提高精度(章节16.6)。</strong></p>
<p><strong>尽管大多数着色器实现，包括我们将要讨论的示例实现，遵循上面描述的一般大纲，当然也有例外。例如，一些应用程序出于风格上的原因选择每个原始底纹评价的面外观。这种风格通常被称为平面着色。下图显示了两个例子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918194718.png" class="" title="image-20210918194718">

<p>两款使用平面着色作为风格选择的游戏:《Kentucky Route Zero》(顶部)和《that Dragon》(底部)。(上图来自Cardboard Computer，下图来自Numinous Games。)</p>
<p><strong>原则上，平面着色可以在几何着色器中执行，但目前的实现通常使用顶点着色器。这是通过将每个元素的属性与其第一个顶点关联并禁用顶点值插值来实现的。禁用插值(可以分别对每个顶点值执行)会导致第一个顶点的值被传递给元素中的所有像素。</strong></p>
<h3 id="Implementation-Example-实现示例"><a href="#Implementation-Example-实现示例" class="headerlink" title="Implementation Example 实现示例"></a>Implementation Example 实现示例</h3><p><strong>现在我们将展示一个着色模型实现的例子。如前所述，我们实现的着色模型类似于Gooch模型的扩展公式，但修改为适用于多个光源。它被描述为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918194934.png" class="" title="image-20210918194934">

<p><strong>中间计算如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918195003.png" class="" title="image-20210918195003">

<p><strong>这个公式适用于之前公式中的多光结构，为了方便起见，这里重复一下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918195046.png" class="" title="image-20210918195046">

<p><strong>这里（光）亮的和未亮的是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918195145.png" class="" title="image-20210918195145">

<p><strong>通过调整冷色的未亮贡献，使结果看起来更像原来的方程。</strong></p>
<p><strong>在大多数典型的渲染应用程序中，改变材质属性的值，如csurface 将存储在顶点数据中，或者，存储在纹理中(第六章)，当然，surface 在整个模型中是恒定的。</strong></p>
<p><strong>这个实现将使用着色器的动态分支功能来循环所有光源。虽然这种直接的方法可以很好地在简单的场景工作，但它不能很好地扩展到大型和几何复杂的场景，有许多光源。渲染技术有效地处理大计数的光将在第20章中介绍。另外，为了简单起见，我们只支持一种光源:点光源。尽管实现非常简单，但它遵循前面介绍的最佳实践。</strong></p>
<p><strong>着色模型不是孤立实现的，而是在一个更大的渲染框架的上下文中实现的。这个例子是在一个简单的WebGL 2应用程序中实现的，它是由Tarek Sherif修改的“phong -着色立方体”WebGL 2示例，但同样的原则也适用于更复杂的框架。</strong></p>
<p><strong>我们将讨论应用程序中GLSL着色器代码和JavaScript WebGL调用的一些示例。目的不是教WebGL API的细节，而是展示一般的实现原则。我们将按照“由内到外”的顺序来执行，从像素着色器开始，然后是顶点着色器，最后是应用程序端图形API调用。</strong></p>
<p><strong>在着色器代码正确之前，着色器源代码包括着色器输入和输出的定义。如3.3节所述，使用GLSL术语，着色器输入分为两类。一个是统一输入的集合，它具有应用程序设置的值，并且在调用draw时保持不变。第二种类型由不同的输入组成，它的值可以在着色器调用(像素或顶点)之间改变。在这里我们看到像素着色器的不同输入的定义，在GLSL中被标记，以及它的输出:</strong></p>
<p><img src="C:\Users\86010\AppData\Roaming\Typora\typora-user-images\image-20210918195829339.png" alt="image-20210918195829339"></p>
<p><strong>这个像素着色器有一个单一的输出，即最终的着色颜色。像素着色器输入与顶点着色器输出相匹配，顶点着色器输出在输入像素着色器之前被插值在三角形上。这个像素着色器有两个不同的输入:表面位置和表面法线，两者都在应用程序的世界空间坐标系统中。均匀输入的数量要大得多，因此为了简洁起见，我们只给出两个定义，它们都与光源有关:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918200146.png" class="" title="image-20210918200146">

<p><strong>因为这些都是点光源，所以每个点光源的定义都包括一个位置和颜色。它们被定义为vec4而不是vec3，以符合GLSL std140数据布局标准的限制。尽管在本例中，std140布局可能会导致一些空间浪费，但它简化了确保CPU和GPU之间数据布局一致的任务，这就是我们在本示例中使用它的原因。Light结构的数组在一个命名的统一块中定义，这是一个GLSL特性，用于将一组统一变量绑定到一个缓冲区对象，以实现更快的数据传输。数组的长度被定义为等于应用程序在一次绘制调用中允许的最大灯数。正如我们稍后将看到的，在着色器编译之前，应用程序用正确的值(在本例中是10)替换着色器源中的MAXLIGHTS字符串。统一整数uLightCount是抽取调用中实际活动的灯数。</strong></p>
<p><strong>接下来，我们将看看像素着色器代码:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918200717.png" class="" title="image-20210918200717">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918200736.png" class="" title="image-20210918200736">

<p><strong>我们有一个lit术语的函数定义，由main()函数调用。总的来说，这是上述方程的一个简单的GLSL实现。注意funlit()和cwarm 作为统一变量传入。由于这些值在整个绘制调用中都是常数，应用程序可以计算这些值，节省一些GPU周期。</strong></p>
<p><strong>这个像素着色器使用了几个内置的GLSL函数。reflect()函数反射一个向量，在本例中是光向量，平面定义第二个向量上，在本例中是表面法线。因为我们想要光线矢量和反射矢量都指向远离表面，所以我们需要在将其传递到reflect()之前剔除前者。clamp()函数有三个输入。其中两个定义了第三个输入所限定的范围。在大多数GPU上，clamp到0和1之间(对应于HLSL saturate()函数)的特殊情况是快速的，通常是有效的免费的。这就是我们在这里使用它的原因，尽管我们只需要将值clamp为0，因为我们知道它不会超过1。mix()函数也有三个输入，并在其中两个输入之间进行线性插值，在本例中是暖色和高亮色，基于第三个输入的值，即介于0和1之间的混合参数。在HLSL中，这个函数被称为lerp()，表示“线性插值”。最后，normalize()将向量除以其长度，将其缩放为1。</strong></p>
<p><strong>现在让我们看看顶点着色器。我们不会展示它的任何统一定义，因为我们已经看到了一些像素着色器的统一定义的例子，但不同的输入和输出定义值得研究:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918224437.png" class="" title="image-20210918224437">

<p><strong>注意，如前所述，顶点着色器输出匹配像素着色器的不同输入。输入包括指定数据如何在顶点数组中布局的指令。接下来是顶点着色器代码:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918224527.png" class="" title="image-20210918224527">

<p><strong>这些是顶点着色器的常见操作。着色器将表面位置和法线转换到世界空间，并将它们传递给像素着色器用于着色。最后，表面位置被转换到裁剪空间，并传递到gl-position，光栅化器使用的一个特殊的系统定义变量。gl-Position变量是任何顶点着色器都需要输出的变量。</strong></p>
<p><strong>注意，在顶点着色器中法向量不是标准化的。它们不需要被标准化，因为它们在原始网格数据中的长度为1，并且这个应用程序不执行任何操作，例如顶点混合或非均匀缩放，这些操作可能会不均匀地改变它们的长度。模型矩阵可以有一个统一的比例因子，但这将按比例改变所有法线的长度，从而不会导致之前图中右侧所示的问题。</strong></p>
<p><strong>该应用程序使用WebGL API进行各种渲染和着色设置。每个可编程着色器阶段都是单独设置的，然后它们都被绑定到一个程序对象。这里是像素着色器设置代码：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918233123.png" class="" title="image-20210918233123">

<p><strong>注意“碎片着色器”的引用。这个术语被WebGL(以及它所基于的OpenGL)所使用。正如本书前面提到的，虽然“像素着色器”在某些方面不太精确，但它是更常见的用法，我们在本书中遵循。这段代码也是将MAXLIGHTS字符串替换为适当数值的地方。大多数渲染框架执行类似的预编译着色器操作。</strong></p>
<p><strong>有更多的应用程序端代码用于设置制服、初始化顶点数组、清除、绘图等等，您可以在程序中查看这些代码，并可以通过大量API指南进行解释。我们的目标是让大家知道着色器是如何被当作独立的处理器，拥有自己的编程环境。因此，我们的演练到此结束。</strong></p>
<h3 id="Material-Systems-材质系统"><a href="#Material-Systems-材质系统" class="headerlink" title="Material Systems 材质系统"></a>Material Systems 材质系统</h3><p><strong>渲染框架很少只实现一个着色器，就像在我们的简单例子中那样。通常，需要一个专门的系统来处理应用程序使用的各种材质、着色模型和着色器。</strong></p>
<p><strong>正如前面章节所解释的，着色器是GPU可编程着色器阶段之一的程序。因此，它是一个低级的图形API资源，而不是与艺术家直接交互的东西。相反，材质是一个表面视觉外观的艺术家封装。材质有时也描述非视觉方面，如碰撞特性，我们将不再进一步讨论，因为它们超出了本书的范围。</strong></p>
<p><strong>虽然材质是通过着色器实现的，但这并不是简单的一对一对应。在不同的渲染情况下，相同的材质可能使用不同的着色器。一个着色器也可以被多个材质共享。最常见的情况是参数化材料。在最简单的形式中，材质参数化需要两种类型的材料实体:材料模板和材料实例。每个材质模板描述了一类材质，并有一组参数，这些参数可以根据参数类型分配数值、颜色或纹理值。每个材质实例对应于一个材质模板加上一组特定的参数值。一些渲染框架，如Unreal Engine，允许更复杂的层次结构，材质模板从其他模板在多个层次派生。</strong></p>
<p><strong>参数可以在运行时通过向着色程序传递统一的输入来解析，或者在编译时通过在着色程序编译之前替换值来解析。编译时参数的一种常见类型是一个布尔开关，它控制给定材质特性的激活。这可以由艺术家通过材质用户界面的一个复选框设置，或者由材质系统程序设置，例如，在功能的视觉效果可以忽略不计的遥远物体上减少着色器成本。</strong></p>
<p><strong>虽然材质参数可能与材质模型的参数一一对应，但情况并非总是如此。材质可以将给定的着色模型参数的值固定到一个常量，例如表面颜色。另外，一个着色模型参数可以作为一个复杂的操作的结果，采用多个材质参数，以及插值的顶点或纹理值，作为输入。在某些情况下，参数，如表面位置，表面方向，甚至时间也可以考虑到计算。基于表面位置和方向的着色在地形材料中特别常见。例如，高度和表面法线可以用来控制雪的效果，在高海拔水平和几乎水平的表面上混合白色表面颜色。基于时间的着色在动画材质中很常见，比如闪烁的霓虹灯标识。</strong></p>
<p><strong>材质系统最重要的任务之一是将不同的着色器功能划分为不同的元素，并控制它们如何组合。在许多情况下，这种类型的组合是有用的，包括以下情况:</strong></p>
<pre><code>**使用几何处理合成表面着色，如刚性变换，顶点混合，变形，镶嵌细分，实例化和剪切。这些功能是独立变化的:表面着色取决于材质，几何处理取决于网格。因此，可以方便地单独编写它们，并根据需要由材质系统组成。**

**使用诸如像素丢弃和混合等合成操作来合成表面着色。这与移动GPU尤其相关，在那里混合通常是在像素着色器中执行的。通常需要选择这些操作独立于用于表面着色的材质。**

**将用于计算着色模型参数的操作与着色模型本身的计算结合起来。这允许编写着色模型一次实现，并将其与计算着色模型参数的各种不同方法结合使用。**

**组合各自可选择的材质特性，选择逻辑和着色器的其余部分。这样就可以分别编写每个特性的实现。**

**组成着色模型并计算其参数与光源评估:计算clight l在每个光源的着色点。延迟呈现(将在第20章讨论)等技术改变了该组合的结构。在支持多种技术的呈现框架中，这又增加了一层复杂性。**
</code></pre>
<p><strong>如果图形API提供这种类型的着色器代码模块化作为核心特性，那将是很方便的。遗憾的是，不像CPU代码，GPU着色器不允许代码片段的后编译链接。每个着色器阶段的程序被编译为一个单元。着色器阶段之间的分离确实提供了一些有限的模块化，这在某种程度上符合我们列表中的第一项:组成表面着色(通常在像素着色器中执行)与几何处理(通常在其他着色器阶段执行)。但是这种匹配并不完美，因为每个着色器都执行其他操作，其他类型的合成仍然需要处理。考虑到这些限制，材质系统能够实现所有这些组合类型的唯一方法是在源代码级别。这主要涉及字符串操作，如连接和替换，通常通过C风格的预处理指令执行，如#include、#if和#define。</strong></p>
<p><strong>早期的渲染系统有相对较少的着色器变体，并且通常每个都是手工编写的。这有一些好处。例如，每个变体都可以在充分了解最终着色程序的情况下进行优化。然而，随着变量数量的增加，这种方法很快变得不切实际。当考虑到所有不同的部分和选项时，可能的不同着色变体的数量是巨大的。这就是模块化和可组合性如此重要的原因。</strong></p>
<p><strong>当设计处理着色变体的系统时，需要解决的第一个问题是，不同选项之间的选择是在运行时通过动态分支执行，还是在编译时通过条件预处理执行。在较旧的硬件上，动态分支通常是不可能的，或者非常慢，因此不能选择运行时。然后在编译时处理所有变体，包括不同light类型计数的所有可能组合。</strong></p>
<p><strong>相比之下，当前GPU处理动态分支相当好，特别是当分支对draw调用中的所有像素行为相同时。如今，许多功能的变化，比如灯的数量，都是在运行时处理的。然而，为着色器添加大量的功能变化会产生不同的成本:增加寄存器数量和相应的占用减少，从而降低性能。</strong></p>
<p><strong>有关更多细节，请参阅18.4.5节。因此，编译时变化仍然很有价值。它避免了包含永远不会被执行的复杂逻辑。</strong></p>
<p><strong>作为一个例子，让我们想象一个支持三种不同类型光源的应用程序。有两种光类型很简单:点光源和定向光源。第三种类型是广义聚光灯，它支持表格照明模式和其他复杂的功能，需要大量的着色器代码来实现。然而，广义聚光灯的使用相对较少，应用程序中只有不到5%的灯是这种类型的。在过去，一个单独的着色器变体将被编译为三种光类型的每一个可能的计数组合，以避免动态分支。虽然这在今天是不需要的，但编译两个独立的变体仍然是有益的，一个用于通用聚光灯的计数等于或大于1的情况，一个用于这种灯的计数正好为0的情况。由于其代码更简单，第二种变体(最常用的)可能占用寄存器更低，因此性能更高。</strong></p>
<p><strong>现代材质系统同时使用运行时和编译时的材质变化。即使全部的负担不再只在编译时处理，总体的复杂性和变化的数量不断增加，所以大量的着色器变体仍然需要编译。例如，在游戏《Destiny: the Taken King》的某些区域中，在单个帧中使用了超过9000种编译过的着色器变体。可能的变化的数量可以更大，例如，Unity渲染系统的着色器有接近1000亿个可能的变化。只有实际使用的变体才会被编译，但是着色器编译系统必须重新设计以处理大量可能的变体。</strong></p>
<p><strong>材料系统设计师采用不同的策略来实现这些设计目标。尽管这些策略有时被描述为相互排斥的系统架构，但这些策略可以——而且通常是在同一个系统中组合的。这些策略包括:</strong></p>
<pre><code>**代码重用：在共享文件中实现函数，使用#include预处理器指令从任何需要它们的着色器访问这些函数。**

**减法：一个着色器，通常被称为一个u¨bershader或supershader，它聚集了大量的功能，使用编译时预处理器条件和动态分支的组合来删除不使用的部分，并在互斥的选项之间切换。**

**加法：各种功能被定义为具有输入和输出连接器的节点，这些节点被组合在一起。这类似于代码重用策略，但是更加结构化。节点的组成可以通过文本或可视化图形编辑器来完成。后者旨在使非工程师(如技术艺术家)更容易创建新的材料模板。通常只有部分着色器是可访问的可视化图形创作。例如，在Unreal Engine中，图形编辑器只能影响着色模型输入的计算。**
</code></pre>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210918234943.png" class="" title="image-20210918234943">

<p>虚幻引擎材质编辑器。注意节点图右侧的高节点。这个节点的输入连接器对应于渲染引擎使用的各种着色输入，包括所有着色模型参数。(Material sample courtesy of Epic Games。)</p>
<pre><code>**基于模板的接口定义，只要符合该接口，就可以将不同的实现插入其中。这比添加策略更正式一点，通常用于更大的功能块。这种界面的一个常见例子是着色模型参数的计算和着色模型本身的计算之间的分离。Unreal Engine有不同的“材质域”，包括计算着色模型参数的表面域和计算调制clight的功能域对于给定的光源。类似的“表面着色器”结构也存在于Unity中。注意，延迟着色技术(在第20章中讨论)强制执行一个类似的结构，G缓冲区作为接口。**
</code></pre>
<p><strong>关于更具体的例子，WebGL Insights中有几章讨论了各种引擎如何控制它们的着色器管线。除了合成，现代材质系统还有其他几个重要的设计考虑因素，例如需要以最小的复制着色器代码来支持多个平台。这包括考虑到平台、着色语言和API之间的性能和能力差异的功能变化。命运着色器系统是这类问题的一个典型解决方案。它使用专有的预处理器层，采用自定义着色语言方言编写的着色器。这允许编写平台无关的材质，并自动翻译到不同的着色语言和实现。Unreal Engine和Unity也有类似的系统。</strong></p>
<p><strong>材质系统也需要保证良好的性能。除了特殊的材质变体编译外，材质系统还可以执行一些其他常见的优化。命运着色器系统和Unreal Engine自动检测计算是常数的绘制调用(如暖色和冷色计算在早期的实现示例)，并将其移出着色器。另一个例子是《Destiny》中使用的范围系统，用于区分以不同频率更新的常量(例如，每帧更新一次，每灯更新一次，每对象更新一次)，并在适当的时间更新每一组常量以减少API开销。</strong></p>
<p><strong>正如我们所看到的，实现着色方程是一个决定哪些部分可以简化的问题，计算各种表达式的频率，以及用户如何能够修改和控制外观。渲染管线的最终输出是颜色和混合值。关于反锯齿、透明度和图像显示的其余部分详细介绍了这些值是如何组合和修改的。</strong></p>
<h2 id="Aliasing-and-Antialiasing-走样和抗锯齿"><a href="#Aliasing-and-Antialiasing-走样和抗锯齿" class="headerlink" title="Aliasing and Antialiasing 走样和抗锯齿"></a>Aliasing and Antialiasing 走样和抗锯齿</h2><p><strong>想象一个大的黑色三角形在白色背景上缓慢移动。当一个屏幕网格单元格被三角形覆盖时，表示该单元格的像素值应该平滑地降低强度。在所有类型的基本渲染器中，通常发生的情况是，当网格单元格的中心被覆盖时，像素颜色立即从白色变成黑色。标准GPU渲染也不例外。如图最左边一列所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919154057.png" class="" title="image-20210919154057">

<p>上面一行显示了三个图像，其中一个三角形、一条直线和一些点具有不同的反锯齿级别。下排图像是上排图像的放大倍数。最左边的一列每个像素只使用一个样本，这意味着没有使用反锯齿。中间一列的图像使用每像素4个样本(在网格模式中)，右边一列使用每像素8个样本(在4 × 4的棋盘中，取样了一半的方块)。</p>
<p><strong>三角形在像素中要么在，要么不在。画出的线也有类似的问题。由于这个原因，边缘看起来呈锯齿状，所以这种视觉人造物被称为“锯齿”，当动画时，它会变成“爬虫”。更正式地说，这个问题被称为走样，努力避免它被称为反走样技术。</strong></p>
<p><strong>采样理论和数字滤波的课题大到足以出一本书。由于这是绘制的一个关键领域，本文将介绍采样和滤波的基本理论。然后，我们将重点关注当前可以实时做些什么来缓解走样现象。</strong></p>
<h3 id="Sampling-and-Filtering-Theory-采样滤波理论"><a href="#Sampling-and-Filtering-Theory-采样滤波理论" class="headerlink" title="Sampling and Filtering Theory 采样滤波理论"></a>Sampling and Filtering Theory 采样滤波理论</h3><p><strong>渲染图像的过程本质上是一个采样任务。这是因为图像的生成是对三维场景进行采样的过程，以获得图像(一个离散像素数组)中每个像素的颜色值。为了使用纹理映射(第6章)，像素必须重新采样，以在不同的条件下获得良好的结果。为了在动画中生成图像序列，动画通常以均匀的时间间隔进行采样。本节介绍采样、重构和滤波的主题。为了简单起见，大多数材质都会以一维形式呈现。这些概念也可以自然地扩展到二维，因此可以在处理二维图像时使用。</strong></p>
<p><strong>下图显示了连续信号是如何在均匀间隔采样的，即离散化。这个采样过程的目标是用数字表示信息。这样做，信息量就减少了。然而，采样后的信号需要进行重构以恢复原始信号。这是通过对采样信号进行滤波来实现的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919155519.png" class="" title="image-20210919155519">

<p>对连续信号(左)进行采样(中)，然后通过重构(右)恢复原始信号。</p>
<p><strong>无论何时进行采样，都可能发生走样。这是一个不必要的人工制品，我们需要减小走样，以生成令人满意的图像。在老西部片中看到的一个走样的经典例子是电影摄像机拍摄的一个旋转的马车轮子。因为辐条的移动速度比相机记录的图像快得多，轮子可能看起来在缓慢地旋转(向后或向前)，甚至可能看起来根本就不旋转。如图所示。由于车轮的图像是在一系列的时间步骤中拍摄的，这种效果被称为时间走样。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919155940.png" class="" title="image-20210919155940">

<p>上面一行显示了一个旋转的轮子(原始信号)。第二行是不充分的采样，使它似乎在相反的方向移动。这是一个由于采样率过低而造成走样的例子。在第三行，采样率恰好是每转两个样本，我们不能确定轮子在哪个方向旋转。这是奈奎斯特极限。在第4行，采样率高于每转2个样本，我们突然可以看到轮子朝着正确的方向旋转。</p>
<p><strong>在计算机图形中，走样的常见例子有光栅化线或三角形边缘的“锯齿”，被称为“萤火虫”的闪烁的高光，以及当带有格子图案的纹理被缩小时(章节6.2.2)。</strong></p>
<p><strong>当以过低的频率采样时，就会发生走样。采样后的信号似乎是比原始信号频率更低的信号。下图所示。对于要适当采样的信号(这样就可以从样本中重构出原始信号)，即采样频率必须大于被采样信号的最大频率的两倍。这通常被称为采样定理，采样频率被称为奈奎斯特速率或奈奎斯特极限，以瑞典科学家哈里·奈奎斯特(1889-1976)命名，他在1928年发现了这一理论。奈奎斯特极限也上图所示。这个定理使用了“最大频率”这个术语，这意味着信号必须是有带宽限制的，也就是说没有任何频率超过某个限制。换句话说，相对于相邻样本的间隔，信号必须足够平滑。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919160619.png" class="" title="image-20210919160619">

<p>蓝实线为原始信号，红圆为等间距采样点，绿虚线为重构信号。上面的数字表明抽样率过低。因此，重构信号的频率较低，即原始信号走样。下面显示的采样率恰好是原始信号频率的两倍，重构信号在这里是一条水平线。可以证明，只要采样率稍微提高一点，就有可能实现完美的重构。</p>
<p><strong>当使用点样本渲染时，三维场景通常不会受到带宽限制。三角形边缘、着色边界和其他现象产生的信号是不连续的，因此产生的频率是无限的。此外，无论采样包裹得多么紧密，对象仍然可能足够小，以至于根本无法进行采样。因此，在使用点采样渲染场景时，完全避免走样问题是不可能的，我们几乎总是使用点采样。然而，有时是可以知道一个信号是频带有限的。一个例子是当一个纹理被应用到一个表面。与像素的采样率相比，可以计算纹理采样的频率。如果该频率低于奈奎斯特极限，则不需要采取任何特殊行动来正确采样纹理。如果频率过高，则使用各种算法对纹理进行带限(章节6.2.2)。</strong></p>
<h4 id="Reconstruction-重构"><a href="#Reconstruction-重构" class="headerlink" title="Reconstruction 重构"></a>Reconstruction 重构</h4><p><strong>给定一个带限采样信号，我们现在将讨论如何从采样信号重构原始信号。要做到这一点，必须使用过滤器。三种常用的过滤器如图所示。请注意，滤波器的面积应该始终为1，否则重建信号可能会出现增大或缩小。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919161515.png" class="" title="image-20210919161515">

<p>左上方显示框式过滤器，右上方显示帐篷式过滤器。下面显示的是sinc滤波器(在这里被 clamp在x轴上)。</p>
<p><strong>在下图中，盒状滤波器(最近邻)被用来重构采样信号。这是最糟糕的滤波器使用，因为产生的信号是一个不连续的楼梯情况。然而，由于它的简单性，它经常被用于计算机图形学。从图中可以看出，盒子过滤器被放置在每个样本点上，然后缩放，使过滤器的最上面的点与样本点重合。所有这些缩放和转换的方框函数的和就是在右边显示的重构信号。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919161621.png" class="" title="image-20210919161621">

<p>采样信号(左)用盒状滤波器重构。这是通过将盒子过滤器放置在每个样本点上，并在y方向上缩放它，使过滤器的高度与样本点相同。求和就是重构信号(右)。</p>
<p><strong>盒式过滤器可更换为任何其他过滤器。在下图中，帐篷滤波器，也称为三角形滤波器，是用来重构一个采样信号。请注意,这滤波器实现了相邻采样点之间的线性插值，因此比盒状滤波器更好，因为现在重构信号是连续的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919161812.png" class="" title="image-20210919161812">

<p>采样后的信号(左)用帐篷滤波器重构。重建后的信号显示在右边。</p>
<p><strong>但帐篷滤波器重构信号的平滑性较差;在样本点有突然的斜率变化。这与帐篷过滤器并不是一个完美的重建过滤器有关。为了得到完美的重构，必须使用理想的低通滤波器。信号的频率分量是一个正弦波:sin(2πf)，其中f是该分量的频率。鉴于此，低通滤波器去除所有频率高于滤波器定义的特定频率的频率成分。直观上，低通滤波器去除信号的尖锐特征，即滤镜会使它模糊。理想的低通滤波器是sinc滤波器:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919162022.png" class="" title="image-20210919162022">

<p><strong>傅里叶分析理论解释了为什么sinc滤波器是理想的低通滤波器。简单地说，理想的低通滤波器是频域的盒状滤波器，当它与信号相乘时，它会去除滤波器宽度以上的所有频率。将盒子滤波器从频域变换到空间域得到一个sinc函数。同时，乘法运算被转换成卷积函数，这就是我们在这一节中使用的，没有实际描述这个术语。</strong></p>
<p><strong>使用sinc滤波器重构信号得到一个更平滑的结果，下图所示。采样过程会在信号中引入高频成分(突变)，而低通滤波器的任务就是去除这些成分。事实上，sinc滤波器消除了所有频率高于采样率1/2的正弦波。如上式所示，sinc函数是采样频率为1.0时的完美重构滤波器。（采样的最大频率信号必须小于1/2)。更一般地，假设采样频率是fs，即相邻样本的间隔为1/fs．对于这种情况，完美重构滤波器为sinc(fsX)，并消除所有高于fs／2的频率.这在重新采样信号时很有用(下一节)。然而，sinc滤波器的宽度是无限的，在某些区域是负的，所以它在实际中很少有用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919162237.png" class="" title="image-20210919162237">

<p>左边是采样信号和重构信号。在右侧，重构信号以两倍的采样率进行了重采样，即进行了放大。</p>
<p><strong>在低质量的盒子和帐篷过滤器和不切实际的sinc过滤器之间有一个有用的中间地带。最广泛使用的滤波函数介于这些极端之间。所有这些滤波函数都有一些近似的sinc函数，但它们影响的像素有一个限制。最接近sinc函数的滤波器在其定义域的一部分有负值。对于负滤波器值不适用实际的应用，通常使用无负瓣的滤波器(通常称为高斯滤波器，因为它们要么来自于高斯曲线，要么类似于高斯曲线)。第12.1节更详细地讨论了过滤器函数及其使用。</strong></p>
<p><strong>在使用任何滤波器后，得到一个连续的信号。然而，在计算机图形学中，我们不能直接显示连续信号，但我们可以使用它们将连续信号重新采样到另一个大小，即要么放大信号，要么缩小信号。下面将讨论这个话题。</strong></p>
<h4 id="Resampling-重采样"><a href="#Resampling-重采样" class="headerlink" title="Resampling 重采样"></a>Resampling 重采样</h4><p><strong>重采样用于放大或缩小采样信号。假设原始采样点位于整数坐标(0,1,2，…)，样本之间的间隔是单位的。此外，假设重新采样后，我们希望新样本点在样本间间隔为a的情况下均匀定位。对于a&gt; 1，缩小(下采样)发生，而对于a&lt; 1，放大(上采样)发生。</strong></p>
<p><strong>放大是两种情况中比较简单的一种，所以让我们从放大开始。假设采样信号如前一节所示被重构。直观地说，由于信号现在是完美的重建和连续的，所有需要的是在期望的间隔重新采样重建信号。上图所示。</strong></p>
<p><strong>然而，当最小化发生时，这种技术就不起作用了。原始信号的频率过高，使采样率无法避免走样。取而代之的是，使用sinc(x/a)的滤波器，用来从采样的信号中创建一个连续的信号。在此之后，可以按所需的间隔进行重新采样。换句话说，通过使用sinc(x/a)作为滤波器，低通滤波器的宽度是增加的，因此更多的信号的高频内容被删除。如图所示，滤波器宽度(单个sinc的)增加了一倍，从而使重采样率降低到原始采样率的一半。与数字图像相关，这类似于先模糊它(去除高频)，然后以较低的分辨率重新采样图像。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919163248.png" class="" title="image-20210919163248">

<p>左边是采样信号和重构信号。在右边，为了使样本之间的间隔加倍，滤光片的宽度加倍，即发生了缩小。</p>
<h3 id="Screen-Based-Antialiasing-基于屏幕的抗锯齿"><a href="#Screen-Based-Antialiasing-基于屏幕的抗锯齿" class="headerlink" title="Screen-Based Antialiasing 基于屏幕的抗锯齿"></a>Screen-Based Antialiasing 基于屏幕的抗锯齿</h3><p><strong>如果没有很好的采样和过滤，三角形的边缘会产生明显的伪影。阴影边界、高光和其他颜色变化迅速的现象也会导致类似的问题。本节讨论的算法有助于提高这些情况下的渲染质量。它们有一个共同的主线，即它们是基于屏幕的。它们只对管线的输出样本进行操作。没有一种最佳的反锯齿技术，因为每种技术在质量、捕捉清晰细节或其他现象的能力、移动过程中的外观、内存成本、GPU要求和速度方面都有不同的优势。</strong></p>
<p><strong>在黑色三角形例子中，有一个问题是采样率低。一个样本是在每个像素的网格单元的中心，所以这是最多的关于单元格的已知信息是，中心是否被三角形覆盖。通过在每个屏幕网格单元格中使用更多的样本并以某种方式混合这些样本，可以计算出更好的像素颜色。如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919164009.png" class="" title="image-20210919164009">

<p>在左边，一个红色的三角形被渲染为像素中心的一个样本。由于三角形没有覆盖样本，像素将是白色的，即使像素的大部分被红色三角形覆盖。在右边，每个像素使用4个样本，如图所示，其中两个样本被红色三角形覆盖，结果是粉色像素颜色。</p>
<p><strong>基于屏幕的反走样方案的一般策略是对屏幕使用一个采样模式，然后对样本进行加权和求和，以产生一个像素颜色，p:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919164442.png" class="" title="image-20210919164442">

<p><strong>其中n是一个像素的采样数。函数c(i, x, y)是样本颜色，wi是一个权重，在[0,1]范围内，该样本将对整个像素颜色做出贡献。样品位置是基于它在序列中的哪个样品1，…， n，并且该函数还可选地使用像素位置(x, y)的整数部分。换句话说，对于每个样本，在屏幕网格上采集的样本是不同的，而且可选地采样模式可以因像素而异。在实时渲染系统(以及大多数其他渲染系统)中，样本通常是点样本。所以，函数c可以被认为是两个函数。首先，函数f(i, n)检索浮点数(xf，yf )在屏幕上需要采样的位置。然后对屏幕上的这个位置进行采样，即此时的颜色就会恢复。选择采样方案，并配置渲染管线来计算特定亚像素位置的采样，通常基于每帧(或每应用程序)设置。</strong></p>
<p><strong>反采样的另一个变量是wi，即每个样本的权重。这些权重之和为1。在实时绘制系统中使用的大多数方法都给它们的样本一个统一的权重，例如。wi＝1/n．图形硬件的默认模式是在像素中心的单个样本，这是上面反采样方程的最简单的情况。只有一项，这一项的权重为1，采样函数f总是返回被采样像素的中心。</strong></p>
<p><strong>计算每个像素一个以上完整样本的抗锯齿算法被称为超采样(或过采样)方法。概念上最简单的全场景反走样(FSAA)，也被称为“超采样反走样”(SSAA)，渲染然后过滤邻近的样本来创建图像。例如，需要1280 × 1024像素的图像。如果在屏幕外渲染2560×2048的图像，然后对屏幕上的每个2×2像素区域求平均值，那么将生成每个像素有四个样本的所需图像，并使用框过滤器进行过滤。注意，这对应于下图中的2 × 2网格采样。这种方法代价很高，因为所有的子样本必须完全着色和填充，每个样本必须有z缓冲深度。FSAA的主要优点是简单。这种方法的其他低质量版本只在一个屏幕轴上以两倍的速率采样，因此称为1 × 2或2 × 1超采样。通常，为简便起见，使用2的幂次分辨率和盒状滤波器。NVIDIA的动态超分辨率特性是一种更精细的超采样形式，场景以更高的分辨率渲染，使用13个样本的高斯滤波器生成显示图像。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919165844.png" class="" title="image-20210919165844">

<p>比较了一些像素采样方案，每个像素从最少到最多的采样。Quincunx共享拐角样本，并将其中心样本权重为像素最终颜色的一半。旋转的2 × 2网格比笔直的2 × 2网格捕捉到的接近水平边缘的灰度级别更多。类似地，尽管使用了更少的样本，8 rooks模式比4 × 4网格捕获了更多的灰色层次。</p>
<p><strong>一种与超采样相关的采样方法是基于累积缓冲器的思想。这种方法不是使用一个大的屏幕外缓冲器，而是使用一个与所需图像具有相同分辨率的缓冲器，但每个通道具有更多的彩色位元。为了获得一个场景的2 × 2采样，将生成4幅图像，并根据需要将视图在屏幕x或y方向上移动半个像素。生成的每个图像都是基于网格单元格内不同的样本位置。每帧需要重新渲染几次场景，并将结果复制到屏幕上，这使得这种算法对实时渲染系统来说成本很高。当性能不是关键的时候，它对于生成高质量的图像很有用，因为任意数量的样本放置在任何地方，每个像素都可以使用。累积缓冲器过去是一个单独的硬件。OpenGL API直接支持它，但在3.0版本中已弃用。在现代GPU上，通过使用更高精度的颜色格式作为输出缓冲区，可以在像素着色器中实现累加缓冲区的概念。</strong></p>
<p><strong>当物体边缘、高光和阴影等出现突然的颜色变化时，需要额外的样本。阴影通常可以做得更柔和，高光更平滑，以避免走样。特定对象类型可以在尺寸上增加，如电线，这样它们就可以保证在其长度上的每个位置至少覆盖一个像素。物体边缘的走样仍然是一个主要的采样问题。可以使用分析方法，在绘制过程中检测物体边缘，并考虑到它们的影响，但这些方法通常比简单地获取更多样本更昂贵，更不可靠。然而，GPU特性，如保守光栅化和光栅化顺序视图，开辟了新的可能性。</strong></p>
<p><strong>超采样和累积缓冲等技术通过生成完全指定的样本，分别计算着色和深度。总体增益相对较低，成本较高，因为每个样本必须通过一个像素着色器。</strong></p>
<p><strong>多重采样抗锯齿(MSAA)通过每像素计算一次表面的着色，并在样本之间共享这个结果，减少了高计算成本。像素每个片段可能有四个(x, y)样本位置，每个位置都有自己的位置颜色和z深度，但是像素着色器只对每个应用到像素的对象碎片进行一次评估。如果碎片覆盖了所有的MSAA位置样本，则在像素的中心评估着色样本。如果碎片覆盖的位置样本更少，则着色样本的位置可以移动，以更好地表示覆盖的位置。这样做可以避免纹理边缘的着色采样。这种位置调整被称为质心采样或质心插值，如果启用，则由GPU自动完成。质心采样避免了三角问题，但会导致导数计算返回不正确的值。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919171043.png" class="" title="image-20210919171043">

<p>在中间，一个像素与两个物体重叠。红色的物体覆盖了三个样本，蓝色的只有一个。像素着色器评估位置显示为绿色。因为红色三角形覆盖了像素的中心，这个位置用于着色器评估。蓝色物体的像素着色器在样本的位置进行评估。对于MSAA，单独的颜色和深度存储在所有四个位置。在右侧显示了EQAA的2f4x模式。这四个示例现在有四个ID值，索引了存储的两种颜色和深度的表。</p>
<p><strong>MSAA比纯超采样方案更快，因为碎片只有一次着色。它专注于以更高的速率采样碎片的像素覆盖率，并共享计算出的着色。通过进一步分离采样和覆盖可以节省更多的内存，这反过来可以使抗锯齿速度更快——触及的内存越少，渲染就越快。NVIDIA在2006年引入了覆盖采样抗锯齿(CSAA)， AMD紧随其后，采用了增强质量抗锯齿(EQAA)。这些技术的工作原理是仅以较高的采样率存储片段的覆盖率。例如，EQAA的“2f4x”模式存储了两个颜色和深度值，在四个样本位置之间共享。颜色和深度不再存储在特定的位置，而是保存在一个表中。然后，四个样本中的每一个只需要一个位来指定两个存储值中的哪个与它的位置相关联。如上图所示。覆盖样本指定每个片段对最终像素颜色的贡献。如果超过存储的颜色数量，存储的颜色将被收回，其样品被标记为未知。这些样品对最终的颜色没有影响。对于大多数场景来说，相对较少的像素包含三个或更多的可见不透明碎片，这些碎片在着色上完全不同，因此该方案在实践中表现良好。为了获得最高质量，《极限竞速2》采用了4× MSAA，尽管《极限竞速2》具有性能优势。</strong></p>
<p><strong>一旦所有的几何图形都被渲染到一个多样本缓冲区，然后执行一个解析操作。这个程序对样本颜色进行平均，以确定像素的颜色。值得注意的是，当使用具有高动态范围颜色值的多次采样时，可能会出现问题。在这种情况下，为了避免伪影，通常需要在解析之前对值进行色调映射。这可能会很昂贵，所以可以使用色调映射函数或其他方法的更简单的近似方法。</strong></p>
<p><strong>默认情况下，MSAA是用方框过滤器解析的。2007年，ATI引入了自定义滤波器反锯齿(CFAA)，具有使用窄和宽帐篷滤波器的能力，可以略微扩展到其他像素单元。这种模式已经被EQAA支持所取代。在现代GPU上，像素或计算着色器可以访问MSAA样本，并使用所需的任何重建过滤器，包括从周围像素的样本中取样的过滤器。更宽的滤波器可以减少走样，尽管会损失清晰的细节。Pettineo发现滤波器宽度为2或3像素的三次平滑步长和B样条滤波器总体上得到的结果最好。这也有性能成本，因为即使模拟默认的框过滤器解析也会用自定义着色器花费更长的时间，更宽的过滤器内核意味着增加样本访问成本。</strong></p>
<p><strong>NVIDIA内置的TXAA支持类似地使用了比单个像素更宽的区域更好的重建过滤器，以提供更好的结果。它和较新的MFAA(多帧反锯齿)方案都使用时间反锯齿(TAA)，这是一种使用前一帧的结果来改善图像的一般技术。在某种程度上，这些技术之所以成为可能，是因为程序员可以设置每帧的MSAA采样模式。这样的技术可以解决像纺车轮这样的走样问题，还可以提高边缘绘制的质量。</strong></p>
<p><strong>想象一下，通过“手动”生成一系列图像来执行采样模式，在这些图像中，每个渲染使用采样像素中的不同位置。这种偏移是通过在投影矩阵上附加一个微小的平移来完成的。生成的图像越多，并将它们平均在一起，结果就越好。这种利用多偏移图像的概念被用于时间反走样算法。生成单个图像，可能使用MSAA或其他方法，并将之前的图像混合在一起。通常只使用2到4帧。旧图像的权重可能会呈指数级降低，尽管如果观看者和场景没有移动，这可能会产生帧闪烁的效果，所以通常最后一帧和当前帧的权重是相等的。每一帧的样本在不同的亚像素位置，这些样本的加权和给出了比单一帧更好的边缘覆盖率评估。因此，一个系统使用最新的两帧平均在一起可以给出一个更好的结果。每帧都不需要额外的样本，这就是这种方法如此吸引人的原因。甚至可以使用时间采样来生成低分辨率的图像，并将其放大到显示器的分辨率。此外，光照方法或其他需要很多样本才能得到好的结果的技术可以在每帧中使用较少的样本，因为结果将在几帧中混合。</strong></p>
<p><strong>在不增加采样代价的情况下为静态场景提供了反走样，但这种算法在用于时间反走样时存在一些问题。如果帧的权重不相等，静态场景中的物体会显示出微光。快速移动的物体或相机的快速移动可能导致重影，即由于先前帧的贡献而在物体后面留下的痕迹。重影的一种解决方案是只对缓慢移动的物体执行这种抗锯齿。另一个重要的方法是使用重投影(章节12.2)来更好地关联先前帧和当前帧的对象。在这种方案中，对象生成的运动矢量存储在一个单独的“速度缓冲区”中(第12.5节)。这些向量用于将前一帧与当前帧关联起来，即从当前像素位置减去向量，以找到该物体表面位置的前一帧的颜色像素。在当前框架中不太可能是表面一部分的样本被丢弃。由于时间反走样算法不需要额外的样本，因此需要的额外工作相对较少，近年来这类算法受到了广泛的关注和采用。这种关注的部分原因是延迟渲染技术(章节20.1)与MSAA和其他多次采样支持不兼容。方法各不相同，根据应用程序的内容和目标，已经开发了一系列避免工件和提高质量的技术。例如，Wihlidal的报告展示了应用于棋盘取样模式的EQAA、时间反锯齿和各种过滤技术如何结合在一起，在降低像素着色器调用数量的同时保持质量。iglesias - gutian等人总结了之前的工作，并提出了使用像素历史和预测来最小化滤波伪影的方案。Patney等人扩展了Karis和Lottes在Unreal Engine 4实现的TAA工作，用于虚拟现实应用程序，增加了可变大小的采样以及眼动补偿(章节21.3.2)。</strong></p>
<h4 id="Sampling-Patterns-采样模式"><a href="#Sampling-Patterns-采样模式" class="headerlink" title="Sampling Patterns 采样模式"></a>Sampling Patterns 采样模式</h4><p><strong>有效的采样模式是减少走样、时间和其他方面的关键因素。Naiman指出，人类最容易受到近水平和近垂直边缘的走样干扰。坡度接近45度的边缘是下一个最令人不安的。旋转网格超采样(RGSS)使用一个旋转的正方形模式，在像素内提供更多的垂直和水平分辨率。</strong></p>
<p><strong>RGSS模式是拉丁超立方或n -rooks抽样的一种形式，n个样本放置在n×n网格中，每行和每列都有一个样本。在RGSS中，4个样本分别位于4 × 4亚像素网格的一行和一列。与常规的2 × 2采样模式相比，这种模式特别适合于捕捉接近水平和垂直的边缘，因为常规的2 × 2抽样模式的边缘可能覆盖偶数个样本，因此提供的有效层次更少。</strong></p>
<p><strong>N-rooks是创建良好采样模式的开始，但它还不够。例如，样本可能都位于亚像素网格的对角线上，因此对于与这个对角线几乎平行的边，结果很差。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919173911.png" class="" title="image-20210919173911">

<p>N-rooks采样。左边是一个合法的N-rooks模式，但它在捕捉沿其直线对角线的三角形边时表现很差，因为当这个三角形移动时，所有的样本位置要么在三角形内部，要么在三角形外部。右边的图案可以更有效地捕捉这条边和其他边。</p>
<p><strong>为了更好的采样，我们希望避免两个样本挨得太近。我们还需要均匀分布，将样本均匀分布在区域内。为了形成这样的模式，将分层采样技术(如拉丁超立方抽样)与抖动、Halton序列和泊松盘采样等其他方法相结合。</strong></p>
<p><strong>在实践中，GPU制造商通常将这样的采样模式硬线连接到他们的硬件中，以进行多次采样反走样。下图显示了实践中使用的一些MSAA模式。对于时间反走样，覆盖模式是程序员想要的，因为样本位置可以在每帧中改变。例如，Karis发现一个基本的Halton序列比GPU提供的任何MSAA模式都要好。Halton序列产生的样本在空间上看起来是随机的，但差异很小，即它们在空间上分布很好，没有一个是集群的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919174117.png" class="" title="image-20210919174117">

<p>AMD和NVIDIA图形加速器的MSAA采样模式。绿色的正方形是着色样本的位置，红色的正方形是计算和保存的位置样本。从左到右:2×， 4×， 6× (AMD)， 8× (NVIDIA)采样。(由D3D FSAA查看器生成。)</p>
<p><strong>虽然亚像素网格模式可以更好地逼近每个三角形如何覆盖网格单元，但它并不理想。场景可以由任意物体构成屏幕上很小，意味着没有采样率可以完美地捕捉它们。如果这些微小的物体或特征形成一个图案，以恒定的间隔进行采样可以产生莫尔纹和其他干涉图案。在超抽样中使用的网格图案特别容易产生走样。</strong></p>
<p><strong>一种解决方案是使用随机采样，它提供了一个更随机的模式。如上图所示的模式当然符合条件。想象一下，在远处有一个细齿梳子，每个像素上覆盖着几颗齿。一个规则的模式可能会出现严重的伪影，因为采样模式进入和与齿频率的相位不一致。有一个不太有序的抽样模式可以打破这些模式。随机化倾向于用噪声替代重复的走样效果，而人类视觉系统对噪声的容忍度要高得多。结构更少的模式会有所帮助，但当像素重复时仍然会出现走样。一种解决方案是在每个像素上使用不同的采样模式，或者随时间改变每个采样位置。交错采样和索引采样，交错，即集合中的每个像素都有不同的采样模式，在过去的几十年里偶尔在硬件中得到支持。例如，ATI的SMOOTHVISION允许每像素最多16个样本，最多16个不同的用户自定义采样模式，可以混合在重复的模式中(例如，在4 × 4像素的贴图中)。Molnar以及Keller和Heidrich发现，当对每个像素使用相同的模式时，使用交错随机采样可以最小化产生的走样伪影。</strong></p>
<p><strong>其他一些GPU支持的算法值得注意。一个让样本影响一个以上像素的实时抗锯齿方案是NVIDIA较早的Quincunx方法。“Quincunx（五角形）”是指五个物体的排列，四个在一个正方形中，第五个在中心，例如六个骰子上的五个点的图案。Quintunx多重采样反走样使用这个模式，将四个外部样本放在像素的角落。参见下图。每个角落的样本值分布到它的四个相邻像素。中心样本的权重为12，角落样本的权重为18，而不是像大多数其他实时方案那样对每个样本平均加权。由于这种共享，平均每个像素只需要两个样本，结果大大优于双样本FSAA方法。这个模式近似于一个二维的帐篷式过滤器，正如上一节所讨论的，它优于盒式过滤器。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919165844.png" class="" title="image-20210919165844">

<p><strong>五次采样也可以应用于时间反走样，每像素使用一个样本。每一帧在每个轴上与前一帧偏移半像素，偏移方向在帧之间交替。前一帧提供像素角样本，使用双线性插值快速计算每个像素的贡献。结果被当前帧平均。每个帧的相同权重意味着静态视图中没有闪烁的伪影。对齐移动对象的问题仍然存在，但方案本身易于编码，并且在每帧每个像素只使用一个样本的情况下提供了更好的外观。</strong></p>
<p><strong>当在单一帧中使用时，Quincunx通过在像素边界共享样本，只有两个样本的成本很低。RGSS模式更擅长于捕捉更多的近水平和垂直边缘的梯度。最初为移动平台开发FLIPQUAD模式结合了这两种理想的功能。它的优点是每像素成本仅为两个样本，质量与RGSS(每像素成本4个样本)相似。这种采样模式如下图所示。Hasselgren等人研究了其他利用样本共享的廉价采样模式。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919175533.png" class="" title="image-20210919175533">

<p>左边显示了RGSS采样模式。这需要每像素4个样本。通过将这些位置移到像素边缘，可以跨边缘实现样本共享。然而，为了解决这个问题，每个其他像素必须有一个反射的样本模式，如图所示。生成的样本模式称为FLIPQUAD，每像素需要两个样本。</p>
<p><strong>像Quincunx一样，双样本FLIPQUAD模式也可以用于时间抗锯齿和扩展到两帧。Drobot在他的混合重建抗锯齿(HRAA)工作中解决了哪一个双样本模式是最好的问题。他探索了不同的时间反锯齿采样模式，发现FLIPQUAD模式是五种测试中最好的。棋盘图案也可以用于时间抗锯齿。El Mansouri讨论了使用双样本MSAA来创建棋盘渲染，以减少着色器成本，同时解决走样问题。Jimenez使用了SMAA、时间反走样和各种其他技术来提供一种解决方案，在这种方案中，反走样质量可以根据渲染引擎负载而改变。Carpentier和Ishiyama对边缘进行采样，将采样网格旋转45◦．他们将这种时间反走样方案与FXAA(稍后讨论)相结合，以在更高分辨率的显示器上有效渲染。</strong></p>
<h4 id="Morphological-Methods-形态学方法"><a href="#Morphological-Methods-形态学方法" class="headerlink" title="Morphological Methods 形态学方法"></a>Morphological Methods 形态学方法</h4><p><strong>走样通常是由边缘造成的，例如由几何形状、锐利的阴影或明亮的高光形成的边缘。利用走样具有与之相关的结构的知识，可以得到更好的反走样结果。2009年，Reshetov提出了一种沿着这些方向的算法，称之为形态反锯齿(MLAA)。“Morpho- logical”是指“与结构或形状有关的”。“早在1983年，Bloomenthal就在这一领域做过早期工作。Reshetov的论文重新激发了对多重采样方法替代方法的研究，强调了搜索和重建边缘。</strong></p>
<p><strong>这种形式的抗锯齿是作为后处理执行的。也就是说，呈现是按照通常的方式完成的，然后将结果提供给生成平滑的结果。自2009年以来，已经开发了一系列广泛的技术。那些依赖于额外缓冲区，如深度和法线可以提供更好的结果，如亚像素重建反锯齿(SRAA)，但随后仅适用于几何边缘的抗锯齿。解析方法，如几何缓冲反走样(GBAA)和距离到边缘反走样(DEAA)，让渲染器计算关于三角形边缘位置的额外信息，例如，边缘离像素中心有多远。</strong></p>
<p><strong>最通用的方案只需要颜色缓冲，这意味着它们也可以从阴影、高光或各种以前应用的后处理技术，如剪影边缘渲染(第15.2.3节)改善边缘。例如，定向局部抗锯齿(DLAA)是基于这样的观察:一个接近垂直的边缘应该在水平方向上被模糊，同样，接近水平的边缘应该在垂直方向上与其相邻的边缘一起被模糊。</strong></p>
<p><strong>更精细的边缘检测是试图找到可能包含任何角度边缘的像素，并确定其覆盖范围。检查潜在边缘周围的邻域，目标是尽可能重建原始边缘所在的位置。边缘对像素的影响可以用来混合相邻像素的颜色。请参见下图了解流程的概念视图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919180125.png" class="" title="image-20210919180125">

<p>形态学抗锯齿。左边是走样图像。目标是确定形成它的边缘可能的方向。在中间，算法通过检查邻居来记录边缘的可能性。给定样本，显示两个可能的边缘位置。在右侧，根据估计的覆盖范围，使用最佳猜测的边缘将邻近的颜色混合到中心像素中。这个过程对图像中的每个像素重复。</p>
<p><strong>Iourcha等人通过以像素为单位检查MSAA样本来改进边缘查找，从而计算出更好的结果。需要注意的是，与基于样本的算法相比，边缘预测和混合可以给出更高的精度结果。例如，一项每像素使用4个样本的技术只能为对象的边缘提供5个层次的混合:没有样本覆盖、1个覆盖、2个、3个和4个。估计的边缘位置可以有更多的位置，从而提供更好的结果。</strong></p>
<p><strong>基于图像的算法有几种误区。首先，如果两个目标之间的颜色差异低于算法的阈值，边缘可能不会被检测到。有三个或更多不同表面重叠的像素是很难解释的。表面有高对比度或高频元素，其中颜色在像素间快速变化，会导致算法缺失边缘。特别是，当应用形态抗锯齿时，文本质量通常会受到影响。物体的角可能是一个挑战，一些算法给它们一个圆形的外观。曲线也会受到边是直的假设的不利影响。单个像素的变化会导致边缘重建的巨大变化，这可能会在帧与帧之间产生明显的伪影。改善这一问题的一种方法是使用MSAA覆盖掩码来改进边缘确定。</strong></p>
<p><strong>形态抗锯齿方案只使用提供的信息。例如，一个宽度比像素细的物体，比如电线或绳子，如果它没有覆盖像素的中心位置，屏幕上就会有缝隙。在这种情况下，多采样可以提高质量;仅仅基于图像的抗锯齿是不行的。此外，执行时间可能取决于所查看的内容。例如，一幅草地的抗锯齿效果需要的时间是一幅天空的三倍。</strong></p>
<p><strong>综上所述，基于图像的方法可以以较低的内存和处理成本提供抗锯齿支持，因此它们被用于许多应用程序。只有颜色的版本也从渲染管线中分离，使它们易于修改或禁用，甚至可以作为GPU驱动程序选项公开。两种最流行的算法是快速近似抗锯齿(FXAA)和亚像素形态抗锯齿(SMAA)，部分原因是这两种算法都为各种机器提供了可靠的(和免费的)源代码实现。这两种算法都使用颜色输入，其中SMAA具有能够访问MSAA样本的优点。每个版本都有自己的设置，在速度和质量之间进行权衡。成本通常在每帧1 - 2毫秒之间，主要是因为电子游戏愿意花这个时间。最后，两种算法都可以利用时间抗锯齿。Jimenez提出了一种改进的SMAA实现，比FXAA更快，并描述了一种时间抗走样方案。最后，我们建议读者阅读Reshetov和Jimenez对形态学技术及其在电子游戏中的使用进行的广泛综述。</strong></p>
<h2 id="Transparency-Alpha-and-Compositing-透明度、Alpha和合成"><a href="#Transparency-Alpha-and-Compositing-透明度、Alpha和合成" class="headerlink" title="Transparency, Alpha, and Compositing 透明度、Alpha和合成"></a>Transparency, Alpha, and Compositing 透明度、Alpha和合成</h2><p><strong>半透明物体有很多不同的方式让光线穿过它们。对于渲染算法，这些可以大致分为基于光线和基于视图的效果。基于光的效果是指物体使光线衰减或偏移，导致场景中的其他物体被照亮并呈现不同的效果。基于视图的效果是指半透明对象本身被渲染的效果。</strong></p>
<p><strong>在这一节中，我们将处理基于视图的透明的最简单形式，其中半透明的物体作为它后面物体的颜色衰减器。更精细的视图和基于光的效果，如磨砂玻璃，弯曲光(折射)，光的衰减由于透明物体的厚度，以及反射率和透射变化由于观察角度的讨论在后面的章节。</strong></p>
<p><strong>一种产生透明错觉的方法叫做屏风透明。这个想法是用像素对齐的棋盘填充模式渲染透明三角形。也就是说，三角形的每一个其他像素都被渲染，从而使物体部分可见。通常，屏幕上的像素靠得很近，棋盘图案本身是看不见的。这种方法的一个主要缺点是，通常只能在屏幕的一个区域上令人信服地呈现一个透明对象。例如，如果一个透明的红色物体和透明的绿色物体被呈现在一个蓝色物体上，那么这三种颜色中只有两种会出现在棋盘图案上。另外，50%的棋盘是有限的。其他更大的像素掩模可以用来给出其他百分比，但这些往往会产生可检测的模式。</strong></p>
<p><strong>也就是说，这种技术的一个优点是简单。透明对象可以在任何时间以任何顺序呈现，不需要特殊的硬件。通过使所有对象在它们所覆盖的像素处都不透明，透明度问题就解决了。同样的想法也用于裁剪纹理的抗锯齿边缘，但在亚像素级别，使用一个称为alpha的特性覆盖(章节6.6)。</strong></p>
<p><strong>由Enderton等提出的随机透明技术是将亚像素掩模与随机采样相结合。一个合理的，尽管有噪声，图像是通过使用随机点画模式来表示片段的alpha覆盖。参见下图。为了使结果看起来合理，每个像素需要大量的样本，以及为所有亚像素样本提供相当大的内存。但是，不需要混合，抗锯齿、透明度和任何其他现象，创建部分覆盖像素是由单一机制覆盖。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919212839.png" class="" title="image-20210919212839">

<p>随机透明度。产生的噪声显示在放大的区域。(图片来自NVIDIA SDK 11样本，由NVIDIA公司提供。)</p>
<p><strong>大多数透明算法将透明物体的颜色与它后面物体的颜色混合。为此，需要alpha混合的概念。当一个对象在屏幕上呈现时，每个像素都与RGB颜色和z缓冲区深度相关联。另一个分量称为α (α)，也可以为对象覆盖的每个像素定义。Alpha是一个值，描述一个给定像素的对象片段的不透明度和覆盖程度。alpha值为1.0意味着该对象是不透明的，并且完全覆盖了该像素感兴趣的区域;0.0表示像素完全没有被遮挡，即该片段是完全透明的。</strong></p>
<p><strong>根据具体情况，一个像素的alpha可以表示不透明度、覆盖率或两者兼有。例如，一个肥皂泡的边缘可能会覆盖四分之三的像素，0.75，并且可能几乎是透明的，让十分之九的光通过眼睛，所以它是十分之一的不透明，0.1。那么它的alpha将是0.75 × 0.1 = 0.075。然而，如果我们使用MSAA或类似的抗锯齿方案，覆盖率将由样本本身考虑。四分之三的样本会受到肥皂泡的影响。在这些样本中，我们将使用0.1的不透明度值作为alpha。</strong></p>
<h3 id="Blending-Order-混合顺序"><a href="#Blending-Order-混合顺序" class="headerlink" title="Blending Order 混合顺序"></a>Blending Order 混合顺序</h3><p><strong>为了让一个物体看起来透明，它被渲染在现有场景的顶部，alpha值小于1.0。被对象覆盖的每个像素将从像素着色器接收到生成的RGBA α(也称为RGBA)。将这个片段的值与原始像素颜色混合通常使用over操作符，如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919213306.png" class="" title="image-20210919213306">

<p><strong>其中cs 透明物体(称为光源)的颜色，αs 是物体的alpha，cd是混合前的像素颜色(称为目标)，co 是由于将透明物体置于现有场景之上而产生的颜色。在渲染管道发送cs 和αs，即像素的原始颜色cd 被替换为co．如果输入的RGBα实际上是不透明的(αs = 1.0)，等式简化为将像素的颜色完全替换为对象的颜色。</strong></p>
<p><strong>列子</strong></p>
<p><strong>混合。一个红色半透明物体被渲染到蓝色背景上。假设在某个像素处，物体的RGB着色为(0.9,0.2,0.1)，背景为(0.1,0.1,0.9)，物体的不透明度设置为0.6。然后是这两种颜色的混合</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919213653.png" class="" title="image-20210919213653">

<p><strong>它的颜色是(0.58,0.16,0.42)。</strong></p>
<p><strong>over运算符给被渲染的对象一个半透明的外观。这样做的透明度是有效的，在某种意义上，当我们可以透过它看到后面的物体时，我们就认为它是透明的。在模拟使用薄纱织物的真实世界效果。织物后面的物体的视图是部分模糊的——织物的线是不透明的。在实践中，松散织物的alpha覆盖范围随角度的变化而变化。我们这里的观点是，alpha模拟了材质覆盖像素的程度。</strong></p>
<p><strong>在模拟其他透明效果时，过度操作就不那么令人信服了，尤其是通过彩色玻璃或塑料观看。在现实世界中，蓝色物体前面的红色滤镜通常会使蓝色物体看起来很暗，因为这个物体反射的光很少，而红色滤镜可以通过。参见下图。当over用于混合，结果是一部分红色和蓝色加在一起。最好是将两种颜色相乘，以及添加透明物体本身的反射。这种类型的物理透射率将在14.5.1和14.5.2节中讨论。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919213844.png" class="" title="image-20210919213844">

<p>红色方形薄纱织物和红色塑料过滤器，产生不同的透明效果。注意阴影也是不同的。(照片由Morgan McGuire提供。)</p>
<p><strong>在基本的混合阶段操作符中，over是通常用于透明效果的操作符。另一种有一定用途的操作是加法混合，即简单地对像素值求和。也就是说,</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919214008.png" class="" title="image-20210919214008">

<p><strong>这种混合模式可以很好地工作于发光效果，如闪电或火花，不衰减后面的像素，而只是使它们更亮。然而，这个透明度看起来不正确，因为不透明的表面不会出现过滤。对于多层半透明表面，如烟雾或火焰，加法混合具有使现象颜色饱和的效果。</strong></p>
<p><strong>为了正确地渲染透明对象，我们需要在不透明对象之后绘制它们。先渲染所有不透明的对象，然后渲染所有透明对象。从理论上讲，我们总是可以使用over，因为1.0的不透明alpha会给出源颜色并隐藏目标颜色，但这样做的代价更大，没有实际的收益。</strong></p>
<p><strong>z缓冲区的一个限制是每个像素只能存储一个对象。如果几个透明对象重叠在同一个像素上，z缓冲区不能单独保存并在稍后解析所有可见对象的效果。当使用在任何给定像素的透明表面上时，通常需要按照前后顺序渲染。不这样做可能会给出错误的知觉线索。实现这种排序的一种方法是根据各个对象的质心沿视图方向的距离来排序。这种粗略的排序有相当好的效果，但在各种情况下存在许多问题。首先，顺序只是一个近似值，所以被分类为较远的物体可能在被认为较近的物体的前面。穿透的物体不可能以每个网格为基础来解析所有视角，除非将每个网格分割成单独的部分。如下图中的左图所示。即使是一个带有凹洞的网格，当它在屏幕上重叠时，也会显示视图方向的排序问题。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919214823.png" class="" title="image-20210919214823">

<p>在左侧，模型使用z-buffer进行透明渲染。以任意顺序渲染网格会产生严重的错误。在右侧，深度剥离提供了正确的外观，以额外的通道为代价。(图片由NVIDIA公司提供。)</p>
<p><strong>尽管如此，由于它的简单和速度，以及不需要额外的内存或特殊的GPU支持，执行一个粗略的透明度排序仍然是常用的。如果实现了，通常最好关闭z-depth用替换当执行的透明度。也就是说，z缓冲区仍然正常测试，但幸存的表面不会改变存储的z深度;最近的不透明表面的深度保持不变。通过这种方式，所有透明对象将至少以某种形式出现，而不是在摄像机旋转改变排序顺序时突然出现或消失。其他技术也可以帮助改善外观，如绘制每个透明网格两次，首先绘制背面，然后绘制正面。</strong></p>
<p><strong>也可以修改over方程，使前后混合得到相同的结果。这种混合模式被称为under操作符:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919215546.png" class="" title="image-20210919215546">

<p><strong>注意，under要求目标维护alpha值，over则不需要。换句话说，目标——被混合的更近的透明表面——不是不透明的，因此需要有一个alpha值。“未完成”的表述就像“结束”一样，只是源和目标互换了。另外，请注意计算alpha的公式是顺序无关的，因为源和目标alpha可以交换，最终的alpha是相同的结果。</strong></p>
<p><strong>alpha的公式来自考虑片段的alpha作为覆盖。Porter和Duff注意到，由于我们不知道每个片段的覆盖区域的形状，我们假设每个片段按其alpha的比例覆盖另一个片段。例如，如果是αs = 0.7，像素以某种方式被分成两个区域，0.7被源碎片覆盖，0.3没有覆盖。排除任何其他知识，目标片段覆盖，比如说，αd = 0.6将被源片段按比例重叠。这个公式有一个几何解释，如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919220503.png" class="" title="image-20210919220503">

<p>一个像素和两个片段，s和d。它们是不相关的。这两个片段所覆盖的面积相当于下面输出的alpha值αs −αsαd +αd．这转换为将两个区域相加，然后减去它们重叠的区域。</p>
<h3 id="Order-Independent-Transparency-Order-Independent透明度"><a href="#Order-Independent-Transparency-Order-Independent透明度" class="headerlink" title="Order-Independent Transparency Order-Independent透明度"></a>Order-Independent Transparency Order-Independent透明度</h3><p><strong>under方程用于将所有透明对象绘制到一个单独的颜色缓冲，然后使用over将这个颜色缓冲合并到场景的不透明视图之上。under操作符的另一个用途是执行一种称为深度剥离(depth peeling)的顺序独立透明(OIT)算法。顺序独立意味着应用程序不需要执行排序。深度剥离背后的想法是使用两个z缓冲区和多个通道。首先，一个渲染通道使得所有表面的z深度，包括透明表面，都在第一个z缓冲区中。在第二次传递中，所有透明对象都被渲染。如果对象的z-depth与第一个z-buffer中的值匹配，我们就知道这是最接近的透明对象，并将其RGBα保存到单独的颜色缓冲区中。我们也通过保存超过第一个z-depth且距离最近的透明对象的z-depth来“剥离”这个层。这个z-depth是第二近的透明物体的距离。连续通过继续剥离和添加透明层使用下。我们在经过一些通道后停止，然后混合透明图像顶部的不透明图像。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919220825.png" class="" title="image-20210919220825">

<p>每个深度剥离通道绘制一个透明层。在左边是第一个通道，显示层直接可见的眼睛。在中间显示的第二层，在每个像素上显示第二最近的透明表面，在本例中是对象的背面。第三层，在右边，是最近的一组透明表面。(图片由Louis Bavoil提供。)</p>
<p><strong>这种方案的几种变体已经开发出来了。例如，Thibieroz给出了一种反向工作的算法，其优点是能够立即混合透明值，这意味着不需要单独的alpha通道。深度剥离的一个问题是知道有多少通道足够捕获所有透明层。一个硬件解决方案是提供一个像素绘制计数器，它告诉在渲染过程中有多少像素被写入;当一个通道没有渲染像素时，渲染就完成了。使用under的优点是最重要的透明层——那些眼睛最先看到的层——在早期就呈现出来了。每个透明表面总是增加它所覆盖的像素的alpha值。如果当一个像素的Alpha值接近1.0时，混合的贡献使得该像素几乎不透明，因此更远的物体的影响可以忽略不计。当一个通道渲染的像素数量低于某个最小值时，或者可以指定一个固定的通道数量时，可以缩短前到后的剥离。这在前后剥离时效果不太好，因为最近的(通常是最重要的)层是最后绘制的，因此可能会因为提前终止而丢失。</strong></p>
<p><strong>虽然深度剥离是有效的，但它可能是缓慢的，因为每一层剥离都是所有透明对象的单独渲染通道。Bavoil和Myers提出了双重深度剥离，即每一遍剥离距离最近和最远的两层深度剥离层，从而将渲染通道的数量减半。Liu等人探索了一种桶排序方法，它可以在一次传递中捕获多达32层。这种方法的一个缺点是它需要相当大的内存来保持所有层的排序顺序。通过MSAA或类似的抗锯齿将大大增加成本。</strong></p>
<p><strong>以交互速率将透明物体正确地混合在一起的问题并不是我们缺少的算法，而是一个有效地将这些算法映射到GPU的问题。1984年Carpenter提出了A-buffer，这是另一种多重采样形式。在a缓冲区中，每个渲染的三角形为它完全或部分覆盖的每个屏幕网格单元创建覆盖掩码。每个像素存储所有相关片段的列表。不透明的片段可以剔除它们后面的片段，类似于z-buffer。所有的碎片都储存在透明的表面上。一旦形成了所有列表，就会遍历片段并解析每个示例，从而生成最终结果。</strong></p>
<p><strong>通过DirectX 11中暴露的新功能，在GPU上创建片段链表的想法成为可能。所使用的特性包括无序访问视图(UAVs)和原子操作，见章节3.8。通过MSAA抗锯齿是通过访问覆盖掩模和在每个样本评估像素着色器的能力来实现的。该算法的工作原理是对每个透明表面进行光栅化，并将生成的碎片插入到一个长数组中。除了颜色和深度，还会生成一个单独的指针结构，将每个片段链接到为像素存储的前一个片段。然后执行一个单独的通道，其中一个屏幕填充四边形被渲染，以便像素着色器在每个像素被评估。这个着色器根据链接检索每个像素上的所有透明片段。检索到的每个片段与前面的片段依次排序。然后将这个排序列表混合到前面，以给出最终的像素颜色。因为混合是由像素着色器执行的，如果需要，可以为每个像素指定不同的混合模式。GPU和API的持续发展通过降低使用原子操作符的成本提高了性能。</strong></p>
<p><strong>a缓冲区的优点是只分配每个像素所需的片段，就像在GPU上的链表实现一样。从某种意义上说，这也可能是一个缺点，因为在开始渲染帧之前，所需的存储量是未知的。一个有头发、烟雾或其他物体的场景可能会产生许多重叠的透明表面，从而产生大量的碎片。</strong></p>
<p><strong>Andersson指出，对于复杂的游戏场景，多达50个透明的物体网格(如树叶)和多达200个半透明粒子可能会重叠。</strong></p>
<p><strong>GPU通常有预先分配的缓冲区和数组等内存资源，链表方法也不例外。用户需要决定多少内存是足够的，而内存耗尽会导致明显的伪影。Salvi和Vaidyanathan提出了一种解决这个问题的方法，即多层alpha混合，使用 Intel引入的一种称为像素同步的GPU特性。参见下图。此功能提供了比原子更少开销的可编程混合。他们的方法是重新规划存储和混合，以便在内存耗尽时降级。粗略的排序顺序对他们的方案有利。DirectX 11.3引入了光栅化顺序视图(章节3.8)，这是一种允许透明方法在任何支持该特性的GPU上实现的缓冲区。移动设备有一种类似的技术，称为tile本地存储，允许它们实现多层alpha混合。然而，这种机制有性能成本，因此这种类型的算法可能是昂贵的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919222028.png" class="" title="image-20210919222028">

<p>在左上角，执行传统的前后alpha混合，导致由于错误的排序顺序而导致渲染错误。在右上角，a缓冲区被用来给出一个完美的，非交互的结果。左下角呈现的是多层alpha混合渲染。右下角为a缓冲区与多层图像的差异，能见度乘以4。(图片由英特尔公司的Marco Salvi和Karthik Vaidyanathan提供)。</p>
<p><strong>这种方法建立在Bavoil等人提出的k-buffer的思想之上，在k-buffer中，前几个可见层被尽可能地保存和排序，较深的层被尽可能地丢弃和合并。Maule等人使用k-buffer，并通过加权平均来解释这些较远的深层层。加权求和和加权平均透明技术是顺序无关的，是单通道的，并运行在几乎每一个GPU。问题是它们没有考虑到对象的顺序。参见下图。因此，使用alpha来表示覆盖范围，薄纱红色围巾在薄纱蓝色围巾上给出一个紫罗兰色，而正确地看到红色围巾中有一点蓝色。虽然几乎不透明的物体效果不佳，但这类算法对于可视化是有用的，对于高度透明的表面和粒子也很有效。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919222322.png" class="" title="image-20210919222322">

<p>随着不透明度的增加，对象的顺序变得更加重要。</p>
<p><strong>在加权和透明度的公式是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919222439.png" class="" title="image-20210919222439">

<p><strong>其中n是透明表面的数量，ci 和αi 表示透明度值的集合，cd是场景中不透明部分的颜色。这两个和被累积并作为透明表面被渲染而单独存储，并且在透明通道的末尾，在每个像素处计算方程。这种方法的问题是第一个和饱和，即生成大于(1.0,1.0,1.0)的颜色值，并且背景颜色可能有负面影响，因为alpha的总和可以超过1.0。</strong></p>
<p><strong>加权平均方程通常被采用，因为它避免了这些问题</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919222623.png" class="" title="image-20210919222623">

<p><strong>第一行表示透明性呈现期间生成的两个独立缓冲区中的结果。每个对csum 有贡献的曲面是否给予权重的影响其α;几乎不透明的表面对颜色的影响更大，而几乎透明的表面对颜色的影响很小。csum除以αsum我们得到一个加权平均透明度颜色。αavg是所有值的平均值。值u是对n个透明表面应用n次平均alpha后的目标(不透明场景)的估计能见度。最后一行实际上是over运算符，(1−u)表示源的alpha。</strong></p>
<p><strong>加权平均的一个限制是，对于相同的alpha，它将所有颜色均匀地混合在一起，不管顺序如何。McGuire和Bavoil引入了加权混合顺序无关透明度，以得到更令人信服的结果。在他们的公式中，到表面的距离也影响权重，更近的表面给予更大的影响。此外，u不是平均的，而是通过乘项(1−αi)来计算的，并从其中减去一个，给出真正的alpha覆盖的表面集合。这种方法产生的结果在视觉上更有说服力，如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919222933.png" class="" title="image-20210919222933">

<p>两个不同的摄像机位置查看相同的引擎模型，都使用加权混合顺序无关透明度渲染。通过距离加权可以帮助确定哪些表面离观察者更近。(图片由Morgan McGuire提供。)</p>
<p><strong>缺点是，在一个大的环境中，彼此靠近的物体从距离看可能具有几乎相等的权重，使得结果与加权平均值相差无几。此外，随着相机到透明物体的距离改变，深度权重可能会发生变化，但这种变化是渐进的。</strong></p>
<p><strong>McGuire和Mara扩展了这种方法，使其包含了一种似是而非的透射色效应。如前所述，本节讨论的所有透明度算法混合各种颜色，而不是过滤它们，模拟像素覆盖。为了获得颜色过滤效果，像素着色器读取不透明场景，每个透明表面将其覆盖的像素乘以其颜色，将结果保存到第三个缓冲区。在这个缓冲区中，不透明的对象现在被透明的对象着色，然后在解析时用来代替不透明冲区。这种方法是可行的，因为不同于由于覆盖而产生的透明度，彩色透射是顺序无关的。</strong></p>
<p><strong>还有其他一些算法使用了本文中介绍的几种技术中的元素。例如，Wyman根据内存需求、插入和合并方法、是否使用alpha或几何覆盖以及如何处理丢弃的片段对以前的工作进行了分类。他提出了两种新方法，通过寻找以前研究的漏洞而发现。他的随机分层alpha混合方法使用k缓冲、加权平均和随机透明度。他的另一个算法是Salvi和Vaidyanathan方法的变体，使用覆盖掩码而不是alpha。</strong></p>
<p><strong>考虑到透明内容、渲染方法和GPU能力的广泛类型，渲染透明对象没有完美的解决方案。我们向感兴趣的读者推荐Wyman的论文和Maule等人对交互透明性算法的更详细的调查。McGuire的报告提供了一个更广阔的视野，通过其他相关现象，如体积照明、彩色透射和折射，这些将在本书后面进行更深入的讨论。</strong></p>
<h3 id="Premultiplied-Alphas-and-Compositing-预乘alpha和合成"><a href="#Premultiplied-Alphas-and-Compositing-预乘alpha和合成" class="headerlink" title="Premultiplied Alphas and Compositing 预乘alpha和合成"></a>Premultiplied Alphas and Compositing 预乘alpha和合成</h3><p><strong>过运算符也用于混合照片或物体的合成渲染。这个过程叫做合成。在这种情况下，每个像素的alpha值与对象的RGB颜色值一起存储。由alpha通道形成的图像有时被称为哑光。它显示了物体的轮廓形状。</strong></p>
<p><strong>使用合成RGBα数据的一种方法是使用预乘α(也称为关联α)。也就是说，RGB值在使用之前要乘以alpha值。这使得合成方程更有效:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210919223613.png" class="" title="image-20210919223613">

<p><strong>其中cs′ 是前置源信道代替之前方程中的αscs 。预乘alpha也使得在不改变混合状态的情况下使用over和加法混合成为可能，因为在混合过程中添加了源颜色。请注意，使用预乘的RGBα值，RGB组件通常不会大于alpha值，尽管它们可以被制作成特别明亮的半透明值。</strong></p>
<p><strong>渲染合成图像与预乘alpha自然吻合。在黑色背景上渲染的抗锯齿不透明对象默认提供预乘值。假设一个白色(1,1,1)三角形沿其边缘覆盖了某个像素的40%。使用(非常精确的)抗锯齿，像素值将被设置为0.4的灰度，即将为这个像素保存为颜色(0.4,0.4,0.4)，如果也会是0.4，因为这是三角形覆盖的面积。RGBα值将是(0.4,0.4,0.4,0.4)，这是一个预乘值。</strong></p>
<p><strong>图像存储的另一种方式是不相乘的，也称为不关联的，甚至是令人费解的术语非预相乘的。一个未乘的alpha值就是它所说的:RGB值没有乘以alpha值。对于白色三角形的例子，未相乘的颜色是(1,1,1,0.4)。这种表示的优点是存储三角形的原始颜色，但是在显示之前，这个颜色总是需要乘以存储的alpha。当进行滤波和混合时，最好使用预乘数据，因为使用未乘的alpha时，如线性插值等操作不能正确工作。像物体边缘周围的黑色条纹这样的伪影可能会产生。请参阅第6.6节的末尾进行进一步的讨论。前乘阿尔法也允许更干净的理论处理。</strong></p>
<p><strong>对于图像处理应用程序，不相关的alpha用于屏蔽照片而不影响底层图像的原始数据。此外，不相关的alpha意味着可以使用颜色通道的全精度范围。也就是说，必须小心地将未乘的RGBα值与用于计算机图形计算的线性空间进行适当的转换。例如，没有浏览器能正确地做到这一点，它们也不可能这样做，因为现在预期会出现错误行为。支持alpha的图像文件格式包括PNG(只支持不关联的alpha)、OpenEXR(只支持关联的)和TIFF(两种alpha类型)。</strong></p>
<p><strong>与alpha通道相关的一个概念是色度键控。这是一个来自视频制作的术语，在视频制作中，演员在绿色或蓝色的屏幕上拍摄，并与背景混合。在电影工业中，这个过程被称为绿幕或蓝幕。这里的想法是，特定的色调(电影作品)或精确的值(计算机图形)被指定为透明;当它被检测到时，背景就会显示出来。这允许图像通过使用RGB颜色得到轮廓形状;不需要存储alpha。这种方案的一个缺点是，对象在任何像素上要么完全不透明，要么完全透明。alpha实际上只有1.0或0.0。例如，GIF格式允许一种颜色被指定为透明。</strong></p>
<h2 id="Display-Encoding-显示编码"><a href="#Display-Encoding-显示编码" class="headerlink" title="Display Encoding 显示编码"></a>Display Encoding 显示编码</h2><p><strong>当我们计算光照、纹理或其他操作的效果时，使用的值被假定为线性的。非正式地说，这意味着加法和乘法按预期工作。然而，为了避免各种视觉伪影，显示缓冲和纹理使用了我们必须考虑的非线性编码。简短而草率的答案如下:在[0,1]范围内取着色器输出的颜色，并将其提高1/2.2的次方，执行所谓的伽马校正。对传入的纹理和颜色做相反的操作。在大多数情况下，你可以让GPU为你做这些事情。本节将解释如何以及为什么进行快速总结。</strong></p>
<p><strong>我们从阴极射线管(CRT)开始。在数字成像技术的早期，CRT显示器是主流。这些器件在输入电压和显示亮度之间呈现幂律关系。当应用到一个像素上的能量水平增加时，发出的辐亮度不是线性增长，而是与该水平成比例增长，其幂次大于1。例如，假设幂是2。一个像素被设置为50%将发射四分之一的光，0.52 = 0.25，作为一个像素被设置为1.0。尽管液晶显示器和其他显示技术与CRT有不同的内在特殊响应曲线，但它们是用转换电路制造的，从而使它们模仿CRT响应。</strong></p>
<p><strong>这个幂函数几乎与人类视觉的亮度灵敏度的倒数相匹配。这种幸运巧合的结果是，编码在感知上是大致一致的。也就是说，在可显示范围内，一对编码值N和N +1之间的感知差异大致是恒定的。通过测量阈值对比度，我们可以在广泛的条件下检测到大约1%的亮度差异。当颜色存储在有限精度的显示缓冲器中时，这种接近最优的值分布最小化了条带伪影(章节23.6)。同样的好处也适用于纹理，它们通常使用相同的编码。</strong></p>
<p><strong>显示传递函数描述显示缓冲器中的数字值与显示发出的亮度水平之间的关系。因此，它也被称为电光传递函数(EOTF)。显示传输功能是硬件的一部分，计算机显示器、电视和电影放映机有不同的标准。对于该过程的另一端，即图像和视频捕捉设备，也有一个标准的传递函数，称为光电传递函数(OETF)。</strong></p>
<p><strong>当编码用于显示的线性颜色值时，我们的目标是抵消显示传递函数的影响，因此无论我们计算出什么值，都会发射出相应的亮度水平。例如，如果我们的计算值增加了一倍，我们希望输出亮度增加一倍。为了保持这种联系，我们应用显示传递函数的逆来抵消它的非线性影响。这个使显示器的响应曲线无效的过程也称为伽马校正，原因很快就会清楚。当解码纹理值时，我们需要应用显示传递函数来生成用于着色的线性值。下图展示了解码和编码在显示过程中的使用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920145139.png" class="" title="image-20210920145139">

<p>在左边，一个PNG颜色纹理被GPU着色器访问，它的非线性编码值被转换(蓝色)为线性值。在底纹和色调映射(章节8.2.2)之后，最终计算的值被编码(绿色)并存储在帧缓冲区中。这个值和显示传递函数决定发射的辐射量(红色)。绿色函数和红色函数的组合消去了，所以发射的辐亮度与线性计算值成比例。</p>
<p><strong>个人电脑显示器的标准传递函数是由称为sRGB的颜色空间规范定义的。大多数API控制GPU可以设置为自动应用适当的sRGB转换时，从纹理或写入颜色缓冲区。正如在第6.2.2节中讨论的，mipmap生成也将考虑sRGB编码。在纹理值之间的双线性插值将正确工作，首先转换为线性值，然后执行插值。通过将存储的值解码回线性值，混合新值，然后对结果进行编码，可以正确地实现Alpha混合。</strong></p>
<p><strong>重要的是在呈现的最后阶段应用转换，此时值被写入帧缓冲区以进行显示。如果后期处理后应用显示编码，这样的影响将计算在非线性值，这通常是不正确的，并将经常导致伪影。显示编码可以被认为是一种压缩形式，它最好地保留了值的感知效果。考虑这个区域的一个好方法是线性值,我们使用执行物理计算,每当我们想要显示结果或访问可显示的图像如颜色纹理,我们需要移动数据或从其显示编码形式,使用适当的编码或解码转换。</strong></p>
<p><strong>如果您确实需要手动应用sRGB，有一个标准的转换方程或几个简化版本可以使用。在实际应用中，显示器由每个颜色通道的若干位控制，例如，8位用于用户显示器，给出一组范围为[0,255]的电平。这里我们将显示编码级别表示为范围[0.0,1.0]，忽略比特数。线性值也在[0.0,1.0]范围内，表示浮点数。我们用x表示这些线性值，用y表示存储在帧缓冲区中的非线性编码值。为了将线性值转换为sRGB非线性编码值，我们应用sRGB显示传递函数的逆函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920145812.png" class="" title="image-20210920145812">

<p><strong>x表示线性RGB中的一个通道。等式应用于每个通道，这三个生成的值驱动显示。你要小心手动应用转换函数。一个错误的来源是使用编码颜色而不是它的线性形式，另一个来源是解码或编码颜色两次。</strong></p>
<p><strong>两个变换表达式的底部是一个简单的乘法，这是由于数字硬件需要使变换完全可逆。上面的表达式将值提高到某次幂，几乎适用于输入值x的整个范围[0.0,1.0]。考虑到偏移量和比例，该函数近似于一个更简单的公式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150010.png" class="" title="image-20210920150010">

<p><strong>其中γ = 2.2。</strong></p>
<p><strong>正如必须对计算值进行编码以便显示一样，静态或视频摄像机捕获的图像在用于计算之前必须转换为线性值。你在显示器或电视上看到的任何颜色都有一些显示编码的RGB三联体，你可以从屏幕捕获或颜色选择器获得。这些值是以PNG、JPEG和GIF等文件格式存储的，这些格式可以直接发送到帧缓冲区以在屏幕上显示，而不需要进行转换。换句话说，无论您在屏幕上看到什么，根据定义都是显示编码的数据。在使用这些颜色进行底纹计算之前，我们必须将这种编码形式转换回线性值。我们需要从显示编码到线性编码的sRGB转换</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150155.png" class="" title="image-20210920150155">

<p><strong>用y表示规范化显示的通道值，即存储在图像或帧缓冲区中的内容，表示为范围[0.0,1.0]的值。这个解码函数与我们以前的sRGB公式相反。这意味着如果一个纹理被一个着色器访问并且输出没有改变，它将显示与被处理之前一样，正如预期的那样。解码函数与显示传递函数相同，因为存储在纹理中的值已经过编码以正确显示。我们不是转换为给出线性响应显示，而是转换为给出线性值。</strong></p>
<p><strong>更简单的gamma显示传递函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150324.png" class="" title="image-20210920150324">

<p><strong>有时你会看到一个更简单的转换组合，特别是在移动和浏览器应用程序:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150334.png" class="" title="image-20210920150334">

<p><strong>也就是说，取线性值的平方根，然后将其与自身相乘得到逆函数。虽然这是一个粗略的估计，但这种转换总比完全忽略这个问题要好。</strong></p>
<p><strong>如果我们不注意伽马值，较低的线性值会在屏幕上显得太暗。一个相关的错误是，如果不进行伽玛校正，某些颜色的色调会发生变化。假设γ = 2.2。我们希望从显示的像素发射出与线性计算值成比例的辐亮度，这意味着我们必须将线性值提高到(1/2.2)次方。线性值0.1给出0.351,0.2给出0.481,0.5给出0.730。如果未对这些值进行编码，则按原样使用这些值将导致显示器发出比所需更少的亮度。注意0.0和1.0在任何这些转换中都是不变的。在使用伽马校正之前，暗色的表面颜色通常会被建模场景的人人为地增强，在反显示变换中折叠。</strong></p>
<p><strong>忽略gamma校正的另一个问题是，对物理线性辐射值正确的着色计算是在非线性值上执行的。如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150548.png" class="" title="image-20210920150548">

<p>两个重叠的聚光灯照亮一个平面。在左边的图像中，添加光值0.6和0.4后没有进行gamma校正。该加法可以有效地对非线性值进行运算，从而产生误差。注意左边的光看起来要比右边的亮得多，而且重叠看起来亮得不现实。在右边的图像中，这些值在相加后进行了gamma校正。光本身按比例更亮，它们在重叠的地方恰当地结合在一起。</p>
<p><strong>忽略伽马校正也会影响抗锯齿边缘的质量。例如，假设一个三角形边缘覆盖四个屏幕网格单元格(下图)。三角形的归一化亮度为1(白色);背景是0(黑色)。从左到右，细胞被覆盖1/8、3/8、5/8和7/8。因此，如果我们使用盒形滤波器，我们想要将像素的归一化线性亮度表示为0.125、0.375、0.625和0.875。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150711.png" class="" title="image-20210920150711">

<p>在左边，四个像素被一个白色三角形的边缘覆盖在一个黑色(显示为灰色)的背景上，真实的区域覆盖显示。如果伽玛校正不执行，中音变暗将导致边缘感知被扭曲，如右图所示。</p>
<p><strong>正确的方法是对线性值执行反走样，对四个结果值应用编码函数。如果不这样做，像素所代表的辐亮度将会太暗，导致在图的右侧看到的边缘变形。这种人为效果被称为绳索，因为它的边缘看起来有点像一根扭曲的绳子。下图显示了这个效果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920150954.png" class="" title="image-20210920150954">

<p>在左侧，抗锯齿线集被伽马校正;中间部分是部分修正;在右边，没有伽马校正。(图片由Scott R. Nelson提供。)</p>
<p><strong>sRGB标准创建于1996年，已经成为大多数计算机显示器的标准。然而，从那时起，显示技术已经发生了变化。人们已经开发出了更明亮、能显示更多种颜色的显示器。第8.1.3节讨论了彩色显示和亮度，第8.2.1节介绍了高动态范围显示的显示编码。Hart的文章提供了关于先进显示器的更多信息。</strong></p>
<h1 id="6-Texturing-纹理"><a href="#6-Texturing-纹理" class="headerlink" title="6 Texturing 纹理"></a>6 Texturing 纹理</h1><p><strong>表面纹理就是外观和感觉——想想油画的纹理就知道了。在计算机图形学中，纹理是一个过程，它获取一个表面，并使用一些图像、功能或其他数据源在每个位置修改它的外观。例如，不精确地表示砖墙的几何形状，而是将砖墙的彩色图像应用于由两个三角形组成的矩形。当查看矩形时，彩色图像出现在矩形所在的位置。除非观众靠近墙壁，否则缺乏几何细节是不会被注意到的。</strong></p>
<p><strong>然而，一些有纹理的砖墙除了缺乏几何学之外，还可能无法令人信服。例如，如果砂浆是哑光的，而砖块是光滑的，观众会注意到这两种材料的粗糙度是相同的。为了产生更令人信服的体验，第二个图像纹理可以应用到表面。这种纹理不是改变表面的颜色，而是根据表面的位置改变墙壁的粗糙度。现在砖块和砂浆的颜色来自图像纹理，粗糙度值来自这个新的纹理。</strong></p>
<p><strong>观众可以看到，现在所有的砖都是光滑的，而砂浆不是，但注意到每个砖面似乎是完美的平面。这看起来不太对，因为砖块的表面通常有一些不规则。通过应用凹凸贴图，砖块的着色法线可能会有所变化，所以当它们被渲染时，它们不会看起来非常光滑。为了计算光照，这种纹理会抖动矩形的原始表面法线的方向。</strong></p>
<p><strong>从一个小角度来看，这种凹凸不平的错觉可能会被打破。砖块应该突出在灰泥之上，遮住视线。即使从直观的角度看，砖块的影子也会投射到灰泥上。视差贴图在渲染平面时使用纹理使其变形，视差遮挡贴图将光线投射到高度场纹理上以提高真实感。位移映射通过修改形成模型的三角形高度来真实地置换表面。下图显示了一个使用颜色纹理和凹凸贴图的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920151615.png" class="" title="image-20210920151615">

<p><strong>这些都是用纹理解决的问题的例子，使用越来越复杂的算法。在本章中，纹理技术将被详细介绍。首先，提出了一个纹理加工的总体框架。接下来，我们着重于使用图像纹理表面，因为这是实时工作中最流行的纹理形式。简要讨论了程序纹理，然后解释了一些常见的纹理影响表面的方法。</strong></p>
<h2 id="The-Texturing-Pipeline-纹理管线"><a href="#The-Texturing-Pipeline-纹理管线" class="headerlink" title="The Texturing Pipeline 纹理管线"></a>The Texturing Pipeline 纹理管线</h2><p><strong>纹理是一种有效地在表面的材质和完成的变化建模技术。考虑纹理的一种方法是考虑单个着色像素的情况。正如在前一章所看到的，着色是通过考虑材质的颜色和光线，以及其他因素来计算的。如果存在，透明度也会影响样本。纹理通过修改在着色方程中使用的值来工作。改变这些值的方式通常是基于表面上的位置。因此，对于砖墙的例子，基于表面位置，表面上任何一点的颜色都被砖墙图像中相应的颜色所替换。图像纹理中的像素通常被称为texels，以与屏幕上的像素区分开来。粗糙度纹理修改了粗糙度值，凹凸纹理改变了着色法线的方向，所以每一个都改变了着色方程的结果。</strong></p>
<p><strong>纹理可以用广义纹理管线来描述。</strong></p>
<p><strong>空间中的位置是纹理过程的起点。这个位置可以在世界空间中，但更多的是在模型的参考框架中，所以当模型移动时，纹理也会随之移动。使用Kershaw的术语，空间中的这个点有一个投影函数，用于获得一组被称为纹理坐标的数字，这些数字将用于访问纹理。这个过程称为映射，这引出了纹理映射。有时纹理图像本身被称为纹理映射，尽管严格上来说这是不正确的。</strong></p>
<p><strong>在使用这些新值访问纹理之前，可以使用一个或多个对应函数将纹理坐标转换为纹理空间。这些纹理空间位置用于从纹理中获取值，例如，它们可以是数组索引到图像纹理中以检索像素。检索到的值被一个值转换函数再次潜在地转换，最后这些新值被用来修改表面的一些属性，如材质或着色法线。下图详细展示了单个纹理的应用过程。管线之所以如此复杂，是因为每一步都为用户提供了一个有用的控件。应该注意的是，并非所有步骤都需要在任何时候被激活。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920153341.png" class="" title="image-20210920153341">

<p>一个单一纹理的广义纹理管线。</p>
<p><strong>使用这个管线，当一个三角形有一个砖墙纹理，并且在它的表面生成一个样本时，就会发生这样的情况(参见下图)。在物体的局部参照系中找到(x, y, z)位置;即(−2.3,7.1,88.2)。然后将一个投影仪功能应用到这个位置。就像一幅世界地图是一个三维物体的二维投影,投影函数通常改变(x, y, z)向量成双元素向量(u, v)。本例中使用的投影仪功能相当于一个正射投影(2.3.1节),作用类似幻灯机闪亮的砖墙上三角形的表面形象。为了返回到壁面，可以将壁面上的一个点转换为一对0到1之间的值。假设得到的值是(0.32,0.29)。这些纹理坐标用于查找图像在这个位置的颜色。砖块纹理的分辨率是256 × 256，所以对应函数将(u, v)分别乘以256，得到(81.92,74.24)。去掉分数，在砖墙图像中找到像素(81,74)，为彩色(0.9,0.8,0.7)。纹理颜色在sRGB颜色空间中，所以如果颜色用于着色方程，它被转换为线性空间，给出(0.787,0.604,0.448)(章节5.6)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920153621.png" class="" title="image-20210920153621">

<p>一堵砖墙的管线。</p>
<h3 id="The-Projector-Function-投影函数"><a href="#The-Projector-Function-投影函数" class="headerlink" title="The Projector Function 投影函数"></a>The Projector Function 投影函数</h3><p><strong>纹理处理的第一步是获取表面的位置并将其投影到纹理坐标空间，通常是二维(u, v)空间。建模包通常允许艺术家定义每个顶点的(u, v)坐标。这些可以从投影仪函数或网格展开算法初始化。艺术家可以用编辑顶点位置的方式编辑(u, v)坐标。投影的功能通常是将空间中的三维点转换为纹理坐标。建模程序中常用的函数包括球面、圆柱和平面投影。</strong></p>
<p><strong>其他输入可用于投影函数。例如，表面法线可以用来选择用于表面的六个平面投影方向中的哪个。纹理匹配的问题发生在面相遇的接缝处;Geiss讨论了一种混合它们的技巧。Tarini等人描述了聚立方体映射，其中模型映射到一组立方体投影，不同的空间体积映射到不同的立方体。</strong></p>
<p><strong>其他投影函数根本不是投影，而是曲面创建和镶嵌的一个隐式部分。例如，参数曲面具有(u, v)值的自然集作为其定义的一部分。参见下图。纹理坐标也可以由各种不同的参数生成，如视图方向、表面温度或其他任何可以想象的参数。投影函数的目标是生成纹理坐标。把这些作为位置的函数来推导只是一种方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920154218.png" class="" title="image-20210920154218">

<p>不同贴图投影。从左到右分别显示球面、圆柱、平面和自然(u, v)投影。下面一行显示了应用于单个对象(没有自然投影)的每个投影。</p>
<p><strong>非交互式渲染器通常将这些投影函数作为渲染过程本身的一部分。单一的投影函数可能足以满足整个模型，但艺术家经常不得不使用工具来细分模型，并分别应用各种投影函数。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920154524.png" class="" title="image-20210920154524">

<p>如何在一个模型上使用不同的纹理投影。箱形映射由六个平面映射组成，每个箱形面一个平面映射。(图片由Tito Pag´an提供。)</p>
<p><strong>在实时工作中，通常在建模阶段应用投影函数，并将投影结果存储在顶点上。情况并非总是如此;有时，在顶点或像素着色器中应用投影函数是有利的。这样做可以提高精度，并帮助启用各种效果，包括动画(第6.4节)。一些呈现方法，如环境映射(第10.4节)，有自己的专门的投影函数，按像素计算。</strong></p>
<p><strong>球面投影将点投射到一个以某一点为中心的虚拟球体上。这个投影与Blinn和Newell的环境映射方案(第10.4.1节)中使用的相同。这种投影方法也会遇到与上一节中描述的顶点插值相同的问题。</strong></p>
<p><strong>圆柱投影计算的纹理坐标u与球面投影相同，纹理坐标v计算的是沿着圆柱轴的距离。这种投影对于具有自然轴的物体是有用的，例如旋转表面。当表面与圆柱体的轴线接近垂直时，就会发生变形。</strong></p>
<p><strong>平面投影就像一束x射线，沿着一个方向平行投影，并将纹理应用到所有的表面。它使用正投影(第4.7.1节)。这种类型的投影对于贴花很有用，例如(第20.2节)。</strong></p>
<p><strong>由于在投影方向上的表面会有严重的扭曲，艺术家经常必须手工将模型分解成近平面的部分。还有一些工具可以通过展开网格来帮助最小化扭曲，或者创建一组接近最优的平面投影，或者其他帮助这个过程的工具。我们的目标是让每个多边形在纹理区域中拥有更公平的份额，同时保持尽可能多的网格连接。连接性是很重要的，因为采样伪影可以沿着纹理的不同部分的边缘出现。一个网格良好的展开也能使艺术家的工作更轻松。第16.2.1节讨论了纹理失真如何对渲染产生不利影响。下图显示了用于创建雕像的工作区。这种展开过程是网格参数化这一更大的研究领域的一个方面。感兴趣的读者可参考Hormann等人的SIGGRAPH课程笔记。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920155042.png" class="" title="image-20210920155042">

<p>雕像模型的几个较小的纹理，保存在两个较大的纹理中。右图显示了三角形网格是如何展开的，并显示在纹理上，以帮助创建。(图片由Tito Pag´an提供。)</p>
<p><strong>纹理坐标空间并不总是一个二维平面;有时它是一个三维的体积。在这种情况下，纹理坐标被呈现为一个三元素向量(u, v, w)， w是沿着投影方向的深度。其他系统最多使用四个坐标，通常指定为(s, t, r, q);Q被用作齐次坐标中的第四个值。它就像一部电影或幻灯片放映机，投影纹理的大小随着距离的增加而增加。例如，在舞台或其他表面上投射一种被称为“gobo”的装饰性聚光灯图案是很有用的。</strong></p>
<p><strong>纹理坐标空间的另一种重要类型是方向性，其中空间中的每个点都可以通过输入方向访问。一种可视化这样一个空间的方法是作为一个单位球体上的点，每个点的法线代表了用于访问该位置纹理的方向。使用方向性参数化的纹理最常见的类型是立方体映射(章节6.2.4)。</strong></p>
<p><strong>同样值得注意的是，一维纹理图像和功能有其用途。例如，在一个地形模型上，颜色可以由海拔高度决定，例如，低地是绿色的;山峰是白色的。线条也可以被纹理化;它的一个用途是将雨渲染成一组带有半透明纹理的长线。这样的纹理对于从一个值转换到另一个值也很有用。例如，作为查找表。</strong></p>
<p><strong>因为多个纹理可以应用到一个表面上，所以可能需要定义多个纹理坐标集。然而，应用坐标值的思路是相同的:这些纹理坐标被插值到整个表面并用于检索纹理值。然而，在插值之前，这些纹理坐标是通过对应函数进行变换的。</strong></p>
<h3 id="The-Corresponder-Function-匹配函数"><a href="#The-Corresponder-Function-匹配函数" class="headerlink" title="The Corresponder Function 匹配函数"></a>The Corresponder Function 匹配函数</h3><p><strong>匹配函数将纹理坐标转换为纹理空间位置。它们提供了在表面上应用纹理的灵活性。匹配函数的一个例子是使用API来选择现有纹理的一部分进行显示;后续操作中只会使用该子图像。</strong></p>
<p><strong>另一种类型的匹配是矩阵变换，它可以应用于顶点或像素着色器。这可以在表面上平移、旋转、缩放、剪切或投影纹理。如第4.1.5节所述，转换的顺序很重要。纹理转换的顺序必须与人们所期望的顺序相反。这是因为纹理变换实际上影响了决定图像在哪里看到的空间。图像本身不是一个被转换的物体;定义图像位置的空间正在被更改。</strong></p>
<p><strong>另一类对应函数控制应用图像的方式。我们知道图像将出现在(u, v)在[0,1]范围内的表面上。但是在这个范围之外会发生什么呢?匹配函数可以决定这个行为。在OpenGL中，这种类型的通信器函数被称为“包装模式”;在DirectX中，它被称为“纹理寻址模式”。”这类匹配的常见功能有:</strong></p>
<pre><code>**wrap (DirectX)， repeat (OpenGL)或tile：图像在表面上重复自身;算法上，纹理坐标的整数部分被删除。这个函数对于让一个材质的图像重复覆盖一个表面很有用，并且通常是默认的。**

**镜像：图像在整个表面上重复，但每重复一次就会被镜像(翻转)。例如，图像从0到1正常显示，然后在1和2之间反向显示，然后在2和3之间正常显示，然后反向显示，以此类推。这就为纹理的边缘提供了一些连续性。**

**clamp (DirectX)或clamp to edge (OpenGL)：超出范围[0,1]的值被clamp到这个范围。这导致图像纹理边缘的重复。该函数有助于避免在纹理边缘附近发生双线性插值时意外地从纹理的相反边缘获取样本。**

**border (DirectX)或clamp to border (OpenGL)：纹理坐标在[0,1]外使用单独定义的边框颜色进行渲染。这个函数可以在单色表面上很好的渲染贴花，例如，纹理的边缘将与边框颜色平滑地融合。**
</code></pre>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920160130.png" class="" title="image-20210920160130">

<p><strong>参见上图。这些匹配函数可以为每个纹理轴分配不同的值，例如，纹理可以沿着u轴重复，并被固定在v轴上。在DirectX中也有一个镜像一次模式，它沿着纹理坐标的零值一次镜像纹理，然后clamp，这对对称贴花很有用。</strong></p>
<p><strong>重复平铺纹理是一种为场景添加更多视觉细节的廉价方法。然而，当眼睛看出图案时，这种技术在重复三次纹理后往往看起来不令人信服。避免这种周期性问题的一个常见解决方案是将纹理值与另一个非平铺的纹理相结合。这种方法可以得到相当大的扩展，正如Andersson所描述的商业地形渲染系统所示。在这个系统中，根据地形类型、海拔高度、坡度等因素组合多种纹理。纹理图像也与场景中放置的几何模型有关，比如灌木丛和岩石。</strong></p>
<p><strong>避免周期性的另一个选择是使用着色程序来实现专门的对应函数，随机重新组合纹理模式或细分。Wang tiles 就是这种方法的一个例子。Wang tiles 是一组边缘相匹配的正方形瓦组。贴图是在贴图过程中随机选择的。Lefebvre和Neyret使用依赖纹理读取和表实现了类似类型的匹配函数，以避免模式重复。</strong></p>
<p><strong>最后应用的对应函数是隐式的，由图像的大小导出。纹理通常在u和v的[0,1]范围内应用。如砖墙的例子所示，通过将这个范围内的纹理坐标乘以图像的分辨率，就可以得到像素的位置。能够在[0,1]范围内指定(u, v)值的好处是，不同分辨率的图像纹理可以交换，而不必更改存储在模型顶点的值。</strong></p>
<h3 id="Texture-Values-纹理值"><a href="#Texture-Values-纹理值" class="headerlink" title="Texture Values 纹理值"></a>Texture Values 纹理值</h3><p><strong>在匹配函数生成纹理空间坐标后，利用坐标获取纹理值。对于图像纹理，这是由访问纹理从图像中检索texel信息。这一过程将在第6.2节中详细讨论。图像纹理构成了实时工作中纹理使用的绝大部分，但过程函数也可以使用。在过程纹理的情况下，从纹理空间位置获取纹理值的过程不涉及内存查找，而是函数的计算。过程纹理将在章节6.3中进一步描述。</strong></p>
<p><strong>最直接的纹理值是RGB三元组，用于替换或修改表面颜色;类似地，可以返回单个灰度值。另一种要返回的数据类型是RGBα，如第5.5节所述。α (alpha)值通常是颜色的不透明度，它决定了颜色可能影响像素的程度。也就是说，任何其他值都可以存储，比如表面粗糙度。还有许多其他类型的数据可以存储在图像纹理中，这将在凹凸贴图的详细讨论中看到(章节6.7)。</strong></p>
<p><strong>从纹理返回的值在使用前可选地转换。这些转换可以在着色器程序中执行。一个常见的例子是将数据从无符号范围(0.0，1.0)映射到有符号范围(−1.0，1.0)，这用于在颜色纹理中存储着色法线。</strong></p>
<h2 id="Image-Texturing-图像纹理"><a href="#Image-Texturing-图像纹理" class="headerlink" title="Image Texturing 图像纹理"></a>Image Texturing 图像纹理</h2><p><strong>在图像纹理化中，一个二维图像有效地粘在一个或多个三角形的表面上。我们已经走过了计算纹理空间位置的过程;现在，我们将讨论从给定位置的图像纹理中获取纹理值的问题和算法。在本章的其余部分，图像纹理将被简单地称为纹理。此外，当我们在这里提到一个像素的单元格时，我们指的是围绕该像素的屏幕网格单元格。正如在第5.4.1节中讨论的，像素实际上是显示的颜色值，它可以(为了更好的质量)受到其相关网格单元之外的样本的影响。</strong></p>
<p><strong>在本节中，我们特别关注快速采样和过滤纹理图像的方法。第5.4.2节讨论了走样问题，特别是渲染对象的边缘。纹理也可能有采样问题，但它们发生在被渲染的三角形内部。</strong></p>
<p><strong>像素着色器通过将纹理坐标值传递给一个调用(如texture2D)来访问纹理。这些值是(u, v)纹理坐标，由匹配函数映射到范围[0.0,1.0]。GPU负责将这个值转换为texel坐标。不同API中的纹理坐标系统有两个主要的区别。在DirectX中，纹理的左上角是(0,0)，右下角是(1,1)。这与存储数据的图像类型的数量相匹配，顶部的行是文件中的第一行。在OpenGL中，texel(0,0)位于左下角，与DirectX的y轴翻转。Texels有整数坐标，但是我们经常想要访问Texels之间的位置并混合它们。这就引出了一个问题，即像素中心的浮点坐标是什么。Heckbert讨论了如何有两种可能的系统:截断和舍入。DirectX 9定义每个中心在(0.0,0.0)：这使用舍入。这个系统有点混乱，因为在DirectX的原点，左上角像素的左上角，然后有值(−0.5，−0.5)。DirectX 10进一步改变了OpenGL的系统，texel的中心有分数值(0.5,0.5)：截断，或者更准确地说，flooring，丢弃分数。flooring是一个更自然的系统，可以很好地映射到语言，例如，在像素(5,9)中，u坐标的范围从5.0到6.0,v坐标的范围从9.0到10.0。</strong></p>
<p><strong>在这一点上一个值得解释的术语是依赖纹理读取，它有两种定义。第一种尤其适用于移动设备。当通过texture2D或类似方法访问纹理时，当像素着色器计算纹理坐标而不是使用从顶点着色器传入的未经修改的纹理坐标时，就会发生依赖纹理读取。注意，这意味着对传入纹理坐标的任何更改，甚至是交换u和v值这样的简单操作。旧的移动GPU，那些不支持OpenGL ES 3.0的，当着色器没有依赖的纹理读取时运行得更高效，因为texel数据可以被预取。这个术语的另一个较早的定义对于早期的桌面GPU尤其重要。在这种情况下，当一个纹理的坐标依赖于一些先前纹理值的结果时，就会发生依赖性纹理读取。例如，一个纹理可能会改变着色法线，这反过来又会改变用于访问立方体映射的坐标。这种功能在早期的GPU上是有限的，甚至不存在。如今，此类读取可能会对性能产生影响，这取决于批处理中计算的像素数量以及其他因素。有关更多信息，请参阅23.8节。</strong></p>
<p><strong>GPU中使用的纹理图像大小通常为2^m ×2^n texels，其中m和n是非负整数。这些被称为2的幂次(POT)纹理。现代GPU可以处理任意大小的非2幂次(NPOT)纹理，这允许生成的图像被当作纹理处理。然而，一些旧的移动GPU可能不支持NPOT纹理的mipmapping(章节6.2.2)。图形加速器在纹理大小上有不同的上限。例如，DirectX 12允许最大16384²像素。</strong></p>
<p><strong>假设我们有一个大小为256 × 256像素的纹理，我们想把它用作一个正方形的纹理。只要投影在屏幕上的方块与纹理的大小大致相同，方块上的纹理看起来就几乎和原始图像一样。但是，如果投影的正方形所覆盖的像素是原始图像的10倍(称为放大)，或者投影的正方形只覆盖屏幕的一小部分(称为缩小)，会发生什么呢?答案是，这取决于您决定对这两种不同的情况使用哪种抽样和过滤方法。</strong></p>
<p><strong>本章讨论的图像采样和滤波方法应用于从每个纹理读取的值。然而，理想的结果是在最终渲染的图像中防止走样，这在理论上需要对最终像素的颜色进行采样和过滤。这里的区别是过滤着色方程的输入，还是过滤输出。只要输入和输出是线性相关的(这是真的对于输入，如颜色)，然后过滤个别纹理值相当于过滤最终的颜色。然而，许多着色器输入值存储在纹理中，如表面法线和粗糙度值，与输出有非线性关系。标准的纹理过滤方法可能不能很好地处理这些纹理，导致走样。改进的纹理过滤方法将在9.13节中讨论。</strong></p>
<h3 id="Magnification-放大"><a href="#Magnification-放大" class="headerlink" title="Magnification 放大"></a>Magnification 放大</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920211152.png" class="" title="image-20210920211152">

<p>将48 × 48的图像纹理放大到320 × 320像素。左:最近的邻域过滤，其中最近的像素被选择。中:使用4个最接近像素的加权平均的双线性滤波。右图:使用5 × 5最接近像素的加权平均值进行立方滤波。</p>
<p><strong>在上图中，一个大小为48 × 48 texels的纹理被纹理到一个正方形上，并且这个正方形相对于纹理大小被观察得相当近，所以底层的图形系统必须放大纹理。最常见的放大滤波技术是最近邻滤波(实际的滤波器称为框式滤波器，见第5.4.1节)和双线性插值。还有立方卷积，它使用4 × 4或5 × 5像素数组的加权和。这使得更高的放大质量成为可能。虽然原生硬件支持三次卷积(也称为双三次插值)目前并不普遍，但它可以在一个着色程序中执行。</strong></p>
<p><strong>在图的左边部分，使用了最近邻法。这种放大技术的一个特点是，单个像素可能变得明显。这种效果被称为像素化，因为该方法在放大时取离每个像素中心最近的像素值，从而产生块状外观。虽然这种方法的质量有时很差，但它只需要为每个像素取一个像素。</strong></p>
<p><strong>在同一图形的中间图像中，使用了双线性插值(有时称为线性插值)。对于每个像素，这种滤波找到四个相邻的像素，并在二维线性插值，以找到像素的混合值。结果变得更加模糊，使用最近邻法产生的许多锯齿都消失了。作为一个实验，试着看看左边的图像当你眯眼的时候，这和低通滤镜的效果差不多，会让你的脸看起来更明显一些。</strong></p>
<p><strong>之前的砖块纹理示例:在不删除碎片的情况下，我们得到了(pu,pv) =(81.92, 74.24)。我们在这里使用OpenGL的左下角原点texel坐标系统，因为它匹配标准笛卡尔坐标系。我们的目标是在四个最接近的像素之间插入，使用它们的像素中心定义一个像素大小的坐标系统。参见下图。为了找到4个最近的像素，我们从样本位置中减去像素中心分数(0.5,0.5)，得到(81.42,73.74)。去掉分数，最接近的四个像素的范围从(x, y) =(81,73)到(x+1, y+1) =(82,74)。在我们的例子中，小数部分(0.42,0.74)是样品相对于由四个texel中心组成的坐标系的位置。我们把这个位置表示为(u′, v′)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920211533.png" class="" title="image-20210920211533">

<p>双线性插值。所涉及的四个像素由左边的四个正方形表示，像素中心为蓝色。右边是由四个像素的中心组成的坐标系。</p>
<p><strong>定义纹理访问函数为t(x, y)，其中x和y是整数，并返回texel的颜色。任何位置(u’,v’)的双线性插值颜色可以通过两步计算。首先,texel底部,t (x, y)和t (x + 1, y),将被内插水平(使用u ‘),同样的最上面的两个texel t (x,y+1)和t (x+1,y+1)。texel底部,我们获得(1−u ‘) t (x, y) + u′(x + 1, y)(上图中下方绿色圆圈),顶部,(1−u ‘) t (x, y + 1) + u′(x + 1, + 1)(顶部绿色圆圈)。然后垂直插入这两个值(使用v′)，因此双线性插值颜色b在(pu,pv)是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920212007.png" class="" title="image-20210920212007">

<p><strong>直观地说，离样本位置越近的texel对最终值的影响越大。这就是我们在这个方程中看到的。右上角的texel (x+1, y +1)有u ‘ v ‘的影响。注意它的对称性:右上角的影响等于左下角和样本点形成的矩形的面积。回到我们的例子，这意味着从texel中获取的值将乘以0.42 × 0.74，具体来说是0.3108。顺时针方向上，其他乘数分别为0.42 × 0.26、0.58 × 0.26和0.58 × 0.74，这四个权重之和为1.0。</strong></p>
<p><strong>一种常见的解决方法是使用细节纹理。这些纹理代表了细微的表面细节，从手机上的划痕到地形上的灌木丛。这样的细节以不同的比例叠加在放大的纹理上作为一个单独的纹理。细节纹理的高频重复图案，结合低频放大纹理，具有类似于使用单一高分辨率纹理的视觉效果。</strong></p>
<p><strong>双线性插值在两个方向上进行线性插值。然而，线性插值是不需要的。假设一个纹理由棋盘图案中的黑色和白色像素组成。使用双线性插值在纹理上给出不同的灰度样本。通过重新映射，例如，所有低于0.4的灰色都是黑色的，所有高于0.6的灰色都是白色的，而那些介于两者之间的灰色被拉伸以填补空白，纹理看起来更像一个棋盘，同时也在像素之间提供了一些混合。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920212226.png" class="" title="image-20210920212226">

<p>最近邻，双线性插值，以及通过重映射的部分方法，使用相同的2 × 2棋盘格纹理。请注意，由于纹理和图像网格不完全匹配，最近邻采样给出的正方形大小略有不同。</p>
<p><strong>使用更高分辨率的纹理也会有类似的效果。例如，想象每个方格由4 × 4像素组成，而不是1 × 1像素。在每个格子的中心，插值的颜色将是全黑或全白。</strong></p>
<p><strong>在本节开头图片的右边，使用了一个双三次滤波器，剩余的块性被很大程度上去除了。需要注意的是，双三次滤波器比双线性滤波器更昂贵。然而，许多高阶滤波器可以表示为重复线性插值(另见第17.1.1节)。因此，纹理单元中用于线性插值的GPU硬件可以通过多次查找来开发。</strong></p>
<p><strong>如果认为双三次滤波器太昂贵，Qu´ılez提出了一种简单的技术，使用平滑曲线在一组2 × 2像素之间进行插值。我们先描述曲线，然后操作。两种常用的曲线是平滑曲线和五次曲线:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920212549.png" class="" title="image-20210920212549">

<p><strong>这对于想要从一个值到另一个值平滑地插入。平滑曲线具有性质s′(0) =s′(1)，且在0和1之间平滑。五次曲线具有相同的性质，但也有q“(0)= q”(1)= 0，即二阶导数在曲线的起点和终点也是0。如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920212817.png" class="" title="image-20210920212817">

<p>平滑曲线s(x)(左)和五次曲线q(x)(右)。</p>
<p><strong>该技术首先计算(u’，v’)，方法是先将样本乘以纹理尺寸并添加0.5。整数部分留待以后使用，分数存储在u ‘和v ‘中，其取值范围为[0,1]。(u′, v′)变换为(tu,tv) = (q (u′),q(v′)，仍然在[0,1]的范围内。最后，减去0.5并将整数部分加回去;然后得到的u坐标除以纹理宽度，v也是如此。在这一点上，新的纹理坐标与GPU提供的双线性插值查找一起使用。注意，这种方法将在每个像素上给出一个平台，这意味着如果像素位于RGB空间的一个平面上，那么这种类型的插值将给出一个平滑的，但仍然是阶梯状的外观，这可能并不总是想要的。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920213045.png" class="" title="image-20210920213045">

<p>四种不同的方法来放大一维纹理。橙色的圆圈表示像素的中心以及像素值(高度)。从左到右:最近邻，线性，使用五次曲线之间的每对相邻像素，并使用三次插值。</p>
<h3 id="Minification-缩小"><a href="#Minification-缩小" class="headerlink" title="Minification 缩小"></a>Minification 缩小</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920213227.png" class="" title="image-20210920213227">

<p>缩小:通过一排像素单元查看棋盘纹理的正方形，大致显示像素数量如何影响每个像素。</p>
<p><strong>当一个纹理被最小化时，几个像素可能会覆盖一个像素的单元格，如上图所示。要为每个像素获得正确的颜色值，您应该集成影响像素的像素的效果。然而，很难精确地确定特定像素附近所有像素的确切影响，而且实际上不可能在实时中完美地做到这一点。</strong></p>
<p><strong>由于这个限制，GPU上使用了几种不同的方法。一种方法是使用最近邻，它的工作原理与相应的放大滤波器完全一样，即它选择在像素单元格中心可见的像素。这个过滤器可能会导致严重的走样问题。在下图中，最上面的图使用了最近邻。朝向视界时，会出现伪影，因为影响一个像素的众多像素中只有一个被选择来代表表面。当表面相对于观察者移动时，这样的伪影更加明显，并且是所谓的时间走样的一种表现。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920213348.png" class="" title="image-20210920213348">

<p>顶部图像采用点采样(最近邻)，中心采用mipmapping，底部采用求和区域表。</p>
<p><strong>另一种常用的滤波器是双线性插值，它的工作原理与放大滤波器完全相同。在缩小方面，这个过滤器只比最近邻方法稍好一点。它混合了四个像素而不是仅仅使用一个，但当一个像素受到超过四个像素的影响时，过滤器很快就会失效并产生走样。</strong></p>
<p><strong>更好的解决方案是存在的。如第5.4.1节所述，走样问题可以通过采样和滤波技术来解决。纹理的信号频率取决于其像素在屏幕上的间距。由于奈奎斯特限制，我们需要确保纹理的信号频率不大于样本频率的一半。例如，假设一幅图像由交替的黑白线条组成，间隔一个像素。波长是两个像素宽(从黑线到黑线)，所以频率是1/2 ．为了在屏幕上正确地显示纹理，频率必须至少为2×1/2,即每像素至少一个像素。所以，对于一般的纹理，每个像素最多应该有一个像素，以避免走样。</strong></p>
<p><strong>为了实现这一目标，要么像素的采样频率必须增加，要么纹理频率必须降低。前面讨论的抗锯齿方法第三章给出了提高像素采样率的方法。然而，这些方法只增加了有限的采样频率。为了更全面地解决这个问题，人们开发了各种纹理缩小算法。</strong></p>
<p><strong>所有纹理抗锯齿算法背后的基本思想都是一样的:对纹理进行预处理，并创建数据结构，以帮助计算一组像素对一个像素的影响的快速近似。对于实时性工作，这些算法具有使用固定的时间和资源执行的特点。通过这种方式，每个像素采集固定数量的样本，并结合起来计算(可能是巨大的)像素数量的效果。</strong></p>
<h4 id="Mipmapping-映射"><a href="#Mipmapping-映射" class="headerlink" title="Mipmapping 映射"></a>Mipmapping 映射</h4><p><strong>最通用的纹理反走样方法叫做mipmapping。它以某种形式在所有图形加速器上实现。“Mip”代表parvo中的multum，拉丁语的意思是“小地方的许多东西”——这个名字很好地描述了一种将原始纹理反复过滤成更小图像的过程。</strong></p>
<p><strong>当使用mipmapping最小化过滤器时，在实际渲染之前，原始纹理会被一组更小的纹理增强的地方。纹理(在0级)被向下采样到原始区域的四分之一，每个新的像素值通常被计算为原始纹理中四个相邻像素的平均值。新的一级纹理有时被称为原始纹理的子纹理。缩减是递归执行，直到纹理的一个或两个维度等于一个texel。这个过程如图所示。整个图像集通常称为mipmap链。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920213940.png" class="" title="image-20210920213940">

<p>mipmap是通过取金字塔底部的原始图像(第0层)，并在下一层将每个2 × 2区域平均为一个texel值而形成的。垂直轴是第三个纹理坐标d。在图中，d不是线性的;它是一个样本用于插值的两个纹理级别的度量。</p>
<p><strong>形成高质量mipmap的两个重要因素是良好的滤波和伽马校正。形成一个mipmap级别的常见方法是取每个2 × 2像素集，并将它们平均得到mip像素值。使用的过滤器是盒状过滤器，可能是最糟糕的过滤器之一。这可能会导致质量差，因为它会不必要地模糊低频，同时保留一些导致走样的高频。最好使用Gaussian, Lanczos, Kaiser或类似的滤波器;该任务有快速、免费的源代码，一些API支持GPU本身更好的过滤。在纹理的边缘附近，在过滤时必须注意纹理是重复的还是单个副本。</strong></p>
<p><strong>对于编码在非线性空间中的纹理(如大多数颜色纹理)，在滤波时忽略gamma校正将修改感知到的mipmap水平亮度。当你离物体越远，使用未校正的mipmaps时，物体整体看起来越暗，对比度和细节也会受到影响。出于这个原因，将这些纹理从sRGB转换为线性空间(章节5.6)是很重要的，在该空间中执行所有的mipmap过滤，并转换结果返回到sRGB颜色空间进行存储。大多数API都支持sRGB纹理，因此可以在线性空间中正确生成mipmaps，并将结果存储在sRGB中。当sRGB纹理被访问时，它们的值首先被转换为线性空间，以便正确地执行放大和缩小。</strong></p>
<p><strong>正如前面提到的，一些纹理与最终的着色颜色具有基本的非线性关系。虽然这通常会给过滤带来问题，但mipmap生成对这个问题特别敏感，因为要过滤成百上千个像素。为了获得最好的结果，通常需要专门的mipmap生成方法。这些方法的详细内容见章节9.13。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920214236.png" class="" title="image-20210920214236">

<p>左边是一个方形像素单元格及其纹理视图。右边是像素单元到纹理本身的投影。</p>
<p><strong>使用纹理的基本过程很简单。屏幕像素包含纹理本身的一个区域。当像素的区域被投影到纹理上时(上图)，它包含一个或多个像素。使用像素的单元格边界并不严格正确，但在这里是用来简化表示的。单元格外的像素会影响像素的颜色;5.4.1之前看到的部分。目标是粗略地确定纹理对像素的影响程度。有两个常用的度量方法用于计算d (OpenGL调用λ，它也被称为纹理细节级别)。一种是利用像素单元形成的四边形的长边来近似像素的覆盖范围;另一种方法是使用∂u/∂x、∂v/∂x、∂u/∂y和∂v/∂y的四个微分的最大绝对值。每个差异都是相对于屏幕轴的纹理坐标变化量的度量。例如，∂u/∂x是沿着x屏幕轴的一个像素的u纹理值的变化量。有关这些方程的更多信息，请参阅Williams的原始文章或Flavell或Pharr的文章。McCormack等人讨论了通过最大绝对值法引入走样，并提出了一个替代公式。Ewins等人分析了几种质量相当的算法的硬件成本。</strong></p>
<p><strong>这些渐变值可用于使用shader Model 3.0或更新版本的像素着色程序。由于它们是基于相邻像素值之间的差异，它们不能在受动态流控制影响的像素着色部分中访问(章节3.8)。对于要在这样一个部分中执行纹理读取(例如，在循环中)，导数必须提前计算。注意，由于顶点着色器不能访问梯度信息，所以梯度或细节级别需要在顶点着色器本身中计算，并在使用顶点纹理时提供给GPU。</strong></p>
<p><strong>计算坐标d的目的是确定沿着mipmap的金字塔轴在哪里取样。目标是像素与像素的比例至少为1:1，以达到奈奎斯特速率。这里的重要原则是，当像素单元包含更多的像素和d增加时，就会访问一个更小、更模糊的纹理版本。(u, v, d)三元组用于访问mipmap。值d类似于纹理级别，但d不是整数值，而是级别之间距离的小数值。对d位置上方和下方的纹理层进行采样。(u, v)位置用于从这两个纹理级别中检索双线性插值样本。然后，根据每个纹理级别到d的距离，对得到的样本进行线性插值。整个过程称为三线性插值，并按每个像素执行。</strong></p>
<p><strong>一个用户对d坐标的控制是详细程度偏差(LOD偏差)。这是d的附加值，因此它会影响纹理的相对感知锐度。如果我们继续向上移动金字塔开始(增加d)，纹理看起来会更模糊。对于任何给定的纹理，一个好的LOD偏差将随图像类型和使用方式而变化。例如，一开始有些模糊的图像可以使用负面偏见，而用于纹理处理的糟糕过滤(别名)合成图像可以使用正面偏见。偏差可以为整个纹理指定，或者在像素着色器中按像素指定。为了更好地控制，用户可以提供d坐标或用于计算它的导数。</strong></p>
<p><strong>mipmapping的好处是，它不是试图将影响一个像素的所有像素相加，而是访问并插值预组合的像素集。这个过程需要固定数量的时间，无论缩小的数量是多少。然而，mipmapping存在一些缺陷。一个主要的问题是过度模糊。假设一个像素单元在u方向上覆盖大量像素，而在v方向上只覆盖少量像素。这种情况通常发生在观察者沿着纹理表面几乎是边对边看的时候。事实上，可能需要沿着纹理的一个轴缩小，沿着纹理的另一个轴放大。访问mipmap的效果是检索纹理上的正方形区域;无法检索矩形区域。为了避免走样，我们选择像素单元在纹理上近似覆盖的最大度量。这导致检索到的样本往往相对模糊。</strong></p>
<h4 id="Summed-Area-Table-求和区域表"><a href="#Summed-Area-Table-求和区域表" class="headerlink" title="Summed-Area Table 求和区域表"></a>Summed-Area Table 求和区域表</h4><p><strong>另一种避免过度模糊的方法是求和面积表(SAT)。要使用此方法，首先创建一个数组，该数组是纹理的大小，但包含存储颜色的更多精度位(例如，红色、绿色和蓝色，每个颜色精度为16位或更多)。在这个数组中的每个位置，必须计算并存储由这个位置和texel(0,0)(原点)组成的矩形中所有对应纹理的texel之和。在纹理过程中，像素单元在纹理上的投影被一个矩形绑定。然后访问求和区域表以确定该矩形的平均颜色，该颜色作为像素的纹理颜色传回。使用如图所示的矩形纹理坐标计算平均值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920214817.png" class="" title="image-20210920214817">

<p>像素单元被反向投影到纹理上，由矩形绑定;矩形的四个角用于访问求和区域表。</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920214909.png" class="" title="image-20210920214909">

<p><strong>这里，x和y是矩形的texel坐标，s[x, y]是该texel的面积之和。这个方程是这样的:取从右上角到原点的整个面积的和，然后减去相邻角的贡献，减去面积A和面积B。面积C被减去了两次，所以它被左下角加了回去。请注意,(xll,yll)是C区的右上角，即(xll + 1, yll + 1)是边界框的左下角。</strong></p>
<p><strong>使用求和区域表的结果如节首图最下所示。往地平线的线在右边边缘附近更尖锐，但中间的对角线仍然过模糊。问题是，当沿着其对角线观看纹理时，会生成一个大的矩形，其中许多像素位于被计算的像素附近。例如，在上图中，想象一个长而细的矩形，表示像素单元的反向投影对角地横过整个纹理。将返回整个纹理矩形的平均值，而不仅仅是像素单元格内的平均值。</strong></p>
<p><strong>求和面积表是所谓各向异性滤波算法的一个例子。这种算法在非正方形区域上检索texel值。然而，SAT能够在水平和垂直方向上最有效地做到这一点的方向。还需要注意的是，对于大小为16 × 16或更小的纹理，求和区域表至少需要两倍的内存，对于更大的纹理，则需要更高的精度。</strong></p>
<p><strong>求和区域表以合理的总体内存成本提供更高的质量，可以在现代GPU上实现。改进的过滤对高级渲染技术的质量是至关重要的。例如，Hensley等人提供了一种有效的实现，并展示了汇总区域采样如何改善光泽反射。其他采用面积采样的算法，如景深、阴影图、模糊反射等，都可以通过SAT进行改进。</strong></p>
<h4 id="Unconstrained-Anisotropic-Filtering-无约束各向异性过滤"><a href="#Unconstrained-Anisotropic-Filtering-无约束各向异性过滤" class="headerlink" title="Unconstrained Anisotropic Filtering 无约束各向异性过滤"></a>Unconstrained Anisotropic Filtering 无约束各向异性过滤</h4><p><strong>对于当前的图形硬件，进一步改进纹理过滤最常用的方法是重用现有的mipmap硬件。其基本思想是像素单元被反向投影，然后对纹理上的这个四边形进行多次采样，并将这些采样进行组合。如上所述，每个mipmap样本都有一个位置和与之相关联的正方形区域。该算法不是使用单一的mipmap样本来近似这个四边形的覆盖范围，而是使用几个正方形来覆盖这个四边形。短边的四边形可以用来确定d(不像在mipmapping，在那里较长的边经常使用);这使得每个mipmap样本的平均面积更小(也更不模糊)。四边形的较长边用来创建一条平行于较长边并穿过四边形中间的各向异性线。当各向异性量在1:1到2:1之间时，沿这条线取两个样品(见下图)。在较高的各向异性比率下，沿轴取的样品越多。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920215307.png" class="" title="image-20210920215307">

<p>各向异性过滤。像素单元格的反向投影创建一个四边形。在较长的边之间形成了一条各向异性线。</p>
<p><strong>该方案允许各向异性线向任何方向运行，因此没有求和面积表的限制。它也不需要比mipmap更多的纹理内存，因为它使用mipmap算法来进行采样。下图是一个各向异性滤波的例子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920215441.png" class="" title="image-20210920215441">

<p>Mipmap与各向异性滤波。在左边做了三线性mipmapping，在右边做了16:1各向异性滤波。向视界方向，各向异性滤波提供了更清晰的结果，并具有最小的走样。(图片来自three.js示例webgl材质纹理各向异性[218]。)</p>
<p><strong>沿轴采样的想法最早是由Schilling等人通过他们的Texram动态存储设备提出的。Barkans描述了该算法在Talisman系统中的使用。McCormack等人提出了一个名为“Feline”的类似系统。Texram的原始配方是沿各向异性轴(也称为探针)给予相同权重的样品。Talisman给予轴两端相对的两个探头一半的重量。Feline使用高斯滤波器核来加权探测器集。这些算法接近高质量的软件采样算法，如椭圆加权平均(EWA)滤波器，它将像素的影响区域转换为纹理上的椭圆，并通过滤波核对椭圆内的像素进行加权。Mavridis和Papaioannou提出了几种使用着色器代码在GPU上实现EWA滤波的方法。</strong></p>
<h3 id="Volume-Textures-体积纹理"><a href="#Volume-Textures-体积纹理" class="headerlink" title="Volume Textures 体积纹理"></a>Volume Textures 体积纹理</h3><p><strong>图像纹理的直接扩展是通过(u, v, w)(或(s, t, r)值)访问的三维图像数据。例如，医学影像数据可以生成为三维网格;通过在网格中移动一个多边形，可以看到这些数据的二维切片。一个相关的想法是用这种形式来表示体积光。在一个表面上的一个点上的照明是通过找到它在这个体积内的位置的值，结合光的方向来找到的。</strong></p>
<p><strong>大多数GPU支持mipmapping的卷纹理。由于在体积纹理的单个mipmap级别内的过滤涉及三线性插值，在mipmap级别之间的过滤需要四线性插值。由于这涉及到平均16像素的结果，可能会导致精度问题，这可以通过使用更高精度的体积纹理来解决。Sigg和Hadwiger讨论了这个问题以及与体积纹理相关的其他问题，并提供了执行过滤和其他操作的有效方法。</strong></p>
<p><strong>尽管体积纹理有更高的存储要求和更昂贵的过滤，他们确实有一些独特的优势。由于三维位置可以直接用作纹理坐标，因此可以跳过为三维网格寻找良好的二维参数化的复杂过程。这避免了在二维参数化中经常出现的变形和接缝问题。体积纹理也可以用来表示木材或大理石等材料的体积结构。一个带有这种纹理的模型看起来就像是用这种材料雕刻出来的。</strong></p>
<p><strong>使用体积纹理的表面纹理是非常低效的，因为绝大多数的样本没有被使用。Benson and Davis和DeBry等讨论了用八叉树结构存储纹理数据。这个方案很适合交互式三维绘画系统，因为表面在创建时不需要明确的纹理坐标，并且八叉树可以将纹理细节保存到所需的任何级别。Lefebvre等人讨论了在现代GPU上实现八叉树纹理的细节。Lefebvre和Hoppe讨论了一种将稀疏的体积数据打包到一个明显更小的纹理中的方法。</strong></p>
<h3 id="Cube-Maps-立方体映射"><a href="#Cube-Maps-立方体映射" class="headerlink" title="Cube Maps 立方体映射"></a>Cube Maps 立方体映射</h3><p><strong>另一种类型的纹理是立方体纹理或立方体贴图，它有6个正方形纹理，每一个都与立方体的一个面相关联。一个立方体地图是通过一个三分量的纹理坐标向量来访问的，它指定了从立方体中心向外的射线方向。射线与立方体的交点如下所示。最大的纹理坐标选择相应的面(例如，向量(−3.2,5.1，−8.4)选择−z面)。其余两个坐标除以最大幅值坐标的绝对值，即8.4。它们现在的范围从−1到1，并简单地重新映射到[0,1]以计算纹理坐标。例如,坐标(−3.2,5.1)映射到((−3.2/8.4 + 1)/ 2,(5.1/8.4 + 1)/ 2)≈(0.31,0.80)。立方体映射对于表示方向函数的值是有用的;它们最常用于环境映射(章节10.4.3)。</strong></p>
<h3 id="Texture-Representation-纹理表示"><a href="#Texture-Representation-纹理表示" class="headerlink" title="Texture Representation 纹理表示"></a>Texture Representation 纹理表示</h3><p><strong>在应用程序中处理许多纹理时，有几种方法可以提高性能。纹理压缩在第6.2.6节中进行了描述，而本节的重点是纹理图集、纹理数组和无绑定纹理，所有这些都旨在避免在渲染时更改纹理的成本。在19.10.1和19.10.2节中，描述了纹理流和转码。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920220049.png" class="" title="image-20210920220049">

<p>左:一个纹理图集，其中九个较小的图像被合成成一个单一的大纹理。右图:更现代的方法是将较小的图像设置为纹理数组，这是在大多数API中发现的概念。</p>
<p><strong>为了能够为GPU批量处理尽可能多的工作，通常最好是尽可能少地改变状态(章节18.4.2)。为此，可以将几张图像放入一个更大的纹理中，称为纹理图集。这在上图的左边进行了说明。注意，子纹理的形状可以是任意的。子纹理布局图集的优化由N¨oll和Stricker描述。还需要注意mipmap的生成和访问，因为mipmap的上层可能包含几个独立的、不相关的形状。Manson和Schaefer提出了一种优化mipmap创建的方法，该方法考虑了表面的参数化，可以产生明显更好的结果。Burley和Lacewell提出了一个名为Ptex的系统，在这个系统中，细分表面上的每个四元组都有自己的小纹理。这样做的好处是避免了在网格上分配独特的纹理坐标，并且在纹理图集的断开部分的接缝上没有工件。为了能够过滤四元组，Ptex使用邻接数据结构。虽然最初的目标是生产渲染，Hillesland提出了包装的Ptex，它将每个人脸的子纹理放入纹理图集，并使用相邻人脸的填充来避免过滤时的间接。Yuksel提出了网格颜色纹理，改进了Ptex。Toth为ptex类系统提供高质量的面部过滤，通过实现一种方法，如果过滤超出[0,1]²的范围就会被丢弃。</strong></p>
<p><strong>使用图集的一个困难是包裹/重复和镜像模式，这将不会正确地影响子纹理，而只是作为一个整体的纹理。在为图集生成mipmaps时可能会出现另一个问题，其中一个子纹理可能会相互渗透。然而，可以通过为每个子纹理分别生成mipmap层次结构，然后将它们放入一个大型纹理图集中，并对子纹理使用2次幂分辨率来避免这一问题。</strong></p>
<p><strong>对于这些问题，一个更简单的解决方案是使用一个称为纹理数组的API构造，它完全避免了与mipmapping和重复模式有关的任何问题。如上图的右侧所示。纹理数组中的所有子纹理都需要有相同的尺寸、格式、mipmap层次结构和MSAA设置。像纹理图集一样，纹理数组的设置只做一次，然后任何数组元素都可以使用着色器中的索引访问。这比绑定每个子纹理快5倍。</strong></p>
<p><strong>API支持无绑定纹理也是一个有助于避免状态更改成本的特性。如果没有绑定纹理，则使用API将纹理绑定到特定的纹理单元。一个问题是纹理单元的上限，这使程序员的工作变得复杂。驱动程序确保纹理驻留在GPU一侧。对于无绑定纹理，没有纹理数量的上限，因为每个纹理仅通过64位指针(有时称为句柄)关联到其数据结构。这些句柄可以通过许多不同的方式访问，例如，通过制服，通过不同的数据，从其他纹理，或从一个着色器存储缓冲对象(SSBO)。应用程序需要确保纹理驻留在GPU一侧。无绑定纹理避免了驱动程序中任何类型的绑定成本，这使得渲染速度更快。</strong></p>
<h3 id="Texture-Compression-纹理压缩"><a href="#Texture-Compression-纹理压缩" class="headerlink" title="Texture Compression 纹理压缩"></a>Texture Compression 纹理压缩</h3><p><strong>一种直接解决内存、带宽和缓存问题的解决方案是固定速率的纹理压缩。通过让GPU快速解码压缩纹理，纹理可以占用更少的纹理内存，从而增加有效缓存的大小。至少同样重要的是，这样的纹理使用起来更有效，因为它们在访问时消耗的内存带宽更少。一个相关但不同的用例是添加压缩以提供更大的纹理。例如，在5122分辨率下，使用每像素3字节的非压缩纹理将占用768 kB。使用压缩比为6:1的纹理压缩，10242个纹理只占用512kb。</strong></p>
<p><strong>图像文件格式(如JPEG和PNG)中使用了多种图像压缩方法，但在硬件中实现这些方法的解码代价很高(关于纹理转码的信息，请参见19.10.1节)。S3开发了一个名为S3纹理压缩(S3TC)的方案，被选为DirectX的标准，称为DXTC，在DirectX 10中称为BC(块压缩)。此外，它是OpenGL上的标准，因为几乎所有的GPU都支持它。它的优点是创建大小固定的压缩图像，具有独立的编码片段，而且解码简单(因此也快速)。图像的每个压缩部分都可以独立于其他部分进行处理。没有共享的查询表或其他依赖项，这简化了解码。</strong></p>
<p><strong>DXTC/BC压缩方案有7种变体，它们有一些共同的属性。编码是在4 × 4像素块上完成的，也称为tiles。每个块被单独编码。编码是基于插值的。对于每个编码量，存储两个参考值(例如，颜色)。一个插值因子被保存为每个16像素块。它沿着两个参考值之间的线选择一个值，例如，等于或从存储的两个值中插入一个颜色。这种压缩来自于只存储两种颜色以及每个像素的短索引值。</strong></p>
<p><strong>这七个变量之间的确切编码是不同的，下表对其进行了总结。注意，“DXT”表示DirectX 9中的名称，“BC”表示DirectX 10及以上的名称。从表中可以看出，BC1有两个16位参考RGB值(5位红色，6位绿色，5位蓝色)，每个texel有一个2位插值因子从一个参考值或两个中间值中选择。这表示纹理压缩比为6:1，与未压缩的24位RGB纹理相比。BC2以与BC1相同的方式编码颜色，但为量化(原始)alpha增加了每像素4位(bpt)。对于BC3，每个块都有与DXT1块相同的方式编码的RGB数据。此外，alpha数据使用两个8位参考值和一个每像素3位插值因子进行编码。每个texel可以选择一个参考alpha值或六个中间值中的一个。BC4只有一个通道，在BC3中被编码为alpha。BC5包含两个通道，每个通道按照BC3中的编码方式进行编码。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920221009.png" class="" title="image-20210920221009">

<p>纹理压缩格式。所有这些压缩块都是4 × 4像素。存储列显示每个块的字节数(B)和每个texel的比特数(bpt)。参考颜色的表示法首先是通道，然后是每个通道的位数。例如，RGB565表示红色和蓝色为5位，绿色通道为6位。</p>
<p><strong>BC6H适用于高动态范围(HDR)纹理，其中每个像素最初有每个R, G和B通道的16位浮点值。这种模式使用16字节，结果是8个bpt。它对一行有一种模式(类似于上面的技术)，对两行有另一种模式，其中每个块可以从一组小的分区中进行选择。两种参考颜色也可以进行增量编码以获得更好的精度，并且根据使用的模式也可以具有不同的精度。在BC7中，每个块可以有1到3行，并存储8个bpt。目标是8位RGB和RGBA纹理的高质量纹理压缩。它与BC6H共享许多属性，但它是LDR纹理的格式，而BC6H是HDR的格式。注意，在OpenGL中，BC6H和BC7分别称为BPTC FLOAT和BPTC。这些压缩技术可以应用于立方体或体积纹理，以及二维纹理。</strong></p>
<p><strong>这些压缩方案的主要缺点是有损。也就是说，通常无法从压缩版本中检索到原始图像。在BC1-BC5的情况下，仅使用4或8个插值值来表示16个像素。如果一个贴图中有更多不同的值，就会有一些损失。在实践中，如果使用得当，这些压缩方案通常能提供可接受的图像保真度。</strong></p>
<p><strong>BC1-BC5的一个问题是，用于块的所有颜色都位于RGB空间的一条直线上。例如，红色、绿色和蓝色不能在单个块中表示。BC6H和BC7支持更多的线路，可以提供更高的质量。</strong></p>
<p><strong>对于OpenGL ES, API中选择了另一种名为Ericsson纹理压缩(ETC)的压缩算法。该方案具有与S3TC相同的特点，即快速解码、随机访问、无间接查找、固定速率。它将一个4 × 4像素的块编码为64位，即每像素使用4位。基本思想如下图所示。每个2 × 4块(或4 × 2，取决于哪种颜色的质量最好)存储一个基本颜色。每个块也从一个小型静态查找表中选择一组4个常量，并且块中的每个texel可以选择在该表中添加一个值。这将修改每个像素的亮度。图像质量与DXTC相当。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920221235.png" class="" title="image-20210920221235">

<p>ETC (Ericsson纹理压缩)编码像素块的颜色，然后修改每个像素的亮度来创建最终的texel颜色。(Jacob Str¨om)</p>
<p><strong>在OpenGL ES 3.0中包含的ETC2中，使用未使用的位组合来为原始ETC算法添加更多模式。未使用的位组合是压缩表示(例如64位)，它解压成与另一个压缩表示相同的图像。例如，在BC1中，将两个参考颜色设置为相同是没有用的，因为这将指示一个恒定色块，而只要有一个参考颜色包含该恒定色块，就可以获得该恒定色块。在ETC中，一种颜色也可以用带符号的数字对第一种颜色进行增量编码，因此计算可能会溢出或溢出。这些病例被用于其他压缩模式的信号。ETC2增加了两种新的模式，每种模式有四种不同的颜色，最后一种模式是RGB空间中的平面，旨在处理平滑过渡。Ericsson alpha压缩(EAC)压缩图像的一个分量(如alpha)。这种压缩类似于基本的ETC压缩，但只针对一个组件，生成的图像每像素存储4位。它可以是选择性的结合ETC2，另外两个EAC通道可以用来压缩法线(下面有更多关于这个主题的内容)。所有的ETC1、ETC2和EAC都是OpenGL 4.0核心配置文件、OpenGL ES 3.0、Vulkan和Metal的一部分。</strong></p>
<p><strong>法线映射的压缩(在第6.7.2节中讨论)需要一些注意。为RGB颜色设计的压缩格式通常不适用于普通的xyz数据。大多数方法都利用了法线是单位长度这一事实，并进一步假设其z分量是正的(对于切空间法线来说这是一个合理的假设)。这只允许存储法线的x和y分量。z分量被推导为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920221936.png" class="" title="image-20210920221936">

<p><strong>这本身会导致适度的压缩，因为只存储两个组件，而不是三个。因为大多数gpu本身不支持三组件纹理，这也避免了浪费一个组件的可能性(或者不得不在第四个组件中打包另一个数量)。进一步的压缩通常是通过将x和y分量存储在BC5/3Dc-格式纹理中来实现的。参见下图。由于每个块的参考值划分了x分量和y分量的最大值和最小值，因此可以将它们视为在xy平面上定义了一个边界框。三位插值因子允许在每个轴上选择8个值，因此包围框被划分为8 × 8的可能的法线网格。另外，可以使用两个EAC通道(用于x和y)，然后按照上面的定义计算z。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920222041.png" class="" title="image-20210920222041">

<p>左:球上的单位法线只需要编码x和y分量。右图:对于BC4/3Dc, xy平面上有一个方框，里面有8 × 8条法线可以用来表示4 × 4块法线(为了清晰起见，这里只显示4 × 4条法线)。</p>
<p><strong>在不支持BC5/3Dc或EAC格式的硬件上，一种常见的方法是使用 DXT5格式纹理并将这两个组件存储在绿色和alpha组件中(因为它们存储的精度最高)。其他两个组件未使用。</strong></p>
<p><strong>PVRTC是一种名为PowerVR的纹理压缩格式，可在Imagination Technolo- gies的硬件上使用，它最广泛的应用是在iphone和ipad上。它提供了2位和4位每像素的方案，并压缩4 × 4像素的块。该方法的核心思想是提供图像的两个低频(平滑)信号，这些信号由相邻的texel数据块和插值得到。然后1或2位每像素使用插值之间的两个信号的图像。</strong></p>
<p><strong>自适应可伸缩纹理压缩(Adaptive scalable texture compression, ASTC)的不同之处在于它将一个n × m像素的块压缩为128位。块大小范围从4 × 4到12 × 12，这导致了不同的比特率，从0.89比特每像素到8比特每像素。ASTC使用了许多紧凑索引表示的技巧，可以为每个块选择行数和端点编码。此外，ASTC可以处理每个纹理的1-4个通道以及LDR和HDR纹理。ASTC是OpenGL ES 3.2及更高版本的一部分。</strong></p>
<p><strong>以上提出的所有纹理压缩方案都是有损的，当压缩一个纹理时，可以在这个过程中花费不同的时间。在压缩上花费几秒钟甚至几分钟，你就可以获得更高的质量;因此，这通常是作为脱机预处理完成的，并被存储起来供以后使用。或者，你可以只花几毫秒的时间，结果是质量较低，但纹理可以接近实时压缩并立即使用。一个例子是天空盒(第13.3节)，当云可能轻微移动时，它大约每隔一秒再生一次。解压缩非常快，因为它是使用固定功能的硬件完成的。这种差异被称为数据压缩不对称，在这种情况下，压缩可能并且确实要比解压缩花费相当长的时间。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920230355.png" class="" title="image-20210920230355">

<p>纹理压缩时每个组件使用16位而不是8位的效果。从左到右:原始纹理，DXT1从每个组件8位压缩，DXT1从每个组件16位压缩，并在着色器中完成重正化。为了更清楚地显示效果，纹理被渲染为强光照。(图片由Anton Kaplanyan提供。)</p>
<p><strong>Kaplanyan提出了几种可以提高压缩纹理质量的方法。对于包含颜色和法线贴图的纹理，建议每个组件使用16位绘制贴图。对于颜色纹理，然后执行一个直方图重正化(对这些16位)，其效果随后在着色器中使用一个比例和偏差常数(每个纹理)。直方图归一化是一种将图像中使用的值扩展到整个范围的技术，这是一种有效的对比度增强。每个组件使用16位确保在重正化后直方图中没有未使用的槽，这减少了许多纹理压缩方案可能引入的带伪。如上图所示。此外，Kaplanyan建议，如果75%的像素高于116/255，则使用线性颜色空间纹理，否则将纹理存储在sRGB中。对于法线映射，他还注意到BC5/3Dc通常会独立于y压缩x，这意味着并不总是能找到最好的法线。相反，他建议使用以下误差度量法:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920230457.png" class="" title="image-20210920230457">

<p><strong>n是原始法线，nc 是相同的正常压缩，然后解压缩。</strong></p>
<p><strong>需要注意的是，也可以压缩不同颜色空间中的纹理，这可以用来加速纹理压缩。常用的变换是RGB→YCoCg :</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920230543.png" class="" title="image-20210920230543">

<p><strong>Y是亮度项，Co 和Cg 是色度的条款。逆变换也很简单:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920230556.png" class="" title="image-20210920230556">

<p><strong>也就是增加了一些。这两个变换是线性的，从公式是矩阵向量乘法可以看出，其本身也是线性的。这一点很重要，因为它可以存储YCoCg而不是RGB;纹理硬件仍然可以在YCoCg空间中执行过滤，然后像素着色器可以根据需要转换回RGB。需要注意的是，这个变换本身是有损的，这可能有也可能没有关系。</strong></p>
<p><strong>还有一种可逆的RGB→YCoCg变换，总结为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920230751.png" class="" title="image-20210920230751">

<p><strong>这意味着它可以在24位RGB颜色和相应的YCoCg表示之间来回转换任何损失。应该注意的是，如果RGB中的每个分量都有n位，那么Co 和Cg 每个有n + 1位来保证一个可逆的变换;Y只需要n位。Van Waveren和Casta ~ no使用有损YCoCg变换在CPU或GPU上实现对DXT5/BC3的快速压缩。他们将Y存储在alpha通道中(因为它具有最高的精确度)，而Co 和Cg 存储在RGB的前两个组件中。由于Y是分开存储和压缩的，所以压缩速度很快。对于Co——和Cg-组件时，他们找到一个二维边界框，并选择产生最佳结果的对角线框。注意，对于在CPU上动态创建的纹理，最好也压缩CPU上的纹理。当纹理通过GPU渲染创建时，通常最好也压缩GPU上的纹理。图像压缩通常使用YCoCg变换和其他亮度-色度变换，其中色度分量平均超过2 × 2像素。这减少了50%的存储空间，并且通常工作得很好，因为色度往往变化得很慢。Lee-Steere和Harmon[1015]进一步将其转换为色调-饱和度值(HSV)，在x和y上将色调和饱和度降低4倍，并将值存储为单个通道DXT1纹理。Van Waveren和Casta ~ no也描述了法线映射的快速压缩方法。</strong></p>
<p><strong>Griffin和Olano的一项研究表明，当将几种纹理应用到带有复杂着色模型的几何模型时，纹理的质量往往很低，没有任何可感知的差异。因此，根据用例，降低质量是可以接受的。Fauconneau[463]提出了DirectX 11纹理压缩格式的SIMD实现。</strong></p>
<h2 id="Procedural-Texturing-程序化纹理"><a href="#Procedural-Texturing-程序化纹理" class="headerlink" title="Procedural Texturing 程序化纹理"></a>Procedural Texturing 程序化纹理</h2><p><strong>给定一个纹理空间位置，执行图像查找是生成纹理值的一种方法。另一种方法是计算一个函数，从而定义一个过程纹理。</strong></p>
<p><strong>虽然过程纹理通常用于离线渲染应用程序，但图像纹理在实时渲染中更为常见。这是由于现代GPU中图像纹理硬件的极高效率，它可以在一秒钟内执行数十亿次纹理访问。然而，GPU架构正在朝着更便宜的计算和(相对)更昂贵的内存访问的方向发展。这些趋势使得过程纹理在实时应用程序中得到了更大的应用。</strong></p>
<p><strong>由于体积图像纹理的高存储成本，体积纹理是一个特别有吸引力的程序纹理应用程序。这种纹理可以用各种技术合成。最常见的一种方法是使用一个或多个噪声函数生成值。参见下图。噪声函数通常按连续的两个频率的幂进行采样，称为八度。每个音阶都有一个权重，通常随着频率的增加而下降，这些权重样本的总和称为湍流函数。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210920231027.png" class="" title="image-20210920231027">

<p>两个使用体积纹理的实时过程纹理的例子。左边的大理石是一个半透明的体纹理，使用光线行进渲染。在右侧，物体是一个合成图像，由一个复杂的程序木着色器生成，并在真实世界的环境上合成。(左图来自shadertoy“Playing marble”，由St´ephane Guillitte提供。右图由Autodesk, Inc. Nicolas Savva提供)</p>
<p><strong>由于估计噪声函数的代价，三维阵列中的晶格点通常是预先计算的，并用于插值纹理值。有各种方法可以使用颜色缓冲混合来快速生成这些数组。Perlin提出了一种快速、实用的噪声函数采样方法，并展示了一些用途。Olano提供了噪声生成算法，允许在存储纹理和执行计算之间进行权衡。McEwan等人开发了在着色器中计算经典噪声和单纯噪声的方法，无需任何查找，源代码可用。Parberry使用动态规划将计算摊销到几个像素上，以加速噪声计算。Green给出了一种更高质量的方法，但这种方法更适合于接近交互的应用程序，因为它使用50像素的着色器指令进行一次查找。可以对Perlin提出的原始噪声函数进行改进。Cook和DeRose提出了一种称为小波噪声的替代表示，它避免了走样问题，但只增加了很小的评估成本。Liu等人使用各种噪声函数来模拟不同的木材纹理和表面处理。我们也推荐Lagae等人关于这个主题的最新报告。</strong></p>
<p><strong>其他程序性方法也是可能的。例如，细胞纹理是通过测量从每个位置到一组分散在空间中的“特征点”的距离而形成的。用不同的方法映射产生的最近距离，例如，改变颜色或着色法线，创建看起来像细胞、石板、蜥蜴皮肤和其他自然纹理的模式。Griffiths讨论了如何在GPU上高效地找到最近的邻居并生成细胞纹理。</strong></p>
<p><strong>另一种类型的程序纹理是物理模拟或其他交互过程的结果，如水波纹或扩展裂缝。在这种情况下，程序纹理可以在动态条件下产生有效的无限可变性。</strong></p>
<p><strong>在生成过程二维纹理时，参数化问题可能会比创作纹理更困难，在创作纹理时，拉伸或接缝工件可以手工润色或处理。一个解决方案是通过在表面上直接合成纹理来完全避免参数化。在复杂的表面上执行这种操作在技术上是具有挑战性的，也是一个活跃的研究领域。见Wei等人对这一领域的概述。</strong></p>
<p><strong>抗锯齿程序纹理比抗锯齿图像纹理既困难又容易。一方面，像mipmapping这样的预计算方法是不可用的，这给程序员带来了负担。另一方面，程序纹理作者拥有关于纹理内容的“内部信息”，因此可以调整它以避免走样。这对于通过叠加多个噪声函数创建的程序纹理来说尤其正确。每个噪声函数的频率都是已知的，因此任何可能导致走样的频率都可以被丢弃，实际上降低了计算成本。对于其他类型的程序纹理有各种各样的抗锯齿技术。Dorn等人讨论了以前的工作，并提出了一些重新构造纹理函数以避免高频的过程，即限制波段。</strong></p>
<h2 id="Texture-Animation-纹理动画"><a href="#Texture-Animation-纹理动画" class="headerlink" title="Texture Animation 纹理动画"></a>Texture Animation 纹理动画</h2><p><strong>应用于表面的图像不一定是静态的。例如，视频源可以用作帧与帧之间变化的纹理。</strong></p>
<p><strong>纹理坐标也不需要是静态的。应用程序设计者可以从一帧到另一帧明确地改变纹理坐标，无论是在网格数据本身，还是通过应用在顶点或像素着色器中的函数。想象一个瀑布已经被建模，并且它已经被纹理图像看起来像瀑布。假设v坐标是流动的方向。要使水移动，必须从每一帧的v坐标中减去一个量。从纹理坐标中减去纹理会使纹理本身看起来向前移动。</strong></p>
<p><strong>更精细的效果可以通过对纹理坐标应用一个矩阵来创建。除了平移，它还支持线性变换，如缩放、旋转和剪切、图像扭曲和变形变换和广义投影。许多更复杂的效果可以通过在CPU或着色器中应用函数来创建。</strong></p>
<p><strong>通过使用纹理混合技术，可以实现其他动画效果。例如，从大理石纹理开始，然后淡入皮肤纹理，就可以让雕像活过来。</strong></p>
<h2 id="Material-Mapping-材质贴图"><a href="#Material-Mapping-材质贴图" class="headerlink" title="Material Mapping 材质贴图"></a>Material Mapping 材质贴图</h2><p><strong>纹理的一个常见用法是修改材质属性，影响材质的着色方程。现实世界中的物体通常在其表面上具有不同的物质属性。为了模拟这样的物体，像素着色器可以从纹理中读取值，并在评估着色方程之前使用它们来修改材质参数。最常被纹理修改的参数是表面颜色。这种纹理被称为反照率色贴图或漫反射色贴图。然而，任何参数都可以被纹理修改:替换它，乘它，或者以其他方式改变它。例如，在下图中，三个不同的纹理被应用到一个表面，替换常量值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210922105629.png" class="" title="image-20210922105629">

<p>金属砖和灰泥。在右边是表面颜色的纹理，粗糙度(越轻越粗糙)，和凹凸贴图高度(越轻越高)。(来自three.js示例webgl tonemapping。)</p>
<p><strong>材质中纹理的使用可以更进一步。与修改等式中的参数不同，纹理可以用来控制像素着色器本身的流和功能。两个或更多的材质与不同的着色方程和参数可以应用到一个表面，通过一个纹理指定表面的哪些区域有哪些材质，导致不同的代码被执行。例如，带有一些生锈区域的金属表面可以使用纹理来指示生锈的位置，有条件地执行基于纹理查找的着色器生锈部分，或者执行闪亮的金属着色器(章节9.5.2)。</strong></p>
<p><strong>材质模型输入，如表面颜色，与材质输出的最终颜色有线性关系。因此，包含这些输入的纹理可以用标准技术过滤，并避免走样。包含非线性着色输入的纹理，如粗糙度或凹凸贴图(章节6.7)，需要更多的注意以避免走样。考虑到着色方程的过滤技术可以改善这种纹理的结果。这些技术将在9.13节中讨论。</strong></p>
<h2 id="Alpha-Mapping-Alpha贴图"><a href="#Alpha-Mapping-Alpha贴图" class="headerlink" title="Alpha Mapping Alpha贴图"></a>Alpha Mapping Alpha贴图</h2><p><strong>alpha值可以用于使用alpha混合或alpha测试的许多效果，如有效渲染树叶、爆炸和远处的物体，等等。本节讨论alpha纹理的使用，注意各种限制和解决方案。</strong></p>
<p><strong>一种与纹理相关的效果是贴花。例如，你想在茶壶上放一幅花的图片。你想要的不是整个画面，而是花存在的部分。通过给texel赋0的alpha值，你使它透明，所以它没有效果。因此，通过正确设置贴花纹理的alpha，你可以用贴花替换或混合底层表面。典型地，对应功能是使用一个透明的边界应用一个贴花的单一副本(相对于重复纹理)的表面。下图显示了如何实现贴花的示例。有关贴花的更多信息，请参阅第20.2节。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923132202.png" class="" title="image-20210923132202">

<p>一种实现贴花的方法。帧缓冲区首先用场景渲染，然后渲染一个框，对于框内的所有点，贴花纹理被投影到帧缓冲区中。最左边的texel是完全透明的，所以它不会影响帧缓冲区。黄色texel是不可见的，因为它会被投射到表面的隐藏部分。</p>
<p><strong>alpha的一个类似应用是在切割中。假设你制作了一个灌木的贴花图像，并将其应用到场景中的矩形上。原理与贴花相同，除了灌木将被绘制在它后面的任何几何图形的顶部，而不是与一个潜在的表面齐平。通过这种方式，使用单个矩形可以渲染一个具有复杂轮廓的对象。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923132629.png" class="" title="image-20210923132629">

<p>在左边，灌木纹理贴图和它下面的1位alpha通道贴图。在右边，灌木被渲染成一个矩形;通过添加第二个旋转90度的矩形副本，我们形成了一个简易的三维灌木。</p>
<p><strong>在灌木的情况下，如果你旋转观察者围绕它，效果不好，因为灌木没有厚度。一个解决方法是复制这个灌木矩形并沿着树干旋转90度。这两个矩形形成了一种简易的三维灌木，有时被称为“十字树”，从地面上看，这种效果相当有效。参见上图。Pelzer讨论了一个类似的配置，使用三个切口来代表草。在第13.6节中，我们将讨论一个名为billboarding的方法，该方法用于将这种渲染减少为一个矩形。如果观察者移动到地面以上，这种错觉就会消失，因为从上面可以看到灌木两个图样。参见下图。为了解决这个问题，可以以不同的方式添加更多的切割——切片、分支、层——以提供更有说服力的模型。第13.6.5节讨论了生成此类模型的一种方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923132806.png" class="" title="image-20210923132806">

<p>从离地面稍远的地方看“交叉树”灌木，然后再往上看，错觉就消失了。</p>
<p><strong>结合alpha贴图和纹理动画可以产生令人信服的特殊效果，如闪烁的火炬、植物生长、爆炸和大气效果。</strong></p>
<p><strong>用alpha地图渲染对象有几个选项。Alpha混合(章节5.5)允许部分透明度值，这使物体边缘和部分透明物体的抗锯齿。然而，alpha混合需要在不透明的三角形之后渲染混合的三角形，并且按照前后顺序。一个简单的交叉树是两个裁剪纹理的例子，其中没有正确的渲染顺序，因为每个四边形都在另一个四边形的前面。即使理论上可以进行排序并得到正确的顺序，但这样做通常效率很低。例如，一块土地可能有数以万计的草叶图样。每个网格对象可能由许多单独的叶片组成。显式地对每个叶片进行排序是非常不切实际的。</strong></p>
<p><strong>这个问题可以在渲染时通过几种不同的方法来改善。一种方法是使用alpha测试，即在像素着色器中有条件地丢弃alpha值低于给定阈值的片段。这是这样做的</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923133054.png" class="" title="image-20210923133054">

<p><strong>texture.a是纹理查找中的alpha值，参数alphaThreshold是用户提供的阈值，决定哪些片段将被丢弃。这个二进制可见性测试允许以任何顺序渲染三角形，因为透明的片段会被丢弃。我们通常希望对alpha为0.0的任何片段进行此操作。丢弃完全透明的片段有额外的好处，可以节省进一步的着色器处理和合并成本，并避免在z-buffer中错误地标记像素为可见的。对于切割，我们经常设置阈值高于0.0，比如，0.5或更高，然后采取进一步的步骤，然后完全忽略alpha值，不使用它来混合。这样做可以避免无序的工件。然而，质量很低，因为只有两种透明度(完全不透明和完全透明)可用。另一种解决方案是对每个模型执行两道工序——一道工序用于实心切割，它被写入z缓冲区，另一道工序用于半透明样品，它不被写入z缓冲区。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923133332.png" class="" title="image-20210923133332">

<p>上图:没有任何修正的mipmapping的alpha测试。下图:alpha测试，根据覆盖率调整alpha值。(图片来自“The Witness”，伊格纳西奥·卡斯塔。)</p>
<p><strong>alpha测试还有另外两个问题，即过度放大和过度缩小。当alpha测试与mipmapping一起使用时，如果不进行不同的处理，其效果可能无法令人信服。上图的顶部显示了一个示例，其中树的叶子变得比预期的更透明。这可以用一个例子来解释。假设我们有一个一维纹理，有四个alpha值，即(0.0,1.0,1.0,0.0)。通过平均，下一个mipmap级别变成(0.5,0.5)，然后顶层是(0.5)。现在，假设我们用αt = 0.75。当访问0级mipmap时，可以显示4个像素中的1.5像素将通过丢弃测试。然而，当访问下两个级别时，将丢弃自0.5 &lt; 0.75以来的所有内容。另一个示例请参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923133526.png" class="" title="image-20210923133526">

<p>顶部是叶子模式混合的不同mipmap级别，更高的级别缩放以提高能见度。在底部的mipmap显示它将被处理的alpha测试0.5，显示对象如何有更少的像素，因为它后退。(图片由Ben Golus提供。)</p>
<p><strong>Casta~no提供了一个在mipmap创建过程中完成的简单解决方案，该方案运行良好。对于mipmap级别k，覆盖范围ck 被定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923133648.png" class="" title="image-20210923133648">

<p><strong>其中nk 是mipmap级别k的像素数，α(k, i)是mipmap级别k在像素i处的alpha值，αt 为用户提供的alpha阈值。在这里，我们假设α(k, i) &gt; αt的结果为1，否则为0。注意，k = 0表示最低的mipmap级别，即原始图像。对于每个mipmap级别，我们找到一个新的mipmap阈值αk，而不是使用αt，例如:ck 等于c0 (或尽可能接近)。这可以使用二进制文件来完成搜索。最后，将mipmap level k中所有像素的alpha值按αt/αk比例缩放．这个方法在mipmapping的alpha测试图的底部部分使用过，在NVIDIA的纹理工具中也支持这种方法。Golus给出了一个变体，其中mipmap没有被修改，而是alpha在着色器中随着mipmap级别的增加而缩放。</strong></p>
<p><strong>Wyman和McGuire提出了一个不同的解决方案，其中之前那行代码在理论上被替换为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923134219.png" class="" title="image-20210923134219">

<p><strong>这个随机函数返回一个在[0,1]中的统一值，这意味着平均而言它将得到正确的结果。例如，如果纹理查找的alpha值是0.3，碎片将有30%的几率被丢弃。这是每像素只有一个样本的随机透明形式。在实际应用中，用哈希函数代替随机函数，以避免时空高频噪声:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923134230.png" class="" title="image-20210923134230">

<p><strong>三维哈希是通过对上述函数的嵌套调用形成的，即float hash3D(x,y,z) {return hash2D(hash2D(x,y)，z);}，它返回[0,1)中的一个数字。哈希的输入是对象空间坐标除以对象空间坐标的最大屏幕空间导数(x和y)，然后是clamp。为了获得z方向运动的稳定性，需要进一步的关注，该方法最好与时间抗锯齿技术相结合。这种技术会随着距离的增加而逐渐减弱，所以当我们靠近时，我们根本不会得到任何随机效应。该方法的优点是平均每个片段都是正确的，而Casta ~ no的方法只创建一个αk 对于每个mipmap级别。然而，这个值可能在每个mipmap级别上都不同，这可能会降低质量，并需要艺术家的干预。</strong></p>
<p><strong>Alpha测试显示放大后的纹波伪象，这可以通过预先计算Alpha图作为距离域来避免。</strong></p>
<p><strong>Alpha到覆盖，和类似的特性透明度自适应抗锯齿，取片段的透明度值，并将其转换为一个像素内覆盖的样本数量。这个想法就像5.5节中描述的screen-door透明度，但是是亚像素级的。假设每个像素有4个样本位置，一个片段覆盖了一个像素，但是由于裁剪纹理，它是25%透明(75%不透明)的。alpha到覆盖模式使碎片变得完全不透明，但它只覆盖四个样本中的三个。这个模式对于纹理重叠的草叶是有用的。由于绘制的每个样本都是完全不透明的，最近的叶子将沿着其边缘以一致的方式隐藏物体。不需要排序来正确混合半透明边缘像素，因为alpha混合是关闭的。</strong></p>
<p><strong>Alpha到覆盖范围对于抗锯齿Alpha测试是很好的，但是当Alpha混合时可以显示伪影。例如，两个具有相同alpha覆盖百分比的alpha混合片段将使用相同的亚像素模式，这意味着一个片段将完全覆盖另一个片段，而不是与它混合。Golus讨论了使用fwidth()着色器指令给内容一个清晰的边缘。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923134608.png" class="" title="image-20210923134608">

<p>不同的渲染技术的叶子纹理与部分alpha覆盖的边缘。从左到右:alpha test, alpha blend, alpha到coverage, alpha到锐化边缘覆盖。(图片由Ben Golus提供。)</p>
<p><strong>对于alpha映射的任何使用，了解双线性插值如何影响颜色值是很重要的。想象两个相邻的像素:rgbα =(255,0,0,255)是实心红色，它的邻居rgbα =(0,0,0,2)是黑色的，几乎完全透明。在两个像素之间的位置的rgbα值是多少?简单的插值给出(127,0,0,128)，结果rgb值单独是一个“调光”红色。然而，这个结果实际上并没有变暗，它是一个全红色，已经乘以了它的alpha。如果你插入alpha值，为了正确的插补，你需要确保被插补的颜色在插补之前已经被alpha预乘。例如，假设这个几乎透明的邻居被设置为rgba α =(0,255,0,2)，给出一个微小的绿色色调。这个颜色不是预先乘以alpha，当插值时，会给出结果(127,127,0,128)——微小的绿色色调突然将结果变成(预先乘以的)黄色样本。这个邻居texel的预乘版本是(0,2,0,2)，它给出了(127,1,0,128)的正确预乘结果。这个结果更有意义，因为结果的前倍增色大部分是红色，带有难以察觉的绿色色调。</strong></p>
<p><strong>忽略双线性插值的结果给出了一个预乘的结果，可能会导致贴花和裁剪对象周围的黑色边缘。“变暗”的红色结果被管线的其余部分视为未乘以的颜色，边缘变为黑色。即使使用alpha测试，这种效果也是可见的。最好的策略是在双线性插值完成之前预乘。WebGL API支持这一点，因为合成对网页很重要。然而，双线性插值通常是由GPU执行的，在执行此操作之前，着色器不能对texel值进行操作。图像不会在PNG等文件格式中预先相乘，因为这样做会失去色彩精度。当使用alpha映射时，这两个因素会导致默认的黑色边缘。一个常见的解决方法是对裁剪图像进行预处理，将透明的“黑色”像素涂上来自附近不透明像素的颜色。所有透明区域经常需要以这种方式重新绘制，手工或自动绘制，这样mipmap级别也可以避免边缘问题。同样值得注意的是，当使用alpha值形成mipmaps时应该使用预乘的值。</strong></p>
<h2 id="Bump-Mapping-凹凸贴图"><a href="#Bump-Mapping-凹凸贴图" class="headerlink" title="Bump Mapping 凹凸贴图"></a>Bump Mapping 凹凸贴图</h2><p><strong>本节描述了一大类我们统称为凹凸映射的小规模细节表示技术。所有这些方法都是通过修改逐像素着色例程来实现的。它们提供了一个比纹理映射更三维的外观，但没有添加任何额外的几何。</strong></p>
<p><strong>物体的细节可以分为三种尺度:覆盖许多像素的宏观特征，跨越几个像素的中观特征，以及实质上小于一个像素的微观特征。这些类别在某种程度上是流动的，因为在动画或互动过程中，观众可以在许多距离上观察同一物体。</strong></p>
<p><strong>宏观几何学是由顶点和三角形或其他几何原语来表示的。当创建一个三维角色时，四肢和头部通常是在宏观尺度上建模的。微几何被封装在着色模型中，它通常在像素着色器中实现，并使用纹理贴图作为参数。使用的着色模型模拟了表面的微观几何的交互作用，例如，发光的物体在微观上是光滑的，而扩散的表面在微观上是粗糙的。角色的皮肤和衣服似乎有不同的材质，因为它们使用不同的着色器，或者至少在这些着色器中使用不同的参数。</strong></p>
<p><strong>微观几何学描述了这两种尺度之间的一切。它包含的细节过于复杂，无法有效地使用单个三角形进行渲染，但它足够大，足以让观看者在几个像素上区分表面曲率的单个变化。角色脸上的皱纹、肌肉细节、衣服上的褶皱和接缝都是中尺度的。一组被统称为凹凸贴图技术的方法通常用于中尺度建模。这些调整的着色参数在像素水平，这样的方式，观众感觉小远离基本几何的扰动，它实际上保持平坦。不同类型的凹凸贴图之间的主要区别是它们如何表示细节特征。变量包括细节特性的现实性和复杂性。例如，数字艺术家通常会将细节雕刻成模型，然后使用软件将这些几何元素转换成一个或多个纹理，如凹凸纹理或裂隙暗化纹理。</strong></p>
<p><strong>1978年，Blinn提出了在纹理中编码中尺度细节的想法。他观察到，如果在着色过程中，我们用一个轻微扰动的表面法线代替真实的表面，表面似乎有小规模的细节。他将描述表面法线扰动的数据存储在阵列中。</strong></p>
<p><strong>关键的想法是，我们使用纹理来修改表面法线，而不是使用纹理来改变光照方程中的颜色成分。表面的几何法线保持不变;我们只是修改了正常使用的渲染方程。这种操作没有物理上的对等物;我们在表面法线上执行改变，但表面本身在几何意义上保持平滑。就像每个顶点的法线会给人一种表面在三角形之间是平滑的错觉一样，修改每个像素的法线会改变对三角形表面本身的感知，而不会修改它的几何形状。</strong></p>
<p><strong>对于凹凸贴图，法线必须改变方向相对于一些参考系。为此，一个切坐标系，也称为切空间基，存储在每个顶点上。这个参考系用于将光线转换到表面位置的空间(或者反之)，以计算扰乱法线的效果。对于一个具有法线映射的多边形表面，除了顶点法线外，我们还存储了所谓的切线和双切线向量。双切线向量也被错误地称为副法向量。</strong></p>
<p><strong>切线和双切线向量表示物体空间中法线贴图本身的轴，因为目标是转换光线，使其相对于贴图。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923140224.png" class="" title="image-20210923140224">

<p>一个球面三角形显示，其切线框架显示在每个角。像球体和环面这样的形状有一个自然的切线空间基础，就像环面上的经纬度线所显示的那样。</p>
<p><strong>这三个向量，法向量n，切向量t，和双切线b，构成一个基矩阵:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923140316.png" class="" title="image-20210923140316">

<p><strong>这个矩阵，有时缩写为TBN，将光的方向(对于给定的顶点)从世界空间转换到切线空间。这些向量不需要相互垂直，因为法线贴图本身可能会被扭曲以适应表面。然而，非正交基引入了纹理的倾斜，这可能意味着需要更多的存储，也可能有性能影响，即矩阵不能用简单的转置求逆。一种节省内存的方法是只存储顶点的切线和双切线，然后用它们的叉乘来计算法线。然而，这种方法只有在惯用手的情况下才有效的矩阵总是相同的。通常一个模型是对称的:一个平面、一个人、一个文件柜和许多其他物体。因为纹理消耗大量内存，所以它们经常被镜像到对称模型上。因此，只存储对象纹理的一侧，但纹理映射将其放置到模型的两侧。在这种情况下，切空间的利手性在两边是不同的，不能被假设。在这种情况下，如果在每个顶点存储一个额外的比特信息来表示左右手方向，仍然有可能避免存储法线。如果设置此位，则使用此位对正切和双切线的叉积求反，以产生正确的法线。如果切线帧是正交的，也可以将基存储为四元数(章节4.3)，这既可以节省更多的空间，也可以节省每像素的一些计算。质量上的小损失是可能的，尽管在实践中很少发生。</strong></p>
<p><strong>切空间的思想对其他算法也很重要。正如在下一章中讨论的，许多着色方程只依赖于表面的法向量。然而，拉丝铝或丝绒等材料也需要知道观察者的相对方向和与表面相比的照明。切线框架对于定义材质在表面上的方向是有用的。Lengyel和Mittring的文章对这一领域进行了广泛的报道。Sch¨uler提出了一种在像素着色器中计算切线空间基础的方法，不需要存储每个顶点预先计算的切线帧。Mikkelsen改进了这一技术，推导出一种不需要任何参数化，而是使用表面位置导数和高度场导数来计算扰动法线的方法。然而，与使用标准的切线空间映射相比，这种技术可能导致显示的细节少得多，而且可能会造成美术工作流程问题。</strong></p>
<h3 id="Blinn’s-Methods-Blinn’s-模型"><a href="#Blinn’s-Methods-Blinn’s-模型" class="headerlink" title="Blinn’s Methods Blinn’s 模型"></a>Blinn’s Methods Blinn’s 模型</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923140746.png" class="" title="image-20210923140746">

<p>在左边，法向量n在u和v方向上被分成(bu，bv )，给出n ‘(未归一化)。在右边，一个高度场和它对着色法线的影响显示。这些法线可以被插值在高度之间，以获得更平滑的外观。</p>
<p><strong>Blinn原来的凹凸映射方法存储两个有符号的值bu 和bv，在纹理的每个texel。这两个值对应于沿u和v图像轴改变法线的量。也就是说，这些纹理值，通常是双线性插值，用于缩放两个垂直于法线的向量。这两个向量相加改变法线方向。两个值bu 和bv 描述曲面在该点的方向。参见上图。这种类型的凹凸贴图纹理被称为偏移矢量凹凸贴图或偏移贴图。</strong></p>
<p><strong>另一种表示凸起的方法是使用高度场来修改表面法线的方向。每个单色纹理值代表一个高度，所以在纹理中，白色是高区域，黑色是低区域(反之亦然)。参见下图中的示例。这是第一次创建或扫描凹凸贴图时使用的一种常见格式，它也是由Blinn在1978年引入的。高度场用于导出与第一种方法中使用的类似的u和v符号值。这是通过计算相邻列之间的差来得到u的斜率，以及v的相邻行之间的斜率来完成的。一种变体是使用Sobel过滤器，它给直接相邻的领域赋予更大的权重。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923140905.png" class="" title="image-20210923140905">

<p>一种波状高度场凹凸图像及其在球体上的使用。</p>
<h3 id="Normal-Mapping-法线贴图"><a href="#Normal-Mapping-法线贴图" class="headerlink" title="Normal Mapping 法线贴图"></a>Normal Mapping 法线贴图</h3><p><strong>凹凸贴图的一个常见方法是直接存储法线贴图。算法和结果与Blinn方法在数学上一致;只有存储格式和像素着色器计算改变。</strong></p>
<p><strong>法线映射编码(x, y, z)映射到[−1,1]，例如，对于一个8位纹理，x轴值0代表−1.0和255代表1.0。下图显示了一个示例。颜色[128,128,255]为浅蓝色，表示所示颜色映射的平面，即一个[0,0,1]的正常值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923141127.png" class="" title="image-20210923141127">

<p>凹凸贴图与法线贴图。每个颜色通道实际上是一个表面的法线坐标。红色通道表示x偏移;红色越多，法线越向右。绿色是y偏移，蓝色是z偏移，右边是使用法线贴图生成的图像。注意立方体顶部的扁平外观。(图片由Manuel M. Oliveira和Fabio Policarpo提供。)</p>
<p><strong>法线贴图最初是作为世界空间法线地图引入的，在实践中很少使用。对于这种类型的映射，干扰是直接的:在每个像素处，从映射和检索法线直接使用它，加上光的方向，来计算表面上那个位置的着色。法线贴图也可以在对象空间中定义，这样模型可以旋转，法线仍然有效。然而，世界空间和对象空间表示都将纹理绑定到特定方向的特定几何图形上，这限制了纹理的重用。</strong></p>
<p><strong>相反，扰动法线通常在切线空间中恢复，即相对于表面本身。这允许表面的变形，以及最大限度地重用正常纹理。切空间法线映射也可以很好地压缩，因为z分量(与未受扰动的表面法线对齐的分量)的符号通常可以假定为正的。</strong></p>
<p><strong>法线映射可以很好地提高真实感，见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923141353.png" class="" title="image-20210923141353">

<p>一个在游戏场景中使用的法线贴图凹凸贴图的例子。左上:两个法线映射到右边没有应用。左下:法线贴图应用。右图:法线贴图。(3D模型和法线贴图由Dulce Isis Segarra L´opez提供。)</p>
<p><strong>与过滤颜色纹理相比，过滤法线贴图是一个困难的问题。一般来说，法线和着色之间的关系不是线性的，所以标准的滤波方法可能会导致令人讨厌的走样。想象一下，看着由闪亮的白色大理石块组成的楼梯。在某些角度，楼梯的顶部或侧面捕捉光线，并反射出明亮的镜面高光。然而，楼梯的平均正常角度是45度;它将从完全不同的方向捕捉亮点，而不是原来的楼梯。当带有高光高光的凹凸贴图在没有正确过滤的情况下渲染时，一个分散的闪光效果可能会发生在高光闪烁的地方，这是由于走样。</strong></p>
<p><strong>Lambertian曲面是一种特殊情况，法线贴图在着色上几乎是线性的。朗伯着色几乎完全是一个点积，这是一个线性运算。对一组法线求平均值并对结果进行点积相当于对单个法线点积求平均值:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923141651.png" class="" title="image-20210923141651">

<p><strong>注意，平均向量在使用前没有被标准化。由上式可知，对于朗伯曲面，标准滤波和mipmaps几乎都能产生正确的结果。因为Lambertian着色方程不是点积，所以结果不是很正确;它是一个夹紧点积：max(l·n, 0)。夹紧操作使其非线性。这将过度暗的表面反光的方向，但在实践中，这通常是不反对的。需要注意的是，一些通常用于法线贴图的纹理压缩方法(例如从其他两个贴图重建z分量)不支持非单位长度的法线，因此使用非标准化法线贴图可能会造成压缩困难。</strong></p>
<p><strong>在非朗伯曲面的情况下，通过将输入作为一组过滤到着色方程中，而不是单独过滤法线映射，可以产生更好的结果。这样做的技术将在第9.13节中讨论。</strong></p>
<p><strong>最后，从高度图h(x, y)推导法线图可能是有用的。如下所示。首先，在x和y方向上的导数的近似值是用中心差值来计算的</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923141944.png" class="" title="image-20210923141944">

<p><strong>则在texel (x, y)处的非标准化法线为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210923141957.png" class="" title="image-20210923141957">

<p><strong>必须注意纹理的边界。</strong></p>
<p><strong>地平线贴图可以用来进一步增强法线贴图，让凹凸点能够将着色投射到它们自己的表面上。这是通过预计算额外的纹理来完成的，每个纹理沿着表面的平面与一个方向相关联，并为每个texel存储在那个方向上的视界角度。有关更多信息，请参阅11.4节。</strong></p>
<h2 id="Parallax-Mapping-视差贴图"><a href="#Parallax-Mapping-视差贴图" class="headerlink" title="Parallax Mapping 视差贴图"></a>Parallax Mapping 视差贴图</h2><p><strong>凹凸贴图和法线贴图的一个问题是，凹凸贴图不会随着视角改变位置，也不会相互遮挡。例如，如果你沿着一堵真正的砖墙，从某个角度看，你不会看到砖块之间的灰泥。一个肿块墙壁的地图将永远不会显示这种类型的遮挡，因为它仅仅是变化的法线。最好让凹凸点实际影响在每个像素上渲染的表面位置。</strong></p>
<p><strong>视差映射的思想由Kaneko在2001年提出，由Welsh对其进行了改进和推广。视差是指物体的位置随着观察者的移动而相对于另一个物体的移动。当观察者移动时，凸起应该有高度。视差贴图的关键思想是，通过检查已发现的可见像素的高度，对一个像素中应该看到什么进行有根据的猜测。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924105412.png" class="" title="image-20210924105412">

<p>左边是目标:从视图向量穿过高度场的位置找到表面上的实际位置。视差映射做了一个一阶近似，取矩形上位置的高度并用它来找到一个新的位置padj．(After Welsh)。</p>
<p><strong>对于视差贴图，凸起被存储在一个高度场纹理中。当在给定像素处查看表面时，高度场值在该位置被检索，并用于移动纹理坐标来检索表面的不同部分。移动的数量是基于检索的高度和眼睛到表面的角度。参见上图。高度场值要么存储在一个单独的纹理中，要么打包在一些其他纹理的未使用的颜色或alpha通道中(打包不相关的纹理时必须小心，因为这会对压缩质量产生负面影响)。在用于移动坐标之前，高度场值被缩放并有偏差。比例尺决定了高度场在地表之上或之下延伸的高度，而偏差给出了“海平面”高度，在这个高度上不会发生移动。给定一个纹理坐标位置p，一个调整后的高度场高度h，和一个高度值为v的标准化视图向量vz 水平分量vxy，新的视差调整纹理坐标padj 是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924105602.png" class="" title="image-20210924105602">

<p><strong>注意，不同于大多数着色方程，这里执行计算的空间很重要——视图向量需要在切线空间中。</strong></p>
<p><strong>虽然这是一个简单的近似，但如果碰撞高度变化相对缓慢，这种移动在实践中工作得相当好。邻近的texels有相同的高度，所以使用原始位置的高度作为估计的想法新地点的高度是合理的。然而，这种方法在浅层视角下是行不通的。当视图向量接近表面的地平线时，一个小的高度变化会导致一个大的纹理坐标移动。这种近似是不适用的，因为新获取的位置与原始地表位置几乎没有高度相关性。</strong></p>
<p><strong>为了改善这个问题，Welsh引入了偏移限制的思想。这样做的目的是限制移动的数量，使其永远不大于取回的高度。方程是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924105737.png" class="" title="image-20210924105737">

<p><strong>注意，这个方程的计算速度比原来的要快。几何上的解释是，高度定义了一个半径，超过这个半径，位置就不能移动。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924105815.png" class="" title="image-20210924105815">

<p>在视差偏移限制中，偏移移动的最多距离原始位置的高度，以虚线圆弧显示。灰色偏移表示原始结果，黑色偏移表示有限结果。右边是用这种技术渲染的一堵墙。(图片由Terry Welsh提供。)</p>
<p><strong>在陡角(面朝上)时，这个方程几乎与原方程相同，因为vz 几乎是1。在浅角度时，偏移的效果会受到限制。从视觉上看，这可以在浅角度上减少凹凸不平，但这比纹理的随机采样要好得多。随着视图的变化，纹理会发生变化，或者在立体渲染中，观察者同时感知到两个视点，必须给出一致的深度提示。即使有这些缺点，带有偏移限制的视差映射只需要花费一些额外的像素着色程序指令，并比基本的法线映射提供了相当大的图像质量改善。Shishkovtsov通过在凹凸贴图法线方向移动估计位置来改善视差遮挡的阴影。</strong></p>
<h3 id="Parallax-Occlusion-Mapping-视差遮挡映射"><a href="#Parallax-Occlusion-Mapping-视差遮挡映射" class="headerlink" title="Parallax Occlusion Mapping 视差遮挡映射"></a>Parallax Occlusion Mapping 视差遮挡映射</h3><p><strong>凹凸贴图不会根据高度场修改纹理坐标;它只在一个位置上改变正常的着色。视差映射提供了高度场效应的一个简单近似，它假定一个像素的高度与其相邻像素的高度大致相同。这种假设可以很快地分解。凸起也不会相互遮挡，也不会投下阴影。我们想要的是在像素处可见的东西。视角向量与高度场相交。</strong></p>
<p><strong>为了更好地解决这个问题，一些研究人员提出使用光线沿着视图向量行进，直到找到一个(近似的)交点。这个工作可以在像素着色器中完成，高度数据可以作为纹理访问。我们把这些方法的研究集中到一个视差映射技术子集中，以这样或那样的方式利用光线行进。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924110149.png" class="" title="image-20210924110149">

<p>绿色的眼球射线投射到平面上，平面以规则的间隔采样(紫点)，并获得高度。该算法求出眼球射线与近似曲线高度场的黑线段的第一个交点。</p>
<p><strong>这些类型的算法被称为视差遮挡映射(POM)或地形映射方法，以及其他名称。其关键思想是首先沿着投影向量测试固定数量的高度场纹理样本。对于掠射角度的视图射线，通常会生成更多的样本，这样就不会错过最近的交点。沿着射线的每个三维位置都被检索，转化为纹理空间，并进行处理，以确定它是高于还是低于高度场。一旦找到高度场以下的样本，则使用高度场以下的样本数量和高度场以上的样本数量来寻找交集位置。参见上图。然后使用附加的法线贴图、颜色贴图和任何其他纹理，使用位置来给表面着色。多层高度场可以用来产生悬垂，独立的重叠表面，和双面浮雕映射的视点替用特效;参见13.7节。高度场追踪方法也可以用来让凹凸不平的表面投射阴影到自身，无论是硬的还是软的。参见下图进行比较。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924110307.png" class="" title="image-20210924110307">

<p>与光线行进(右)相比，没有光线行进(左)的视差映射。当不使用光线行进时，立方体的顶部会被压扁。在光线行进时，也会产生自阴影效果。(图片由Manuel M. Oliveira和Fabio Policarpo提供。)</p>
<p><strong>关于这个话题有大量的文献。虽然所有这些方法都是沿着一条射线前进的，但也有几个不同之处。可以使用简单的纹理来检索高度，但也可以使用更高级的数据结构和更高级的根查找方法。一些技术可能涉及着色器丢弃像素或写入到深度缓冲区，这会影响性能。下面我们总结了大量的方法，但请记住，随着GPU的发展，最好的方法也在发展。这种“最佳”方法取决于内容和在射线行进过程中完成的步数。</strong></p>
<p><strong>确定两个正则样本之间的实际交点的问题是一个寻根问题。在实践中，高度场更多地被视为深度场，矩形平面定义了表面的上限。这样，平面上的起始点就在高度场的上方。在求出高度场表面上的最后一个点和下面的第一个点之后，Tatarchuk使用割线法的单步求出一个近似解。Policarpo等人使用在两个点之间的二分搜索来寻找更近的交叉点。Risser等人使用割线法迭代速度收敛。这样做的代价是，常规采样可以并行进行，而迭代方法需要更少的整体纹理访问，但必须等待结果，并执行较慢的依赖纹理获取。蛮力方法总体上表现很好。</strong></p>
<p><strong>对高度场进行足够频繁的采样是至关重要的。McGuire和McGuire提出对mipmap查找进行偏性，并使用各向异性mipmap来确保对高频高度场(如代表尖峰或头发的高度场)的正确采样。我们也可以用比法线贴图更高的分辨率来存储高程贴图。最后，一些渲染系统甚至不存储法线贴图，而是使用交叉过滤器从高度场动态导出法线。</strong></p>
<p><strong>另一种提高性能和采样精度的方法是，不要在一开始就定期采样高度场，而是尝试跳过中间的空白区域。Donnelly将高度场预处理为一组体素，在每个体素中存储距离高度场表面的距离。在这个通过这种方式，可以快速跳过中间的空间，代价是每个高度场的存储空间更高。Wang等人使用五维位移映射方案来保持从各个方向和位置到表面的距离。这使得复杂曲面、自阴影和其他效果得以实现，但代价是消耗相当大的内存。Mehra和Kumar也出于类似的目的使用方向距离地图。Dummer介绍了圆锥步进映射的思想，polpolo和Oliveira对其进行了改进。这里的概念是为每个高度场位置存储一个锥半径。这个半径定义了射线上与高度场最多有一个交点的区间。这个特性允许沿着射线快速跳过，而不会错过任何可能的交叉，尽管代价是需要依赖结构读取。另一个缺点是创建圆锥步进图需要预先计算，这使得该方法不能用于动态变化的高度场。Schroders和Gulik提出了四叉树地形映射，这是一种在遍历过程中跳过体积的分层方法。Tevs等人使用“最大mipmaps”来允许跳过，同时最小化预计算成本。Drobot也使用了mipmaps中存储的四叉树结构来加快穿越速度，并提出了一种混合不同高度场的方法，其中一种地形类型转换为另一种地形类型。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924110559.png" class="" title="image-20210924110559">

<p>法线测绘和地形测绘。正常映射时不会发生自闭塞。地形映射在重复纹理的轮廓上有问题，因为矩形更多的是对高度场的视图，而不是真正的边界定义。(图片由NVIDIA公司提供。)</p>
<p><strong>上述所有方法的一个问题是，错觉沿着物体的轮廓边缘消失，这将显示出原始表面的光滑轮廓。参见上图。关键的想法是，渲染的三角形定义了像素着色程序应该评估哪些像素，而不是表面实际位于哪里。此外，对于曲面，轮廓的问题变得更加复杂。其中一种方法是由Oliveira和Policarpo描述和开发的，它使用二次轮廓近似技术。Jeschke等人和Dachsbacher等人都给出了一种更普遍、更健壮的方法(并回顾了以前的工作)来正确处理轮廓和曲面。首先由Hirche探索，一般的想法是将网格中的每个三角形向外挤压，形成一个棱镜。渲染这个棱柱力评估所有可能出现高度场的像素。这种类型的方法被称为外壳映射，因为扩展的网格在原始模型上形成一个单独的外壳。当棱镜与光线相交时，通过保持棱镜的非线性特性，可以实现无人工渲染的高度场，尽管计算费用昂贵。下图显示了这种技术的一个令人印象深刻的应用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924110725.png" class="" title="image-20210924110725">

<p>视差闭塞贴图，也称为浮雕贴图，用于路径上，使石头看起来更真实。地面实际上是一组简单的三角形，并应用了高度场。(图片来自Crytek公司的《孤岛危机》)</p>
<h2 id="Textured-Lights-灯光纹理"><a href="#Textured-Lights-灯光纹理" class="headerlink" title="Textured Lights 灯光纹理"></a>Textured Lights 灯光纹理</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210924110847.png" class="" title="image-20210924110847">

<p>投影变形。纹理被投射到茶壶和地平面上，用于调节光线在投影截锥内的贡献(在截锥外它被设置为0)。(图片由英伟达公司提供。)</p>
<p><strong>纹理也可以用来添加视觉丰富的光源，并允许复杂的强度分布或聚光灯功能。对于所有照明限制在一个圆锥体或锥面上的光，投射纹理可以用来调节光的强度。这允许有形状的聚光灯，图案灯，甚至“幻灯机”效果(上图)。这些灯通常被称为戈博灯或饼干灯，以专业剧院和电影照明中使用的剪纸的术语命名。请参阅第7.2节，以类似的方式使用投影映射来投射阴影。</strong></p>
<p><strong>对于不局限于视锥的光线，而是照亮所有方向的光线，立方体贴图可以用来调节强度，而不是二维投影纹理。一维纹理可以用来定义任意距离衰减函数。结合二维角衰减图，这可以考虑复杂的体积照明模式。一种更普遍的可能性是使用三维(体积)纹理来控制光的衰减。这允许任意体积的效应，包括光束。这种技术是内存密集型的(就像所有的卷纹理一样)。如果光的效应体积沿三个轴对称，通过将数据镜像到每个八分仪，内存占用可以减少八倍。</strong></p>
<p><strong>纹理可以添加到任何灯光类型，以实现额外的视觉效果。有纹理的灯光允许艺术家很容易地控制照明，他们可以简单地编辑使用的纹理。</strong></p>
<h1 id="7-Shadows-阴影"><a href="#7-Shadows-阴影" class="headerlink" title="7 Shadows 阴影"></a>7 Shadows 阴影</h1><p><strong>阴影对于创建逼真的图像和为用户提供有关物体放置的视觉线索非常重要。本章重点介绍计算阴影的基本原理，并描述最重要和流行的实时算法。我们还简要讨论了一些不太流行但包含重要原则的方法。我们没有花时间在这一章中涵盖所有的选择和方法，因为有两本全面的书深入研究了阴影领域。相反，我们专注于调查自发表以来出现的文章和报告，偏向于经过实战检验的技术。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925145054.png" class="" title="image-20210925145054">

<p>阴影术语:光源、遮挡器、接收器、阴影、本影和半影。</p>
<p><strong>本章所用的术语如上图所示，occlers（遮挡器）是指在 receivers（接收器）上投射阴影的物体。准时光源，即那些没有面积的区域，只产生完全阴影区域，有时称为硬阴影。如果使用面积或体积光源，然后产生柔和的阴影。每个阴影可以有一个完全阴影区域，称为本影，和一个部分阴影区域，称为半影。通过模糊阴影边缘识别软阴影。然而，需要注意的是，它们通常不能通过低通过滤器模糊硬阴影的边缘来正确渲染。如下图所示，正确的软阴影越靠近接收器，阴影投射的几何形状就越清晰。软阴影的本影区并不等同于由准时光源产生的硬阴影。相反，软阴影的本影区域会随着光源的增大而减小，如果光源足够大，接收器距离遮挡器足够远，它甚至可能会消失。柔和的阴影通常是可取的，因为半影边缘让观众知道阴影确实是阴影。硬边阴影通常看起来不那么真实，有时会被误解为实际的几何特征，如表面的折痕。然而，硬阴影比软阴影渲染更快。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925145417.png" class="" title="image-20210925145417">

<p>硬阴影和软阴影的混合。板条箱的阴影是尖锐的，因为遮挡器靠近接收器。人的阴影是尖锐的接触点，软化的距离，以遮挡增加。远处的树枝投下柔和的阴影。(图片来自育碧的《Tom Clancy’s The Division》。)</p>
<p><strong>比有半影更重要的是有阴影。如果没有一些阴影作为视觉线索，场景往往难以令人信服，更难以感知。正如Wanger所展示的，通常有一个不准确的影子比没有好，因为眼睛对影子的形状是相当宽容的。例如，在地板上使用模糊的黑色圆圈作为纹理，可以将角色固定在地面上。</strong></p>
<p><strong>在接下来的部分中，我们将超越这些简单的模型阴影，并提出从场景中的遮挡器自动实时计算阴影的方法。第一部分处理在平面上投射阴影的特殊情况，第二部分涵盖了更通用的阴影算法，即将阴影投射到任意表面上。硬阴影和软阴影都将被覆盖。最后，提出了一些适用于各种阴影算法的优化技术。</strong></p>
<h2 id="Planar-Shadows-平面阴影"><a href="#Planar-Shadows-平面阴影" class="headerlink" title="Planar Shadows 平面阴影"></a>Planar Shadows 平面阴影</h2><p><strong>当物体在一个平面上投射阴影时，就会发生一个简单的阴影情况。本节将介绍几种平面阴影的算法，每一种算法都在阴影的柔软性和真实感方面有所变化。</strong></p>
<h3 id="Projection-Shadows-投射阴影"><a href="#Projection-Shadows-投射阴影" class="headerlink" title="Projection Shadows 投射阴影"></a>Projection Shadows 投射阴影</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925153347.png" class="" title="image-20210925153347">

<p>左:位于l的光源在平面y = 0上投下阴影。顶点v投影到平面上。投影点称为p。相似三角形用于推导投影矩阵。右图:阴影投射到一个平面上，π: n·x + d = 0。</p>
<p><strong>在这种方案中，三维物体被再次渲染以产生阴影。一个矩阵可以被导出，它将一个物体的顶点投射到一个平面上。考虑上图中的情况下,光源位于l的顶点投影是v,和预计的顶点是p。我们将推导出投影矩阵的特殊情况跟踪平面y = 0,然后这个结果会与任何平面推广工作。</strong></p>
<p><strong>我们从求x坐标的投影开始。从上图左侧的相似三角形中，我们得到</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925153521.png" class="" title="image-20210925153521">

<p><strong>z坐标用同样的方法得到:pz = (lyvz −lzvy) /(ly −vy)，而y坐标为零。现在这些方程可以转化为投影矩阵M:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925153531.png" class="" title="image-20210925153531">

<p><strong>证明Mv = p很简单，这意味着M确实是投影矩阵。</strong></p>
<p><strong>在一般情况下，投射阴影的平面不是y = 0平面，而是π: n·x + d = 0平面。上图的右侧部分描述了这种情况。我们的目标还是要找到一个能将v投影到p的矩阵。为了达到这个目的，从l发出的射线，经过v，与平面π相交。这就得到了投影点p:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925153710.png" class="" title="image-20210925153710">

<p><strong>这个方程也可以转化为一个投影矩阵，如式所示，满足Mv = p:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925153721.png" class="" title="image-20210925153721">

<p><strong>如预期的那样，如果平面为y = 0，即n = (0,1,0) and d = 0，则该矩阵变为之前方程中的矩阵。</strong></p>
<p><strong>要渲染阴影，只需将这个矩阵应用到应该在平面π上投射阴影的对象上，并将这个投影对象渲染为没有照明的深色。在实践中，您必须采取措施，以避免允许投影的三角形被渲染在接收它们的表面之下。一种方法是在我们投射的平面上添加一些偏差，这样阴影三角形总是呈现在表面的前面。</strong></p>
<p><strong>一个更安全的方法是先画出地平面，然后画出带有z缓冲的投影三角形，然后像往常一样渲染其余的几何图形。预计三角形总是画在地平面的顶部，因为没有深度比较。</strong></p>
<p><strong>如果地平面有一个限制，例如，它是一个矩形，投射的阴影可能会落在它的外面，打破错觉。要解决这个问题，我们可以使用模板缓冲区。首先，将接收器绘制到屏幕和模板缓冲区。然后，关闭z缓冲区，只在接收器绘制的地方绘制投影三角形，然后正常渲染场景的其余部分。</strong></p>
<p><strong>另一种阴影算法是将三角形渲染成纹理，然后应用到地面上。这个纹理是一种光贴图，是一种调制底层表面强度的纹理(章节11.5.1)。正如我们所看到的，这种将阴影投影到纹理上的想法也允许在曲面上产生半影和阴影。这种技术的一个缺点是，纹理可能被放大，一个像素覆盖多个像素，破坏了错觉。</strong></p>
<p><strong>如果阴影情况在帧与帧之间没有变化，即光源和阴影投射器不相对移动，这个纹理可以重复使用。如果没有发生变化，大多数阴影技术都可以从帧与帧之间重用中间计算结果中获益。</strong></p>
<p><strong>所有的阴影投射器必须在光和地面接收器之间。如果光源在物体上的最高点以下，则生成反阴影，因为每个顶点都通过光源的点进行投影。正确的阴影和反阴影如下图所示。如果我们投射一个低于接收平面的物体，也会发生错误，因为它也不会投射阴影。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925154036.png" class="" title="image-20210925154036">

<p>在左边，一个正确的阴影被显示出来，而在右边的图形中，一个反阴影出现，因为光源在物体的顶点下面。</p>
<p><strong>当然，可以明确地剔除和修剪阴影三角形，以避免此类伪影。接下来介绍的一种更简单的方法是使用现有的GPU管线执行带有裁剪的投影。</strong></p>
<h3 id="Soft-Shadows-软阴影"><a href="#Soft-Shadows-软阴影" class="headerlink" title="Soft Shadows 软阴影"></a>Soft Shadows 软阴影</h3><p><strong>通过使用各种技术，投影阴影也可以变得柔和。在这里，我们描述了Heckbert和Herf提出的一种产生软阴影的算法。该算法的目标是在地平面上生成一个显示软阴影的纹理。然后我们描述不那么准确、更快的方法。</strong></p>
<p><strong>当光源有一个区域时，就会出现软阴影。一种近似区域光效果的方法是在它的表面使用几个准时的光来取样。对于每一个准时的光源，图像被渲染并累积到一个缓冲器中。这些图像的平均值就是带有软阴影的图像。注意，在理论上，任何生成硬阴影的算法都可以使用这种积累技术来生成半影。在实践中，由于涉及到执行时间，以交互速度执行通常是站不住脚的。</strong></p>
<p><strong>Heckbert和Herf使用基于截点的方法来产生他们的阴影。这个想法是把光当作观察者，地平面形成截锥的远剪切平面。截锥的宽度足以包含咬合器。</strong></p>
<p><strong>软阴影纹理是通过生成一系列地平面纹理而形成的。区域光源在其表面取样，每个位置用于遮蔽代表地平面的图像，然后将投射阴影的物体投射到该图像上。所有这些图像被求和并平均，以产生一个地平面阴影纹理。参见下图的左边的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925154223.png" class="" title="image-20210925154223">

<p>在左边，渲染使用Heckbert和Herf的方法，使用256个通道。右边是海恩斯的方法。用海恩斯的方法，阴影太大了，在门口和窗户周围特别明显。</p>
<p><strong>采样区域光方法的一个问题是，它往往看起来像它本来的样子:几个重叠的阴影来自准时光源。同样，对于n个阴影通道，只能生成n + 1个不同的阴影。大量的通道给出了准确的结果，但代价过高。该方法对于获取(字面上的)“地面真实”图像，以测试其他更快算法的质量是有用的。</strong></p>
<p><strong>一种更有效的方法是使用卷积。即过滤。在某些情况下，模糊从单个点生成的硬阴影就足够了，可以生成半透明的纹理，可以与真实世界的内容合成。参见下图。然而，在物体接触地面的地方，一个统一的模糊可能是不令人信服的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210925154435.png" class="" title="image-20210925154435">

<p>阴影。阴影纹理是通过从上面渲染阴影投射体，然后模糊图像并在地平面上渲染它而生成的。(图片在Autodesk的A360查看器中生成，模型来自Autodesk的Inventor样本。)</p>
<p><strong>有许多其他方法可以提供更好的近似，但需要额外的成本。例如，Haines先投影一个硬阴影，然后用渐变来渲染剪影边缘，从中心的黑暗到边缘的白色，以创建可信的半影。如上上图右侧所示。然而，这些半影在物理上是不正确的，因为它们还应该延伸到轮廓边缘内部的区域。Iwanicki借鉴了球面谐函数的思想，用椭球体来近似遮挡字符，从而给出柔和的阴影。所有这些方法都有不同的近似值和缺点，但比平均一组大的投影图像要有效率得多。</strong></p>
<h2 id="Shadows-on-Curved-Surfaces-曲面阴影"><a href="#Shadows-on-Curved-Surfaces-曲面阴影" class="headerlink" title="Shadows on Curved Surfaces 曲面阴影"></a>Shadows on Curved Surfaces 曲面阴影</h2><p><strong>将平面阴影的概念扩展到曲面的一个简单方法是使用生成的阴影图像作为投影纹理。从光的角度考虑阴影。光明所看见的都被照亮;它看不见的东西就在阴影里。假设遮挡器从光线中呈现为黑色将视点转换为白色纹理。这个纹理可以被投射到表面上，以接收阴影。实际上，接收器上的每个顶点都有一个为其计算的(u, v)纹理坐标，并将纹理应用于它。这些纹理坐标可以由应用程序显式地计算。这与上一节中的地面阴影纹理有些不同，在那里物体被投射到一个特定的物理平面上。在这里，图像是通过光线形成的，就像放映机里的胶片。</strong></p>
<p><strong>当渲染时，投影的阴影纹理修改接收器表面。它也可以与其他阴影方法相结合，有时主要用于帮助感知物体的位置。例如，在一款平台跳跃电子游戏中，主角可能总是会被给予一个直接位于其下方的阴影，即使角色处于完全的阴影中。更精细的算法可以得到更好的结果。例如，Eisemann和D´ecoret假设有一个矩形顶灯，并创建一个物体水平切片的阴影图像堆栈，然后将其转换成mipmaps或类似的图像。每个切片对应的区域通过使用它的mipmap与它到接收者的距离成正比，这意味着越远的切片投射的阴影越柔和。</strong></p>
<p><strong>纹理投影方法存在一些严重的缺陷。首先，应用程序必须识别哪些对象是遮挡对象，哪些对象是它们的接收对象。程序必须保持接收器与光线的距离大于遮挡器，否则阴影将“向后投射”。此外，被遮挡的物体不能使自己阴影。接下来的两部分将介绍在不需要这种干预或限制的情况下生成正确阴影的算法。</strong></p>
<p><strong>注意，通过使用预先构建的投射纹理，可以获得各种照明模式。聚光灯是一个简单的方形投影纹理，内部有一个圆形定义光线。百叶窗效果可以通过由水平线组成的投影纹理来创建。这种类型的纹理被称为光衰减蒙版、cookie纹理或gobo贴图。通过简单地将两个纹理相乘，预先构建的图案可以与动态创建的投影纹理相结合。这种灯将在第6.9节中进一步讨论。</strong></p>
<h2 id="Shadow-Volumes-阴影体积"><a href="#Shadow-Volumes-阴影体积" class="headerlink" title="Shadow Volumes 阴影体积"></a>Shadow Volumes 阴影体积</h2><p><strong>Heidmann在1991年提出了一种基于Crow’s shadow volume的方法，该方法巧妙地利用模板缓冲区将阴影投射到任意物体上。它可以在任何GPU上使用，因为唯一的要求是一个模板缓冲区。它不是基于图像的(不像下面描述的阴影映射算法)，因此避免了采样问题，从而产生正确的清晰阴影。这有时可能是一个缺点。例如，角色的衣服可能会有褶皱，造成薄而硬的阴影，造成走样。由于其不可预测的成本，阴影体积今天很少被使用。我们在这里给出算法的简要描述，因为它说明了一些重要的原则和基于这些继续的研究。</strong></p>
<p><strong>首先，想象一个点和一个三角形。将直线从一点通过三角形的顶点延伸到无穷远处，就形成了一个无限的三角形金字塔。三角形下面的部分，即不包括点的部分是一个截断的无限大金字塔，上面的部分就是一个简单的金字塔。如下图所示。现在假设这个点是一个点光源。然后，在被截断的金字塔体积内(在三角形下面)的物体的任何部分都处于阴影中。这个体积称为阴影体积。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926110922.png" class="" title="image-20210926110922">

<p>左:点光源的线通过三角形的顶点延伸，形成一个无限的金字塔。右图:上面部分是一个金字塔，下面部分是一个无限截短的金字塔，也叫影子体积。所有在阴影体积内的几何体都在阴影中。</p>
<p><strong>假设我们查看某个场景，沿着从眼睛通过像素的光线，直到光线击中要显示在屏幕上的对象。当光线到达这个物体时，我们增加一个计数器，每次它经过正面的阴影体(即面向观众)。因此，每次光线进入阴影时计数器都增加。以同样的方式，每次射线经过被截断的金字塔的背面时，我们减少相同的计数器。然后光线从阴影中走出来。我们继续，递增和递减计数器，直到射线击中要在该像素上显示的对象。如果计数器大于零，则该像素处于阴影中;否则就不是。当有多个三角形投射阴影时，这个原则也适用。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926111055.png" class="" title="image-20210926111055">

<p>使用两种不同计数方法计算阴影-体积交叉的二维侧视图。在z-pass体积计数中，当射线通过阴影体积的前面向三角形时，计数增加，当离开阴影体积的后面向三角形时，计数减少。所以，在点A，光线进入两个阴影体积为+2，然后离开两个阴影体积，净重为0，所以这个点在光线中。在z-fail体积计数中，计数从表面以外开始(这些计数以斜体显示)。对于点B处的射线，z-pass方法通过两个正面三角形给予+2计数，而z-fail通过两个反面三角形给予相同计数。点C显示了z-fail阴影体积必须被封顶。从点C开始的射线首先击中一个正面的三角形，得到−1。然后它退出两个阴影体积(通过它们的尾盖，这是这个方法正常工作所必需的)，给出净计数+1。计数不为零，所以点处于阴影中。这两种方法总是给出相同的计数结果的所有点上观察的表面。</p>
<p><strong>用光线做这个是很耗时间的。但有一个更聪明的解决方案:一个模板缓冲区可以为我们做计数。首先，清除模板缓冲区。其次，整个场景被绘制到帧缓冲区中，只使用了未点亮的材质的颜色，以便在颜色缓冲区中获得这些着色组件，并将深度信息放入z缓冲区中。第三，关闭z-缓冲区更新和写入颜色缓冲区(尽管z-缓冲区测试仍在进行)，然后绘制阴影体的正面三角形。在此过程中，模具操作被设置为在绘制三角形的位置增加模具缓冲区中的值。第四步，使用模板缓冲区完成另一步，这一次只绘制阴影体的背面三角形。在此过程中，模板缓冲区中的值将在三角形被吸引。只有当渲染的阴影-体面的像素是可见的(例如:，而不是被任何真实的几何学所隐藏)。此时，模板缓冲区保存每个像素的阴影状态。最后，整个场景再次渲染，这一次只显示了受光照影响的活动材料的组件，并且只显示在模板缓冲区的值为0的地方。值为0表示光线走出阴影的次数与进入阴影体积的次数相同。这个位置被灯光照亮。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926111257.png" class="" title="image-20210926111257">

<p>阴影体积。在左边，一个人物投下了阴影。在右边，模型的挤压三角形显示。(图片来自Microsoft SDK样本“ShadowVolume”。)</p>
<p><strong>这种计算方法是影子体积背后的基本思想。阴影体积算法生成的阴影示例如上图所示。有许多有效的方法可以一次性实现算法。然而，当物体穿透相机的近平面时，计数就会出现问题。解决方法称为z-fail，涉及计数隐藏在可见表面后面而不是前面的交叉。上上图显示了这个替代方案的简要概述。</strong></p>
<p><strong>为每个三角形创建四边形会产生大量的透支。也就是说，每个三角形将创建三个必须被渲染的四边形。一个球体由一千个三角形组成三千个四边形，每一个四边形都可以跨越屏幕。一个解决方案是沿着物体的轮廓线只画那些四边形，例如，我们的球体可能只有50个轮廓线，所以只需要50个四边形。几何着色器可以用来自动生成这样的轮廓边缘。选择和夹紧技术也可以用来降低填充成本。</strong></p>
<p><strong>然而，阴影体积算法仍然有一个可怕的缺点:极端的可变性。想象一个单一的小三角形。如果相机和光源处于完全相同的位置，阴影体积成本是最小的。形成的四边形不会覆盖任何像素，因为它们是视图的边。只有三角形本身才重要。假设观察者现在绕着三角形旋转，保持它在视野中。当相机远离光源时，阴影-体积四边形将变得更加可见，并覆盖更多的屏幕，导致更多的计算发生。如果观察者碰巧移动到三角形的阴影中，阴影体积将完全填满屏幕，与我们最初的视图相比，需要花费相当多的时间来评估。这种可变性使得阴影体积在具有一致帧率的交互应用中不可用。像其他情况一样，朝光看会导致算法成本的巨大、不可预测的飞跃。</strong></p>
<p><strong>由于这些原因，阴影体积在很大程度上已经被应用程序所抛弃。然而，考虑到新的和不同的方式在GPU上访问数据的持续发展，以及研究人员对这种功能的巧妙重新用途，阴影体积可能有一天会重新被普遍使用。例如，Sintorn等人概述了提高效率的阴影体积算法，并提出了自己的层次加速结构。</strong></p>
<p><strong>下一个提出的算法，阴影贴图，具有更可预测的成本，并且非常适合GPU，因此在许多应用中形成阴影生成的基础。</strong></p>
<h2 id="Shadow-Maps-阴影贴图"><a href="#Shadow-Maps-阴影贴图" class="headerlink" title="Shadow Maps 阴影贴图"></a>Shadow Maps 阴影贴图</h2><p><strong>1978年，Williams提出了一种通用的基于z缓冲区的渲染器，可以用于在任意物体上快速生成阴影。这个想法是渲染场景，使用z缓冲区，从光源的位置投射阴影。凡是光“看到”的都被照亮了，其余的都处于阴影中。当生成这个映像时，只需要z缓冲。灯光、纹理和写入值到颜色缓冲可以关闭。</strong></p>
<p><strong>z缓冲区中的每个像素现在都包含了离光源最近的物体的z深度。我们将z缓冲区的全部内容称为阴影贴图，有时也称为阴影深度贴图或阴影缓冲区。为了使用阴影贴图，场景将进行第二次渲染，但这一次是基于观察者的视角。当每个绘图原语被渲染时，它在每个像素处的位置将与阴影图进行比较。如果一个渲染点离光源的距离大于阴影贴图中对应的值，那么这个点就处于阴影中，否则就不是。这种技术是通过使用纹理映射来实现的。参见下图。阴影映射是一种流行的算法，因为它相对来说是可预测的。构建阴影地图的成本与渲染原语的数量大致成线性关系，访问时间是恒定的。阴影贴图可以生成一次，并在光线和物体不移动的场景中重复使用每一帧，例如用于计算机辅助设计。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926111708.png" class="" title="image-20210926111708">

<p>阴影贴图。在左上角，阴影贴图是通过在视图中存储表面深度而形成的。在右上角，眼睛注视着两个地方。球体在点va处可见，这个点被发现位于阴影贴图的texel a。存储在那里的深度并不(远)小于点va从光线处的深度，因此点被照亮。矩形击中点vb 比存储在texel b的深度(远)远离光，因此在阴影中。左下角是从光的角度看的场景，白色更远。在右下角是用阴影贴图渲染的场景。</p>
<p><strong>当一个z缓冲区被生成时，光线只能“看”到一个特定的方向，就像相机一样。对于一个遥远的定向光，如太阳，光线的视野被设置为包含所有物体，在眼睛所看到的观察体积中投射阴影。光线使用正投影，它的视图需要在x和y上足够宽和高来观察这组物体。当地的光源也需要尽可能的进行类似的调整。如果局部光线离投射阴影的物体足够远，一个单一的视锥可能足以包含所有这些。或者，如果局部的光是一个聚光灯，它有一个与它相关联的自然锥，与它的锥外的一切被认为是不照明的。</strong></p>
<p><strong>如果局部光源在场景中，并且被阴影投射器包围，一个典型的解决方案是使用六视图立方体，类似于立方体环境映射。这些被称为全向阴影贴图。全向映射的主要挑战是避免沿着两个独立映射相遇的接缝处的工件。King和Newhall深入分析了问题并提出了解决方案，Gerasimov提供了一些实施细节。Forsyth出了一种用于全向光的通用多锥体分区方案，在需要的地方提供了更多的阴影贴图分辨率。Crytek根据每个视图的投影截锥的屏幕空间覆盖范围为点光源设置了每个视图的分辨率，所有地图存储在一个纹理图集中。</strong></p>
<p><strong>并不是场景中的所有物体都需要渲染到光线的视图体中。首先，只有能够投射阴影的物体才需要渲染。例如，如果已知地面只能接收阴影而不能投射阴影，那么就不需要将其渲染到阴影地图中。</strong></p>
<p><strong>阴影投射体定义为光线视野锥体内的阴影投射体。这个截锥可以通过多种方式增强或收紧，让我们可以安全地忽略一些阴影投射器。想象一组肉眼可见的阴影接收器。这组物体在光线视野方向的最大距离内。任何超过这个距离的物体都不能在可见的接收器上投下阴影。同样，可见接收器的集合可能比光线的原始x和y视图边界要小。参见下图。另一个例子是，如果光源在眼睛的视锥内，那么这个额外视锥外的任何物体都不能在接收器上投下阴影。只渲染相关对象不仅可以节省渲染时间，还可以减少光锥所需的尺寸，从而提高阴影图的有效分辨率，从而提高质量。此外，如果光锥的近平面尽可能地远离光，如果远平面尽可能地远离光，它会有所帮助尽可能接近。这样做可以提高z缓冲区的有效精度(章节4.7.2)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926112004.png" class="" title="image-20210926112004">

<p>在左侧，光的视野围绕着眼睛的视锥。在中间，光的远平面被拉进来，只包括可见的接收器，所以选择三角形作为施法者;近平面也进行了调整。在右侧，光线的截锥侧面被用来约束可见的接收器，剔除绿色的胶囊。</p>
<p><strong>阴影贴图的一个缺点是阴影的质量取决于阴影映射的分辨率(以像素为单位)和z缓冲区的数值精度。由于在深度比较过程中对阴影图进行采样，该算法容易出现走样问题，特别是在靠近物体接触点的地方。一个常见的问题是自阴影走样叠，通常被称为“表面痤疮”或“阴影痤疮”，在这种情况下，三角形被错误地认为是阴影本身。这个问题有两个根源。一个是处理器精度的数值限制。另一个来源是几何的，因为点样本的值被用来代表一个区域的深度。也就是说，为光线生成的样本几乎从不位于与屏幕样本相同的位置(例如，像素通常在其中心取样)。当光线的存储深度值与被观察表面的深度相比较时，光线的值可能会略低于表面的深度，从而导致自阴影。这些错误的影响如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926112152.png" class="" title="image-20210926112152">

<p>阴影贴图的走样。在左边，偏差太低，所以出现了自阴影。在右边，高偏置导致鞋子不会投出接触影子。阴影贴图的分辨率也太低，给阴影一个块状的外观。(图片由Christoph Peters使用阴影演示生成。)</p>
<p><strong>一种帮助避免(但不总是消除)各种阴影映射的常见方法是引入偏差因素。当检查在阴影图中发现的距离与被测试的位置的距离，一个小的偏差从接收机的距离。参见下图。这种偏置可以是一个恒定值，但当接收器不是主要面向光时，这样做可能会失败。一种更有效的方法是使用与接收器对光线的角度成比例的偏置。为了避免这个问题，表面倾斜得越远，偏移就越大。这种类型的偏差被称为坡度比例偏差。这两种偏差都可以通过使用命令来应用，例如OpenGL的glPolygonOffset()来将每个多边形移离光线。注意，如果一个表面直接面对光线，它不偏向后都是由坡度比例偏差决定的。由于这个原因，一个常数偏差与坡度偏差一起使用，以避免可能的精度误差。坡度比例偏差也经常固定在某个最大值，因为当从光线下观察时，当表面接近边缘时，切线值可能非常高。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926112520.png" class="" title="image-20210926112520">

<p>阴影的偏置。这些表面被渲染成一个阴影贴图，以垂直线表示阴影贴图的像素中心。遮挡深度被记录在×位置。我们想知道表面是否在显示为点的三个样品处被照亮。最接近的阴影贴图深度值用相同的颜色×显示。在左边，如果没有添加偏移，蓝色和橙色的样本将被错误地判定为处于阴影中，因为它们距离光线比它们对应的阴影贴图深度更远。在中间，从每个样本中减去一个恒定的深度偏差，使每个样本更靠近光。蓝色样本仍然被认为是在阴影中，因为它并不比测试时的阴影贴图深度更接近光源。在右侧，阴影贴图是通过将每个多边形移动到与其斜度成比例的光线之外而形成的。所有的样本深度现在都比阴影贴图的深度更接近，所以都是亮的。</p>
<p><strong>Holbert引入了法向偏移，它首先使接收器的世界空间位置沿着表面的法向稍微移动一点，并与光的方向和几何法向之间角度的正弦成比例。这不仅改变了深度，而且改变了样本在阴影贴图上测试的x和y坐标。当光线与表面的角度变得更浅时，偏移量就会增加，希望样本能够离表面足够远，以避免自阴影。这种方法可以看作是将样品移动到接收器上方的“虚拟表面”。这个偏移是一个世界空间距离，所以Pettineo建议根据阴影贴图的深度范围缩放它。Pesce提出了沿着摄像机视图方向偏移的想法，这也可以通过调整阴影贴图坐标来工作。其他偏差方法在第7.5节讨论，因为阴影方法也需要测试几个邻近的样本。</strong></p>
<p><strong>太大的偏差会导致一个被称为“光泄漏”或“Peter Panning”的问题，在这个问题中，物体似乎漂浮在下方表面的上方。产生这种人为现象的原因是物体接触点下方的区域，例如脚下的地面，被推得太远，所以没有影子。</strong></p>
<p><strong>避免自阴影问题的一种方法是只渲染阴影贴图的背面。这个方案被称为二次深度阴影映射，它在许多情况下都能很好地工作，特别是在一个不能手动调整偏移的渲染系统中。当物体是双面的、薄的或相互接触时，就会出现问题。如果一个对象是一个模型，其中网格的两边都是可见的，例如，一个棕榈叶或一张纸，自阴影可能发生，因为背面和正面在同一位置。类似地，如果不进行偏置，在轮廓边缘或薄物体附近也会出现问题，因为在这些区域中，背面接近正面。添加偏置可以帮助避免表面粉刺，但该方案更容易漏光，因为在接收端和遮挡器的背面接触点没有分离。参见下图。选择哪种方案取决于具体情况。例如，Sousa等人发现，使用正面作为阳光阴影，使用背面作为室内灯光，对它们的应用效果最好。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926112758.png" class="" title="image-20210926112758">

<p>阴影贴图表面为一个头顶光源。在左边，面向光的表面(用红色标记)被发送到阴影地图。表面可能会被错误地确定为自阴影(“痤疮”)，所以需要偏向远离光线。在中间，只有背面三角形被渲染到阴影贴图中。将这些遮光器向下推的偏置可能会让光线泄漏到位置A附近的地平面上;向前偏置会使标记为b的剪影边界附近被照亮的位置被认为处于阴影中。在右侧，阴影地图上每个位置上最近的正面和背面三角形之间的中点形成了一个中间表面。漏光可能发生在c点附近(第二深度阴影贴图也可能发生)，因为最近的阴影贴图样本可能在这个位置左边的中间表面上，所以这个点离光源更近。</p>
<p><strong>注意，对于阴影贴图，对象必须是“水密的”(流形和封闭的，例如固体;第16.3.3节)，或者必须同时将正面和背面渲染到映射中，否则对象可能不能完全投射阴影。Woo提出了一种通用的方法，从字面上讲，它试图在仅仅使用正面或背面阴影之间找到一种折衷的方法。这个想法是将实体物体渲染到阴影贴图上，并跟踪两个距离光线最近的表面。这个过程可以通过深度剥离或其他与透明度相关的技术来完成。两个物体之间的平均深度形成了一个中间层，它的深度被用作阴影贴图，有时也被称为双重阴影贴图。如果物体足够厚，自阴影和光漏的影响就会最小化。Bavoil等人讨论了处理潜在伪影的方法，以及其他实现细节。主要的缺点是额外的成本关联使用两个阴影地图。Myers讨论了闭塞器和接收器之间由艺术家控制的深度层。</strong></p>
<p><strong>当观察者移动时，光线的视野体积通常会随着阴影投射体的变化而变化。这样的变化导致阴影在帧与帧之间的轻微移动。这是因为光线的阴影地图是抽样一组不同方向的光,而这些方向与前面不一致集。对于定向照明,解决办法是迫使每一个成功的影子映射生成维持相同的相对 texel beam位置在世界空间。也就是说，您可以将阴影地图看作是在整个世界上强加一个二维网格参考框架，每个网格单元代表地图上的一个像素样本。当你移动的时候，阴影贴图会生成一组不同的相同网格单元。换句话说，光线的视野投射被迫在这个网格上，以保持帧对帧的连贯性。</strong></p>
<h3 id="Resolution-Enhancement-分辨率增强"><a href="#Resolution-Enhancement-分辨率增强" class="headerlink" title="Resolution Enhancement 分辨率增强"></a>Resolution Enhancement 分辨率增强</h3><p><strong>与纹理的使用类似，理想情况下，我们希望一个阴影贴图texel覆盖大约一个图像像素。如果我们有一个光源位于与眼睛相同的位置，阴影地图与屏幕空间像素完美地一对一映射(并且没有可见的阴影，因为光线正好照亮眼睛看到的东西)。当光线的方向改变时，每像素的比例就会改变，这就会造成伪影。下图显示了一个示例。阴影是块状的，定义很差，因为前景中的大量像素与阴影贴图的每个像素相关联。这种不匹配被称为透视走样。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926113332.png" class="" title="image-20210926113332">

<p>左边的图像是使用标准阴影映射创建的;使用LiSPSM查看右边的图像。图中显示了每个阴影贴图的像素投影。这两种阴影图具有相同的分辨率，不同之处在于LiSPSM改变了光源的矩阵，以提供更接近观察者的更高采样率。(图片由维也纳理工大学的Daniel Scherzer提供)</p>
<p><strong>单个阴影贴图像素也可以如果一个表面接近光的侧面，但面对观众，覆盖许多像素。这个问题被称为投影走样;参见下图。块性可以通过增加阴影映射的分辨率来降低，但代价是额外的内存和处理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926113449.png" class="" title="image-20210926113449">

<p>左边的灯几乎就在头顶上。阴影的边缘有点参差不齐，因为与眼睛的视图相比，分辨率较低。在右侧，光线靠近地平线，所以每个阴影纹理水平覆盖了相当多的屏幕区域，因此给了一个更锯齿状的边缘。(图片由realmjp在Github上的“阴影”程序生成。)</p>
<p><strong>还有另一种方法来创建光的采样模式，使其更接近相机的模式。这是通过改变场景向光线投射的方式来实现的。通常我们认为视图是对称的，视图向量位于截锥的中心。然而，视图方向仅仅定义了一个视图平面，而不是哪个像素被采样。定义截锥的窗口可以在这个平面上移动、倾斜或旋转，创建一个四边形，提供了不同的世界到视图空间的映射。四边形仍然按规则间隔采样，因为这是线性变换矩阵的性质和GPU的使用。采样率可以通过改变光线的视图方向和视图窗口的边界来修改。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926113536.png" class="" title="image-20210926113536">

<p>对于顶灯，左边地板上的采样与眼睛的频率不匹配。通过改变光线的视野方向和右边的投影窗口，采样率倾向于在靠近眼睛的地方有更高的像素密度。</p>
<p><strong>在将光线映射到眼睛上有22个自由度。对这个解决方案空间的探索导致了几种不同的算法进行尝试以便更好地匹配光线的采样率与眼睛的采样率。方法包括透视阴影图(PSM)、梯形阴影图(TSM)和光空间透视阴影图(LiSPSM)。参见本节首图中的示例。这个技术被称为透视扭曲方法。</strong></p>
<p><strong>这些矩阵扭曲算法的一个优点是，除了修改光的矩阵之外，不需要额外的工作。每种方法都有自己的优点和缺点，因为每种方法都可以帮助匹配某些几何和照明情况下的采样率，而在其他情况下则会降低采样率。Lloyd等人分析了PSM、TSM和LiSPSM之间的等效性，很好地概述了这些方法的采样和走样问题。当光线的方向垂直于视图的方向时(例如，头顶)，这些方案工作得最好，因为透视变换可以移动到更靠近眼睛的地方放置更多的样本。</strong></p>
<p><strong>矩阵扭曲技术无法帮助的一种照明情况是当一盏灯在相机前面并指向它时。这种情况被称为dueling frusta，或者更通俗的说法是“deer in the headlights”。“需要更多的阴影贴图样本靠近眼睛，但线性扭曲只会让情况更糟。这个问题和其他问题，如质量的突然变化和“紧张的”，不稳定的阴影在相机运动中产生，使这些方法不再受欢迎。</strong></p>
<p><strong>在观察者所在的位置添加更多的样本是一个很好的想法，这导致了为给定视图生成多个阴影地图的算法。当Carmack在2004年地震经济大会上描述这个想法时，这个想法第一次产生了显著的影响。Blow独立实现了这一系统。这个想法很简单:生成一组固定的阴影贴图(可能在不同的分辨率)，覆盖场景的不同区域。在Blow的方案中，四个阴影地图嵌套在查看器周围。通过这种方式，高分辨率的地图可以用于附近的物体，而对于远处的物体，分辨率会下降。Forsyth提出了一个相关的想法，为不同的可见物体集生成不同的阴影地图。在他的设置中，避免了如何处理跨越两个阴影贴图边界的对象的转换问题，因为每个对象都有且只有一个与它相关的阴影贴图。Flagship Studios开发了一个混合了这两种理念的系统。一个阴影图是用于附近的动态对象，另一个是用于观察者附近的静态对象的网格部分，第三个是用于场景中的整体静态对象。每一帧生成第一个阴影贴图。另外两个可以只生成一次，因为光源和几何形状是静态的。虽然所有这些特定的系统现在都很老了，但针对不同的对象和情况(一些是预先计算的，一些是动态的)的多个地图的想法，是此后开发的算法中的一个共同主题。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926114059.png" class="" title="image-20210926114059">

<p>在左侧，视觉上的视锥体被分割成四个体量。在右侧，为体块创建了包围框，它决定了方向光的四个阴影贴图所渲染的体块。(在恩格尔)。</p>
<p><strong>2006年Engel、Lloyd等和Zhang等独立研究了相同的基本思想。这个想法是通过平行于视图方向的切片将视图截体的体积分成几块。参见上图。随着深度的增加，每个连续体积的深度范围大约是前一体积的2到3倍。对于每个视图体，光源可以创建一个紧密绑定的锥体，然后生成阴影贴图。通过使用纹理图集或数组，不同的阴影图可以被视为一个大的纹理对象，从而最小化缓存访问延迟。获得的质量改进的对比如下图所示。恩格尔为这种算法命名为级联阴影映射(CSM)，比张的术语平行分割阴影映射更常用，但两者都出现在文献中，实际上是相同的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926114235.png" class="" title="image-20210926114235">

<p>在左侧，场景的宽可视区域导致一个2048 × 2048分辨率的阴影地图显示透视走样。在右侧，四个1024 × 1024的阴影地图沿着视图轴放置，大大提高了质量。围栏的前角的缩放显示在插入的红框中。(图片由香港中文大学张帆提供)</p>
<p><strong>该算法实现简单，可以覆盖大面积的场景，结果合理，具有较强的鲁棒性。决斗锥柱问题可以通过在靠近眼睛的地方以更高的采样率来解决，而且不会出现严重的最坏情况问题。由于这些优点，级联阴影映射在许多应用程序中被使用。</strong></p>
<p><strong>虽然可以使用透视扭曲将更多的样本打包到单个阴影贴图的细分区域中，但规范是为每个级联使用单独的阴影贴图。如上上图所示，下图从查看者的角度显示，每个地图所覆盖的区域可能不同。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926114408.png" class="" title="image-20210926114408">

<p>级联阴影映射可视化。紫色、绿色、黄色和红色分别代表最近和最远的级联。(图片由Unity Technologies提供。)</p>
<p><strong>对于更近的阴影贴图，更小的视图体积提供了更多需要的样本。决定z-depth的范围如何在映射之间划分—一个称为z-partitioning的任务—可能非常简单，也可能非常复杂。一种方法是对数划分，其中对每个级联映射，使远平面距离与近平面距离的比率相同:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926114606.png" class="" title="image-20210926114606">

<p><strong>其中n和f是整个场景的近平面和远平面，c是地图的数量，r是生成的比率。例如，如果场景中最近的物体在1米之外，p最大距离是1000米，我们有三个级联地图，然后r = ³√(1000/1) = 10。最近视图的远近平面距离是1和10，下一个间隔是10到100以保持这个比例，最后一个是100到1000米。初始近深度对这种划分有很大的影响。如果近深度只有0.1米，那么10000的立方根是21.54，这是一个相当高的比率，例如0.1到2.154,46.42到1000。这意味着生成的每个阴影地图必须覆盖更大的区域，从而降低其精度。在实践中，这样的划分为近平面附近的区域提供了相当大的分辨率，如果在这个区域中没有物体，这就浪费了。避免这种不匹配的一种方法是将分割距离设置为对数和等距分布的加权混合，但如果我们能够为场景确定紧密的视图边界，那就更好了。</strong></p>
<p><strong>挑战在于设置近距离的飞机。如果距离眼睛太远，物体可能会被平面夹住，这是一个非常糟糕的藏物。对于过场动画，美工可以设置场景这个值恰好提前，但对于交互式环境来说，这个问题更具挑战性。Lauritzen等人提出了样本分布阴影图(SDSM)，它使用前一帧的z-depth值，通过两种方法中的一种来确定更好的分区。</strong></p>
<p><strong>第一种方法是查看z深度的最小值和最大值，并使用这些值设置近平面和远平面。这是使用所谓的GPU上的reduce操作来执行的，在这个操作中，一系列越来越小的缓冲区被计算器或其他着色器分析，输出缓冲区反馈作为输入，直到1 × 1缓冲区被留下。通常情况下，这些值会稍微往外推一点，以适应场景中物体的移动速度。除非采取纠正措施，从屏幕边缘进入的附近物体仍可能对画面造成问题，但在下一帧中会很快得到纠正。</strong></p>
<p><strong>第二种方法还分析深度缓冲区的值，制作一个称为直方图的图，记录z-深度沿范围的分布。除了发现紧密的近平面和远平面外，图中可能会有根本没有物体的间隙。任何通常添加到该区域的分区平面都可以被捕捉到对象实际存在的地方，从而为级联映射集提供更多的z-depth精度。</strong></p>
<p><strong>在实践中，第一种方法是通用的，速度快(通常在1 ms /帧范围内)，效果好，因此在多个应用中被采用。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210926114825.png" class="" title="image-20210926114825">

<p>深度边界效果。在左边，没有特殊处理来调整近平面和远平面。在右边，SDSM用来寻找更紧密的边界。注意每个图像左边缘附近的窗口框架，二楼的花盒下面的区域，以及一楼的窗口，由于松散的视图边界导致的欠采样导致了伪影。指数阴影图用于渲染这些特定的图像，但提高深度精度的想法是有用的所有阴影图技术。(图片由Ready at Dawn Studios提供，版权为索尼互动娱乐公司。)</p>
<p><strong>与单个阴影贴图一样，由于光样本在帧间移动而产生的闪烁伪影是一个问题，当物体在级联之间移动时可能会更糟。各种方法被用来保持世界空间中稳定的样本点，每种方法都有各自的优点。当一个物体跨越两个阴影图之间的边界时，阴影的质量会发生突然的变化。一种解决方案是让视图稍微重叠。在这些重叠区域中采集的样本从相邻的阴影图中收集结果，并进行混合。另一种方法是利用抖动法在该区域采集单个样本。</strong></p>
<p><strong>由于它的普及，人们在提高效率和质量方面投入了相当大的努力。如果阴影贴图的截锥内没有任何变化，则不需要重新计算阴影贴图。对于每一种光，阴影投射者的列表可以通过找出哪些物体对光线可见，以及其中哪些物体可以在接收器上投射阴影来预先计算出来。由于很难判断阴影是否正确，因此可以采用一些适用于级联和其他算法的捷径。一种技术是使用低细节级别的模型作为实际投射阴影的代理。另一种方法是从考虑中去除微小的遮挡器。较远的阴影地图更新频率可能少于每帧一次，理论上这样的阴影不太重要。这种想法有可能是由大型移动物体造成的，因此需要小心使用。Day提出了从一帧到另一帧“滚动”远程地图的想法，这个想法是大多数静态阴影地图可重用的帧到帧，只有边缘可能改变，因此需要渲染。《毁灭战士》(2016)等游戏保留了大量的阴影地图，只生成那些物体移动的地方。更进一步的级联贴图可以被设置为完全忽略动态对象，因为这样的阴影对场景的贡献可能很小。在某些环境中，高分辨率的静态阴影图可以代替这些进一步的级联，这可以显著减少工作量。稀疏纹理系统(章节19.10.1)可以用于单个静态阴影地图非常庞大的世界。级联阴影贴图可以与烘烤的光线贴图纹理或其他更适合于特定情况的阴影技术相结合。Valient的报告值得注意的是，它描述了各种电子游戏的不同影子系统定制和技术。第11.5.1节详细讨论了预先计算的光和影算法。</strong></p>
<p><strong>创建几个独立的阴影贴图意味着要为每个贴图运行一些几何体。许多提高效率的方法都建立在将遮挡器渲染到一组阴影贴图的想法上。几何着色器可以用来复制对象数据，并将其发送到多个视图。实例几何着色器允许对象输出到32个深度纹理。</strong></p>
<p><strong>多视口扩展可以执行一些操作，例如将一个对象渲染到一个特定的纹理数组切片。第21.3.1节将在它们用于虚拟现实的背景下更详细地讨论这些。视口共享技术的一个可能的缺点是，所有生成的阴影贴图的遮挡器必须被发送到管线中，而不是与每个阴影贴图相关的集合。</strong></p>
<p><strong>你自己目前处于世界上数十亿光源的阴影中。光只从其中几个到达你。在实时渲染中，如果所有的光都处于激活状态，那么带有多个光的大型场景可能会被计算淹没。如果一个空间体积在视锥内部，但肉眼不可见，则遮挡该接收体体积的对象不需要评估。Bittner等人使用眼睛的遮挡剔除(第19.7节)来找到所有可见的阴影接收器，然后从光线的角度将所有潜在的阴影接收器渲染到模板缓冲掩模中。这个遮罩编码了从光中看到的可见阴影接收器。为了生成阴影贴图，他们使用遮挡剔除从光线中渲染对象，并使用蒙版剔除没有接收器所在的对象。各种选择策略也适用于光。由于辐照度随距离的平方而衰减，一种常见的技术是在一定的阈值距离后对光源进行消光。例如，第19.5节中的门户筛选技术可以发现哪些光线影响哪些细胞。这是一个活跃的研究领域，因为性能的好处是相当可观的。</strong></p>
<h2 id="Percentage-Closer-Filtering-Percentage-Closer过滤"><a href="#Percentage-Closer-Filtering-Percentage-Closer过滤" class="headerlink" title="Percentage-Closer Filtering Percentage-Closer过滤"></a>Percentage-Closer Filtering Percentage-Closer过滤</h2><p><strong>阴影贴图技术的一个简单扩展可以提供伪软阴影。这种方法还可以帮助改善分辨率问题，当一个光样本单元覆盖了许多屏幕像素时，阴影看起来是块状的。解决方法类似于纹理放大(章节6.2.1)。不是从阴影地图上取一个样本，而是取四个最近的样本。该技术并没有插入深度本身，而是与表面深度比较的结果。也就是说，将表面的深度分别与四个texel深度进行比较，然后确定每个阴影贴图样本的点处于光照或阴影中。这些结果,即0为阴影，1为光线，然后用双线性插值来计算光线对表面位置的实际贡献。这种过滤结果是一个人为的软阴影。这些半影会根据阴影地图的分辨率、相机位置和其他因素而变化。例如，更高的分辨率会使边缘的软化幅度更小。不过，有一点半影和平滑总比没有好。</strong></p>
<p><strong>这种从阴影映射中提取多个样本并混合结果的想法被称为接近百分比滤波(PCF)。区域灯产生柔和的阴影。到达一个表面某个位置的光的数量与该位置可见的光的面积的比例有关。PCF试图通过反转过程来近似点光源(或方向光源)的软阴影。</strong></p>
<p><strong>它不是从一个表面位置寻找光的可见区域，而是从一组靠近原始位置的表面位置寻找准时光的可见性。参见下图。“接近百分比过滤”的名称指的是最终目标，即找到在光线下可见的样本的百分比。这个百分比是用来着色表面的光的多少。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927144303.png" class="" title="image-20210927144303">

<p>在左边，来自区域光源的棕色线显示了半影形成的地方。对于接收器上的单个点p，可以通过测试区域光的表面上的一组点并找到没有被任何遮挡物遮挡的点来计算接收到的光照量。在右边，点光源不会投出半影。PCF通过反转过程来近似区域光的效果:在一个给定的位置，它对阴影贴图上的一个可比区域进行采样，以得出有多少样本被照亮的百分比。红色椭圆表示阴影地图上的采样区域。理想情况下，这个圆盘的宽度与接收器和遮挡器之间的距离成正比。</p>
<p><strong>在PCF中，位置生成在一个表面位置附近，在相同的深度，但在阴影贴图上的不同texel位置。每个位置的可见性都被检查，这些结果的布尔值，亮的或未亮的，然后混合得到一个软阴影。注意这个过程是非物理的:不是直接对光源取样，这个过程依赖于对表面本身取样的想法。到遮挡器的距离不影响结果，所以阴影有相似大小的半影。尽管如此，这种方法在许多情况下提供了一个合理的近似。</strong></p>
<p><strong>一旦确定要采样的区域的宽度，以避免混叠的方法进行采样是很重要的。有许多不同的方法来采样和过滤附近的阴影贴图位置。变量包括采样区域的宽度，使用多少样本，采样模式，以及如何对结果进行加权。使用性能较差的API，可以通过一种类似于双线性插值的特殊纹理采样模式来加速采样过程，该模式访问四个相邻节点的位置。不是混合结果，而是将四个样本分别与给定值进行比较，返回通过测试的比率。然而，在规则网格模式中执行最近邻采样可能会产生明显的伪数据。使用联合双边过滤器，使结果模糊，但尊重物体边缘，可以提高质量，同时避免阴影泄漏到其他表面。有关此过滤技术的更多信息，请参阅12.1.1节。</strong></p>
<p><strong>DirectX 10引入了对PCF的单指令双线性滤波支持，使结果更加平滑。这比最近的邻居取样提供了相当大的视觉改进，但是常规取样产生的伪影仍然是一个问题。最小化网格模式的一个解决方案是使用预先计算的泊松分布模式对一个区域进行采样，如下图所示。这种分布将样本分散开来，使它们既不接近彼此，也不是有规律的模式。众所周知，对每个像素使用相同的采样位置，无论其分布如何，都会产生模式。这种伪影可以通过围绕其中心随机旋转样本分布来避免，这将使混叠变成噪声。Casta ~ no发现泊松采样产生的噪声因其平滑、程式化的内容而特别明显。他提出了一种基于双线性抽样的高效高斯加权抽样方案。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927144513.png" class="" title="image-20210927144513">

<p>最左边显示了4×4网格模式中的PCF抽样，使用的是最近邻抽样。最右边显示了圆盘上的12点泊松采样模式。使用这个模式对阴影贴图进行采样，可以在中间的左半部分得到改进的结果，尽管伪影仍然可见。在右中，采样模式围绕其中心从一个像素随机旋转到另一个像素。结构化的阴影伪影变成了(不那么令人讨厌的)噪音。(图片由ATI研究公司的John Isidoro提供)</p>
<p><strong>自我遮蔽问题和光线泄露，即痤疮和彼得·潘宁，会因PCF而变得更糟。坡度比例偏差纯粹基于它与光线的角度将表面推离光线，假设一个样本在阴影贴图上的距离不超过一个texel。通过从表面上的单一位置在更大范围内取样，一些测试样品可能会被真实表面挡住。</strong></p>
<p><strong>一些不同的额外偏见因素被发明出来，并成功地用于减少自我跟踪的风险。Burley描述了偏锥，其中每个样本向光方向移动，其距离与原始样本的距离成正比。Burley建议斜率为2.0，并有一个小的恒定偏差。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927144627.png" class="" title="image-20210927144627">

<p>附加阴影偏差方法。对于PCF，在原始样品位置(5个点的中心)周围采集几个样品。所有这些样本都应该被点亮。在左图中，形成了一个偏锥，样本被移动到它上面。锥形的陡度可以增加，以使右边的样本足够接近而被点亮，但有可能增加其他地方(没有显示)真正被阴影笼罩的样本的光泄漏。在中间的图中，所有的样品被调整到位于接收器的平面上。这种方法对于凸面很有效，但对于凹面就会适得其反，如左侧所示。在右图中，法向偏移偏移沿表面的法向移动样本，与法向和光线之间的角度的正弦成正比。对于中心样本，这可以被认为是移动到原始表面之上的一个想象表面。这种偏差不仅会影响深度，还会改变用于测试阴影贴图的纹理坐标。</p>
<p><strong>sch¨uler、Isidoro和Tuft提出了基于观测的技术，即接收器本身的斜率应该用来调整其余样本的深度。在这三种方法中，Tuft的公式最容易应用于级联阴影贴图。Dou等进一步细化和扩展了这一概念，解释了z-深度如何以非线性方式变化。这些方法假定附近的样本位置在由三角形构成的同一平面上。被称为接收平面深度偏差或其他类似术语，这种技术在许多情况下可以相当精确，因为这个假想平面上的位置确实在表面上，或者如果模型是凸的，就在它前面。如上图所示，凹腔附近的样品会被隐藏。常数、坡度、接收平面、视图偏差和正常偏移偏差的组合已经用于解决自阴影问题，但仍然需要对每个环境进行手动调整。</strong></p>
<p><strong>PCF的一个问题是，由于采样区域的宽度保持不变，阴影会均匀地呈现柔和，所有的阴影都具有相同的半影宽度。在某些情况下这可能是可以接受的，但在闭塞器和接收器之间有地面接触的地方似乎是不正确的。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927144759.png" class="" title="image-20210927144759">

<p>接近百分比的过滤和接近百分比的软阴影。在左边，硬阴影加上一点PCF滤波。在中间，恒定宽度的软阴影。在右侧，当物体与地面接触时，有适当硬度的可变宽度软阴影。(图片由NVIDIA公司提供。)</p>
<h2 id="Percentage-Closer-Soft-Shadows-Percentage-Closer软阴影"><a href="#Percentage-Closer-Soft-Shadows-Percentage-Closer软阴影" class="headerlink" title="Percentage-Closer Soft Shadows Percentage-Closer软阴影"></a>Percentage-Closer Soft Shadows Percentage-Closer软阴影</h2><p><strong>2005年，Fernando发表了一种有影响力的方法，称为百分比-更接近的软阴影(PCSS)。它试图通过搜索附近的区域来解决问题阴影贴图找到所有可能的遮挡器。这些遮挡器离位置的平均距离用来确定样本面积宽度:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927145021.png" class="" title="image-20210927145021">

<p><strong>dr 接收器到光和do的距离是多少的平均遮挡距离。换句话说，样本表面面积的宽度随着平均遮挡器离接收器和光线的距离越来越远而增大。查看下图，并考虑移动遮挡器的效果，看看这是如何发生的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927144303.png" class="" title="image-20210927144303">

<p><strong>如果没有发现遮挡器，位置是完全照明，没有进一步的处理是必要的。类似地，如果位置完全被遮挡，处理就会结束。否则，则对感兴趣的区域进行采样，并计算光的近似贡献。为了节省加工成本，样品面积的宽度可以用来改变取样的数量。其他技术也可以实现，例如，对不太重要的远处软阴影使用较低的采样率。</strong></p>
<p><strong>这个方法的缺点是，它需要采样一个公平大小的阴影地图的区域，以找到遮挡器。使用旋转的泊松盘模式可以帮助隐藏欠采样的伪影。Jimenez注意到泊松采样在运动时可能是不稳定的，并发现通过使用介于抖动和随机之间的函数形成的螺旋模式可以在帧与帧之间提供更好的结果。</strong></p>
<p><strong>Sikachev等人详细讨论了一种使用AMD引入的SM 5.0特性的PCSS更快的实现，通常称之为接触硬化阴影(CHS)。这个新版本还解决了基本PCSS的另一个问题:半影的大小受阴影地图分辨率的影响。参见下图。这个问题可以通过首先生成阴影贴图的mipmaps来最小化，然后选择最接近用户定义的世界空间内核大小的mip级别。采样一个8 × 8的区域以找到平均阻塞深度，只需要16次GatherRed()纹理调用。一旦半影估计被发现，高分辨率的mip电平用于阴影的尖锐区域，而低分辨率的mip级别用于较软的区域。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927144759.png" class="" title="image-20210927144759">

<p><strong>CHS已经在大量的电子游戏中使用，研究还在继续。例如，Buades等提出了可分离软阴影映射(SSSM)，其中对网格采样的PCSS过程被分割成可分离的部分，元素尽可能从一个像素到另一个像素重用。</strong></p>
<p><strong>一个被证明有助于加速每像素需要多个样本的算法的概念是分层最小/最大阴影贴图。虽然阴影贴图深度通常不能被平均，但是每个mipmap级别的最小值和最大值是有用的。也就是说，可以形成两个mipmap，一个保存每个区域中最大的z- depth(有时称为HiZ)，一个保存最小的z- depth。给定一个texel位置、深度和要采样的面积，mipmaps可以用来快速确定完全光照和完全阴影的条件。例如，如果texel的z-depth大于mipmap中存储的对应区域的最大z-depth，那么texel必须处于阴影中-不需要进一步的采样。这种类型的阴影地图使得确定光线能见度的任务更加有效。</strong></p>
<p><strong>PCF等方法通过对附近的接收器位置进行采样来工作。PCSS通过寻找附近遮挡器的平均深度来工作。这些算法不直接考虑光源的面积，而是取样附近的表面，并受到阴影贴图分辨率的影响。PCSS背后的一个主要假设是，平均阻滞剂是半影大小的合理估计。当两种遮挡器，比如一盏路灯和一座遥远的山，部分遮挡同一表面上的一个像素时，这种假设就被打破了，并可能导致伪影。理想情况下，我们希望确定从单个接收器位置可见光源面积的多少。一些研究人员已经探索了使用GPU的反投影。这个想法是将每个接收器的位置作为一个视点，将区域光源作为视点平面的一部分，并将遮挡器投射到这个平面上。Schwarz和Stamminger和Guennebaud等都总结了之前的工作，并提出了自己的改进。Bavoil等人采用了不同的方法，使用深度剥离创建多层阴影贴图。反投影算法可以给出很好的结果，但(到目前为止)每像素的高成本意味着它们还没有被应用到交互式应用中。</strong></p>
<h2 id="Filtered-Shadow-Maps-过滤阴影贴图"><a href="#Filtered-Shadow-Maps-过滤阴影贴图" class="headerlink" title="Filtered Shadow Maps 过滤阴影贴图"></a>Filtered Shadow Maps 过滤阴影贴图</h2><p><strong>Donnelly 和 Lauritzen的 variance shadow map (VSM)是一种允许对生成的阴影图进行过滤的算法。该算法将深度存储在一个映射中，将深度平方存储在另一个映射中。当生成地图时，可以使用MSAA或其他抗锯齿方案。这些地图可以被模糊处理、映射、放入求和区域表或任何其他方法。将这些地图视为可过滤纹理的能力是一个巨大的优势，因为当从它们检索数据时，可以使用整个采样和过滤技术阵列。</strong></p>
<p><strong>我们将在这里对VSM进行一些深入的描述，以说明这个过程是如何工作的;同样，这类算法中的所有方法都使用相同类型的测试。有兴趣进一步了解这一领域的读者可以查阅相关参考资料，我们也推荐Eisemann等人的书，这本书为这一主题提供了相当大的空间。</strong></p>
<p><strong>首先，对于VSM，深度图在接收器的位置取样(仅一次)，以返回最近光遮挡器的平均深度。当这个平均深度M1，称为第一矩，大于阴影上接收机深度t时，则认为接收机完全处于光照中。当平均深度小于接收机深度时，用下式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927205951.png" class="" title="image-20210927205951">

<p><strong>pmax 样品的最大百分比是在光，σ² 为方差，t为受者深度，M1 是阴影图中预期的平均深度。深度平方阴影贴图的样本M2，称为第二矩，用于计算方差:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927205959.png" class="" title="image-20210927205959">

<p><strong>pmax 是接收端可见性百分比的上限。实际照度百分比p不能大于此值。这个上界来自Chebyshev不等式的片面变型。这个方程试图用概率论来估计，在表面位置上遮挡物的分布有多少超出了表面到光的距离。Donnelly和Lauritzen表明，对于平面闭塞器和平面接收器在固定深度，p = pmax，所以公式可以作为许多真实阴影情况的一个很好的近似。</strong></p>
<p><strong>Myers建立了一种关于为什么这种方法有效的直觉。在阴影边缘区域的方差增加。深度差异越大，方差就越大。(t−M1)²项是可见性百分比的重要决定因素。如果这个值略高于零，这意味着平均遮挡深度比接收深度更接近光，pmax 然后接近1(完全点亮)。这种情况会发生在半影完全亮着的边缘。进入半影，平均遮挡深度变得更接近光，所以这一项变得更大，pmax 下降。与此同时，方差本身在半影中发生变化，从边缘的几乎为零到最大的方差，其中遮挡器在深度上不同，并平等地共享该区域。这些项相互平衡，在半影上形成线性变化的阴影。与其他算法的对比如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927210244.png" class="" title="image-20210927210244">

<p>左上方是标准阴影映射。右上方，透视阴影贴图，增加观察者附近阴影贴图的纹理密度。左下角，接近百分比的软阴影，随着闭塞器与接收器的距离增加，阴影变得柔和。右下角是具有恒定软阴影宽度的方差阴影映射，每个像素用单个方差映射样本进行着色。(图片由Nico Hempe、Yvonne Jung和Johannes Behr提供。)</p>
<p><strong>方差阴影映射的一个重要特征是，它可以以一种优雅的方式处理由于几何原因造成的表面偏差问题。Lauritzen推导了如何利用表面的斜率来修改二阶矩的值。来自数值稳定性的偏差和其他问题可能是方差映射的问题。例如，式减去一个较大的值从另一个相似的值。这种类型的计算往往夸大了基础数字表示的准确性的缺乏。使用浮点纹理可以帮助避免这个问题。</strong></p>
<p><strong>总的来说，由于GPU优化的纹理能力得到了有效的利用，VSM的处理时间显著提高了质量。而PCF需要更多的样本，因此需要更多的时间，为了避免产生柔和阴影时的噪声，VSM可以只用一个高质量的样本来确定整个区域的效果，从而产生一个平滑的半影。这种能力意味着阴影可以在算法的限制范围内，在没有额外成本的情况下任意软化。</strong></p>
<p><strong>与PCF一样，滤波核的宽度决定了半影的宽度。通过寻找接收机和最近的遮挡器之间的距离，可以改变核宽度，从而给出令人信服的软阴影。mimapapping样本是一个缓慢增加宽度的半影覆盖范围的差估计器，创建了方框伪影。Lauritzen详细介绍了如何使用求和面积表来提供更好的阴影效果。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927210423.png" class="" title="image-20210927210423">

<p>方差阴影映射，其中到光源的距离从左到右增加。(图片来自NVIDIA SDK 10样本，由NVIDIA公司提供。)</p>
<p><strong>当两个或更多的遮挡器覆盖一个接收器并且一个遮挡器靠近接收器时，沿半影区域的方差阴影映射中断。概率理论中的Chebyshev不等式将产生一个与正确的光百分比无关的最大光值。最近的遮光器，由于只部分地隐藏光，抛弃了方程的近似值。这导致轻度出血(又称透光)，完全闭塞的区域仍然接受光照。参见下图。通过在更小的区域上获取更多的样本，可以解决这个问题，将方差阴影映射变成一种PCF形式。与PCF一样，速度和性能都需要权衡，但对于阴影深度复杂度较低的场景，方差映射效果很好。Lauritzen给出了一种由艺术家控制的方法来改善这个问题，即将低百分比视为完全阴影，并将其余百分比范围重新映射为0%到100%。这种方法使光出血变暗，以缩小整个半影为代价。虽然光出血是一个严重的限制，但由于这种阴影很少涉及多个遮挡器，所以VSM在从地形生成阴影方面是很好的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927210547.png" class="" title="image-20210927210547">

<p>在左边，方差阴影映射应用于茶壶。在右边，一个三角形(没有显示)在茶壶上投下阴影，在地上的阴影中造成了令人讨厌的伪影。(图片由Marco Salvi提供。)</p>
<p><strong>利用滤波技术快速产生平滑阴影的前景在滤波阴影映射中产生了很大的兴趣;主要的挑战是解决各种出血问题。Annen等人引入了卷积阴影映射。扩展了Soler和Sillion的平面算法背后的想法接收器，其思想是将阴影深度编码为傅立叶展开。与方差阴影映射一样，这样的映射可以被过滤。该方法收敛到正确答案，从而减少了漏光问题。</strong></p>
<p><strong>卷积阴影映射的一个缺点是需要计算和访问几个项，大大增加了执行和存储成本。Salvi和Annen等人同时独立地想到了使用基于指数函数的单一项的想法。这种方法被称为指数阴影映射(ESM)或指数方差阴影映射(EVSM)，它将深度的指数和其二阶矩保存到两个缓冲区中。指数函数更接近于阴影映射执行的阶跃函数。因此，这可以显著减少出血的假象。它避免了卷积阴影映射的另一个问题，称为振铃，轻微的光泄漏可能发生在特定深度刚刚超过原始遮挡器的深度。</strong></p>
<p><strong>存储指数值的一个限制是，第二阶矩值可能变得非常大，因此使用浮点数会超出范围。为了提高精度，并使指数函数下降得更陡，可以生成z-深度，使其为线性。</strong></p>
<p><strong>由于指数阴影映射方法的质量优于VSM，且与卷积映射方法相比，其存储容量更低，性能更好，因此在三种滤波方法中最受关注。Pettineo注意到其他几个改进，例如使用MSAA来改善结果和获得有限的透明度的能力，并描述了如何利用计算着色器提高过滤性能。</strong></p>
<p><strong>最近，Peters和Klein引入了矩影映射。它提供了更好的质量，尽管以使用四分钟或更多的时间为代价，增加了存储成本。可以通过使用16位整数来存储矩来降低这个代价。Pettineo实现了这种新方法，并将其与ESM进行了比较，提供了一个探索多种变体的代码库。</strong></p>
<p><strong>级联阴影映射技术可以应用于滤波映射以提高精度。级联ESM相对于标准级联映射的一个优点是，可以为所有级联设置一个偏差因子。Chen和Tatarchuk详细介绍了级联ESM遇到的各种透光问题和其他文物，并提出了一些解决方案。</strong></p>
<p><strong>过滤映射可以被认为是PCF的一种廉价形式，它只需要很少的示例。像PCF一样，这种阴影的宽度是恒定的。这些过滤的方法都可以与PCSS一起使用，以提供可变宽度的半影。力矩阴影贴图的扩展还包括提供光散射和透明效果的能力。</strong></p>
<h2 id="Volumetric-Shadow-Techniques-体积阴影技术"><a href="#Volumetric-Shadow-Techniques-体积阴影技术" class="headerlink" title="Volumetric Shadow Techniques 体积阴影技术"></a>Volumetric Shadow Techniques 体积阴影技术</h2><p><strong>透明的物体会减弱并改变光的颜色。对于一些透明对象集合，可以使用类似于第5.5节中讨论的技术来模拟这种效果。例如，在某些情况下，可以生成第二种阴影地图。将透明对象渲染到它，并存储最近的深度和颜色或alpha覆盖。如果接收端没有被不透明的阴影贴图阻塞，则测试透明深度贴图，如果被遮挡，则根据需要检索颜色或覆盖率。这个想法让人想起第7.2节中的阴影和光投影，存储的深度避免在透明物体和光线之间投影到接收器上。这种技术不能应用于透明物体本身。</strong></p>
<p><strong>对于头发和云彩等物体的真实渲染来说，自阴影是至关重要的，因为这些物体要么很小，要么是半透明的。单深度阴影贴图不适用于这些情况。Lokovic和Veach首先提出了深阴影贴图的概念，在这个概念中，每个阴影贴图texel存储了一个关于光线如何随深度下降的函数。这个函数通常由一系列不同深度的样本来近似，每个样本都有一个不透明度值。在地图的两个样本，括号给定位置的深度是用来寻找阴影的效果。GPU面临的挑战是如何高效地生成和评估这些函数。这些算法使用了类似的方法，遇到了一些与顺序无关的透明算法(章节5.5)遇到的类似挑战，比如忠实地表示每个函数所需的数据压缩存储。</strong></p>
<p><strong>Kim和Neumann首先提出了一种基于GPU的方法，他们称之为不透明度阴影地图。仅存储不透明度的地图生成在一个固定的深度集。Nguyen和Donnelly给出了这种方法的更新版本。然而，由于深度切片都是平行且均匀的，由于线性插值，需要大量的切片来隐藏切片之间的不透明度伪影。Yuksel和Keyser通过创建更接近模型形状的不透明度地图来提高效率和质量。这样做可以减少所需的层数，因为对每一层的评估对最终图像更重要。</strong></p>
<p><strong>为了避免依赖固定切片设置，人们提出了更多的自适应技术。Salvi等人引入了自适应体积阴影贴图，其中每个阴影贴图texel同时存储不透明度和层深。像素着色器操作用于有损压缩数据流(表面不透明度)，因为它是栅格化。这避免了需要无限的内存来收集所有的样本并在一个集合中处理它们。该技术类似于深阴影贴图，但在像素着色器中进行了动态压缩步骤。将函数表示限制为一个小的、固定数量的存储不透明度/深度对，使得GPU上的压缩和检索更加高效。由于需要读取、更新和回写曲线，因此成本高于简单的混合，这取决于用于表示曲线的点的数量。在这种情况下，该技术还需要支持无人机和ROV功能的最新硬件(章节3.8的末尾)。如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210927210945.png" class="" title="image-20210927210945">

<p>头发和烟雾渲染与自适应体积阴影贴图。(转载由Marco Salvi和英特尔公司许可，版权属英特尔公司，2010年。)</p>
<p><strong>在游戏GRID2中，采用自适应体积阴影映射方法进行逼真的烟雾渲染，平均成本低于2 ms/frame。F¨urst等人描述并提供了他们为电子游戏实现深度阴影贴图的代码。他们使用链表来存储深度和alpha，并使用指数阴影映射来提供光照和阴影区域之间的软过渡。</strong></p>
<p><strong>阴影算法的探索仍在继续，各种算法和技术的综合变得越来越普遍。例如，Selgrad等人研究了用链表存储多个透明样本，并使用带有分散写操作的计算着色器来构建地图。他们的作品使用了深阴影贴图的概念，以及过滤贴图和其他元素，为提供高质量的软阴影提供了一个更普遍的解决方案。</strong></p>
<h2 id="Irregular-Z-Buffer-Shadows-不规则Z缓存阴影"><a href="#Irregular-Z-Buffer-Shadows-不规则Z缓存阴影" class="headerlink" title="Irregular Z-Buffer Shadows 不规则Z缓存阴影"></a>Irregular Z-Buffer Shadows 不规则Z缓存阴影</h2><p><strong>各种各样的阴影贴图方法之所以流行有几个原因。它们的成本是可预测的，并且可以很好地扩展场景大小，最坏情况下与原语的数量成线性关系。它们可以很好地映射到GPU上，因为它们依赖于光栅化来定期采样光线对世界的看法。然而，由于这种离散采样，问题出现了，因为眼睛看到的位置与光线看到的位置不是一对一的映射。当光线对一个表面的采样频率低于人眼时，就会出现各种走样问题。即使取样率是可比较的，也存在偏差问题，因为表面取样的位置与人眼看到的位置略有不同。</strong></p>
<p><strong>阴影体积提供了一个精确的解析解，因为光线与表面的相互作用产生了一组三角形，定义了任何给定位置是处于光照还是阴影中。该算法在GPU上实现时的不可预测成本是一个严重的缺点。近年来探索的改进是诱人的，但还没有一个“存在的证据”被采纳在商业应用。</strong></p>
<p><strong>另一种分析阴影测试方法在较长时期内可能有潜力:光线追踪。在第11.2.2节中详细描述了它的基本思想，特别是对于阴影。一束光线从接收器位置射向光线。如果发现任何物体挡住了光线，接收器就处于阴影中。快速射线跟踪器的大部分代码都致力于生成和使用分层数据结构，以最小化每条射线所需的对象测试数量。为动态场景构建和更新这些结构是一个有几十年历史的话题和持续的研究领域。</strong></p>
<p><strong>另一种方法是使用GPU的光栅化硬件来查看场景，但是除了z深度之外，还存储了关于光线每个网格单元中闭塞器边缘的额外信息。例如，想象在每个阴影贴图texel中存储重叠网格单元格的三角形列表。这样的列表可以通过保守栅格化生成，即如果三角形的任何部分重叠像素，而不仅仅是像素的中心，则生成一个碎片(章节23.1.2)。这种方案的一个问题是，每个texel的数据量通常需要被限制，这反过来会导致在确定每个接收器位置的状态时不准确。考虑到GPU的现代链表原理，每个像素存储更多数据当然是可能的。然而，除了物理内存限制外，在每个texel的列表中存储可变数量的数据的问题是GPU处理会变得非常低效，因为单个warp可能有几个片段需要检索和处理许多项的线程，而其余线程是空闲的，没有工作要做。构造着色器以避免由于动态“if”语句和循环导致的线程发散对性能至关重要。</strong></p>
<p><strong>在阴影贴图中存储三角形或其他数据并测试接收器位置的另一种方法是翻转问题，存储接收器位置，然后针对每个位置测试三角形。Johnson等人和Aila and Laine首先探索了这种保存接收机位置的概念，称为不规则z-缓冲区(IZB)。这个名字有点误导人，因为缓冲区本身有一个正常的、规则的阴影贴图形状。相反，缓冲区的内容是不规则的，因为每个阴影贴图texel将有一个或多个接收器位置存储在里面，或者可能根本没有。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210929131651.png" class="" title="image-20210929131651">

<p>不规则z-buffer。在左上角，眼睛在像素中心产生了一组点。两个三角形形成一个立方体的面显示。在右上角，这些点是从光线的角度显示出来的。在左下角，一个阴影贴图网格被应用。对于每个texel，将生成网格单元格内所有点的列表。在右下角，通过保守的栅格化对红色三角形进行阴影测试。在每一个被触摸的texel(显示为淡红色)上，它列表中的所有点都被测试在光线下的可见性。(下面的光栅图像由Timo Aila和Samuli Laine提供。)</p>
<p><strong>使用Sintorn等人和Wyman等人提出的方法，一个多通道算法创建IZB，并测试其内容从光的能见度。首先，场景从眼睛渲染，以找到从眼睛看到的表面的z深度。这些点被转换为场景中的光视图，并且从这个集合中形成了光的截锥。然后这些点被储存在光的IZB中，每一个点都被放入一个对应texel的列表中。注意，有些列表可能是空的，光线可以看到空间的体积，但眼睛看不到表面。遮光器被保守地栅格化到光的IZB，以确定是否有任何点被隐藏，因此在阴影中。保守的栅格化确保了，即使一个三角形没有覆盖光像素的中心，它也会被测试到它可能重叠的点上。</strong></p>
<p><strong>可见性测试在像素着色器中进行。测试本身可以看作是光线追踪的一种形式。光线从图像点的位置到光线产生。如果一个点在三角形的内部，并且距离三角形的平面更远，那么这个点就被隐藏了。一旦所有的遮挡器都被栅格化，光的可见性结果就被用来遮蔽表面。这个测试也被称为截锥跟踪，因为三角形可以被认为是定义了一个视图截锥，检查其体积中包含的点。</strong></p>
<p><strong>仔细的编码是使这种方法与GPU良好工作的关键。Wyman等人指出，他们的最终版本比最初的原型快两个数量级。部分性能的提高是直接的算法改进，比如剔除表面法线背光的图像点(所以总是没有光照)，避免为空像素生成碎片。其他性能的提高来自于改进GPU的数据结构，以及通过在每个像素中使用短的、相似长度的点列表来最小化线程发散。上图显示了一个带有长列表的低分辨率阴影图。理想情况是每个列表有一个图像点。更高的分辨率提供更短的列表，但也增加了闭塞器生成的碎片的数量进行评估。</strong></p>
<p><strong>从上图左下方的图像中可以看出，由于透视效果的影响，地平面左侧可见点的密度明显高于右侧。使用级联阴影贴图可以通过聚焦更接近眼睛的光线贴图来降低这些区域的列表大小。</strong></p>
<p><strong>这种方法避免了其他方法的采样和偏差问题，并提供了完美的清晰阴影。出于美学和感知的原因，软阴影通常是需要的，但可能会有偏置问题与附近的闭塞器，如Peter Panning。Story和Wyman探索混合阴影技术。核心思想是使用遮挡距离来混合IZB和PCSS阴影，当遮挡距离较近时使用硬阴影结果，当遮挡距离较远时使用软阴影结果。参见下图。阴影质量对于附近的物体通常是最重要的，所以IZB的成本可以通过只在一个选定的子集上使用这种技术来降低。这个解决方案已经成功地应用于电子游戏中。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210929131955.png" class="" title="image-20210929131955">

<p>在左边，PCF为所有物体提供均匀柔和的阴影。在中间，PCSS通过距离遮挡器的距离来软化阴影，但是树枝阴影重叠在箱子的左上角会产生伪影。在右侧，来自IZB的锐利阴影与来自PCSS的柔和阴影混合，得到了改进的结果。(图片来自育碧的《Tom Clancy’s The Division》。)</p>
<h2 id="Other-Applications-其他应用"><a href="#Other-Applications-其他应用" class="headerlink" title="Other Applications 其他应用"></a>Other Applications 其他应用</h2><p><strong>将阴影贴图定义为一个空间体量，将光与暗分开，也可以帮助确定物体的哪些部分需要阴影。Gollent描述了CD Projekt的地形阴影系统如何计算每个仍然被遮挡的区域的最大高度，然后不仅可以用于地形，还可以用于场景中的树木和其他元素的阴影。为了找到每个高度，可见区域的阴影图被渲染为太阳。然后检查每个地形高度场位置的太阳能见度。如果在阴影中，太阳第一次可见的高度是通过增加一个固定的步长来估计的，直到太阳进入视野，然后执行二元搜索。换句话说，我们沿着一条垂直线前进，并迭代以缩小它与分离光明与黑暗的阴影地图表面相交的位置。邻近高度被插值，以在任何位置找到这个闭塞高度。在下图中可以看到一个用于地形高程软阴影的例子。我们将在第14章中看到更多光线穿越光明和黑暗区域的用法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210929132203.png" class="" title="image-20210929132203">

<p>地形与太阳第一次看到的高度计算每个高度场位置。注意沿着阴影边缘的树是如何被正确遮蔽的。(CD PROJEKT R, The Witcher R是CD PROJEKT Capital Group的注册商标。The Witcher game c CD PROJEKT S.A.版权所有《巫师》游戏是根据Andrzej Sapkowski的散文改编的。所有其他版权和商标均为其各自所有者的财产。)</p>
<p><strong>最后一个值得一提的方法是渲染屏幕空间阴影。阴影图往往不能产生精确的遮挡小特征，因为他们的分辨率有限。这在渲染人脸时尤其成问题，因为我们特别容易注意到人脸上的任何视觉伪影。例如，渲染发光的鼻孔(当不是有意的时候)看起来很刺耳。虽然使用更高分辨率的阴影图或单独的阴影图只针对感兴趣的区域可以有所帮助，但另一种可能性是利用已经存在的数据。在大多数现代的渲染引擎中，深度缓冲从相机的角度，来自早期的预印版，在渲染过程中是可用的。存储在其中的数据可以当作高度场来处理。通过迭代采样这个深度缓冲区，我们可以执行一个射线行进过程(章节6.8.1)，并检查朝向光线的方向是否未被遮挡。虽然成本很高，因为它需要重复采样深度缓冲区，但这样做可以为过场动画中的特写提供高质量的结果，在这方面花费额外的毫秒通常是合理的。该方法由Sousa at al.提出，目前在许多游戏引擎中普遍使用。</strong></p>
<p><strong>总结整个章节，阴影映射在某些形式是迄今为止最常用的算法用于投射到任意曲面形状上的阴影。级联阴影贴图提高采样质量时，阴影投射在一个大的区域，如室外场景。通过SDSM找到一个合适的近平面最大距离可以进一步提高精度。接近百分比滤波(PCF)使阴影具有一定的柔和性，接近百分比软阴影(PCSS)及其变体具有接触硬化性，而不规则z缓冲区可以提供精确的硬阴影。滤波后的阴影图提供了快速的软阴影计算，当遮挡器远离接收器时工作得特别好，就像地形一样。最后，屏幕空间技术可以用于提高精度，尽管成本相当高。</strong></p>
<p><strong>在本章中，我们重点讨论了当前应用程序中使用的关键概念和技术。每一种都有自己的优势，选择取决于世界的大小、组成(静态内容vs动画)、材质类型(不透明、透明、头发或烟雾)，以及灯光的数量和类型(静态或动态;本地或遥远;点、点或区域)，以及一些因素，如底层纹理可以隐藏任何工件的程度。GPU的性能在不断发展和改进，因此我们预计在未来几年将继续看到新的算法能够很好地映射到硬件上。例如，章节19.10.1中描述的稀疏纹理技术已被应用于阴影贴图存储以提高分辨率。sintorn用一种创造性的方法，K¨ampe等人探索了将用于照明的二维阴影图转换为三维体素集的想法(小盒子;见13.10节)。使用体素的一个优点是它可以被分类为有光或有影，因此需要最小的存储空间。高度压缩稀疏体素八叉树表示为大量的光和静态遮挡器存储阴影。Scandolo等人将他们的压缩技术与使用双阴影映射的基于区间的方案结合起来，得到了更高的压缩率。Kasyan[865]使用体素锥跟踪(第13.10节)从区域灯光生成柔和阴影。如图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210929132401.png" class="" title="image-20210929132401">

<p>在顶部是一个用基本的软阴影近似生成的图像。在底部是基于体素的区域光阴影，使用圆锥跟踪，在场景的体素化。注意，汽车的阴影更加弥散。光照也因一天中时间的变化而不同。(图片由Crytek提供。)</p>
<h1 id="8-Light-and-Color-光照和颜色"><a href="#8-Light-and-Color-光照和颜色" class="headerlink" title="8 Light and Color 光照和颜色"></a>8 Light and Color 光照和颜色</h1><h2 id="Light-Quantities-光量"><a href="#Light-Quantities-光量" class="headerlink" title="Light Quantities 光量"></a>Light Quantities 光量</h2><p><strong>任何基于物理的渲染方法的第一步都是以精确的方式量化光。首先介绍辐射度量学，因为这是与光的物理传输有关的核心领域。我们接着讨论光度学，这涉及由人眼灵敏度加权的光值。我们对颜色的感知是一种心理物理现象:对物理刺激的心理感知。颜色感知在比色法一节中讨论。最后讨论了用RGB颜色值绘制图像的有效性。</strong></p>
<h3 id="Radiometry-辐射度量学"><a href="#Radiometry-辐射度量学" class="headerlink" title="Radiometry 辐射度量学"></a>Radiometry 辐射度量学</h3><p><strong>辐射度量学研究的是电磁辐射的测量。这种辐射以波的形式传播，将在第9.1节中详细讨论。不同波长的电磁波——相同相位的两个相邻点之间的距离，例如两个相邻的峰——往往具有不同的性质。在自然界中，电磁波存在于一个巨大的波长范围，从长度不到百分之一纳米的伽马波到数万公里长的极低频(ELF)无线电波。人类可以看到的海浪由这个范围的一小部分组成，从紫光的约400纳米到红光的略高于700纳米。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930102945.png" class="" title="image-20210930102945">

<p>可见光的波长范围，在整个电磁波谱中显示。</p>
<p><strong>辐射量的存在是为了测量电磁辐射的各个方面:总能量、功率(随时间变化的能量)和功率密度与面积、方向或两者有关。下表总结了这些量。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930103037.png" class="" title="image-20210930103037">

<p>辐射的量和单位。</p>
<p><strong>在放射学中，基本单位是辐射通量Φ。辐射通量是辐射能随时间——功率的流动，以瓦特(W)为单位。</strong></p>
<p><strong>辐照度是辐射通量相对于面积的密度，即dΦ/ dA。辐照度是根据一个区域来定义的，这个区域可能是空间中的一个想象区域，但通常是物体的表面。它的计量单位是瓦特每平方米。</strong></p>
<p><strong>在我们讨论下一个量之前，我们需要先介绍立体角的概念，它是角概念的三维扩展。角度可以被认为是一个平面上连续方向集的大小的度量单位，其弧度值等于这组方向集与半径为1的外圆相交的弧的长度。同样，立体角测量三维空间中连续方向集的大小，用立体角(缩写为“sr”)测量，立体角是由半径为1的外接球面上的交点面积定义的。实心角用ω符号表示。</strong></p>
<p><strong>在二维空间中，2π弧度的角覆盖整个单位圆。将此扩展到三维，一个4π立体角将覆盖单位球的整个面积。一个立体角的大小可以在下图中看到。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930103310.png" class="" title="image-20210930103310">

<p>圆锥体从圆角球的剖面图上去掉一个立体角的圆锥体。形状本身与测量无关。球表面的覆盖率是关键。</p>
<p><strong>现在我们可以引入辐射强度I，这是相对于方向的通量密度——更准确地说，是立体角(dΦ/dω)。它的测量单位是瓦特每立体角。</strong></p>
<p><strong>最后，辐射亮度(L)是对单条射线的电磁辐射的测量。更准确地说，它被定义为辐射通量相对于面积和立体角的密度(dΦ²/dAdω)。这个面积是在垂直于射线的平面上测量的。如果在其他方向上对表面施加辐射，则必须使用余弦校正因子。你可能会遇到用术语“投影面积”来指代这个校正因子的辐亮度定义。</strong></p>
<p><strong>亮度是传感器(如眼睛或相机)所测量的(更多细节见9.2节)，所以它在渲染中是最重要的。计算着色方程的目的是计算沿给定光线从着色表面点到相机的亮度。沿着这条射线的L的值与cshaded在物理上是等价的(第5章)。辐射的公制单位是瓦特每平方米每立体角。</strong></p>
<p><strong>环境中的辐亮度可以看作是五个变量(或六个变量，包括波长)的函数，称为辐亮度分布。其中三个变量指定位置，另外两个指定方向。这个函数描述所有在空间中任何地方传播的光。一种考虑渲染过程的方法是，眼睛和屏幕定义一个点和一组方向(例如，通过每个像素的光线)，这个函数在每个方向的眼睛处进行评估。在第13.4节中讨论的基于图像的渲染使用了一个相关的概念，称为光场。</strong></p>
<p><strong>在着色方程中，辐亮度常以Lo(x, d)或Li(x, d)的形式出现分别表示从x点发出的辐亮度和进入x点的辐亮度。方向向量d表示射线的方向，按照惯例，射线总是指向远离x的方向。而对于Li来说，这种惯例可能有些令人困惑，由于d指向与光传播方向相反的方向，因此便于计算点积等。</strong></p>
<p><strong>辐亮度的一个重要特性是它不受距离的影响，忽略了大气效应，如雾。换句话说，一个表面将有相同的辐射，不管它距离观众的距离。当距离越远时，表面覆盖的像素越少，但从表面到每个像素的辐亮度是恒定的。</strong></p>
<p><strong>大多数光波包含许多不同波长的混合物。这通常被可视化为光谱功率分布(SPD)，这是一个显示光的能量如何在不同波长分布的图。下图显示了三个示例。值得注意的是，尽管在图中，中间和底部spd之间存在显著差异，但它们被认为是相同的颜色。很明显，人眼的光谱仪很差。我们将在8.1.3节中详细讨论颜色视觉。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930103813.png" class="" title="image-20210930103813">

<p>三种不同光波的光谱功率分布。顶部的SPD是绿色激光器，它的光谱分布非常窄。它的波形与简单的正弦波相似。中间的SPD用于由相同的绿色激光器和两个额外的激光器组成的光，一个红色和一个蓝色。这些激光器的波长和相对强度对应于RGB激光投影显示器，显示中性白色。底部的SPD是标准的D65光源，这是一个典型的中性白色参考，旨在代表室外照明。这种spd的能量持续分布在可见光谱中，是典型的自然照明。</p>
<p><strong>所有的辐射量都有光谱分布。由于这些分布是密度在波长上的分布，它们的单位是原始量除以纳米的单位。例如，辐照度的光谱分布以瓦特每平方米每纳米为单位。</strong></p>
<p><strong>由于使用完整的spd进行渲染是很笨拙的，特别是在交互速率下，在实践中辐射量被表示为RGB三元组。在8.1.3节中，我们将解释这些三元组与光谱分布的关系。</strong></p>
<h3 id="Photometry-光度学"><a href="#Photometry-光度学" class="headerlink" title="Photometry 光度学"></a>Photometry 光度学</h3><p><strong>辐射测量学只研究物理量，不考虑人的感知。一个相关的领域，光度学，就像辐射测量学，除了它通过人眼的灵敏度来衡量一切。通过与CIE光度曲线相乘，辐射计算的结果被转换为光度单位，1是一条以555 nm为中心的钟形曲线，代表眼睛对不同波长光的响应。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930104054.png" class="" title="image-20210930104054">

<p>光度曲线。</p>
<p><strong>转换曲线和测量单位是光度学理论和辐射学理论的唯一区别。每个辐射量都有一个等效的光度量。下表显示了每一种的名称和单位。单位都有预期的关系(lux是照明度每平方米)。虽然从逻辑上应该是基本单位，但历史上candela被定义为基本单位，其他单位都是从它派生出来的。在北美，照明设计师使用已被废弃的英制测量单位“ foot-candle”(fc)来代替lux来测量照明度。无论哪种情况，照度是大多数光度计测量的，它在照明工程中很重要。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930104146.png" class="" title="image-20210930104146">

<p>辐射和光度的量和单位。</p>
<p><strong>亮度通常用来描述平面的亮度。例如，高动态范围(HDR)电视屏幕的峰值亮度通常在500到1000nit之间。相比之下，晴空的亮度约为8000nit，60瓦的灯泡约为12万nit，地平线上的太阳约为60万nit。</strong></p>
<h3 id="Colorimetry-比色法"><a href="#Colorimetry-比色法" class="headerlink" title="Colorimetry 比色法"></a>Colorimetry 比色法</h3><p><strong>在第8.1.1节中，我们已经看到我们对光线颜色的感知与光线的SPD(光谱功率分布)密切相关。我们也看到这不是一个简单的一对一对应。上上图中底部和中间的SPDs是完全不同的，但被认为是完全相同的颜色。比色法研究光谱功率分布与颜色感知之间的关系。</strong></p>
<p><strong>人类能分辨大约一千万种不同的颜色。在颜色感知方面，眼睛的视网膜上有三种不同类型的锥状受体，每种受体对不同波长的光作出不同的反应。其他动物有不同数量的颜色感受器，在某些情况下多达15个。所以，对于一个特定的SPD，我们的大脑只能从这些受体接收到三种不同的信号。这就是为什么只用三个数字就可以精确地代表任何颜色刺激。</strong></p>
<p><strong>但是哪三个数字呢?CIE出了一套测量颜色的标准条件，并利用这些条件进行了配色实验。在配色中，三种颜色的光投射在白色屏幕上，使它们的颜色叠加在一起，形成一个补丁。要匹配的测试颜色投影在这个补丁旁边。测试色斑是单一波长的。然后观察者可以使用校准到范围加权[−1,1]的旋钮来改变三种颜色的灯，直到测试颜色匹配。需要一个负权重来匹配一些测试颜色，这样的权重意味着相应的光被添加到波长的测试色斑中。下图显示了三个灯(称为r、g和b)的一组测试结果。灯几乎是单色,每个狭隘的能量分布集中在一个波长:r：645 nm , g：526nm,b：444 nm。每一组相关的函数匹配的重量测试补丁波长称为比对功能。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930105039.png" class="" title="image-20210930105039">

<p>r, g，和b 2度颜色匹配曲线，来自Stiles和Burch。这些配色曲线不能与配色实验中使用的光源的光谱分布相混淆，后者是纯波长的。</p>
<p><strong>这些函数提供的是一种将频谱功率分布转换为三个值的方法。给定单一波长的光，可以从图中读出三种颜色的光设置，设置旋钮，并创建光照条件，使屏幕上的两个光块产生相同的感觉。对于任意的光谱分布，颜色匹配函数可以乘以分布和每个结果曲线下的面积(即积分)给出相对数量将彩色的光设置成与光谱产生的可感知的颜色相匹配。相当不同的光谱分布可以解析相同的三个权值，即它们在观察者看来是一样的。给出匹配权重的谱分布称为超谱分布。</strong></p>
<p><strong>三个加权的r、g、b光不能直接代表所有可见的颜色，因为它们的配色函数对不同波长的光都有负权值。CIE提出了三种不同的假设光源的颜色匹配函数，对所有可见波长都是积极的。这些曲线是原始的r, g, b颜色匹配函数的线性组合。这就要求光源的光谱功率分布在某些波长是负的，所以这些光是无法实现的数学抽象。它们的颜色匹配函数记为ˉx(λ)， ˉy(λ)， ˉz(λ)，如下图所示。配色函数y(λ)与光度曲线相同，因为辐亮度通过该曲线转换为亮度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930105434.png" class="" title="image-20210930105434">

<p>Judd-Vos-modified CIE(1978)二度颜色匹配函数。注意，这两个x是同一曲线的一部分。</p>
<p><strong>与前面的颜色匹配函数集一样，ˉx(λ)，ˉy(λ)，ˉz(λ)被用来通过乘法和积分将任何SPDs(λ)减少到三个数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930105528.png" class="" title="image-20210930105528">

<p><strong>这些X、Y和Z三刺激值是在CIE XYZ空间中定义颜色的权重。把颜色分为亮度(亮度)和色度通常是很方便的。色度是一种与亮度无关的颜色的特性。例如，两种深浅不同的蓝色，一种深一种亮，尽管亮度不同，却可以具有相同的色度。</strong></p>
<p><strong>为此，CIE通过将颜色投射到X +Y +Z = 1平面上定义了一个二维色度空间。参见下图。这个空间中的坐标称为x和y，计算方法如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930105722.png" class="" title="image-20210930105722">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930105757.png" class="" title="image-20210930105757">

<p>CIE RGB三原色的RGB颜色立方体显示在XYZ空间，以及它在X + Y + Z = 1平面上的投影(紫色)。蓝色轮廓线包含可能的色度值空间。从原点辐射出来的每条线都有一个恒定的色度值，只在亮度上变化。</p>
<p><strong>z值不提供额外的信息，所以通常省略它。色度坐标x和y值的曲线称为CIE 1931色度图。参见下图。图中曲线的轮廓表示了可见光谱的颜色所处的位置，而连接光谱两端的直线称为紫色线。黑点表示光源D65的色度，它是常用的白点，用来定义白色或无色(无色)刺激的色度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930105927.png" class="" title="image-20210930105927">

<p>CIE 1931色度图。这条曲线用相应的纯色的波长标记。白色三角形和黑点分别显示色域和白点，用于sRGB和Rec. 709颜色空间。</p>
<p><strong>总而言之，我们首先进行了一个实验，使用了三种单波长光，并测量了每种光需要多少光才能与其他波长的光相匹配。有时这些纯光必须添加到被观察的样品，以匹配。这提供了一组颜色匹配函数，将它们组合起来创建一个没有负值的新集合。有了这个非负的颜色匹配函数集在手，我们可以将任何光谱分布转换为XYZ坐标，XYZ坐标定义了颜色的色度和亮度，可以简化为xy来描述色度，保持亮度不变。</strong></p>
<p><strong>给定一个颜色点(x, y)，从白点通过这个点画一条线到边界(光谱线或紫色线)。色点与区域边缘距离的相对距离就是色的激发纯度。区域边缘上的点定义了主导波长。这些比色术语在图形学中很少遇到。相反，我们使用饱和度和色相，它们分别与激发纯度和主导波长松散相关。饱和度和色调的更精确定义可以在Stone和其他人的书中找到。</strong></p>
<p><strong>色度图描述了一个平面。要完全描述一种颜色需要的第三个维度是Y值，即亮度。这些定义了所谓的xyY坐标系。色度图对于理解颜色在渲染中是如何使用的，以及渲染系统的限制是很重要的。电视或计算机显示器通过使用R、G和B颜色值的一些设置来显示颜色。每个颜色通道控制一个显示原色，该原色发出具有特定光谱功率分布的光。这三种原色中的每一种都根据其各自的颜色值进行缩放，然后将它们加在一起，形成观众所感知的单一光谱功率分布。</strong></p>
<p><strong>色度图中的三角形表示典型电视或电脑显示器的色域。三角形的三个角是三原色，即屏幕所能显示的最饱和的红色、绿色和蓝色。色度图的一个重要性质是，这些极限颜色可以用直线连接起来，以显示整个显示系统的极限。直线代表了通过混合这三种原色所能显示的颜色的极限。白点表示当R、G、B颜色值相等时显示系统产生的色度。重要的是要注意显示系统的全色域是一个三维体积。色度图只显示了这个体积在二维平面上的投影。更多信息请参阅Stone的书。</strong></p>
<p><strong>在渲染中有几个感兴趣的RGB空间，每个都由R、G和B三原色和一个白点定义。为了比较它们，我们将使用一种不同类型的色度图，称为CIE 1976 UCS(均匀色度比例尺)图。这张图是CIELUV颜色空间的一部分，CIE(以及另一个颜色空间CIELAB)采用了CIELUV颜色空间，目的是为XYZ空间提供更统一的感知选择[1707]。在CIE XYZ空间中，颜色对的差异可以达到20倍。CIELUV在此基础上进行了改进，将比率降低到最大4倍。这种增加的感知一致性使得1976年的图在比较RGB空间的色域方面比1931年的图要好得多。对感知统一颜色空间的持续研究最近产生了集成电路ICTCP和Jzazbz空间。这些颜色空间比CIELUV在感知上更统一，特别是对于现代显示器的高亮度和饱和颜色。但是，基于这些颜色空间的色度图还没有被广泛采用，所以我们在本章中使用CIE 1976 UCS图，例如下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930110334.png" class="" title="image-20210930110334">

<p>一张CIE 1976 UCS图显示了三个RGB颜色空间的原色和白点:sRGB, DCI-P3，和ACEScg。sRGB图也可以用于Rec. 709，因为这两个颜色空间有相同的原色和白点。</p>
<p><strong>在上图所示的三个RGB空间中，sRGB是目前为止在实时渲染中最常用的。需要注意的是，在本节中，我们使用“sRGB颜色空间”来指具有sRGB原色和白点的线性颜色空间，而不是第5.6节中讨论的非线性sRGB颜色编码。大多数计算机显示器都是为sRGB颜色空间设计的，同样的原色和白点也适用于Rec. 709颜色空间，这用于高清电视显示器，因此对游戏机来说很重要。然而，越来越多的显示器正在使用更宽的色域。一些用于照片编辑的计算机显示器使用adobe1998彩色空间(未显示)。DCI-P3彩色空间最初是为制作故事片而开发的，现在正得到更广泛的应用。苹果已经在从iphone到mac的产品线中采用了这种颜色空间，其他制造商也纷纷效仿。虽然超高清(UHD)内容和显示器被指定使用极宽色域Rec. 2020彩色空间，但在很多情况下，DCI-P3实际上也被用作UHD的彩色空间。Rec. 2020没有在上图显示，但它的色域非常接近图中的第三个颜色空间，ACEScg。ACEScg色彩空间由美国电影艺术与科学学院(AMPAS)开发，用于故事片的计算机图形渲染。它不打算用作显示颜色空间，而是用作呈现的工作颜色空间，在呈现后将颜色转换为适当的显示颜色空间。</strong></p>
<p><strong>虽然目前sRGB颜色空间在实时渲染中无处不在，但更宽的颜色空间的使用可能会增加。最直接的好处是针对宽色域显示器的应用程序，但即使针对sRGB或Rec. 709显示器的应用程序也有优势。常规的渲染操作，如乘法，在不同的颜色空间中执行时会得到不同的结果，有证据表明，在DCI-P3或ACEScg空间中执行这些操作产生的结果比在线性sRGB空间中执行更精确。</strong></p>
<p><strong>从RGB空间到XYZ空间的转换是线性的，可以用由RGB空间的原色和白点导出的矩阵来完成。通过矩阵反演和串接，可以导出矩阵从XYZ转换到任何RGB空间，或在两个不同的RGB空间之间。注意，在这样的转换之后，RGB值可以是负数或大于1。这些是超出色域的颜色，也就是。，在目标RGB空间中不可复制。可以使用各种方法将这些颜色映射到目标RGB域。</strong></p>
<p><strong>一种常用的转换是将RGB颜色转换为灰度亮度值。因为亮度与Y系数相同，所以这个操作只是RGB到XYZ转换的“Y部分”。换句话说，它是RGB系数和RGB到XYZ矩阵的中间行之间的点积。对于sRGB和Rec. 709空格，公式为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930110837.png" class="" title="image-20210930110837">

<p><strong>这让我们再次回到光度曲线。这条曲线代表了一个标准观察者的眼睛对不同波长的光的反应，乘以三次原色的光谱功率分布，每条结果曲线都被整合。这三个权重就是上面亮度方程的形式。灰度强度值不等于红、绿、蓝的原因是眼睛对不同波长的光有不同的敏感性。</strong></p>
<p><strong>比色法可以告诉我们两种颜色刺激是否匹配，但它不能预测它们的外观。给定的XYZ颜色刺激的出现很大程度上取决于诸如光照、周围的颜色和之前的条件等因素。颜色外观模型(CAM)，如CIECAM02试图处理这些问题并预测最终的颜色外观。</strong></p>
<p><strong>色彩外观建模是更广泛的视觉感知领域的一部分，其中包括掩蔽等效应。这是指在物体上放置高频率、高对比度的图案往往会掩盖缺陷。换句话说，贴图(如Persian rug)将有助于伪装色带和其他着色伪影，这意味着渲染这样的表面会需要更少的努力。</strong></p>
<h3 id="Rendering-with-RGB-Colors-RGB颜色渲染"><a href="#Rendering-with-RGB-Colors-RGB颜色渲染" class="headerlink" title="Rendering with RGB Colors RGB颜色渲染"></a>Rendering with RGB Colors RGB颜色渲染</h3><p><strong>严格地说，RGB值代表知觉量而不是物理量。从技术上讲，使用它们进行基于物理的渲染是一个类别错误。正确的方法是对光谱数量进行绘制计算，通过密集采样或在合适的基础上投影来表示，并在最后转换为RGB颜色。</strong></p>
<p><strong>例如，最常见的渲染操作之一是计算从对象反射的光。物体的表面通常会反射一些波长的光比其他波长的光更多，正如它的光谱反射曲线所描述的那样。计算反射光颜色的严格正确方法是将入射光的SPD乘以每个波长的光谱反射率，得到反射光的SPD，然后将其转换为RGB颜色。相反，在RGB渲染器中，光线和表面的RGB颜色相乘得到反射光的RGB颜色。在一般情况下，这并不能给出正确的结果。为了说明这一点，我们将看一个有点极端的例子，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930111408.png" class="" title="image-20210930111408">

<p>上图显示的是一种用于投影屏幕的材料的光谱反射率。下面两幅图显示了相同RGB颜色的两种光源的光谱功率分布:中间图是RGB激光投影仪，底部图是D65标准光源。屏幕材料会反射大约80%的激光投影仪的光，因为它的反射峰与投影仪的原色一致。然而，它将反射不到20%的来自D65光源的光，因为大部分光源的能量在屏幕的反射峰值之外。这个场景的RGB渲染可以预测屏幕对两种光的反射强度是相同的。</p>
<p><strong>我们的例子展示了为使用激光投影仪而设计的屏幕材料。它在匹配激光投影仪波长的窄波段中具有高反射率，而在大多数其他波长中具有低反射率。这使得它反射来自投影仪的大部分光，但吸收来自其他光源的大部分光。在这种情况下，RGB渲染器将产生严重误差。</strong></p>
<p><strong>然而，上图所示的情况远非典型。实际中遇到的表面的光谱反射率曲线要平滑得多，如下图所示。典型的光源spd类似于D65光源，而不是示例中的激光投影仪。当光源SPD和表面光谱反射率均为光滑时，RGB绘制引入的误差相对较小。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930111517.png" class="" title="image-20210930111517">

<p>黄色香蕉的光谱反射率。</p>
<p><strong>在预测渲染应用中，这些细微的错误可能很重要。例如，两个光谱反射曲线在一个光源下可能具有相同的颜色外观，而在另一个光源下则不然。这个问题被称为异聚体故障或光源异聚体，在喷漆修理的车身部件时就会引起严重的关注。RGB渲染在试图预测这种效果的应用程序中是不合适的。</strong></p>
<p><strong>然而，对于大多数渲染系统，特别是那些交互式应用，不是为了产生预测模拟，RGB渲染惊人地好。即使是故事片离线渲染也只是最近才开始使用光谱渲染，而且它还远未普及。</strong></p>
<p><strong>本节只涉及色彩科学的基础知识，主要是让人们意识到光谱与颜色三幅图的关系，并讨论设备的局限性。下一节将讨论一个相关的主题，即渲染场景颜色到显示值的转换。</strong></p>
<h2 id="Scene-to-Screen-场景到屏幕"><a href="#Scene-to-Screen-场景到屏幕" class="headerlink" title="Scene to Screen 场景到屏幕"></a>Scene to Screen 场景到屏幕</h2><p><strong>本书接下来的几章将重点讨论基于物理的渲染问题。给定一个虚拟场景，基于物理的渲染的目标是计算如果场景是真实的，将会出现的亮度。然而，在这一点上，工作还远远没有完成。最终的结果(显示的帧缓冲区中的像素值)仍然需要确定。在本节中，我们将介绍在此确定过程中涉及的一些考虑事项。</strong></p>
<h3 id="High-Dynamic-Range-Display-Encoding-高动态范围显示编码"><a href="#High-Dynamic-Range-Display-Encoding-高动态范围显示编码" class="headerlink" title="High Dynamic Range Display Encoding 高动态范围显示编码"></a>High Dynamic Range Display Encoding 高动态范围显示编码</h3><p><strong>本节中的内容建立在第5.6节的基础上，该节涵盖了显示编码。我们决定将高动态范围(HDR)显示的覆盖到本节，因为它需要一些主题的背景知识，比如色域，而这些主题在本书的这一部分中还没有讨论过。</strong></p>
<p><strong>第5.6节讨论了标准动态范围(SDR)监视器的显示编码，SDR监视器通常使用sRGB显示标准，SDR电视使用Rec. 709和Rec. 1886标准。这两套标准具有相同的RGB色域和白点(D65)，以及有点相似(但不相同)的非线性显示编码曲线。它们也有大致相似的参考白亮度水平(sRGB为80 cd/m², Rec. 709/1886为100 cd/m²)。这些亮度规格并没有被显示器和电视制造商严格遵守，他们在实践中倾向于制造更明亮的白光水平的显示器。</strong></p>
<p><strong>HDR显示器使用Rec. 2020和Rec. 2100标准。Rec. 2020定义了一个明显更宽的色域的颜色空间，如下图所示，和Rec. 709和sRGB颜色空间相同的白点(D65)。Rec. 2100定义了两种非线性显示编码:感知量化器(PQ)和混合对数伽马(HLG)。HLG编码在渲染情况下使用的不多，所以我们在这里将重点放在PQ上，它定义的峰值亮度值为10,000 cd/m²．</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930112118.png" class="" title="image-20210930112118">

<p>一张CIE 1976 UCS图显示了Rec. 2020和sRGB/Rec的色域和白点(D65)。709彩色空间。还显示了DCI-P3颜色空间的色域，以供比较。</p>
<p><strong>虽然峰值亮度和色域规格对编码目的很重要，但就实际显示而言，它们有些不切实际。在撰写本文时，很少有消费级HDR显示器的峰值亮度水平超过1500 cd/m²．在实际操作中，显示域比Rec. 2020更接近DCI-P3的显示域(也如上图所示)。因此，HDR显示器执行从标准规范到实际显示功能的内部色调和色域映射。这个映射可能会受到应用程序传递的元数据的影响，以指示内容的实际动态范围和色域。</strong></p>
<p><strong>从应用程序方面来看，将图像传输到HDR显示器有三种路径，但根据显示器和操作系统的不同，这三种路径并非都可用:</strong></p>
<pre><code>**1.HDR10：广泛支持在HDR显示器以及PC和控制台操作系统。帧缓冲区格式为每像素32位，每个RGB通道10位无符号整数位，alpha为2位。采用PQ非线性编码和Rec 2020颜色空间。每个HDR10显示模型执行其自己的色调映射，这不是标准化的或文档化的。**

**2.scRGB(线性变体)：仅在Windows操作系统上支持。名义上它使用sRGB原色和白色级，尽管这两者都可以被超越，因为标准支持RGB值小于0和大于1。帧缓冲区格式为每个通道16位，并存储线性RGB值。它可以与任何HDR10显示，因为驱动程序转换为HDR10。它主要是为了方便和向后兼容sRGB。**

**3.Dolby Vision：专用格式，还没有广泛支持在显示器或任何控制台(在撰写本文时)。它使用自定义的每通道12位帧缓冲格式，并使用PQ非线性编码和Rec. 2020颜色空间。显示内部色调映射在模型之间是标准化的(但没有文档记录)。**
</code></pre>
<p><strong>Lottes指出，实际上还有第四种选择。如果仔细调整曝光和颜色，那么HDR显示器可以通过规则的SDR信号路径驱动，效果很好。</strong></p>
<p><strong>scRGB以外的任何选项,作为显示编码步骤的一部分,应用程序需要将像素的RGB值呈现工作空间Rec.2020——需要一个3×3矩阵变换和应用PQ编码,这是更昂贵的比Rec.709或sRGB编码功能。Patry给出了一个廉价的PQ曲线近似。在HDR显示器上合成用户界面(UI)元素时需要特别注意，以确保用户界面是清晰的，并处于舒适的亮度水平。</strong></p>
<h3 id="Tone-Mapping-色调映射"><a href="#Tone-Mapping-色调映射" class="headerlink" title="Tone Mapping 色调映射"></a>Tone Mapping 色调映射</h3><p><strong>在第5.6节和8.2.1节中，我们讨论了显示编码，即为显示硬件将线性亮度值转换为非线性代码值的过程。显示编码所应用的函数是显示器的光电传递函数(EOTF)的逆函数，它确保输入的线性值与显示器发出的线性辐射度匹配。我们之前的讨论忽略了呈现和显示编码之间的一个重要步骤，我们现在准备探索这个步骤。</strong></p>
<p><strong>色调映射或色调再现是将场景辐亮度值转换为显示辐亮度值的过程。在此步骤中应用的转换称为端到端传递函数，或场景到屏幕的转换。图像状态的概念是理解色调映射的关键。有两种基本的形象状态。场景参考图像的定义参考场景辐亮度值，而显示参考图像的定义参考显示辐亮度值。图像状态与编码无关。这两种状态下的图像可以线性编码，也可以非线性编码。下图显示了图像状态、色调映射和显示编码如何在成像管线中结合在一起，该管线处理从初始渲染到最终显示的颜色值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930112847.png" class="" title="image-20210930112847">

<p>合成(渲染)图像的成像管道。我们渲染线性场景参考亮度值，色调映射将其转换为线性显示参考值。显示编码应用逆EOTF将线性显示值转换为非线性编码值(代码)，并传递给显示。最后，显示硬件应用EOTF将非线性显示值转换为从屏幕发射到人眼的线性亮度。</p>
<p><strong>关于色调映射的目标有几个常见的误解。这并不是保证场景到屏幕的转换是一个身份转换，完美地再现了显示场景的辐射值。也不是将场景的高动态范围中的每一个信息“挤”到显示的低动态范围中，尽管考虑场景和显示动态范围的差异确实起到了重要的作用。</strong></p>
<p><strong>为了理解色调映射的目的，最好将它看作是图像复制的一个实例。图像复制的目标是创建一个显示——参考图像的复制——尽可能接近，考虑到显示属性和观看条件——如果观看者正在观察原始场景，他们会产生的知觉印象。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930112954.png" class="" title="image-20210930112954">

<p>图像再现的目的是确保再现(右)所唤起的知觉印象尽可能接近原场景(左)。</p>
<p><strong>有一种图像复制的目标略有不同。首选图像复制的目的是创建一个在某种意义上比原始场景更好看的显示参考图像。稍后将在8.2.3节中讨论首选图像复制。</strong></p>
<p><strong>由于一个典型场景的亮度范围超过了原始场景，因此要再现与原始场景相似的感知印象是一个具有挑战性的目标几个数量级的显示能力。场景中至少一些颜色的饱和度(纯度)也可能远远超过显示能力。然而，正如文艺复兴时期的画家们所做的那样，摄影、电视和电影确实设法产生了令人信服的对原始场景的感知相似性。这一成就是通过利用人类视觉系统的某些特性实现的。</strong></p>
<p><strong>视觉系统弥补绝对亮度的差异，这种能力被称为适应能力。由于这种能力，在昏暗房间的屏幕上再现的室外场景可以产生与原始场景相似的感知，尽管复制的亮度不到原始场景的1%。然而，适应所提供的补偿是不完善的。在较低的亮度水平下，感知到的对比度会降低(史蒂文斯效应)，感知到的“色彩”(亨特效应)也是如此。</strong></p>
<p><strong>其他因素影响实际的或感知的复制对比。显示器的环绕(显示矩形外的亮度水平，例如房间照明的亮度)可能会增加或减少感知到的对比度(巴特尔森-布里尼曼效应)。显示耀斑是由于显示缺陷或屏幕反射而添加到显示图像上的不需要的光线，它会降低图像的实际对比度，通常是相当大的程度。这些效果意味着，如果我们想保持与原始场景相似的感知效果，就必须提高显示参考图像值的对比度和饱和度。</strong></p>
<p><strong>然而，这种反差的增加加剧了一个现有的问题。由于场景的动态范围通常比显示器的动态范围大得多，我们必须选择一个狭窄的亮度值窗口来再现，窗口上方和下方的值被裁剪为黑色或白色。提高对比度会进一步缩小这个窗口。为了部分抵消暗和亮值的裁剪，使用了一个软滚动来带来一些阴影和突出细节。</strong></p>
<p><strong>所有这些都导致了一个s形(s形)的色调复制曲线，类似于光化学薄膜所提供的曲线。这并非偶然。柯达和其他公司的研究人员仔细调整了光化学胶片乳剂的特性，以产生有效和令人满意的图像复制。由于这些原因，“电影的”这个形容词经常出现在色调映射的讨论中。</strong></p>
<p><strong>曝光的概念对于色调映射是至关重要的。在摄影中，曝光指的是控制落在胶片或传感器上的光量。然而，在渲染中，曝光是在色调再现变换之前对场景参考图像进行线性缩放操作。曝光的棘手之处在于确定要采用何种比例因子。色调再现、变换和曝光是紧密联系在一起的。色调变换的设计通常是预期它们将应用于以某种方式曝光的场景参考图像。</strong></p>
<p><strong>通过曝光进行缩放，然后应用色调再现变换的过程是一种全局色调映射，其中相同的映射应用于所有像素。相比之下，局部色调映射过程根据周围像素和其他因素使用不同的像素到像素的映射。实时应用程序几乎已经过时专门使用全局色调映射(除了少数例外)，因此我们将重点讨论这一类型，首先讨论色调再现转换，然后是曝光。</strong></p>
<p><strong>重要的是要记住场景引用的图像和显示引用的图像是完全不同的。物理操作只有在场景引用的数据上才有效。由于显示的限制和我们已经讨论过的各种感知效果，两个图像状态之间总是需要一个非线性变换。</strong></p>
<h4 id="Tone-Reproduction-Transform-色调再现变换"><a href="#Tone-Reproduction-Transform-色调再现变换" class="headerlink" title="Tone Reproduction Transform 色调再现变换"></a>Tone Reproduction Transform 色调再现变换</h4><p><strong>色调再现变换通常表示为一维曲线，将场景引用的输入值映射到显示引用的输出值。这些曲线既可以独立应用于R、G和B值，也可以应用于亮度。在前一种情况下，结果将自动在显示范围内，因为每个显示参考的RGB通道值将在0和1之间。然而，在RGB通道上执行非线性操作(特别是剪切)可能会导致饱和度和色相的偏移，以及所需的亮度偏移。Giorgianni和Madden指出，饱和度的变化在感知上是有益的。大多数复制转换使用的对比度增强来抵消史蒂文斯效应(以及环绕和观看耀斑效应)，将导致相应的饱和度增强，这将抵消亨特效应。然而，色相变化通常被认为是不可取的，现代色调变换试图通过在色调曲线之后应用额外的RGB调整来减少它们。</strong></p>
<p><strong>通过将色调曲线应用到亮度上，可以避免色相和饱和度的变化(或至少减少)。然而，由此产生的显示参考颜色可能超出了显示的RGB范围，在这种情况下，需要将其映射回来。</strong></p>
<p><strong>色调映射的一个潜在问题是，将非线性函数应用到场景涉及的像素颜色可能会导致一些反锯齿技术的问题。这个问题(以及解决它的方法)将在第5.4.2节中讨论。</strong></p>
<p><strong>Reinhard色调再现算子是早期用于实时渲染的色调变换之一。它保持深色值基本不变，而明亮值渐近地变成白色。Drago等人提出了一种有点类似的色调映射算子，该算子具有调整输出显示亮度的能力，这可能使其更适合HDR显示。Duiker在视频游戏中创造了一个接近柯达胶片响应曲线的方法。这条曲线后来被Hable修改以添加更多用户控制，并被用于《神秘海域2》中。Hable在这条曲线上的展示很有影响力，导致“Hable电影曲线”被用于多款游戏中。后来，Hable提出了一种新的曲线，与他早期的工作相比，它有许多优点。</strong></p>
<p><strong>Day呈现的是sigmoid曲线，这是Insomniac Games的游戏以及《使命召唤:高级战争》所使用的曲线。Gotanda创造了模拟胶片和数码相机传感器响应的色调变换。这些都是在《Star Ocean 4》和其他游戏中使用的。Lottes指出显示器耀斑对显示器有效动态范围的影响是显著且高度依赖于房间照明条件。出于这个原因，为用户提供色调映射的调整是很重要的。他提出了一种支持此类调整的色调再现转换，可用于SDR和HDR显示。</strong></p>
<p><strong>学院色彩编码系统(ACES)是由美国电影艺术与科学学院的科学与技术委员会创建的，作为管理电影和电视行业色彩的提议标准。ACES系统将场景到屏幕的转换分成两部分。第一个是参考呈现转换(RRT)，它将场景引用的值转换为一个称为输出颜色编码规范(OCES)的标准、设备无关的输出空间中的显示引用的值。第二部分是输出设备转换(ODT)，它将颜色值从OCES转换为最终的显示编码。有许多不同的ODT，每一个都是为特定的显示设备和查看条件设计的。RRT和适当的ODT的连接创建了整个转换。这种模块化结构便于处理各种显示类型和查看条件。Hart推荐ACES色调映射转换用于需要同时支持SDR和HDR显示的应用程序。</strong></p>
<p><strong>虽然ACES是为电影和电视设计的，但它的转换在实时应用中的应用越来越多。ACES色调映射在Unreal Engine中默认启用，它也被Unity支持。Narkowicz给出了用SDR和HDR ODTs拟合ACES RRT的廉价曲线，Patry也是如此。Hart提出了ACES odt的参数化版本，以支持一系列设备。</strong></p>
<p><strong>HDR显示的色调映射需要一些注意，因为显示器也会应用它们自己的色调映射。Fry提供了一套在Frostbite游戏引擎中使用的色调映射变换。他们申请一个相对积极的色调特别提供再现曲线显示,不再显示使用HDR10信号路径(与一些变化基于显示器的亮度峰值),和没有色调映射显示使用杜比视觉路径(换句话说,他们依靠内置杜比视觉色调映射应用的显示)。Frostbite色调复制转换设计为中性，没有显著的对比或色调变化。目的是通过颜色分级应用任何想要的对比度或色调修改(章节8.2.3)。为此，在集成电路中应用了色调再现变换ICTCP颜色空间，为感知均匀性和色度轴与亮度轴之间的正交性而设计。Frostbite变换色调映射亮度和日益降低饱和度的色度，因为亮度滚动显示白色。这提供了一个没有色相变化的干净的变换。</strong></p>
<p><strong>具有讽刺意味的是，在资产(如火焰效果)出现问题后，Frostbite团队最终修改了转换，使用户能够在显示引用的颜色中重新引入某种程度的色调转换。下图显示了Frostbite转换与本节中提到的其他几个转换的对比。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930114152.png" class="" title="image-20210930114152">

<p>一个场景与四种不同的色调转换应用。差异主要体现在圆圈区域，那里的场景像素值特别高。左上角: clipping(加上sRGB OETF);右上角:Reinhard;左下:Duiker ;右下:Frostbite(色彩保存版本)。Reinhard, Duiker和Frostbite变换都保留了通过剪切丢失的高光信息。然而，Reinhard曲线趋向于在图像较暗的部分去饱和度，而Duiker变换在较暗的区域增加饱和度，这有时被认为是一个理想的特征。通过设计，Frostbite变换保留了饱和度和色调，避免了在其他三张图片左下角的圆圈中看到的强烈色调偏移。(图片来自2018年Electronic Arts Inc.)</p>
<h4 id="Exposure-曝光"><a href="#Exposure-曝光" class="headerlink" title="Exposure 曝光"></a>Exposure 曝光</h4><p><strong>一个常用的技术家族的计算曝光依赖于分析场景参考亮度值。为了避免出现档位，这种分析通常是通过对前一帧进行采样来完成的。</strong></p>
<p><strong>根据Reinhard等人的建议，早期实现中使用的一个度量是日志平均场景亮度。通常，曝光量是通过计算帧的对数平均值来确定的。这个对数平均数是通过执行一系列向下采样的后处理过程来计算的，直到最后计算出帧的单个值。</strong></p>
<p><strong>使用平均值往往对异常值过于敏感，例如，少量的明亮像素可能会影响整个画面的曝光。随后的实现通过使用亮度值的直方图来改善这个问题。直方图可以计算中位数，而不是平均值，中位数更稳健。直方图中的其他数据点可以用于改进结果。例如，在Valve的The Orange Box中，基于第95百分位和中位数的启发式方法用于确定暴露程度。Mittring描述了使用计算着色器来生成亮度直方图。</strong></p>
<p><strong>到目前为止讨论的技术的问题是，像素亮度是一个错误的度量，以驱动曝光。如果我们看看摄影实践，例如安塞尔·亚当斯的区域系统，以及如何使用入射光度计来设置曝光，就会明白，最好是单独使用照明(没有表面反照率的影响)来确定曝光。这样做是可行的，因为初步估计，摄影曝光是用来抵消光线的。这就产生了一种主要显示物体表面颜色的印刷品，这与人类视觉系统的颜色恒定特性相对应。以这种方式处理曝光也确保正确的值传递给色调转换。例如，在电影或电视行业中使用的大多数色调变换被设计成将曝光场景参考值0.18映射到显示参考值0.1，期望0.18代表主导场景照明中18%的灰度卡。</strong></p>
<p><strong>尽管这种方法在实时应用程序中还不常见，但已经开始使用了。例如，《合金装备V:归零地》就有一个基于光照强度的曝光系统。在许多游戏中，静态曝光水平是根据已知的场景光照值手动设置的。这样做可以避免曝光的意外动态变化。</strong></p>
<h3 id="Color-Grading-颜色分级"><a href="#Color-Grading-颜色分级" class="headerlink" title="Color Grading 颜色分级"></a>Color Grading 颜色分级</h3><p><strong>在8.2.2节中，我们提到了首选图像复制的概念，即生成在某种意义上比原始场景更好看的图像。通常情况下，这涉及到对图像颜色的创造性处理，这个过程被称为颜色分级。</strong></p>
<p><strong>数字色彩分级在电影工业中应用已有一段时间了。早期的例子包括电影《O Brother, Where Art Thou?》(2000)和《Am´elie》(2001)。颜色分级通常是通过交互操作示例场景图像中的颜色来实现的，直到达到理想的创造性“外观”。然后将相同的操作序列重新应用于一个镜头或序列中的所有图像。颜色分级从电影传播到游戏，现在它被广泛使用。</strong></p>
<p><strong>Selan展示了如何将颜色分级或图像编辑应用程序中的任意颜色转换“烘焙”到一个三维颜色查找表(LUT)中。通过使用输入R、G和B值作为x、y和z坐标来在表中查找新颜色，这样的表可以应用于从输入到输出颜色的任何映射，直到LUT的分辨率限制。Selan的烘焙过程首先取一个标识符LUT(将每个输入的颜色映射到相同的颜色)，并将其“切片”，以创建一个二维图像。然后将这个切片的LUT图像加载到颜色分级应用程序中，并对其应用定义所需的创造性外观的操作。要注意只对LUT应用颜色操作，避免模糊等空间操作。编辑的LUT然后被保存出来，“打包”到一个三维GPU纹理中，并在渲染应用程序中使用，以便在动态渲染像素上应用相同的颜色转换。Iwanicki提出了一种在LUT中存储颜色变换时减少采样误差的聪明方法，即使用最小二乘最小化。</strong></p>
<p><strong>在后来的出版物中，Selan区分了两种进行颜色分级的方法。在一种方法中，颜色分级是在显示参考图像数据上执行的。另一种方法是对通过显示变换预览的场景参考数据进行颜色分级操作。虽然以显示为参照的颜色分级方法更容易设置，但以场景为参照的分级数据可以产生更高保真度的结果。</strong></p>
<p><strong>当实时应用程序首次采用颜色分级时，参考显示的方法占主导地位。然而，场景参考方法由于其更高的视觉质量而获得了关注。参见下图。将颜色分级应用到场景参考数据中还可以通过将色调映射曲线烘烤到分级LUT来节省一些计算，就像在游戏《Uncharted 4》中所做的那样。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20210930133523.png" class="" title="image-20210930133523">

<p>这是《神秘海域4》中的一个场景。上面的截图没有颜色分级。另外两张截图都应用了颜色分级操作。为了说明的目的，选择了极端的颜色分级操作(乘以高度饱和的青色)。在左下角的截图中，颜色分级应用于显示参考(post-tone-mapping)图像，在右下角的截图中，颜色分级应用于场景参考(pre-tone-mapping)图像。(UNCHARTED 4 A Thief ’s End  c / TM 2016 SIE. Created and developed by Naughty Dog LLC.)</p>
<p><strong>在查找LUT之前，场景引用的数据必须重新映射到范围[0,1]。在Frostbite引擎中，感知量化器OETF用于此目的，尽管可以使用更简单的曲线。Duiker使用对数曲线，Hable建议使用一到两次的平方根算子。</strong></p>
<p><strong>Hable很好地概述了常见的颜色分级操作和实现注意事项。</strong></p>
<h1 id="9-Physically-Based-Shading-基于物理的着色"><a href="#9-Physically-Based-Shading-基于物理的着色" class="headerlink" title="9 Physically Based Shading 基于物理的着色"></a>9 Physically Based Shading 基于物理的着色</h1><h2 id="Physics-of-Light-物理光"><a href="#Physics-of-Light-物理光" class="headerlink" title="Physics of Light 物理光"></a>Physics of Light 物理光</h2><p><strong>光和物质的相互作用形成了物理上的着色基础。要理解这些相互作用，对光的本质有一个基本的了解是有帮助的。</strong></p>
<p><strong>在物理光学中，光被建模为一种电磁横波，一种垂直于其传播方向的振荡电场和磁场的波。这两个场的振荡是耦合的。磁场和电场矢量是互相垂直的，它们的长度之比是固定的。这个比值等于相速度，这个我们稍后会讨论。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001133449.png" class="" title="image-20211001133449">

<p>光，一种电磁横波。电和磁场矢量振荡在90◦彼此和传播的方向。图中所示的波是可能存在的最简单的光波。它是单色的(只有一个波长λ)和线偏振的(电场和磁场都沿着一条线振荡)。</p>
<p><strong>在上图中，我们看到了一个简单的光波。事实上，它是最简单的——一个完美的正弦函数。这个波有一个波长，用希腊字母λ (lambda)表示。正如我们在第8.1节中所看到的，光的颜色与其波长密切相关。因此，单波长的光被称为单色光，意思是“单色的”。“然而，在实践中遇到的大多数光波是多色的，包含许多不同的波长。</strong></p>
<p><strong>上图中的光波在另一方面非常简单。它是线性极化的。这意味着对于空间中的一个固定点，电场和磁场每一个都沿着一条线来回移动。相比之下，在这本书中，我们将重点放在非偏振光，这是更为普遍的。在非偏振光中，场振荡均匀地分布在垂直于传播轴的所有方向上。尽管它们很简单，但理解单色线偏振波的行为是有用的，因为任何光波都可以被分解成这种波的组合。</strong></p>
<p><strong>如果我们以给定的相位(例如，振幅峰值)跟踪波上的一个点，随着时间的推移，我们会看到它以恒定的速度穿过空间，这就是波的相速度。对于穿过真空的光波，相速度是c，通常被称为光速，大约每秒30万公里。</strong></p>
<p><strong>在8.1.1节中，我们讨论了这样一个事实:对于可见光，单个波长的大小大约在400-700纳米范围内。为了直观地了解这个长度，它大约是一根蜘蛛丝宽度的二分之一到三分之一，而蛛丝本身的宽度还不到人类头发宽度的五十分之一。参见下图。在光学中，讨论特征相对于光波长的大小通常是有用的。在这种情况下，我们可以说蜘蛛丝线的宽度约为2λ-3λ(2-3个光波)，而一根头发的宽度约为100λ-200λ。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001133709.png" class="" title="image-20211001133709">

<p>左边显示的是相对于一根蛛丝的可见光波长，这根蛛丝的宽度略大于1微米。在右边，一根类似的蛛丝被展示在一根人的头发旁边，以提供一些额外的背景。(图片由URnano/罗切斯特大学提供。)</p>
<p><strong>光波携带能量。能量流的密度等于电场大小和磁场大小的乘积，因为磁场大小是成比例的，正比于电场大小的平方。我们把重点放在电场上，因为它对物质的影响比磁场大得多。在渲染中，我们关注的是随时间的平均能量流，它与波幅的平方成正比。这个平均能量流密度就是辐照度，用字母E表示。辐照度及其与其他光量的关系已在第8.1.1节中讨论。</strong></p>
<p><strong>光波线性组合。总波是各分量波的和。然而，由于辐照度与振幅的平方成正比，这似乎会导致一个悖论。例如，对两个相等的波进行求和，是否不会导致“1 + 1 = 4”的辐照度?既然辐照度测量能量流，这不会违反能量守恒吗?这两个问题的答案分别是“有时”和“不”。</strong></p>
<p><strong>为了说明这一点，我们将看一个简单的例子:添加n个单色波，除了相位不同外，它们是相同的。每个n波的振幅为a，如前所述，辐照度为E1 与a²成正比，换句话说就是E1 = ka² 对于某个常数k。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001133912.png" class="" title="image-20211001133912">

<p>将频率、极化和振幅相同的n个单色波加在一起的三种情况。从左到右依次为相干干涉、相干干涉和非相干相加。在每一种情况下，组合波的振幅和辐照度(底部)相对于n个原始波(顶部)显示。</p>
<p><strong>上图显示了这个案例的三个示例场景。在左边，所有的波都以相同的相位排列并相互加强。组合波辐照度为n²倍于单个波的辐照度，即n倍于单个波的辐照度之和。这种情况称为相长干涉。在图的中心，每对波处于相反的相位，相互抵消。组合波的振幅为零，辐照度为零。这种情况是破坏性干扰。</strong></p>
<p><strong>相干叠加和相干干涉是相干叠加的两种特殊情况，其中波峰和波谷以某种一致的方式排列起来。根据相对相位关系，n个相同波的相干叠加可以产生一个辐照度在0到n²之间的波乘以一个单独的波浪。然而，大多数情况下，当波相加时，它们是相互不相干的，如上图。在这个阶段的情景中，振幅是相对随机的。如人们所期望的那样，单个波的辐照度与单个波的辐照度线性相加为n倍。</strong></p>
<p><strong>看来，破坏性和建设性的干涉违反了能量守恒定律。但是上图并没有显示全貌——它只显示了一个位置的波的相互作用。当波在空间中传播时，它们之间的相位关系从一个位置到另一个位置会发生变化，如下图所示。在某些地方，波会构成干涉，并且组合波的辐照度大于单个波辐照度值的总和。在其他地方，它们会产生破坏性的干扰，导致综合辐照度小于单个波辐照度值的总和。这并不违反能量守恒定律，因为通过相长干涉获得的能量和通过相消干涉损失的能量总是相互抵消的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001134154.png" class="" title="image-20211001134154">

<p>从两个频率相同的点源发出的单色波。波在空间的不同区域产生建设性和破坏性的干涉。</p>
<p><strong>当物体中的电荷振荡时就发出光波。引起振荡的部分能量——热、电能、化学能——被转换成光能，光能从物体辐射出去。在渲染中，这些对象被视为光源。我们在第5.2节中首先讨论了光源，在第10章中将从更物理的角度对它们进行描述。</strong></p>
<p><strong>光波被发射后，它们在太空中旅行，直到遇到一些可以相互作用的物质。背后的核心现象大多数光与物质的相互作用是简单的，与上面讨论的发射情况非常相似。振荡的电场推动和拉动物质中的电荷，使它们依次振荡。振荡电荷发射出新的光波，将入射光波的一些能量转向新的方向。这种反应称为散射，是各种光学现象的基础。</strong></p>
<p><strong>散射的光波与原始波的频率相同。通常情况下，当原始波包含多个频率的光时，每一个频率都分别与物质相互作用。以一个频率入射的光能不会对以不同频率发射的光能产生贡献，除了特定的、相对罕见的情况，如荧光和磷光，我们将在本书中不进行描述。</strong></p>
<p><strong>一个孤立的分子向各个方向散射光，强度有一定的方向变化。更多的光被散射到靠近原始传播轴的方向，无论是向前还是向后。分子作为散射体的有效性——其附近的光波被散射的几率——随波长的不同而有很大的变化。短波长的光比长波长的光更能有效地散射。</strong></p>
<p><strong>在渲染中，我们关心的是许多分子的集合。与这种聚集体的光相互作用不一定类似于与孤立分子的相互作用。从附近分子散射的波往往相互相干，因此表现出干涉，因为它们来自同一入射波。本节的其余部分将专门讨论光从多个分子散射的几个重要的特殊情况。</strong></p>
<h3 id="Particles-粒子"><a href="#Particles-粒子" class="headerlink" title="Particles 粒子"></a>Particles 粒子</h3><p><strong>在理想气体中，分子之间不相互影响，因此它们的相对位置是完全随机和不相关的。虽然这是一个抽象的概念，但对于常压下的空气来说，这是一个相当好的模型。在这种情况下，从不同分子散射的波之间的相位差是随机的，并且不断变化。因此，散射波是非相干的，它们的能量线性增加，如上上图的右侧所示。换句话说，从n个分子散射的总光能是从单个分子散射的光能的n倍。</strong></p>
<p><strong>相反，如果分子紧密地聚集在比光波波长小得多的簇中，每个簇中的散射光波就会处于相位并相互干涉。这导致散射波能量以二次形式叠加，如上上图的左侧所示。因此，由n个分子组成的小团簇散射的光的强度为n² 乘以单个分子散射的光，比理想气体中相同数量的分子散射的光多n倍。这种关系意味着，对于每立方米固定的分子密度，分子聚集成簇将显著增加散射光的强度。使团簇更大，同时仍然保持整个分子密度常数，将进一步增加散射光的强度，直到星团直径变得接近光的波长。除此之外，星团大小的额外增加不会进一步增加散射光强度。</strong></p>
<p><strong>这个过程解释了为什么云和雾会如此强烈地散射光。它们都是由冷凝产生的，这是空气中的水分子聚集成越来越大的簇的过程。这大大增加了光散射，即使水分子的总体密度没有变化。云绘制将在14.4.2节中讨论。</strong></p>
<p><strong>当讨论光散射时，粒子这一术语既指孤立的分子，也指多分子团簇。由于直径小于一个波长的多分子粒子的散射是孤立分子散射的放大(通过相构干涉)版本，它表现出相同的方向变化和波长依赖性。这种散射在大气粒子的情况下称为瑞利散射，在粒子嵌入固体的情况下称为廷德尔散射。</strong></p>
<p><strong>当粒子的大小超过一个波长时，散射波在整个粒子上不再处于相位，这一事实改变了散射特性。散射越来越倾向于正向，波长依赖性逐渐减小，直到所有可见波长的光散射相等。这种散射称为米氏散射。瑞利散射和米氏散射将在第14.1节中详细讨论。</strong></p>
<h3 id="Media-媒介"><a href="#Media-媒介" class="headerlink" title="Media 媒介"></a>Media 媒介</h3><p><strong>另一个重要的例子是光通过均匀介质传播，均匀介质是一个充满均匀间隔的相同分子的体积。分子间距不必像晶体那样完全规则。如果液体和非结晶固体的成分是纯的(所有的分子都是相同的)，并且没有空隙或气泡，那么它们在光学上是均匀的。</strong></p>
<p><strong>在均匀介质中，散射波排列成一排，使它们在除原始传播方向外的所有方向上发生破坏性干扰。当原始波与所有从单个分子散射的波结合后，最终的结果与原始波相同，除了它的相速度和(在某些情况下)振幅。最后的波不表现出任何散射——它已被破坏性干涉有效地抑制了。</strong></p>
<p><strong>原波和新波的相速度之比定义了介质的一种光学性质，称为折射率(IOR)或折射率，用字母n表示。有些介质是可吸收的。它们将部分光能转换为热能，使波的振幅随距离的增加呈指数级减小。衰减率由衰减指数定义，以希腊字母κ (kappa)表示。n和κ通常随波长而变化。这两个数字完全定义了介质对给定波长的光的影响，它们经常被组合成一个复数n + iκ，称为复折射率。</strong></p>
<p><strong>折射率去掉了光相互作用的分子级细节，使得将介质视为一个连续的体积，这就简单得多了。</strong></p>
<p><strong>虽然光的相速度不会直接影响外观，但速度的变化会，我们稍后会解释。另一方面，光的吸收对视觉效果有直接的影响，因为它降低了光的强度，并且(如果根据波长变化)也会改变光的颜色。下图显示了一些光吸收的例子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001134620.png" class="" title="image-20211001134620">

<p>四个小容器的液体具有不同的吸收特性。从左到右:清水、石榴汁水、茶和咖啡。</p>
<p><strong>非均匀介质通常可以模拟为含有散射粒子的均匀介质。在均匀介质中抑制散射的破坏性干涉是由分子的均匀排列引起的，因此是由它们产生的散射波引起的。分子分布的任何局部变化都会打破这种破坏性干涉的模式，允许散射的光波传播。这种局部变化可以是不同分子类型的簇、气隙、气泡或密度变化。无论如何，它会像前面讨论的粒子一样散射光，散射特性同样依赖于星团的大小。甚至气体也可以用这种方法建模。因此，“散射粒子”是由分子不断运动引起的瞬时密度波动。该模型可以为气体建立一个有意义的n值，这对理解气体的光学性质是有用的。下图显示了一些光散射的例子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001134717.png" class="" title="image-20211001134717">

<p>从左到右:水，加了几滴牛奶的水，加了10%牛奶的水，全脂牛奶，和乳白色玻璃。大多数牛奶的散射粒子都比可见光波长大，所以它的散射基本上是无色的，在中间的图像中有一种微弱的蓝色。乳白色玻璃中的散射粒子都小于可见光波长，因此蓝光的散射比红光更强烈。由于明暗背景的分裂，透射光在左侧更明显，散射光在右侧更明显。</p>
<p><strong>散射和吸收都与尺度有关。在小场景中不产生任何明显散射的介质在大尺度上可能产生相当明显的散射。例如，当观察房间里的一杯水时，光在空气中的散射和在水中的吸收是不可见的。然而，在扩展的环境中，这两种效果都是显著的，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001134800.png" class="" title="image-20211001134800">

<p>左边的图像显示，在数米的距离内，水吸收光线，尤其是红光，非常强烈。右边的图像显示，即使在没有严重污染或雾的情况下，明显的光线也散射在数英里的空气中。</p>
<p><strong>在一般情况下，介质的出现是由散射和吸收的某种结合引起的，如下图所示。散射的程度决定了云量，高散射造成不透明的外观。除了一些罕见的例外情况，如上上图中的乳白色玻璃，固体和液体介质中的颗粒往往大于光波长，并倾向于均匀地散射所有可见波长的光。因此，任何颜色的色调通常是由波长依赖性的吸收引起的。介质的亮度是这两种现象的结果。特别是白色是高散射和低吸收结合的结果。这将在14.1节中进行更详细的讨论。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001134858.png" class="" title="image-20211001134858">

<p>表现出不同吸收和散射组合的液体容器。</p>
<h3 id="Surfaces-表面"><a href="#Surfaces-表面" class="headerlink" title="Surfaces 表面"></a>Surfaces 表面</h3><p><strong>从光学角度看，物体表面是一个二维界面，将不同折射率的体分开。在典型的渲染情况下，外层包含空气，折射率约为1.003，通常为简单起见假设为1。内部体积的折射率取决于制成物体的物质。</strong></p>
<p><strong>当光波照射到一个表面时，该表面的两个方面对结果有重要影响:两侧的物质和表面的几何形状。我们将从物质方面开始，假设最简单的表面几何，一个完美的平面。我们用“外面”(入射波或入射波产生的那一边)的折射率表示n1 而“内部”(波穿过表面后将被透射的地方)的折射率为n₂．</strong></p>
<p><strong>在前一节中我们已经看到，当光波遇到材料组成或密度的不连续时，即散射。，在折射率。一个不同折射率的平面表面是一种特殊类型的不连续，以特定的方式散射光。边界条件要求平行于表面的电场分量是连续的。换句话说，电场向量在平面上的投影必须与平面的任意一侧相匹配。这有几个含义:</strong></p>
<pre><code>**1.在水面上，任何散射波必须与入射波同相，或180◦异相。因此，在表面上，散射波的波峰必须与入射波的波峰或波谷对齐。这就限制了散射波只能向两种可能的方向移动，一种是继续向水面前进，另一种是后退。第一种是透射波，第二种是反射波。**

**2.散射波必须与入射波具有相同的频率。我们假设这里是一个单色波，但是我们讨论的原理可以应用于任何一般波，首先要把它分解成单色分量。**

**3.当光波从一种介质移动到另一种介质时，相速度——即光波穿过介质的速度——与相对折射率成正比变化(n₁/ n₂)．由于频率是固定的，波长也与(n₁/ n₂)成比例变化．**
</code></pre>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001135538.png" class="" title="image-20211001135538">

<p>入射平面的光波，折射率n₁ 和n₂．图的左侧显示了一个侧面视图，入射波从左上方进入。红色波段的强度表示波的相位。表面以下的波的间距与比率(n₁/ n₂)成比例变化，在本例中为0.5。相位沿表面排列，因此间距的变化弯曲(折射)透射波的方向。三角形的构造说明了斯涅尔定律的推导。为清晰起见，图的右上角分别显示了反射波。它与入射波有相同的波间距，因此它的方向与表面法线有相同的角度。图的右下角显示了波的方向向量。</p>
<p><strong>最终结果如上图所示。反射波和入射波方向具有相同的角度θi 表面法线。透射波的方向弯曲(折射)成θ角t，它与θ的关系如下i：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001135638.png" class="" title="image-20211001135638">

<p><strong>这个折射方程被称为斯涅尔定律。它用于全局折射效应，这将在14.5.2节中进一步讨论。</strong></p>
<p><strong>虽然折射通常发生在透明的材料，如玻璃和晶体，它也发生在不透明物体的表面。当不透明物体发生折射时，光在物体内部发生散射和吸收。光与物体的介质相互作用，就像上上图中不同杯子的液体一样。以金属为例，其内部包含许多自由电子(没有与分子绑定的电子)，它们“吸收”折射的光能，并将其重新定向到反射波中。这就是金属具有高吸收率和高反射率的原因。</strong></p>
<p><strong>我们已经讨论过的表面折射现象——反射和折射——需要折射率的突变，发生在小于一个波长的距离内。更渐进的折射率变化不会使光分裂，而是使光的路径弯曲，类似于折射过程中发生的不连续弯曲。这种效应通常可以在空气密度因温度而变化时看到，如海市蜃楼和热变形。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001135735.png" class="" title="image-20211001135735">

<p>由于折射率的逐渐变化而引起的光路弯曲的一个例子，在这种情况下是由温度变化引起的。(“EE lighting heat haze，”Paul Lucas，在CC BY 2.0许可下使用。)</p>
<p><strong>即使一个物体有明确的边界，如果它浸没在具有相同折射率的物质中，它也不会有可见的表面。在没有折射率变化的情况下，就不会发生反射和折射。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001135824.png" class="" title="image-20211001135824">

<p>这些装饰珠子的折射率与水一样。在水面上，由于它们的折射率与空气的不同，它们有一个可见的表面。在水下，珠子表面两侧的折射率是一样的，所以表面是看不见的。由于颜色的吸收，珠子本身是可见的。</p>
<p><strong>到目前为止，我们一直专注于表面两侧物质的影响。现在我们将讨论另一个影响表面外观的重要因素:几何。严格地说，一个完全平坦的平面是不可能的。每个表面都有某种不规则性，即使只有单个原子构成了表面。然而，比波长小得多的表面不规则性对光线没有影响，而比波长大得多的表面不规则性有效地使表面倾斜，而不影响其局部平坦度。只有在1-100波长范围内的不规则现象，通过一种称为衍射的现象，使表面的行为与平面不同，这将在第9.11节中进一步讨论。</strong></p>
<p><strong>在渲染中，我们通常使用几何光学，这忽略了波的影响，如干涉和衍射。这相当于假设所有表面的不规则性要么小于光波长，要么大于光波长。在几何光学中，光被模拟成射线而不是波。在光线与曲面相交的那一点上，该曲面被局部地视为一个平面。上上上图右下角的图可以看作是反射和折射的几何光学图，与图中其他部分的波动图形成对比。我们将从这一点保持几何光学的领域，直到9.11节，这是专门的主题的阴影模型基于波动光学。</strong></p>
<p><strong>正如我们前面提到的，比波长大得多的表面不规则性会改变表面的局部方向。当这些不规则现象太小而无法单独呈现时——换句话说，比像素还小——我们称之为微几何。反射和折射的方向取决于表面法线。微几何的作用是改变表面上不同点的法线，从而改变光的反射和折射方向。</strong></p>
<p><strong>尽管表面上的每个特定点只在一个方向反射光线，但每个像素覆盖了许多在不同方向反射光线的表面点。外观是由所有不同反射方向的聚合结果驱动的。下图展示了两个表面的例子，它们在宏观尺度上具有相似的形状，但微观几何形状却有显著不同。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001140015.png" class="" title="image-20211001140015">

<p>左边是两个表面的照片，右边是它们的微观结构图。顶部表面有轻微粗糙的微观几何形状。射入的光线击中表面的点的角度有些不同，并在一个狭窄的圆锥方向反射。可见的效果是反射物有轻微的模糊。底部表面有粗糙的微观几何形状。被入射光线击中的表面点的角度有显著不同的方向和反射光在一个宽的锥体中扩散，造成更模糊的反射。</p>
<p><strong>对于渲染，而不是显式地建模微几何，我们处理它统计和观察表面有一个随机分布的微观结构法线。因此，我们将表面建模为连续方向上的反射(和折射)光。这种扩展的宽度，以及反射和折射细节的模糊程度，取决于微几何法向量的统计方差，换句话说，就是表面微尺度粗糙度。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001140108.png" class="" title="image-20211001140108">

<p>从宏观上看，表面可以看作是在多个方向反射和折射光线。</p>
<h3 id="Subsurface-Scattering-次表面散射"><a href="#Subsurface-Scattering-次表面散射" class="headerlink" title="Subsurface Scattering 次表面散射"></a>Subsurface Scattering 次表面散射</h3><p><strong>折射的光继续与物体的内部体积相互作用。如前所述，金属反射大部分入射光，并迅速吸收其余的光。相反，非金属表现出各种各样的散射和吸收行为与之前图中所示的杯状液体相似。低散射和低吸收的材料是透明的，可以将任何折射的光穿透整个物体。在第5.5节中讨论了在没有折射的情况下渲染这些材料的简单方法，而折射将在第14.5.2节中详细讨论。在这一章中，我们将重点关注不透明物体，在这些物体中，透射光经历多次散射和吸收事件，直到其中一些最终从表面重新发射回来。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001140323.png" class="" title="image-20211001140323">

<p>折射的光在穿过材料时被吸收。在这个例子中，大部分的吸收是在较长的波长，主要留下短波长的蓝光。此外，它从物质内部的粒子散射。最终，一些折射的光被散射出表面，如蓝色箭头所示，从不同的方向离开表面。</p>
<p><strong>这种次表面散射光以不同的距离从表面进入点。入射出口距离的分布取决于材料中散射粒子的密度和性质。这些距离和着色比例(像素的大小，或着色样本之间的距离)之间的关系是重要的。如果入口-出口距离与遮阳尺度相比较小，则可以假设它们为有效的零遮阳目的。这使得次表面散射与表面反射结合到一个局部的阴影模型中，在一个点上发出的光只依赖于在同一点上进入的光。然而，由于次表面散射光的外观与表面反射光有显著的不同，将它们划分为单独的遮光项是很方便的。镜面项模拟表面反射，漫反射项模拟局部次表面散射。</strong></p>
<p><strong>如果入口-出口距离比阴影尺度大，那么就需要专门的渲染技术来捕捉光线从一点进入表面和从另一点离开表面的视觉效果。这些全球次表面散射技术将在第14.6节详细介绍。局部和全局次表面散射的区别如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001140338.png" class="" title="image-20211001140338">

<p>在左边，我们正在渲染一个材质的次表面散射。黄色和紫色分别显示了两种不同的抽样大小。大的黄色圆圈表示单个阴影样本覆盖的面积大于次表面散射距离。因此，这些距离可以忽略，使次表面散射被视为局部阴影模型中的漫射项，如右图所示。如果我们靠近这个表面，着色样本区域会变得更小，如紫色的小圆圈所示。与着色样本覆盖的区域相比，次表面散射距离现在很大。从这些样本中生成逼真的图像需要全局技术。</p>
<p><strong>值得注意的是，局部和全局次表面散射技术模拟的是完全相同的物理现象。每种情况下的最佳选择并不取决于不仅在物质特性上，而且在观察尺度上。例如，当渲染一个孩子玩塑料玩具的场景时，很可能需要全局技术来精确渲染孩子的皮肤，而局部漫反射阴影模型对于玩具来说就足够了。这是因为在皮肤中的散射距离比在塑料中大得多。然而，如果相机足够远，皮肤散射距离将小于一个像素和局部着色模型将是准确的孩子和玩具。相反，在一个极端的特写镜头，塑料将显示出明显的非局部次表面散射和全球技术将需要渲染玩具准确。</strong></p>
<h2 id="The-Camera-相机"><a href="#The-Camera-相机" class="headerlink" title="The Camera 相机"></a>The Camera 相机</h2><p><strong>如8.1.1节所述，在渲染时，我们计算从阴影表面点到摄像机位置的亮度。这模拟了成像系统的简化模型，如胶片相机、数码相机或人眼。</strong></p>
<p><strong>这种系统包含由许多离散的小传感器组成的传感器表面。例如眼睛中的视杆细胞和视锥细胞，数码相机中的光电二极管，或者胶片中的染料颗粒。每个传感器检测其表面的辐照度值，并产生颜色信号。辐照度传感器本身无法产生图像，因为它们平均来自所有入射方向的光线。由于这个原因，一个完整的成像系统包括一个有一个小孔径(开口)的防光外壳，以限制光线可以从哪个方向进入并攻击传感器。放置在光圈上的透镜聚焦光，这样每个传感器只接收一小部分入射方向的光。外壳、光圈和透镜具有使传感器具有方向性的综合效果。它们平均的光面积小，方向也小。我们在8.1.1节中已经看到，平均辐照度量化了来自各个方向的光的表面密度，而这些传感器测量的是平均辐照度，平均辐照度量化了单光束的亮度和颜色。</strong></p>
<p><strong>在过去，渲染已经模拟了一个特别简单的成像传感器称为针孔相机，如下图的顶部所示。针孔相机的光圈非常小——在理想情况下，是零尺寸的数学点——而且没有镜头。点孔径限制传感器表面上的每个点收集单一光线，离散传感器收集狭窄的光线圆锥，其基底覆盖传感器表面，其顶点位于孔径。渲染系统模型针孔摄像机在一个稍微不同(但等效)的方式，如下图的中间部分所示。针孔孔径的位置由点c表示，通常称为“相机位置”或“眼睛位置”。这个点也是透视变换的投影中心(章节4.7.2)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211001140623.png" class="" title="image-20211001140623">

<p>每一个相机模型都包含一组像素传感器。实线将三个传感器从现场收集到的光线集合绑定在一起。每个图中的插入图像显示了由像素传感器上的单点样本收集的光线。上图是一个针孔摄像机，下图是一个典型的针孔摄像机和摄像机点c的渲染系统模型，下图是一个物理上更正确的带有镜头的摄像机。红色的球在焦点上，其他两个球不在焦点上。</p>
<p><strong>渲染时，每个着色样本对应于一条射线，因此对应于传感器表面上的一个样本点。反走样的过程(章节5.4)可以解释为重构在每个离散传感器表面上采集的信号。然而，由于渲染不受物理传感器的限制，我们可以更一般地看待这个过程，即从离散样本重建连续图像信号。</strong></p>
<p><strong>虽然已经制造出了实际的针孔摄像机，但对于实际使用的大多数摄像机以及人眼来说，它们都是糟糕的模型。使用透镜的成像系统模型如上图的底部所示。加上透镜可以使用更大的光圈，这大大增加了成像系统收集的光量。然而，它也会导致相机有一个有限的景深(章节12.4)，模糊的对象太近或太远。</strong></p>
<p><strong>除了限制景深外，镜头还有一个额外的效果。每个传感器的位置都接收到一个光锥，即使是聚焦完美的点。理想化的模型，其中每个着色样本代表一个单一的观察射线有时会引入数学奇点，数值不稳定性，或视觉混叠。当我们渲染图像时，记住物理模型可以帮助我们识别和解决这些问题。</strong></p>
<h2 id="The-BRDF-双向反射分布函数"><a href="#The-BRDF-双向反射分布函数" class="headerlink" title="The BRDF 双向反射分布函数"></a>The BRDF 双向反射分布函数</h2><p><strong>最终，基于物理的渲染归结为计算沿着一组视图射线进入相机的亮度。使用8.1.1节介绍的入射辐亮度符号，对于给定的视场射线，我们需要计算的量是Li(c，−v)，其中c为摄像机位置，−v为沿视图射线的方向。我们使用−v是由于两种符号约定。首先是Li()中的方向向量总是指向给定的点，在本例中是摄像机位置。其次，视图向量v总是指向相机。</strong></p>
<p><strong>在渲染中，场景通常被建模为对象的集合，对象之间有媒介(“媒介”这个词实际上来自于拉丁词“在中间”或“在中间”)。通常所讨论的介质是适量的相对干净的空气，它不会明显地影响光线的亮度，因此在渲染时可以忽略它。有时，射线穿过的介质通过吸收或散射对其辐射有明显的影响。这类媒体被称为参与媒体，因为它们参与了光在场景中的传输。参与的媒体将在第14章详细介绍。在本章中，我们假设没有参与的媒体在场，因此进入相机的亮度等于在相机方向上离开最近物体表面的亮度:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112113.png" class="" title="image-20211002112113">

<p><strong>其中p是视图射线与最近物体表面的交点。</strong></p>
<p><strong>根据上式，我们的新目标是计算Lo(p, v)。该计算是5.1节中讨论的着色模型评估的物理版本。有时辐亮度直接由表面发出。更常见的情况是，离开表面的辐亮度来自别处，并通过第9.1节所述的物理相互作用被表面反射到视场射线中。在本章中，我们先不讨论透明度(第5.5节和第14.5.2节)和全局次表面散射(第14.6节)。换句话说，我们关注的是局部反射现象，它将照射到当前阴影点的光线向外折射。这些现象包括表面反射和局部亚表面散射，只依赖于入射光方向l和出射视图方向v。局部反射通过双向反射分布函数(BRDF)来量化，记为f(l, v)。</strong></p>
<p><strong>在其原始推导中，BRDF被定义为均匀曲面。也就是说，BRDF假定在表面上是相同的。然而，现实世界中的物体(以及渲染场景)很少在其表面具有统一的材质属性。即使是由单一材料制成的物体，例如银制的雕像，也会有划痕、污点、污渍和其他变化，导致其视觉特性从一个表面点到另一个表面点发生变化。从技术上讲，根据空间位置捕获BRDF变化的函数称为空间变化BRDF (SVBRDF)或空间BRDF (SBRDF)。然而，这种情况在实践中非常普遍，因此经常使用短期BRDF，并隐含地假定它依赖于表面位置。</strong></p>
<p><strong>进方向和出方向各有两个自由度。常用的参数化包括两个角度:相对于表面法线n的仰角θ和关于n的方位角(水平旋转)φ。在一般情况下，BRDF是四个标量变量的函数。各向同性BRDFs是一个重要的特例。这样的BRDFs保持不变，当进入和向外的方向是围绕表面法线旋转，保持他们之间的相对角度相同。下图显示了两种情况下使用的变量。各向同性BRDFs是三个标量变量的函数，因为光与相机之间只有一个角度φ旋转是必要的。这意味着，如果一个均匀的各向同性的材料被放置在转盘上并进行旋转，在给定固定的光线和摄像机的情况下，它在所有旋转角度上都是相同的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112303.png" class="" title="image-20211002112303">

<p>双向反射。方位角度φi 和φo 的相对方位角φ，用在各向同性BRDFs中代替φi 和φo，不需要参考切向量。</p>
<p><strong>由于我们忽略了荧光和磷光等现象，我们可以假设入射光的波长是相同的。反射的光的数量可以根据波长而变化，波长可以用两种方法之一来建模。要么将波长视为BRDF的附加输入变量，要么将BRDF视为返回光谱分布值。在离线渲染中有时会使用第一种方法，而在实时渲染中总是使用第二种方法。由于实时渲染器将光谱分布表示为RGB三元组，这仅仅意味着BRDF返回一个RGB值。</strong></p>
<p><strong>计算Lo(p, v)，我们将BRDF纳入到反射方程中:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112408.png" class="" title="image-20211002112408">

<p><strong>l∈Ω下标的积分符号执行意味着集成/ l向量躺在上面的单位半球表面(集中在表面上正常n)。注意,l是被不断在西半球的方向——它不是一个特定的“光源的方向。“这个想法是，任何入射方向都可能(通常会)有一些与之相关的辐射。我们用dl表示l周围的微分实心角(实心角在8.1.1节中讨论)。</strong></p>
<p><strong>综上所述，反射率方程表明出射辐亮度等于入射辐亮度的积分(在Ω中除以l)乘以BRDF乘以n与l之间的点积。</strong></p>
<p><strong>为简洁起见，在本章的其余部分，我们将从L中省略曲面点pi(), Lo()，反射率方程为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112456.png" class="" title="image-20211002112456">

<p><strong>在计算反射率方程时，通常采用球坐标φ和θ对半球进行参数化。对于这个参数化，微分立体角dl等于sin θi dθi dφi．利用这个参数化，可以推导出上式的二重积分形式，该形式使用球坐标(回想一下(n·l) = cos θi）：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112543.png" class="" title="image-20211002112543">

<p><strong>角度θi,φi,θo,φo 如上图所示。</strong></p>
<p><strong>在某些情况下，使用略微不同的参数化是方便的，使用仰角的余弦µi = cosθi 和µo = cosθo 作为变量而不是角度θi 和θo 他们自己。对于这个参数化，微分立体角dl等于dµi dφi．利用(µ，φ)参数化得到如下积分形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112712.png" class="" title="image-20211002112712">

<p><strong>BRDF仅在光线和视图方向都高于表面的情况下被定义。光方向在表面以下的情况可以通过将BRDF乘以0或不首先计算该方向的BRDF来避免。但是曲面下的视图方向呢，也就是说n·v的点积是负的?从理论上讲，这种情况永远不应该发生。表面将背对着摄像机，因此是看不见的。然而，插值顶点法线和法线映射(这两种方法在实时应用中都很常见)在实践中可能会产生这种情况。通过将n·v夹持为0或使用其绝对值，可以避免对表面下的视图方向的BRDF进行评估，但这两种方法都可能产生伪影。Frostbite引擎使用n·v的绝对值加上一个小数字(0.00001)来避免被零除。另一种可能的方法是“软夹”，当n和v之间的夹角超过90°时，它逐渐趋于零．</strong></p>
<p><strong>物理定律对任何BRDF都有两个限制。第一个约束条件是Helmholtz reciprocity，即输入输出角可以切换，函数值不变:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002112920.png" class="" title="image-20211002112920">

<p><strong>在实践中，渲染中使用的BRDFs经常违反Helmholtz reciprocity，而没有明显的伪影，除非离线渲染算法特别需要互易性，例如双向路径跟踪。然而，当确定BRDF在物理上是否合理时，它是一个有用的工具。</strong></p>
<p><strong>第二个约束是能量守恒——输出的能量不能大于输入的能量(不包括发光的表面，这是一个特例)。离线渲染算法，如路径跟踪节约能源，确保收敛。对于实时渲染，精确的能量守恒是不必要的，但近似的能量守恒是重要的。用BRDF渲染的表面严重违反了能量节约，会太亮，因此可能看起来不现实。</strong></p>
<p><strong>方向半球反射率R(l)是一个与BRDF有关的函数。它可以用来测量BRDF的节能程度。尽管它的名字有点吓人，方向半球面反射是一个简单的概念。它测量从一个给定方向入射的光被反射到半球表面法线周围任何方向的量。本质上，它测量的是给定入射方向的能量损失。该函数的输入为输入方向向量l，其定义如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113013.png" class="" title="image-20211002113013">

<p><strong>注意这里的v，就像反射方程中的l一样，覆盖了整个半球，并不代表一个单一的观察方向。</strong></p>
<p><strong>一个类似但在某种意义上相反的函数，半球定向反射率R(v)可以类似地定义为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113021.png" class="" title="image-20211002113021">

<p><strong>如果BRDF是倒数的，则半球方向反射率和半球方向反射率相等，可以使用相同的函数来计算两者。方向性反照率可以作为这两种反照率的概括性术语，在它们可以互换使用的情况下。</strong></p>
<p><strong>由于能量守恒，方向半球反射率R(l)的值必须始终在[0,1]范围内。反射值为0表示所有入射光被吸收或丢失的情况。如果所有的光都被反射，反射率为1。在大多数情况下，它会在这两个值之间。和BRDF一样，R(l)的值随波长而变化，因此为了渲染的目的，它被表示为RGB向量。由于每个组件(红色、绿色和蓝色)都被限制在[0,1]范围内，所以R(l)的值可以被认为是一种简单的颜色。注意，这个限制不适用于BRDF的值。作为一个分布函数，如果BRDF描述的分布是高度不均匀的，那么它可以在某些方向上有任意高的值(例如高光的中心)。BRDF节能的要求是R(l)对于所有可能的l值不大于1。</strong></p>
<p><strong>可能最简单的BRDF是Lambertian着色模型，它对应于在第5.2节中简要讨论的Lambertian着色模型。朗伯BRDF有一个常数值。著名的(n·l)因子区分朗伯氏着色不是BRDF的一部分，而是方程的一部分。尽管它很简单，兰伯特BRDF经常被用于实时渲染来表示局部的次表面散射(尽管它正在被更精确的模型所取代，如9.9节所述)。朗伯曲面的方向半球面反射率也是一个常数。对上上方程求常值f(l, v)的值，得到方向-半球反射率作为BRDF函数的如下值:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113223.png" class="" title="image-20211002113223">

<p><strong>LambertianBRDF的常数反射值通常被称为漫反射颜色cdiff 或者是ρ反照率。在本章中，为了强调与次表面散射的联系，我们将把这个量称为次表面反照率ρss．地下反照率将在第9.9.1节中详细讨论。由上式得到的BRDF结果如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113231.png" class="" title="image-20211002113231">

<p><strong>1/π因子是由于在半球上对余弦因子积分得到π值而产生的。这些因素在BRDFs中很常见。</strong></p>
<p><strong>理解BRDF的一种方法是在输入方向不变的情况下将其形象化。参见下图。对于入射光的给定方向，BRDF的值显示所有出站方向。在交点周围的球面部分是漫反射部分，因为发出的辐亮度在任何方向上都有相同的反射机会。椭球状的部分是镜面裂片。这样的波瓣自然处于入射光的反射方向，波瓣的厚度与反射的模糊性相对应。根据相互作用的原理，这些相同的可视化也可以被认为是每个不同的入射光方向对单个出射光方向的贡献。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113441.png" class="" title="image-20211002113441">

<p>双向反射的例子。每个图形右侧的实绿线为入射光方向，绿白虚线为理想的反射方向。在上面一行，左图显示了一个朗伯式BRDF(一个简单的半球)。中间的图显示了添加到lambert术语中的Blinn-Phong高亮显示。右图显示的是库克-托伦斯BRDF。注意镜面的高光在反射方向上不是最强的。在最下面一行，左图是沃德的各向异性模型的特写。在这种情况下，效果是倾斜镜面瓣。中间的图是Hapke/Lommel-Seeliger“月球表面”BRDF，具有强烈的反反射。右图显示的是Lommel-Seeliger散射，在这个过程中，布满灰尘的表面将光线散射到掠射角度。(图片由Szymon Rusinkiewicz提供，来自他的“bv”BRDF浏览器)</p>
<h2 id="Illumination-光照"><a href="#Illumination-光照" class="headerlink" title="Illumination 光照"></a>Illumination 光照</h2><p><strong>Li(l)(入射辐亮度)项在反射方程中表示从场景其他部分照射到着色表面点的光线。全局光照算法计算Li(l)通过模拟光线如何在场景中传播和反射。这些算法使用绘制方程，其中反射方程是一个特例。整体照明将在第11章中讨论。在这一章和下一章中，我们重点关注局部照明，它使用反射方程来计算每个表面点的局部阴影。在局部光照算法Li(l)已给出，不需要计算。</strong></p>
<p><strong>在现实场景中，Li(l)包括来自各个方向的非零辐亮度，不论是直接由光源发出还是由其他表面反射而来。与第5.2节中讨论的定向光源和点灯不同，真实世界的光源是覆盖非零立体角的区域光源。在本章中，我们使用L的限制形式Li(l)只包含方向灯和点灯，将更一般的照明环境留给第10章。这个限制允许更集中的讨论。</strong></p>
<p><strong>虽然准时光和定向光是非物理抽象的，但它们可以作为物理光源的近似来推导。这样的推导是重要的，因为它使我们能够在一个基于物理的渲染框架中合并这些光，并且我们能够自信地理解所涉及的错误。</strong></p>
<p><strong>我们取一个小的，远处的光，定义lc 作为指向它中心的向量。我们还定义了光的颜色clight 如白色的朗伯氏表面对着光的反射亮度(n = lc)。这是对创作的直观定义，因为光的颜色直接对应着它的视觉效果。</strong></p>
<p><strong>根据这些定义，可以导出一个方向光作为缩小面积光的大小为零而保持c值的极限情况light 。在这种情况下，反射率方程中的积分简化为单个BRDF计算，计算成本大大降低:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113738.png" class="" title="image-20211002113738">

<p><strong>点积(n·l)通常被固定为零，作为跳过表面下光源贡献的一种方便的方法:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113746.png" class="" title="image-20211002113746">

<p><strong>注意1.2节中介绍的x+符号，它表示负数被固定为零。</strong></p>
<p><strong>准时的灯光也可以用类似的方法来处理。唯一的区别是区域光不需要是远距离的，clight 如第5.11公式(111页)所示。在多个光源的情况下，将上上式多次计算，并将结果求和:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211002113857.png" class="" title="image-20211002113857">

<p><strong>lci和clighti 分别为第i个光的方向和颜色。注意公式5.6(第109页)的相似之处。</strong></p>
<p><strong>上式中的π因子抵消了BRDFs中经常出现的1/π因子。这个取消将除法操作移出着色器，使着色方程更容易读取。然而，当从学术论文中改编BRDFs用于实时着色方程时，必须小心。通常情况下，BRDF在使用前需要乘以π。</strong></p>
<h2 id="Fresnel-Reflectance-菲尼尔反射"><a href="#Fresnel-Reflectance-菲尼尔反射" class="headerlink" title="Fresnel Reflectance 菲尼尔反射"></a>Fresnel Reflectance 菲尼尔反射</h2><p><strong>在第9.1节中，我们从高层讨论了光与物质的相互作用。在第9.3节中，我们介绍了用数学方法表达这些相互作用的基本机制:BRDF和反射方程。现在我们准备开始深入到特定的现象，量化它们，以便它们可以用于着色模型。我们将从平面反射开始，第一次讨论在章节9.1.3。</strong></p>
<p><strong>物体的表面是周围介质(通常是空气)和物体本身之间的界面。光与两种物质之间的平面界面的相互作用遵循奥古斯汀-让·菲涅耳(1788 - 1827)提出的菲涅耳方程。菲涅耳方程要求遵循几何光学假设的平面界面。换句话说，假设表面在1个波长和100个波长之间没有任何不规则。小于此范围的不规则度对光线没有影响，较大的不规则度会使表面倾斜，但不会影响其局部平坦度。</strong></p>
<p><strong>入射到平面上的光分为反射部分和折射部分。反射光的方向(用矢量ri表示)形成相同的角(θi)，以表面法线n为入射方向l。反射矢量ri 可以由n和l计算:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003113634.png" class="" title="image-20211003113634">

<p><strong>参见下图。反射光的数量(作为入射光的一部分)由菲涅耳反射率F描述，它取决于入射角θi．</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003113720.png" class="" title="image-20211003113720">

<p>平面上的反射光向量l围绕法向量n反射，以生成ri．首先，将l投影到n上，得到法线(n·l)n的缩放版本。然后求l的负数，加上投影向量的两倍得到反射向量。</p>
<p><strong>如第9.1.3节所述，反射和折射受平面两侧两种物质折射率的影响。我们将继续使用之前讨论过的符号。n1 在入射光和反射光传播的界面上方的物质的折射率是否为n2 为折射光传播的界面下方物质的折射率。</strong></p>
<p><strong>菲涅耳方程描述了F对θi,n1和n2的依赖关系．我们将描述它们的重要特征，而不是给出方程本身，因为它们有些复杂。</strong></p>
<h3 id="External-Reflection-全反射"><a href="#External-Reflection-全反射" class="headerlink" title="External Reflection 全反射"></a>External Reflection 全反射</h3><p><strong>全反射是n1 &lt; n2．换句话说，光线是从表面折射率较低的一侧发出的。通常，这一面含有空气，折射率约为1.003。为简单起见，我们假设n1 = 1。相反的转变，从物体到空气，称为内部反射，将在后面的章节9.5.3中讨论。</strong><br><strong>对于给定的物质，菲涅耳方程可以定义一个反射率函数F(θi)，只取决于入射光的角度。理论上F(θi)的值在可见光谱上不断变化。出于渲染目的，它的值被视为RGB向量。函数F(θi)有下列特点:</strong></p>
<pre><code>**•当θi=0 ◦使光线垂直于表面(l = n)， F(θi)具有一种价值，即该物质的一种属性。这个值,F0，可以认为是该物质特有的镜面颜色。θi = 0◦的情况 叫做正态入射。**

**•为θi 当光照射到表面的角度增大时，F(θi)将趋于增加，在θi= 90◦ 处所有频率(白色)均为1．**
</code></pre>
<p><strong>下图显示了F(θi)的功能，以几种不同的方式表现出来。曲线是高度非线性的，在θi = 75◦之前几乎没有变化然后快速到1。从F0 到1开始的增加是单调的，尽管一些物质(如下图中的铝)在变成白色之前有轻微的下降。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003114533.png" class="" title="image-20211003114533">

<p>菲涅耳反射率F为三种物质的全反射:玻璃，铜和铝(从左到右)。最上面一行是F作为波长和入射角的函数的三维图。第二行显示了每个入射角的光谱值F转换为RGB，并绘制为每个颜色通道的单独曲线。玻璃的曲线是一致的，因为它的菲涅耳反射率是无色的。在第三行，R、G和B曲线与入射角的正弦曲线相对应，以解释下图中所示的透视缩短。下面一行的条带使用相同的x轴，将RGB值显示为颜色。</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003114617.png" class="" title="image-20211003114617">

<p>远离眼睛倾斜的表面被缩短。这种透视缩短与根据v和n之间夹角的正弦(对于镜面反射，这与入射角相同)来突出表面点是一致的。因此，在上图和下图中，菲涅耳反射率与入射角的正弦作了对比。</p>
<p><strong>在镜面反射的情况下，出射角或视角与入射角相同。这意味着表面是在一个瞥视角度进入具有θi 接近90◦值的光也与眼睛有一个斜视角度。由于这个原因，反射的增加主要是在物体的边缘看到的。此外，从相机的角度来看，表面反射率增加最强的部分被缩短了，因此它们只占用相对较少的像素。下图和上上图下半部分的菲涅尔反射率图和彩色条与sin(θi)作对比，以显示菲涅尔曲线的不同部分与它们的视觉突出度成比例，而不是直接指向θi．上图说明了为什么sin(θi)是为此目的而适当选择的轴。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003114846.png" class="" title="image-20211003114846">

<p>Schlick的近似菲涅尔反射率与六种物质全反射的正确值进行比较。排名前三的物质与上上图相同:玻璃、铜和铝(从左到右)。底部的三种物质是铬、铁和锌。每一种物质都有一个RGB曲线图，实线显示完整的菲涅耳方程，虚线显示Schlick的近似。每个曲线图下面的上色条显示的是完整菲涅耳方程的结果，下色条显示的是Schlick近似的结果。</p>
<p><strong>从这里开始，我们通常用F(n, l)来代替F(θi)，以强调所涉及的向量。回想一下,θi 是向量n和l之间的夹角。当菲涅耳函数作为BRDF的一部分加入时，通常会用不同的向量代替表面法线n。详情请参见9.8节。</strong></p>
<p><strong>在渲染出版物中，反射角度的增加通常被称为菲涅耳效应(在其他领域，这个术语与无线电波的传输有不同的含义)。你可以通过一个简短的实验自己看到菲涅耳效应。拿一部智能手机，坐在明亮的地方，比如电脑显示器前。在不打开手机的情况下，首先将手机拿近胸部，向下看，并稍微倾斜，使其屏幕能够反射屏幕。在手机屏幕上应该有一个相对较弱的显示器反射。这是因为玻璃的正入射反射率很低。现在把智能手机举起来，让它大致位于你的眼睛和显示器之间，再次调整屏幕的角度反映了班长。现在显示器在手机屏幕上的反射应该几乎和显示器本身一样亮。</strong></p>
<p><strong>除了它们的复杂性，菲涅耳方程还有其他的特性，使得直接使用它们来绘制变得困难。它们需要在可见光谱上取样的折射率值，这些值可能是复数。上上图中的曲线表明了一种基于特征高光颜色F0的更简单的方法．Schlick给出了菲涅耳反射率的近似:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003115041.png" class="" title="image-20211003115041">

<p><strong>这个函数是白色和F0之间的RGB插值．尽管如此简单，这种近似还是相当准确的。</strong></p>
<p><strong>上图包含了一些从Schlick曲线发散出来的物质，在变成白色之前显示出明显的“下降”。事实上，最下面一行的物质之所以被选中，是因为它们在很大程度上偏离了Schlick近似。即使对于这些物质，产生的误差也是相当细微的，如图中每个图底部的色条所示。在极少数情况下，精确捕捉这些材质的行为非常重要，可以使用Gulbrandsen给出的另一种近似方法。这种近似可以达到与金属的全菲涅耳方程很接近的结果，尽管它更接近在计算上比Schlick的昂贵。一个更简单的选择是修改Schlick的近似，以允许将最后一项提升为5以外的幂(如下下式)。这将改变“锐度”的过渡到白色在90◦，这可能导致更接近的匹配。 Lagarde总结了菲涅耳方程及其几个近似。</strong></p>
<p><strong>当使用Schlick近似时，F0 是唯一控制菲涅耳反射率的参数。这很方便，因为F0 在[0,1]中有一个定义良好的有效值范围，很容易用标准的选色界面进行设置，并且可以使用为颜色设计的纹理格式进行纹理化。另外，F0 的参考值可获得许多真实世界的材质。折射率也可以用来计算F0．假设n1 = 1是空气折射率的近似值，用n代替n2 表示物体的折射率。这种简化得到以下方程:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003115243.png" class="" title="image-20211003115243">

<p><strong>如果使用(复)折射率的大小，这个方程甚至适用于复数折射率(如金属折射率)。在折射率在可见光谱上显著变化的情况下，计算F0 的准确RGB值需要先计算F0 ，然后使用8.1.3节所述的方法将得到的光谱矢量转换为RGB值。</strong></p>
<p><strong>在一些应用中使用了更一般的Schlick近似形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003115336.png" class="" title="image-20211003115336">

<p><strong>这提供了对菲涅尔曲线在90◦转场时的颜色的控制，以及转型的“锐度”。使用这种更普遍的形式通常是出于增加艺术控制的愿望，但在某些情况下它也有助于匹配物理现实。如上所述，修改功率可以使某些材料更适合。同时,设置F90 可以帮助匹配菲涅耳方程没有很好地描述的材料，例如表面覆盖着颗粒大小为单个光波长的细粉尘。</strong></p>
<h3 id="Typical-Fresnel-Reflectance-Values-典型菲涅耳反射率值"><a href="#Typical-Fresnel-Reflectance-Values-典型菲涅耳反射率值" class="headerlink" title="Typical Fresnel Reflectance Values 典型菲涅耳反射率值"></a>Typical Fresnel Reflectance Values 典型菲涅耳反射率值</h3><p><strong>物质根据其光学性质可分为三大类。有电介质，是绝缘体;金属是导体;还有半导体，它的特性介于电介质和金属之间。</strong></p>
<h4 id="Fresnel-Reflectance-Values-for-Dielectrics-介质的菲涅耳反射值"><a href="#Fresnel-Reflectance-Values-for-Dielectrics-介质的菲涅耳反射值" class="headerlink" title="Fresnel Reflectance Values for Dielectrics 介质的菲涅耳反射值"></a>Fresnel Reflectance Values for Dielectrics 介质的菲涅耳反射值</h4><p><strong>日常生活中遇到的大多数材料都是电介质——玻璃、皮肤、木材、头发、皮革、塑料、石头和混凝土等等。水也是一种电介质。最后一个可能是令人惊讶的是，因为在日常生活中，水是导电的，但这种导电是由于各种杂质。电介质的F0值相当低通常为0.06或更低。这种正入射时的低反射率使得菲涅耳效应在电介质中尤其明显。电介质的光学特性在可见光谱中很少有很大的变化，导致无色的反射值。F0 几种常用电介质的值见下表。这些值是标量而不是RGB，因为RGB通道对于这些材料没有显著的差异。为方便起见，下表包括线性值以及用sRGB传递函数编码的8位值(纹理绘制应用程序通常使用的形式)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003115747.png" class="" title="image-20211003115747">

<p>F0 的值适用于各种介质的全反射。每个值都以线性数字、纹理值(非线性编码的8位无符号整数)和颜色样本的形式给出。如果给定了一个值的范围，那么色块就在范围的中间。回想一下，这些是高光色。例如，宝石通常有鲜艳的颜色，但这些颜色是物质内部吸收的结果，与菲涅尔反射率无关。</p>
<p><strong>F0 其他电介质的值可以通过查看表中的类似物质来推断。对于未知介质，0.04是一个合理的默认值，与大多数常见材料相差不大。</strong></p>
<p><strong>一旦光被传输到电介质中，它可能会被进一步散射或吸收。这个过程的模型将在第9.9节中进行更详细的讨论。如果材质是透明的，光线将一直持续到“从内部”照射到物体表面，详见章节9.5.3。</strong></p>
<h4 id="Fresnel-Reflectance-Values-for-Metals-金属的菲涅耳反射率值"><a href="#Fresnel-Reflectance-Values-for-Metals-金属的菲涅耳反射率值" class="headerlink" title="Fresnel Reflectance Values for Metals 金属的菲涅耳反射率值"></a>Fresnel Reflectance Values for Metals 金属的菲涅耳反射率值</h4><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003120014.png" class="" title="image-20211003120014">

<p>F0 的值用于各种金属(和一种合金)的全反射，按亮度的增加排序。金色的实际红色值稍微超出了sRGB范围。显示的值是夹紧后的值。</p>
<p><strong>金属的F0值很高几乎总是0.5或以上。有些金属具有在可见光谱中变化的光学特性，从而产生彩色的反射率值。F0 几种金属的值见上表。</strong></p>
<p><strong>与上上表类似，上表有线性值以及用于纹理的8位sRGB编码值。然而，这里我们给出RGB值，因为许多金属都有彩色菲涅耳反射。这些RGB值是使用sRGB(和Rec. 709)原色和白点定义的。黄金有一个不同寻常的F0 价值。它是颜色最强烈的，红色通道值略高于1(它刚好在sRGB/Rec之外。709色域)和特别低的蓝色通道值(上表中唯一显著低于0.5的值)。它也是最亮的金属之一，这可以从它在表中的位置看出，这是根据其亮度的增加来排序的。黄金的明亮和强烈的反射可能有助于它在历史上独特的文化和经济意义。</strong></p>
<p><strong>回想一下，金属会立即吸收任何透射光，因此它们不会表现出任何次表面散射或透明度。金属的所有可见颜色都从F0显现出来了．</strong></p>
<h4 id="Fresnel-Reflectance-Values-for-Semiconductors-半导体的菲涅耳反射值"><a href="#Fresnel-Reflectance-Values-for-Semiconductors-半导体的菲涅耳反射值" class="headerlink" title="Fresnel Reflectance Values for Semiconductors 半导体的菲涅耳反射值"></a>Fresnel Reflectance Values for Semiconductors 半导体的菲涅耳反射值</h4><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003120329.png" class="" title="image-20211003120329">

<p>F0 的值与明亮的介质(钻石)和黑色金属(钛)相比，具有代表性的半导体(晶体形式的硅)。</p>
<p><strong>正如人们所预料的那样，半导体具有F0 值介于最亮电介质和最暗金属之间，如上表所示。在实践中很少需要渲染这些物质，因为大多数渲染场景都没有散布晶体硅块。为了实际目的，F0 的范围应该避免在0.2和0.45之间的值，除非你有意试图模拟一个奇异或不切实际的材料。</strong></p>
<h4 id="Fresnel-Reflectance-Values-in-Water-水中的菲涅耳反射率"><a href="#Fresnel-Reflectance-Values-in-Water-水中的菲涅耳反射率" class="headerlink" title="Fresnel Reflectance Values in Water 水中的菲涅耳反射率"></a>Fresnel Reflectance Values in Water 水中的菲涅耳反射率</h4><p><strong>在我们讨论全反射时，我们假设渲染的表面被空气包围。如果没有，反射率将会改变，因为它取决于界面两侧折射率之间的比率。如果我们不能再假设n1 = 1，则需要将之前式中的n替换为相对折射率n1/ n2．这就得到了以下更一般的等式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003120447.png" class="" title="image-20211003120447">

<p><strong>可能是最常见的情况，n1 ≠1是渲染水下场景。由于水的折射率大约是空气的1.33倍，F0 在水下是不同的。这种效应在电介质中比在金属中更强，如下表所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003120559.png" class="" title="image-20211003120559">

<p>F0 值之间的比较在空气中，在水中，对于各种物质。从上式可以看出，折射率接近水的电介质受到的影响最大。相比之下，金属几乎没有受到影响。</p>
<h4 id="Parameterizing-Fresnel-Values-参数化菲涅耳值"><a href="#Parameterizing-Fresnel-Values-参数化菲涅耳值" class="headerlink" title="Parameterizing Fresnel Values 参数化菲涅耳值"></a>Parameterizing Fresnel Values 参数化菲涅耳值</h4><p><strong>一种常用的参数化方法是将镜面颜色F0 弥散色ρss (漫反射颜色将在9.9节中进一步讨论)。这种参数化利用了观察到的金属没有漫反射颜色和电介质有一组F0可能值的限制集，它包括RGB表面颜色csurf 以及标量参数m，称为“金属”或“金属性”。”如果m = 1，那么F0 设置为csurf 和ρss 设置为黑色。如果m = 0，那么F0 设置为介电值(常数或由附加参数控制)和ρss 设置为csurf ．</strong></p>
<p><strong>“metalness”参数首次出现在布朗大学(Brown University)使用的早期着色模型中，其当前形式的参数化首次被皮克斯(Pixar)在电影《机器人总动员》(Wall-E)中使用。对于迪士尼原则性的着色模型，从《无敌破坏王》开始在迪士尼动画电影中使用，Burley添加了一个额外的着色模型标量“镜面”参数来控制电介质F0 在一定范围内。这种形式的参数化在Unreal Engine中使用，Frostbite引擎使用了稍微不同的形式，F0 的范围可能更大电介质的值。《使命召唤:无限战争》使用了一种变体，将这些金属属性和镜面参数整合到一个单一值中，以节省记忆。</strong></p>
<p><strong>对于那些使用金属参数化而不是使用F0 和ρss 的渲染应用程序直接来说，动机包括用户方便和保存纹理或G-buffer存储。在游戏《使命召唤:无限战争》中，这种参数化以一种不同寻常的方式使用。艺术家为F0 和ρss绘制纹理，自动转换为金属度参数化作为压缩方法。</strong></p>
<p><strong>使用金属性也有一些缺点。它不能表达某些类型的材料，例如涂有着色电介质F0的值。伪影可能出现在金属和电介质之间的边界上。</strong></p>
<p><strong>一些实时应用程序使用的另一个参数化技巧利用了没有材料具有F0 值低于0.02这一事实，外涂特殊防反射涂层。这个技巧被用来抑制表面区域的高光，这些区域代表空洞或空隙。而不是使用单独的高光遮挡纹理，值F0 低于0.02用于“关闭”菲涅耳边缘亮度。这种技术首先由Sch¨uler提出，并在Unreal和Frostbite引擎中使用。</strong></p>
<h3 id="Internal-Reflection-全反射"><a href="#Internal-Reflection-全反射" class="headerlink" title="Internal Reflection 全反射"></a>Internal Reflection 全反射</h3><p><strong>虽然在渲染中经常遇到全反射，但内部反射有时也很重要。当n1 &gt; n2．在换句话说，当光在透明物体内部传播并“从内部”遇到该物体表面时，全反射就发生了。见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003121347.png" class="" title="image-20211003121347">

<p>平面上的全反射，其中n1 &gt; n2．</p>
<p><strong>斯涅尔定律表明，对于内反射，sin θt &gt; sinθi．因为这些值都在0◦ 和90◦之间，这个关系式也暗示了θt &gt;θi，如上图所示。在全反射的情况下，情况正好相反。这种差异是理解内部反射和全反射如何不同的关键。在全反射中，sin θt的一个有效(较小)值 对于sin θi 的任何可能值都存在在0和1之间。对于内在反思来说，情况并非如此。对于θi 的值大于临界角θc斯涅尔定律暗示sin θt &gt;1，这是不可能的。事实上，根本就没有θt．当θi &gt;θc时，不发生透射，所有射入的光都被反射。这种现象被称为全反射。</strong></p>
<p><strong>菲涅耳方程是对称的，因为入射矢量和透射矢量可以互换，反射率保持不变。结合斯涅尔定律，这种对称性意味着F(θi)内部反射曲线将类似于全反射曲线的“压缩”版本。F0 的值是相同的，全反射曲线在θc 而不是90◦．如下图所示。下图还显示，平均而言，内部反射的反射率更高。例如，这就是为什么在水下看到的气泡具有高度反光的银色外观。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003121741.png" class="" title="image-20211003121741">

<p>玻璃-空气界面内外反射曲线的比较。在临界角θc处，内反射率曲线趋于1.0．</p>
<p><strong>全反射只发生在电介质中，因为金属和半导体会迅速吸收在它们内部传播的任何光。由于介质具有实值折射率，从折射率或从计算临界角度F0 很简单:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003121842.png" class="" title="image-20211003121842">

<p><strong>之前式中所示的Schlick近似对于全反射是正确的。通过代入透射角θt 为θi，可用于内反射．如果已经计算出透射方向矢量t(例如，绘制折射-见14.5.2节)，就可以用它来求θt．否则就可以用斯涅尔定律了计算θt 从θi，但这是昂贵的，并需要折射率，这可能无法得到。</strong></p>
<h2 id="Microgeometry-微观几何"><a href="#Microgeometry-微观几何" class="headerlink" title="Microgeometry 微观几何"></a>Microgeometry 微观几何</h2><p><strong>正如我们在前面的9.1.3节中讨论的，比像素小得多的表面不规则性不能被明确地建模，因此BRDF从统计角度对其聚合效应进行建模。目前，我们仍停留在几何光学领域，该领域假设这些不规则性要么小于光的波长(因此对光的行为没有影响)，要么要大得多。在“波动光学领域”(大约1-100个波长)中不规则的影响将在第9.11节中讨论。</strong></p>
<p><strong>每个可见表面点包含许多微表面法线，这些法线将反射光反射到不同的方向。由于各个微表面的方向在某种程度上是随机的，因此将它们建模为统计分布是有意义的。对于大多数表面，微观几何表面法线的分布是连续的，在宏观表面法线处有一个强烈的峰值。这种分布的“紧密性”是由表面粗糙度决定的。表面越粗糙，微几何法线就越“分散”。</strong></p>
<p><strong>增加微尺度粗糙度的可见效果是反射的环境细节更模糊。在小而明亮的光源的情况下，这种模糊导致更宽和更暗的高光。那些来自粗糙表面的光线更暗，因为光能扩散到一个更大的方向锥。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003124128.png" class="" title="image-20211003124128">

<p>从可见细节到微尺度的渐变。图像序列从上一行从左到右，然后从下一行从左到右。表面形状和光照是恒定的。只有表面细节的比例发生了变化。</p>
<p><strong>上图显示了可见光反射是如何由单个微尺度表面细节的聚合反射产生的。这一系列的图像显示了一个被单一光线照亮的曲面，其中的凸起在比例上稳步下降，直到最后一张图像中的凸起比单个像素小得多。许多小亮点中的统计模式最终成为最终聚合亮点形状的细节。例如，相对稀疏的个别凹凸高光在外围成为相对黑暗的聚集高光远离其中心。</strong></p>
<p><strong>对于大多数表面，微尺度表面法线的分布是各向同性的，这意味着它是旋转对称的，没有任何固有的方向性。其他表面具有各向异性的微尺度结构。这些表面具有各向异性的表面正态分布，导致反射和高光的方向模糊。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003124226.png" class="" title="image-20211003124226">

<p>左边是各向异性表面(拉丝金属)。注意反射的方向模糊。在右边，一张显微照片显示了一个相似的表面。注意细节的方向性。(显微照片由康奈尔大学计算机图形学程序提供。)</p>
<p><strong>一些表面具有高度结构的微几何，导致各种微尺度正态分布和表面形貌。织物是一个常见的例子——天鹅绒和缎子的独特外观是由于它们的微几何结构。面料模型将在第9.10节中讨论。</strong></p>
<p><strong>虽然多重表面法线是微几何对反射率的主要影响，但其他影响也可能很重要。阴影是指光源通过微尺度表面细节的遮挡，如下图左侧所示。掩蔽，也就是一些面隐藏了其他面的镜头，显示在图的中心。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003124332.png" class="" title="image-20211003124332">

<p>微尺度结构的几何效应。在左边，黑色虚线箭头表示一个区域被其他微几何体遮蔽(从光遮蔽)。在中间，红色虚线箭头表示一个区域被其他微几何遮罩(从视图中遮挡)。右图显示了微尺度结构之间的光相互反射。</p>
<p><strong>如果微几何高度与表面法线有一定的相关性，那么阴影和掩蔽可以有效地改变正态分布。例如，想象一个表面，凸起的部分已经被风化或其他过程磨平，而较低的部分仍然粗糙。在反光角度，较低的部分的表面将倾向于阴影或蒙面，导致一个有效的光滑表面。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003124436.png" class="" title="image-20211003124436">

<p>显微几何图形显示高度和表面法线之间有很强的相关性，凸起的区域是平滑的，较低的区域是粗糙的。在上面的图像中，表面从一个接近宏观表面法线的角度被照亮。在这个角度，许多入射光线都能进入粗糙的凹坑，所以很多光线会分散到不同的方向。在下面的图像中，表面从一个角度被照亮。阴影挡住了大部分凹坑，所以很少有光线照射到凹坑上，大部分光线都是从表面光滑的部分反射回来的。在这种情况下，表观粗糙度很大程度上取决于照明角度。</p>
<p><strong>对于所有的表面类型，表面不规则的可见尺寸随入射角θi 的增大而减小增加到正常水平。在非常倾斜的角度，这种效应可以减少不规则的观察尺寸，使其小于光的波长，使它们“消失”，就光响应而言。这两种效果结合菲涅尔效应，使表面出现高度反射和镜子一样的视角和照明角度接近90◦。</strong></p>
<p><strong>你自己确认一下。把一张不发亮的纸卷成一个长管。不要从洞里往外看，把你的眼睛稍微抬高一点，这样你就可以往下看长度。把你的电视机对着明亮的窗户或电脑屏幕。当你的视角几乎与纸张平行时，你会看到窗户或屏幕在纸张上的强烈反射。角度必须非常接近90度◦ 看看效果如何。</strong></p>
<p><strong>被微尺度表面细节遮挡的光不会消失。它可能会反射到其他的微观几何结构上。光在到达眼睛之前可能会以这种方式经历多次反射。这样的相互反射如上上图的右侧所示。由于光在每次反弹时都被菲涅耳反射率衰减，所以在电介质中相互反射往往是微妙的。在金属中，多次反射是任何可见漫反射的来源，因为金属缺乏次表面散射。有色金属的多次反射比主反射颜色更深，因为它们是光与表面多次相互作用的结果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003124631.png" class="" title="image-20211003124631">

<p>由于微尺度粗糙度的反射。这两幅图都显示了一个粗糙的表面，低菲涅耳反射率和高散射反照率，因此地下反射率在视觉上很重要。在左边，观看和照明方向是相似的。微几何的明亮部分也是最可见的部分，导致了明亮的外观。在右侧，观看和照明方向差异很大。在这种情况下，明亮的区域被遮挡从视图和可见区域被阴影，导致一个更暗的外观。</p>
<p><strong>到目前为止，我们已经讨论了微几何对镜面反射率的影响。，即表面反射率。在某些情况下，微尺度的表面细节也会影响地下反射率。如果微几何形状的不规则性大于次表面散射距离，那么阴影和掩蔽会导致反反射效应，光线会优先反射回入射方向。这种效果的发生是因为阴影和掩蔽将遮挡光照区域时，观察和照明方向的差异很大。参见上图。反光会使粗糙的表面变得平整。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211003124642.png" class="" title="image-20211003124642">

<p>由于微尺度的表面粗糙度，两个物体表现出非朗伯特反反射行为的照片。(右侧照片由Peter-Pike Sloan提供。)</p>
<h2 id="Microfacet-Theory-微表面理论"><a href="#Microfacet-Theory-微表面理论" class="headerlink" title="Microfacet Theory 微表面理论"></a>Microfacet Theory 微表面理论</h2><p><strong>许多BRDF模型都是基于微几何对反射率影响的数学分析，称为微面理论。该工具最初是由光学领域的研究人员开发的。1977年Blinn和1981年Cook和Torrance将它引入计算机图形学。该理论的基础是将微几何建模为微表面的集合。</strong></p>
<p><strong>每个微面都是平的，有一个微表面法线m。微表面根据微BRDF fμ分别反射光µ(l, v, m)，所有微表面的综合反射率加起来等于整个表面BRDF。通常的选择是每个微表面都是一个完美的菲涅尔镜面，从而产生一个镜面微表面 BRDF来建模表面反射。然而，也有其他选择。漫反射微BRDFs已经被用于创建多个局部次表面散射模型。衍射微BRDF被用来创建一个结合几何和波动光学效应的着色模型。</strong></p>
<p><strong>微表面模型的一个重要特性是微表面法线m的统计分布。这种分布由表面的正态分布函数(NDF)定义。一些参考文献使用了术语正态分布，以避免与高斯正态分布混淆。我们将用D(m)来表示方程中的NDF。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004115934.png" class="" title="image-20211004115934">

<p>微表面的侧视图。在左边，我们看到积分D(m)(n·m)， 微表面面积投影到宏观平面上，得到宏观表面的面积(在这个侧视图中，长度)，按照惯例是1。在右边,整合D (m) (v·米),微表面面积投射到平面垂直于v,等于微表面这个平面上的投影,cosθo或(v·n)。当多个微表面重叠的预测,背面微表面的负的投影面积沿微表面抵消“额外”前面的微表面。(以Matej Drame的人物命名。)</p>
<p><strong>NDF D(m)是微表面表面法线在微几何表面积上的统计分布。对整个微表面法线球积分D(m)就得到了微表面的面积。更有用的是，对D(m)(n·m)进行积分，D(m)在宏观平面上的投影，可以得到宏观patch的面积，按照惯例等于1，如上图左侧所示。也就是说，投影D(m)(n·m)是归一化的:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004120322.png" class="" title="image-20211004120322">

<p><strong>这个积分是在整个球面上进行的，这里用Θ表示，不像本章中之前的球面积分，只对以n为中心的半球进行积分，用Ω表示。尽管一些参考文献使用Ω来表示完整的球体，但大多数图形出版物都使用这种符号。在实际应用中，图形中使用的微观结构模型多为高度场，即在Ω外的m方向上，D(m) = 0。然而，上式同样适用于非高度场微结构。</strong></p>
<p><strong>一般来说，微面和宏观面在垂直于任意视图方向v的平面上的投影是相等的:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004141747.png" class="" title="image-20211004141747">

<p><strong>上面两个方程中的点积不是固定为0。上图的右侧显示了原因。上面两个方程规定了函数D(m)必须服从的约束条件，使其为有效的NDF。</strong></p>
<p><strong>直观地说，NDF就像微表面法线的直方图。它在微表面法线更可能指向的方向上有高值。大多数表面都有NDF，在宏观表面法线n处显示一个强烈的峰值。9.8.1节将涵盖在渲染中使用的几个NDF模型。</strong></p>
<p><strong>再看一下上图的右侧。尽管有许多具有重叠投影的微表面，但最终为了渲染，我们只关心可见的微表面，即。，在每个重叠集中最接近相机的微表面。这一事实提出了一种将投影的微表面面积与投影的宏观几何区域关联起来的替代方法:可见微表面的投影面积之和等于宏观曲面的投影面积。我们可以通过定义掩蔽函数G1(m, v)来用数学方法来表示它，它给出沿视图向量v可见的法向m的微表面的分数。G1(m, v)D(m)(v·m)+ 的积分球面，然后给出宏观表面投影到垂直于v的平面上的面积:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004142027.png" class="" title="image-20211004142027">

<p><strong>如下图所示。与上上式不同，上式中的点积是固定为零的。这个运算用x+ 表示在第1.2节中介绍的符号。背面的微表面不可见，因此在本例中不计算它们。产品G1(m, v)D(m)为可见正态分布。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004142057.png" class="" title="image-20211004142057">

<p>将可见微表面的投影面积(亮红色)进行积分，就可以得到宏观表面在垂直于v的平面上的投影面积。</p>
<p><strong>而上式对G1(m, v)施加约束它不是唯一决定它的。有无限函数满足给定微表面正态分布D(m)的约束。这是因为D(m)没有完全指定微表面。它告诉我们有多少微表面的法线指向某个方向，但不告诉我们它们是如何排列的。</strong></p>
<p><strong>尽管各种G1 多年来一直有人提出函数，但在Heitz的一篇优秀论文中(至少目前)解决了该使用哪个函数的难题。Heitz讨论了Smith掩蔽函数，它最初是由高斯正态分布推导出来的，后来推广到任意NDFs。Heitz证明，在文献中提出的掩模函数之外，只有两个——Smith函数和Torrance-Sparrow“V-cavity”函数——服从上式，因此在数学上是有效的。他进一步表明，史密斯函数比托伦斯-斯派洛函数更接近于随机微表面的行为。Heitz还证明了Smith掩蔽函数是唯一可能的既符合上式又具有正规掩蔽独立性的函数。这意味着G1(m, v)的值不依赖于m的方向，只要m不是背向的。只要m·v≥0。史密斯G1 函数的形式如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004142409.png" class="" title="image-20211004142409">

<p><strong>其中χ+(x)为正特征函数</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004142418.png" class="" title="image-20211004142418">

<p><strong>Λ(lambda)函数对于每个NDF是不同的。Walter等人和Heitz的出版物中描述了为给定NDF推导 Λ的过程。</strong></p>
<p><strong>Smith屏蔽函数确实有一些缺点。从理论的角度来看，它的要求与实际表面的结构不一致，甚至可能在物理上无法实现。从实用的角度来看，虽然它对随机表面是相当精确的，但对于法向和掩蔽之间有更强依赖性的表面，其精度预期会降低，特别是如果表面有一些重复结构(就像大多数织物)。然而，在找到更好的替代方案之前，它是大多数呈现应用程序的最佳选择。</strong></p>
<p><strong>给出微几何描述，包括微BRDF fµ(l, v, m)，正态分布函数D(m)，掩蔽函数G1(m, v)，可推导出整体宏观表面BRDF:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004142624.png" class="" title="image-20211004142624">

<p><strong>这个积分是在以n为中心的半球Ω上，以避免从表面下收集光的贡献。而不是掩蔽函数G1(m, v)， 上式使用联合遮蔽函数G2(l v m)这个函数，由G1，给出了从两个方向可见的具有法向m的微表面的比例:视图向量v和光向量l2 函数，上式使BRDF能够考虑掩蔽和遮蔽，但不考虑微表面之间的相互反射。缺少微表面相互反射是由上式推导出来的所有BRDFs共有的一个限制。因此，这样的BRDFs有些过于黑暗。在9.8.2和9.9节中，我们将讨论一些已经提出的解决这一限制的方法。</strong></p>
<p><strong>Heitz讨论了G2 函数。最简单的是可分离形式，其中掩蔽和阴影分别使用G1 进行评估相乘:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004142913.png" class="" title="image-20211004142913">

<p><strong>这种形式相当于假设遮蔽和遮蔽是不相关的事件。在现实中，它们不是，并且假设导致BRDFs使用这种形式的G2过度暗化．</strong></p>
<p><strong>作为一个极端的例子，考虑视图和光方向相同的情况。这里是G2 应该等于G1，因为所有可见的面都没有阴影，但使用上式G2 将等于G1²。</strong></p>
<p><strong>如果微表面是一个高度场，这通常是用于绘制微表面模型的情况，那么当v和l之间的相对方位角φ等于0◦,G2(l, v, m)等于min(G1 (v, m)，G1(l, m))。这种关系提供了一种解释掩蔽和遮蔽之间相关性的一般方法，可以用于任何G1 功能:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004143122.png" class="" title="image-20211004143122">

<p><strong>其中λ(φ)是随着角度φ增大而从0增加到1的函数。Ashikhmin等提出了一个标准差为15◦(~ 0.26 弧度)的高斯分布 :</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004143347.png" class="" title="image-20211004143347">

<p><strong>van Ginneken等人提出了一个不同的λ函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004143356.png" class="" title="image-20211004143356">

<p><strong>不管光线和视图方向的相对对齐，在一个给定的表面点上的遮蔽和阴影是相关的还有一个原因。两者都与点相对于曲面其余部分的高度有关。对于较低的点，掩蔽的概率增加，遮蔽的概率也增加。如果使用Smith掩蔽函数，这种相关性可以用Smith高度相关的掩蔽-阴影函数精确地解释:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004143432.png" class="" title="image-20211004143432">

<p><strong>海茨还描述了史密斯G2 它结合了方向和高度的相关性:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211004143446.png" class="" title="image-20211004143446">

<p><strong>其中λ(v, l)可以是一个经验函数，如上上上两个方程中的那些，或一个专门为给定NDF推导出来的函数。</strong></p>
<p><strong>在这些备选方案中，Heitz推荐了Smith函数的高度相关形式(上上式)，因为它的代价与不相关形式相似，而且精度更高。这种形式在实践中使用最广泛，尽管有些实践者使用可分离形式。</strong></p>
<p><strong>通用微表面 BRDF不直接用于渲染。它被用来推导一个闭形式的解(精确的或近似的)给定一个特定的微BRDF fµ选择．下一节将展示这种类型的派生的第一个示例。</strong></p>
<h2 id="BRDF-Models-for-Surface-Reflection-表面反射的BRDF模型"><a href="#BRDF-Models-for-Surface-Reflection-表面反射的BRDF模型" class="headerlink" title="BRDF Models for Surface Reflection 表面反射的BRDF模型"></a>BRDF Models for Surface Reflection 表面反射的BRDF模型</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006133451.png" class="" title="image-20211006133451">

<p>半矢量h与光矢量和视图矢量形成相等的角度(如图所示)。</p>
<p><strong>除了少数例外，在基于物理的渲染中使用的高光BRDF术语来自微表面理论。在镜面反射的情况下，每个微面是一个完美光滑的菲涅耳镜。回想一下，这种镜子将每一束射入的光线反射到一个单一的反射方向。这意味着微BRDF fµ每个面(l, v, m)等于零,除非v是平行的反射l。对于给定l和v向量,这个配置相当于情况微表面法线m是与一个向量指向l和诉的正中间。这个向量是半矢量h。参见上图。通过将v和l相加并对结果进行归一化计算:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006133405.png" class="" title="image-20211006133405">

<p><strong>当由之前式子推导镜面微面模型时，对于所有m≠ h，菲涅耳镜微BRDF fµ(l, v, m)等于零是很方便的，因为它将积分分解为在m = h处的积分函数的值。这样做就产生了镜面BRDF项</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006133631.png" class="" title="image-20211006133631">

<p><strong>关于推导的细节可以在Walter et al. ， Heitz和Hammon的出版物中找到。Hammon还提出了一种优化BRDF实现的方法，通过计算n·h和l·h而不计算向量h本身。</strong></p>
<p><strong>我们用符号fspec 对于上式中的BRDF项，表示它仅模拟表面(镜面)反射。在一个完整的BRDF中，它可能会与另一个模型下表面(漫反射)着色的术语配对。为了直观地理解上式，考虑到只有那些法线恰好与半矢量(m = h)对齐的微表面才能正确地将光线从l反射到v，见下图。因此，反射光的数量取决于法线等于h的微表面的浓度。这个值由D(h)给出，D(h)是那些从光线和视野方向都能看到的微表面的比例，等于G2(l, v, h)，以及每个微表面反射的光的部分，由F(h, l)指定。在求菲涅尔函数时，向量h代替表面法线。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006133857.png" class="" title="image-20211006133857">

<p>由微面组成的表面。只有表面法线与半矢量h对齐的红色微表面参与从入射光矢量l到视图矢量v的反射。</p>
<p><strong>在遮罩-阴影函数中使用半矢量可以进行较小的简化。由于涉及的角度永远不能大于90◦，χ+项在方程中可以被删除。</strong></p>
<h3 id="Normal-Distribution-Functions-正态分布函数"><a href="#Normal-Distribution-Functions-正态分布函数" class="headerlink" title="Normal Distribution Functions 正态分布函数"></a>Normal Distribution Functions 正态分布函数</h3><p><strong>正态分布函数对渲染表面的外观有重要影响。NDF的形状，绘制在微表面法线的球面上，决定了反射光线(镜面)的锥的宽度和形状叶)，这反过来决定了高光的大小和形状。NDF影响表面粗糙度的整体感知，以及更微妙的视觉方面，如高光是否有明显的边缘或被雾霾包围。</strong></p>
<p><strong>然而，镜面叶并不是NDF形状的简单复制。它，以及高光形状，根据表面曲率和视角的不同，被或大或小程度地扭曲。这种扭曲对于平面来说尤其强烈，如下图所示。Ngan等人对这种扭曲背后的原因进行了分析。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006134325.png" class="" title="image-20211006134325">

<p>左边的图像是用非物理Phong反射模型渲染的。该模型的镜面波瓣围绕反射矢量旋转对称。这种BRDFs在早期的计算机图形学中经常使用。中心的图像是用基于物理的微表面BRDF渲染的。左上方和中间显示了一个平面表面在一个斜视角度照明。左上方显示一个不正确的圆形高光，而中心显示微表面 BRDF上的特征高光延伸。正如右边的照片所示，中间的视图与现实相符。高光形状的差异在下面两个渲染图像中显示的球体上要微妙得多，因为在这种情况下，表面曲率是高光形状的主要因素。(摄影:Elan Ruskin)</p>
<h4 id="Isotropic-Normal-Distribution-Functions-各向同性正态分布函数"><a href="#Isotropic-Normal-Distribution-Functions-各向同性正态分布函数" class="headerlink" title="Isotropic Normal Distribution Functions 各向同性正态分布函数"></a>Isotropic Normal Distribution Functions 各向同性正态分布函数</h4><p><strong>大多数用于绘制的NDFs是关于宏观表面法线n的各向同性旋转对称。在这种情况下，NDF只是一个变量的函数，角度θm 在理想情况下，NDF可以写成cos θm 的表达式它可以被有效地计算为n和m的点积。</strong></p>
<p><strong>Beckmann NDF是光学界开发的第一个微表面模型中使用的正态分布。时至今日，它仍在那个社区被广泛使用。它也是为Cook-Torrance BRDF选择的NDF。归一化贝克曼分布有以下形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006164058.png" class="" title="image-20211006164058">

<p><strong>项χ+(n·m)确保所有微表面法线的NDF值为0宏观表面下的点。这个属性告诉我们，这个NDF，就像我们将在本节讨论的所有其他NDF一样，描述了一个高度场微表面。的αb 参数控制表面粗糙度。它与微几何表面的均方根(RMS)斜率成正比，因此αb = 0表示完美光滑的表面。</strong></p>
<p><strong>来推导Smith G2 对于Beckmann NDF函数，我们需要相应的Λ函数，代入9.24式(如果使用G2)， 9.31(高度相关形式)，或9.32(方向和高度相关形式)。</strong></p>
<p><strong>Beckmann NDF是形状不变的，这简化了Λ的推导。根据Heitz的定义，如果粗糙度参数的影响等效于微表面的缩放(拉伸)，则各向同性NDF是形状不变的。形状不变NDFs可以写成以下形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006164328.png" class="" title="image-20211006164328">

<p><strong>其中g表示任意的单变量函数。对于任意的各向同性NDF， Λ函数依赖于两个变量。第一个是粗糙度α，第二个是计算Λ的向量(v或l)的入射角。然而，对于形状不变的NDF， Λ函数只依赖于变量a:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006164358.png" class="" title="image-20211006164358">

<p><strong>其中s是表示v或l向量。在这种情况下，Λ只依赖于一个变量，这一事实便于实现。单变量函数可以更容易地用近似曲线拟合，并且可以在一维数组中制成表格。</strong></p>
<p><strong>贝克曼NDF的Λ函数为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006164410.png" class="" title="image-20211006164410">

<p><strong>上式的计算代价很高，因为它包含误差函数erf。为此，通常使用近似:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006164535.png" class="" title="image-20211006164535">

<p><strong>下一个我们要讨论的NDF是Blinn-Phong NDF。在过去，它在计算机图形学中被广泛使用，尽管在最近的时间里它已经被其他发行版所取代。Blinn-Phong NDF仍然用于计算成本较高的情况下(例如，在移动硬件上)，因为它比本节讨论的其他NDF的计算成本更低。</strong></p>
<p><strong>Blinn-Phong NDF是由Blinn推导出来的，是对(非物理的)Phong着色模型的修正:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006164728.png" class="" title="image-20211006164728">

<p><strong>αp 为Phong NDF的粗糙度参数。高值代表光滑表面，低值代表粗糙表面。αp 对于极其光滑的表面可以达到任意的高度——一个完美的镜子需要αp =∞。通过设置，可以得到最大随机表面(均匀NDF)αp 为0。αp 参数的视觉冲击力极不均匀，不便于直接操作。较小的数值变化对于较小的αp 值具有较大的视觉效果，但是较大的值可以在没有太多视觉影响的情况下进行显著更改。因此，αp 通常由用户操作的参数通过非线性映射导出。例如,αp=m^s，其中s是0到1之间的参数值，m是αp 的上限在给定的应用程序中。许多游戏都使用了这种映射，包括《使命召唤:黑色行动》，其中m被设置为8192。</strong></p>
<p><strong>当BRDF参数的行为在感知上不一致时，这种“接口映射”通常是有用的。这些映射用于解释通过滑块设置或绘制纹理的参数。</strong></p>
<p><strong>Beckmann和Blinn-Phong粗糙度参数的等值值可以用αp = 2αb^−2−2关系求得。当参数通过这种方式匹配时，两种分布非常接近，特别是对于相对光滑的表面，如下图左上角所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006165128.png" class="" title="image-20211006165128">

<p>左上方是Blinn-Phong(蓝色虚线)和Beckmann(绿色)分布的对比，αb的值从0.025到0.2(使用αp = 2αb^-2−2的参数关系)。右上方是GGX(红色)和Beckmann(绿色)分布的对比。αb 和左边的图一样。αg 已调整眼睛，以匹配高光大小。这些相同的值也被用在底部图像的球体中。顶部行使用Beckmann NDF，底部行使用GGX。</p>
<p><strong>Blinn-Phong NDF不是形状不变的，它的Λ函数不存在解析形式。Walter等人建议将贝克曼Λ函数与α函数结合使用p = 2αb^−2−2参数等价。</strong></p>
<p><strong>在同一篇1977年的论文中，Blinn将Phong着色函数应用到微表面 NDF中，他提出了另外两个NDF。在这三种分布中，Blinn推荐了Trowbridge和Reitz推导的一种分布。这一建议没有得到广泛重视，但30年后，沃尔特等人独立地重新发现了Trowbridge-Reitz分布，并将其命名为GGX分布。这一次，种子生根了。在几年内，GGX发行方式开始在电影和游戏行业传播开来，今天它可能是这两个行业最常用的发行方式。布林的建议似乎超前了30年。虽然“Trowbridge-Reitz发行版”在技术上是正确的名称，但我们在本书中使用GGX的名称，因为它已被牢固确立。</strong></p>
<p><strong>GGX发行版是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006165437.png" class="" title="image-20211006165437">

<p><strong>由αg参数提供的粗糙度控制与由Beckmann αb 提供的粗糙度控制相似参数。在迪士尼原则着色模型中，Burley揭示粗糙度控制为αg = r²，其中r为用户界面粗糙度参数值，取值范围为0 ~ 1。将r显示为滑块值意味着效果以更线性的方式变化。大多数使用GGX发行版的应用程序都采用了这种映射。</strong></p>
<p><strong>GGX分布是形状不变的，其Λ函数相对简单:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006165605.png" class="" title="image-20211006165605">

<p><strong>变量a在上式中只作为a²出现，因为可以避免之前式中的平方根。</strong></p>
<p><strong>由于GGX发行版和Smith遮蔽功能的流行，人们一直在努力优化这两者的组合。拉加德观察到，高度相关的Smith G2 对于GGX，当与镜面微表面 BRDF(9.34式)的分母结合时，有抵消的项。合并项可以简化为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006165755.png" class="" title="image-20211006165755">

<p><strong>该方程采用变量替换法μi=(n·l)+，μo = (n·v)+为了简洁。Karis提出了Smith G1 的近似形式GGX函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006165927.png" class="" title="image-20211006165927">

<p><strong>其中s可以用l或v代替。Hammon表明G1 得到了高度相关的Smith G2 组合项的有效近似函数和镜面微表面 BRDF 分母:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006170113.png" class="" title="image-20211006170113">

<p><strong>它使用线性插值算子，lerp(x, y, s) = x(1 - s) + ys。</strong></p>
<p><strong>对比上图中的GGX分布和Beckmann分布，可以明显看出两者的形状有根本的不同。GGX的峰值比贝克曼的要窄，而这些峰值周围的“尾巴”则更长。在下图底部的渲染图像中，我们可以看到GGX较长的尾部在高光核心周围产生了薄雾或辉光的外观。</strong></p>
<p><strong>许多真实世界的材料显示了类似的模糊亮点，其尾部通常比GGX分布的尾部更长。参见下图。这种认识是GGX发行版日益流行的重要原因，同时也促使人们不断寻找新的发行版，以便更准确地匹配测量到的材料。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006170240.png" class="" title="image-20211006170240">

<p>NDFs适合测量铬从MERL数据库。在左边，我们画出了反射峰相对于θm 的曲线对于铬(黑色)，GGX(红色;αg = 0.006)， Beckmann(绿色;αb = 0.013)， and Blinn-Phong(蓝色破折号;n = 12000)。渲染后的高亮显示在右边的chrome, GGX和Beckmann。(数据来自Brent Burley。)</p>
<p><strong>Burley提出了广义的Trowbridge-Reitz (GTR) NDF，其目标是对NDF的形状，特别是分布的尾部进行更多的控制:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006170415.png" class="" title="image-20211006170415">

<p><strong>γ参数控制尾形。γ = 2时，GTR与GGX相同。随着γ值的减小，分布的尾部变长，随着γ值的增大，他们变得更短。γ值较高时，GTR分布与Beckmann分布相似。k(α,γ)项是归一化因子，由于它比其他NDFs更复杂，我们用单独的方程给出:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006170535.png" class="" title="image-20211006170535">

<p><strong>GTR分布不是形状不变的，这使寻找它的Smith G2 遮罩-阴影函数变得复杂。在NDF发表之后，花了三年时间才找到G2 。这个G2 解是相当复杂的，带有γ某些值的解析解表(对于中间值，必须使用插值)。GTR的另一个问题是，参数α和γ以一种非直观的方式影响感知粗糙度和“辉光”。</strong></p>
<p><strong>Student’s t-distribution(STD)和指数功率分布(EPD) NDFs包括形状控制参数。与GTR相反，这些函数对于它们的粗糙度参数是形状不变的。在撰写本文时，这些都是新出版的，因此尚不清楚它们是否会在应用中得到应用。</strong></p>
<p><strong>为了更好地匹配测量材料，一种替代方案是使用多个镜面瓣，而不是增加NDF的复杂性。这个想法是由Cook和Torrance提出的。Ngan对其进行了实验测试，发现对于许多材料来说，添加第二个瓣确实显著提高了契合度。皮克斯的PxrSurface材料有一个“粗糙镜面”瓣，打算用于这个目的(与主镜面瓣一起使用)。附加瓣是一个具有所有相关参数和项的全镜面微表面 BRDF。Imageworks采用了一种更为外科手术的方法，使用两种GGX NDF的混合，这两种NDF作为扩展的NDF暴露给用户，而不是整个单独的高光BRDF术语。在这种情况下，唯一需要的附加参数是第二个粗糙度值和混合量。</strong></p>
<h4 id="Anisotropic-Normal-Distribution-Functions-各向异性正态分布函数"><a href="#Anisotropic-Normal-Distribution-Functions-各向异性正态分布函数" class="headerlink" title="Anisotropic Normal Distribution Functions 各向异性正态分布函数"></a>Anisotropic Normal Distribution Functions 各向异性正态分布函数</h4><p><strong>虽然大多数材料具有各向同性表面统计，但有些材料的微观结构具有显著的各向异性，显著影响其外观。为了准确地渲染这些材料，我们需要BRDFs，特别是 NDFs，也是各向异性的。</strong></p>
<p><strong>与各向同性 NDFs不同，各向异性 NDFs不能只用角度θm来计算．需要额外的定向信息。一般情况下，微面法线m需要转换为由法线向量n、切线向量t和双切线向量b定义的局部坐标系或切线空间。在实践中，这个变换通常表示为三个独立的点积:m·n, m·t，和m·b。</strong></p>
<p><strong>当法线映射与各向异性BRDFs相结合时，确保法线映射扰动正切和双切向量以及法线向量是很重要的。这一过程通常是通过将修正的Gram-Schmidt过程应用于摄动的法向量n和插值的顶点切线和双切线向量t0 和b0 来完成的(下面假设n已经归一化):</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171044.png" class="" title="image-20211006171044">

<p><strong>或者，在第一行之后，正交b向量可以通过取n和t的叉乘来创建。</strong></p>
<p><strong>对于拉丝金属或卷发这样的效果，逐像素修改切线方向是需要的，通常由切线贴图提供。这个贴图是一个纹理，它存储每像素的正切，类似于法线贴图存储每像素的法线。切映射通常存储切向量在垂直于法线的平面上的二维投影。这种表示可以很好地用于纹理过滤，并且可以像法线贴图一样进行压缩。有些应用程序存储标量旋转量，用于围绕n旋转切向量。尽管这种表示更紧凑，但它容易产生旋转角度为360◦ 到0◦的纹理过滤现象．</strong></p>
<p><strong>创建各向异性NDF的常用方法是推广现有的各向同性NDF。所用的一般方法可以应用于任何形状不变的各向同性NDF，这是形状不变NDF更可取的另一个原因。回想一下，各向同性形状不变NDFs可以写成以下形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171214.png" class="" title="image-20211006171214">

<p><strong>用g表示表示NDF形状的一维函数。各向异性的版本是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171224.png" class="" title="image-20211006171224">

<p><strong>参数αx 和αy 表示沿t和b方向的粗糙度，分别。如果αx =αy上式又还原为各向同性形式。</strong></p>
<p><strong>G2 各向异性NDF的遮蔽函数与各向同性NDF相同，只是变量a(传递到Λ函数)的计算方式不同:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171322.png" class="" title="image-20211006171322">

<p><strong>其中s代表v或l。</strong></p>
<p><strong>利用这种方法，我们得到了Beckmann NDF的各向异性版本，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171412.png" class="" title="image-20211006171412">

<p><strong>GGX NDF，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171421.png" class="" title="image-20211006171421">

<p><strong>如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171440.png" class="" title="image-20211006171440">

<p>使用各向异性NDFs渲染的球体:第一行是Beckmann，第二行是GGX。在两行中αy 保持不变，αx 从左到右递增。</p>
<p><strong>而参数化各向异性ndf最直接的方法是使用各向同性粗糙度参数化两次，一次是αx 一次是αy，有时会使用其他参数化。在Disney原则性着色模型中，各向同性粗糙度参数r与第二个标量参数kaniso 相结合取值范围为[0,1]。αx 和αy 从这些参数计算值如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171642.png" class="" title="image-20211006171642">

<p><strong>0.9因素限制宽高比为10:1。</strong></p>
<p><strong>Imageworks使用了一种不同的参数化方法，允许任意程度的各向异性:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171704.png" class="" title="image-20211006171704">

<h3 id="Multiple-Bounce-Surface-Reflection-多次反射表面反射"><a href="#Multiple-Bounce-Surface-Reflection-多次反射表面反射" class="headerlink" title="Multiple-Bounce Surface Reflection 多次反射表面反射"></a>Multiple-Bounce Surface Reflection 多次反射表面反射</h3><p><strong>如前面9.7节所述，微表面 BRDF框架不考虑从微表面多次反射(“反弹”)的光。这种简化会导致一些能量损失和过度暗化，特别是对于粗糙金属。</strong></p>
<p><strong>Imageworks使用了一种技术，结合了以前工作中的元素，创建了一个可以添加到BRDF中的术语，以模拟多次反弹的表面反射:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006171806.png" class="" title="image-20211006171806">

<p><strong>在RsF1 的方向反照率为(第9.3节)fsF1，即带有F0 的高光BRDF项设置为1。RsF1 的函数取决于粗糙度α和仰角θ。它是相对光滑的，所以它可以预先计算数值，并存储在一个小的二维纹理中。Imageworks发现32 × 32的分辨率就足够了。</strong></p>
<p><strong>ˉRsF1 的函数是RsF1 的余弦加权平均值。它只依赖于α，所以它可以存储在一维纹理中，或者可以用廉价的曲线来拟合数据。自RsF1 是关于n，ˉRsF1 旋转对称可以用一维积分来计算。我们还利用变量的变化量µ= cos θ:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006172115.png" class="" title="image-20211006172115">

<p><strong>最后，ˉF为菲涅耳项的余弦加权平均值，计算方法相同:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006172125.png" class="" title="image-20211006172125">

<p><strong>Imageworks提供了上式的闭格式解，如果F使用的是广义Schlick式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006172134.png" class="" title="image-20211006172134">

<p><strong>如果使用原始的Schlick近似，则解简化为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006172228.png" class="" title="image-20211006172228">

<p><strong>在各向异性的情况下，Imageworks使用αx 和αy 之间的中间粗糙度为了计算fms．这种近似避免了增大RsF1 维数的需要查找表，它引入的错误很小。</strong></p>
<p><strong>Imageworks多次反射反射项的结果如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211006172238.png" class="" title="image-20211006172238">

<p>在所有的行中，表面的粗糙度从左到右递增。顶部的两行显示了黄金材质。呈现第一行时不使用Imageworks多次反弹项，呈现第二行时使用多次反弹项。这种差异在粗糙的球体中最为明显。接下来的两行是黑色的电介质材料。呈现第三行时不使用多次反弹项，而呈现第四行时应用了多次反弹项。这里的差别更微妙，因为镜面反射要低得多。(图由Christopher Kulla提供。)</p>
<h2 id="BRDF-Models-for-Subsurface-Scattering-次表面散射的BRDF模型"><a href="#BRDF-Models-for-Subsurface-Scattering-次表面散射的BRDF模型" class="headerlink" title="BRDF Models for Subsurface Scattering 次表面散射的BRDF模型"></a>BRDF Models for Subsurface Scattering 次表面散射的BRDF模型</h2><p><strong>在前一节中，我们讨论了镜面反射。在本节中，我们将讨论问题的另一方面，即光在表面下折射时会发生什么。正如我们在9.1.4节中讨论的，这种光经历了一些散射和吸收的结合，其中一部分被重新发射出原始表面。我们将在这里集中讨论不透明介质中局部次表面散射或漫射表面响应的BRDF模型。金属是无关的，因为它们没有任何显著的地下光相互作用。介质材料是透明的或表现出全面的次表面散射将在第14章中涉及。</strong></p>
<p><strong>我们开始讨论漫反射模型的一部分，漫反射颜色的属性和可能的值，这种颜色可以在现实世界的材料。在下面的小节中，我们将解释表面粗糙度对漫射着色的影响，以及对于给定的材质选择使用平滑表面还是粗糙表面着色模型的标准。最后两个小节专门讨论光滑表面和粗糙表面模型本身。</strong></p>
<h3 id="Subsurface-Albedo-次表面反照率"><a href="#Subsurface-Albedo-次表面反照率" class="headerlink" title="Subsurface Albedo 次表面反照率"></a>Subsurface Albedo 次表面反照率</h3><p><strong>地下层反照率ρss 一种不透明介质的能量是从表面逃逸的光的能量与进入材料内部的光的能量之比。ρss 的值介于0(所有光线都被吸收)和1(没有光线被吸收)之间，取决于波长，所以ρss 建模为RGB矢量进行渲染。对于创作,ρss 常被称为表面的漫反射颜色，就像正入射菲涅耳反射率F0 通常被称为高光色。地下反照率与第14.1节讨论的散射反照率密切相关。</strong></p>
<p><strong>由于电介质传输大部分入射光而不是将其反射到表面，所以次表面反照率ρss 通常更明亮，因此在视觉上比镜面颜色F0．因为它是由不同的物理过程产生的，不同于内部的镜面颜色吸收，而不是表面的菲涅耳反射-ρss 通常有不同的光谱分布(因此是RGB颜色)与F0．例如，彩色塑料是由透明、透明的基材组成的，基材内部嵌有颜料颗粒。镜面反射的光将是无色的，而漫反射的光将被色素颗粒吸收而着色;例如，一个红色的塑料球有一个白色的高光。</strong></p>
<p><strong>次表面反照率可以被认为是吸收和散射之间“竞赛”的结果——光线会在有机会从物体散射回来之前被吸收吗?这就是为什么液体上的泡沫比液体本身更亮。起泡过程并不改变液体的吸收率，但大量气液界面的加入大大增加了散射量。这导致大部分入射光在被吸收之前就被散射，从而产生高的地下反照率和明亮的外观。新雪是高反照率物质的另一个例子。雪粒和空气之间的界面有相当大的散射，但吸收很少，导致在可见光谱中地下反照率为0.8或更高。白漆略少，约0.7。日常生活中遇到的许多物质，如混凝土、石头、土壤，平均在0.15到0.4之间。煤是一种地下反照率极低的材料，接近0.0。</strong></p>
<p><strong>许多物质在潮湿时颜色变深的过程与液体泡沫的例子相反。如果材料是多孔的，水就会渗透到以前充满空气的空间。电介质材料的折射率更接近水而不是空气。相对折射率的降低降低了在物质内部的散射，光在逃离物质之前(平均)传播了更长的距离。这种变化导致更多的光被吸收，次表面反照率变暗。</strong></p>
<p><strong>这是一个常见的误解(甚至反映在备受尊重的材料创作指南)，价值ρss 对于真实的材料创作，永远不应该低于0.015-0.03的下限(30-50在8位非线性sRGB编码)。然而，这个下限是基于颜色测量，包括表面(镜面)和次表面(漫反射)，因此太高了。实际材料的值可能更低。例如，“OSHA黑色”涂料标准的联邦规范的Y值为0.35(满分100)。根据测量条件和表面光泽度，这个Y对应于ρss 值约0.0035(11在8位非线性sRGB编码)。</strong></p>
<p><strong>当获取点值或纹理ρss 从现实世界的表面，分离出镜面反射是很重要的。这种提取可以通过仔细使用受控的照明和偏振滤波器来完成。为了准确的颜色，还应该进行校准。</strong></p>
<p><strong>并不是每一个RGB三重都表示ρ值的合理(甚至物理上可能)值ss．反射光谱比发射光谱功率分布受到更多的限制:对于任何波长，反射光谱都不能超过1，而且它们通常非常光滑。这些限制在颜色空间中定义了包含ρ的所有可能的RGB值的体积ss．即使是相对较小的sRGB色域也包含在这个音量之外的颜色，所以在设置ρss 值时必须小心避免指定不自然的饱和和明亮的颜色。除了降低现实主义，这些颜色还会在预计算全局光照时造成过亮的二次反射(章节11.5.1)。孟等人2015年发表的论文对这一课题有很好的参考价值。</strong></p>
<h3 id="Scale-of-Subsurface-Scattering-and-Roughness-次表面散射与粗糙度的比例尺"><a href="#Scale-of-Subsurface-Scattering-and-Roughness-次表面散射与粗糙度的比例尺" class="headerlink" title="Scale of Subsurface Scattering and Roughness 次表面散射与粗糙度的比例尺"></a>Scale of Subsurface Scattering and Roughness 次表面散射与粗糙度的比例尺</h3><p><strong>一些局部次表面散射的BRDF模型考虑了表面粗糙度——通常是使用带有漫射微BRDF f的微面理论µ而有些则不然。使用哪种类型的模型的决定因素不仅仅是表面有多粗糙，尽管这是一个常见的误解。正确的决定因素与地表不规则的相对大小和次表面散射距离有关。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008130001.png" class="" title="image-20211008130001">

<p>三个表面具有相似的NDFs但有差异微几何尺寸与次表面散射距离的关系。在左上方，次表面散射距离小于地表不规则性。在右上方，散射距离大于表面的不规则性。底部图中显示了一个多尺度粗糙度的微表面。红色虚线表示仅包含大于次表面散射距离的微观结构的有效表面。</p>
<p><strong>参见上图。如果微几何形状的不规则性大于次表面散射距离(图左上方)，那么次表面散射将表现出与微几何相关的效应，如反反射。对于这样的表面，应该使用粗糙表面扩散模型。如上所述，此类模型通常基于微表面理论，将次表面散射视为每个微表面的局部，因此只影响微BRDF fµ．</strong></p>
<p><strong>如果散射距离都大于不规则距离(上图右上角)，那么为了模拟次表面散射，表面应该被认为是平坦的，这样就不会发生反反射等效果。次表面散射不是微表面局部的，并且不能通过微表面理论进行建模。在这种情况下，应该使用平滑表面扩散模型。</strong></p>
<p><strong>在中间情况下，表面的粗糙度在比散射距离更大或更小的尺度上，那么应该使用粗糙表面漫射模型，但有效表面只包括比散射距离更大的不规则。漫反射和镜面反射都可以用微表面理论建模，但每个都有不同的粗糙度值。镜面项将使用一个基于实际表面粗糙度的值，漫反射项将使用一个较低的值，基于有效表面的粗糙度。</strong></p>
<p><strong>观察的尺度也与此相关，因为它决定了“微几何学”的定义。“例如，月球经常被认为是一个应该使用粗糙表面漫反射模型的例子，因为它展示了显著的后反射。当我们从地球上看月球时，观察的尺度是如此之大，甚至一块5英尺高的石头都是“微观几何”。“因此，我们观察到粗糙表面的漫反射效果就不足为奇了。</strong></p>
<h3 id="Smooth-Surface-Subsurface-Models-光滑表面次表面模型"><a href="#Smooth-Surface-Subsurface-Models-光滑表面次表面模型" class="headerlink" title="Smooth-Surface Subsurface Models 光滑表面次表面模型"></a>Smooth-Surface Subsurface Models 光滑表面次表面模型</h3><p><strong>这里我们将讨论光滑表面的次表面模型。这些适用于建模材料的表面不规则小于次表面散射距离。漫反射阴影不直接影响表面粗糙度这样的材料。如果漫反射和镜面条件是耦合的，这是本节中的一些模型的情况，那么表面粗糙度可能会间接影响漫反射阴影。</strong></p>
<p><strong>如第9.3节所述，实时渲染应用程序经常使用朗伯项来模拟局部次表面散射。在这种情况下，BRDF扩散项是ρss 在π:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008131205.png" class="" title="image-20211008131205">

<p><strong>兰伯特模型没有解释在表面反射的光不能用于次表面散射的事实。为了改进这个模型，在表面(镜面)和次表面(漫反射)反射项之间应该有一个能量平衡。菲涅耳效应表明，这种表面-地下能量平衡随入射光角θi的变化而变化．随着掠入射角度的增加，漫反射随着镜面反射的增加而减小。计算这种平衡的一个基本方法是将漫反射项乘以1减去镜面项的菲涅耳部分。如果镜面术语是平面镜的术语，则产生的漫反射项是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008131250.png" class="" title="image-20211008131250">

<p><strong>如果镜面项是微表面 BRDF项，那么最终的漫反射项为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008131300.png" class="" title="image-20211008131300">

<p><strong>上面两个公式导致出射光均匀分布，因为BRDF值不依赖于出射方向v。这个行为有一定的意义，因为光在重新发射之前通常会经历多次散射事件，所以它的出射方向将是随机的。然而，有两个理由怀疑出射光的分布不完全均匀。首先，由于上上式中的扩散BRDF项随入射方向而变化，亥姆霍兹互易性意味着它也必然随出射方向而变化。其次，光线在出射时必须经历折射，这将对出射的光线施加某种方向偏好。</strong></p>
<p><strong>Shirley等人对平面提出了耦合漫反射项，解决了菲涅耳效应和表面-地下反射权衡，同时支持能量守恒和亥姆霍兹互易。推导中假设菲涅耳反射率采用Schlick近似:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008131411.png" class="" title="image-20211008131411">

<p><strong>上式仅适用于镜面反射为完美菲涅尔镜面的表面。提出了一种广义的计算方法，该方法可用于计算与任意镜面项耦合的互反的、能量守恒的漫反射项Ashikhmin和Shirley，并由Kelemen和Szirmay-Kalos进一步细化:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008131441.png" class="" title="image-20211008131441">

<p><strong>在这里,Rspec 是镜面项的方向反照率(第9.3节)和Rspec 是它是半球上的余弦加权平均值。R值spec 可以预计算并存储在查找表中。平均Rspec 的计算方法与我们前面遇到的类似平均值相同:RsF1 方程。</strong></p>
<p><strong>上式中的形式与之前式子有一些明显的相似之处，这并不奇怪，因为Imageworks的多次反射反射项是从Kelemen-Szirmay-Kalos耦合漫反射项派生出来的。然而，有一个重要的区别。这里，不是RsF1 我们用Rspec，包括菲涅耳的全镜面BRDF项的方向反照率，以及与多次反射的镜面项f的方向反照率ms 同样，如果使用的话。这种差异增加了Rspec 的查找表的维数因为它不仅与粗糙度α和仰角θ有关，还与菲涅耳反射率有关。</strong></p>
<p><strong>在Imageworks对Kelemen-Szirmay-Kalos耦合漫反射项的实现中，他们使用了一个以折射率为第三轴的三维查找表。他们发现，在积分中包含多次弹跳项使Rspec 比RsF1 平滑，所以一个16×16×16表格就足够了。结果如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008131658.png" class="" title="image-20211008131658">

<p>第一行和第三行显示添加到朗伯项的镜面项。第二和第四行显示了与Kelemen-Szirmay-Kalos耦合漫反射项相同的镜面术语。上面两行的粗糙度值比下面两行低。在每一行中，粗糙度从左到右递增。(图由Christopher Kulla提供。)</p>
<p><strong>如果BRDF使用Schlick Fresnel近似且不包含多次反射反射项，则F0 的值可以被提出来。这样做允许我们对Rspec使用一个二维表，每个条目存储两个量，而不是Karis所讨论的三维表格。另外，Lazarov提出了一个拟合Rspec的解析函数，同理分解F0 来简化拟合函数。</strong></p>
<p><strong>Karis和Lazarov都使用了镜面定向反照率Rspec 用于不同的目的，与基于图像的照明有关。关于该技术的更多细节可以在第10.5.2节中找到。如果在同一个应用程序中实现了这两种技术，那么可以对这两种应用程序使用相同的表查找，从而提高效率。</strong></p>
<p><strong>这些模型是通过考虑表面(镜面)和次表面(漫反射)之间的能量守恒而建立的。其他模型是从物理原理发展而来的。这些模型中的许多都依赖于Subrahmanyan Chandrasekhar(1910-1995)的工作，他开发了一个半无限、各向同性散射体积的BRDF模型。Kulla和Conty证明，如果平均自由路径足够短，该BRDF模型是任意形状散射体积的完美匹配。Chandrasekhar BRDF可以在他的书中找到，不过Dupuy等人的一篇论文的方程30和31中可以找到使用熟悉的渲染符号的更容易理解的形式。</strong></p>
<p><strong>由于它不包括折射，钱德拉塞卡BRDF只能用来建模折射率匹配的表面。这些是折射率的表面两侧相同。为了模拟非折射率匹配表面，必须对BRDF进行修改，以考虑光线进入和离开表面时的折射。这种修改是 Hanrahan ， Krueger 和 Wolf的工作重点。</strong></p>
<h3 id="Rough-Surface-Subsurface-Models-粗糙次表面模型"><a href="#Rough-Surface-Subsurface-Models-粗糙次表面模型" class="headerlink" title="Rough-Surface Subsurface Models 粗糙次表面模型"></a>Rough-Surface Subsurface Models 粗糙次表面模型</h3><p><strong>作为迪士尼原则着色模型的一部分，Burley包含了一个漫反射BRDF术语，该术语旨在包括粗糙度效应和匹配测量材料:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008132323.png" class="" title="image-20211008132323">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008132335.png" class="" title="image-20211008132335">

<p><strong>α是镜面粗糙度。在各向异性的情况下，αx 和αy 之间的中间值使用。这个方程通常被称为迪士尼扩散模型。</strong></p>
<p><strong>下面的项fss 是受到Hanrahan-Krueger BRDF的启发，目的是作为一种廉价的替代对遥远物体的全球地下散射。扩散模型混合在fss 和fd 基于用户控制参数kss的粗糙扩散项．</strong></p>
<p><strong>迪士尼漫反射模型已被用于电影，以及游戏(尽管没有次表面术语)。完整的迪士尼漫反射BRDF还包括一个光泽的术语，这主要是为了建模面料，但也有助于弥补由于缺乏多重反弹镜面术语的能量损失。迪士尼的光泽术语将在第9.10节中讨论。几年后，Burley提出了一个更新的模型，旨在集成全球地下散射渲染技术。</strong></p>
<p><strong>由于迪士尼漫反射模型使用相同的粗糙度作为高光BRDF术语，它可能有建模某些材料的困难。参见上上图。然而，使用一个单独的漫射粗糙度值将是一个微不足道的修改。</strong></p>
<p><strong>大多数其他粗糙表面漫射BRDFs是利用微表面理论开发的，NDF D、micro-BRDF fµ有各种不同的选择，遮罩-阴影函数G2．这些模型中最著名的是Oren和Nayar提出的。Oren-Nayar BRDF使用了朗伯微BRDF、球面高斯NDF和托伦斯-斯派洛“v腔”遮蔽函数。完整形式的BRDF模型一次二次反弹。Oren和Nayar还在他们的论文中加入了一个简化的“定性”模型。多年来，人们提出了对Oren-Nayar模型的一些改进，包括优化、在不增加成本的情况下使“定性”模型更接近完整模型的调整，以及将微BRDF改为更精确的光滑表面漫反射模型。</strong></p>
<p><strong>Oren-Nayar模型假设了一个微表面，其正态分布和遮蔽函数与当前的镜面模型有很大的不同。利用各向同性GGX NDF和高度-导出了两种扩散微面模型相关的Smith遮蔽函数。第一个模型由Gotanda提出，是对通用微表面方程进行数值积分的结果，使用之前式子中的镜面耦合漫反射项作为微BRDF。然后对数值积分数据拟合一个解析函数。goanda的BRDF没有考虑面之间的相互反射，拟合函数也相对复杂。</strong></p>
<p><strong>Hammon使用与Gotanda相同的NDF、遮罩-遮蔽函数和微BRDF数值模拟BRDF，包括相互反射。他指出，相互反射对于这种微表面结构是很重要的，它代表了粗糙表面总反射率的一半。然而，第二次反弹几乎包含了所有缺失的能量，因此Hammon使用了两次反弹模拟的数据。此外，可能是因为添加了相互反射使数据变得平滑，Hammon能够将一个相当简单的函数拟合到模拟结果中:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008133037.png" class="" title="image-20211008133037">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008133047.png" class="" title="image-20211008133047">

<p><strong>和αg 为GGX镜面粗糙度。为了清晰起见，这里的术语与哈蒙的陈述略有不同。请注意,fsmooth 从9.64方程中得到的耦合扩散BRDF是否没有ρss/π因子，因为它在9.68式中被乘了。Hammon讨论了用其他光滑表面漫反射BRDFs代替f的“混合”BRDFssmooth，以提高性能或改进与在旧模型下创建的资产的兼容性。</strong></p>
<p><strong>总的来说，Hammon的弥漫性BRDF是廉价的，基于可靠的理论原理，尽管他没有展示与测量数据的比较。需要注意的是，表面不规则性大于散射距离的假设是推导BRDF的基础，这可能限制了它可以精确模拟的材料类型。参见上上图。</strong></p>
<p><strong>9.61式中所示的简单朗伯项仍然被许多实时渲染应用程序所实现。除了lambert术语的低计算成本外，它比其他漫射模型更容易使用间接和烘烤光照，而且它与更复杂的模型之间的视觉差异往往是微妙的。然而，对照片写实主义的持续追求正推动更精确模型的使用增加。</strong></p>
<h2 id="BRDF-Models-for-Cloth-布料的BRDF模型"><a href="#BRDF-Models-for-Cloth-布料的BRDF模型" class="headerlink" title="BRDF Models for Cloth 布料的BRDF模型"></a>BRDF Models for Cloth 布料的BRDF模型</h2><p><strong>布料往往具有不同于其他类型材料的微观几何形状。根据织物类型的不同，它可能具有高度重复的编织微结构，圆柱体(线)垂直地从表面突出，或两者兼有。因此,布料表面有表象特征,通常需要专门的阴影模型,如各向异性高光、粗糙面散射(明亮的边缘效应引起的光散射通过突出,半透明的纤维),甚至颜色变化与视图方向(由线程运行的不同的颜色通过织物)。</strong></p>
<p><strong>除了BRDF，大多数面料都有高频空间变化，这也是创造令人信服的布料外观的关键]。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008133345.png" class="" title="image-20211008133345">

<p>使用《神秘海域4》中布料系统的材料。左上方的球体有一个标准w表面镜面和lambert漫反射。中上方球体采用BRDF面料。每一个其他的球体都增加了不同类型的逐像素变化，从左到右，从上到下:织物编织细节、织物老化、不完美细节和小褶皱。(UNCHARTED 4 A Thief ’s End  c / TM 2016 SIE. Created &amp; developed by Naughty Dog LLC。)</p>
<p><strong>布BRDF模型主要分为三类:通过观察建立的经验模型、基于微表面理论的模型和微柱体模型。我们将从每个类别中举出一些值得注意的例子。</strong></p>
<h3 id="Empirical-Cloth-Models-经验布料模型"><a href="#Empirical-Cloth-Models-经验布料模型" class="headerlink" title="Empirical Cloth Models 经验布料模型"></a>Empirical Cloth Models 经验布料模型</h3><p><strong>在游戏《神秘海域2》中，布料表面使用以下漫反射BRDF术语:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008135045.png" class="" title="image-20211008135045">

<p><strong>krim，kinner和kdiff 分别是用户控制的边缘照明术语、照亮前向(内)表面术语和朗伯术语的比例因子。此外,αrim 和αinner 控制边缘和内部条款的脱落。这种行为是非物理的，因为有几个依赖于视图的效果，但没有一个依赖于光的方向。</strong><br><strong>相比之下，《神秘海域4》中的布料使用了微表面或微圆柱体模型，这取决于布料的类型(如下两部分详细说明)，而“包裹照明”的经验次表面散射近似是漫反射的术语:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008135201.png" class="" title="image-20211008135201">

<p><strong>这里我们使用1.2节中介绍的(x)+ˉ符号，它表示0和1之间的夹紧。奇符号fdiff (l, v)(n·l)+根…表明该模型影响照明以及BRDF。箭头右边的项代替了左边的项。用户指定的参数cscatter 是一种散射颜色，值w，范围[0,1]，控制环绕照明宽度。</strong></p>
<p><strong>对于模型布，迪士尼使用了漫反射BRDF术语(第9.9.4节)，并在模型粗糙散射中添加了光泽术语:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008135338.png" class="" title="image-20211008135338">

<p><strong>其中ksheen是一个用户参数，用于调制亮度项的强度。光泽色csheen 是白色和ρss的亮度归一化值之间的混合(由另一个用户参数控制)．换句话说，ρss 用亮度来区分色调和饱和度。</strong></p>
<h3 id="Microfacet-Cloth-Models-微表面布料模型"><a href="#Microfacet-Cloth-Models-微表面布料模型" class="headerlink" title="Microfacet Cloth Models 微表面布料模型"></a>Microfacet Cloth Models 微表面布料模型</h3><p><strong>Ashikhmin等人提出使用反高斯NDF来模拟天鹅绒。该NDF在后续工作中略有修改，该工作还提出了用于一般材料建模的微表面 BRDF的变体形式，没有遮罩-阴影项，分母也经过修改。</strong></p>
<p><strong>在游戏The Order: 1886中使用的布料BRDF结合了改进的微表面 BRDF和Ashikhmin和Premoˇze后来的报告中使用的天鹅绒NDF的一般形式，以及之前公式中的扩散术语。广义天鹅绒NDF是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008155945.png" class="" title="image-20211008155945">

<p><strong>其中α控制反高斯函数的宽度和kamp 控制它的振幅。全布料BRDF是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008160028.png" class="" title="image-20211008160028">

<p><strong>在《神秘海域4》使用了这种BRDF的变体，用于制作毛料和棉花等粗糙织物。</strong></p>
<p><strong>Imageworks使用不同的倒NDF来表示光泽，可以添加到任何BRDF中:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008160055.png" class="" title="image-20211008160055">

<p><strong>虽然这个NDF没有Smith遮蔽函数的封闭解，但Imageworks可以用解析函数逼近数值解。Estevez和Kulla详细讨论了遮蔽函数和光泽项与BRDF其余部分之间的能量守恒。一些使用Imageworks光泽术语渲染的例子见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008160131.png" class="" title="image-20211008160131">

<p>Imageworks的光泽镜面术语添加到红色漫反射术语。从左到右依次为α = 0.15、0.25、0.40、0.65和1.0。(图由Alex Conty提供)</p>
<p><strong>到目前为止，我们看到的每一种布料模型都仅限于特定类型的布料。下一节讨论的模型试图以一种更普遍的方式来建模布料。</strong></p>
<h3 id="Micro-Cylinder-Cloth-Models-微圆柱布料模型"><a href="#Micro-Cylinder-Cloth-Models-微圆柱布料模型" class="headerlink" title="Micro-Cylinder Cloth Models 微圆柱布料模型"></a>Micro-Cylinder Cloth Models 微圆柱布料模型</h3><p><strong>用于布料的微圆柱模型与用于头发的模型非常相似，因此第14.7.2节中关于头发模型的讨论可以提供额外的背景。这个想法在这些模型的背后是假定表面被一维线覆盖。Kajiya和Kay针对该案例开发了一个简单的BRDF模型，Banks为该模型提供了坚实的理论基础。它也被称为Kajiya-Kay BRDF或Banks BRDF。这个概念是基于这样一种观察:一个由一维线组成的曲面在任何给定位置都有无限条法线，这条法线是由垂直于该位置切向量t的法平面定义的。尽管许多更新的微圆筒模型已经从这个框架发展出来，但由于其简单性，原来的Kajiya-Kay模型仍然有一些用途。例如，在《神秘海域4》中，Kajiya-Kay BRDF被用来指代闪亮的织物，如丝绸和天鹅绒。</strong></p>
<p><strong>梦工厂使用一个相对简单的、艺术家可以控制的微圆筒模型来制作织物。纹理可以用来改变粗糙度、颜色和线的方向，这些可以指向表面平面，用于建模天鹅绒和类似的织物。经纬线可设定不同的参数，以模拟复杂的变色面料，如散弹丝。模型被归一化为节能的。</strong></p>
<p><strong>Sadeghi等人提出了一种基于织物样品和单个丝线测量的微圆筒模型。该模型还考虑了线间遮罩和线间阴影。</strong></p>
<p><strong>在某些情况下，实际的头发BSDF模型(第14.7节)用于布料。Render- Man的PxrSurface材质有一个“fuzz”叶，使用Marschner等人的毛发模型中的R术语(第14.7节)。Wu和Yuksel在实时布料渲染系统中实现的模型之一是源自迪士尼动画电影中使用的头发模型。</strong></p>
<h2 id="Wave-Optics-BRDF-Models-波动光学BRDF模型"><a href="#Wave-Optics-BRDF-Models-波动光学BRDF模型" class="headerlink" title="Wave Optics BRDF Models 波动光学BRDF模型"></a>Wave Optics BRDF Models 波动光学BRDF模型</h2><p><strong>我们在前几节中讨论的模型依赖于几何光学，即光以射线而不是波的形式传播。正如在之前所讨论的，几何光学是基于这样的假设:任何表面的不规则性不是小于一个波长就是大于大约100个波长。</strong></p>
<p><strong>现实世界的表面就没那么亲切了。它们在所有尺度上都有不规则性，包括1-100波长范围。我们提到纳米几何尺寸的不规则性，以区别于前面讨论的微几何不规则性，微几何不规则性太小，无法单独渲染，但大于100个波长。纳米几何对反射率的影响不能用几何光学来模拟。这些效应取决于光的波动性质，需要波动光学(也称为物理光学)来模拟它们。</strong></p>
<p><strong>厚度接近光波的表层或薄膜也会产生与光波性质有关的光学现象。</strong></p>
<p><strong>在本节中，我们将讨论波动光学现象，如衍射和薄膜干涉，讨论它们(有时令人惊讶)在真实渲染这些看似相对平凡的材料中的重要性。</strong></p>
<h3 id="Diffraction-Models-衍射模型"><a href="#Diffraction-Models-衍射模型" class="headerlink" title="Diffraction Models 衍射模型"></a>Diffraction Models 衍射模型</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008234403.png" class="" title="image-20211008234403">

<p>在左边，我们看到一个平面波阵面在真空中传播。如果波前上的每个点都被当作一个新的球面波的源，新波在除正向外的所有方向都发生破坏性的干涉，再次产生一个平面波前。在中心，波浪遇到了障碍。在障碍物边缘的球形波，其右侧没有对其产生破坏性干扰的波，所以有些波会绕射或“泄漏”到障碍物边缘。在右边，一个平面波阵面从一个平面反射回来。平面波前与左侧面点的接触时间比右侧面点的接触时间早，因此从左侧面点发射的球面波有更多的时间传播，因此球面波更大。不同尺寸的球面波阵面沿反射平面波阵面边缘产生建设性干涉，在其他方向产生破坏性干涉。</p>
<p><strong>纳米几何会引起一种叫做衍射的现象。为了解释它，我们使用惠更斯-菲涅耳原理，该原理指出，波前(具有相同波相的点的集合)上的每一点都可以被视为一个新的球面波的源。参见上图。当波遇到障碍物时，惠更斯-菲涅耳原理表明，它们会在转角轻微弯曲，这是衍射的一个例子。这种现象是几何光学所不能预测的。在光入射到一个平面上的情况下，几何光学确实正确地预测光将在一个方向上反射。也就是说，菲涅尔-惠更斯原理提供了额外的见解。它表明表面的球面波刚好排成一条直线，形成反射波阵面，而其他方向的波则通过破坏性干扰被消除。当我们观察纳米不规则的表面时，这种洞察力变得非常重要。由于表面点的高度不同，表面上的球面波不再整齐排列。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211008234744.png" class="" title="image-20211008234744">

<p>在左边，我们看到平面波面入射到一个粗糙的纳米几何表面。在中心，我们看到根据菲涅耳-惠更斯原理在表面形成的球波。在右边我们看到，在发生了相干和相干干涉之后，一些产生的波(红色部分)形成了一个平面反射波。剩下的部分(紫色部分)是衍射的，每个方向的光传播量不同，这取决于波长。</p>
<p><strong>如图所示，光线分散在不同的方向。它的一部分是镜面反射的，即在反射方向上叠加成一个平面波前。剩余的光以一种依赖于纳米几何特性的定向模式衍射出去。镜面反射光和衍射光之间的划分取决于纳米几何凸起的高度，或者更准确地说，取决于高度分布的方差。衍射光在周围的角扩散镜面反射的方向取决于相对于光波长的纳米几何凸起的宽度。与直觉相悖的是，更广泛的违规行为会导致更小的价差。如果不均匀度大于100个波长，则衍射光和镜面反射光之间的角度很小，可以忽略不计。尺寸减小的不规则性会导致衍射光扩散得更广，直到不规则性变得小于光的波长，在这一点上就不会发生衍射。</strong></p>
<p><strong>在具有周期性纳米几何结构的表面上，衍射是最清晰可见的，因为重复的图案通过构造干涉加强了衍射光，造成了彩色的彩虹色。这种现象可以在CD和DVD光盘和某些昆虫中观察到。虽然衍射也发生在非周期表面，但计算机图形界多年来一直认为这种影响是轻微的。因此，除了少数例外，计算机图形学文献多年来大多忽略了衍射。</strong></p>
<p><strong>然而，Holzschuch和Pacanow- ski最近对实测材料的分析表明，许多材料中都存在显著的衍射效应，这可能解释了用现有模型拟合这些材料的持续困难。同一作者的后续工作介绍了一个结合微表面和衍射理论的模型，通过使用通用微表面 BRDF和一个可以解释衍射的微BRDF。与此同时，Toisoul和Ghosh提出了捕捉周期性纳米几何产生的彩虹衍射效应的方法，并使用点光源和基于图像的照明实时渲染它们。</strong></p>
<h3 id="Models-for-Thin-Film-Interference-薄膜干涉模型"><a href="#Models-for-Thin-Film-Interference-薄膜干涉模型" class="headerlink" title="Models for Thin-Film Interference 薄膜干涉模型"></a>Models for Thin-Film Interference 薄膜干涉模型</h3><p><strong>薄膜干涉是一种波光学现象，当光路径从薄介质层的顶部和底部反射时发生相互干涉。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211009000217.png" class="" title="image-20211009000217">

<p>入射到反射衬底上的薄膜上的光。除了主反射外，还有多种路径的光折射，从衬底反射，或者从顶部薄膜表面的内部反射，或者通过它折射。这些路径都是同一波的副本，但由于路径长度的不同，相位延迟较短，因此它们相互干涉。</p>
<p><strong>不同波长的光要么是建设性的干涉，要么是破坏性的干涉，这取决于波长和路径长度差之间的关系。</strong></p>
<p><strong>由于路径长度的差异随着角度的变化而变化，最终的结果是虹彩颜色的漂移，因为不同的波长在建设性和破坏性干涉之间的过渡。</strong></p>
<p><strong>薄膜需要很薄才能产生这种效应的原因与相干长度的概念有关。这个长度是光波的一个拷贝被移动并且仍然与原波相干的最大距离。这个长度与光的带宽成反比，带宽是光谱功率分布(SPD)延伸的波长范围。激光由于其极窄的带宽而具有极长的相干长度。根据激光的类型，可以达到数英里。这种关系是有意义的，因为一个简单的正弦波被许多波长所取代，仍然会与原始波相干地干涉。如果激光器真的是单色的，那么它的相干长度将是无限的，但实际上激光器的带宽是非零的。相反，极宽带宽的光会产生混沌波形。这种波形的一个副本只需要移动一小段距离，就会停止与原始波形的相干干扰，这是有道理的。</strong></p>
<p><strong>理论上，混合了所有波长的理想白光的相干长度为零。然而，对于可见光光学而言，人类视觉系统(仅在400-700 nm范围内感知光)的带宽决定了相干长度，约为1微米。因此，在大多数情况下，问题的答案是“一层薄膜能有多厚才能不再引起可见干扰?”是“大约1微米。”</strong></p>
<p><strong>与衍射相似，多年来，薄膜干涉被认为是一种特殊情况下的效应，只发生在表面，如肥皂泡和油渍。然而Akin指出，薄膜干涉确实会带来微妙的色彩对许多日常表面，并展示了如何建模这种效果可以增加现实主义。参见下图。他的文章使人们对基于物理的薄膜干涉的兴趣大大增加，各种着色模型包括Render- Man的PxrSurface和Imageworks着色模型都支持这种效果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211009000324.png" class="" title="image-20211009000324">

<p>一种没有(左边)薄膜干涉和(右边)薄膜干涉的皮革材料。由薄膜干涉引起的镜面着色增加了图像的真实感。(图片来源:阿提拉·阿金，Next Limit Technologies )</p>
<p><strong>适用于实时绘制的薄膜干涉技术已经存在一段时间了。Smits和Meyer提出了一种有效的方法来解释一阶光路和二阶光路之间的薄膜干涉。他们观察到产生的颜色主要是路径长度差的函数，路径长度差可以从薄膜厚度、视角和折射率有效地计算出来。它们的实现需要一个带有RGB颜色的一维查找表。表格的内容可以使用密集光谱采样和转换成RGB颜色作为预处理，这使得技术相当快。在《使命召唤:无限战争》(Call of Duty: Infinite Warfare)这款游戏中，使用了一种不同的快速薄膜近似材料作为分层材料系统的一部分。这些技术不能模拟薄膜中光线的多次反射，也不能模拟其他物理现象。Belcour和Barla提出了一种更精确、计算成本更高、但仍以实时实现为目标的技术。</strong></p>
<h2 id="Layered-Materials-分层材质"><a href="#Layered-Materials-分层材质" class="headerlink" title="Layered Materials 分层材质"></a>Layered Materials 分层材质</h2><p><strong>在现实生活中，材料通常是层叠在一起的。表面可能被灰尘、水、冰或雪覆盖;它可以用漆或其他涂层来粉刷出于装饰或保护的原因;或者它可能有多层作为其基本结构的一部分，如许多生物材料。</strong></p>
<p><strong>一种最简单和最具视觉意义的分层情况是一层透明涂层，这是一层光滑的透明层覆盖在一些不同的材料的基板上。例如在粗糙的木材表面上涂一层光滑的清漆。迪士尼原则性的着色模型包括一个透明涂层术语，就像Unreal Engine，RenderMan的PxrSurface材质，以及梦工厂动画和Imageworks使用的着色模型等。</strong></p>
<p><strong>透明涂层最显著的视觉效果是光从透明涂层和底层基底反射而产生的双重反射。当衬底是金属时，第二次反射最为显著，从那时起，介质透明涂层的折射率与衬底之间的差异最大。当衬底是电介质时，其折射率接近于透明涂层的折射率，导致第二次反射相对较弱。这种效果类似于水下材料。</strong></p>
<p><strong>透明层也可以着色。从物理学的观点来看，这种着色是吸收的结果。根据比尔-朗伯定律(第14.1.2节)，光的吸收量取决于光穿过透明层的路径长度。这个路径长度取决于视角和光线的角度，以及材料的折射率。更简单的透明层实现，例如那些在迪士尼原则模型和虚幻引擎中，不建模这种视图依赖。其他的可以，比如PxrSurface的实现，Imageworks和Dreamworks的着色模型。Imageworks模型还允许连接任意数量的不同类型的层。</strong></p>
<p><strong>在一般情况下，不同的层可能有不同的表面法线。一些例子包括流过平坦路面的小溪，崎岖不平的土壤上的光滑的冰层，或者覆盖纸板箱的皱巴巴的塑料膜。电影行业使用的大多数分层模型都支持每层分离法线。这种做法在实时应用程序中并不常见，尽管虚幻引擎的透明实现支持它作为一个可选特性。</strong></p>
<p><strong>Weidlich和Wilkie提出了一个分层的微表面模型，假设层的厚度与微表面的尺寸相比很小。他们的模型支持任意数量的层，并跟踪反射和折射事件，从顶层到底层再回到顶层。它非常简单，可以实时实现，但没有考虑到层之间的多次反射。Jakob等人提出了一种全面而精确的模拟层状材料(包括多次反射)的框架。虽然不适合实时实现，但该系统对地面真实比较是有用的，所使用的思想可能为未来的实时技术提供建议。</strong></p>
<p><strong>《使命召唤:无限战争》(Call of Duty: Infinite Warfare)使用的分层材质系统尤其引人注目。它允许用户合成任意数量的材料层。它支持折射、散射和基于路径长度的吸收层，以及不同的表面法线每层。结合高效的实现，该系统能够实现前所未有的实时材料的复杂性，特别是对一个运行在60hz的游戏印象深刻。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211009000655.png" class="" title="image-20211009000655">

<p>测试表面显示各种功能的使命召唤:无限战争多层材料系统。这种材料模拟了一个具有扭曲和散射的几何复杂表面，尽管每个边仅由两个三角形构成。(图片由动视出版公司提供，2018年)</p>
<h2 id="Blending-and-Filtering-Materials-混合和过滤材质"><a href="#Blending-and-Filtering-Materials-混合和过滤材质" class="headerlink" title="Blending and Filtering Materials 混合和过滤材质"></a>Blending and Filtering Materials 混合和过滤材质</h2><p><strong>材质混合是将各属性结合起来的过程，即BRDF参数，适用于多种材料。例如，要建模带有锈斑的金属板，我们可以绘制一个蒙版纹理来控制锈斑的位置，并使用它来混合材料属性(镜面颜色F0，扩散色ρss锈蚀和金属的粗糙度α)。每个被混合的材料也可以在空间上变化，参数存储在纹理中。混合可以作为创建新纹理的预处理，通常称为“烘培”，或在着色器中飞行。虽然表面法线n在技术上不是BRDF参数，但它的空间变化对外观很重要，所以材质混合通常也包括法线贴图混合。</strong></p>
<p><strong>材料混合是许多实时渲染应用的关键。例如，游戏the Order: 1886就有一个复杂的材质混合系统它允许用户从广泛的库中提取材质，并由各种空间掩模控制，任意深度的堆栈。大多数材料混合是作为离线预处理完成的，但某些合成操作可以根据需要推迟到运行时。这种运行时处理通常用于环境，为平铺纹理添加独特的变化。流行的材质创作工具Substance Painter和Substance Designer使用类似的方法进行材质合成，Mari纹理绘画工具也是如此。</strong></p>
<p><strong>混合纹理元素在飞行中提供了一套不同的效果，同时保存记忆。游戏基于各种目的使用材质混合，例如:</strong></p>
<pre><code>**•显示建筑物，车辆和活着的(或不死的)生物的动态伤害。** 

**•允许用户自定义游戏内装备和服装。**

**•增加字符和环境的视觉多样性。**
</code></pre>
<p><strong>有时一个材质混合在另一个材质上，不透明度小于100%，但即使是完全不透明的混合也会有像素(或像素，如果烘焙成纹理)在蒙版边界上，部分混合需要执行。在这两种情况下，严格正确的方法是评估每个材质的着色模型并混合结果。然而，混合BRDF参数，然后评估一次着色要快得多。在材料属性的情况下，有一个线性或接近线性的关系，以最终的着色颜色，如漫反射和镜面颜色参数，很少或没有错误引入这种插值。在许多情况下，即使参数与最终着色的高度非线性关系(如镜面粗糙度)，沿蒙版边界引入的误差是不令人反感的。</strong></p>
<p><strong>混合法线贴图需要特别的考虑。通常，把这个过程看作是高程图之间的混合，法线图就是从高程图中推导出来的，可以得到好的结果。在某些情况下，例如在基础表面上覆盖一个细节法线贴图时，其他形式的混合是可取的。</strong></p>
<p><strong>材质过滤是一个与材质混合密切相关的话题。材质属性通常存储在纹理中，通过GPU双线性滤波和mipmapping等机制进行过滤。然而，这些机制是基于被过滤的数量(这是着色方程的输入)与最终颜色(着色方程的输出)有线性关系的假设。线性同样适用于某些量，但不是一般的量。在法线贴图或包含非线性BRDF参数(如粗糙度)的纹理上使用线性mipmapping方法可以产生伪影。这些伪影可以表现为高光走样(闪烁的高光)，或者是表面光泽度或亮度的意外变化，因为表面距离相机的变化。在这两者中，镜面走样要明显得多;缓解这些伪影的技术通常被称为镜面抗锯齿技术。现在我们将讨论其中的几种方法。</strong></p>
<h3 id="Filtering-Normals-and-Normal-Distributions-正态分布和正态滤波"><a href="#Filtering-Normals-and-Normal-Distributions-正态分布和正态滤波" class="headerlink" title="Filtering Normals and Normal Distributions 正态分布和正态滤波"></a>Filtering Normals and Normal Distributions 正态分布和正态滤波</h3><p><strong>大部分材料过滤伪影(主要来自镜面走样)，以及它们最常用的解决方案，都与正态和正态分布函数的过滤有关。由于它的重要性，我们将在这方面进行一些深入的讨论。</strong></p>
<p><strong>为了理解这些伪影产生的原因以及如何解决它们，请回忆NDF是亚像素表面结构的统计描述。当相机和表面之间的距离增加时，之前覆盖多个像素的表面结构可能会减少到亚像素大小，从凹凸贴图的领域移动到NDF的领域。这种转换与mipmap链密切相关，它将纹理细节缩减到亚像素大小。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010113418.png" class="" title="image-20211010113418">

<p>在左边，圆柱体是用原始法线贴图渲染的。在中间，使用了一个低分辨率的法线贴图，它包含了平均和重正化的法线，如下图左下角所示。在右边，圆柱体用同样低分辨率的纹理进行渲染，但包含符合理想NDF的正常和光泽值，如下图右下角所示。右边的图像明显更好地呈现了原始的外观。在低分辨率渲染时，这个表面也不容易出现走样。(图片由工业光魔的帕特里克·康兰提供。)</p>
<p><strong>考虑一个对象的外观，例如上图左边的圆柱体，是如何建模的。外观建模总是假定一定的观察规模。大尺度(大尺度)几何模型为三角形，中尺度(中尺度)几何模型为纹理，小于单个像素的微尺度几何模型通过BRDF进行建模。</strong></p>
<p><strong>根据图中所示的比例，将圆柱体建模为光滑网格(宏观尺度)，并用法线贴图(中尺度)表示凸起。具有固定粗糙度αb 的Beckmann NDF来模拟微尺度正态分布。这种组合表示法在这个比例下很好地模拟了圆柱体的外观。但是，当观察范围发生变化时，会发生什么呢?</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010113621.png" class="" title="image-20211010113621">

<p>部分表面从上图。最上面的一行显示了正态分布(红色显示的是平均正态分布)和隐含的微观几何形状。下面一行显示了将四个ndf平均为一个的三种方法，就像在mipmapping中所做的那样。左边是地面真实值(平均正态分布)，中心分别显示平均(正态分布)和方差(粗糙度)的结果，右边显示一个拟合平均NDF的NDF瓣。</p>
<p><strong>上图研究。顶部的黑框图形显示了表面的一小部分，被四个法线贴图texel覆盖。假设我们以一个比例渲染表面，这样每个法线贴图texel平均被一个像素覆盖。为每个texel，正态(即分布的平均值)用红色箭头表示，被Beckmann NDF(用黑色表示)包围。法线和NDF隐式指定了一个底层表面结构，如横断面所示。中间的大隆起是法线图上的隆起之一，而小的摆动则是微尺度的表面结构。法线贴图中的每一个texel，结合粗糙度，可以被看作是在纹理覆盖的表面上收集法线的分布。</strong></p>
<p><strong>现在假设相机离物体更远了，所以一个像素覆盖了所有四个法线贴图像素。在这个分辨率下，理想的表面表示应该准确地表示在每个像素所覆盖的更大的表面积上收集到的所有法线的分布。这种分布可以通过在顶级mipmap的四个像素中平均ndf来找到。左下角的图显示了理想的正态分布。这个结果，如果用于渲染，将最准确地代表表面的外观在这个较低的分辨率。底部中心图显示了分别平均正态分布、每个分布的平均值和粗糙度的结果，粗糙度对应于每个分布的宽度。结果有正确的平均正态(红色)，但分布太窄。这个错误会导致表面看起来太光滑。更糟糕的是，由于NDF很窄，它会以闪烁的高光的形式造成走样。</strong></p>
<p><strong>我们不能直接用 Beckmann NDF来表示理想的正态分布。然而，如果我们使用粗糙度图，贝克曼粗糙度αb 可以从像素到像素不等。想象一下，对于每个理想NDF，我们找到与它最匹配的定向Beckmann波瓣，无论是在方向上还是总体宽度上。我们将该Beckmann波瓣的中心方向存储在法线图中，将其粗糙度值存储在粗糙度图中。结果显示在右下角。这个NDF更接近于理想。如上上图所示，用这种方法比用简单的正常平均法更能真实地表示圆柱体的外观。</strong></p>
<p><strong>为了获得最好的结果，像mipmapping这样的过滤操作应该应用于正态分布，而不是正态或粗糙度值。这样做意味着考虑ndf和常规之间关系的方法略有不同。通常NDF是在由法线贴图的每像素法线决定的局部切线空间中定义的。然而，当在不同法线上过滤NDF时，更有用的是将法线贴图和粗糙度贴图的组合看作是在潜在几何表面的切线空间中定义一个倾斜的NDF(一个没有平均到垂直向上的法线的NDF)。</strong></p>
<p><strong>早期解决NDF滤波问题的尝试使用数值优化来将一个或多个NDF叶瓣拟合到平均分布。这种方法存在健壮性和速度方面的问题，目前还不怎么使用。相反，目前使用的大多数技术都是通过计算正态分布的方差来工作的。Toksvig做了一个聪明的观察，如果正态分布是平均的而不是重新正态化的，则平均正态分布的长度与正态分布的宽度成反比。也就是说，原始法线越指向不同的方向，其平均值就越短。他提出了一种基于此法向长度来修改NDF粗糙度参数的方法。用修改后的粗糙度来评估BRDF近似于滤波后法线的扩散效果。</strong></p>
<p><strong>Toksvig最初的公式是用于Blinn-Phong NDF的:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010113903.png" class="" title="image-20211010113903">

<p><strong>其中αp 是原始粗糙度参数修改后的值αp′ ，||ˉn||为平均法线长度。通过等效αp = 2αb^−2−2，该方程也可用于Beckmann NDF(来自Walter et al.)，因为这两个NDFs的形状非常接近。使用GGX的方法就不那么简单了，因为GGX和Blinn-Phong(或Beckmann)之间没有明显的等价性。使用αb 等效为αg 在中心处的值是相同的高光，但高光的外观是相当不同的。更麻烦的是，GGX分布的方差是未定义的，这使得这种基于方差的技术在与GGX一起使用时的理论基础不稳固。尽管有这些理论上的困难，在GGX分布中使用上式是相当普遍的，通常使用αp = 2αg^−2−2。这样做在实践中相当有效。</strong></p>
<p><strong>Toksvig方法的优点是可以考虑GPU纹理滤波引入的正态方差。它还适用于最简单的法向mipmapping方案，即不需要标准化的线性平均。这个特性对于动态生成的法线贴图特别有用，比如水波纹贴图，对于这些贴图，mipmap生成必须在运行中完成。该方法对于静态法线映射不太好，因为它不能很好地与常用的法线映射压缩方法一起工作。这些压缩方法依赖于单位长度的法线。由于Toksvig的方法依赖于平均法线变化的长度，与它一起使用的法线映射可能必须保持未压缩。即使这样，存储缩短的法线也会导致精度问题。</strong></p>
<p><strong>Olano和Baker的LEAN映射技术是基于正态分布协方差矩阵的映射。像Toksvig的技术一样，它可以很好地用于GPU纹理过滤和线性映射。它还支持各向异性正态分布。与Toksvig的方法类似，精益映射可以很好地处理动态生成的法线，但为了避免精度问题，当使用静态法线时，它需要大量存储。Hery等人独立开发了类似的技术，并在皮克斯的动画电影中用于渲染亚像素细节，如金属薄片和小划痕。LEAN映射的一个更简单的变体CLEAN映射，需要更少的存储空间，但代价是失去各向异性支持。LEADR映射扩展了精益映射，也考虑了位移映射的可见性影响。</strong></p>
<p><strong>实时应用程序中使用的大多数法线映射是静态的，而不是动态生成的。对于这样的映射，通常使用方差映射族技术。在这些技术中，当法线地图的mipmap链生成时，就会计算通过平均而丢失的方差。Hill指出，Toksvig技术的数学公式、LEAN映射和CLEAN映射都可以以这种方式预先计算方差，这就消除了这些技术在使用其原始形式时的许多缺点。在某些情况下，预先计算的方差值存储在单独的方差纹理的mipmap链中。更常见的情况是，这些值用于修改现有粗糙度图的mipmap链。例如，《使命召唤:黑色行动》中的方差映射技术就采用了这种方法。修改的粗糙度值是通过将原始粗糙度值转换为方差值，添加法线映射的方差，并将结果转换回粗糙度来计算的。在游戏《秩序:1886》中，Neubelt和Pettineo以类似的方式使用了Han的技术。他们将法线映射NDF与BRDF的高光项NDF进行卷积，将结果转换为粗糙度，并将其存储在一个粗糙度映射中。</strong></p>
<p><strong>为了改进结果，需要额外存储一些数据，可以在纹理空间的x和y方向上计算方差，并存储在各向异性的粗糙度图中。就其本身而言，这项技术仅限于轴向各向异性，这在人造表面很常见，但在自然发生的表面不太常见。以多存储一个值为代价，也可以支持定向各向异性。</strong></p>
<p><strong>与Toksvig、LEAN和CLEAN映射的原始形式不同，方差映射技术不考虑GPU纹理滤波引入的方差。为了弥补这一点，方差映射实现通常用一个小过滤器卷积法线映射的顶层mip。当组合多个法线贴图时，例如详细法线贴图，需要注意正确组合法线贴图的方差。</strong></p>
<p><strong>法向方差可以由高曲率几何以及法向映射引入。由这种差异产生的工件不能通过前面讨论的技术得到缓解。存在一组不同的方法来处理几何正态方差。如果一个独特的纹理映射存在于几何体上(通常是角色，而不是环境)，那么几何曲率就可以“烘培”到粗糙度映射中。曲率也可以通过使用像素-着色器衍生指令来动态估计。这种估计可以在渲染几何图形时完成，或者在后期处理过程中，如果正常缓冲区可用。</strong></p>
<p><strong>到目前为止讨论的方法集中在镜面反射，但正常的方差也可以影响漫反射阴影。考虑正态方差对n·l项的影响有助于提高漫反射遮阳和镜面遮阳的精度，因为在反射率积分中两者都乘以了该因子。</strong></p>
<p><strong>方差映射技术近似正态分布为光滑的高斯波瓣。这是一个合理的近似，如果每个像素覆盖成千上万的颠簸，以便它们都平滑地平均出来。然而，在许多情况下，一个像素只覆盖了几百或几千个凸起，这可能导致“闪烁”的外观。一个例子可以在328页的图9.25中看到，这是一个图像序列，显示了一个球体的大小随着图像的不同而减小。右下角的图像显示了当凸起足够小到可以平均为平滑的高亮时的结果，但左下角和底部中心的图像显示的凸起小于一个像素，但不够小到可以平滑地平均。如果你观察这些球体的动画渲染，嘈杂的高光会在帧与帧之间出现闪烁。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010114557.png" class="" title="image-20211010114557">

<p>左边是随机凹凸不平表面的一小块区域(一侧有几十个凸起)的NDF。右边是一个宽度近似相同的Beckmann NDF波瓣。(图片由Miloˇ的Haˇsan提供)</p>
<p><strong>如果我们要绘制这样一个曲面的NDF，它看起来就像上图中的左图。当球体动画时，h矢量移动到NDF上，穿过亮区和暗区，这导致了“闪闪发光”的外观。如果我们在这个表面上使用方差映射技术，它将有效地近似这个NDF与一个平滑的NDF在上图的右边，失去闪闪发光的细节。</strong></p>
<p><strong>在电影工业中，这通常是通过大量的超采样来解决的，这在实时渲染应用中是不可行的，甚至在离线渲染中也是不可取的。</strong></p>
<p><strong>已经开发了几种技术来解决这个问题。有些不适合实时使用，但可能为未来的研究提供了途径。为了实时实现，设计了两种技术。Wang和Bowles展示了一种在游戏《迪士尼无限3.0》中渲染闪亮雪花的技术。该技术的目的是产生一个似是而非的闪光外观，而不是模拟一个特定的NDF。它是用于材料，如雪，有相对稀疏的闪光。Zirr和Kaplanyan的技术在多个尺度上模拟了正态分布，在空间和时间上都是稳定的，并允许更广泛的形式出现。</strong></p>
<p><strong>我们没有空间来涵盖关于材料过滤的所有广泛的文献，所以我们将提到一些值得注意的参考文献。Bruneton等人提出了一种跨尺度处理海洋表面从几何到BRDF(包括环境照明)的方差的技术。Schilling讨论了一种支持环境贴图的各向异性着色的方差映射类技术。Bruneton和Neyret提供了这一领域早期工作的全面概述。</strong></p>
<h1 id="10-Local-Illumination-直接光照"><a href="#10-Local-Illumination-直接光照" class="headerlink" title="10 Local Illumination 直接光照"></a>10 Local Illumination 直接光照</h1><p><strong>在第九章中，我们讨论了物理基材料的理论，以及如何用准时光源来评价它们。有了这个内容，我们可以通过模拟光线与表面的相互作用来进行着色计算，以测量在给定方向上有多少亮度发送到我们的虚拟相机。这个光谱亮度是场景参考像素颜色，它将被转换(第8.2节)为最终图像中给定像素的显示参考颜色。</strong></p>
<p><strong>在现实中，我们需要考虑的交互从来都不是准时的。我们已经在9.13.1节中看到，为了正确地评估着色，我们必须求解曲面BRDF响应在整个像素足迹上的积分，这是像素区域在曲面上的投影。这个积分过程也可以被认为是一个抗锯齿的解决方案。我们预先积分，而不是对频率分量没有界限的着色函数进行采样。</strong></p>
<p><strong>到目前为止，只有点和方向光源的影响已经提出，这限制了表面接收来自少数离散方向的光。这种照明描述是不完整的。事实上，表面接收来自所有入射方向的光。户外的景色不仅仅是由阳光照亮的。如果这是真的，所有处于阴影或背向太阳的表面都将是黑色的。天空是一个重要的光源，由大气中的阳光散射引起。天光的重要性可以从月球的照片上看出来，月球因为没有大气而缺乏天光。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010124326.png" class="" title="image-20211010124326">

<p>这是在月球上拍摄的照片，月球上没有天光，因为没有大气层来散射阳光。这张图片显示了当场景只被直接光源照亮时的样子。注意背向太阳的表面上漆黑的阴影和缺乏任何细节。这张照片显示宇航员詹姆斯·b·欧文在阿波罗15号任务期间站在月球漫游车旁边。前景的阴影来自登月舱。宇航员大卫·r·斯科特(指挥官)拍摄。(图片来自NASA的收藏)</p>
<p><strong>在阴天，在黄昏或黎明，室外照明都是天空光。即使在晴朗的日子，从地球上看，太阳也笼罩着一个圆锥体，所以也不是无极小。奇怪的是，尽管太阳和月球的大小有巨大的差异——太阳的半径比月球大两个数量级，但太阳和月球的相对角度都差不多，大约是半度。</strong></p>
<p><strong>事实上，照明从来不是准时的。在某些情况下，无穷小的实体是有用的，可以作为廉价的近似，或者作为更完整模型的构建块。为了形成一个更加真实的照明模型，我们需要整合BRDF响应整个半球的入射方向在表面。在实时绘制中，我们倾向于通过寻找闭形式的解或近似来解决绘制方程(第11.1节)所包含的积分。我们通常避免平均多个样本(射线)，因为这种方法往往要慢得多。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010124512.png" class="" title="image-20211010124512">

<p>左边是我们在第9章见过的积分:表面积和点状光。在右边，本章的目标将是扩展我们的着色数学，以说明在光表面的积分。</p>
<p><strong>本章致力于探索此类解决方案。特别地，我们想通过计算各种非点状光源的BRDF来扩展我们的着色模型。通常，为了找到便宜的解决方案(或任何解决方案)，我们需要近似的光发射器，BRDF，或两者。在一个感性的框架中评估最终的着色效果是很重要的，理解什么元素在最终的图像中是最重要的，所以要在这些方面投入更多的精力。</strong></p>
<p><strong>我们在这一章开始用公式来积分分析区域光源。这种发射器是场景中的主要光源，负责大部分的直接照明强度，所以对于这些，我们需要保留所有选择的材质属性。阴影应该计算这样的发射器，因为光线泄漏将导致明显的伪影。然后，我们研究如何表现更一般的照明环境，其中包括任意分布在传入半球。在这些情况下，我们通常接受更近似的解决方案。环境照明用于大型、复杂但强度较低的光源。例子包括从天空和云层散射的光，场景中大物体反射的间接光，和调暗直接区域光源。这样的发射器对于图像的平衡非常重要，否则图像会显得太暗。即使我们考虑了间接光源的影响，我们仍然不在整体照明的领域(第11章)，这依赖于场景中其他表面的明确知识。</strong></p>
<h2 id="Area-Light-Sources-区域光"><a href="#Area-Light-Sources-区域光" class="headerlink" title="Area Light Sources 区域光"></a>Area Light Sources 区域光</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010124806.png" class="" title="image-20211010124806">

<p>由光源照亮的表面，考虑由表面法线n定义的可能入射光方向的半球。在左侧，光源是无穷小的。在右边，它被建模为一个区域光源。</p>
<p><strong>在第九章中，我们描述了理想的无穷小光源:准时的和定向的。上图显示了入射半球在表面点上，以及无穷小光源和非零尺寸的面积光源之间的差异。左边的光源使用9.4节中讨论的定义。它从一个方向lc照亮表面．它的亮度用颜色clight来表示，定义为白色朗伯氏表面对着光线反射的亮度。点或方向光对出射亮度Lo(v)的贡献在v方向上为πf(lc, v)clight(n·lc)+(请注意1.2节介绍的用于将负数夹紧为零的x+符号)。或者，区域光源(右侧)的亮度用其亮度Ll表示．面积灯对着一个实心角ωl 从地面的位置。它对v方向的输出辐射的贡献是f(l, v)Ll(n·l)+除以ωl的积分。</strong></p>
<p><strong>无穷小光源的基本近似表达式为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125056.png" class="" title="image-20211010125056">

<p><strong>一个区域光源对一个表面位置的照明的贡献量是它的亮度(Ll)和从该位置看到的大小(ωl)．正如我们在第9.4节中看到的，点光源和定向光源是在实践中无法实现的近似，因为它们的零立体角意味着无限的亮度。理解近似值带来的视觉错误将有助于知道何时使用它，以及当不能使用它时采取什么方法。这些误差将取决于两个因素:光源有多大(由它从着色点覆盖的实心角度测量)，以及表面有多光滑。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125150.png" class="" title="image-20211010125150">

<p>从左到右，球体材料的表面粗糙度增加，使用GGX BRDF。最右边的图像复制了系列中的第一个，垂直翻转。注意，在一个低粗糙度的材料上由一个大的圆盘光源引起的高光和着色看起来是如何类似于在一个更粗糙的材料上由一个较小的光源引起的高光。</p>
<p><strong>上图显示了镜面高光的大小和形状如何取决于材料的粗糙度和光源的大小。对于一个小光源，一个与视场角度相比包含一个很小的实心角度的光源，误差很小。粗糙的表面也倾向于显示光源大小小于抛光的效果。一般情况下，面点的面发射面积和面BRDF的镜面波瓣都是球面函数。如果我们考虑这两个函数有重要贡献的方向集，我们得到两个实心角。误差的决定因素与发射角相对于BRDF镜面高光立体角的大小成正比。</strong></p>
<p><strong>最后，请注意，区域光的高光可以通过使用准时光和增加表面粗糙度来近似。这个观察结果对于推导出代价更低的面积光积分近似是有用的。这也解释了为什么在实践中许多实时渲染系统只使用准时源就能产生可信的结果:艺术家弥补了这个错误。然而，这样做是有害的，因为它将材质属性与特定的照明设置结合在一起。以这种方式创建的内容在灯光场景改变时看起来并不正确。</strong></p>
<p><strong>对于朗伯曲面的特殊情况，使用点光作为面积光是准确的。对于这样的表面，输出辐亮度与辐照度成正比:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125424.png" class="" title="image-20211010125424">

<p><strong>在ρss 为表面的次表面反照率或漫反射色(第9.9.1节)。根据这个关系，我们可以使用等效的上上公式来计算辐照度，这要简单得多:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125434.png" class="" title="image-20211010125434">

<p><strong>矢量辐照度的概念有助于理解辐照度在区域光源存在时的行为。矢量辐照度是由Gershun提出的，他称之为光矢量，并由Arvo进一步扩展。利用矢量辐照度，可以将任意大小和形状的面积光源准确地转换为点或方向光源。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125548.png" class="" title="image-20211010125548">

<p>矢量辐照度的计算。左:点p被各种形状、大小和亮度分布的光源包围。黄色的亮度表示放射出的亮度。橙色箭头是指向所有方向的矢量，每个长度等于从那个方向发出的辐射量乘以箭头覆盖的无限小实心角度。原则上，箭头的数目应该是无限的。右:矢量辐照度(大橙色箭头)是所有这些矢量的总和。矢量辐照度可用来计算任意平面在p点的净辐照度。</p>
<p><strong>想象一个亮度Li 的分布进入空间中的点p。参见上图。现在我们假设Li 是波长无关的，因此可以表示为标量。对于以入射方向l为中心的每一个无限小实心角dl，将构造一个与l对齐的向量，其长度等于从该方向入射的(标量)亮度乘以dl。最后，将所有向量相加，得到向量辐照度e:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125646.png" class="" title="image-20211010125646">

<p><strong>其中Θ表示对整个方向球进行积分。</strong></p>
<p><strong>向量辐照度e可以通过执行点积来求出任意方向平面上p处的净辐照度:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125716.png" class="" title="image-20211010125716">

<p><strong>n是平面的法线。通过一个平面的净辐照度是通过该平面的“正面”(由平面法线n定义)和通过该平面“负面”的辐照度之间的差。“光网辐照度本身并不能用于遮阳。然而，如果没有亮度通过“负的一面”发射(换句话说，被分析的光分布没有部分之间的角度l和n超过90◦)，那么E(p，−n) = 0和</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125813.png" class="" title="image-20211010125813">

<p><strong>单个区域光源的矢量辐照度可以使用上式，以任意法线n照亮朗伯氏表面，只要n不面对大于90◦远离区域光源的任何部分。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010125857.png" class="" title="image-20211010125857">

<p>单一区域光源的矢量辐照度。在左边，箭头表示用于计算矢量辐照度的矢量。在右边，大的橙色箭头是矢量辐照度e。红色虚线代表光源的范围，红色矢量(每个垂直于红色虚线)定义了一组表面法线的限制。法线外的这个设置将有一个大于90◦与区域光源的某些部分的角度。这些法线不能正确地使用e来计算它们的辐照度。</p>
<p><strong>如果我们假设Li 波长独立不成立，那么在一般情况下，我们不能再定义一个单一的向量e。然而，有色光通常在所有点有相同的相对光谱分布，这意味着我们可以因子Li 变成颜色c′ 和波长无关的辐射分布L′i．在这种情况下，我们可以计算L ‘的ei 将上式扩展为n·e乘以c ‘。这样做得到的结果与从a开始计算辐照度的公式相同定向光源，替换如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130011.png" class="" title="image-20211010130011">

<p><strong>我们有效地将任意形状和大小的面积光源转换为定向光源而不引入任何误差。</strong></p>
<p><strong>求矢量辐照度的公式10.4对于简单情况可以用解析方法求解。例如，假设一个圆心为pl 的球形光源半径是rl．光发出恒定的亮度Ll 从球体上的每一点，从各个方向。对于这种光源，公式10.4和上式得出如下结果:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130109.png" class="" title="image-20211010130109">

<p><strong>这个等式与带有clight0 = Ll, r0 = rl的泛光灯(章节5.2.2)相同，和标准的平方反比距离衰减函数。这个衰减函数可以调整，以考虑到球内的点，并将光的影响限制到给定的最大距离。有关此类调整的更多细节可参阅第5.2.2节。</strong></p>
<p><strong>所有这些都是正确的，只有当没有“负的一面”辐照度。另一种思考方法是，区域光源的任何部分都不能“在地平线下”，或者被表面遮挡。我们可以推广这个说法。对于朗伯曲面，区域和点光源之间的所有差异都是由遮挡差异造成的。点光源的辐照度在光线不被遮挡的情况下服从余弦定律。Snyder推导了考虑遮挡的球形光源的解析表达式。这个表达式相当复杂。然而，由于它只取决于两个量(r/rl 和θi， n和lc之间的夹角)，它可以预先计算成一个二维纹理。Snyder还给出了两个适用于实时渲染的函数逼近。</strong></p>
<p><strong>在上上上图中，我们看到区域照明的效果对粗糙表面不太明显。这个观察结果也允许我们使用一种较少物理基础但仍然有效的方法来建模Lambertian表面上的区域灯光效果:包裹照明。在这种技术中，对n·l的值做一些简单的修改，然后将其固定为0。Forsyth给出了一种包裹式照明的形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130340.png" class="" title="image-20211010130340">

<p><strong>kwrap 范围从0(点光源)到1(覆盖整个半球的区域光源)。Valve使用了另一种模拟大面积光源效果的形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130350.png" class="" title="image-20211010130350">

<p><strong>一般来说，如果我们计算区域光照，我们还应该修改阴影计算，以考虑非准时源。如果我们不这样做，一些视觉效果可能会被强烈的阴影抵消。如第7章所述，软阴影可能是区域光源最明显的效果。</strong></p>
<h3 id="Glossy-Materials-光泽材质"><a href="#Glossy-Materials-光泽材质" class="headerlink" title="Glossy Materials 光泽材质"></a>Glossy Materials 光泽材质</h3><p><strong>区域灯光在非兰伯特表面上的效果更复杂。Snyder推导出球形光源的求解方法，但其限于原始的反射矢量Phong材料模型，且极其复杂。在今天的实践中，需要近似法。</strong></p>
<p><strong>区域灯光在光滑表面上的主要视觉效果是亮点。参见上上上图。它的大小和形状与区域光相似，而高光的边缘根据表面的粗糙度而模糊。这一观察结果导致了对这种效应的几个经验近似。这些在实践中很有说服力。例如，我们可以修改高光计算的结果，加入一个临界值，创建一个大的平面高光区域。这可以有效地创造球光源镜面反射的错觉，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130529.png" class="" title="image-20211010130529">

<p>光滑物体上的高光是光源形状的强烈反射。在左边，这个外观已经通过阈值的Blinn-Phong着色器的高亮值来近似。在右侧，相同的对象使用未修改的Blinn-Phong着色器进行比较。(图片由拉里·格里茨提供)</p>
<p><strong>大多数用于实时渲染的区域照明效果的实际近似都是基于这样的想法:为每个着色点寻找一个等效的准时照明设置，以模拟一个非无穷小光源的效果。该方法常用于实时绘制，以解决各种问题。这与我们在第9章中看到的处理表面像素足迹上的BRDF积分的原理相同。它产生的近似值通常很便宜，因为所有的工作都是通过改变着色方程的输入来完成的，而不会引入任何额外的复杂性。因为数学没有被改变，我们经常可以保证，在某些条件下，我们恢复到对原始着色的计算，从而保留它的所有属性。由于大多数典型系统的着色代码都是基于点灯的，所以将这些用于区域灯只会引入本地化的代码更改。</strong></p>
<p><strong>开发的第一个近似是Mittring的粗糙度修改，用于Unreal Engine的“Unreal Engine”。这个想法是首先找到一个包含大部分光源照射到半球方向上的圆锥体。然后，我们在镜瓣周围安装一个类似的锥，包含“大部分”BRDF。参见下图。这两种视锥细胞都是半球功能的替代品，它们包含了一组方向，在这些方向上，这两种功能的值大于给定的任意临界值。这样，我们可以通过寻找一个新的BRDF瓣来近似光源与材料BRDF的卷积，这个BRDF瓣的粗糙度不同，它有一个对应的圆锥，其立体角等于光瓣角与材料BRDF的和。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130803.png" class="" title="image-20211010130803">

<p>GGX BRDF，以及一个圆锥体，用于包围反射镜瓣反射大部分入射光的方向集。</p>
<p><strong>Karis将Mittring原理应用于GGX/Trowbridge- Reitz BRDF(章节9.8.1)和球面面积光，得到了GGX粗糙度参数αg的简单修正：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130902.png" class="" title="image-20211010130902">

<p><strong>注意在第1.2节中介绍的符号x+ˉ的用法，用于在0和1之间夹紧。这种近似工作得相当好，而且非常便宜，但对于有光泽的、几乎像镜子一样的材质来说，这种方法就行不通了。这是因为镜面波瓣总是平滑的，不能模拟由区域光源在表面上的强烈反射引起的高光。此外，大多数微表面 BRDF模型都有一个瓣，它不是“紧凑的”(局部的)，但表现出一个广泛的衰减(镜面尾)，使得粗糙度重映射的效率降低。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010130957.png" class="" title="image-20211010130957">

<p>球形照明。从左到右:数值积分、粗糙度修正技术、代表点技术计算的参考解。(图片来源:Epic Games Inc.， Brian Karis)</p>
<p><strong>而不是改变材料的粗糙度，另一个想法是表示区域照明的来源与光的方向，根据被着色点的变化。这被称为最具代表性的点解决方案，修改光矢量，使其在产生最大光的区域表面上的点的方向上对着色表面的能量贡献。参见上图。Picott使用光线上与反射光形成最小角度的点。Karis改进了Picott的公式，为了提高效率，他将球面上与反射光距离最短的点夹角最小的点近似。他还提出了一个廉价的公式来衡量光的强度，以尽量保持整体释放的能量。参见下图。大多数有代表性的点解都是方便的，并且已经发展为各种光几何，因此了解它们的理论背景是很重要的。这些方法类似于蒙特卡罗积分中的重要抽样的思想，在蒙特卡罗积分中，我们通过在积分域上平均样本来数值计算定积分的值。为了更有效地做到这一点，我们可以尝试对总体平均值有较大贡献的样本进行优先排序。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010131146.png" class="" title="image-20211010131146">

<p>球面的Karis代表点近似。首先计算出反射光上最接近球心l的点:pcr = (l·r)r−l，那么球面上最接近pcr的点:pcs = l + pcr·min(1，radius /||pcr||)．</p>
<p><strong>更严格地证明其有效性的是定积分的中值定理，它允许我们用同一函数的单个求值来替换函数的积分:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010131331.png" class="" title="image-20211010131331">

<p><strong>如果f (x)在D是连续,然后∫D 1是域的面积,与c点∈D在函数最小值和最大值之间的界线在D .对于照明,我们考虑的是产品的积分和双向光辐照度超过半球的面积覆盖的光。我们通常认为我们的光是均匀照射的，所以我们只需要考虑光的衰减，并且大多数近似也假设区域D从着色点是完全可见的。 即使有这些假设，确定点c和归一化因子∫D 1仍然可能太昂贵，所以要使用进一步的近似。</strong></p>
<p><strong>有代表性的点解决方案也可以通过它们对高光形状的影响来框定。在表面的一部分，当反射矢量在区域光所覆盖的方向锥的外面时，代表点不会改变，我们使用点光有效地照明。高光的形状只取决于下面的镜面瓣的形状。或者，如果我们在反射向量击中区域光的表面上着色点，那么代表点将不断变化，以指向最大贡献的方向。这样做有效地扩展了镜面波瓣峰值，“扩大”它，这种效果类似于上上上上图中的硬阈值。</strong></p>
<p><strong>这个宽的、恒定的高光峰也是近似中剩余的误差来源之一。在粗糙的表面上，区域的光反射看起来比地面真实的解决方案更“锐利”。通过蒙特卡洛积分得到一个与粗糙修改技术的过度模糊相反的视觉缺陷。为了解决这个问题，Iwanicki和Pesce将BRDF瓣、软阈值、代表性点参数和比例因子(为了节能)拟合到通过数值积分计算得到的球形区域照明结果中，得到了近似结果。这些拟合函数的结果是一个由材质粗糙度、球体半径和光源中心与表面法线和视图向量之间的角度索引的参数表。由于在着色器中直接使用这种多维查找表是昂贵的，因此提供了封闭形式的近似。最近，de Carpentier推导出了一种改进的方法，用于基于微面的BRDFs，可以更好地保留球面区域源在掠入射角度下的高光形状。这种方法的工作原理是找到一个具有代表性的点，使表面法线和光线视图半矢量之间的点积n·h最大化，而不是原始公式的n·r(这是为Phong BRDF导出的)。</strong></p>
<h3 id="General-Light-Shapes-一般灯光形状"><a href="#General-Light-Shapes-一般灯光形状" class="headerlink" title="General Light Shapes 一般灯光形状"></a>General Light Shapes 一般灯光形状</h3><p><strong>到目前为止，我们已经看到了一些计算均匀发射球形区域光和任意光滑BRDFs着色的方法。这些方法中的大多数都采用了各种各样的近似方法，以便得出能够快速实时评估的数学公式，因此与实际问题的解决方法相比，会显示出不同程度的误差。然而，即使我们有计算能力得出一个精确的解，我们仍然会犯一个很大的错误，一个我们嵌入在照明模型假设中的错误。现实世界中的光通常不是球体，它们也很难成为完美的均匀发射体。参见下图。球面区域灯在实践中仍然是有用的，因为他们提供了最简单的方法来打破照明和表面粗糙度之间的错误相关性，准时灯引入。然而，只有当球面光源相对较小时，它才能很好地近似于大多数真实光源。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010132015.png" class="" title="image-20211010132015">

<p>常用的光形状。从左到右:球体，矩形(卡)，管(线)，和聚焦发射管(沿光表面法线集中，不均匀散布在半球)。注意它们创建的不同的亮点。</p>
<p><strong>由于基于物理的实时渲染的目标是生成令人信服的、可信的图像，在这个追求中，我们只能将自己限制在一个理想化的场景中。在计算机图形学中，这是一种反复出现的权衡。我们可以通常是在为简化假设的简单问题生成精确的解决方案，还是为更贴近现实的更普遍的问题生成近似的解决方案之间进行选择。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010132145.png" class="" title="image-20211010132145">

<p>一个光管。图像采用代表性点解进行计算。</p>
<p><strong>球形灯的一个最简单的扩展是“管”灯(也称为“胶囊”)，它可以用来代表现实世界中的荧光灯。参见上图。对于Lambertian BRDFs, Picott给出了一个封闭形式的照明积分公式，该公式等价于用适当的衰减函数计算线性光段的两个点光源的照明:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010132214.png" class="" title="image-20211010132214">

<p><strong>p0 和p1 是线性光的两个端点，n是表面法线。Picott还推导出了Phong高光BRDF积分的一个代表性点解，近似为从放置在光段位置的点光源进行照明，当连接到考虑的表面点时，形成了与反射矢量的最小夹角。这个具有代表性的点解动态地将线性光转换为点1，因此我们可以使用任何近似球面光来“加厚”光夹具到一个胶囊中。</strong></p>
<p><strong>在球形灯的情况下,Karis提供了一个更高效的(但不太准确)变体Picott最初的解决方案,通过使用最小的点线距离反射向量(而不是最小的角),并提出一个缩放公式,试图恢复能量守恒。</strong></p>
<p><strong>我们可以很容易地获得许多其他光形状的代表性点近似，如环和B´ezier分段，但我们通常不希望我们的着色器分支太多。在我们的场景中，好的光形状可以用来代表许多真实世界的光。最具表现力的形状类别之一是平面区域灯，定义为由给定几何形状(如矩形(在这种情况下它们也被称为卡片灯)、磁盘或更普遍的多边形)约束的平面的一部分。这些原体可以用于发射面板，如广告牌和电视屏幕，代替常用的摄影照明(软盒，反弹卡)，模拟许多更复杂的照明装置的光圈，或表示从墙壁和场景中其他大型表面反射的光线。</strong></p>
<p><strong>Drobot是卡片灯(以及磁盘)的第一个实际近似值。这也是一个具有代表性的点解，但它特别值得注意，因为将这种方法扩展到平面的二维区域非常复杂，而且对于求解的整体方法来说也是如此。机器人从均值定理开始，作为第一次近似，确定一个好的候选点用于光线评估应该位于光照积分的全局最大值附近。</strong></p>
<p><strong>对于朗伯BRDF，这个积分是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010132452.png" class="" title="image-20211010132452">

<p><strong>Ll 是光发射的恒定辐射度，ωl 是灯光几何正对立体角，rl 是在l方向上从曲面到灯光平面的光线长度，(n·l)+为常用的朗伯夹紧点积。(n·l)+的最大值点pc 在光区域的边界上，从该表面发出的光线沿法线方向与光平面相交而得到的离点p ‘最近的点。同样，1/rl² 的最大值是点pr 在最接近p′′ 点的边界上这是光平面上离被着色覆盖的表面点最近的地方。参见下图。被积函数的全局最大值就在连接pr 和pc的线段上的某个地方: pmax = tmpc +(1 - tm) pr，tm ∈[0,1]。Drobot使用数值积分来找到许多不同构型的最佳代表点，然后找到单个tm 这在平均水平上是最好的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010133131.png" class="" title="image-20211010133131">

<p>Drobot矩形面积光代表点近似的几何构造。</p>
<p><strong>Drobot的最终解决方案采用了漫反射和镜面照明的进一步近似，所有这些都是通过与数值上发现的地面真实解决方案进行比较来实现的。他还推导出了一种算法，用于纹理卡片灯的重要情况，在光线的矩形区域，发射不是恒定的，而是由纹理调制的。该过程使用一个三维查找表执行，该表包含在不同半径的圆形足迹上预集成的发射纹理版本。Mittring使用类似的方法来处理光滑反射，将反射光线与有纹理的矩形广告牌相交，并根据光线相交距离索引预计算的纹理模糊版本。这项工作先于Drobot的发展，但它是一种更经验性的、不那么有原则的方法，确实试图匹配实际的整体解决方案。</strong></p>
<p><strong>对于平面多边形区域灯的更一般情况，Lambert最初推导出了一种完全漫射表面的精确封闭解。Arvo对该方法进行了改进，允许将光滑材质建模为Phong镜面瓣。Arvo通过将矢量辐照度的概念扩展到高维辐照度张量，并利用斯托克定理将面积积分作为沿积分域轮廓的简单积分来求解。他的方法做出的唯一假设是，光从着色表面点完全可见(这是一个常见的，可以通过剪切与表面相切的光多边形来绕过)，BRDF是一个径向对称的余弦瓣。不幸的是，在实践中，Arvo的解析解对于实时渲染是相当昂贵的，因为它需要评估一个公式，其时间复杂度是线性的Phong瓣指数使用，每个区域光多边形的每条边。最近Lecocq通过找到一个O(1)逼近轮廓积分函数，并将解推广到一般的、基于半矢量的BRDFs，使这种方法更加实用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010133523.png" class="" title="image-20211010133523">

<p>线性变换余弦技术背后的关键思想是，通过使用3 × 3变换矩阵，一个简单的余弦叶(在左边)可以很容易地缩放、拉伸和倾斜。这使得余弦瓣在球面上有许多不同的形状。(图片由Eric Heitz提供。)</p>
<p><strong>迄今为止所描述的所有实际的实时区域照明方法都采用了某些简化假设，以允许推导分析结构和近似处理得到的积分。Heitz等人对线性变换余弦(LTCs)采取了不同的方法，得出了实用、准确和通用的技术。他们的方法是从在球体上设计一类具有高度表现力的函数开始。例如，它们可以有多种形状)，并且可以在任意球形多边形上轻松集成。参见上图。LTCs只使用一个通过3×3矩阵变换的余弦瓣，因此它们可以在半球上调整大小、拉伸和旋转，以适应各种形状。球面多边形的简单余弦瓣(不像Blinn-Phong，没有取指数)的积分已经建立，可以追溯到Lambert。Heitz等人的关键观察是，在波瓣上用变换矩阵扩展积分不会改变其复杂性。我们可以通过矩阵的逆变换多边形域，并在积分内消去矩阵，返回到一个简单的余弦叶作为被积函数。参见下图。通用的双向反射和区域灯光形状,剩下的工作就是想办法(近似)表达的双向反射函数作为一个或多个LTCs范围,可以离线完成的工作和列表中查找数组索引与BRDF参数:粗糙度、入射角等上。线性变换的基于余弦的解决方案，既适用于一般的纹理多边形区域光源，也适用于特殊的、计算成本较低的形状，如卡片、磁盘和线灯。LTCs可能比典型的点解决方案更昂贵，但更精确。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211010133721.png" class="" title="image-20211010133721">

<p>给定一个LTC和一个球面多边形域(左图)，我们可以通过LTC矩阵的逆对它们进行变换，从而得到一个简单的余弦瓣和一个新的域(右图)。余弦瓣在变换域中的积分等于LTC在原域中的积分。(图片由Eric Heitz提供。)</p>
<h2 id="Environment-Lighting-环境光"><a href="#Environment-Lighting-环境光" class="headerlink" title="Environment Lighting 环境光"></a>Environment Lighting 环境光</h2><p><strong>原则上，反射率(公式9.3)不区分直接来自光源的光和从天空或场景中物体散射的间接光。所有入射方向都有辐亮度，反射率方程对所有方向进行积分。然而，在实践中，直射光通常以相对小的实心角度和高辐亮度值来区分，而间接光往往以中到低辐亮度值漫射覆盖半球的其余部分。这种拆分为分别处理这两个问题提供了很好的实际理由。</strong></p>
<p><strong>到目前为止，区域光技术讨论了积分恒定辐射从光的形状发射。这样做为每个着色表面点创建了一组方向，这些方向具有恒定的非零入射辐亮度。我们现在所研究的是在所有可能的入射方向上用变化函数定义的辐亮度的积分方法。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011135924.png" class="" title="image-20211011135924">

<p>渲染在不同的环境照明下同一个场景。</p>
<p><strong>虽然我们通常会在这里讨论间接照明和“环境”照明，但我们不会研究全局照明算法。关键的区别在于，在本章中，所有的着色数学并不依赖于场景中其他表面的知识，而是依赖于一组光基元。所以，虽然我们可以，举个例子，使用区域光来模拟光线从墙壁的反射，这是一个全局效果，但着色算法不需要知道墙壁的存在。它拥有的唯一信息是关于光源的，所有的着色都是在局部执行的。全局照明(第11章)将经常与本章的概念密切相关，因为许多解决方案可以看作是计算的方法为每个物体或表面位置使用正确的局部光原语集，以模拟光线在场景周围反弹的交互作用。</strong></p>
<p><strong>环境光是环境照明最简单的模型，其亮度不随方向变化，LA为常数．即使是这样一个环境照明的基本模型也能显著提高视觉质量。一个不考虑光线从物体间接反射的场景显得非常不现实。在这样的场景中，处于阴影或背光的物体将是完全黑色的，这与现实中发现的任何场景都不一样。在376页的图10.1中，月球表面与之很接近，但即使在这样的场景中，一些间接的光线也会反射到附近的物体上。</strong></p>
<p><strong>环境光的确切效果将取决于BRDF。对于朗伯曲面，固定的亮度LA 无论表面法向n或视图方向v，输出辐亮度的贡献都是恒定的:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011140144.png" class="" title="image-20211011140144">

<p><strong>当着色时，这个恒定的出射亮度贡献被添加到直接光源的贡献中。对于任意BRDFs，等价方程为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011140154.png" class="" title="image-20211011140154">

<p><strong>该方程的积分与方向反照率R(v)(第9.3节式9.9)相同，因此方程等价于Lo(v) = LAR (v)。旧的实时渲染应用程序有时假定R(v)是一个常量，称为环境色camb．这进一步将方程简化为Lo(v) = camblA．</strong></p>
<p><strong>反射方程忽略遮挡，即许多表面点会被其他物体或同一物体的其他部分挡住，无法“看到”一些进入的方向。这种简化降低了现实主义一般，但它是特别明显的环境照明，当遮挡被忽略时，它显得非常平坦。解决这个问题的方法将在第11.3节讨论，特别是在第11.3.4节。</strong></p>
<h2 id="Spherical-and-Hemispherical-Functions-球面和半球函数"><a href="#Spherical-and-Hemispherical-Functions-球面和半球函数" class="headerlink" title="Spherical and Hemispherical Functions 球面和半球函数"></a>Spherical and Hemispherical Functions 球面和半球函数</h2><p><strong>为了将环境照明扩展到一个常数项之外，我们需要一种方法来表示从任何方向入射到物体上的亮度。首先，我们将认为辐亮度仅仅是被积分方向的函数，而不是表面位置的函数。这样做是基于光照环境是无限远的假设。</strong></p>
<p><strong>到达某一给定点的辐射在每个入射方向上都是不同的。照明可以从左边变为红色，从右边变为绿色，或者从顶部被阻挡而从侧面不被阻挡。这些类型的量可以用球形表示函数，定义在单位球面上，或者R³的方向空间上．我们将这个域表示为s。这些函数的工作方式不受它们产生单个值还是多个值的影响。例如，通过为每个颜色通道存储单独的标量函数，用于存储标量函数的相同表示也可以用于编码颜色值。</strong></p>
<p><strong>假设朗伯曲面，球形函数可以用来计算环境照明，通过存储一个预先计算的辐照度函数，例如，辐射与余弦瓣卷积，每个可能的表面法向。更复杂的方法存储辐亮度，并在运行时使用BRDF计算每个着色表面点的积分。球面函数也广泛用于全局光照算法(第11章)。</strong></p>
<p><strong>与球面函数相关的是那些半球函数，在这种情况下，只有一半方向的值是定义的。例如，这些函数用于描述在没有来自下面的光的表面入射的辐亮度。</strong></p>
<p><strong>我们将把这些表示称为球基，因为它们是定义在球上的函数的向量空间的基。即使环境/高光/方向形式(章节10.3.3)在技术上不是数学意义上的基础，我们也将使用这个术语来指代它。将函数转换为给定的表示形式称为投影，从给定的表示形式求函数的值称为重构。</strong></p>
<p><strong>每种表示都有自己的一组权衡。我们可以在给定的基础上寻找的属性是:</strong></p>
<pre><code>**•高效的编码(投影)和解码(查找)。**

**•能够表示任意球面函数，系数小，重构误差低。**

**•投影的旋转不变性，它是旋转函数的投影的结果，与旋转函数然后进行投影是相同的。这种等效性意味着一个近似于，例如，球谐函数在旋转时不会改变。**

**•易于计算编码函数的总和和乘积。**

**•易于计算球面积分和卷积。**
</code></pre>
<h3 id="Simple-Tabulated-Forms-简单表格"><a href="#Simple-Tabulated-Forms-简单表格" class="headerlink" title="Simple Tabulated Forms 简单表格"></a>Simple Tabulated Forms 简单表格</h3><p><strong>表示球形(或半球形)函数的最直接方法是选择几个方向，并为每个方向存储一个值。对函数的求值涉及到在求值方向周围找到一些样本，然后用某种形式的插值来重建这个值。</strong></p>
<p><strong>这种表示很简单，但很有表现力。添加或相乘这样的球形函数就像添加或相乘相应的表项一样简单。</strong></p>
<p><strong>我们可以根据需要，通过添加更多的样本，以任意低的误差编码许多不同的球面函数。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011140617.png" class="" title="image-20211011140617">

<p>在球面上分布点的几种不同方法。从左到右:随机点，立方体网格点，球面t形设计。</p>
<p><strong>以一种允许高效检索的方式将样本分布在一个球体上(参见上图)，同时相对平等地表示所有方向，这不是一件简单的事情。最常用的技术是首先将球体展开成一个矩形域，然后用点网格对这个域进行采样。由于二维纹理恰好代表了一个矩形上的点(像素)网格，我们可以使用像素作为样本值的底层存储。这样做可以让我们利用gpu加速的双线性纹理过滤来进行快速查找(重建)。在本章的后面，我们将讨论环境映射(第10.5节)，它是这种形式的球形函数，并讨论展开球形的不同选项。</strong></p>
<p><strong>表格也有缺点。在低分辨率下，硬件滤波提供的质量通常是不可接受的。卷积的计算复杂度是处理光照时的一种常见操作，它与样本的数量成正比，可能会令人却步。此外，投影在旋转下不是不变的，这在某些应用中可能是有问题的。例如，想象从一组方向照射到物体表面的光的亮度编码。如果对象旋转，编码的结果可能会以不同的方式重建。这可以导致编码的辐射能数量的变化，这可以在场景动画时表现为脉动的人工制品。通过在投影和重构过程中使用与每个样本相关的精心构造的核函数，可以减轻这些问题。不过，更常见的是，仅仅使用足够密集的采样就足以掩盖这些问题。</strong></p>
<p><strong>通常，当我们需要存储复杂的、高频率的函数时，我们会使用表格，这些函数需要许多数据点来进行低误差的编码。如果我们需要对球函数进行紧凑的编码，只有几个参数，可以使用更复杂的基。</strong></p>
<p><strong>环境立方体(AC)是一种流行的基本选择，它是最简单的表格形式之一，由沿长轴方向的6个平方余弦瓣构成。它被称为环境“立方体”，因为它相当于将数据存储在……的表面上一个立方体，当我们从一个方向移动到另一个方向时进行插值。对于任何给定的方向，只有三个叶瓣是相关的，所以其他三个叶瓣的参数不需要从内存中提取。数学上，环境立方体可以定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011140732.png" class="" title="image-20211011140732">

<p><strong>其中c+ 和c− 包含多维数据集面和sel+(c+,c−,(d)的六个值是一个向量函数，它的每个分量都假定来自c+ 或c− 的值根据d中各自的分量是否为正。</strong></p>
<p><strong>环境立方体类似于立方体映射(章节10.4)，每个立方体表面只有一个texel。在某些系统中，针对这种特殊情况，在软件中执行重构可能比在立方体映射上使用GPU的双线性滤波要快。Sloan推导出一个简单的公式，用于在环境立方和球谐基之间进行转换(第10.3.2节)。</strong></p>
<p><strong>使用环境立方体重建的质量相当低。通过存储和插值8个值而不是6个值(对应于立方体顶点)，可以获得稍微更好的结果。最近，Iwanicki和Sloan提出了一种称为环境骰子(AD)的替代方法。基由沿二十面体顶点方向的平方和四次方余弦瓣组成。存储的12个值中有6个用于重建，确定检索哪6个值的逻辑比环境立方体的对应逻辑稍微复杂一些，但结果的质量要高得多。</strong></p>
<h3 id="Spherical-Bases-基于球形"><a href="#Spherical-Bases-基于球形" class="headerlink" title="Spherical Bases 基于球形"></a>Spherical Bases 基于球形</h3><p><strong>有无数种方法可以将(编码)函数投射到使用固定数量值(系数)的表示上。我们所需要的是一个数学表达式，它跨越了我们的球域，带有一些我们可以改变的参数。然后我们可以通过拟合逼近任意给定的函数，即找到参数的值，使表达式与给定函数之间的误差最小化。</strong></p>
<p><strong>最小可能的选择是使用一个常量:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011143711.png" class="" title="image-20211011143711">

<p><strong>我们可以将给定的函数f在单位球的表面积上求平均，从而导出它在这个基底上的投影:<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011143820.png" class="" title="image-20211011143820">。平均函数c也称为直流分量。这种基具有简单的优点，甚至考虑了我们正在寻找的一些性质(易重构、加法、积、旋转不变性)。然而，它不能很好地表达大多数球形函数，因为它只是用它们的平均值来代替它们。我们可以用两个系数a和b构造一个稍微复杂一点的近似:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011143721.png" class="" title="image-20211011143721">

<p><strong>它创建了一种表示，可以在极点编码精确的值，并可以在它们之间插入穿过球体的表面。这种选择更具表现力，但现在投影变得更加复杂，并不是对所有旋转都是不变的。事实上，这个基础可以看作是一个表格形式，只有两个样本，放在极点。</strong></p>
<p><strong>一般来说，当我们讨论函数空间的基时，我们的意思是我们有一组函数，它们的线性组合(加权和求和)可以用来表示给定域中的其他函数。这个概念的示例如下图所示。本节的其余部分探讨了一些可用于在球面上近似函数的基的选择。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144010.png" class="" title="image-20211011144010">

<p>基函数的一个基本例子。在本例中，空格是“输入在0到5之间的值在0到1之间的函数”。左边的图显示了这种功能的一个例子。中间的图显示了一组基函数(每种颜色都是一个不同的函数)。右边的图显示了目标函数的近似值，它是通过将每个基函数乘以一个权重并对其求和而形成的。基函数按其各自的权重按比例表示。黑线表示求和的结果，它是原始函数的近似，用灰色表示以供比较。</p>
<h4 id="Spherical-Radial-Basis-Functions-球面径向基函数"><a href="#Spherical-Radial-Basis-Functions-球面径向基函数" class="headerlink" title="Spherical Radial Basis Functions 球面径向基函数"></a>Spherical Radial Basis Functions 球面径向基函数</h4><p><strong>使用GPU硬件滤波的表格重建质量较低，至少在一定程度上是由用于插值样本的双线性形状函数造成的。其他函数可以用来对重构样本进行加权。这种函数可能比双线性滤波产生更高质量的结果，而且它们可能还有其他优点。通常用于此目的的一组函数是球面径向基函数(SRBFs)。它们是径向对称的，这使得它们只有一个参数，即它们所指向的轴与计算方向之间的角度。基是由一组这样的函数组成的，这些函数被称为瓣，分布在整个球体上。函数的表示由每个叶的一组参数组成。这个集合可以包含它们的方向，但这会使投影变得更加困难(需要非线性、全局优化)。由于这个原因，波瓣方向通常被假定是固定的，均匀分布在整个球面上，并使用其他参数，如每个波瓣的大小或它的扩展，即覆盖的角度。重建是通过评估给定方向的所有瓣，并将结果相加来进行的。</strong></p>
<h4 id="Spherical-Gaussians-球形高斯函数"><a href="#Spherical-Gaussians-球形高斯函数" class="headerlink" title="Spherical Gaussians 球形高斯函数"></a>Spherical Gaussians 球形高斯函数</h4><p><strong>对于SRBF瓣，一个特别常见的选择是球形高斯分布(SG)，在方向统计中也称为von Mises-Fisher分布。我们应该注意到von-Mises-Fisher分布通常包含一个标准化常数，我们在公式中避免了这个常数。单个瓣可定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144331.png" class="" title="image-20211011144331">

<p><strong>其中v为评价方向(单位向量)，d为瓣方向轴(分布的均值，也归一化)，λ≥0为瓣锐度(控制其角宽，也称为浓度参数或扩散)。</strong></p>
<p><strong>为了构造球面基，我们使用给定数目的球面高斯函数的线性组合:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144344.png" class="" title="image-20211011144344">

<p><strong>将球函数投影到这个表示法中需要找到参数集合{wk,dk,λk}使重构错误最小化。这个过程通常是通过数值优化来完成的，通常使用非线性最小二乘优化算法(如Levenberg-Marquardt)。请注意，如果我们允许在优化过程中整组参数发生变化，我们就不会使用函数的线性组合，因此上方程并不代表一组基。只有选择一组固定的瓣(方向和扩展)，才能得到一个合适的基，使整个域都能很好地覆盖，并且只拟合权值wk进行投影．这样做也极大地简化了优化问题，因为现在它可以表述为普通的最小二乘优化。如果我们需要在不同的数据集(投影函数)之间进行插值，这也是一个很好的解决方案。在这种情况下，允许波瓣方向和锐度变化是有害的，因为这些参数是高度非线性的。</strong></p>
<p><strong>这种表述的优点是SGs的许多操作都有简单的解析形式。两个球面高斯函数的乘积是另一个球面高斯函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144501.png" class="" title="image-20211011144501">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144511.png" class="" title="image-20211011144511">

<p><strong>球面高斯函数的积分也可以通过解析计算:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144521.png" class="" title="image-20211011144521">

<p><strong>这意味着两个球面高斯积的积分也有一个简单的公式。</strong></p>
<p><strong>如果我们可以将光辐亮度表示为球面高斯函数，那么我们可以将其乘积与以相同表示形式编码的BRDF进行集成，以进行照明计算。由于这些原因，SGs在许多研究项目和工业应用中得到了应用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144625.png" class="" title="image-20211011144625">

<p>各向异性高斯球面。左:球体上的ASG和相应的自上而下的情节。右:ASG配置的其他四个例子，显示了公式的表现力。(徐坤图)</p>
<p><strong>对于平面上的高斯分布，von Mises-Fisher分布可以推广到允许各向异性。Xu等引入了各向异性球面高斯(ASGs;如上图所示)，其定义为在单方向d上加上两个补充轴t和b，共同构成一个正交切坐标系:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144700.png" class="" title="image-20211011144700">

<p><strong>其中λ，µ≥0控制波瓣沿正切坐标系的两轴展开，S(v, d) = (v·d)+为平滑项。这个术语是方向统计中使用的Fisher-Bingham分布和计算机图形学中使用的asg之间的主要区别。Xu等人还提供了积分、乘积和卷积算子的解析逼近。</strong></p>
<p><strong>尽管SGs有许多理想的属性，但它们的一个缺点是，与表格形式和一般有限范围(带宽)的内核不同，它们有全局支持。对于整个球体来说，每个波瓣都是非零的，尽管它的衰减相当快。这种全局范围意味着，如果我们使用N个瓣来表示一个函数，我们将需要所有N个瓣来在任何方向上进行重构。</strong></p>
<h4 id="Spherical-Harmonics-球面谐波"><a href="#Spherical-Harmonics-球面谐波" class="headerlink" title="Spherical Harmonics 球面谐波"></a>Spherical Harmonics 球面谐波</h4><p><strong>球面调和函数(SH)是球面上的一组正交基函数。基函数的正交集是这样一个集合，它使得任意两个不同函数的内积为零。内积是一个更一般，但类似于点积的概念。两个向量的内积是它们的点积:两个分量相乘的和。我们同样可以通过考虑两个函数相乘的积分，推导出两个函数的内积的定义:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144944.png" class="" title="image-20211011144944">

<p><strong>积分是在相关域上执行的。对于上上图所示的函数，相关的域在x轴上介于0和5之间(注意，这组函数是不正交的)。球面函数的形式略有不同，但基本概念是相同的:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011144955.png" class="" title="image-20211011144955">

<p><strong>其中n∈Θ表示在单位球上进行积分。</strong></p>
<p><strong>标准正交集是一个正交集，其附加条件是集合中任意函数与自身的内积等于1。更正式地说，一组函数{fj()}是标准正交的条件是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011145006.png" class="" title="image-20211011145006">

<p><strong>下图显示了一个类似于上上图的例子，其中基函数是标准正交的。注意，下图所示的标准正交基函数不重叠。这个条件对于非负函数的标准正交集是必要的，因为任何重叠都意味着一个非零内积。函数在其部分范围内的负值可以重叠，并仍然形成一个标准正交集。这种重叠通常会导致更好的逼近，因为它允许基底平滑。不相交区域的基容易造成不连续。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011145109.png" class="" title="image-20211011145109">

<p>标准正交基函数。本示例使用与上上图相同的空间和目标函数，但基函数已被修改为标准正交。左边是目标函数，中间是基函数的标准正交集，右边是缩放后的基函数。对目标函数的近似结果用黑色虚线表示，原始函数用灰色表示以供比较。</p>
<p><strong>标准正交基的优点是找到与目标函数最接近的近似的过程是直接的。为了进行投影，每个基函数的系数都是目标函数ftarget()的内积具有适当的基函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011145207.png" class="" title="image-20211011145207">

<p><strong>在实践中，这个积分必须用数值计算，通常是通过蒙特卡罗采样，将均匀分布在球体上的n个方向平均。</strong></p>
<p><strong>标准正交基在概念上类似于4.2.4节中介绍的三维向量的“标准基”。标准基的目标不是函数，而是点的位置。标准基由三个向量(每维一个)组成，而不是一组函数。根据上上公式中使用的相同定义，标准基是标准正交的。将点投影到标准基上的方法也是一样的，因为系数是位置向量与基向量的点积的结果。一个重要的区别是，标准基精确地再现了每一个点，而有限的基函数集只能近似它的目标函数。结果永远不可能是精确的，因为标准基使用三个基向量来表示一个三维空间。一个函数空间有无限多的维数，所以有限的基函数永远不能完美地表示它。</strong></p>
<p><strong>球谐是正交的和标准正交的，它们还有其他一些优点。它们是旋转不变的，并且SH基函数的计算成本不高。它们是单位长度向量的x、y和z坐标上的简单多项式。然而，像球面高斯函数一样，它们具有全局支持，因此在重建过程中需要评估所有的基函数。基函数的表达式可以在一些参考文献中找到，包括Sloan的陈述。他的介绍值得注意的是，它讨论了许多使用球面谐波的实用技巧，包括公式，在某些情况下，着色器代码。最近，Sloan还发现了进行SH重建的有效方法。</strong></p>
<p><strong>SH基函数按频带排列。第一个基函数是常数，接下来的三个是线性函数，在球面上变化缓慢，接下来的五个是二次函数，变化稍微快一些。参见下图。频率较低的函数(例如。例如辐照度值，可以用相对较少的SH系数精确地表示(我们将在第10.6.1节中看到)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011145324.png" class="" title="image-20211011145324">

<p>球谐的前五个频带。每个球谐函数都有正的区域(绿色)和负的区域(红色)，当它们接近零时逐渐变黑。(罗宾·格林提供的球面调和可视化。)</p>
<p><strong>当投影到球谐时，得到的系数代表投影函数的各种频率的振幅，即它的频谱。在这个谱域，有一个基本的性质:两个函数的乘积的积分等于函数投影系数的点积。这个属性允许我们高效地计算光照积分。</strong></p>
<p><strong>球面谐波的许多运算在概念上很简单，可以归结为系数向量上的矩阵变换。在这些操作中，计算投影到球谐的两个函数的乘积、旋转投影函数和计算卷积是很重要的例子。在实际中，SH中的矩阵变换意味着这些操作的复杂性是所使用的系数数量的二次，这可能是一个巨大的代价。幸运的是，这些矩阵通常有特殊的结构，可以用来设计更快的算法。Kautz等人提出了一种优化旋转计算的方法，将它们分解为围绕x轴和z轴的旋转。Hable给出了一种流行的快速旋转低阶SH投影的方法。Green的调查讨论了如何利用旋转矩阵的块结构来更快地计算。目前的技术状态是通过分解成带状谐波来表示的，如Nowrouzezahrai等人所提出的。</strong></p>
<p><strong>谱变换的一个常见问题，如下面描述的球谐和h基，是它们可以表现出一种视觉伪影，称为振铃(也称为吉布斯现象)。如果原始信号包含不能用带限近似表示的快速变化，重构将显示出振荡。在极端情况下，这个重建函数甚至可以产生负值。可以使用各种预过滤方法来解决这个问题。</strong></p>
<h4 id="Other-Spherical-Representations-其他球形表示"><a href="#Other-Spherical-Representations-其他球形表示" class="headerlink" title="Other Spherical Representations 其他球形表示"></a>Other Spherical Representations 其他球形表示</h4><p><strong>使用有限数目的系数可以对球函数进行编码。线性变换余弦(第10.1.2节)是一个例子，它可以有效地近似BRDF函数，同时具有在球体的多边形截面上易于积分的特性。</strong></p>
<p><strong>球面小波是一种平衡空间局部(具有紧密的支持)和频率(平滑)的基，允许高频函数的压缩表示。球形分段常数基函数将球体划分成常值区域，以及依赖矩阵分解的双簇近似]，也被用于环境照明。</strong></p>
<h3 id="Hemispherical-Bases-基于半球"><a href="#Hemispherical-Bases-基于半球" class="headerlink" title="Hemispherical Bases 基于半球"></a>Hemispherical Bases 基于半球</h3><p><strong>尽管上述碱基可以用来表示半球函数，但它们是浪费的。信号的一半总是等于零。在这些情况下，通常首选使用直接在半球域上构造的表示。这对于定义在表面上的函数尤其相关:BRDF、入射辐亮度和到达物体给定点的辐照度都是常见的例子。这些函数自然地局限于以给定曲面点为中心的半球，并与曲面法线对齐;它们没有指向对象内部方向的值。</strong></p>
<h4 id="Ambient-Highlight-Direction-环境-高光-方向"><a href="#Ambient-Highlight-Direction-环境-高光-方向" class="headerlink" title="Ambient/Highlight/Direction 环境/高光/方向"></a>Ambient/Highlight/Direction 环境/高光/方向</h4><p><strong>沿着这些线最简单的表述之一是一个常数函数和一个单一方向的组合，在这个方向上，信号在半球最强。它通常被称为环境/高光/方向(AHD)基础，它最常见的用途是存储辐照度。AHD的名称代表了单个组件所代表的:一个恒定的环境光，加上一个方向光，该方向近似于“高光”方向的辐照度，以及大部分入射光集中的方向。AHD基础通常需要存储八个参数。两个角度用于方向向量，两种RGB颜色用于环境光和方向光强度。它的首次显著应用是在《雷神之锤3》中，即以这种方式存储动态对象的体光。从那时起，它便被用于许多游戏中，如《使命召唤》系列。</strong></p>
<p><strong>在这个表示法上的投影有点棘手。因为它是非线性的，寻找近似给定输入的最优参数是昂贵的计算。在实践中，使用的是启发式。首先将信号投影到球面谐波，并利用最优线性方向来定位余弦瓣。给定方向，环境值和亮点值可以使用最小二乘最小化计算。Iwanicki和Sloan展示了如何在执行非负向时执行这种投射。</strong></p>
<h4 id="Radiosity-Normal-Mapping-Half-Life-2-Basis-辐射法向映射-基于半条命2"><a href="#Radiosity-Normal-Mapping-Half-Life-2-Basis-辐射法向映射-基于半条命2" class="headerlink" title="Radiosity Normal Mapping/Half-Life 2 Basis 辐射法向映射/基于半条命2"></a>Radiosity Normal Mapping/Half-Life 2 Basis 辐射法向映射/基于半条命2</h4><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011150039.png" class="" title="image-20211011150039">

<p>《半条命2》照明基础。这三个基向量的仰角约为26◦在切平面以上，他们的投影到该平面的间隔为120◦ 在正常区间的间隔。它们是单位长度，每一个都垂直于另外两个。</p>
<p><strong>Valve为《半条命2》系列游戏使用了一种新颖的表示方法，即在辐射法向映射的背景下表达方向辐照度。它最初设计用于存储预计算的漫反射光照，同时允许法线映射，现在被称为《半条命2》的基础。它通过在切线空间的三个方向上采样来表示曲面上的半球函数。参见上图。这三个相互垂直的基向量在切空间中的坐标是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011150129.png" class="" title="image-20211011150129">

<p><strong>对于重建，给定切空间方向d，我们可以插值E0,E1和E2沿三个基向量:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011150139.png" class="" title="image-20211011150139">

<p><strong>Green指出，如果改为在切空间方向d上预先计算以下三个值，则上式的代价会大大降低:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011150149.png" class="" title="image-20211011150149">

<p><strong>对于k = 0,1,2。式上上化简为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211011150159.png" class="" title="image-20211011150159">

<p><strong>Green描述了这种表示的其他几个优点，其中一些将在第11.4节中讨论。</strong></p>
<p><strong>《半条命2》的基础可以很好地用于定向辐照度。 Sloan发现这种表示产生的结果优于低阶半球谐波。</strong></p>
<h4 id="Hemispherical-Harmonics-H-Basis-半球形谐波-H-Basis"><a href="#Hemispherical-Harmonics-H-Basis-半球形谐波-H-Basis" class="headerlink" title="Hemispherical Harmonics/H-Basis 半球形谐波/ H-Basis"></a>Hemispherical Harmonics/H-Basis 半球形谐波/ H-Basis</h4><p><strong>Gautron等人将球面谐波专门用于半球域，他们称之为半球谐波(HSHs)。可以使用各种方法来执行这种专门化。</strong></p>
<p><strong>例如，泽尼克多项式是正交函数，类似于球面调和函数，但定义在单位圆盘上。与SH一样，这些可以用于在频域(频谱)上变换函数，这产生了许多方便的性质。由于可以将一个单位半球转化为一个圆盘，因此可以用泽尼克多项式来表示半球函数。然而，用这些材料进行重建是相当昂贵的。Gautron等人的解决方案既更经济，又允许系数向量上的矩阵乘法进行相对快速的旋转。</strong></p>
<p><strong>然而，HSH基的评估仍然比球面谐波更昂贵，因为它是通过将球体的负极移到半球的外边缘来构建的。这种移位操作使得基本函数是非多项式的，需要计算除法和平方根，这在GPU硬件上通常是很慢的。此外，基底在半球边缘始终是恒定的，因为它映射到球上的一个点之前的移动。近似误差可能是相当大的附近的边缘，特别是如果只有几个系数(球谐带)使用。</strong></p>
<p><strong>Habel引入了H基，H基部分用于纵向参数化球面调和基，部分用于纵向参数化HSH。这个基础，一个混合了移位和非移位的SH版本，仍然是正交的，同时允许有效的评估。</strong></p>
<h2 id="Environment-Mapping-环境映射"><a href="#Environment-Mapping-环境映射" class="headerlink" title="Environment Mapping 环境映射"></a>Environment Mapping 环境映射</h2><p><strong>在一个或多个图像中记录一个球形函数被称为环境映射，因为我们通常使用纹理映射来实现表中的查找。这种表现形式是最强大和最流行的环境照明形式之一。与其他球形表示法相比，它消耗更多内存，但实时解码简单快速。此外，它可以表达任意高频率的球面信号(通过提高纹理的分辨率)，并能准确捕获任意频率的球面信号环境辐射范围(通过增加每个通道的比特数)。这样的准确性是有代价的。不同于存储在其他常用纹理中的颜色和着色器属性，存储在环境地图中的亮度值通常具有较高的动态范围。每像素的比特数越多，环境地图就会比其他纹理占用更多空间，访问速度也会更慢。</strong></p>
<p><strong>对于任何全局球函数，我们都有一个基本的假设，即用于场景中的所有物体，即入射亮度Li 只取决于方向。这个假设要求被反射的物体和光线在很远的地方，而且反射器不会反射自己。</strong></p>
<p><strong>依赖于环境映射的着色技术通常不以它们代表环境照明的能力为特征，而是通过我们如何将它们与给定的材料整合。也就是说，为了完成积分，我们必须对BRDF采用什么样的近似和假设?反射映射是环境映射的最基本情况，在这种情况下，我们假设BRDF是一个完美的镜像。光学平面或镜面将入射光线反射到光的反射方向ri (9.5节)。同样地，出射辐亮度只包括来自一个方向的入射辐亮度，即反射视图向量r。这个向量的计算方法与ri 相同方程(9.15):</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012135509.png" class="" title="image-20211012135509">

<p><strong>反射镜的反射方程大大简化:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012135526.png" class="" title="image-20211012135526">

<p><strong>其中F是菲涅耳项(第9.5节)。注意,与菲涅耳上一半基于矢量的双向反射(使用半矢量之间的夹角h和l或者v),菲涅耳方程上式术语使用曲面法线之间的夹角n和反射向量r (n和v之间的角度是一样的)。</strong></p>
<p><strong>因为入射亮度Li 只依赖于方向，它可以存储在一个二维表中。这种表示使我们能够有效地用任意入射亮度分布的任何形状的镜面。我们计算每个点的r值，并在表中查找亮度。这个表被称为环境地图，由Blinn和Newell提出。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012135723.png" class="" title="image-20211012135723">

<p>反射的映射。查看器看到一个对象，反射视图向量r由v和n计算得到。反射视图向量访问环境的表示。通过使用一些投影仪函数来计算访问信息，将反射视图向量(x, y, z)转换为纹理坐标，用于检索环境的存储亮度。</p>
<p><strong>反射映射算法的步骤如下:</strong> </p>
<pre><code>**•生成或加载一个代表环境的纹理。**

**•对于每个包含反射物体的像素，计算物体表面位置的法线。**

**•从视图向量和法线计算反射视图向量。**

**•使用反射视图向量在环境地图中计算一个索引，该索引表示反射视图方向的入射亮度。**

**•使用环境地图中的texel数据作为上方程中的入射亮度。** 
</code></pre>
<p><strong>值得一提的是环境映射的一个潜在障碍。当使用环境映射时，平面通常不能很好地工作。一个平面的问题是，从它反射回来的光线变化通常不超过几度。这种紧密的集群导致环境表的一小部分被映射到一个相对较大的表面上。在第11.6.1节中讨论的同样使用辐射的位置信息的技术可以得到更好的结果。此外，如果我们假设表面是完全平坦的，例如地板，则可以使用平面反射的实时技术(第11.6.2节)。</strong></p>
<p><strong>用纹理数据照亮场景的想法也被称为基于图像的照明(IBL)，通常是通过相机捕捉360度全景、高动态范围的图像从真实场景中获得环境地图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012135936.png" class="" title="image-20211012135936">

<p>一个光(在相机)结合凹凸和环境映射。从左到右:没有环境映射，没有凹凸映射，没有相机上的光，三者结合起来。(图片生成自three.js示例webgl materials displacementmap，模型来自AMD GPU MeshMapper。)</p>
<p><strong>使用环境映射和法线映射特别有效，可以产生丰富的视觉效果。参见上图。这些特征的组合在历史上也很重要。颠簸环境映射的一种受限形式是在消费级图形硬件中首次使用依赖纹理读取(章节6.2)，这使得这种能力成为像素着色器的一部分。</strong></p>
<p><strong>有许多投影仪功能可以将反射的视图向量映射到一个或多个纹理中。我们在这里讨论更流行的映射，并指出每种映射的优点。</strong></p>
<h3 id="Latitude-Longitude-Mapping-经度映射"><a href="#Latitude-Longitude-Mapping-经度映射" class="headerlink" title="Latitude-Longitude Mapping 经度映射"></a>Latitude-Longitude Mapping 经度映射</h3><p><strong>1976年，Blinn和Newell开发了第一个环境映射算法。他们使用的地图是地球上常见的经纬度系统这就是为什么这种技术通常被称为纬度-经度映射或后期-长映射。他们的方案不像从外面看的地球仪，而是像夜空中星座的地图。就像地球仪上的信息可以被平铺成墨卡托或其他投影地图一样，空间中某个点周围的环境也可以被映射到纹理上。当一个反射视图矢量计算一个特定的表面位置，矢量转换为球坐标(ρ， φ)。这里的φ，相当于经度，从0到2π弧度变化，而ρ，相当于纬度，从0到π弧度变化。对(ρ， φ)由下式计算，其中r = (rx, ry, rz)是正规化的反射视图向量，+z向上:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012140309.png" class="" title="image-20211012140309">

<p><strong>有关atan2的描述，请参阅第8页。然后使用这些值访问环境地图，并检索在反射视图方向上看到的颜色。请注意经纬度映射与墨卡托投影不同。它保持纬度线之间的距离不变，而墨卡托在两极趋于无穷。</strong></p>
<p><strong>为了将球体展开成一个平面，某些扭曲总是必要的，特别是如果我们不允许多次切割，并且每个投影在保留面积、距离和局部角度之间都有自己的权衡。这种映射的一个问题是，信息的密度是不均匀的。从下图的顶部和底部的极端拉伸可以看出，靠近两极的区域接收到的texel要比靠近赤道的区域多得多。这种失真是有问题的，不仅因为它不能产生最有效的编码，而且当使用硬件纹理过滤时，它还会产生伪影，尤其是在两极奇点处。滤波核不跟随纹理的拉伸，从而有效地收缩纹理密度较高的区域。还要注意投影数学是简单的，它可能不是有效的，因为超越函数，如arccosine在GPUs上是昂贵的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012140431.png" class="" title="image-20211012140431">

<p>与传统的墨卡托投影相反，地球的纬度和经线等间距。(图片来自NASA的“蓝色大理石”系列。)</p>
<h3 id="Sphere-Mapping-球体映射"><a href="#Sphere-Mapping-球体映射" class="headerlink" title="Sphere Mapping 球体映射"></a>Sphere Mapping 球体映射</h3><p><strong>最初由Williams提出，由Miller和Hoffman独立开发，球体映射是第一种通用商业图形硬件支持的环境映射技术。纹理图像来自环境的外观，就像在一个完全反射的球体中以正投影的方式观察的那样，所以这个纹理被称为球体地图。制作真实环境的球体地图的一种方法是给发光的球体拍照，比如圣诞树装饰。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012140639.png" class="" title="image-20211012140639">

<p>球面映射(左)和经纬度格式的等效映射(右)。</p>
<p><strong>由此产生的圆形图像也被称为光探测器，因为它捕获了球体所在位置的照明情况。拍摄球形探头是一种有效的方法方法来捕获基于图像的光照，即使我们在运行时使用其他编码。我们总是可以在球面投影和另一种形式之间进行转换，例如后面讨论的立方体映射(章节10.4.3)，如果捕获有足够的分辨率来克服方法之间的失真差异。</strong></p>
<p><strong>一个反射球体仅仅在球体的前面显示整个环境。它将每个反射的视图方向映射到这个球体的二维图像上的一个点。假设我们想去另一个方向，给定球面地图上的一个点，我们想要反射视图的方向。为了做到这一点，我们将在球面上取那个点的表面法线，然后生成反射视图方向。因此，为了反转这个过程并从反射视图向量中获得球面上的位置，我们需要推导球面上的表面法线，这将产生访问球面映射所需的(u, v)参数。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012140757.png" class="" title="image-20211012140757">

<p>给定恒定的视图方向v和球面映射空间中的反射视图向量r，球面映射的法线n在两者之间。对于原点处的单位球，交点h与单位法线n有相同的坐标y (从原点测量)和球体贴图纹理坐标v(不要与视图向量v混淆)是相关的。</p>
<p><strong>球面法线是反射视图向量r和原始视图向量v之间的半角向量，在球面映射空间中为(0,0,1)。参见上图。这个法向量n是原始视图向量和反射视图向量的和，即(rx, ry, rz + 1)。 正规化这个向量得到单位法线:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012140912.png" class="" title="image-20211012140912">

<p><strong>如果球面在原点，半径为1，那么单位法线坐标也就是球面上法线的位置h。我们不需要hz, (hx,hy)描述球面图像上的一个点，每个值都在范围[−1,1]。要将这个坐标映射到范围[0,1)以访问球体映射，每一个都除以2，并加上一半:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012140953.png" class="" title="image-20211012140953">

<p><strong>与经纬度映射相比，球面映射计算起来要简单得多，并且显示了一个位于图像圆边缘的奇异点。缺点是球体贴图纹理捕获的环境视图只对单个视图方向有效。这个纹理确实捕获了整个环境，所以可以计算一个新的观察方向的纹理坐标。然而，这样做可能会导致视觉伪影，因为球体地图的一小部分由于新视图而被放大，边缘周围的奇异点变得明显。在实践中，球面地图通常被假定跟随摄像机，在视图空间中操作。</strong></p>
<p><strong>由于球面映射定义为一个固定的视图方向，原则上球面映射上的每个点不仅定义了一个反射方向，而且还定义了一个表面法线。参见上图。对于任意的各向同性BRDF，可以求解反射方程，并将其结果存储在球面映射中。这个BRDF可以包括漫反射、镜面反射、反反射和其他术语。只要照明和视图方向是固定的，球面地图就会是正确的。只要球体的BRDF是均匀且各向同性的，就可以使用在实际光照下的真实球体的摄影图像。</strong></p>
<p><strong>它也可以索引两个球面地图，一个是反射矢量，另一个是表面法线，以模拟高光和漫反射环境效果。如果我们调整存储在球体贴图中的值，以考虑表面材料的颜色和粗糙度，我们就有了一种廉价的技术，可以生成令人信服的(尽管与视图无关)材料效果。这种方法是通过雕刻软件Pixologic ZBrush作为“MatCap”着色来推广的。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141111.png" class="" title="image-20211012141111">

<p>“MatCap”渲染的例子。左边的对象使用右边的两个球面贴图进行着色。顶部的映射使用视图空间的法向量进行索引，而底部的映射使用视图空间的反射向量，并将两者的值相加。结果效果是相当令人信服的，但移动视点将揭示照明环境遵循相机的坐标框架。</p>
<h3 id="Cube-Mapping-立方体映射"><a href="#Cube-Mapping-立方体映射" class="headerlink" title="Cube Mapping 立方体映射"></a>Cube Mapping 立方体映射</h3><p><strong>1986年，Greene引入了立方体环境地图，通常称为立方体映射。这种方法是目前最流行的方法，它的投影直接在硬件上实现在现代GPUs上。立方体地图是通过将环境投影到立方体的侧面而创建的，立方体的中心位于摄像机的位置。立方体表面上的图像随后被用作环境地图。见下两图。立方体映射通常以“交叉”图的形式显示，即打开立方体并把它压平。然而，在硬件上，立方体映射被存储为6个方形纹理，而不是一个单一的矩形纹理，所以没有浪费空间。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141332.png" class="" title="image-20211012141332">

<p>插图格林的环境地图，并显示关键点。左边的立方体将展开到右边的环境地图中。</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141342.png" class="" title="image-20211012141342">

<p>与之前图中使用的环境地图相同，转换为立方体映射格式。</p>
<p><strong>有可能创建立方体地图综合渲染场景六次与相机在立方体的中心，看着每个立方体的面与90◦视图角度。参见下图。为了从真实环境中生成立方体地图，通常将通过拼接或专用摄像机获得的球形全景投影到立方体地图坐标系统中。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141506.png" class="" title="image-20211012141506">

<p>《极限竞速7》中的环境地图照明会随着汽车位置的改变而更新。(图片由微软Turn 10 Studios提供。)</p>
<p><strong>与球面映射不同，立方体环境映射与视图无关。它也比经纬度制图具有更均匀的采样特征，经纬度制图对两极进行采样，而不是赤道。Wan等人提出了一种称为等立方的映射，它比立方体映射的采样率差更低，同时仍然利用立方体映射纹理硬件来提高性能。</strong></p>
<p><strong>访问多维数据集映射很简单。任何向量都可以直接作为一个三分量的纹理坐标来获取它所指向的方向上的数据。所以，对于反射，我们可以把反射的视图向量r传递给GPU，甚至不需要标准化它。在较老的GPUs上，双线性过滤可以显示立方体边缘的接缝，因为纹理硬件无法正确地过滤不同的立方体面(这个操作执行起来有点昂贵)。为了避免这个问题，我们开发了一些技术，比如让视图投影更宽一些，这样单个面就可以包含这些相邻的像素。所有现代GPUs现在都可以正确地执行这种过滤，所以这些方法不再是必要的。</strong></p>
<h3 id="Other-Projections-其他预测"><a href="#Other-Projections-其他预测" class="headerlink" title="Other Projections 其他预测"></a>Other Projections 其他预测</h3><p><strong>如今，立方体地图是最受欢迎的环境照明表格表示法，因为它的通用性、再现高频细节的准确性以及在GPU上的执行速度。然而，还有一些其他的预测也值得一提。</strong></p>
<p><strong>Heidrich和Seidel提出使用两种纹理来执行双抛物面环境映射。这个想法就像球面映射，但不是通过记录环境在球面上的反射来生成纹理，而是使用了两个抛物线投影。每个抛物面创建一个类似于球体地图的圆形纹理，每个都覆盖一个环境半球。</strong></p>
<p><strong>与球面映射一样，反射视图射线是在地图的基础上计算的，即在其参照系中。反射视图向量的z分量符号用来决定访问两个纹理中的哪个。访问函数是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141813.png" class="" title="image-20211012141813">

<p><strong>对于前面的图像，同样的，r的符号倒转z，用于背面图像。</strong></p>
<p><strong>与球体地图甚至立方体地图相比，抛物线地图具有更均匀的环境纹理采样。然而，必须注意在两个投影之间的接缝处进行适当的采样和插值，这使得访问双抛物面映射更加昂贵。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141855.png" class="" title="image-20211012141855">

<p>球体的立方体映射展开(左)与八面体展开(右)比较。(以尼米兹的Shadertoy命名。)</p>
<p><strong>八面体映射是另一个值得注意的投影。它不是将周围的球体映射到一个立方体，而是映射到一个八面体(参见上图)。为了把这个几何形状变平，它的八个三角形面被切割并安排在一个平面上。正方形或矩形结构都是可能的。如果我们使用正方形结构，访问八面体映射的数学方法是非常有效的。给定一个反射方向r，我们用L1 绝对值规范:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012141958.png" class="" title="image-20211012141958">

<p><strong>对于r′y 是正的，我们可以用</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012142007.png" class="" title="image-20211012142007">

<p><strong>在r′y 为负时，我们需要用变换将八面体的后半部分向外“折叠”</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012142017.png" class="" title="image-20211012142017">

<p><strong>八面体映射不受对偶抛物面映射的过滤问题的影响，因为参数化的接缝与使用的纹理的边缘相对应。纹理“环绕”采样模式可以自动从另一边访问texels，并执行正确的插值。虽然用于投影的数学方法稍微复杂一些，但在实践中表现得更好。引入的失真量与立方体映射相似，所以当立方体映射纹理硬件不存在时，八面体映射是一个很好的选择。另一个值得注意的用途是仅使用两个坐标表示三维方向(标准化向量)，作为压缩的平均值(第16.6节)。</strong></p>
<p><strong>对于围绕对称轴径向对称的环境地图的特殊情况，Stone提出了一种简单的分解方法，使用单一的一维纹理存储从对称轴出发的任何子午线上的亮度值。他将这个方案扩展到二维纹理，在每一行存储一个环境地图，用不同的Phong瓣预卷积。这种编码可以模拟多种材料，并被用于编码从晴朗的天空发射的辐射。</strong></p>
<h2 id="Specular-Image-Based-Lighting-基于图像的镜面光照"><a href="#Specular-Image-Based-Lighting-基于图像的镜面光照" class="headerlink" title="Specular Image-Based Lighting 基于图像的镜面光照"></a>Specular Image-Based Lighting 基于图像的镜面光照</h2><p><strong>虽然环境映射最初是作为一种绘制镜面表面的技术开发的，但它也可以扩展到光滑的反射。当用于模拟无限远光源的一般镜面效果时，环境地图也被称为镜面光探测器。之所以使用这个术语，是因为它们在场景中给定的点捕捉到来自各个方向的辐亮度(从而探测)，并利用这些信息来评估一般BRDFs——而不仅仅是局限于纯镜子或朗伯曲面的情况。高光立方体贴图的名字也用于存储环境照明的立方体贴图，这些立方体贴图被操纵来模拟在光滑材料上的反射。</strong></p>
<p><strong>为了模拟表面粗糙度，可以对纹理中的环境表示进行预过滤。通过模糊环境贴图纹理，我们可以呈现一个镜面反射，看起来比完美的镜面反射更粗糙。这种模糊应以非线性的方式进行，即不同部位的纹理应该有不同的模糊。这种调整是必要的，因为环境贴图纹理表示具有到理想球面空间方向的非线性映射。两个相邻像素中心之间的角距离不是恒定的，单个像素所覆盖的立体角也不是恒定的。预处理立方体地图的专门工具，如AMD的CubeMapGen(现在是开源的)，在过滤时会考虑这些因素。来自其他人脸的邻近样本被用来创建mipmap链，并且每个texel的角度范围被考虑在内。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012142244.png" class="" title="image-20211012142244">

<p>在顶部，原始的环境地图(左)和着色结果应用于一个球体(右)。在底部，使用高斯核模糊相同的环境地图模拟粗糙材质的外观。</p>
<p><strong>模糊的环境地图，虽然经验接近粗糙表面的外观，与实际的BRDF没有联系。一个更有原则的方法是当考虑给定的表面法线和视图方向时，考虑BRDF函数在球体上的形状。然后我们使用这个分布来筛选环境映射。参见下图。用镜面波瓣对环境地图进行过滤不是简单的，因为BRDF可以假设任何形状，这取决于它的粗糙度参数以及视图和法向量。至少有五个维度的输入值(粗糙度和两个极角的视图和法线方向)来控制得到的瓣形状。为其中的每个选择存储多个环境映射是不可行的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012142331.png" class="" title="image-20211012142331">

<p>左图显示了从一个对象反射的眼球光线，以从一个环境纹理(在本例中是一个立方体映射)获得一个完美的镜面反射。右图显示了反射视图射线的镜面波瓣，它被用来采样环境纹理。绿色的正方形代表立方体地图的横截面，红色的勾号表示像素之间的边界。</p>
<h3 id="Prefiltered-Environment-Mapping-预过滤环境映射"><a href="#Prefiltered-Environment-Mapping-预过滤环境映射" class="headerlink" title="Prefiltered Environment Mapping 预过滤环境映射"></a>Prefiltered Environment Mapping 预过滤环境映射</h3><p><strong>应用于光滑材料的环境照明的预过滤的实际实现需要近似BRDF使用，从而产生纹理独立于视图和法向量。如果我们限制BRDF的形状变化仅为材料光泽度，我们可以计算和存储一些环境地图对应的不同选择的粗糙度参数，并选择一个合适的在运行时使用。在实践中，这意味着限制我们使用的模糊核，从而使瓣形状围绕反射向量径向对称。</strong></p>
<p><strong>想象一些光线从一个给定的反射视图方向射入。直接来自反射视图方向的光将提供最大的贡献，随着入射光的方向与反射视图方向的差异越来越大而衰减。环境地图texel的面积乘以texel的BRDF贡献给出了这个texel的相对效果。这个加权贡献乘以环境地图texel的颜色，并将结果相加，计算q。加权贡献的总和，也计算s。最终的结果，q/s，是在反射视图方向的波瓣上集成的整体颜色，并存储在生成的反射映射中。</strong></p>
<p><strong>如果我们使用Phong材料模型，径向对称假设自然成立，我们可以几乎准确地计算环境照明。Phong通过经验推导出了他的模型，与我们在9.8节中看到的BRDFs相比，没有物理动机。冯氏的模型和Blinn-Phong双向9.8.1正余弦叶节中我们讨论了提高力量,但在冯氏着色的情况下,cos是由反射的点积向量方程(9.15)和视图,而不是一半的向量方程(见9.33)和正常的。这使得反射波瓣是旋转对称的。请参见第338页图9.35。</strong></p>
<p><strong>有一个径向对称的镜面波瓣，这是我们唯一还不能理解的效果适应，因为它使瓣形状依赖于视图方向，是水平剪切。想想看一个闪亮的球体(不是镜面)。观察球体表面的中心，会得到一个对称的峰瓣。观察附近的表面球体的轮廓在现实中必须被切掉一部分，因为地平线以下的光线无法照射到眼睛。参见下图。这与我们之前讨论区域照明近似时(第10.1节)看到的问题相同，但在实践中，实时方法经常忽略它。这样做会导致过度明亮的着色在掠角。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012144914.png" class="" title="image-20211012144914">

<p>两个观察者看到一个闪亮的球体。球体上的不同位置为两个观察者提供相同的反射视图方向。左侧观察者的表面反射采样一个对称瓣。右方观察者的反射波瓣必须被表面本身的视界切掉，因为光线不能从视界以下的表面反射出去。</p>
<p><strong>Heidrich和Seidel以这种方式使用单个反射映射来模拟表面的模糊。为了适应不同的粗糙度水平，通常使用环境立方体地图的mipmaps(章节6.2.2)。每一级用于存储入射亮度的模糊版本，较高的mip级存储粗糙的表面，即更宽的Phong叶。在运行时，我们可以通过使用反射向量来处理立方体映射，并根据期望的Phong指数(材料粗糙度)强制选择给定的mip水平。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012145014.png" class="" title="image-20211012145014">

<p>环境地图前置过滤。将立方体映射与不同粗糙度的GGX叶进行卷积，并将卷积结果存储在纹理mip链中。随着粗糙度从左到右的减少，最终的纹理mips显示在底部，一个球体被渲染在上面以反射矢量的方向访问它们。</p>
<p><strong>粗糙材料使用的更宽的过滤区域可以去除高频，因此需要更低的分辨率才能得到充分的结果，这与mipmap结构完美地对应。此外，通过使用GPU硬件的三线性滤波，可以在预滤波的mip水平之间进行采样，模拟我们没有确切表示的粗糙度值。当与菲涅耳术语结合在一起时，这种反射映射对光滑表面似乎很有效。</strong></p>
<p><strong>出于性能和走样的原因，选择要使用的mipmap级别不仅要考虑着色点的材质粗糙度，还要考虑被着色像素覆盖的表面面积上的法线和粗糙度的变化。Ashikhmin Ghosh指出,为达到最佳效果,两个候选人产生的指数水平(缩小级别计算纹理硬件和对应于当前过滤器宽度)应该相比,和应该使用低分辨率产生水平指数。为了更加准确，应该考虑表面方差的扩大效应，并使用一个新的粗糙度水平，对应于一个BRDF瓣，该瓣在像素足迹中最适合的平均值，应该使用。这个问题与BRDF抗锯齿(章节9.13.1)完全相同，也适用相同的解决方案。</strong></p>
<p><strong>前面提出的滤波方案假设在给定的反射视图方向上的所有瓣都是相同的形状和高度。这个假设也意味着叶瓣必须是径向对称的。除了视界上的问题，大多数BRDFs在所有角度上都没有均匀的径向对称瓣。例如，在掠角时，叶片往往会变得更尖锐和更薄。此外，叶的长度通常随仰角而变化</strong></p>
<p><strong>这种效果对于曲面通常是看不出来的。然而，对于像地板这样的平面，径向对称滤波器可能会引入明显的误差。(参见第338页的图9.35)</strong></p>
<h4 id="Convolving-the-Environment-Map-卷积环境地图"><a href="#Convolving-the-Environment-Map-卷积环境地图" class="headerlink" title="Convolving the Environment Map 卷积环境地图"></a>Convolving the Environment Map 卷积环境地图</h4><p><strong>生成预过滤的环境地图意味着计算每一个texel，对应一个方向v，环境辐射与镜面的积分lobe D:</strong> </p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012145352.png" class="" title="image-20211012145352">

<p><strong>这个积分是一个球面卷积，通常不能用解析的方法来执行，如Li，对于环境地图，仅以表格形式知道。一种流行的数值解是采用蒙特卡罗方法:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012145400.png" class="" title="image-20211012145400">

<p><strong>其中lk 对于k = 1,2，…， N为单位球(方向)上的离散样本， 和p(lk， v)是在lk方向上生成样本的概率函数．如果我们对球均匀采样，那么p(lk， v)总是= 1。虽然这个总和对于我们想要积分的每个方向v都是正确的，但在将结果存储到环境地图中时，我们还必须考虑到投影带来的失真，通过对每个计算texel所对应的立体角进行加权(参见Driscoll)。</strong></p>
<p><strong>虽然蒙特卡罗方法简单正确，但它可能需要大量的样本才能收敛到积分的数值，即使是离线过程也会很慢。这种情况在mipmap的第一级尤其明显，在这里我们编码浅镜面叶(Blinn-Phong为高指数，Cook-Torrance为低粗糙度)。我们不仅需要计算更多的像素(因为我们需要存储高频细节的分辨率)，而且对于不接近完美反射的方向，波瓣可能接近于零。大多数样本都被“浪费”了，就像D(lk，v)≈0。</strong></p>
<p><strong>为了避免这种现象，我们可以使用重要采样，我们用概率分布生成方向，试图匹配镜面瓣的形状。这样做是蒙特卡罗积分的一种常见的方差减少技术，重要度抽样策略存在于最常用的叶型中。为了更有效的采样方案，还可以结合镜面瓣的形状来考虑环境图中辐射度的分布。然而，所有依赖于点采样的技术通常只用于离线渲染和地面真实模拟，因为通常需要数百个样本。</strong></p>
<p><strong>为了进一步减小采样方差(即我们也可以估计样本之间的距离和积分使用锥的和，而不是单一的方向。使用锥体对环境地图进行采样可以通过对其mip水平之一进行点采样来近似，选择其像素大小跨越与锥体相似的立体角的水平。这样做会引入偏差，但它允许我们大大减少实现无噪声结果所需的样本数量。这种类型的采样可以在GPU的帮助下以交互速率进行。</strong></p>
<p><strong>同样利用区域样本，McGuire等人开发了一种技术，旨在实时逼近与镜面波瓣的卷积结果，而不需要任何预计算。这个过程是通过明智地混合非预过滤环境立方体映射的多个mipmap级别来实现的，以重建Phong瓣的形状。类似地，Hensley等人使用求和面积表(章节6.2.2)来快速进行近似。McGuire et al.和Hensley et al.的技术在技术上都不是没有任何预计算的，因为在渲染一个环境地图之后，他们仍然需要我们分别生成mip级别或前缀和。对于这两种情况，都存在有效的算法，因此所需的预计算要比执行全镜面波瓣卷积快得多。这两种技术都足够快，甚至可以实时用于环境照明的表面着色，但它们不如其他依赖于临时预滤波的方法准确。</strong></p>
<p><strong>Kautz等人提出了另一种变体，一种快速生成滤波抛物面反射图的分层技术。最近，Manson和Sloan使用一种有效的二次B样条滤波方案来生成环境地图的mip水平，显著改进了这一技术。这些经过特别计算的B样条滤波的mips然后通过结合少量样本使用，类似于McGuire等人和Kautz等人的技术，以产生快速而准确的近似。这样做可以生成实时的结果，这些结果与通过重要性采样蒙特卡罗技术计算的地面真实值难以区分。</strong></p>
<p><strong>快速卷积技术允许实时更新预过滤的立方体映射，当我们想要过滤的环境映射被动态渲染时，这是必要的。使用环境地图通常会让物体在不同的光照环境中移动变得困难，例如，从一个房间到另一个房间。立方环境贴图可以在帧与帧之间动态生成(或每隔几帧生成一次)，所以如果采用有效的滤波方案，交换新的镜面反射贴图是相对便宜的。</strong></p>
<p><strong>另一种替代方法是重新生成完整的环境贴图，将动态光源的高光添加到静态的基础环境贴图上。添加的高光可以被添加到预过滤的基础环境地图上的预过滤“斑点”。这样做可以避免在运行时进行任何过滤。限制是由于环境映射的假设，光线和反射的物体是遥远的，因此不会随观察物体的位置而改变。这些要求意味着当地的光源不容易使用。</strong></p>
<p><strong>如果几何图形是静态的，但是一些光源(如太阳)移动了，一种不需要在立方体地图中动态渲染场景的更新探针的廉价技术是在G缓冲环境地图中存储表面属性(位置、法线、材质)。G -buffer将在第20.1节中详细讨论。然后我们使用这些属性在环境地图中计算表面的辐射亮度。《使命召唤:无限战争》、《巫师3》]和《孤岛惊魂4》等游戏都使用了这种技术。</strong></p>
<h3 id="Split-Integral-Approximation-for-Microfacet-BRDFs-微表面BRDFs的分裂积分近似"><a href="#Split-Integral-Approximation-for-Microfacet-BRDFs-微表面BRDFs的分裂积分近似" class="headerlink" title="Split-Integral Approximation for Microfacet BRDFs 微表面BRDFs的分裂积分近似"></a>Split-Integral Approximation for Microfacet BRDFs 微表面BRDFs的分裂积分近似</h3><p><strong>环境照明的用处是如此之大，以至于许多技术已经发展起来，以减少立方体映射预滤波中固有的BRDF近似问题。</strong></p>
<p><strong>到目前为止，我们已经描述了通过假设Phong波瓣，然后乘上完美镜菲涅耳项来工作的近似:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012150127.png" class="" title="image-20211012150127">

<p><strong>其中∫ΩDPhong(r) 是使用每一个r到环境立方体映射,如果我们考虑使用在337页方程9.34的镜面微表面 BRDF fsmf，得到简单的替换</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012150610.png" class="" title="image-20211012150610">

<p><strong>我们注意到，即使假设D(h)≈DPhong(r)是有效的，我们正在从照明积分中移除BRDF的重要部分。阴影项G₂(l, v, h)和半向量菲涅耳项F(h, l)在积分之外的应用没有理论基础。Lazarov表明，使用依赖于n·v的完美镜菲涅尔，而不是微表面 BRDF中的n·h，比完全不使用菲涅尔项产生更大的误差。Gotanda ， Lazarov， Karis分别推导出了类似的分裂积分近似:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012150716.png" class="" title="image-20211012150716">

<p><strong>注意，即使这个解通常被称为“分裂积分”，我们也没有将积分分解成两个不相交的项，因为这不是一个很好的近似。记住,fsmf 包括镜面波瓣D，我们注意到后者和n·l项都被复制到两边。在分裂积分近似中，我们在两个积分中都包含了环境映射中围绕反射向量对称的所有项。Karis称他的推导为分裂和，因为它是在他在预计算中使用的重要性采样数值积分器(上上上上方程)上完成的，但实际上它是相同的解。</strong></p>
<p><strong>由此得到的两个积分都可以有效地预先计算。第一种取决于表面粗糙度和反射矢量，假设是径向对称的D瓣。在实践中，我们可以使用任意的波瓣，使n = v = r。这个积分可以像往常一样预先计算并存储在立方体映射的mip层中。当将半矢量BRDFs转换为反射矢量周围的瓣时，为了在环境光和分析光之间获得类似的高光，径向对称瓣应该使用修改的粗糙度。例如，要将纯基于phong的反射矢量反射项转换为使用半角的Blinn-Phong BRDF，可以将指数除以4获得良好的拟合。</strong></p>
<p><strong>第二个积分是镜面项Rspec(v)的半球定向反射率(第9.3节), Rspec 函数取决于仰角θ、粗糙度α和菲涅耳项F。通常F是使用Schlick近似(9.16式)实现的，该近似仅对单个值F0进行参数化，从而使Rspec 一个有三个参数的函数。Gotanda预计算Rspec 在数值上，将结果存储在一个三维查找表中。Karis和Lazarov注意到F0 可以从Rspec中分解出来，导致两个因素，每个因素取决于两个参数:仰角和粗糙度。Karis使用这种洞察力来减少对Rspec的预计算查找到一个二维表格，可以存储在一个双通道纹理中，而Lazarov通过函数拟合得出两个因素的解析近似。一个更精确和更简单的解析近似后来由Iwanicki和Pesce推导出来。请注意,Rspec 也可用于提高漫反射BRDF模型的精度(见第352页公式9.65)。如果这两种技术是在同一个应用程序中实现的，那么Rspec 两者都可以使用，提高效率。</strong></p>
<p><strong>对于常数环境映射，分裂积分解是精确的。立方体映射部分提供了与镜面反射率成比例的光照强度，这是均匀光照下正确的BRDF积分。Karis和Lazarov都从经验上观察到，这种近似也适用于一般的环境地图，特别是在频率含量相对较低的情况下，这在户外场景中并不少见。参见下图。与地面真实值相比，这种技术的最大误差来源是对预过滤环境立方体图的径向对称、非裁剪镜面瓣的限制(上上图)。拉加德建议根据表面粗糙度，将用于获取预过滤环境地图的矢量从反射方向倾斜到法线方向，因为从经验上讲，这减少了与地面真实相比较的误差。这样做是合理的，因为它部分地补偿了不与表面的入射辐亮度半球裁剪瓣。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012151014.png" class="" title="image-20211012151014">

<p>Karis“分裂和”近似。从左到右:材质粗糙度增加。第一行:引用解决方案。第二行:分裂积分近似。第三行:将需要的径向对称的分裂积分加到镜面波瓣(n = v = r)。这最后一项要求是引入误差最多的。(图片来源:Epic Games Inc.， Brian Karis)</p>
<h3 id="Asymmetric-and-Anisotropic-Lobes-非对称各向异性叶"><a href="#Asymmetric-and-Anisotropic-Lobes-非对称各向异性叶" class="headerlink" title="Asymmetric and Anisotropic Lobes 非对称各向异性叶"></a>Asymmetric and Anisotropic Lobes 非对称各向异性叶</h3><p><strong>到目前为止，我们看到的解决方案都局限于各向同性的镜面瓣，这意味着当入射和出射方向围绕表面法线旋转时(第9.3节)，它们不会改变，并且径向对称反射向量。微表面 BRDF瓣是围绕半矢量h = (l+v)/||l+v||定义的(9.33式)，因此即使在各向同性的情况下也不具有我们需要的对称性。半矢量取决于光的方向l，对于环境照明来说，它不是唯一定义的。因此，在Karis之后，对于这些BRDFs，我们施加n = v = r，并推导出一个恒定的粗糙度校正因子，以匹配镜面高光的大小，以原始的半矢量公式。这些假设都是相当大的误差来源(见下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211012151325.png" class="" title="image-20211012151325">

<p>比较GGX BRDF(红色)和GGX NDF瓣的两幅图，该瓣适合于围绕反射向量径向对称(绿色)。后者已经被缩放以匹配GGX镜面瓣的峰值，但请注意它如何不能捕获基于半矢量的BRDF的各向异性形状。在右边，注意两个脑叶在球体上形成的高光的不同。(图片使用迪士尼的开源软件BRDF Explorer生成。)</p>
<p><strong>我们在第10.5.1节中提到的一些方法可以用于计算具有任意BRDFs的交互速率环境照明，如Luksch等人和Colbert和Kˇriv´anek的方法。然而，由于这些方法需要几十个样本，很少用于表面的实时着色。它们可以被看作是蒙特卡罗积分的快速重要采样技术。</strong></p>
<p><strong>与预滤器环境地图创建的镜面叶施加径向对称,和访问预滤器叶的简单直接的逻辑对应于当前的镜面表面粗糙度,结果只在观看时保证是正确的连续表面(n = v)。在所有其他情况下没有这样的保证,并在放牧的角度我们承担错误不管双向叶的形状,因为我们忽略了真正的叶瓣不能下沉到阴影表面点的地平线以下。一般来说，在镜面反射的准确方向上的数据可能不是与现实的最佳匹配。</strong></p>
<p><strong>Kautz和McCool通过使用存储在预过滤环境图中的径向对称叶的更好的采样方案改进了朴素的预积分。他们提出了两种方法。第一种方法使用单个样本，但试图找到最好的来近似当前视场方向上的BRDF，而不是依赖一个恒定的校正因子。第二种方法是对来自不同叶的几个样本进行平均。第一种方法较好地模拟了掠射角度下的曲面。他们还推导了一个校正因子，以解释使用径向对称瓣近似与原始BRDF相比反射的总能量的差异。第二个解决方案扩展了结果，包括典型的半矢量模型的拉伸亮点。在这两种情况下，都使用优化技术来计算驱动预滤叶采样的参数表。Kautz和McCool的技术使用了贪婪拟合算法和抛物线环境地图。</strong></p>
<p><strong>最近，Iwanicki和Pesce使用一种称为Nelder-Mead最小化的方法，推导出了GGX BRDFs和环境立方体映射的类似近似。他们还分析了利用现代图形处理器的硬件各向异性滤波能力来加速采样的想法。</strong></p>
<p><strong>Revie还探索了使用预过滤的立方体映射的单个样本，但将其位置调整到更复杂的高光BRDF的峰值的想法，用于结合延迟着色的毛皮渲染(第20.1节)。在这种情况下，限制不是直接来自环境映射，而是需要在g缓冲区中编码尽可能少的参数。McAuley扩展了这一思想，将此技术用于延迟渲染系统中的所有表面。</strong></p>
<p><strong>McAllister等人开发了一种技术，通过利用拉福BRDF的特性，可以绘制各种效应，包括各向异性和反反射。这个BRDF本身就是一个基于物理的渲染的近似。它由多个Phong瓣组成，在反射方向周围受到扰动。Lafortune通过将这些叶拟合到He-Torrance模型和通过角反射仪测量真实材料，证明了这种BRDF表示复杂材料的能力。McAllister的技术依赖于注意到，由于Lafortune叶是广义的Phong叶，可以使用传统的预过滤环境图，其mips编码不同的Phong指数。Green等人提出了一种类似的方法，使用高斯瓣代替Phong瓣。此外，他们的方法可以扩展为支持环境地图的方向阴影(章节11.4)。</strong></p>
<h2 id="Irradiance-Environment-Mapping-辐射度量环境映射"><a href="#Irradiance-Environment-Mapping-辐射度量环境映射" class="headerlink" title="Irradiance Environment Mapping 辐射度量环境映射"></a>Irradiance Environment Mapping 辐射度量环境映射</h2><p><strong>上一节讨论了使用过滤环境贴图进行镜面反射。这些地图也可以用于漫反射。镜面反射的环境贴图有一些共同的属性，无论它们是用于镜面反射的未过滤的，还是用于光滑反射的过滤的。在这两种情况下，镜面环境地图都是用反射视图向量索引的，并且它们包含了辐亮度值。未过滤的环境地图包含传入的辐亮度值，而过滤的环境地图包含传出的辐亮度值。</strong></p>
<p><strong>相反，漫反射的环境映射仅用表面法线n索引，并且包含辐照度值。因此，它们被称为辐照度环境图。上图10.35显示了带有环境贴图的光滑反射在某些条件下由于其固有的模糊性而存在错误。相同的反射视图向量可能对应不同的反射情况。这个问题不会发生在辐照度环境贴图上。表面法线包含了漫反射的所有相关信息。由于辐照度环境图与原始照度相比是非常模糊的，它们可以以明显较低的分辨率存储。通常使用预过滤镜面环境图的最低mip级之一来存储辐照度数据。此外，与我们之前研究的光滑反射不同，我们没有对BRDF瓣积分，该瓣需要被剪切到表面法线周围的半球。环境光照与夹持余弦瓣的卷积是精确的，而不是近似的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013114149.png" class="" title="image-20211013114149">

<p>计算辐照度环境图。围绕表面法线的余弦加权半球从环境纹理(在本例中是一个立方体贴图)采样，并对其进行求和，以获得与视图无关的辐照度。绿色的正方形代表立方体地图的横截面，红色的勾号表示像素之间的边界。虽然显示了多维数据集映射表示，但可以使用任何环境表示。</p>
<p><strong>对于地图中的每个texel，我们需要总结所有影响给定法线方向表面的照明的余弦加权贡献。辐照度环境地图是通过应用深远的过滤器创建的，覆盖整个可见半球，原始环境地图。滤波器包括余弦因子。参见上图。408页图10.26中的球面图有一个相应的照度图，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013114332.png" class="" title="image-20211013114332">

<p>光照图由格雷斯大教堂球体图组成。左边的图是原始的球面图。右图是将半球上每个像素上的加权颜色相加形成的。(左图由保罗·德贝维奇提供，debevec.org;右图由斯坦福大学计算机图形实验室的Ravi ramamoori提供。)</p>
<p><strong>下图给出了使用中的辐照度图的一个例子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013114407.png" class="" title="image-20211013114407">

<p>使用辐照度贴图进行角色照明。(图片由Tecmo, Ltd. 2001游戏“Dead or Alive R 3”提供)</p>
<p><strong>辐照度环境映射与镜面环境或反射映射是分开存储和访问的，通常是一个视图独立的表示，如立方体映射。参见下图。而不是反射的视图向量，表面法线用于访问立方体映射来检索辐照度。从辐照度环境图中检索到的值乘以漫反射，从镜面环境图中检索到的值乘以镜面反射率。菲涅尔效应也可以建模，即在掠射角度增加镜面反射(可能降低漫反射)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013114539.png" class="" title="image-20211013114539">

<p>一个立方体映射(左)和它相应的过滤的辐照度映射(右)。(经微软公司许可转载)</p>
<p><strong>由于辐照度环境图使用非常宽的过滤器，很难通过采样有效地在飞行中创建它们。King讨论了如何在GPU上执行卷积来创建辐照度贴图。他能够在2004年的硬件上，通过将环境映射转换到频域，以超过300 FPS的速率生成辐照度映射。</strong></p>
<p><strong>漫反射或粗糙表面的过滤环境地图可以以低分辨率存储，但有时也可以由场景中相对较小的反射地图生成，例如64 × 64像素的立方体地图面。这种方法的一个问题是，一个区域光源渲染成如此小的纹理可能会“落在像素之间”，导致光闪烁或完全消失。为了避免这个问题，Wiley和Scheuermann建议在渲染动态环境地图时，用大型“卡片”(有纹理的矩形)来表示这些光源。</strong></p>
<p><strong>就像在光滑反射的情况下，动态光源也可以添加到预过滤的辐照度环境地图。Brennan给出了一种便宜的方法。想象一个单一光源的辐照度图。在光的方向上，亮度是最大的，因为光直接击中表面。给定表面法线方向的亮度。(一个给定的texel)随着角度对光线的余弦值下降，当表面背向光线时为零。GPU可以通过绘制一个半球来快速地将这个贡献直接添加到现有的辐照度图中，该半球代表余弦瓣，以观察者为中心，半球的极点沿着光线的方向。</strong></p>
<h3 id="Spherical-Harmonics-Irradiance-球面谐波辐照度"><a href="#Spherical-Harmonics-Irradiance-球面谐波辐照度" class="headerlink" title="Spherical Harmonics Irradiance 球面谐波辐照度"></a>Spherical Harmonics Irradiance 球面谐波辐照度</h3><p><strong>虽然我们已经讨论过只用纹理(如立方体贴图)来表示辐照度环境贴图，但是其他的表示也可以，如10.3节所述。球谐尤其作为一种辐照度环境地图表示非常流行，因为环境照明的辐照度是平滑的。用余弦瓣对辐射进行卷积可以去除环境地图中所有的高频成分。</strong></p>
<p><strong>Ramamoori和Hanrahan指出，仅仅用前9个SH系数(每一个都是SH系数)就能以约1%的精度表示辐照度环境图系数是RGB向量，所以我们需要存储27个浮点数)。任何辐照度环境图都可以被解释为一个球函数E(n)，并使用公式10.21和10.23投影到9个RGB系数上。这种形式比三次或抛物线映射更紧凑，在渲染期间，可以通过计算一些简单的多项式来重建辐照度，而不是访问纹理。通常，如果辐照度环境图代表间接照明，则需要较低的精度，这在交互式应用中是一种常见情况。在这种情况下，对于常数基函数和三个线性基函数，四个系数往往可以产生良好的结果，因为间接光照的频率往往较低，即随着角度的变化缓慢。</strong></p>
<p><strong>Ramamoori和Hanrahan还表明，入射辐亮度函数L(l)的SH系数可以通过每个系数乘以一个常数转化为辐照度函数E(n)的系数。这样做产生了一个快速的方法来过滤环境映射到辐照环境映射，即将它们投影到SH基中，然后将每个系数乘以一个常数。例如，King实现的快速辐照度滤波就是这样工作的。其思想是，通过辐射计算辐照度相当于在入射辐射度函数L(l)和夹持余弦函数cos(θi）+之间进行球面卷积．由于夹持余弦函数是围绕球的z轴旋转对称的，它在SH中有一种特殊形式:它的投影在每个频带中只有一个非零系数。非零系数对应于图10.21中中心列的基函数(401页)，它们也被称为区域谐波。</strong></p>
<p><strong>在一个普通球面函数和一个旋转对称函数(如夹紧余弦函数)之间执行一个球面卷积的结果是球面上的另一个函数。这种卷积可以有效地在函数的SH系数上进行。卷积结果的SH系数相等 p 两个函数系数的乘积，按比例乘以√4π/(2l + 1)，其中l是频带指数。于是，辐照度函数E(n)的SH系数等于辐照度函数L(l)的系数乘以夹持余弦函数cos(θi）+的系数，乘以频带常数。cos (θi）+的系数超过前9个系数的值很小，这解释了为什么九个系数足以表示辐照度函数E(n)。用这种方法可以快速地评估SH辐照度环境图。Sloan描述了一种高效的GPU实现。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013115343.png" class="" title="image-20211013115343">

<p>夹持余弦函数(红色)与它的九系数球谐近似(蓝色)。近似是相当接近的。注意π/2和π之间的下移和上移。</p>
<p><strong>这里有一个固有的近似，因为尽管E(n)的高阶系数很小，但它们不是零。参见上图。虽然π/2和π之间曲线的“摆动”在信号处理中被称为振铃，但这个近似非常接近。它通常发生在高频函数用少量基函数逼近时，如10.3.2节所示。π/2处的钳位为零是一个急剧的变化，这意味着钳位余弦函数有一个无限频率的信号。在大多数情况下，铃声是不明显的，但它可以看到在极端光照条件下的颜色转移或物体阴影侧面的明亮“斑点”。如果辐照度环境图只用于存储间接照明(经常发生)，那么铃声不太可能是一个问题。有一些预过滤方法可以最小化这个问题。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013115513.png" class="" title="image-20211013115513">

<p>左:由振铃引起的视觉伪影的例子。正确:一个可能的解决方案是使原始功能更平滑，这样它就可以在没有铃声的情况下表示，这个过程叫做“窗口化”。(图片由Peter-Pike Sloan提供。)</p>
<p><strong>图10.40显示了直接得到的照度图与由九项函数合成的照度图的比较。这种SH表示可以在使用当前表面法线n进行渲染时进行评估，也可以用于快速创建一个立方体或抛物线图供以后使用。这种照明是廉价的，并提供了良好的视觉效果漫反射情况。</strong></p>
<p><strong>动态渲染的立方体环境地图可以投影到SH基础上。由于立方环境地图是入射辐亮度函数的离散表示，方程10.21中球面上的积分将成为立方地图texels的总和:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013115601.png" class="" title="image-20211013115601">

<p><strong>其中t是当前立方体贴图贴图texel的索引，r[t]是指向当前贴图贴图贴图texel的方向向量，fj (r[t])为r[t]处的第j个SH基函数，L[t]为存储在texel中的亮度，dω[t]为texel所面对的立体角。Kautz， King和Sloan描述了如何计算dω[t]。</strong></p>
<p><strong>转换辐射系数kLj 在辐照度系数中，需要乘以固定余弦函数cos(θi）+的比例系数：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013115612.png" class="" title="image-20211013115612">

<p><strong>其中kEj 是辐照度函数E(n)的第j个系数，kLj 是入射亮度函数L(l)的第j个系数，k′cos+j 为夹持余弦函数cos(θi) +按√4π/(2l + 1)缩放后的第j个系数(l为频带指数)。</strong></p>
<p><strong>给定t和立方体映射分辨率，对于每个基函数fj (），因子k’ cos +j fj (r[t])dω[t]是常数．这些基本因素可以离线预计算并存储在多维数据集映射中，多维数据集映射的分辨率应该与将要呈现的动态环境映射相同。使用的纹理数量可以通过在每个颜色通道中打包一个单独的基础因子来减少。为计算动态立方体映射的辐照度系数，将适当的基因子映射的像素与动态立方体映射的像素相乘，并对结果进行总结。除了动态辐照度立方体映射的信息，King还提供了GPU SH投影的实现细节。</strong></p>
<p><strong>动态光源可以添加到现有的SH辐照度环境地图中。这个合并是通过计算光的辐照度贡献的SH系数，并将它们加入到现有的系数中来完成的。这样做可以避免重新计算整个辐照度环境图。这是一个简单的过程，因为点、盘和球面光的系数存在简单的解析表达式。把系数加起来和把辐照度加起来有同样的效果。对于与z轴对齐的光来说，通常这些表示是在区域谐波中给出的，然后可以应用旋转来将光定位到任意方向。区域谐波旋转是SH旋转的一种特殊情况(章节10.3.2)，它更有效，只需要一个点积而不需要一个完整的矩阵变换。对于形状更复杂的光源，可以通过将其绘制成图像来计算系数，然后将图像数值投影到SH基础上。对于物理天空模型的特殊情况，Habel显示了Preetham天窗在球面谐波中的直接扩展。</strong></p>
<p><strong>常见的分析光源投射到SH中是很重要的，因为通常环境照明被用来代替远处或较弱的光源。补光灯是一个重要的例子。在渲染中，这些光源被放置来模拟场景中的间接光。光线从表面反射回来。对于填充光，高光的贡献通常不会被计算出来，特别是当这些光相对于被着色物体而言在物理上是很大的，而相对于场景中的其他光源来说则是相对昏暗的。这些因素使他们的高光更分散，不太明显。这种类型的光在现实世界中与电影和视频的照明有相似之处，物理补光通常用于在阴影中添加照明。</strong></p>
<p><strong>在球面谐波空间也是相反的推导过程简单,也就是说,从光芒中提取分析光源投射在SH。在他的调查SH技术,斯隆表明,给定一个定向光源与一个已知的轴,很容易从SH辐照度计算表示光的强度应该最小化错误本身和编码的辐照度之间。</strong></p>
<p><strong>在他之前的工作斯隆展示了如何通过只使用第一个(线性)波段的系数来选择一个接近最优的方向。该调查还包括一种提取多个方向光的方法。结果表明，球面谐波是光求和的实际基础。我们可以将多个光源投射到SH中，并提取出数量更少、能够接近投影集的定向光源。lightcuts框架提供了一种聚合次要光源的原则性方法。</strong></p>
<p><strong>虽然最常用于辐照度，SH投影可以用来模拟光滑的，视相关的BRDF照明。Ramamoori和Hanrahan描述了一种这样的技术。与单一颜色不同，它们在一个立方体映射中存储球谐投影的系数，编码环境映射的视图依赖性。然而，在实践中，这种技术比我们前面看到的预过滤环境映射方法需要更多的空间。Kautz等人利用二维SH系数表推导出一种更经济的解，但这种方法仅限于相当低频率的照明。</strong></p>
<h3 id="Other-Representations-其他表示"><a href="#Other-Representations-其他表示" class="headerlink" title="Other Representations 其他表示"></a>Other Representations 其他表示</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013120403.png" class="" title="image-20211013120403">

<p>各种编码辐照度的方法。从左到右:环境图和漫射照明，通过蒙特卡罗积分计算辐照度;用环境立方体编码的辐照度;球面谐波;球形高斯函数;和h基(它只能代表一个半球的方向，所以背面的法线是不着色的)。(图片是由Yuriy O ‘Donnell和David Neubelt通过开源软件Probulator计算的。)</p>
<p><strong>虽然立方体映射和球面调和是最流行的辐照度环境映射表示，其他表示也可能。参见上图。许多辐照度环境地图有两种主要颜色:顶部的天空颜色和底部的地面颜色。受此观察的启发，Parker等人提出了只使用两种颜色的半球照明模型。假设上半球发射均匀辐亮度Lsky，下半球发射均匀辐亮度Lground．这种情况下的辐照度积分是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013120452.png" class="" title="image-20211013120452">

<p><strong>其中θ是表面法线与天球轴之间的夹角。Baker和Boyd提出了一个更快的近似(由Taylor描述):</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013120519.png" class="" title="image-20211013120519">

<p><strong>它是天空和地面之间的线性插值，使用(cos θ + 1)/2作为插值因子。术语cosθ通常是快速计算点积,在通常情况下,天空半球轴是一个红衣主教轴(例如,y或z轴),它不需要计算,因为它等于n的世界坐标之一。近似相当接近,明显加快,所以它比大多数应用程序的完整表达式。</strong></p>
<p><strong>Forsyth提出了一种便宜而灵活的照明模型，称为三权照明，它包括定向照明、双向照明、半球形照明和包裹照明。</strong></p>
<p><strong>Valve最初引入了辐照度的环境立方体表示法(章节10.3.1)。一般来说，我们在第10.3节中看到的所有球面函数表示都可以用于预计算辐照度。对于辐射函数所代表的低频信号，我们知道SH是一个很好的近似。我们倾向于创造特殊的方法来简化或使用比球面谐波更少的存储。</strong></p>
<p><strong>如果我们想要评估遮挡和其他全局光照效果，或者如果我们想要合并光滑反射(章节10.1.1)，就需要对高频进行更复杂的表示。预计算光照以考虑所有相互作用的一般思想称为预计算辐射传输(PRT)，将在第11.5.3节中讨论。捕捉高频率的光泽照明也被称为全频率照明。小波表示通常用于这种情况，作为压缩环境映射和在设计有效操作符的手段比我们见过的球谐函数更时髦。Ng等人演示了使用哈尔小波将辐照度环境映射推广到模型自阴影。它们在小波基中存储环境地图和阴影函数，阴影函数在物体表面上变化。这种表示是值得注意的，因为它相当于对环境立方体映射进行变换，对每个立方体面执行二维小波投影。因此，它可以被看作是一种立方体映射的压缩技术。</strong></p>
<h2 id="Sources-of-Error-误差的来源"><a href="#Sources-of-Error-误差的来源" class="headerlink" title="Sources of Error 误差的来源"></a>Sources of Error 误差的来源</h2><p><strong>为了正确地进行着色，我们必须在非点状光源上计算积分。在实践中，这一要求意味着我们可以使用许多不同的技术，基于正在考虑的灯的特性。通常实时引擎会对一些重要的灯光进行分析建模，在灯光区域上近似积分，并通过阴影贴图计算遮挡。所有其他光源——远处照明、天空、补光和在表面上反弹的光——通常由环境立方体贴图(用于镜面组件)和球面基础(用于漫射光)来表示。</strong></p>
<p><strong>使用照明技术的混合意味着我们不会直接使用给定的BRDF模型，而是使用具有不同程度误差的近似。有时BRDF近似是明确的，因为我们为了计算照明积分而拟合中间模型——ltcs就是一个例子。其他时候，我们构建的近似是在特定(通常很少)条件下对给定BRDF精确的，但在一般的预过滤立方体映射中容易出错——这就属于这一类。</strong></p>
<p><strong>在开发实时着色模型时需要考虑的一个重要方面是确保不同形式的光照之间的差异不明显。从视觉上看，从不同的表征中获得相干光的结果，甚至可能比每个表征产生的绝对近似误差更重要。</strong></p>
<p><strong>遮挡对于真实渲染来说也是至关重要的，因为在应该没有光线的地方光线“漏出”通常比在应该有光线的地方没有光线更明显。大多数区域光表示对于阴影来说并不简单。今天，没有一种现有的实时阴影技术，即使考虑到“软化”效果(第7.6节)，也不能准确地考虑光的形状。我们计算一个标量因子，当物体投射阴影时，我们乘这个标量因子来减少给定光的贡献，这是不正确的;在用BRDF积分时，我们应该考虑这种遮挡。环境照明的情况是特别困难的，因为我们没有一个明确的、主导的光方向，所以不能使用点状光源的阴影技术。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013120839.png" class="" title="image-20211013120839">

<p>生产照明。(拖车公园5。档案颜料打印，17x22英寸。格雷戈里·克鲁德森的《玫瑰下》系列剧照。c Gregory Crewdson。礼貌高古轩)。</p>
<p><strong>即使我们已经看到了一些相当先进的照明模型，但重要的是要记住，这些并不是真实世界光源的精确表示。例如，在环境照明的情况下，我们假设无限远辐射源，那些永远不可能的。我们所见过的所有解析光都建立在一个更强的假设上，即光对其表面上的每个点均匀地向外照射半球。在实践中，这种假设可能会产生误差，因为通常真实的光具有很强的方向性。在摄影和电影照明中，特别制作的面具和过滤器，称为gobos, cuculoris，或饼干，经常被用于艺术效果。例如，如上图中由摄影师Gregory Crewdson设计的复杂的电影照明。为了限制照明角度，同时保持大范围的发射，可以在大型发光面板(所谓的软箱)前面添加被称为蜂巢的黑色屏蔽材料网格。镜子和反光镜的复杂配置也可以用于灯的外壳，如室内照明、汽车前照灯和手电筒。参见下图。这些光学系统创建了一个或多个远离物理中心辐射光的虚拟发射器，在进行衰减计算时应该考虑这个偏移。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211013120943.png" class="" title="image-20211013120943">

<p>相同的圆盘灯有两种不同的发射剖面。左:圆盘上的每一点都均匀地向外射出光线。右图:发射聚焦在正常圆盘周围的一个瓣上。</p>
<p><strong>请注意，这些错误应该总是在一个感知的、面向结果的框架中评估(除非我们的目标是做预测渲染，即以可靠地模拟表面的真实世界外观)。在艺术家的手中，某些简化，即使不现实，仍然可以产生有用和富有表现力的原语。物理模型是有用的，因为它可以让艺术家更容易地创造出视觉上可信的图像，但它们不是自己的目标。</strong></p>
<h1 id="11-Global-Illumination-全局光照"><a href="#11-Global-Illumination-全局光照" class="headerlink" title="11 Global Illumination 全局光照"></a>11 Global Illumination 全局光照</h1><p><strong>辐亮度是通过渲染过程计算出来的最终数量。到目前为止，我们一直使用反射率方程来计算它:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014113728.png" class="" title="image-20211014113728">

<p><strong>其中Lo(p, v)是从表面位置p在视图方向v上发出的辐亮度，Ω是p以上方向的半球，f(l, v)是v和当前入射方向l, Li(p, l)的BRDF值是从l入射到p的亮度，(n·l)+是l和n之间的点积，负的值固定为零。</strong></p>
<h2 id="The-Rendering-Equation-渲染方程"><a href="#The-Rendering-Equation-渲染方程" class="headerlink" title="The Rendering Equation 渲染方程"></a>The Rendering Equation 渲染方程</h2><p><strong>反射率方程是Kajiya在1986年提出的全渲染方程的一个限制性特例。渲染方程使用了不同的形式。我们将使用这个版本:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014114339.png" class="" title="image-20211014114339">

<p><strong>新元素是Le(p, v)，为表面位置p在v方向上发出的辐亮度，替换如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014114428.png" class="" title="image-20211014114428">

<p><strong>这一项意味着从l方向进入位置p的入射辐亮度等于从相反方向-l的另一点发出的辐亮度。在这种情况下，“其他点”是由光线投射函数r(p, l)定义的。该函数返回从p向l方向投射光线击中的第一个表面点的位置。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014114638.png" class="" title="image-20211014114638">

<p>着色表面位置p，光照方向l，光线投射函数r(p, l)，入射亮度Li(p, l)，也表示为Lo(r(p, l)，−l)。</p>
<p><strong>渲染方程的含义很简单。要遮蔽表面位置p，我们需要知道出射亮度Lo 让p在视图方向v，这就等于发射的辐亮度Le 加上反射的亮度。光源的发射和反射率已在前几章中研究过。甚至光线投射操作符也不像看起来那么陌生。例如，z缓冲区对从眼睛射入场景的光线进行计算。</strong></p>
<p><strong>唯一的新项是Lo(r(p, l)，−l)，这说明入射到某一点的光辉必定是从另一点发出来的。不幸的是，这是一个递归术语。也就是说，它是通过对位置r(r(p, l),l ‘)的输出辐亮度的另一个求和来计算的。这些依次需要计算从位置r(r(r(p, l),l ‘),l “)到无穷远的输出辐亮度。现实世界能够实时计算出所有这些，真是令人惊讶。</strong></p>
<p><strong>我们凭直觉就知道，光线照亮一个场景，光子四处反弹，每次碰撞都以各种方式被吸收、反射和折射。渲染方程很重要，因为它将所有可能的路径总结成一个简单的方程。</strong></p>
<p><strong>渲染方程的一个重要属性是，它对发射的光照是线性的。如果我们把光线放大两倍，着色的效果会更亮两倍。材质对每种光的响应也独立于其他光源。也就是说，一种光的存在并不影响另一种光与材质的相互作用。</strong></p>
<p><strong>在实时渲染中，通常只使用局部光照模型。计算光照只需要可见点的表面数据，而这正是GPU最有效的功能。基元分别被处理和栅格化，然后被丢弃。在b点进行计算时，不能访问a点的光照计算结果。透明度、反射和阴影都是全局光照算法的例子。它们使用的信息来自于其他物体而不是被照亮的物体。这些效果有助于提高渲染图像的真实感，并提供线索，帮助观众理解空间关系。同时，模拟它们也很复杂，可能需要预计算或呈现多个通道来计算一些中间信息。</strong></p>
<p><strong>思考照明问题的一种方法是通过光子的路径。在局部照明模型中，光子从光到表面(忽略干涉物体)，然后到眼睛。阴影技术考虑到这些干涉对象的直接遮挡效应。环境地图捕捉从光源到远处物体的照明，然后应用到局部闪亮的物体上，这些物体将光线反射到眼睛。辐照度图还可以捕捉到光对遥远物体的影响，在半球的每个方向上进行整合。从所有这些物体反射的光被加权和求和，以计算出一个表面的照明，然后被眼睛看到。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014115309.png" class="" title="image-20211014115309">

<p>一些路径和它们到达眼睛时的等价符号。请注意，从网球开始有两条连续的路径。</p>
<p><strong>以更正式的方式思考光传输路径的不同类型和组合有助于理解现有的各种算法。Heckbert提出了一种有用的符号格式，用于描述一种技术所模拟的路径。光子从光(L)到眼睛(E)的每一次相互作用都可以被标记为漫反射(D)或镜面(S)。分类还可以进一步增加其他表面类型，如“光滑的”，意思是有光泽但不像镜子。参见上图。可以用正则表达式对算法进行简要总结，显示它们模拟的交互类型。基本表示法的概述见下表。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014115420.png" class="" title="image-20211014115420">

<p>正则表达式的符号。</p>
<p><strong>光子从光到眼睛可以有不同的路径。最简单的路径是LE，光直接被眼睛看到。一个基本的z缓冲区是L(D|S)E，或等价于LDE|LSE。光子离开光，到达漫反射或镜面，然后到达眼睛。注意，在基本的渲染系统中，点光源没有物理表示。给出灯的几何形状将产生一个系统L(D |S)?E，这样光线也可以直接进入眼睛。</strong></p>
<p><strong>如果将环境映射添加到渲染器中，那么紧凑表达式就不那么明显了。虽然Heckbert的表示法读起来从头到脚，但构建相反方向的表达式通常更容易。眼睛首先会看到镜面或漫反射面,(S|D)E。如果表面是高光的，它也可以选择反射一个(远处的)高光或漫反射表面，渲染到环境地图中。因此，有一个额外的潜在路径:((S|D)?S|D)E。要计算眼睛直接看到光的路径，加一个L((S|D)?S|D)?E。</strong></p>
<p><strong>该表达式可以扩展为LE|LSE|LDE|LSSE|LDSE，单独显示所有可能的路径，或更短的L(D|S)?S?E。每一种都有其在理解关系和限制方面的作用。这种表示法的部分效用在于表达算法效果，并能够基于这些效果进行构建。例如，L(S|D)是生成环境映射时编码的内容，而SE是随后访问该映射的部分。</strong></p>
<p><strong>渲染方程本身可以用简单的表达式L(D|S)∗E总结，即来自光的光子在进入眼睛之前可以接触到零到几乎无限个漫反射或镜面。</strong></p>
<p><strong>全局照明研究的重点是计算沿这些路径的光传输的方法。当将它应用到实时渲染时，我们经常愿意牺牲一些质量或正确性来进行有效的评估。最常见的两种策略是简化和预计算。例如，我们可以假设所有的光在到达眼睛之前都是漫反射的，这种简化在某些环境中很有效。我们还可以离线预计算物体间效果的一些信息，例如生成记录表面光照水平的纹理，然后在实时中仅根据这些存储的值进行基本计算。本章将举例说明如何使用这些策略来实现实时的各种全局照明效果。</strong></p>
<h2 id="General-Global-Illumination-通用全局光照"><a href="#General-Global-Illumination-通用全局光照" class="headerlink" title="General Global Illumination 通用全局光照"></a>General Global Illumination 通用全局光照</h2><p><strong>前面几章重点介绍了求解反射率方程的各种方法。我们假设入射辐亮度L有一定的分布i，并分析了它如何影响阴影。在本章中，我们将介绍用于求解完整渲染方程的算法。两者的区别在于前者忽略了光芒的来源——它只是被给予。后者明确地说明了这一点:到达某一点的辐亮度是由其他点发射或反射出来的辐亮度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014120257.png" class="" title="image-20211014120257">

<p>路径跟踪可以生成逼真的图像，但在计算上很昂贵。上面的图像每个像素使用超过2000条路径，每条路径最长可达64段。它花了两个多小时渲染，但仍然有一些轻微的噪音。(“乡村厨房”模型由Jay-Artist, Benedikt Bitterli渲染资源，授权CC by 3.0。使用三菱渲染器渲染。)</p>
<p><strong>解决完整渲染方程的算法可以生成令人惊叹的、逼真的图像(上图)。然而，对于实时应用程序来说，这些方法的计算成本太高。那么，为什么要讨论它们呢?第一个原因是，在静态或部分静态场景中，这样的算法可以作为预处理运行，将结果存储起来，以便在渲染时使用。例如，这是游戏中的常见方法，我们将讨论这类系统的不同方面。</strong></p>
<p><strong>第二个原因是全局光照算法建立在严格的理论基础上。它们是直接从渲染方程中推导出来的，并且它们做出的任何近似都是经过仔细分析的。在设计实时解决方案时，可以也应该应用类似类型的推理。即使我们走了某些捷径，我们也应该意识到后果是什么正确的方法。随着图形硬件变得越来越强大，我们将能够做出更少的妥协，并创建更接近正确的物理结果的实时渲染图像。</strong></p>
<p><strong>求解绘制方程的两种常用方法是有限元法和蒙特卡罗法。Radiosity是基于第一种方法的算法;不同形式的光线追踪使用的是第二种方法。在这两种方法中，射线追踪要流行得多。这主要是因为它可以在同一个框架内有效地处理一般的光传输——包括体积散射等效应。它也更容易伸缩和并行化。</strong></p>
<p><strong>我们将简要描述这两种方法，但感兴趣的读者应该参考任何优秀的书籍，其中涵盖了在非实时设置下求解渲染方程的细节。</strong></p>
<h3 id="Radiosity-光能传递"><a href="#Radiosity-光能传递" class="headerlink" title="Radiosity 光能传递"></a>Radiosity 光能传递</h3><p><strong>辐射度是第一种计算机图形技术，用于模拟漫反射表面之间的反射光。它的名字来自算法计算的数量。在经典的形式中，辐射度可以计算区域光的互反射和软阴影。关于这个算法的书籍已经有了，但其基本思想相对简单。光线在环境中反射。你打开一盏灯，光线很快就会达到平衡。在这种稳定状态下，每个表面都可以被认为是一个光源。基本的辐射度算法简化假设所有的间接光都来自漫射表面。这一前提不适用于有抛光大理石地板或墙壁上有大镜子的地方，但对于许多建筑设置来说，这是一个合理的近似。辐射度可以跟随有效的无限数量的漫反射。使用本章开始时介绍的符号，其轻型传输集为LD∗E。</strong></p>
<p><strong>辐射度假定每个表面都是由若干个小块组成的。对于每一个较小的区域，它计算一个单一的平均辐射值，因此这些补丁需要足够小，以捕获所有的照明细节(例如，阴影边缘)。然而，它们不需要与下面的表面三角形一一匹配，甚至不需要大小一致。</strong></p>
<p><strong>从渲染方程出发，我们可以得出patch i的辐射度为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014124422.png" class="" title="image-20211014124422">

<p><strong>Bi 为patch i, Bi^e的辐射度为辐射出度，即第i块发射的辐射度，和ρss 为次表面反照率(第9.3节)。只有光源的发射不为零。Fij 是斑块i和j之间的形状因子。形状因子被定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014124553.png" class="" title="image-20211014124553">

<p><strong>Ai 为patch i的面积，V (i, j)为点i和点j之间的可见度函数，如果两者之间没有遮挡光，则为1，否则为0。θi 和θj 是两个贴片法线和射线连接点i和j之间的夹角，最后是dij 为射线的长度。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014124717.png" class="" title="image-20211014124717">

<p>两个表面点之间的形状因子。</p>
<p><strong>形状因子是一个纯粹的几何术语。它是离开patch i的均匀扩散辐射能入射到patch j上的分数。两个补丁的面积、距离和方向，以及它们之间的任何表面，都会影响它们的形状因子值。想象一个补丁，比如说，一个电脑显示器。房间里的其他每一块都将直接接收显示器发出的光的一部分。如果表面在监视器后面或不能“看到”监视器，这个分数可能为零。这些分数加起来都是1。辐射度算法的一个重要部分是准确地确定场景中对patch之间的形状因素。</strong></p>
<p><strong>通过计算形状因子，将所有patch的方程(上上式)组合成一个单一的线性系统。然后对系统进行求解，得到每个补丁的辐射度值。由于计算复杂度高，随着patch数量的增加，减少这样一个矩阵的成本是相当大的。</strong></p>
<p><strong>由于该算法伸缩性差，并且有其他限制，经典的辐射很少用于产生照明解决方案。然而，在现代实时全球照明系统中，预计算形状因子并在运行时使用它们来执行某种形式的光传播的想法仍然很流行。我们将在本章后面(第11.5.3节)讨论这些方法。</strong></p>
<h3 id="Ray-Tracing-光线追踪"><a href="#Ray-Tracing-光线追踪" class="headerlink" title="Ray Tracing 光线追踪"></a>Ray Tracing 光线追踪</h3><p><strong>射线投射(Ray casting)是指从某个位置发射射线，以确定某个特定方向上的物体的过程。光线追踪使用光线来确定光线在不同场景元素之间的传输。在其最基本的形式中，光线从相机通过像素网格射入场景。对于每一条射线，要找到最近的物体。然后，通过向每一束光发射一条射线，并寻找是否有任何物体处于两者之间，来检查交点是否处于阴影中。不透明的物体会挡住光线;透明物体会使它衰减。其他射线可以从交点产生。如果一个表面是有光泽的，则在反射方向产生一条射线。这条射线拾取第一个物体相交的颜色，然后对其相交点进行阴影测试。光线也可以产生在折射方向的透明固体物体，再次递归评估。这一基本机制非常简单，以至于功能性射线示踪剂被写在名片的背面。</strong></p>
<p><strong>经典的光线追踪只能提供有限的效果:强烈的反射和折射，以及硬阴影。然而，同样的基本原理可以用来解决完整的渲染方程。Kajiya意识到发射射线和计算它们携带多少光的机制可以用来计算公式11.2中的积分。这个方程是递归的，这意味着对于每一条射线，我们需要在不同的位置，重新计算积分。幸运的是，处理这个问题的坚实的数学基础已经存在。蒙特卡罗方法是在曼哈顿计划期间为物理实验而开发的，专门设计来处理这类问题。不是直接通过求积规则计算每个阴影点的积分值，而是在定义域的一些随机点上计算被积函数。然后用这些值计算积分值的估计值。采样点越多，精度越高。这种方法最重要的性质是只需要被积函数的点计算。只要有足够的时间，我们可以任意精度地计算这个积分。在渲染的上下文中，这正是光线追踪所提供的。当我们发射射线时，我们对11.2式中的被积函数进行点采样。即使在交点处还有另一个积分，我们不需要它的最终值，我们可以对它再次进行点采样。当光线穿过场景时，一条路径就建立起来了。沿每条路径携带的光提供被积函数的一个计算值。这个过程称为路径跟踪(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014125004.png" class="" title="image-20211014125004">

<p>由路径跟踪算法生成的示例路径。这三种路径都通过胶片平面上相同的像素，并用于估计其亮度。底部的地板是高度光滑的，并以一个小的实心角度反射光线。蓝色的方框和红色的球体是漫射的，所以光线在交点处均匀地围绕法线散射。</p>
<p><strong>跟踪路径是一个非常强大的概念。路径可以用于渲染光滑或漫反射材质。使用它们，我们可以生成柔和的阴影和渲染透明的物体以及焦散效果。将路径跟踪扩展到样本点的体积，而不仅仅是表面，它可以处理雾和次表面散射效果。</strong></p>
<p><strong>路径跟踪的唯一缺点是实现高视觉保真度所需的计算复杂性。对于电影质量的图像，可能需要追踪数十亿条路径。这是因为我们从不计算积分的实际值，只计算它的估计值。如果使用的路径太少，这种近似将是不精确的，有时相当不精确。此外，即使是相邻的点，结果也可能会有很大的不同，因为人们会期待灯光几乎是相同的。我们说这样的结果有高方差。从视觉上看，这在图像中显示为噪声(下图)。已经提出了许多方法来消除这种影响，而不需要追踪额外的路径。一种流行的技术是重要性采样。这个想法是，通过向大部分光线来自的方向发射更多的光线，方差可以大大减少。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211014125118.png" class="" title="image-20211014125118">

<p>在样本数目不足的情况下使用蒙特卡罗路径跟踪所产生的噪声。左边的图像每像素渲染8条路径，右边的图像每像素渲染1024条路径。来自Benedikt Bitterli Rendering Resources的“Cornell Box”模型，在CC BY 3.0下授权。使用三菱渲染器渲染。)</p>
<p><strong>在路径跟踪及其相关方法方面，已经发表了许多论文和著作。Pharr等人对现代脱机光线追踪技术作了很好的介绍。Veach为现代关于光传输算法的推理奠定了数学基础。我们将在本章末尾的第11.7节讨论交互速率下的光线和路径跟踪。</strong></p>
<h2 id="Ambient-Occlusion-环境遮蔽"><a href="#Ambient-Occlusion-环境遮蔽" class="headerlink" title="Ambient Occlusion 环境遮蔽"></a>Ambient Occlusion 环境遮蔽</h2><p><strong>上一节介绍的通用全局光照算法在计算上非常昂贵。它们可以产生各种各样的复杂效果，但生成一张图像可能需要几个小时。我们将开始我们的探索实时替代与最简单的，但仍然视觉上令人信服的解决方案，并逐步建立更复杂的影响，整个章节。</strong></p>
<p><strong>一个基本的全局照明效果是环境遮挡(AO)。这种技术是在21世纪初由工业光魔公司的兰迪斯开发的，用于提高电影《珍珠港》(Pearl Harbor)中电脑生成飞机的环境照明质量。尽管这种效应的物理基础包括相当数量的简化，但结果看起来令人惊讶地可信。这种方法在光线缺乏方向变化且不能显示物体细节时提供了关于形状的提示。</strong></p>
<h3 id="Ambient-Occlusion-Theory-环境遮蔽理论"><a href="#Ambient-Occlusion-Theory-环境遮蔽理论" class="headerlink" title="Ambient Occlusion Theory 环境遮蔽理论"></a>Ambient Occlusion Theory 环境遮蔽理论</h3><p><strong>环境遮蔽的理论背景可以直接从反射方程推导出来。为了简单起见，我们将首先关注朗伯曲面。出射亮度Lo 辐照度是入射辐亮度的余弦加权积分。一般来说，它取决于表面位置p和表面法线n。同样，为简单起见，我们将假设入射辐亮度为常数Li(l) = LA，对于所有入射方向l，得到计算辐照度的公式如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015132655.png" class="" title="image-20211015132655">

<p><strong>积分是在可能传入方向的半球Ω上执行的。在恒定均匀照明的假设下，辐照度(以及由此产生的出射亮度)不依赖于表面位置或法线，在整个物体上是恒定的。这导致了一个扁平的外观。</strong></p>
<p><strong>上方程没有考虑任何可见性。有些方向可能会被物体的其他部分或场景中的其他物体挡住。这些方向会有不同的入射亮度，而不是LA．为简单起见，我们假设从闭塞方向入射的辐亮度为零。这忽略了场景中其他物体反射的所有光线，并最终从这些被阻挡的方向到达p点，但它极大地简化了推理。得到由Cook和Torrance首先提出的方程:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015132811.png" class="" title="image-20211015132811">

<p><strong>其中，v(p, l)是一个可见性函数，如果从p向l方向投射的光线被阻挡，该函数等于零，如果不被阻挡，则等于1。</strong></p>
<p><strong>可视性函数的归一化余弦加权积分称为环境遮蔽:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015132906.png" class="" title="image-20211015132906">

<p><strong>它代表了未被遮挡半球的余弦加权百分比。值的范围从0(完全遮挡的表面点)到1(没有遮挡的位置)。值得注意的是，凸面物体，如球体或盒子，不会造成自身的遮挡。如果场景中不存在其他物体，凸物体的环境遮蔽值将到处为1。如果物体有凹穴，在这些区域遮挡将小于一个。</strong></p>
<p><strong>一旦kA 定义时，遮挡存在时的环境辐照度方程为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015132944.png" class="" title="image-20211015132944">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015133024.png" class="" title="image-20211015133024">

<p>一个物体渲染只有恒定的环境光(左)和环境光遮蔽(右)。即使在光照恒定的情况下，环境遮挡也会带来物体的细节。(“龙”模型由Delatronic, Benedikt Bitterli渲染资源，在CC by 3.0下许可。使用三菱渲染器渲染。)</p>
<p><strong>注意，现在辐照度确实随表面位置而改变，因为kA 所做的事。这将导致更加真实的结果，如上图所示。表面位置在尖锐的折痕将是黑暗的，因为他们的值kA 很低。比较地表位置p0 和p1 如下图所示。表面方向也有影响，因为可视性函数v(p, l)在积分时被余弦因子加权。比较p1 p2 在图的左边。两者都有一个大小相同的未闭塞立体角，但p1 是绕其表面法线，所以余弦系数比较高，从箭头的亮度就可以看出。相比之下，p2 偏离表面法线的一侧，相应的余弦系数值较低。因此，kA 的值在p2点更低．从这里开始，为了简短起见，我们将不再显式地显示对表面位置p的依赖关系。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015133215.png" class="" title="image-20211015133215">

<p>环境照明下的物体三分(p0,p1和p2)所示。在左边，被阻挡的方向显示为相交点(黑色圆圈)结束的黑色射线。畅通的方向显示为箭头，根据余弦系数着色，以便那些更接近表面法线较轻。在右边，每个蓝色箭头显示平均未闭塞方向或弯曲法线。</p>
<p><strong>除了kA， Landis也计算出平均未遮挡方向，称为弯曲法线。这个方向向量被计算为未被遮挡光方向的余弦加权平均值:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015133308.png" class="" title="image-20211015133308">

<p><strong>符号||x||表示向量x的长度。积分的结果除以其自身的长度以产生标准化结果。如上图右侧所示。结果向量可以在着色过程中代替几何法线，以提供更准确的结果，而不需要额外的性能成本(章节11.3.7)。</strong></p>
<h3 id="Visibility-and-Obscurance-可视性和遮蔽"><a href="#Visibility-and-Obscurance-可视性和遮蔽" class="headerlink" title="Visibility and Obscurance 可视性和遮蔽"></a>Visibility and Obscurance 可视性和遮蔽</h3><p><strong>可视性函数v(l)用于计算环境遮挡因子kA (上上上式)需要仔细定义。对于一个物体，例如一个角色或车辆，它是直接定义v(l)基于从表面位置在l方向投射的光线是否相交于同一物体的任何其他部分。然而，这并不能解释被附近其他物体遮挡的原因。通常，物体可以假定被放置在一个平面上以达到照明的目的。通过在可见性计算中包含这个平面，可以实现更真实的遮挡。另一个好处是，物体对地平面的遮挡可以用作接触阴影。</strong></p>
<p><strong>不幸的是，可见函数方法在封闭几何中失败了。想象这样一个场景:一个封闭的房间里有各种各样的物品。所有曲面都是kA 值为0，因为所有来自表面的射线都会击中某个物体。经验方法，试图复制环境遮蔽的外观，而不必模拟延迟物理可视性通常更适合这类场景。其中一些方法受到Miller无障碍着色概念的启发，该概念模拟了表面的角落和裂缝如何捕获污垢或腐蚀。</strong></p>
<p><strong>Zhukov等人引入了遮蔽的思想，通过将可视性函数v(l)替换为距离映射函数ρ(l)来修改环境遮挡计算:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015133810.png" class="" title="image-20211015133810">

<p><strong>与v(l)不同，v(l)只有两个有效值，1表示无交点，0表示有交点，ρ(l)是一个基于射线与曲面相交前的距离的连续函数。对于大于指定距离d的任意交点，ρ(l)在交点距离为0和1处的值为dmax，或者根本没有交集。dmax 之外不需要测试，可大大加快kA。下图显示了ambient occlusion 和 ambient obscurance的区别。注意，使用ambient occlusion渲染的图像相当暗。这是因为即使在很远的距离处也能检测到交叉点，因此会影响kA的值。</strong></p>
<p><strong>尽管试图在物理上证明它，模糊在物理上是不正确的。然而，它通常会给出符合观众期望的可信结果。缺点之一是dmax 的值需要手动设置才能达到令人满意的效果。这种妥协在计算机图形学中经常出现，其中一种技术没有直接的物理基础，但“在感知上令人信服”。“目标通常是一个可信的图像，所以这种技术使用起来很好。也就是说，基于理论的方法的一些优点是它们可以自动工作，并可以通过推理真实世界的工作方式进一步改进。</strong></p>
<h3 id="Accounting-for-Interreflections-相互反射的计算"><a href="#Accounting-for-Interreflections-相互反射的计算" class="headerlink" title="Accounting for Interreflections 相互反射的计算"></a>Accounting for Interreflections 相互反射的计算</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015134512.png" class="" title="image-20211015134512">

<p>没有反射和有反射的环境遮蔽的区别。左边的图像只使用关于可见性的信息。右边的图像也使用了间接照明的反射。(“维多利亚风格的房子”模型由mr黑猩猩2313,Benedikt Bitterli渲染资源，授权CC by 3.0。使用三菱渲染器渲染。)</p>
<p><strong>尽管由环境遮挡产生的结果在视觉上是令人信服的，但它们比由全局照明模拟产生的结果要暗。比较上图中的图像。</strong></p>
<p><strong>环境遮蔽和全局照明之间的一个重要区别是相互反射。方程11.8假设在闭塞方向上的辐亮度为零，而在现实中，相互反射将从这些方向引入非零辐亮度。这种效果可以从上图左侧模型的折痕和凹坑中看到，与右侧模型相比。这种差异可以通过增加kA的值来解决。使用遮挡距离映射函数代替可视性函数(章节11.3.2)也可以缓解这个问题，因为遮挡函数对于阻塞方向的值通常大于零。</strong></p>
<p><strong>以更精确的方式跟踪相互反射是昂贵的，因为它需要解决递归问题。要遮蔽一个点，必须先遮蔽其他点，以此类推。计算kA 的值这比执行一个完整的全局照明计算要便宜得多，但是它经常以某种形式包含这个缺失的光，以避免过度暗。Stewart和Langer提出了一种便宜但惊人精确的近似相互反射的方法。它是基于对扩散照明下的朗伯场景的观察，从一个给定位置可见的表面位置趋向于有相似的亮度。假设亮度Li 从封闭方向发射的辐射亮度Lo 从当前着色点，递归被打破，可以找到一个解析表达式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015134755.png" class="" title="image-20211015134755">

<p><strong>在ρss 为地下反照率，或漫反射。这等价于替换环境遮挡因子kA 有一个新的因子kA′：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015134836.png" class="" title="image-20211015134836">

<p><strong>这个方程将倾向于使环境遮挡因子变亮，使它在视觉上更接近一个完整的全局照明解决方案的结果，包括相互反射。这种效应高度依赖于ρss值。潜在的近似假设表面颜色在着色点附近是相同的，以产生一种有点像颜色出血的效果。Hoffman和Mitchell使用这种方法用天空光照亮地形。</strong></p>
<p><strong>Jimenez等人提出了一个不同的解。他们为许多场景执行完全的、离线的路径跟踪，每个场景都被一个统一的白色、无限远的环境地图照亮，以获得适当考虑相互反射的遮挡值。基于这些例子，他们拟合三次多项式来逼近由环境遮挡值kA 映射的函数f 以及次表面反照率ρss 到遮挡值kA′ ，它被反射光照亮。他们的方法也假设反照率是局部常数，并且入射反照率的颜色可以根据给定点的反照率得到。</strong></p>
<h3 id="Precomputed-Ambient-Occlusion-预计算环境遮挡"><a href="#Precomputed-Ambient-Occlusion-预计算环境遮挡" class="headerlink" title="Precomputed Ambient Occlusion 预计算环境遮挡"></a>Precomputed Ambient Occlusion 预计算环境遮挡</h3><p><strong>环境遮蔽因子的计算非常耗时，通常在渲染前离线进行。预计算任何与光照相关的信息的过程，包括环境遮蔽，通常被称为烘培。</strong></p>
<p><strong>最常用的预计算环境遮挡的方法是蒙特卡罗方法。光线投射和检查与场景的交叉口，方程11.8是数值计算。例如，我们随机选择N个方向l，均匀分布在法线n附近的半球上，沿着这些方向跟踪光线。基于交叉结果，我们评估可视性函数v，然后环境遮蔽可计算为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015135414.png" class="" title="image-20211015135414">

<p><strong>当计算环境遮挡时，投射光线可以被限制在一个最大距离，并且v的值是基于所找到的交点距离。</strong></p>
<p><strong>环境遮挡或遮蔽因子的计算包括一个余弦加权因子。虽然它可以直接包含，如上式所示，但更有效地包含该权重因子的方法是采用重要性采样。射线方向的分布是余弦加权的，而不是均匀地投射在半球上并对结果进行余弦加权。换句话说，光线更有可能投射到更接近表面法线的方向，因为从这个方向产生的结果可能更重要。这种采样方案称为马利方法。</strong></p>
<p><strong>环境遮挡预计算可以在CPU上执行，也可以在GPU上执行。在这两种情况下，可以使用库来加速针对复杂几何体的光线投射。最受欢迎的两个是CPU的Embree和GPU的OptiX。过去，来自GPU管线的结果，如深度映射或遮挡查询，也被用于计算环境遮蔽。随着GPU上越来越普遍的光线投射解决方案的普及，它们的使用在今天已经不那么普遍了。大多数商业上可用的建模和渲染软件包提供了一个选项来预计算环境遮蔽。</strong></p>
<p><strong>遮挡数据对于对象上的每个点都是唯一的。它们通常以纹理、体积或网格顶点的形式存储。不管存储的信号类型是什么，不同存储方法的特点和问题都是相似的。如第11.5.4节所述，同样的方法也可以用于存储环境遮蔽、方向遮蔽或预计算光照。</strong></p>
<p><strong>预先计算的数据也可以用来模拟物体相互之间的环境遮挡效应。Kontkanen和Laine将一个物体对其周围环境的环境遮挡效应存储在一个立方体映射中，称为环境遮蔽场。他们用二次多项式的倒数来模拟环境遮蔽值如何随着与物体的距离而变化。它的系数存储在一个立方体映射中，以模拟遮挡的方向变化。在运行时，利用遮挡对象的距离和相对位置获取合适的系数并重建遮挡值。</strong></p>
<p><strong>Malmer等人通过将环境遮蔽因子和可选的弯曲法线存储在一个称为环境遮蔽体积的三维网格中，显示了改进的结果。计算要求较低，因为环境遮挡因子直接从纹理中读取，而不是计算。与Kontkanen和Laine的方法相比，存储的标量更少，两种方法的纹理分辨率都很低，所以总体存储需求是相似的。Hill和Reed描述了Malmer等人的方法在商业游戏引擎中的实现。他们讨论算法的各个实际方面以及有用的优化。这两种方法都适用于刚性对象，但它们可以扩展到具有少量运动部件的铰接对象，其中每个部件被视为单独的对象。</strong></p>
<p><strong>无论我们选择哪种方法来存储环境遮蔽值，我们都需要知道我们处理的是连续信号。当我们从空间中的一个特定点发射光线时，我们进行采样，当我们在着色之前从这些结果中插入一个值时，我们进行重建。来自信号处理领域的所有工具都可以用来提高采样重构过程的质量。Kavan等人提出了一种他们称之为最小二乘烘焙的方法。遮挡信号通过网格均匀采样。接下来，导出顶点的值，使插值和采样点之间的总差最小，在最小二乘意义上。他们专门讨论在顶点存储数据的上下文中的方法，但是同样的推理也可以用于导出存储在纹理或体积中的值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015135933.png" class="" title="image-20211015135933">

<p>命运号在其间接照明计算中使用了预先计算的环境遮蔽。该解决方案被用于两代不同硬件的游戏版本，提供了高质量和性能。(图片c 2013 Bungie, Inc.版权所有。)</p>
<p><strong>《命运》是一款使用预计算环境遮挡作为间接照明解决方案基础的广受好评的游戏(上图)。这款游戏是在两代主机硬件之间的过渡时期发行的，它需要一个解决方案来平衡新平台的高质量与老平台的性能和内存使用的局限性。游戏的特点是一天中的动态时间，所以任何预先计算的解决方案都必须正确地考虑到这一点。开发人员选择环境遮蔽，因为它的可信外观和低成本。由于环境遮挡将能见度计算与光照解耦，所以无论一天中的哪个时间，都可以使用相同的预计算数据。完整的系统，包括基于GPU的烘培管线，由Sloan等人描述。</strong></p>
<p><strong>育碧的《刺客信条》和《Far Cry》系列也使用了一种预计算环境遮挡的形式来增强它们的间接照明解决方案。他们从自上而下的视角渲染世界，并处理得到的深度图来计算大规模遮挡。根据邻近深度样本的分布，使用各种启发式方法来估计值。通过将世界空间的位置投影到纹理空间，生成的世界空间AO地图应用于所有物体。他们称这个方法为World AO。Swoboda也描述了类似的方法</strong>。</p>
<h3 id="Dynamic-Computation-of-Ambient-Occlusion-环境遮蔽的动态计算"><a href="#Dynamic-Computation-of-Ambient-Occlusion-环境遮蔽的动态计算" class="headerlink" title="Dynamic Computation of Ambient Occlusion 环境遮蔽的动态计算"></a>Dynamic Computation of Ambient Occlusion 环境遮蔽的动态计算</h3><p><strong>对于静态场景，环境遮蔽因子kA 弯曲法线nbent 可以预先计算的。然而，对于物体移动或改变形状的场景，通过动态计算这些因素可以获得更好的结果。这样做的方法可以分为在物体空间操作的，和在屏幕空间操作的。</strong></p>
<p><strong>离线计算环境遮挡的方法通常涉及从每个表面点向场景投射大量光线，几十到数百条，并检查相交。这是一项昂贵的操作，实时方法关注于近似或避免大量此类计算的方法。</strong></p>
<p><strong>Bunnell计算环境遮蔽因子kA 弯曲法线nbent 通过将曲面建模为放置在网格顶点上的圆盘形元素的集合。选择圆盘是因为一个圆盘被另一个圆盘遮挡可以通过分析计算，避免了需要投射光线。简单地将一个磁盘的遮挡因子与所有其他磁盘相加，就会由于双重阴影而导致过度暗的结果。也就是说，如果一个圆盘在另一个圆盘的后面，那么两个圆盘都将被计算为封闭表面，即使只有两个圆盘之间更近的部分应该被计算。邦内尔使用了一个聪明的双通道方法来避免这个问题。第一个通道计算环境遮蔽，包括双阴影。在第二次通过中，每个盘的贡献因其从第一次通过的遮挡而减少。这只是一个近似值，但在实践中，它产生的结果是令人信服的。</strong></p>
<p><strong>计算每个元素对之间的遮挡是O(n²)，这是太昂贵的，除了最简单的场景。通过对远处表面的简化表示可以降低代价。Bunnell构造了一个层次结构的元素树，其中每个节点都是一个磁盘，它表示树中它下面的磁盘的聚合。在执行盘间遮挡计算时，较高层的节点用于较远处的表面。这将计算减少到O(nlogn)阶，这是更合理的。邦内尔的技术相当高效，并产生高质量的结果。例如，《加勒比海盗》(Pirates of the Caribbean)电影的最终渲染使用了它。</strong></p>
<p><strong>Hoberock对Bunnell的算法提出了几个改进，以更高的计算费用提高了算法的质量。他还提出了一个距离衰减因子，其结果类似于Zhukov等人提出的遮蔽因子。</strong></p>
<p><strong>Evans描述了一种基于符号距离场(SDF)的动态环境遮挡近似方法。在这幅图中，一个物体被嵌入到一个三维网格中。网格中的每个位置存储到物体最近表面的距离。对于任何对象内部的点，该值为负值，对于所有对象外部的点，该值为正值。Evans在一个体积纹理中创建并存储一个场景的SDF。为了估计物体上某个位置的遮挡，他使用了一种启发式方法，该方法结合了一些点的采样值，沿着法线逐渐远离表面。正如Qu´ılez所描述的，当SDF以解析方式表示(第17.3节)而不是存储在三维纹理中时，也可以使用相同的方法。虽然这种方法是非物理的，但结果在视觉上令人愉悦。</strong></p>
<p><strong>Wright进一步推广了将符号距离场用于环境遮挡。我们没有使用特别的启发式来生成遮挡值，Wright执行圆锥追踪。视锥产生于被遮蔽的位置，并通过在距离场中编码的场景表示对交叉口进行测试。圆锥跟踪是通过沿着轴执行一组步骤和检查相交的SDF与一个不断增加的半径在每一步。如果到最近的遮挡器的距离(从SDF采样的值)小于球体的半径，那部分锥体被遮挡(下图)。追踪单个圆锥是不精确的，并且不允许包含余弦项。基于这些原因，Wright追踪了一组覆盖整个半球的视锥细胞，以估计周围环境的遮挡。为了提高视觉保真度，他的解决方案不仅为场景使用全局SDF，而且还使用局部SDF，代表单个对象或逻辑连接的对象集。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015141351.png" class="" title="image-20211015141351">

<p>圆锥跟踪是通过在场景几何图形和逐渐增大半径的球体之间进行一系列的交点来近似实现的。球面的大小对应于从轨迹原点到给定距离的圆锥的半径。在每一步中，圆锥角度被减少，以考虑场景几何遮挡。最后的遮挡因子被估计为被剪切锥所覆盖的立体角与原始锥的立体角的比值。</p>
<p><strong>Crassin等人在场景体素表示的背景下描述了一种类似的方法。他们使用稀疏体素八叉树(第13.10节)存储场景的体素化。他们计算环境遮蔽的算法是渲染全全局光照效果的更通用方法的一个特例(章节11.5.7)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015141505.png" class="" title="image-20211015141505">

<p>环境遮挡效果是模糊的，不显示遮挡器的细节。AO计算可以使用更简单的几何表示，但仍然可以达到合理的效果。犰狳模型(左)近似于一组球体(右)。在他们身后墙上的模型几乎没有遮挡投射的区别。(模型由斯坦福计算机图形实验室提供。)</p>
<p><strong>Ren等人将遮挡几何体近似为球体的集合(上图)。用球谐函数表示被单球面遮挡的表面点的能见度函数。由一组球体遮挡的聚集可见性函数是将单个球体可见性函数相乘的结果。不幸的是，计算球谐函数的乘积是一项昂贵的操作。他们的关键思想是对单个球面调和可见性函数的对数求和，并将结果取幂。这产生了与乘可见性函数相同的最终结果，但是球面调和函数的求和比乘要便宜得多。本文表明，正确的逼近，对数和指数可以快速执行，产生一个整体的加速。</strong></p>
<p><strong>该方法不仅计算环境遮挡因子，而且计算一个完整的球面能见度函数，用球面谐波表示(第10.3.2节)。一阶(0)系数可用作环境遮挡系数kA，下三个(阶1)系数可用于计算弯曲法向nbent．高阶系数可以用于阴影环境地图或圆形光源。由于几何图形近似为边界球体，从折痕和其他小细节的遮挡不被建模。</strong></p>
<p><strong>Sloan等在屏幕空间中对Ren描述的可见性函数进行了积累。对于每个闭塞器，他们考虑一组像素，这些像素距离它的中心在一定的世界空间距离内。这个操作可以通过渲染一个球体，或者在着色器中执行距离测试，或者使用模板测试来实现。对于所有受影响的屏幕区域，适当的球谐值被添加到屏幕外缓冲区。在积累了所有遮挡器的可见性后，缓冲区中的值被取幂得到最终的组合可见性函数每个屏幕像素。Hill使用了相同的方法，但将球谐可见性函数限制为只有二阶系数。在这种假设下，球面谐波乘积只是少量的标量乘法，甚至GPU的固定功能混合硬件都可以执行。这使得我们能够在性能有限的主机硬件上使用这种方法。由于该方法使用低阶球面谐波，它不能用于生成边界更明确的硬阴影，而只是大部分无方向遮挡。</strong></p>
<h3 id="Screen-Space-Methods-屏幕空间方法"><a href="#Screen-Space-Methods-屏幕空间方法" class="headerlink" title="Screen-Space Methods 屏幕空间方法"></a>Screen-Space Methods 屏幕空间方法</h3><p><strong>对象空间方法的开销与场景复杂度成正比。然而，一些关于遮挡的信息可以纯粹地从屏幕空间数据中推断出来，比如深度和法线。这些方法的成本是恒定的，与场景的细节无关，而只与渲染所用的分辨率有关</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015144755.png" class="" title="image-20211015144755">

<p>Crytek的环境遮挡方法应用于三个表面点(黄色圆圈)。为清晰起见，算法以二维形式显示，相机(没有显示)位于图上方。在这个例子中，10个样本分布在每个表面点周围的圆盘上(实际上，它们分布在一个球体上)。未通过z检验的样本，即那些超出存储的z-缓冲区值的样本显示为红色，通过的样本显示为绿色。k的值A 是通过的样本与总样本之比的函数。为了简单起见，我们忽略变量样本权重。左边的点在10个样本中有6个通过，因此比率为0.6,kA 计算。中点有三个通过的样本。还有一个在对象外部，但没有通过z测试，如红色箭头所示。这就得到kA为0.3。右边的点有一个通过的样本，所以是kA 是0.1。</p>
<p><strong>Crytek开发了一种用于《孤岛危机》的动态屏幕空间环境遮挡(SSAO)方法。他们使用z缓冲区作为唯一的输入，在全屏通道中计算环境遮挡。环境遮蔽因子kA 每个像素的估计是通过测试一组点，这些点分布在像素位置周围的一个球体上，与z缓冲区相对。k的值A 是z缓冲区中对应值前面的样本数量的函数。通过的样本数量越少，kA值就越低。参见上图。样本的权重随着与像素的距离而减小，类似于模糊因子。请注意，由于样本不是由(n·l)+因子加权的，因此产生的环境遮蔽是不正确的。所有的样本都被计算在内，而不是只考虑在一个表面位置上的半球的样本。这种简化意味着在表面以下的样本不应该被计算的时候被计算。这样做会使平面变暗，边缘比周围的环境更亮。尽管如此，结果往往是赏心悦目的。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015144947.png" class="" title="image-20211015144947">

<p>屏幕空间环境遮挡的效果显示在左上方。右上方显示无环境遮挡的反照率(漫反射色)。在左下方，这两个组合显示。镜面阴影和阴影被添加到最终的图像，在右下角。(图片来自Crytek公司提供的《孤岛危机》。)</p>
<p><strong>Shanmugam和Arikan同时开发了一种类似的方法。在他们的论文中，他们描述了两种方法。一个从小的，附近的细节生成精细的环境遮挡。另一种方法是对较大的物体产生粗糙的环境遮挡。将这两种方法的结果结合起来产生最终的环境遮挡因子。他们的精细尺度环境遮挡方法使用全屏通道访问z缓冲区，以及包含可见像素的表面法线的第二个缓冲区。对于每个阴影像素，从z缓冲区中采样附近的像素。采样像素被表示为球体，并对着色像素计算遮挡项，考虑其法线。没有考虑双重阴影，所以结果有点暗。他们的粗糙遮挡方法类似于Ren等人(在456页讨论)的对象空间方法，遮挡几何近似为球体的集合。然而，Shanmugam和Arikan使用屏幕对齐的广告牌覆盖屏幕空间每个闭塞球体的“效果区域”。与Ren等人的方法不同，粗遮挡方法中也没有考虑双重遮挡。</strong></p>
<p><strong>这两种方法极其简单，很快被业界和学术界注意到，并催生了大量后续工作。许多方法，如Filion等人在《星际争霸2》[471]中使用的方法和McGuire等人[1174]中使用的可扩展环境遮蔽方法，使用特别启发式来生成遮挡因子。这些方法具有良好的性能特点，并暴露出一些可以手工调整的参数，以达到预期的艺术效果。</strong></p>
<p><strong>其他方法旨在提供更有原则的计算遮挡的方法。Loos和Sloan注意到Crytek的方法可以解释为蒙特卡罗积分。他们称计算值为体积模糊度和定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015145227.png" class="" title="image-20211015145227">

<p><strong>其中X是一个围绕点的三维球面邻域，ρ是距离映射函数，类似于方程11.11,d是距离函数，o(X)是占据函数，如果X没有被占据，则等于0，否则等于1。他们注意到ρ(d)函数对最终的视觉质量影响很小，所以使用常数函数。在此假设下，体积模糊度是一个点邻域上的占位函数的积分。Crytek的方法是随机采样三维邻域来计算积分。洛斯和斯隆通过随机采样一个像素的屏幕空间邻域，在xy维度上计算积分。z维是解析积分的。如果球形邻域的点不包含任何几何、积分的长度等于x射线和一个球体代表之间的相交的几何、深度缓冲用作入住率的近似函数,积分计算,只有每个线段的空置的一部分。如下图左侧所示。该方法生成的结果与Crytek的质量相当，但使用更少的样本，因为在一个维度上的集成是精确的。如果表面法线是可用的，该方法可以扩展到考虑它们。在那个版本中，线积分的计算被固定在计算点的法线定义的平面上。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015145438.png" class="" title="image-20211015145438">

<p>体积模糊度(左)用线积分估计点周围的未占用体积的积分。体积环境遮挡(右图)也使用线积分，但要计算到阴影点的球切线的占用率，这是从反射方程模拟余弦项。在这两种情况下，积分是由球体的未占用体积(用绿色实线标记)与球体的总体积(用红色虚线标记的未占用体积和已占用体积之和)的比值估计的。对于这两幅图，相机都是从上方观察的。绿色的圆点表示从深度缓冲区读取的样本，黄色的圆点是正在计算遮挡的样本。</p>
<p><strong>Szirmay-Kalos等人提出了另一种使用正常信息的屏幕空间方法，称为体积环境遮蔽。方程11.6对一个半球的法向函数进行积分，其中包括余弦项。他们提出，这种类型的积分可以通过从被积函数中去除余弦项和用余弦分布夹紧积分范围来近似。这将积分变换为在一个球面上而不是在一个半径为一半的半球上，并沿法线移动，以完全包围在半球内。其未占用部分体积的计算方法与Loos和Sloan方法一样，通过对像素邻域随机采样，并对占据函数在z维上进行解析积分。如上图右侧所示。</strong></p>
<p><strong>Bavoil等人提出了一种不同的方法来估计局部可视性问题。他们的灵感来自Max的地平线制图技术。他们的方法称为基于水平的环境遮挡(HBAO)，假设z缓冲区中的数据代表一个连续的高度场。某一点的能见度可以通过确定地平角来估计，地平角是被邻域遮挡的切平面上方的最大角度。也就是说，给定一个点的方向，我们记录可见的最高物体的角度。如果我们忽略余弦项，那么环境遮蔽因子可以计算为视界上未遮挡部分的积分，或者，1减去视界下遮挡部分的积分:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015145622.png" class="" title="image-20211015145622">

<p><strong>式中h(φ)为切平面以上的地平角，t(φ)为切平面与视场矢量的切角，W(ω)为衰减函数。参见下图。的1/ 2π 项使积分标准化，使结果在0和1之间。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015145725.png" class="" title="image-20211015145725">

<p>基于水平的环境遮挡(左)找到切平面以上的水平角h，并整合它们之间的未遮挡角。切平面和视图向量之间的角度被记为t。地面真实环境遮挡(右)使用相同的地平线角度h1 和h2，但也使用法线和视图向量之间的角度γ，将余弦项纳入计算。在这两幅图中，相机都是从上方观察场景的。图中显示了横截面，水平角为φ的函数，φ是视角周围的角度。绿色的圆点表示从深度缓冲区读取的样本。黄色的点是正在计算遮挡的样本。</p>
<p><strong>对于给定的φ，利用到定义视界的点的距离上的线性衰减，我们可以解析地计算内部积分:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015145805.png" class="" title="image-20211015145805">

<p><strong>其余的积分是通过对几个方向取样并找到地平角进行数值计算的。</strong></p>
<p><strong>Jimenez等人也使用了基于水平的方法，他们称之为地面真实环境遮挡(GTAO)。他们的目的是获得地面真实结果，与射线追踪得到的结果相匹配，假设唯一可用的信息是z-缓冲区数据形成的高度场。基于水平的环境遮挡在其定义中不包括余弦项。它还增加了在11.8式中不存在的特别衰减，所以它的结果，即使与光线追踪的结果很接近，也不一样。GTAO引入了缺失的余弦因子，去除衰减函数，并在视图向量周围的参考坐标系中推导遮挡积分。遮挡因子定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015145902.png" class="" title="image-20211015145902">

<p><strong>在h1(φ)和h2(φ)为给定φ的左右视界角度，γ为法线方向与视界方向之间的角度。标准化术语1/ π 与HBAO不同，因为它包含了余弦项。这使得开放半球与π积分。公式中不包含余弦项，积分为2π。在高度场假设下，这个公式与11.8式完全匹配。参见上图。内积分仍然可以用解析方法求解，因此只需要对外积分进行数值计算。这个积分与HBAO中的方法相同，通过在给定像素周围采样多个方向来实现。</strong></p>
<p><strong>在基于水平的方法中，过程中最昂贵的部分是沿着屏幕空间线取样深度缓冲区以确定水平角度。Timonen提出了一种专门旨在改进性能特性的方法这一步。他指出，用于估算给定方向的视界角度的样本可以在屏幕空间中沿直线排列的像素之间大量重用。他将遮挡计算分为两个步骤。首先，他在整个z缓冲区执行线跟踪。在跟踪的每一步，他都会根据规定的最大影响距离，在沿着直线移动时更新视界角度，并将此信息写入缓冲区。为水平映射中使用的每个屏幕空间方向创建一个这样的缓冲区。缓冲区不需要与原始深度缓冲区的大小相同。它们的大小取决于线之间的间距，以及沿线的步骤之间的距离，在选择这些参数时有一定的灵活性。不同的设置会影响最终的质量。</strong></p>
<p><strong>第二步是根据缓冲区中存储的地平线信息计算遮挡因子。Timonen使用HBAO定义的遮挡因子(上上方程)，但可以使用其他遮挡估计器，如GTAO(上方程)。</strong></p>
<p><strong>深度缓冲并不是场景的完美表现，因为只有最近的对象被记录在一个给定的方向上，我们不知道它后面发生了什么。许多方法使用不同的启发式来尝试推断一些关于可见物体厚度的信息。在许多情况下，这些近似就足够了，眼睛可以原谅不准确的地方。虽然有一些方法使用多层深度来缓解这个问题，但由于与渲染引擎的复杂集成和高运行时成本，它们从未得到广泛的普及。</strong></p>
<p><strong>屏幕空间方法依赖于重复采样z缓冲区，以在给定点周围形成一些简化的几何模型。实验表明，要达到高质量的视觉效果，需要多达几百个样本。然而，为了便于交互渲染，最多只能采集10到20个样本，通常甚至更少。Jimenez等人报告称，为了符合60帧/秒游戏的性能预算，他们只能在每个像素中使用一个样本!为了在理论和实践之间架起桥梁，屏幕空间方法通常采用某种形式的空间抖动。在最常见的形式中，每个屏幕像素使用一组稍微不同的随机样本，并进行径向旋转或移动。在AO计算的主要阶段之后，执行全屏滤波。联合双边滤波(章节12.1.1)用于避免跨越表面不连续的滤波，并保持锐利的边缘。它使用有关深度或法线的可用信息来限制过滤只使用属于同一表面的样本。一些方法使用随机变化的采样模式和实验选择的滤波核;另一些使用固定大小的屏幕空间模式(例如，4 × 4像素)的重复样本集，以及一个限制在该邻域的过滤器。</strong></p>
<p><strong>环境遮挡计算也经常随时间进行超采样。这个过程通常是通过每帧应用不同的采样模式并对遮挡因子进行指数平均来完成的。使用上一帧的z缓冲区、相机变换和动态对象的运动信息，前一帧的数据被重新投影到当前视图。然后与当前帧结果混合。基于深度、标准或速度的试探法通常用于检测来自最后一帧的数据不可靠，应该被丢弃的情况(例如，因为一些新的对象进入了视图)。第5.4.2节在更一般的情况下解释了时间超采样和抗锯齿技术。时间滤波的成本很小，实现起来也很简单，尽管它并不总是完全可靠，但在实践中，大多数问题都是不明显的。这主要是因为环境遮挡从来没有直接可视化，它只是作为照明计算的输入之一。在将这个效果与法线贴图、反照纹理和直接照明相结合后，任何次要的伪影都被掩盖掉，不再可见。</strong></p>
<h3 id="Shading-with-Ambient-Occlusion-环境遮蔽的阴影"><a href="#Shading-with-Ambient-Occlusion-环境遮蔽的阴影" class="headerlink" title="Shading with Ambient Occlusion 环境遮蔽的阴影"></a>Shading with Ambient Occlusion 环境遮蔽的阴影</h3><p><strong>尽管我们已经在恒定的、远处的照明环境中导出了环境遮蔽值，我们也可以将其应用到更复杂的照明场景中。再次考虑反射方程:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015150713.png" class="" title="image-20211015150713">

<p><strong>上面的形式包含可见性函数v(l)，如11.3.1节所介绍的。</strong></p>
<p><strong>如果我们处理的是漫反射面，我们可以用朗伯BRDF替换f(l, v)，它等于次表面反照率ρss 除以π。我们得到了</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015150822.png" class="" title="image-20211015150822">

<p><strong>我们可以用上面的公式来表示</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015150901.png" class="" title="image-20211015150901">

<p><strong>如果我们使用11.8式中环境遮挡的定义，上面模拟</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015150919.png" class="" title="image-20211015150919">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015150934.png" class="" title="image-20211015150934">

<p><strong>这种形式给了我们一个新的角度来看待这个过程。上上式中的积分可以看作是对入射辐亮度Li应用方向滤波核K。</strong></p>
<p><strong>滤波器K在空间和方向上都以一种复杂的方式变化，但它有两个重要的特性。首先，由于夹紧点积，它最多覆盖了法线p点附近的半球。第二，由于分母上的归一因子，它在半球上的积分等于1。</strong></p>
<p><strong>为了进行遮光，我们需要计算两个函数乘积的积分，即入射亮度Li 和滤波器函数k。在某些情况下，可以用一种简化的方法来描述滤波器，并以相当低的代价计算这个二重积积分Li 和K用球谐表示(第10.3.2节)。处理这个方程复杂性的另一种方法是用一个具有类似性质的更简单的滤波器来近似这个滤波器。最常见的选择是归一化余弦核H:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015151403.png" class="" title="image-20211015151403">

<p><strong>当没有任何东西挡住射入的光线时，这个近似是准确的。它还涵盖了与我们正在近似的滤波器相同的角度范围。它完全忽略了能见度，但环境遮挡kA 项仍然存在于上上上方程中，因此在着色表面上会有一些可视的变暗。</strong></p>
<p><strong>选择了这个过滤内核，上上上等式就变成了</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015151522.png" class="" title="image-20211015151522">

<p><strong>这意味着，在其最简单的形式，着色与环境遮蔽可以通过计算辐照度并将其乘以环境遮挡值而形成。辐照度可以来自任何来源。例如，它可以从辐照度环境图中取样(章节10.6)。该方法的准确性只取决于近似的滤波器在多大程度上代表了正确的滤波器。对于在球体上平滑变化的光线，近似值给出了合理的结果。如果Li 在所有可能的方向上都是常数，即就好像场景被代表照明的全白色环境地图照亮。</strong></p>
<p><strong>这个公式也给了我们一些见解，为什么环境遮挡是一个较差的近似值的时点或小面积光源的能见度。它们只在表面上包含一个小的实心角度——在点灯的情况下是无穷小的——可见性函数对照明积分的值有重要的影响。它几乎以二进制的方式控制光的贡献，即。，它要么完全启用，要么完全禁用。忽略可见性，正如我们在公式11.25中所做的，是一个重要的近似，通常不会产生预期的结果。阴影缺乏清晰度，不显示任何预期的方向性，也就是说，似乎不是由特定的光产生的。环境遮挡不是一个好的选择建模的能见度这样的灯。其他方法，如阴影贴图，应该使用。然而，值得注意的是，有时小的，局部的光被用来模拟间接照明。在这种情况下，用环境遮挡值调制它们的贡献是合理的。</strong></p>
<p><strong>到目前为止，我们假设我们是在朗伯曲面上着色。当处理一个更复杂的非常数BRDF时，这个函数不能从积分中提出来，就像我们在方程11.20中做的那样。对于镜面材料，K不仅取决于能见度和法线，还取决于观看方向。典型微表面 BRDF的波瓣在域上发生显著变化。用一个单一的、预先确定的形状来近似它是太粗糙了，无法得出可信的结果。这就是为什么使用环境遮挡来做着色对漫反射BRDFs最有意义的原因。其他方法，将在接下来的章节中讨论，更适合更复杂的材料模型。</strong></p>
<p><strong>使用弯曲法线(见第448页的11.10式)可以看作是更精确地逼近滤波器K的一种方法。可见性项仍然没有出现在过滤器中，但它的最大值与平均未被遮挡方向匹配，这使得它总体上更接近11.23式。在几何法线和弯曲法线不匹配的情况下，使用后者将提供更准确的结果。Landis不仅将其用于环境地图的着色，还用于一些直接光照，而不是常规的阴影技术。</strong></p>
<p><strong>对于环境贴图的着色，Pharr提出了一种替代方案，使用GPU的纹理过滤硬件动态地执行过滤。滤波器K的形状是动态确定的。它的中心是弯曲法线的方向，它的大小取决于kA的值。这提供了与方程11.23中的原始过滤器更精确的匹配。</strong></p>
<h2 id="Directional-Occlusion-方向遮蔽"><a href="#Directional-Occlusion-方向遮蔽" class="headerlink" title="Directional Occlusion 方向遮蔽"></a>Directional Occlusion 方向遮蔽</h2><p><strong>尽管单独使用环境遮挡可以极大地提高图像的视觉质量，但它是一个大大简化的模型。当处理甚至是大面积的光源时，它提供了一个可怜的能见度近似，更不用说小的或准时的光源了。它也不能正确处理光滑的BRDFs或更复杂的照明设置。考虑一个被远处的顶灯照亮的表面，整个顶灯的颜色从红色变成绿色。这可能代表地面被来自天空的光线照亮——考虑到颜色，可能是在某个遥远的星球上。参见下图。即使环境遮挡会使点a和点b的光线变暗，它们仍然会被天空的红色和绿色部分照亮。使用弯曲的法线有助于缓解这种效果，但它也不是完美的。我们之前提出的简单模型不够灵活，无法处理这种情况。一种解决方案是用更有表现力的方式描述可见性。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015152408.png" class="" title="image-20211015152408">

<p>在复杂照明条件下，a和b点辐照度的近似颜色。环境遮挡不建模任何方向，所以颜色是相同的在两个点。使用弯曲的法线可以有效地将余弦波瓣移向天空中未被遮挡的部分，但由于积分范围没有受到任何限制，这不足以提供准确的结果。定向方法能够正确地消除来自天空闭塞部分的光线。</p>
<p><strong>我们将专注于编码整个球形或半球形可见性的方法，即用来描述哪个方向挡住了入射的辐射。虽然这个信息可以用来遮蔽准时的灯光，但这不是它的主要目的。针对这些特定类型的光的方法(在第7章中广泛讨论)能够获得更好的质量，因为它们需要为光源的单个位置或方向编码可见性。这里描述的解决方案主要用于为大面积光或环境照明提供遮挡生成的阴影是柔和的，由近似可见性引起的伪影是不明显的。此外，这些方法还可以用于在常规阴影技术不可行的情况下提供遮挡，如凹凸贴图细节的自阴影，以及超大场景的阴影，其中阴影贴图没有足够的分辨率。</strong></p>
<h3 id="Precomputed-Directional-Occlusion-预先计算的方向遮蔽"><a href="#Precomputed-Directional-Occlusion-预先计算的方向遮蔽" class="headerlink" title="Precomputed Directional Occlusion 预先计算的方向遮蔽"></a>Precomputed Directional Occlusion 预先计算的方向遮蔽</h3><p><strong>Max引入了水平映射的概念来描述高度场表面的自遮挡。在地平制图中，对于地面上的每一点，确定一组方位角方向的地平高度角，如八:北，东北，东，东南，在周围。</strong></p>
<p><strong>作为一个整体，未被遮挡的三维方向集可以被建模为一个椭圆形或圆形孔径，而不是存储某些给定罗盘方向的地平角。后一种技术称为环境光圈照明(下图)。这些技术的存储要求比地平线图低，但当未被遮挡的方向集不像椭圆形或圆形时，可能会导致不正确的阴影。例如，在一个平面上，每隔一定的间隔就会有一个高尖刺突出来，这个平面应该有一个星形的方向集，这就不能很好地映射到方案中。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015152743.png" class="" title="image-20211015152743">

<p>环境光圈照明近似于阴影点上方未遮挡区域的实际形状。在左边，区域光源用黄色显示，而地面位置的可见地平线用蓝色显示。在右边，地平线被简化为一个圆，这是从表面位置向上和向右突出的一个圆锥的边缘，用虚线显示。然后估计区域光的遮挡，通过将其圆锥与遮挡圆锥相交，得到红色显示的区域。</p>
<p><strong>遮挡技术有许多变体。Wang等人使用球面带符号距离函数(SSDF)来表示能见度。它编码一个带符号的距离到球体上被遮挡区域的边界。第10.3节中讨论的任何球形或半球形基也可以用于编码能见度。就像环境遮蔽一样，方向可见性信息可以存储在纹理、网格顶点或体积中。</strong></p>
<h3 id="Dynamic-Computation-of-Directional-Occlusion-方向遮蔽的动态计算"><a href="#Dynamic-Computation-of-Directional-Occlusion-方向遮蔽的动态计算" class="headerlink" title="Dynamic Computation of Directional Occlusion 方向遮蔽的动态计算"></a>Dynamic Computation of Directional Occlusion 方向遮蔽的动态计算</h3><p><strong>许多用于生成环境遮挡的方法也可以用来生成方向能见度信息。Ren等人的球谐指数法，以及Sloan等人的屏幕空间变量法产生球谐向量形式的可见性。如果使用一个以上的SH波段，这些方法本身就提供方向信息。使用更多的波段可以使编码可见性更精确。</strong></p>
<p><strong>如来自Crassin等和Wright的圆锥跟踪方法，为每个轨迹提供一个遮挡值。由于质量原因，即使是环境遮挡估计也使用多个轨迹，因此可用信息已经具有方向性。如果需要特定方向的能见度，我们可以追踪更少的锥。</strong></p>
<p><strong>Iwanicki也使用了圆锥追踪，但他将其限制在一个方向上。结果被用于生成由一组球体近似的动态特征投射到静态几何上的软阴影，类似于Ren等人和Sloan等人。在这个解决方案中，静态几何的光照使用AHD编码存储(章节10.3.3)。环境和方向组件的可见性可以独立处理。对环境部分的遮挡进行了解析计算。绘制单个圆锥并与球体相交以计算方向分量的衰减因子。</strong></p>
<p><strong>许多屏幕空间方法也可以扩展为提供定向遮挡信息。Klehm等人使用z-buffer数据计算屏幕空间弯曲锥，这些锥实际上是圆形孔径，很像Oat和Sander离线预计算的那些锥。当对一个像素的邻域采样时，它们对未遮挡方向求和。结果向量的长度可用于估计能见度锥的顶角，它的方向定义了这个锥的轴。Jimenez等人根据地平角估计圆锥轴方向，并从环境遮挡因子得出角度。</strong></p>
<h3 id="Shading-with-Directional-Occlusion-有方向遮蔽的着色"><a href="#Shading-with-Directional-Occlusion-有方向遮蔽的着色" class="headerlink" title="Shading with Directional Occlusion 有方向遮蔽的着色"></a>Shading with Directional Occlusion 有方向遮蔽的着色</h3><p><strong>有这么多不同的编码方向遮挡的方法，我们不能提供一个单一的处方如何执行着色。解决方案将取决于我们想要达到的具体效果。</strong></p>
<p><strong>让我们再次考虑反射方程，在一个入射辐亮度分裂为远处光照Li 的版本中及其能见度v:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015154705.png" class="" title="image-20211015154705">

<p><strong>我们能做的最简单的操作就是利用能见度信号对准时的灯光进行投影。由于大多数编码可见性的方法都很简单，所以结果的质量往往不能令人满意，但它允许我们根据一个基本的例子进行推理。这种方法也可以用于传统的阴影方法由于分辨率不足而失败的情况，结果的精度比实现任何形式的遮挡都不重要。这种情况的例子包括非常大的地形模型，或者用凹凸贴图表示的小的表面细节。</strong></p>
<p><strong>在第9.4节讨论之后，当处理准时照明时，上式变成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015154754.png" class="" title="image-20211015154754">

<p><strong>其中clight 是在面对光线的白色朗伯式表面反射出的亮度，而lc 是指向光的方向。我们可以将上述方程解释为计算材料对未遮挡光的响应，并将结果乘以能见度函数的值。如果光的方向落在地平线下(当使用地平线贴图时)，在能见度锥外(当使用环境光圈照明时)，或在SSDF的负区域，能见度函数等于零，因此光的任何贡献都不应该被考虑。值得一提的是，尽管可见性被定义为二进制函数，许多表示形式可以返回整个范围的值，而不仅仅是0或1。这样的值表示部分遮挡。球谐或H基甚至可以重建负值，由于振铃。这些行为可能是不需要的，但只是编码的固有属性。</strong></p>
<p><strong>我们可以对区域灯的照明进行类似的推理。在这种情况下是Li 在任何地方都等于零，除了在光线所面对的立体角内，它等于这个光源发出的亮度。我们称它为Ll 假设它在光的实心角度上是恒定的。我们可以用光的实心角度的积分Ω代替整个球面的积分Ωl：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165151.png" class="" title="image-20211015165151">

<p><strong>如果我们假设BRDF是常数——所以我们在处理一个朗伯曲面——它也可以从积分下面拉出来:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165225.png" class="" title="image-20211015165225">

<p><strong>为了确定遮挡光照，我们需要计算能见度函数乘以余弦项除以光线所覆盖的立体角的积分。在某些情况下，这可以通过分析来实现。Lambert推导了一个计算球面多边形上余弦积分的公式。如果我们的区域光是多边形的，并且我们可以将它与可见性表示进行剪辑，那么我们只需要使用Lambert公式来得到一个精确的结果(下图)。这是可能的，例如，当我们选择视界角度作为我们的可见性表示。然而，如果由于某种原因我们选择了另一种编码，例如弯曲锥，剪切将产生圆形段，我们不能再使用Lambert公式。同样，如果我们想使用非多边形区域灯。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165308.png" class="" title="image-20211015165308">

<p>一个黄色多边形光源可以投射到一个单位半球上的阴影点，形成一个球形多边形。如果能见度是用地平线映射来描述的，那么这个多边形可以被裁剪到它上面。红色裁剪多边形的余弦加权积分可以用朗伯公式进行解析计算。</p>
<p><strong>另一种可能是假设余弦项的值在整个积分域中是常数。如果光的面积很小，这个近似是相当精确的。为了简单起见，我们可以使用余弦值在区域光的中心方向的值。这就剩下能见度项对光线立体角的积分了。我们的选择取决于，我们的可见性表示和面灯类型的选择。如果我们使用球面光和弯曲锥表示的能见度，积分的值是能见度锥与光线所面对的锥交点的立体角。它可以通过解析计算得到，如Oat和Sander所示。虽然确切的公式很复杂，但它们提供了一个在实践中很有效的近似。如果能见度用球谐编码，积分也可以用解析方法计算。</strong></p>
<p><strong>对于环境照明，我们不能限制集成范围，因为照明来自四面八方。我们需要找到一种方法来计算11.26式的完整积分。让我们首先考虑朗伯BRDF:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165404.png" class="" title="image-20211015165404">

<p><strong>这个方程中的积分类型称为三重积积分。如果单个函数以特定的方式表示——例如，球谐函数或小波函数——它就可以通过分析来计算。不幸的是，这对于典型的实时应用程序来说太昂贵了，尽管这种解决方案已经被证明在简单的设置下以交互帧率运行。</strong></p>
<p><strong>我们的特殊情况稍微简单一点，因为其中一个函数是cos。我们可以把上式写成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165453.png" class="" title="image-20211015165453">

<p><strong>或</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165510.png" class="" title="image-20211015165510">

<p><strong>其中</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165519.png" class="" title="image-20211015165519">

<p><strong>这两个ˉLi(l)和ˉv(l)是球面函数，就像Li(l)和v (l)一样。与其计算三重积积分，不如先把cos乘以Li (上上上式)或vi 方程(上上式)。这样做使得被积函数只是两个函数的乘积。虽然这看起来可能只是一个数学技巧，但它显著简化了计算。如果因数用标准正交基表示，如球谐，则可以简单地计算二重积积分。它是它们系数向量的点积(第10.3.2节)。</strong></p>
<p><strong>我们仍然需要计算ˉLi(l)或者ˉv(l)但是因为它们包含了cos，这比完全一般的情况要简单。如果我们用球谐来表示函数，余弦投影到区域谐波(ZH)，一个球谐的子集，每个波段只有一个系数是非零的(章节10.3.2)。这个投影的系数有简单的解析公式。一个SH和一个ZH的乘积比一个SH和另一个SH的乘积的计算效率要高得多。</strong></p>
<p><strong>如果我们决定先将cos乘以v(上上方程)，我们可以离线进行，而不是只存储可见性。正如Sloan等人(第11.5.3节)所描述的，这是一种预先计算的亮度传递形式。然而，在这种形式下，我们不能对法线进行任何精细的修改，因为由法线控制的余弦项已经与可见性融合在一起了。如果我们想要模拟精确尺度的法向细节，我们可以用Li 乘以cos第一个方程(11.31)。由于我们事先不知道法线方向，我们可以预先计算不同法线的乘积，或者在运行时执行乘法。预计算Li 的乘积而离线余弦意味着，反过来，任何照明的改变都是受限制的，而允许照明在空间上改变将需要大量的内存。另一方面，在运行时计算产品在计算上是昂贵的。Iwanicki和Sloan描述了如何降低成本。产品可以在较低的粒度上计算——在它们的情况下，在顶点上。结果与余弦项进行卷积，投影到一个更简单的表示(AHD)上，然后用逐像素法向量插值并重建。这种方法允许他们在性能要求为60 FPS的游戏中使用这种方法。</strong></p>
<p><strong>Klehm等人提出了一种用环境地图和用圆锥体编码的能见度表示照明的解决方案。他们用不同大小的核过滤环境地图，这些核代表了一个产品的可视性和不同锥开口的照明的整体。它们存储在纹理的mip级别中增加锥角的结果。这是可能的，因为大锥角的预过滤结果在球体上平滑地变化，不需要以高角度分辨率存储。在预滤波时，他们假设视锥的方向与法线对齐，这是一个近似，但在实践中给出了可信的结果。他们分析了这种近似是如何影响最终质量的。</strong></p>
<p><strong>如果我们要处理光滑的BRDFs和环境照明，情况会更加复杂。我们不能再把BRDF从积分下面拉出来了，因为它不是常数。为了解决这个问题，Green等人建议用一组球面高斯函数来近似BRDF本身。这些是径向对称函数，可以只用三个参数来紧密表示:方向(或均值)d，标准差µ，和振幅w。近似的BRDF定义为球面高斯函数的和:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015165955.png" class="" title="image-20211015165955">

<p><strong>其中G(d，µ，l)为球形高斯瓣，方向为d，具有锐度µ(章节10.3.2)，wk 在第k波瓣的振幅中。对于一个各向同性BRDF，波瓣的形状只取决于法线和视图方向之间的角度。近似可以存储在一维查找表中并进行插值。</strong></p>
<p><strong>根据这个近似，我们可以把11.26式写成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015170038.png" class="" title="image-20211015170038">

<p><strong>Green等人还假设能见度函数在每个球形高斯的整个支持范围内是恒定的，这允许他们将其从积分下拉出来。他们在波瓣中心方向评估能见度函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015170113.png" class="" title="image-20211015170113">

<p><strong>剩下的积分表示入射光与给定方向和给定标准偏差的球面高斯卷积。这种卷积的结果可以被预先计算并存储在环境地图中，较大的卷积存储在较低的mip层中。可见性用低阶球面谐波编码，但也可以使用任何其他表示，因为它只是点计算。</strong></p>
<p><strong>Wang等人以类似的方式近似BRDF，但以更精确的方式处理可见性。他们的表示允许他们计算一个单球面高斯在支持的可见性函数的积分。他们用这个值来引入一个新的球面高斯函数，它具有相同的方向和标准偏差，但振幅不同。他们在计算光照时使用这个新功能。</strong></p>
<p><strong>对于某些应用程序，这种方法可能过于昂贵。它需要从预过滤的环境地图中获取多个样本，而纹理采样通常已经是渲染过程中的一个瓶颈。Jimenez等人和El Garawany提出了更简单的近似。为了计算遮挡因子，它们用单个锥代表整个BRDF瓣，忽略其对视角的依赖，只考虑材料粗糙度等参数(下图)。他们将能见度近似为一个圆锥体，并计算能见度和BRDF圆锥体相交的立体角，就像对环境光圈照明所做的那样。标量结果被用来衰减光照。尽管它是一个显著的简化，结果是可信的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015170248.png" class="" title="image-20211015170248">

<p>为了计算遮挡，有光泽材料的镜面瓣可以表示为一个锥体。如果能见度近似为另一个锥体，遮挡因子可以计算为两者交点的实心角度，方法与环境光圈照明相同(上上图)。该图像显示了用锥表示BRDF波瓣的一般原理，但只是作为一种说明。在实践中，为了产生貌似合理的遮挡效果，锥体需要更宽一些。</p>
<h2 id="Diffuse-Global-Illumination-漫反射全局光照"><a href="#Diffuse-Global-Illumination-漫反射全局光照" class="headerlink" title="Diffuse Global Illumination 漫反射全局光照"></a>Diffuse Global Illumination 漫反射全局光照</h2><p><strong>接下来的部分将涵盖模拟各种方法，不仅是遮挡，还包括实时的全光反射。它们可以大致分为两种算法，即假设光线在到达人眼之前会从漫反射面或镜面反射。相应的光路可以分别写成L(D |S)∗DE或L(D|S)∗SE，其中许多方法对早期反弹的类型施加了一些约束。第一组的解决方案假设入射光在阴影点上方的半球上平滑地变化，或者完全忽略这种变化。第二组算法假设在入射方向上有很高的变化率。它们依赖于这样一个事实，即光线只能在一个相对较小的实心角度内进入。由于这些约束有很大的不同，分开处理这两组是有益的。我们将在这一节介绍漫反射全局照明的方法，下一节介绍镜面照明，然后在最后一节介绍统一的方法。</strong></p>
<h3 id="Surface-Prelighting-表面预照明"><a href="#Surface-Prelighting-表面预照明" class="headerlink" title="Surface Prelighting 表面预照明"></a>Surface Prelighting 表面预照明</h3><p><strong>辐射度和路径跟踪都是为离线使用而设计的。虽然已经有人在实时设置中使用它们，但结果仍然太不成熟，不能用于生产。目前最常见的做法是使用它们来预计算光照相关的信息。这种昂贵的离线过程会提前运行，其结果会被存储起来，然后在显示过程中使用，以提供高质量的照明。如第11.3.4节所述，以这种方式对静态场景进行预计算称为烘培。</strong></p>
<p><strong>这种做法有一定的限制。如果我们提前执行光照计算，我们就不能在运行时更改场景设置。所有场景的几何形状、灯光和材料需要保持不变。我们不能改变时间，也不能在墙上炸个洞。在许多情况下，这种限制是可以接受的。建筑可视化可以假设用户只能在虚拟环境中行走。游戏也会限制玩家的行动。在这些应用中，我们可以把几何分为静态和动态对象。静态对象在预计算过程中使用，它们与照明完全交互。静态的墙投射阴影和静态红地毯反射红光。动态对象只能作为接收者。它们不会阻挡光线，也不会产生间接照明效果。在这种情况下，动态几何通常被限制为相对较小的，所以它对其他照明的影响可以忽略或使用其他技术建模，以最小的质量损失。例如，动态几何学可以使用屏幕空间方法来生成遮挡。一组典型的动态对象包括角色、装饰几何体和车辆。</strong></p>
<p><strong>可以预先计算的最简单的照明信息形式是辐照度。对于平面，朗伯的表面，连同表面颜色，它完全描述了材料对光线的反应。由于光源的效果是独立于其他光源的，因此可以在预先计算的辐照度上添加动态光源(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015205157.png" class="" title="image-20211015205157">

<p>给定一个具有已知法线的朗伯曲面，就可以预先计算出它的辐照度。在运行时，这个值乘以实际的表面颜色(例如，从纹理)来获得反射的亮度。根据表面颜色的确切形式，可能需要额外除以π以确保节能。</p>
<p><strong>1996年的Quake和1997年的Quake II是第一个使用预先计算的辐照度值的商业交互式应用程序。Quake预先计算了静态光的直接贡献，主要是作为一种提高性能的方法。《雷神之锤2》也包含了一个间接组件，这使得它成为第一款使用全局光照算法来生成更真实光照的游戏。它使用了一种基于辐射的算法，因为这种技术非常适合在朗伯环境中计算辐照度。此外，记忆的时间限制限制了照明的相对低分辨率，这与模糊，低频阴影典型的辐射解决方案。</strong></p>
<p><strong>预先计算的辐照度值通常与漫反射颜色或反照率地图相乘，存储在一个单独的纹理集。虽然在理论上可以预先计算出出度(辐照度乘以漫射颜色)并存储在一组纹理中，但在大多数情况下，许多实际考虑都排除了这个选项。颜色地图的使用频率通常很高，它们使用各种各样的贴图，并且它们的部分经常在模型中被重用，所有这些都是为了保持合理的内存使用。辐照度值的频率通常要低得多，不容易重复使用。保持光照和表面颜色分离会消耗更少的内存。</strong></p>
<p><strong>目前，除了最严格的硬件平台外，很少使用预先计算的辐照度。由于根据定义，辐照度是在给定的法线方向上计算的，因此我们不能使用法线映射来提供高频细节。这也意味着只能预先计算平面的辐照度。如果我们需要在动态几何体上使用烘烤光照，我们需要其他方法来存储它。这些限制促使人们寻找一种方法来存储带有方向组件的预计算光照。</strong></p>
<h3 id="Directional-Surface-Prelighting-定向表面预照明"><a href="#Directional-Surface-Prelighting-定向表面预照明" class="headerlink" title="Directional Surface Prelighting 定向表面预照明"></a>Directional Surface Prelighting 定向表面预照明</h3><p><strong>为了在朗伯曲面上使用预光照和法线映射，我们想要一种方法来表示辐照度如何随表面法线变化。为动态几何提供间接照明，我们还需要它的值为每个可能的表面方向。幸运的是，我们已经有了表示这些函数的工具。在第10.3节中，我们描述了根据法线方向确定光照的各种方法。这包括函数域是半球形的情况下的特殊解决方案，球体下半部分的值无关紧要，就像不透明表面的情况一样。</strong></p>
<p><strong>最常用的方法是存储全球面辐照度信息，例如利用球面谐波。该方案首先由Good和Taylor在加速光子映射的背景下提出，并由Shopf等人在实时设置中使用。在这两种情况下，方向辐照度都存储在纹理中。如果使用九个球谐系数(三阶SH)，质量很好，但存储和带宽成本很高。仅仅使用四个系数(二阶SH)是比较便宜的，但是许多细微之处会丢失，灯光对比度更低，法线贴图也不那么明显。</strong></p>
<p><strong>Chen在光晕3中使用了一种方法的变体，开发该方法是为了以更低的成本实现三阶SH的质量。他从球形信号中提取出最主要的光，并将其分别存储为颜色和方向。残差使用二阶SH编码，这将系数的数目从27减少到18，几乎没有质量损失。Hu描述了如何进一步压缩这些数据。Chen和Tatarchuk提供了他们在生产中使用的基于GPU的烘烤管道的进一步信息。</strong></p>
<p><strong>Habel等人提出的H基是另一种解决方案。由于它只编码半球信号，较少的系数可以提供与球面谐波相同的精度。只需6个系数就可以得到与三阶SH相当的质量。因为基是为一个半球定义的，我们需要在表面上的一些局部坐标系来正确地定位它。通常，由紫外线参数化得到的切线框架用于此目的。如果将h基组件存储在纹理中，其分辨率应该足够高，以适应底层切线空间的变化。如果多个切线空间显著不同的三角形覆盖同一像素，重构信号将不精确。</strong></p>
<p><strong>球谐和H基的一个问题是它们可以表现出振铃(章节10.6.1)。虽然预滤波可以缓和这种效果，但它也可以使光线更平滑，这可能并不总是可取的。此外，即使是价格较低的变体，在存储和计算方面的成本也相对较高。在更严格的情况下，例如在低端平台或在呈现虚拟现实时，这种开销可能会令人望而却步。</strong></p>
<p><strong>成本是简单的替代品仍然受欢迎的原因。《半条命2》使用自定义的半球形基础(第10.3.3节)，存储三个颜色值，每个样本共九个系数。环境/高光/方向(AHD)基础(章节10.3.3)也是一个受欢迎的选择，尽管它很简单。它已被用于《使命召唤》系列和《最后生存者》等游戏中。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015211436.png" class="" title="image-20211015211436">

<p>《使命召唤:第二次世界大战》使用了AHD表示法来编码光照地图中光照的方向变化。该网格用于在调试模式中可视化光地图密度。每个正方形对应一个光贴图texel。(图片由动视出版公司提供，2018年)</p>
<p><strong>Crytek在《孤岛惊魂》中使用了一种变体。Crytek表示法由切线空间中的平均光方向、平均光色和标量方向因子组成。最后一个值用于混合环境和方向组件，它们都使用相同的颜色。这将每个样本的存储减少到6个系数:3个颜色值，2个方向值，1个方向因子值。Unity引擎也在其中一个模式中使用了类似的方法。</strong></p>
<p><strong>这种类型的表示是非线性的，这意味着，从技术上讲，线性插值单个组件，无论是在像素或顶点之间，都不是数学的正确。如果主导光的方向变化迅速，例如在阴影边界上，视觉伪影可能会出现在阴影中。尽管有这些不准确之处，但结果在视觉上还是令人满意的。由于环境和方向光照区域之间的高对比度，法线贴图的效果被强调，这通常是可取的。此外，方向性成分可以用于计算BRDF的镜面反射响应，为低光泽材料的环境地图提供低成本的替代方案。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015211620.png" class="" title="image-20211015211620">

<p>The Order:1886存储投射到一组球面高斯叶上的入射亮度。在运行时，将亮度与余弦瓣进行卷积以计算漫反射响应(左图)，并使用适当形状的各向异性球面高斯函数生成镜面响应(右图)。(图片由Ready at Dawn Studios提供，版权为索尼互动娱乐公司。)</p>
<p><strong>在光谱的另一端是为高视觉质量设计的方法。Neubelt和Pettineo在游戏《the Order: 1886》(上图)中使用纹理贴图存储球形高斯系数。它们存储的不是辐照度，而是入射辐亮度，它被投影到一组高斯叶(章节10.3.2)，在切线框架中定义。根据特定场景中灯光的复杂程度，他们使用5到9个瓣叶。为了产生扩散响应，球面高斯函数与沿表面法线方向的余弦瓣进行卷积。通过将高斯波与高光BRDF波瓣进行卷积，这种表示法也足够精确，足以提供低光泽的镜面效果。Pettineo详细描述了整个系统。他还提供了一个能够烘培和渲染不同照明表示的应用程序的源代码。</strong></p>
<p><strong>如果我们需要关于任意方向的照明信息，而不仅仅是在表面上方的一个半球内(例如，为动态几何体提供间接照明)，我们可以使用编码完整球形信号的方法。球面谐波在这里是很自然的。当记忆不那么重要时，三阶SH(每个颜色通道九个系数)是最受欢迎的选择;否则，将使用二阶系数(每个颜色通道有四个系数，这与RGBA纹理中的组件数量相匹配，因此一个地图可以存储一个颜色通道的系数)。球面高斯函数也可以在一个完全球形的环境下工作，因为叶状结构可以分布在整个球体上，也可以只分布在法线周围的半球上。然而,由于对于球形技术来说，需要被瓣覆盖的立体角是两倍大，我们可能需要使用更多瓣来保持相同的质量。</strong></p>
<p><strong>如果我们想避免处理振铃，但又负担不起使用大量的瓣，环境立方体(第10.3.1节)是一个可行的选择。它由6个沿长轴固定的cos²瓣组成。每个余弦叶只覆盖一个半球，因为它们有局部支持，这意味着它们只有在其球域的子集上有非零值。因此，在重建过程中只需要六个存储值中的三个可见叶。这限制了照明计算的带宽成本。重构质量与二次球面谐波相似。</strong></p>
<p><strong>环境骰子(也是第10.3.1节)可以用于比环境立方体更高的质量。该方案使用沿二十面体顶点方向的12个瓣，这些瓣是cos²和cos⁴瓣的线性组合。存储的12个值中有6个在重构期间使用。其质量可与三阶球面谐波相媲美。这些和其他类似的表示(例如，由三个cos²组成的基) 叶和余弦叶扭曲覆盖一个实心球)已经使用在许多商业成功的游戏,比如半条命2,《使命召唤》系列,Far Cry 3,Tom Clancy’s The Division,和刺客信条4:黑旗,等等。</strong></p>
<h3 id="Precomputed-Transfer-预先计算的变换"><a href="#Precomputed-Transfer-预先计算的变换" class="headerlink" title="Precomputed Transfer 预先计算的变换"></a>Precomputed Transfer 预先计算的变换</h3><p><strong>虽然预先计算的光照看起来令人惊叹，但它本身也是静态的。任何几何体或照明的改变都会使整个解决方案失效。就像在现实世界中一样，打开窗帘(局部改变场景中的几何形状)可能会使整个房间充满光(全局改变照明)。人们花费了大量的研究工作来寻找能够允许某些类型变化的解决方案。</strong></p>
<p><strong>如果我们假设场景的几何形状没有变化，只改变了灯光，我们就可以预先计算光线如何与模型交互。物体间效应，如相互反射或地下散射，可以预先分析到一定程度，并将结果存储起来，而无需对实际辐射值进行操作。将入射光线转化为整个场景中亮度分布的描述的函数称为传递函数。预先计算这个的解决方案称为预先计算转移或预先计算辐射转移(PRT)方法。</strong></p>
<p><strong>与完全脱机烘培照明不同，这些技术确实有明显的运行成本。当在屏幕上显示场景时，我们需要计算特定照明设置的亮度值。为了做到这一点，直接光的实际数量被“注入”到系统中，然后传递函数被应用到整个场景中。有些方法假设这种直接光照来自环境地图。其他方案允许照明设置是任意的，并以灵活的方式改变。</strong></p>
<p><strong>斯隆等人将预先计算的亮度传递概念引入图形。他们用球谐来描述它，但方法不必使用SH，基本思想很简单。如果我们使用一些(最好是较低的)“构建块”灯来描述直接照明，我们就可以预先计算每个灯如何照亮场景。假设一个房间里有三台电脑显示器，每个显示器只能显示一种颜色，但亮度不同。考虑每个屏幕的最大亮度等于1，一个标准化的“单位”亮度。我们可以独立地预估每个显示器对房间的影响。这个过程可以使用第11.2节中介绍的方法来完成。因为光传输是线性的，用所有三个显示器照亮场景的结果将等于每个显示器直接或间接发出的光的总和。每个显示器的照明不会影响其他解决方案，所以如果我们将其中一个屏幕的亮度设置为原来的一半，这样做只会改变它对总照明的贡献。</strong></p>
<p><strong>这使我们能够快速计算整个房间内的全部反射光线。我们将每一个预先计算的光解乘以屏幕的实际亮度，并将结果相加。我们可以打开或关闭显示器，使它们更亮或更暗，甚至改变它们的颜色，所有需要得到的最终照明是这些倍数和添加(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015212627.png" class="" title="image-20211015212627">

<p>使用预先计算的亮度传递的渲染示例。从三个显示器的全部照明运输分别预先计算，获得一个“单位”响应。由于光传输的线性，这些单独的解决方案可以乘以屏幕的颜色(这里的例子中是粉色、黄色和蓝色)来获得最终的照明。</p>
<p><strong>我们可以写</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015212717.png" class="" title="image-20211015212717">

<p><strong>L(p)是p, Li(p)为屏幕i预计算的单位贡献，wi 就是它当前的亮度。这个方程用Li 定义了一个数学意义上的向量空间是这个空间的基向量。任何可能的照明都可以由灯光贡献的线性组合创建。</strong></p>
<p><strong>斯隆等人的原始PRT论文使用了相同的推理，但是在使用球面谐波表示的无限远的照明环境的背景下。它们不是存储场景对监视器屏幕的响应，而是存储场景对周围光线的响应，其分布由球谐基函数定义。通过这样做一些SH波段，他们可以渲染一个场景照明任意的照明环境。他们将这个照明投射到球面谐波上，将每个结果系数乘以其各自的标准化“单位”贡献，然后将这些加在一起，就像我们在监视器上做的那样。</strong></p>
<p><strong>请注意，用于将光线“注入”到场景中的基础的选择是独立于用于表达最终照明的表示的。例如，我们可以用球谐来描述场景是如何被照亮的，但是选择另一个基底来存储在任何给定点到达的亮度。假设我们用一个环境立方体来储存。我们可以计算出有多少光辉来自顶部，有多少来自侧面。每个方向的转移将被单独存储，而不是作为代表总转移的单个标量值。</strong></p>
<p><strong>斯隆等人的PRT论文分析了两个案例。第一种是当接收基只是表面的标量辐照度值时。为此，接收器需要是一个完全扩散的表面，与预定法线，这意味着它不能使用法线地图为精细的细节。传递函数的形式是输入光照的SH投影和预先计算的传递向量之间的点积，它在场景中随空间变化。</strong></p>
<p><strong>如果我们需要渲染非朗伯材料，或者允许法线映射，我们可以使用第二种变体。在这种情况下，将周围光线的SH投影转换为某一给定点的入射亮度的SH投影。因为这个操作为我们提供了整个球体(或半球，如果我们处理的是一个静态不透明物体)的亮度分布，我们可以适当地将它与任何BRDF卷积。传递函数将SH向量映射到其他SH向量，并具有矩阵乘法的形式。这个乘法运算在计算和内存方面都很昂贵。如果我们对源和接收器都使用三阶SH，我们需要为场景中的每个点存储9×9矩阵，这些数据仅用于单色传输。如果我们想要颜色，我们需要三个这样的矩阵——每个点都有难以置信的内存。</strong></p>
<p><strong>一年后，斯隆等人解决了这个问题。不直接存储传输向量或矩阵，而是使用主成分分析(PCA)技术对它们的整个集合进行分析。传递系数可以考虑多维空间中的点(例如，在81维的情况下，9 × 9矩阵)，但它们的集合在该空间中不是均匀分布的。它们形成低维度的簇。这种集群就像三维空间的一维子空间中的三维点沿直线分布一样有效。PCA可以有效地检测这种统计关系。一旦发现了一个子空间，点就可以用更少的坐标表示，因为我们可以用更少的维数存储子空间中的位置。用直线类比，不是用三个坐标存储点的全部位置，我们可以只存储点沿直线的距离。Sloan等人使用这种方法将转移矩阵的维数从625维(25 × 25转移矩阵)降至256维。虽然这对于典型的实时应用程序来说仍然过高，但许多后来的轻传输算法已经采用PCA作为压缩数据的方法。</strong></p>
<p><strong>这种类型的降维本质上是有损的。在极少数情况下，数据会形成一个完美的子空间，但大多数情况下它是近似的，所以将数据投射到它上面会导致一些退化。为了提高质量，Sloan等人将转移矩阵集合划分为簇，并分别对每个簇执行PCA。该过程还包括一个优化步骤，以确保在集群边界上没有不连续。还提出了一种允许物体有限变形的扩展，称为局部可变形预计算辐射转移(LDPRT)。</strong></p>
<p><strong>PRT已经在一些游戏中以各种形式被使用。在那些游戏玩法侧重于户外区域(游戏邦注:这些区域的时间和天气状况会发生动态变化)的游戏中，这种方法尤其受欢迎。《孤岛惊魂3》和《孤岛惊魂4》使用PRT，其中源基础是二阶SH，接收基础是定制的四方向基础。《刺客信条4:黑旗》使用一种基本功能作为源(太阳色)，但会预计算一天中不同时间的转移。这种表示可以解释为在时间维度而不是方向上定义源基函数。接收器基础与《孤岛惊魂》中使用的相同。</strong></p>
<p><strong>关于预计算辐射传递的SIGGRAPH 2005课程提供了该领域研究的一个很好的概述。Lehtinen给出了一个数学框架，可以用来分析各种算法之间的差异，并开发新的算法。</strong></p>
<p><strong>最初的PRT方法假设周围的光线无限远。虽然这个模型的室外场景照明相当好，但它对室内环境的限制太大。然而，正如我们前面提到的，这个概念完全不知道照明的初始来源。Kristensen等人描述了一种计算整个场景中一组散射光的PRT的方法。这相当于拥有大量的“源”基函数。接下来，这些光被组合成簇，接收的几何图形被分割成区域，每个区域受不同子集的光的影响。这个过程导致传输数据的显著压缩。在运行时，由任意放置的光源产生的照明是通过从预计算集中最接近的光源中插值数据来近似的。Gilabert和Stefanov在《Far Cry 3》中使用这种方法生成间接照明。这种方法的基本形式只能处理点光源。而它可以扩展到支持其他类型，成本随着每个光的自由度的数量呈指数增长。</strong></p>
<p><strong>在这一点上讨论的PRT技术预先计算从一些元素的转移，然后使用这些元素建模的灯。另一类流行的方法是预计算曲面之间的转换。在这种类型的系统中，照明的实际来源变得无关紧要。任何光源都可以使用，因为这些方法的输入是某一组表面发出的辐亮度(或者其他一些相关的量，如辐照度，如果方法假设只扩散表面)。这些直接照明计算可以使用阴影(第7章)，辐照度环境图(第10.6节)，或本章前面讨论的环境和方向遮挡方法。任何表面也可以简单地通过设置其发出的亮度到一个期望的值，把它变成一个区域光源。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015213042.png" class="" title="image-20211015213042">

<p>几何启发可以实时生成全局光照效果。下图展示了它与Unity引擎整合的例子。用户可以自由地改变一天的时间，以及打开和关闭灯。所有间接照度实时更新。(庭院演示c Unity Technologies, 2015)</p>
<p><strong>根据这些原则运行的最流行的系统是Enlighten by Geomerics(上图)。虽然该算法的确切细节从未被完全公开，但无数的演讲和演讲给出了该系统原理的准确图像。</strong></p>
<p><strong>场景被假定为兰伯特式的，但仅仅是为了光转移的目的。使用Heckbert表示法，处理的路径集为LD∗(D|S)E，因为眼前的最后一个表面不需要仅进行扩散。系统定义了一组“源”元素和另一组“接收”元素。源元素存在于表面上，并且共享它们的一些属性，如漫反射颜色和法线。的预处理步骤计算光如何在源元素和接收器之间传输。这种信息的确切形式取决于源元素是什么，以及在接收器上收集光线的基础是什么。在最简单的形式中，源元素可以是点，然后我们感兴趣的是在接收位置产生辐照度。在这种情况下，传输系数就是源与接收者之间的相互可见性。在运行时，向系统提供所有源元件的出射亮度。根据这些信息，我们可以利用预先计算的能见度和已知的源和接收机的位置和方向信息，数值积分反射率方程(方程11.1)。用这种方法，光的一次反弹就完成了。由于大部分的间接照明来自于第一次反射，仅进行一次反射就足以提供合理的照明。然而，我们可以使用这个光并再次运行传播步骤来生成第二次光反弹。这通常是在几帧的过程中完成的，其中一帧的输出被用作下一帧的输入。</strong></p>
<p><strong>使用点作为源元素会导致大量的连接。为了提高性能，表示相似法线和颜色区域的点簇也可以用作源集。在这种情况下，传递系数与在辐射度算法中看到的形状因子相同(第11.2.1节)。请注意，尽管有相似之处，该算法与经典的辐射度不同，因为它每次只计算一次光的反弹，不涉及解线性方程组。它借鉴了渐进式辐射的概念。在这个系统中，一个小块可以通过迭代过程确定它从其他小块接收到多少能量。把辐射度传送到接收位置的过程称为收集。</strong></p>
<p><strong>接收元件上的辐射可以以不同的形式收集。向接收单元的传输可以使用我们前面描述的任何方向基。在这种情况下，单个系数成为一个值向量，其维数等于接收基中的函数数。当使用定向表示进行收集时，结果与第11.5.2节中描述的离线解决方案相同，因此它可以与法线映射一起使用，或提供低光泽度的镜面响应。</strong></p>
<p><strong>同样的概念在许多变体中被使用。为了节省内存，Sugden和Iwanicki使用SH转移系数，量化它们，并将它们间接存储为调色板中某项的索引。Jendersie等人构建了源补丁的层次结构，并在子节点所照顾的立体角太小时存储对该树中较高元素的引用。Stefanov引入了一个中间步骤，在这个步骤中，来自表面元素的辐射首先传播到场景的体素化表示，随后作为传输的源。</strong></p>
<p><strong>(在某种意义上)理想的表面分割成源块取决于接收器的位置。对于远处的元素，将它们视为独立的实体会产生不必要的存储成本，但在近距离观察时应该单独处理它们。源补丁的层次结构在一定程度上缓解了这个问题，但并不能完全解决它。某些补丁可以组合为特定的重新Ceivers之间的距离可能足以阻止这种合并。Silvennoinen和Lehtinen提出了一种解决这个问题的新方法。他们的方法不是显式地创建源补丁，而是为每个接收位置生成一组不同的源补丁。对象被渲染到散落在场景周围的一组稀疏的环境地图中。每个地图都被投影到球谐，这个低频版本“几乎”被投影回环境中。接收点记录他们能看到多少投影，这个过程是针对每个发送者的SH基函数分别完成的。这样做会根据来自环境探测和接收点的可见性信息，为每个接收方创建一组不同的源元素。</strong></p>
<p><strong>因为源基础是由环境地图投影到SH生成的，所以它自然地结合了较远处的表面。为了选择要使用的探测器，接收者使用了一种倾向于附近探测器的启发式方法，这使得接收者以类似的规模“看到”环境。为了限制必须存储的数据量，使用集群PCA对传输信息进行压缩。</strong></p>
<p><strong>Lehtinen等人描述了另一种预计算转移形式。在这种方法中，源和接收单元都不存在于网格中，而是具有体积的，可以在三维空间的任何位置进行查询。这种形式可以方便地在静态和动态几何之间提供光照一致性，但这种方法在计算上相当昂贵。</strong></p>
<p><strong>Loos等人在具有不同侧壁配置的模块化单元内预计算转移。然后缝合和弯曲多个这样的细胞，以近似的几何场景。亮度首先传播到作为界面的细胞边界，然后使用预先计算的模型传播到邻近的细胞。即使在移动平台上，这种方法也足够快速有效地运行，但由此产生的质量可能不足以满足要求更高的应用程序。</strong></p>
<h3 id="Storage-Methods-存储方法"><a href="#Storage-Methods-存储方法" class="headerlink" title="Storage Methods 存储方法"></a>Storage Methods 存储方法</h3><p><strong>无论我们是想使用完全预先计算的光照还是预先计算传输信息并允许光照的一些变化，结果数据都必须以某种形式存储。GPU友好的格式是必须的。</strong></p>
<p><strong>光照图是存储预计算光照最常见的方法之一。这些是存储预计算信息的纹理。虽然有时像辐照度图这样的术语被用来表示存储的特定类型的数据，但术语光图被用来统称所有这些数据。在运行时，使用GPU的内置纹理机制。值通常是双线性过滤的，这对于某些表示可能不是完全正确的。例如，当使用AHD表示时，滤波后的D(方向)分量在插值后将不再是单位长度，因此需要进行重正化。使用插值还意味着A(环境值)和H(高光值)并不完全是我们在采样点直接计算的结果。也就是说，结果通常看起来是可以接受的，即使表示是非线性的。</strong></p>
<p><strong>在大多数情况下，光贴图不使用mipmapping，这通常是不需要的，因为光贴图的分辨率比典型的反照率贴图或法线贴图小。即使在高质量的应用程序中，一个光贴图的texel至少可以覆盖20×20厘米的面积，通常还会更多。使用这种尺寸的像素，额外的mip级别几乎是不需要的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015213559.png" class="" title="image-20211015213559">

<p>光线被烘烤到一个场景中，连同灯光贴图应用到表面上。光映射使用一种独特的参数化。场景被划分为多个元素，这些元素被压平并打包成一个共同的纹理。例如，左下角的剖面对应于地面，显示了立方体的两个阴影。(来自three.js示例webgl materials lightmap。)</p>
<p><strong>为了在纹理中存储光照，对象需要提供一个独特的参数。当将漫反射颜色纹理映射到一个模型上时，通常网格的不同部分使用相同的纹理区域是很好的，特别是当一个模型的纹理具有一般的重复模式时。再使用灯光地图是非常困难的。光照对于网格上的每个点都是独特的，所以每个三角形都需要在光照地图上占据自己独特的区域。创建参数化的过程从将网格分割成更小的块开始。这既可以使用一些启发式自动完成，也可以使用创作工具手动完成。通常情况下，已经存在于其他纹理映射中的分割被使用。接下来，对每个chunk进行独立参数化，确保其各部分在纹理空间中不重叠。纹理空间中生成的元素称为图表或壳。最后，所有图表都打包到一个共同的纹理中(上图)。必须小心确保图表不仅不重叠，而且它们的过滤足迹必须保持分离。当渲染一个给定的图表时，所有可以访问的像素(双线性滤波访问四个相邻的像素)都应该被标记为使用过的，这样就不会有其他图表与它们重叠。否则，图表之间可能会出现出血现象，其中一个图表的光照可能会在另一个图表上可见。尽管为灯光地图系统提供一个用户控制的“排水沟”量用于灯光地图图表之间的间距是相当普遍的，但这种分离是不必要的。图表的正确过滤足迹可以通过在光映射空间中使用一套特殊规则进行栅格化自动确定。参见下图。如果炮弹栅格化这种方式不重叠，我们保证不会流血将发生。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015213714.png" class="" title="image-20211015213714">

<p>为了准确地确定一个图表的过滤足迹，我们需要找到渲染期间可以访问的所有texel。如果一个图表与四个相邻像素中心之间的正方形相交，那么所有这些像素都将用于双线性滤波。texel网格用实线标记，texel中心用蓝点，图表用粗实线进行栅格化(左)。我们首先保守地将图表栅格化为移动了一半像素大小的网格，并以虚线(中间)标记。任何接触标记单元格的texel都被认为占用(右)。</p>
<p><strong>避免出血是mipmapping很少用于光贴图的另一个原因。图表过滤足迹需要在所有mip水平上保持分离，这将导致壳之间的间距过大。</strong></p>
<p><strong>将图表最优地打包到纹理中是一个np完全问题，这意味着没有已知的算法可以生成具有多项式复杂性的理想解决方案。由于实时应用程序可能在一个纹理中有数十万个图表，所有真实世界的解决方案都使用微调的启发式和仔细优化的代码来快速生成打包。如果光照图稍后进行块压缩(章节6.2.6)，为了提高压缩质量，可能会向封隔器添加额外的约束条件，以确保单个块只包含类似的值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015213824.png" class="" title="image-20211015213824">

<p>为了为一个环面创建一个独特的参数化，它需要被切割和展开。左边的环面使用了一个简单的映射，创建时没有考虑到切割在纹理空间中的位置。注意左边代表像素的网格的不连续。使用更高级的算法，我们可以创建一个参数化，以确保texel网格线在三维网格上保持连续，就像右边那样。这种展开方法对于光线映射是完美的，因为产生的光线不会显示出任何不连续。</p>
<p><strong>光照贴图的一个常见问题是接缝(上图)。由于网格被分割成多个图表，并且每个图表都是独立参数化的，因此不可能确保分割边缘两侧的光照完全相同。这表现为视觉上的不连续性。如果网格是手动分割的，这个问题可以通过在不直接可见的区域分割来避免。然而，这样做是一个费力的过程，并且不能在自动生成参数化时应用。Iwanicki对最终的光照贴图进行后期处理，沿着分裂的边缘修改texel，以最小化两边插值值之间的差异。Liu和Ferguson等人通过等式约束强制沿边插值值匹配，并求解最能保持平滑的texel值。另一种方法是在创建参数化和包装图表时考虑这个约束。Ray等人展示了如何使用保持网格的参数化来创建不受接缝伪影影响的光映射。</strong></p>
<p><strong>预先计算的光照也可以存储在网格的顶点上。缺点是光照的质量取决于网格镶嵌的精细程度。因为这个决定通常是在创作的早期阶段做出的，很难确保网格上有足够的顶点来在所有预期的光照情况下看起来很好。此外，镶嵌可能是昂贵的。如果网格被精细地镶嵌，灯光信号将被过采样。如果使用定向存储光照的方法，整个表示需要由GPU在顶点之间插入，并传递到像素着色阶段来执行光照计算。在顶点和像素着色器之间传递如此多的参数是相当罕见的，并产生现代GPU没有优化的工作负载，这导致效率低下和性能较低。由于所有这些原因，在顶点上存储预先计算的光照很少被使用。</strong></p>
<p><strong>尽管关于入射亮度的信息在表面上是需要的(除了在做体积渲染时，在第14章讨论)，我们可以在体积上预计算和存储它。这样，就可以在空间的任意点查询光照，为在预计算阶段不存在的对象提供光照。但是请注意，这些物体不会正确地反射或遮挡光线。</strong></p>
<p><strong>Greger等人提出了辐照度体积，通过辐照度环境图的稀疏空间采样表示五维(三个空间和两个方向)辐照度函数。也就是说，在空间中有一个三维网格，在每个网格点上都有一个辐照度环境地图。动态对象从最近的地图中插值辐照度值。Greger等人使用两级自适应网格进行空间采样，但也可以使用其他体积数据结构，如八叉树。</strong></p>
<p><strong>在原始辐照度体积中，Greger等人将每个采样点的辐照度存储在一个小纹理中，但这种表示在GPU上无法有效过滤。如今，体积照明数据通常以三维形式存储纹理，所以体积采样可以使用GPU的加速过滤。样本点辐照度函数的最常见表示包括:</strong></p>
<pre><code>**•二阶和三阶球面谐波(SH)，前者更常见，因为一个颜色通道所需的四个系数方便地打包到四个典型纹理格式的通道。**

**•球高斯函数。**

**•环境立方体或环境骰子。**
</code></pre>
<p><strong>AHD编码，即使在技术上能够表示球面辐照度，也会产生分散的伪影。如果使用SH，球谐梯度可以进一步提高质量。以上所有表示方法都成功地应用于许多游戏。</strong></p>
<p><strong>Evans描述了一个在小小大星球上用来测量辐照度的技巧。不是一个完整的辐照度地图表示，平均辐照度存储在每个点。由辐照度场的梯度计算出近似的方向因子，即磁场变化最快的方向。代替显式计算梯度,梯度和表面之间的点积法线n是通过计算两个样品的辐照度,一个表面点p和另一个点的方向n,二者相减。这种近似表示是由于在小大星球上的辐照度体积是动态计算的。</strong></p>
<p><strong>辐照度体积也可以用来为静态表面提供照明。这样做的好处是不必为光线映射提供单独的参数化。这种技术也不会产生裂缝。静态和动态对象都可以使用相同的表示，使两种几何类型之间的照明一致。在延迟着色(第20.1节)中，体积表示很方便使用，其中所有照明都可以在一次通过中执行。其主要缺点是内存消耗。光图所使用的内存大小与分辨率的平方成正比;对于一个规则的体积结构，它与立方体一起增长。由于这个原因，网格体积表示使用了相当低的分辨率。自适应、分层形式的照明体量具有更好的特性，但它们仍然比照明地图存储更多的数据。它们也比有规则间隔的网格慢，因为额外的间接在着色器代码中创建加载依赖，这可能导致暂停和更慢的执行。</strong></p>
<p><strong>在体积结构中存储表面照明有点棘手。多个表面，有时有着非常不同的照明特性，可以占用相同的体素，这使得我们不清楚应该存储哪些数据。当从这些体素进行采样时，光照往往是不正确的。在光线明亮的室外和黑暗的室内之间的墙壁附近，这种情况尤其常见，结果要么是室外一片黑暗，要么是室内一片明亮。对此的补救措施是使体素大小足够小，以永远不会跨越这些边界，但这通常是不切实际的，因为所需的数据量。处理这个问题最常用的方法是沿法线移动采样位置，或者在插值过程中调整三线性混合权值。这通常是不完美的，可能需要手工调整几何体来掩盖问题。Hooker在辐照度体积上增加了额外的剪切平面，这将它们的影响限制在凸多面体的内部。Kontkanen和Laine讨论了各种减少出血的策略。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015214306.png" class="" title="image-20211015214306">

<p>Unity引擎使用一个四面体网格来插值一组探针的光照。(死亡之书——Unity Technologies, 2018)</p>
<p><strong>容纳照明的体积结构不必是规则的。一种流行的选择是将其存储在不规则的点云中，然后连接形成一个Delaunay四面体(上图)。Cupisz推广了这种方法。为了查看灯光，我们首先找到采样位置所在的四面体。这是一个迭代过程，可能会有些昂贵。我们遍历网格，在相邻的单元格之间移动。查找点相对于当前四面体角的重心坐标用于在下一个步骤中选择要访问的邻居(下图)。因为典型场景可能包含数千个位置，其中存储了照明，这个过程可能会很耗时。为了加快速度，我们可以记录一个四面体，用于在前一帧(如果可能的话)查找，或者使用一个简单的体积数据结构，为场景中的任意点提供一个良好的“开始四面体”。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015214401.png" class="" title="image-20211015214401">

<p>二维四面体网格的查找过程。步骤显示从左到右，从上到下。给定一些起始单元格(用蓝色标记)，我们计算查找点(蓝点)相对于单元格角的重心坐标。在接下来的步骤中，我们沿着与最负坐标的拐角相对的边缘向邻居移动。</p>
<p><strong>一旦正确的四面体被定位，存储在它的角落的光线被插值，使用已经可用的重心坐标。这个操作不被GPU加速，但是它只需要4个值来进行插值，而不是网格上的三线性插值需要8个值。</strong></p>
<p><strong>预先计算和存储光照的位置可以手动或自动。它们通常被称为照明探头，或光探头，因为它们探测(或取样)照明信号。这个术语不应与“光探头”(第10.4.2节)混淆，它是在环境地图上记录的远距离照明。</strong></p>
<p><strong>从一个四面体网格中采样的光照质量高度依赖于网格的结构，而不仅仅是探测器的总体密度。如果它们不均匀分布，产生的网格可能包含产生视觉伪影的细长四面体。如果用手放置探头，问题可以很容易地纠正，但这仍然是一个手动过程。四面体的结构与场景的几何结构没有关系，所以如果处理不当，灯光将会在墙壁上插入并产生流血的人工制品，就像辐照度体积一样。在手动放置探针的情况下，可以要求用户插入额外的探针以防止这种情况发生。当使用自动放置探针时，可以在探针或四面体上添加某种形式的可见性信息，以将其影响限制在相关区域。</strong></p>
<p><strong>对静态和动态几何图形使用不同的光照存储方法是一种常见的做法。例如，静态网格可以使用光照贴图，而动态对象可以从体积结构中获得光照信息。虽然很受欢迎，但这种方案可以在不同类型的几何形状之间创建不一致的外观。其中的一些差异可以通过正则化来消除，在正则化中，光照信息在表示中被平均。</strong></p>
<p><strong>当烘培照明时，只需要在它们真正有效的地方计算它的值。网格通常是不完美的。一些顶点可能被放置在几何体内部，或者部分网格可能自相交。如果我们在这些有缺陷的位置计算入射亮度，结果将是不正确的。它们会造成不必要的暗化或不正确的无着色照明。Kontkanen和Laine以及Iwanicki和Sloan讨论了可以用来丢弃无效样本的不同启发式方法。</strong></p>
<p><strong>环境和方向遮蔽信号共享漫射照明的许多空间特征。如第11.3.4节所述，上述所有方法也可以用于存储它们。</strong></p>
<h3 id="Dynamic-Diffuse-Global-Illumination-动态漫反射全局照明"><a href="#Dynamic-Diffuse-Global-Illumination-动态漫反射全局照明" class="headerlink" title="Dynamic Diffuse Global Illumination 动态漫反射全局照明"></a>Dynamic Diffuse Global Illumination 动态漫反射全局照明</h3><p><strong>尽管预计算光照可以产生令人印象深刻的结果，但它的主要优点也是它的主要缺点——它需要预计算。这种脱机流程可能会很长。在典型的游戏关卡中，光照烘培需要花费数小时的时间。因为光照计算需要很长时间，美工通常被迫同时处理多个关卡，以避免等待烘培完成时的停工时间。这反过来又会导致用于呈现的资源负载过大，并导致烘培时间更长。这种循环会严重影响生产力并导致挫败感。在某些情况下，甚至不可能预先计算光照，因为几何图形在运行时发生变化或在某种程度上由用户创建。</strong></p>
<p><strong>研究了动态环境下全局光照的模拟方法。它们要么不需要任何预处理，要么准备阶段足够快，可以每帧都执行。</strong></p>
<p><strong>最早在全动态环境中模拟全局光照的方法之一是基于“瞬时辐射度”。尽管名称如此，但该方法与辐射度算法几乎没有共同之处。在它里面，光线从光源向外投射。对于光线照射到的每一个位置，都放置一盏灯，代表来自该表面元素的间接照明。这些光源被称为虚点光源(VPLs)。基于这个想法，Tabellion和Lamorlette开发了一种在制作《怪物史莱克2》时使用的方法，该方法对场景表面进行直接照明，并将结果存储在纹理中。然后，在渲染过程中，该方法跟踪光线并使用缓存的照明创建单反射间接照明。Tabellion和Lamorlette表明，在许多情况下，一次弹跳就足以产生令人信服的结果。这是一种离线方法，但它启发了Dachsbacher和Stamminger的一种方法，即反射阴影地图(RSM)。</strong></p>
<p><strong>类似于常规阴影贴图(章节7.4)，反射阴影贴图是从光线的角度渲染的。除了深度之外，它们还存储了其他有关可见表面的信息，如反照率、正常照度和直接照度(通量)。当执行最后的着色时，RSM的像素被当作点光源来提供间接照明的单一反弹。因为一个典型的RSM包含几十万个像素，所以只选择其中的一个子集，使用重要度驱动启发式。Dachsbacher和Stamminger后来展示了如何通过逆转过程来优化该方法。不是从RSM中为每个着色点选择相关的像素，而是基于整个RSM和屏幕空间中的散开(章节13.9)创建一些灯。</strong></p>
<p><strong>该方法的主要缺点是它不能为间接照明提供遮挡。虽然这是一个重要的近似，但结果看起来是可信的，并且在许多应用程序中是可接受的。</strong></p>
<p><strong>为了达到高质量的效果，并在光运动时保持时间稳定，需要创建大量的间接光。如果创建的太少，它们往往会在RSM重新生成时迅速改变它们的位置，并导致工件闪烁。另一方面，从性能的角度来看，过多的间接光源是一个挑战。Xu描述了该方法是如何在《神秘海域4》中执行的。为了保持在性能限制范围内，他在每个像素上使用少量的光(16)，但是在几个帧上循环使用不同的光集，并暂时过滤结果(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015214940.png" class="" title="image-20211015214940">

<p>在《神秘海域4》中，玩家使用手电筒的反射阴影地图提供间接照明。左边的图像显示了没有间接贡献的场景。右边的图片已经启用了它。插图显示了没有(顶部)和启用(底部)时间过滤的帧的特写。它用于增加每个图像像素所使用的VPLs的有效数量。((UNCHARTED 4 A Thief ’s End  c / TM 2016 SIE. Created and developed by Naughty Dog LLC.)</p>
<p><strong>人们提出了不同的方法来解决间接遮挡的不足。Laine等人使用双抛物面阴影贴图作为间接光源，但将它们增量地添加到场景中，因此在任何一帧中只有少量的阴影贴图被渲染。Ritschel等人使用简化的、基于点的场景表示来渲染大量不完美的阴影地图。当直接使用时，这样的贴图很小，包含很多缺陷，但经过简单的过滤后，提供了足够的保真度，为间接照明提供适当的遮挡效果。</strong></p>
<p><strong>有些游戏使用了与这些解决方案相关的方法。Dust 514呈现了一个自上而下的世界视图，在需要的时候有多达四个独立的层。这些产生的纹理被用来进行间接照明的收集，很像Tabellion和Lamorlette的方法。在Kite演示中，使用类似的方法从地形提供间接照明，展示了Unreal Engine。</strong></p>
<h3 id="Light-Propagation-Volumes-光传播量"><a href="#Light-Propagation-Volumes-光传播量" class="headerlink" title="Light Propagation Volumes 光传播量"></a>Light Propagation Volumes 光传播量</h3><p><strong>辐射传输理论是模拟电磁辐射在介质中传播的一般方法。它解释了散射、发射和吸收。尽管实时图像努力呈现所有这些效果，但除了最简单的情况外，用于这些模拟的方法成本太高，无法直接用于渲染。然而，该领域中使用的一些技术在实时图形方面被证明是有用的。</strong></p>
<p><strong>光传播体积(LPV)是由Kaplanyan提出的，灵感来自于辐射传输中的离散坐标方法。在他的方法中，场景被离散成一个规则的三维网格。每个细胞都将保持一个方向分布的光辉流动通过它。他用二阶球面谐波来处理这些数据。在第一步中，光线被注入细胞，这些细胞的表面直接被光照射。可以使用反射阴影贴图来找到这些细胞，但也可以使用任何其他方法。注入的光线是被照亮的表面反射的亮度。因此，它形成了一个分布周围的法线，面对表面，并得到其颜色的材料的颜色。接下来，光线被传播。每个细胞分析其相邻细胞的辐射场。然后，它调整自己的分布，以适应来自各个方向的辐射。在一个单一的步骤中，辐射只传播到一个细胞的距离。需要多次迭代来进一步分发它(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015215433.png" class="" title="image-20211015215433">

<p>光线分布通过一个体积网格的三个传播步骤。左边的图像显示了由定向光源照亮的几何体反射的光的分布。注意，只有直接靠近几何图形的单元格具有非零分布。在随后的步骤中，来自邻近细胞的光被收集并通过网格传播。</p>
<p><strong>这种方法的重要优点是它为每个细胞产生一个完整的辐射场。这意味着我们可以使用任意的BRDF来做着色尽管当使用二阶球面谐波时，光滑BRDF的反射质量会相当低。Kaplanyan展示了漫反射和反射表面的例子。</strong></p>
<p><strong>为了允许光在更大的距离内传播，以及增加体积覆盖的面积，同时保持内存的合理使用，Kaplanyan和Dachsbacher开发了该方法的一个级联变体。他们不是使用单个细胞大小一致的体积，而是使用一组细胞逐渐变大，嵌套在一起的体积。光照被注入到所有的层次并独立地传播。在查找过程中，他们为给定的位置选择最详细的级别。</strong></p>
<p><strong>最初的实现没有考虑到间接照明的遮挡。修改后的方法使用了来自反射阴影贴图的深度信息，以及来自相机位置的深度缓冲区，以添加关于光阻挡器的信息到体块。这个信息是不完整的，但场景也可以在预处理过程中进行体素化，从而使用更精确的表示。</strong></p>
<p><strong>这种方法存在其他容积法的问题，其中最大的问题是出血。不幸的是，增加网格分辨率来修复它会导致其他问题。当使用更小的单元时，需要更多的迭代来在相同的世界空间距离上传播光，这使得该方法的成本大大增加。在网格的分辨率和性能之间找到平衡并非易事。该方法还存在混叠问题。有限的网格分辨率，再加上粗糙的辐射方向表示，导致信号在相邻单元之间移动时退化。空间工件，比如对角线条纹，可能会在多次迭代之后出现在解决方案中。其中一些问题可以通过在传播通过后执行空间滤波来消除。</strong></p>
<h3 id="Voxel-Based-Methods-基于体素锥体的方法"><a href="#Voxel-Based-Methods-基于体素锥体的方法" class="headerlink" title="Voxel-Based Methods 基于体素锥体的方法"></a>Voxel-Based Methods 基于体素锥体的方法</h3><p><strong>由Crassin提出的体素锥体跟踪全局照明(VXGI)也是基于体素化场景表示的。几何本身以稀疏体素八叉树的形式存储，在第13.10节中描述。关键的概念是，这种结构提供了一种类似于mipmap的场景表示，因此，例如，可以快速测试空间的遮挡。体素还包含关于它们所代表的几何形状反射的光的数量的信息。它是以定向形式存储的，因为辐射是在六个主要方向反射的。使用反射阴影贴图，直接光照首先注入到八叉树的最低层。然后将其向上传播到层次结构。</strong></p>
<p><strong>八叉树用于估计入射辐亮度。理想情况下，我们可以通过追踪光线来估计来自特定方向的亮度。然而，这样做需要很多光线，所以整个束的这些代替了接近一个圆锥跟踪他们的平均方向，只返回一个单一的值。精确地测试圆锥与八叉树的交点不是简单的，所以这个操作近似于沿着圆锥的轴对树进行一系列的查找。每次查找都读取树的层次，其节点大小与给定点的圆锥的横截面相对应。查找提供了在圆锥体原点方向反射的滤波亮度，以及几何形状所占查找足迹的百分比。这个信息被用来衰减来自后续点的光线，以一种类似于alpha混合的方式。跟踪整个锥体的遮挡情况。在每一步中，它被减少，以说明当前样品的几何占据的百分比。当积累辐亮度时，它首先乘以综合遮挡因子(下图)。该策略不能检测出由多个局部遮挡导致的完全遮挡，但结果是可信的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015215829.png" class="" title="image-20211015215829">

<p>体素锥体跟踪是通过对体素树的一系列过滤查找来近似一个精确的锥体跟踪。左侧显示的是三维轨迹的二维模拟。右侧显示体素化几何结构的层次表示，每一列显示的是树的越来越粗的层次。每行显示用于为给定示例提供覆盖率的层次结构的节点。选择所使用的级别，以便粗级别中的节点大小大于查找大小，而细级别中的节点大小小于查找大小。一个类似于三线性滤波的过程被用来在这两个选择的能级之间进行插值。</p>
<p><strong>为了计算漫射光，需要追踪一些锥。生成和强制转换的数量是性能和精度之间的折衷。追踪更多的视锥细胞可以提供更高质量的结果，但代价是花费更多的时间。假设余弦项在整个圆锥上是常数，因此这一项可以从反射率方程积分中提出。这样做使得漫射光照的计算简单到计算圆锥轨迹返回值的加权和。</strong></p>
<p><strong>如Mittring所述，该方法在虚幻引擎的原型版本中实现。他给出了开发人员需要的几个优化，使其作为一个完整的渲染管道的一部分运行。这些改进包括以较低的分辨率执行跟踪，并在空间上分布视锥。这样做的目的是让每个像素只追踪一个圆锥。漫射响应的全辐射是通过在屏空间中对结果进行滤波得到的。</strong></p>
<p><strong>使用稀疏八叉树存储照明的一个主要问题是查找成本很高。找到包含给定位置的叶节点对应于一系列内存查找，并穿插一个简单的逻辑来确定要遍历哪棵子树。一次典型的内存读取可能需要几百个周期。GPU试图通过并行执行多组着色线程(扭曲或波前)来隐藏这个延迟(第三章)。即使在任何给定的时间只有一组执行ALU操作，当它需要等待内存读取时，另一组代替它。同时激活的扭曲数量是由不同的因素决定的，但所有这些因素都与单个组使用的资源数量有关(第23.3节)。在遍历分层数据结构时，大部分时间都花在等待从内存中获取下一个节点上。然而，在此等待期间执行的其他翘曲很可能也会执行内存读取。由于与内存访问的数量相比，ALU工作很少，而且由于飞行中的翘曲总数量是有限的，因此，所有组都在等待内存而没有实际工作执行的情况是很常见的。</strong></p>
<p><strong>大量的失速翘曲会导致性能不佳，人们已经开发了一些方法来缓解这些效率低下的问题。McLaren用一组级联的三维纹理替换了八叉树，很像级联的光传播体积(章节11.5.6)。它们具有相同的维度，但覆盖的区域越来越大。通过这种方式，读取数据只需要一个常规的纹理查找—不需要依赖的读取。存储在纹理中的数据与稀疏体素八叉树中的数据相同。它们包含六个方向的反照率、占用率和反射照明信息。因为级联的位置会随着相机的移动而改变，物体会不断地进出高分辨率区域。由于内存的限制，不可能一直保留这些体素化版本，所以它们在需要时按需进行体素化。McLaren还描述了一些优化方法，使这一技术适用于FPS为30的游戏《the Tomorrow Children》(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211015220204.png" class="" title="image-20211015220204">

<p>《The Tomorrow Children》游戏使用体素锥跟踪来渲染间接照明效果。(c 2016年索尼互动娱乐公司。“明日之子”是美国索尼互动娱乐有限责任公司的商标。)</p>
<h3 id="Screen-Space-Methods-屏幕空间方法-1"><a href="#Screen-Space-Methods-屏幕空间方法-1" class="headerlink" title="Screen-Space Methods 屏幕空间方法"></a>Screen-Space Methods 屏幕空间方法</h3><p><strong>就像屏幕空间环境遮挡(章节11.3.6)，一些漫反射全局照明效果可以仅使用存储在屏幕位置的表面值来模拟。这些方法不像SSAO那样流行，主要是因为有限的可用数据产生的工件更加明显。像颜色出血这样的效果是强烈的直接光照射相当恒定的颜色大面积的结果。像这样的表面通常不可能完全适应视图。这种情况使得反射光的数量强烈地依赖于当前帧，并随着相机的移动而波动。由于这个原因，屏幕空间方法仅用于在精细尺度上增加其他解决方案，超出了主算法所能达到的分辨率。游戏《Quantum Break》使用了这种类型的系统。辐照度体积用于模拟大规模的全局照明效果，屏幕空间解决方案提供有限距离的反弹光。</strong></p>
<h3 id="Other-Methods-其他方法"><a href="#Other-Methods-其他方法" class="headerlink" title="Other Methods 其他方法"></a>Other Methods 其他方法</h3><p><strong>Bunnell计算环境遮挡的方法(第11.3.5节)也允许动态计算全局光照效果。场景的基于点的表示(章节11.3.5)通过存储关于每个磁盘的反射辐亮度的信息来增强。在收集步骤中，不只是收集遮挡，可以在每个收集位置构建一个完整的入射亮度函数。就像环境遮蔽一样，必须执行后续步骤来消除来自闭塞磁盘的光照。</strong></p>
<h2 id="Specular-Global-Illumination-镜面全局光照"><a href="#Specular-Global-Illumination-镜面全局光照" class="headerlink" title="Specular Global Illumination 镜面全局光照"></a>Specular Global Illumination 镜面全局光照</h2><p><strong>前几节中介绍的方法主要用于模拟漫射全局照明。现在，我们将看看各种方法，可以用来渲染依赖视图的效果。对于有光泽的材料，镜面瓣比用于漫射照明的余弦瓣紧密得多。如果我们想要展示一种极其闪亮的材料，一种具有薄镜面瓣的材料，我们需要一种能够呈现高频细节的亮度表示。另外，这些条件也意味着反射率方程的评估只需要从一个有限的实心角度入射的光照，不像朗伯BRDF反射整个半球的光照。这与漫反射材料的要求完全不同。这些这些特性解释了为什么需要做出不同的权衡来实现实时的效果。</strong></p>
<p><strong>存储入射辐亮度的方法可用于提供粗略的视相关效果。当使用AHD编码或HL2基时，我们可以计算镜面反射响应，就好像照明来自编码方向的定向光(或三个方向，在HL2基的情况下)。这种方法确实提供了一些间接照明的高光，但它们是相当不精确的。对于AHD编码来说，使用这种方法尤其成问题，因为在AHD编码中，方向分量在很小的距离内就会发生巨大的变化。这种变化导致高光以不自然的方式变形。伪影可以通过空间方向滤波来减少。当使用HL2基时，如果相邻三角形之间的切空间快速变化，也会观察到类似的问题。</strong></p>
<p><strong>伪影也可以通过以更高的精度表示入射光来减少。Neubelt和Pettineo在游戏the Order: 1886中使用球形高斯瓣来表示入射辐射。为了渲染镜面效果，他们使用了Xu等人的方法，他们开发了一个典型微表面 BRDF的镜面响应的有效近似(章节9.8)。如果用一组球面高斯函数来表示光照，并假定菲涅耳项和遮蔽函数在其支撑上为常数，则反射率方程可近似为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016133846.png" class="" title="image-20211016133846">

<p><strong>其中Lk 为表示入射亮度的第k个球面高斯函数，M为菲涅耳和遮蔽函数的结合因子，D为NDF。Xu等人引入了一个各向异性球面高斯(ASG)，他们使用它来模拟NDF。它们还提供了计算SG和ASG乘积积分的有效近似，如上式所示。</strong></p>
<p><strong>Neubelt和Pettineo使用9到12个高斯叶来代表照明，这让他们只模拟适度光泽的材料。他们能够使用这种方法来代表大多数的游戏照明，因为游戏发生在19世纪的伦敦，高度抛光的材料，玻璃，和反射表面是罕见的。</strong></p>
<h3 id="Localized-Environment-Maps-本地化环境映射"><a href="#Localized-Environment-Maps-本地化环境映射" class="headerlink" title="Localized Environment Maps 本地化环境映射"></a>Localized Environment Maps 本地化环境映射</h3><p><strong>到目前为止讨论的方法还不足以令人信服地渲染抛光材料。对于这些技术，亮度场太粗糙，无法精确编码入射亮度的细节，这使得反射看起来很暗淡。如果使用相同的材料，产生的结果也与分析光的高光不一致。一种解决方案是使用更多的球面高斯函数或更高阶SH函数来获得我们需要的细节。这是可能的，但我们很快面临一个性能问题:SH和SGs都有全球支持。每个基函数在整个球面上都是非零的，这意味着我们需要所有的基函数来评估光照给定的方向。这样做变得非常昂贵，只需要很少的基函数，而不需要渲染清晰的反射，因为我们需要数千个基函数。也不可能以漫射照明通常使用的分辨率存储那么多数据。</strong></p>
<p><strong>在实时设置中提供全局照明的高光组件的最流行的解决方案是本地化的环境地图。它们解决了我们之前的两个问题。入射辐亮度表示为一个环境地图，因此只需要少量的值来评估辐亮度。它们也稀疏地分布在整个场景中，因此入射辐亮度的空间精度被增加的角分辨率所取代。这种在场景中特定点上渲染的环境映射通常称为反射探测。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016134321.png" class="" title="image-20211016134321">

<p>一个简单的场景，设置了局部反射探测。反射球代表探头位置。黄线表示框形反射代理。注意代理是如何近似场景的整体形状的。</p>
<p><strong>环境地图是自然适合渲染完美的反射，这是镜面间接照明。已经开发了许多使用纹理的方法来提供广泛的镜面效果(章节10.5)。所有这些都可以用于局部环境地图，以渲染间接照明的镜面响应。</strong></p>
<p><strong>《半条命2》是最早将环境地图与特定空间点绑定在一起的游戏之一。在他们的系统中，艺术家首先将采样地点放置在现场。在预处理步骤中，从每个位置渲染一个立方体映射。物体然后使用最近的位置的结果作为入射光在高光照明计算的表示。可能会发生相邻的对象使用不同的环境地图，这会导致视觉不匹配，但美工可以手动重写立方体地图的自动分配。</strong></p>
<p><strong>如果一个物体很小，环境地图从它的中心渲染(隐藏物体后，它不会出现在纹理中)，结果是相当精确的。不幸的是，这种情况很少见。通常相同的反射探头用于多个对象，有时具有显著的空间范围。镜面的位置离环境地图的中心越远，结果就越可能与现实不同。</strong></p>
<p><strong>Brennan和Bjorke提出了一种解决这个问题的方法。他们并没有将入射光视为来自于一个无限远的周围球体，而是假设它来自于一个有限大小的球体，半径是用户定义的。当查看入射辐亮度时，方向不是直接用于索引环境地图，而是作为来自评估的表面位置并与这个球体相交的射线。接下来，计算一个新的方向，从环境地图的中心到十字路口位置。这个向量作为查找方向。参见下图。该过程具有在空间中“固定”环境地图的效果。这样做通常被称为视差校正。同样的方法也可以用于其他原语，比如box。用于光线相交的形状通常称为反射代理。所使用的代理对象应该表示渲染到环境地图中的几何图形的一般形状和大小。虽然通常不可能，但如果它们完全匹配，例如用一个盒子来代表一个矩形的房间，这种方法就能提供完美的局部反射。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016134442.png" class="" title="image-20211016134442">

<p>使用反射代理在空间上定位环境地图(EM)的效果。在这两种情况下，我们都想在黑色圆圈的表面上渲染环境的反射。左边是规则的环境映射，由蓝色圆圈表示(但它可以是任何表示，例如立方体映射)。它的效果是通过使用反射视图方向r 访问环境地图上的一个点来确定的。通过使用这个方向，蓝色圆圈EM被视为无穷大且遥远。对于黑圆上的任何一点，电磁似乎都是以这里为中心。在右边，我们想让EM代表周围的黑色房间是局部的，而不是无限远的。蓝色的圆圈EM是从房间的中心生成的。为了访问这个EM，就像它是一个房间一样，从位置p的反射光线沿着反射视图的方向被跟踪，并在着色器中与一个简单的代理对象相交，房间周围的红框。这个交点和电磁中心然后被用来形成方向r ‘，它被用来像往常一样通过一个方向访问电磁。通过找到r ‘，这个过程将电磁视为一个物理形状，即红色方框。由于代理形状与实际房间的几何形状不匹配，代理框假设将在下方的两个角落打破。</p>
<p><strong>这种技术在游戏中很受欢迎。它易于实现，运行时速度快，可以在前向和延迟呈现方案中使用。艺术家可以直接控制外观和内存的使用。如果某些区域需要更精确的照明，他们可以放置更多的反射探头，并更好地适合代理。如果使用太多内存来存储环境映射，则很容易删除探测。当使用光滑材质时，阴影点和代理形状的交点之间的距离可以用来决定使用哪个级别的预过滤环境贴图(下图)。这样做模拟了当我们离开阴影点时BRDF瓣的占地面积的增长。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016134607.png" class="" title="image-20211016134607">

<p>点a和点b的BRDFs是相同的，视图向量v和v ‘是相等的。因为从a点到反射代理点的距离d比从b点到反射代理点的距离d ‘短，所以反射代理点(用红色标记)一侧的BRDF瓣的足迹更小。当采样一个预先过滤的环境地图时，这个距离可以与反射点的粗糙度一起使用，以影响mip水平。</p>
<p><strong>当多个探测覆盖相同区域时，可以建立关于如何组合它们的直观规则。例如，探测可以有一个用户设置的优先级参数，使具有较高值的探测优先于较低值的探测，或者它们可以平滑地融合在一起。</strong></p>
<p><strong>不幸的是，这种方法的简单本质导致了各种各样的工件。反射代理很少与底层几何精确匹配。这使得反射在某些区域以不自然的方式伸展。这是一个问题，主要是高反射，抛光材料。此外，反射物体渲染到环境中他们的BRDFs评估从地图的位置。表面位置访问环境地图将不会有这些对象的完全相同的视图，所以纹理的存储结果不是完全正确的。</strong></p>
<p><strong>代理也会导致(有时是严重的)光线泄露。通常，查找将返回环境地图明亮区域的值，因为简化的光线投射错过了应该导致遮挡的局部几何体。这个问题有时可以通过使用定向遮挡方法来缓解(第11.4节)。另一个缓解这个问题的流行策略是使用预计算的漫射照明，这通常以更高的分辨率存储。环境地图中的值首先被渲染位置的平均漫反射光照所分割。这样做可以有效地从环境映射中去除平滑、扩散的影响，只留下更高频率的组件。当进行着色时，在被着色位置的反射乘以漫射光。这样做可以部分缓解反射探测缺乏空间精度的问题。</strong></p>
<p><strong>解决方案已经开发出来，使用更复杂的表示反射探头捕获的几何图形。szirmai - kalos等人为每个反射探头存储一个深度图，并在查找时对其执行射线跟踪。这可以产生更准确的结果，但要付出额外的代价。McGuire等人提出了一种更有效的方法来跟踪探针深度缓冲区中的射线。他们的系统存储多个探针。如果最初选择的探测没有包含足够的信息来可靠地确定命中位置，则选择回退探测，并使用新的深度数据继续跟踪。</strong></p>
<p><strong>当使用光滑的BRDF时，环境地图通常是预过滤的，每个mipmap存储与逐渐增大的核卷积的入射辐亮度。预过滤步骤假设这个内核是径向对称的(章节10.5)。然而，当使用视差校正时，BRDF瓣在反射代理形状上的足迹取决于阴影点的位置。这样做会使预过滤略有错误。Pesce和Iwanicki分析了这个问题的不同方面，并讨论了可能的解决方案。</strong></p>
<p><strong>反射代理不必是封闭的凸形状。也可以使用简单的平面矩形来代替或增加具有高质量细节的盒子或球体代理。</strong></p>
<h3 id="Dynamic-Update-of-Environment-Maps-环境地图的动态更新"><a href="#Dynamic-Update-of-Environment-Maps-环境地图的动态更新" class="headerlink" title="Dynamic Update of Environment Maps 环境地图的动态更新"></a>Dynamic Update of Environment Maps 环境地图的动态更新</h3><p><strong>使用局部反射探测需要渲染和过滤每个环境地图。这项工作通常是离线完成的，但在某些情况下，可能需要在运行时完成这项工作。在开放世界游戏中，每天的时间是变化的，或者当世界的几何图形是动态生成的，离线处理所有这些地图可能会花费太长时间，并影响生产力。在极端情况下，当需要许多变体时，甚至可能不可能将它们全部存储在磁盘上。</strong></p>
<p><strong>在实践中，有些游戏在运行时渲染反射探测。这种类型的系统需要谨慎地进行调优，以免显著影响性能。</strong></p>
<p><strong>除了一些琐碎的情况，我们不可能在每一帧中重新渲染所有可见的探头，因为现代游戏中的典型帧可能使用数十甚至数百个探头。幸运的是，这不是必需的。我们很少要求反射探头在任何时候都精确地描绘出它们周围的所有几何形状。大多数情况下，我们确实希望它们能够正确地对一天中的时间变化做出反应，但我们可以通过一些其他方法来近似反映动态几何，例如后面描述的屏幕空间方法(第11.6.5节)。这些假设允许我们在加载时渲染一些探测，而当它们进入视图时，逐步渲染其余的探测。</strong></p>
<p><strong>即使我们确实想要在反射探测中渲染动态几何体，我们几乎肯定能够以较低的帧率更新探测。我们可以定义需要花费多少帧时间来渲染反射探测，并在每一帧中更新固定数量的反射探测。基于每个探针到摄像机的距离、自上次更新以来的时间以及类似因素的启发式方法可以确定更新顺序。在时间预算特别小的情况下，我们甚至可以在多个帧上分割一个环境地图的渲染。例如，我们可以在每一帧渲染一个立方体映射的单个面。</strong></p>
<p><strong>离线卷积时通常使用高质量滤波。这种过滤涉及多次采样输入纹理，这在高帧率下是不可能承受的。Colbert和Kˇriv´anek开发了一种方法，使用重要抽样，在相对较低的样本计数(按64个顺序)下实现可比较的过滤质量。为了消除大多数噪声，他们从一个完整的mip链的立方体映射中取样，并使用启发式方法来确定每个样本应该读取哪个mip级别。他们的方法是环境地图快速、运行时预过滤的流行选择。Manson和Sloan利用基函数构造了所需的滤波核。构造特定核的精确系数必须在优化过程中得到，但对于给定的形状只会发生一次。卷积分两个阶段进行。首先，对环境地图进行下采样，同时用一个简单的核进行过滤。接下来，来自最终mip链的样本被组合起来构建最终的环境地图。</strong></p>
<p><strong>为了限制在照明通道中使用的带宽，以及内存的使用，压缩产生的纹理是有益的。Narkowicz描述了一种将高动态范围反射探头压缩为BC6H格式(章节6.2.6)的有效方法，该格式能够存储半精度浮点值。</strong></p>
<p><strong>渲染复杂的场景，即使一次渲染一个立方体映射面，对CPU来说可能太昂贵了。一种解决方案是为环境映射离线准备g缓冲区，只计算(更少的CPU要求)照明和卷积。如果需要，我们甚至可以在预生成的G缓冲区之上渲染动态几何。</strong></p>
<h3 id="Voxel-Based-Methods-基于体素锥体的方法-1"><a href="#Voxel-Based-Methods-基于体素锥体的方法-1" class="headerlink" title="Voxel-Based Methods 基于体素锥体的方法"></a>Voxel-Based Methods 基于体素锥体的方法</h3><p><strong>在大多数性能受限的场景中，本地化环境映射是一种出色的解决方案。然而，它们的质量往往不能令人满意。在实践中，必须使用变通方法来掩盖由探测器空间密度不足或代理过于粗糙的实际几何形状近似所造成的问题。当每帧有更多的可用时间时，可以使用更精细的方法。</strong></p>
<p><strong>体素锥跟踪——无论是在稀疏八叉树还是级联版本(章节11.5.7)——也可以用于高光分量。该方法对存储在稀疏体素八叉树中的场景表示进行锥跟踪。单个圆锥轨迹只提供一个值，代表从圆锥所面对的实心角度发出的平均辐亮度。对于漫射照明，我们需要追踪多个锥，因为只使用一个锥是不准确的。</strong></p>
<p><strong>对于光滑的材料使用锥形跟踪是非常有效的。在镜面照明的情况下，BRDF瓣很窄，只需要考虑来自小实心角度的亮度。我们不再需要追踪多个锥细胞;在很多情况下，一个就足够了。只有在粗糙材料上的镜面效应可能需要追踪多个锥，但因为这样的反射是模糊的，在这种情况下，通常回到局部反射探头就足够了，根本不追踪锥。</strong></p>
<p><strong>与之相反的是高度抛光的材料。它们的镜面反射几乎像镜子一样。这使得圆锥体很薄，就像一条单线。有了这样精确的轨迹，底层场景表示的体素本质可能会在反射中被注意到。它将显示由体素化过程产生的立方体，而不是多边形几何。这个工件在实践中很少有问题，因为反射几乎从来没有被直接看到过。它的贡献是由纹理修改的，这经常掩盖任何缺陷。当需要完美的镜面反射时，可以使用其他方法，以更低的运行成本提供它们。</strong></p>
<h3 id="Planar-Reflections-平面反射"><a href="#Planar-Reflections-平面反射" class="headerlink" title="Planar Reflections 平面反射"></a>Planar Reflections 平面反射</h3><p><strong>另一种选择是重用场景的常规表示，并重新渲染它以创建一个反射图像。如果反射表面的数量有限，并且它们是平面的，我们可以使用常规的GPU渲染管道来创建场景反射这些表面的图像。这些图像不仅可以提供精确的镜面反射，而且还可以通过对每个图像进行一些额外的处理来呈现似是而非的光泽效果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016135339.png" class="" title="image-20211016135339">

<p>在一个平面上的反射，显示入射角和反射角、反射几何形状和反射器。</p>
<p><strong>理想的反射镜遵循反射定律，即入射角等于反射角。也就是说，入射光和法线的夹角等于反射光和法线的夹角。参见上图。这个图也显示了被反射物体的“图像”。根据反射定律，物体的反射像就是物体本身，在物理上通过平面反射。也就是说，我们不是沿着反射光走，而是沿着入射光穿过反射器到达同一点，但是在被反射物体上。</strong></p>
<p><strong>这就引出了一个原理，即反射可以通过创建对象的副本，将其转换为反射位置，然后从那里进行渲染。为了实现正确的照明，光源也必须在平面上进行反射，包括位置和方向。一种等效的方法是将观察者的位置和方向通过镜子反射到反射器的另一侧。这种反射可以通过对投影矩阵的简单修改来实现。</strong></p>
<p><strong>在远端的物体(即在背面)不应被反射。这个问题可以用反射器的平面方程来解决。最简单的方法是在像素着色器中定义一个剪切平面。放置裁剪平面，使其与反射器平面重合。在渲染反射场景时使用这个剪切平面将会剪切掉所有与视点同侧的反射几何体，也就是所有原本在镜子后面的物体。</strong></p>
<h3 id="Screen-Space-Methods-屏幕空间方法-2"><a href="#Screen-Space-Methods-屏幕空间方法-2" class="headerlink" title="Screen-Space Methods 屏幕空间方法"></a>Screen-Space Methods 屏幕空间方法</h3><p><strong>就像环境遮挡和漫反射全局照明一样，一些镜面效果可以仅在屏幕空间中计算。这样做比在漫反射的情况下稍微更精确，因为镜面叶的清晰度。关于亮度的信息只需要从反射视图向量周围有限的固体角度，而不是从整个半球，所以屏幕数据更有可能包含它。这种类型的方法最早由Sousa等人提出，同时也被其他开发人员发现。这一整套方法被称为屏幕空间反射(SSR)。</strong></p>
<p><strong>给定被着色点的位置、视图向量和法线，我们可以沿着穿过法线反射的视图向量追踪光线，用深度缓冲区测试交点。这个测试是通过沿着射线迭代移动，将位置投影到屏幕空间，并从该位置检索z-缓冲区深度来完成的。如果射线上的点距离相机比深度缓冲区所代表的几何图形更远，这意味着射线在几何图形内部，命中被检测到。然后从颜色缓冲读取相应的值，以获得从跟踪方向入射的亮度值。这种方法假设射线击中的表面是朗伯方程的，但这个条件是许多方法的共同近似，在实践中很少成为约束。光线在世界空间中可以匀速追踪。这个方法相当粗糙，所以当检测到命中时，可以执行一个细化步骤。在有限的距离内，可以使用二值搜索来精确定位交点位置。</strong></p>
<p><strong>McGuire和Mara注意到，由于透视投影，在均匀的世界空间间隔中行走会造成采样点在屏幕空间中沿射线的不均匀分布。靠近相机的部分光线采样不足，因此可能会错过一些碰撞事件。那些距离较远的像素会被过度采样，因此相同深度的缓冲区像素会被多次读取，从而产生不必要的内存流量和冗余计算。他们建议用数字差分分析仪(DDA)代替在屏幕空间中执行射线移动，这种方法可以用于栅格化线条。</strong></p>
<p><strong>首先，要追踪的光线的起点和终点都投影到屏幕空间。沿着这条线的像素依次检查，以保证统一的精度。这种方法的一个结果是，交集测试不需要为每个像素完全重建视图空间深度。在典型透视投影的情况下，视图空间深度的倒数(即存储在z缓冲区中的值)在屏幕空间中线性变化。这意味着我们可以在实际跟踪之前计算它对屏幕空间x和y坐标的导数，然后使用简单的线性插值来得到屏幕空间段上任何位置的值。计算值可以直接与深度缓冲区的数据进行比较。</strong></p>
<p><strong>屏幕空间反射的基本形式只能追踪一条射线，只能提供镜面反射。然而，完美的镜面是相当罕见的。在现代的基于物理的渲染管道中，更经常需要光滑的反射，SSR也可以用来渲染这些。</strong></p>
<p><strong>简单的，特别的方法，反射仍然沿着反射方向用单线追踪。结果存储在屏幕外缓冲区中，在后续步骤中进行处理。应用了一系列的滤波内核，通常与下行采样的缓冲区相结合，以创建一组反射缓冲区，每个反射缓冲区都被模糊到不同的程度。当计算照明时，BRDF瓣的宽度决定了哪个反射缓冲器被采样。即使滤波器的形状经常被选择来匹配BRDF瓣的形状，这样做仍然只是一个粗略的近似，因为屏幕空间滤波是在不考虑不连续面的情况下进行的定位等因素对结果的精度至关重要。自定义启发式添加在最后，以使光滑的屏幕空间反射在视觉上匹配来自其他来源的高光贡献。尽管这是一个近似值，但结果是令人信服的。</strong></p>
<p><strong>Stachowiak以一种更有原则的方式处理这个问题。计算屏幕空间的反射是射线追踪的一种形式，就像射线追踪一样，它可以用来进行适当的蒙特卡罗积分。他使用BRDF的重要抽样，并随机发射射线，而不是仅仅使用反射视图方向。由于性能的限制，跟踪以一半的分辨率完成，每个像素(1到4)跟踪少量的射线。这是太少的光线产生一个无噪声的图像，所以交集的结果是共享的相邻像素。假设在一定范围内的像素的局部可见性是相同的。如果射线沿d0方向从点p0射出在第一点与场景相交i0，我们可以假设如果我们沿d1方向从点p1发射一条射线使它也经过i0，它也会击中i0 中的几何体在它之前不会有任何交叉。这让我们不用追踪光线，只需要适当地修改它对邻域积分的贡献。正式地说，从邻近像素射出的射线方向，相对于当前像素的BRDF的概率分布函数，将有不同的概率。</strong></p>
<p><strong>为了进一步增加有效的射线数，结果被暂时过滤。通过离线执行与场景无关的集成部分，并将其存储在由BRDF参数索引的查找表中，还可以减少最终积分的方差。在反射光线所需的所有信息都可以在屏幕空间获得的情况下，这些策略使我们能够获得精确的、无噪声的结果，接近路径跟踪地面真实图像(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016135948.png" class="" title="image-20211016135948">

<p>该图像中的所有镜面效果都是使用随机屏幕空间反射算法渲染的。注意微表面模型反射的垂直拉伸特性。(图片由Tomasz Stachowiak提供。场景建模和纹理由Joacim Lunde)</p>
<p><strong>在屏幕空间中追踪光线通常是昂贵的。它包括重复采样深度缓冲区(可能是多次)，并对查找结果执行一些操作。因为读取是相当不连贯的，缓存利用率可能很差，导致在着色器执行期间从等待内存事务完成很长时间的停顿。需要非常注意使实现尽可能快。屏幕空间反射通常以降低的分辨率计算，时间滤波用来弥补降低的质量。</strong></p>
<p><strong>Uludag描述了一种使用层次深度缓冲区(章节19.7.2)加速跟踪的优化。首先，创建一个层次结构。深度缓冲器是逐步向下采样的，每一步在每个方向上按因子2进行采样。较高层次的像素存储较低层次的四个对应像素之间的最小深度值。接下来，通过层次结构执行跟踪。如果在一个给定的步骤中，光线没有击中存储在单元格中的几何体，它将被推进到单元格的边界，在下一步中使用一个低分辨率的缓冲区。如果射线在当前单元格中遇到碰撞，它将被推进到碰撞位置，并在下一步使用更高分辨率的缓冲区。当最高分辨率缓冲区上的命中被注册时，跟踪终止(下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016140135.png" class="" title="image-20211016140135">

<p>通过层次深度缓冲区追踪光线。如果光线在通过一个像素时没有击中几何体，下一步使用一个粗糙的分辨率。如果已注册命中，则后续步骤使用更细的分辨率。这个过程允许光线以大的步骤遍历空白区域，提供更高的性能。</p>
<p><strong>该方案特别适合长轨迹，因为它确保了不会错过任何特征，同时允许射线以大增量前进。它也能很好地访问缓存，因为深度缓冲区不是在随机的、遥远的位置读取的，而是在本地附近读取的。Grenier给出了许多实现该方法的实用技巧。</strong></p>
<p><strong>另一些则完全避免追踪光线。机器人利用反射代理重新定位交叉点，并从那里查看屏幕空间的亮度。Cichocki假设使用平面反射器，而不是追踪光线，而是反向进行整个过程，在整个屏幕上，每个像素都将其值写入应该被反射的位置。</strong></p>
<p><strong>与其他屏幕空间方法一样，反射也会受到可用数据有限造成的人为影响。这是很常见的反射光线离开屏幕区域之前登记一个击中，或击中几何体的背面，这是没有照明信息可用。这种情况需要优雅地处理，因为跟踪的有效性甚至对于相邻像素也是不同的。空间滤波器可以用来部分填充跟踪缓冲区中的空白。</strong></p>
<p><strong>SSR的另一个问题是缺乏关于深度缓冲区中物体厚度的信息。因为只存储一个值，所以当光线进入深度数据描述的表面后，没有办法判断光线是否击中了任何东西。Cupisz讨论了各种低成本的方法，以减轻由于不知道深度缓冲区中对象的厚度而产生的失真。Mara等人描述了深层G-buffer，它存储了多层数据，因此有更多关于地表和环境的信息。</strong></p>
<p><strong>屏幕空间反射是一个很好的工具，可以提供一组特定的效果，比如附近物体在平面上的局部反射。它们极大地提高了实时镜面照明的质量，但并没有提供一个完整的解决方案。本章中描述的不同方法通常是相互叠加的，以交付一个完整而健壮的系统。屏幕空间反射作为第一层。如果不能提供准确的结果，则使用局部反射探测作为备用方法。如果在给定区域中没有应用任何探测，则使用全局的默认探测。这种类型的设置提供了一种一致和健壮的方法来获得貌似可信的间接镜面贡献，这对于真实的外观尤其重要。</strong></p>
<h2 id="Unified-Approaches-统一的方法"><a href="#Unified-Approaches-统一的方法" class="headerlink" title="Unified Approaches 统一的方法"></a>Unified Approaches 统一的方法</h2><p><strong>目前提出的方法可以组合成一个连贯的系统，能够绘制美丽的图像。然而，它们缺乏路径跟踪的优雅性和概念上的简单性。渲染方程的每个方面都以不同的方式处理，每个方面都做出不同的妥协。尽管最终的图像看起来很真实，但在很多情况下，这些方法都失败了，错觉也破灭了。由于这些原因，实时路径跟踪一直是重要研究工作的重点。</strong></p>
<p><strong>用路径跟踪来渲染可接受的图像所需的计算量远远超过了即使是快速的CPU的能力，所以使用GPU代替。它们极快的速度和计算单元的灵活性使它们成为这项任务的最佳候选人。实时路径跟踪的应用包括建筑电影渲染的演练和预可视化。对于这些用例来说，较低且变化的帧率是可以接受的。当相机静止时，可以使用渐进细化(第13.2节)等技术来改善图像质量。高端系统可以使用多个GPU。</strong></p>
<p><strong>相比之下，游戏需要呈现最终质量的帧，并且他们需要在时间预算内始终如一地做到这一点。GPU可能还需要执行渲染本身以外的任务。例如，像粒子模拟这样的系统通常都是由GPU来释放一些CPU处理能力。所有这些元素结合在一起使得路径跟踪对于今天的渲染游戏来说是不切实际的。</strong></p>
<p><strong>在图形界有这样一种说法:“光线追踪是未来的技术，它永远都是!”这句妙语暗示了这个问题是如此复杂，即使在硬件速度和算法上都有了进步，也总会有更有效的方法来处理渲染管道的特定部分。支付额外的成本和仅使用光线投射，包括初级能见度，可能很难证明。因为gpu从来没有被设计来执行有效的射线追踪，所以目前有相当多的事实可以证明这一点。他们的主要目标一直是栅格化三角形，而且他们非常擅长这项任务。虽然光线追踪可以映射到GPU，但目前的解决方案没有任何来自固定功能硬件的直接支持。用运行在GPU计算单元上的有效软件解决方案总是很难击败硬件光栅化。</strong></p>
<p><strong>更合理、更不纯粹的方法是对光栅化框架中难以处理的效果使用路径跟踪方法。栅格化从相机可见的三角形，但不是依靠近似的反射代理，或不完整的屏幕空间信息，跟踪路径来计算反射。而不是尝试用特殊的模糊来模拟区域的光阴影，将光线追踪到光源并计算正确的遮挡。充分发挥GPU的优势，对无法在硬件中有效处理的元素使用更通用的解决方案。这样的系统仍然有点拼凑，并且缺少路径跟踪的简单性，但是实时渲染总是需要妥协。如果为了额外的几毫秒而不得不放弃一些优雅，这就是正确的选择——帧率是不可商量的。</strong></p>
<p><strong>虽然我们可能永远无法将实时渲染称为“已解决的问题”，但更多地使用路径跟踪将有助于把理论和实践更紧密地结合在一起。随着GPU的速度越来越快，在不久的将来，这种混合解决方案甚至应该适用于要求最高的应用程序。建立在这些原则基础上的系统的最初例子已经开始出现。</strong></p>
<p><strong>光线追踪系统依赖于加速方案，例如使用包围体层次(BVH)来加速可见性测试。有关此主题的更多信息，请参阅19.1.1节。一个简单的BVH实现不能很好地映射到GPU。正如在第3章中解释的，GPU本地执行一组线程，称为翘曲或波阵面。经纱是用锁步法处理的，每条线都执行相同的操作。如果某些线程不执行代码，它们暂时被禁用。出于这个原因，GPU代码应该以一种方式编写，使同一波阵面内的线程之间的发散流控制最小化。假设每个线程处理一个射线。这种方案通常会导致线程之间的巨大分歧。不同的射线将执行遍历代码的分叉分支，并在此过程中相交不同的边界体。有些射线会比其他射线更早地完成树的遍历。这种行为让我们偏离了理想状态，即所有的线程都在使用GPU的计算能力。为了消除这些效率低下的问题，已经开发了遍历方法，以最小化分歧并重用早期完成的线程。</strong></p>
<p><strong>为了生成高质量的图像，每个像素可能需要追踪数百或数千条射线。即使有最优的BVH、高效的树遍历算法和快速的GPU，在今天，除了最简单的场景外，这样做也不可能在实时中实现。我们在可用性能约束下生成的图像噪声非常大，不适合显示。然而，它们可以用去噪算法处理，以产生大部分无噪声的图像。参见下图，以及第1044页的图24.2。该领域最近取得了令人印象深刻的进展，已经开发出的算法可以从输入中创建高质量的、路径跟踪的参考图像，即使每像素只追踪一条路径。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211016140512.png" class="" title="image-20211016140512">

<p>时空方差引导滤波可用于降噪每像素一个样本，路径跟踪图像(左)，以创建平滑的无伪图像(中)。其质量可与每像素2048个样本渲染的参考图像相媲美(右)。(图片由英伟达公司提供。)</p>
<p><strong>2014年PowerVR发布了他们的Wizard GPU。除了典型的功能，它还包含在硬件中构造和遍历加速结构的单元(章节23.11)。该系统证明了对固定功能单元进行定制以加速光线投射的能力和兴趣。</strong></p>
<h1 id="12-Image-Space-Effects-图像空间影响"><a href="#12-Image-Space-Effects-图像空间影响" class="headerlink" title="12 Image-Space Effects 图像空间影响"></a><strong>12 Image-Space Effects</strong> 图像空间影响</h1><p><strong>制作图像比简单地描绘物体要复杂得多。使图像看起来真实的一部分就是使它看起来像一张照片。就像摄影师调整他们的最终结果一样，我们也可能希望修改，比如说，色彩平衡。在渲染图像中添加胶片纹理、渐晕和其他细微的变化可以使渲染看起来更有说服力。另一方面，更戏剧化的效果，如镜头光晕和开花可以传达戏剧感。描绘景深和运动模糊可以增加现实主义和艺术效果。</strong></p>
<p><strong>利用GPU可以有效地对图像进行采样和处理。在本章中，我们首先讨论如何使用图像处理技术修改渲染后的图像。额外的数据，如深度和法线，可以用来增强这些操作，例如，允许平滑噪声区域，同时仍然保留尖锐的边缘。重投影方法可以用来节省阴影计算，或快速创建缺失的帧。最后，我们提出了各种基于样本的技术，以产生镜头光晕，bloom，景深，运动模糊和其他效果。</strong></p>
<h2 id="Image-Processing-图像处理"><a href="#Image-Processing-图像处理" class="headerlink" title="Image Processing 图像处理"></a>Image Processing 图像处理</h2><p><strong>图形加速器通常关注从几何和阴影描述创建人工场景。图像处理是不同的，我们用不同的方法对输入图像进行修改。可编程着色器和使用输出图像作为输入纹理的能力的结合，为使用GPU实现各种图像处理效果开辟了道路。这种效果可以与图像合成相结合。通常，生成一个图像，然后对其执行一个或多个图像处理操作。渲染后修改图像被称为后处理。在渲染单个帧时，可以执行大量的通道，访问图像、深度和其他缓冲区。例如，《战地4》拥有超过50种不同类型的渲染通道，尽管并非所有通道都在同一帧中使用。</strong></p>
<p><strong>使用GPU进行后处理有几个关键技术。场景以某种形式呈现到屏幕外缓冲区，如彩色图像、z-depth缓冲区或两者兼有。然后将生成的图像作为纹理处理。这个纹理应用于填充屏幕的四边形。后期处理是通过渲染这个四边形来完成的，因为像素着色程序将为每个像素调用。大多数图像处理效果依赖于在相应像素处检索图像texel的信息。根据系统限制和算法，这可以通过从GPU检索像素位置或通过向四边形分配范围为[0,1]的纹理坐标并根据进入的图像大小缩放来实现。</strong></p>
<p><strong>实际上，填充屏幕的三角形可能比四边形更有效。例如，在AMD GCN架构上，当使用单个三角形而不是由两个三角形组成的四边形时，图像处理速度提高了近10%，这是由于更好的缓存相干性。三角形被做得足够大，足以填满整个屏幕。参见下图。无论使用何种原始对象，其目的都是相同的:让像素着色器为屏幕上的每个像素进行评估。这种类型的渲染称为全屏传递。如果可以，您还可以使用计算着色器来执行图像处理操作。如上所述，这样做以后有几个好处。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017152939.png" class="" title="image-20211017152939">

<p>在左边，一个填充屏幕的四边形，显示了(u, v)纹理坐标。在右侧，一个三角形填满了屏幕，它的纹理坐标经过适当调整以提供相同的映射。</p>
<p><strong>使用传统的管线，舞台现在设置为像素着色器访问图像数据。检索所有相关的相邻样本，并对其进行操作。邻居的贡献由一个值加权，该值取决于其相对于被评估像素的位置。有些操作，如边缘检测，有一个固定大小的邻域(例如，3 × 3像素)，每个邻域和像素本身的原始值具有不同的权值(有时是负的)。每个texel的值乘以其相应的权重，并对结果进行求和，从而产生最终结果。</strong></p>
<p><strong>如第5.4.1节所述，可以使用各种滤波核来重构信号。以类似的方式，可以使用滤镜核来模糊图像。旋转不变滤波核是指分配给每个贡献texel的权重不依赖于径向角度的核。也就是说，在滤波操作中，这样的滤波核完全用一个texel到中心像素的距离来描述。在第135页的5.22号方程中，sinc过滤器是一个简单的例子。高斯滤波器，即众所周知的钟形曲线，是一种常用的核函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017153055.png" class="" title="image-20211017153055">

<p><strong>其中r为到texel中心的距离，σ为标准差;σ² 叫做方差。标准差越大，钟形曲线越宽。一个粗略的经验法则是使支持，过滤器大小，3σ像素宽或更大，作为一个开始。更广泛的支持提供更多的模糊，以更多的内存访问为代价。</strong></p>
<p><strong>e前面的这一项使连续曲线下的面积等于1。然而，当形成一个离散滤波器核时，这一项是无关的。每像素计算的值在面积上相加，然后所有值除以这个和，这样最终的权重总和为1。由于这种规范化过程，常数术语没有任何用途，因此经常不在过滤器内核描述中显示。如下图所示的高斯二维和一维滤波器就是这样形成的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017153308.png" class="" title="image-20211017153308">

<p>执行高斯模糊的一种方法是采样一个5 × 5的区域，加权每个贡献并相加。图的(a)部分显示了σ = 1的模糊核的权重。第二种方法是使用可分离过滤器。连续执行两个一维高斯模糊(b)和(c)，结果相同。第一次通过，如图(b)所示，对5行单独的行，使用该行中的5个样本水平模糊每个像素。第二步，(c)，对(b)的结果图像应用5个样本的垂直模糊过滤器，以得到最终结果。将(b)中的权重乘以(c)中的权重得到与(a)中相同的权重，这表明该滤波器是等价的，因此可以分离。与(a)中需要25个样本不同，(b)和(c)中的每个都有效地使用了每像素5个样本，总共10个样本。</p>
<p><strong>sinc滤波器和高斯滤波器的一个问题是函数会无限延伸。一个权宜之计是将这样的过滤器夹紧到一个特定的直径或方形区域，并简单地将任何超出这个范围的东西视为值为零。其他过滤核是为各种特性而设计的，例如易于控制、平滑性或评估的简单性。Bjorke和Mitchell等提供了一些常用的旋转不变滤波器等关于GPU上图像处理的信息。</strong></p>
<p><strong>任何全屏过滤操作都将尝试从显示边界之外取样像素。例如，如果您为屏幕上的左上角像素收集3×3样本，则您正在尝试检索不存在的像素。一个基本的解决方案是设置纹理采样器钳到边缘。当请求一个离屏的、不存在的texel时，将检索最近的边缘texel。这将导致图像边缘的过滤错误，但这些错误通常是不明显的。另一种解决方案是生成过滤后的图像，其分辨率略高于显示区域，这样这些离屏像素就会存在。</strong></p>
<p><strong>使用GPU的一个优势是内置的插值和mipmapping硬件可以帮助最小化象素访问的数量。例如，我们的目标是使用框式过滤器。，取九个像素的平均值，在给定像素周围形成一个3 × 3的网格，并显示这个模糊的结果。这9个纹理样本将被像素着色器加权并相加，然后将模糊结果输出到像素。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017153629.png" class="" title="image-20211017153629">

<p>在左边，通过执行9个纹理样本并将其平均在一起，应用了一个方框过滤器。在中间，使用了5个样本的对称模式，外部的每个样本代表两个像素，因此每个样本的权重是中心样本的两倍。这种类型的模式可以用于其他过滤器内核，通过在它们的两个像素之间移动外部样本，每个像素的相对贡献可以改变。在右边，使用了更有效的四样本模式。左上方的样本在四个像素值之间进行插值。那些在右上方和左下方的每个插值两个像素的值。每个样本都被赋予与它所代表的像素数成比例的权重。</p>
<p><strong>然而，9个显式示例操作是不必要的。通过使用纹理的双线性插值，一次纹理访问可以检索最多四个相邻像素的加权和。使用这个想法，3 × 3网格可以通过4次纹理访问进行采样。参见上图。对于一个盒子过滤器，在重量相等的情况下，一个样本可以放置在四个像素的中间，得到四个像素的平均值。对于高斯滤波器，权值的不同使得四个样本之间的双线性插值可能是不准确的，每个样本仍然可以被放置在两个像素之间，但偏移更接近其中一个。例如，假设一个像素的重量是0.01，而它的相邻像素的重量是0.04。可以将样本放置到与第一个像素点的距离为0.8，与相邻像素点的距离为0.2，这样每个像素点就有了合适的比例。这个单一样本的重量将是两个像素的重量的总和，0.05。或者，高斯可以通过使用双线性插值样本为每四个像素，找到偏移，给出最接近理想权重的近似。</strong></p>
<p><strong>有些过滤核是可分离的。两个例子是高斯滤波器和箱形滤波器。这意味着它们可以应用于两个单独的一维模糊。这样做的结果是相当少的texel访问需要整体。成本从d² 到2d，其中d是内核直径或支持度。例如，假设盒子过滤器将应用于图像中每个像素的5 × 5区域。首先，图像可以水平过滤:左边和右边相邻的两个texel，每个像素右侧的两个像素以及像素值本身的权重相等乘以0.2，相加。然后生成的图像被垂直模糊，上面和下面的两个相邻像素与中心像素平均。例如，玩家可以通过两次访问总共10个像素，而不是一次访问25个像素。参见上上图。更宽的过滤器内核受益更多。</strong></p>
<p><strong>圆磁盘滤波器对散景效果很有用(第12.4节)，由于在实数范围内不可分离，所以通常计算起来很昂贵。然而，使用复数打开了一个广泛的函数家族。Wronski讨论了这种可分离滤波器的实现细节。</strong></p>
<p><strong>计算着色器很适合滤波，与像素着色器相比，核越大，性能越好。例如，线程组内存可以用来共享不同像素的滤波计算之间的图像访问，从而降低带宽。任何半径的盒过滤器都可以通过使用计算着色器的分散写入来实现。对于水平和垂直通道，计算行或列中第一个像素的核值。每个连续像素的结果是通过在核的前沿加入下一个样本，并减去在远端留下的样本来确定的。这种“移动平均”技术可以用来在常数时间内近似任意大小的高斯模糊。</strong></p>
<p><strong>向下采样是另一个GPU相关的技术，通常用于模糊。其想法是将要操作的图像缩小，例如，沿两个轴将分辨率减半，以制作四分之一屏幕图像。根据输入数据和算法的要求，原始图像可能会在尺寸上被过滤或简单地以较低的分辨率创建。当这个图像被访问到最终的，全分辨率的图像，纹理的放大将使用双线性插值来混合样本。这将产生进一步的模糊效果。在原始图像的小版本上执行操作，可以显著减少访问的texels总数。此外，任何应用于这幅较小图像的过滤器都有增加过滤器核的相对大小的净效果。例如，应用一个宽度为5的内核。对于较小的图像，在效果上类似于对原始图像应用宽度为9的核函数。质量将会降低，但对于许多眩光效果和其他现象的常见情况下的大面积相似颜色的模糊，大多数伪影将是最小的。减少每像素的比特数是降低内存访问成本的另一种方法。下行采样可以用于其他缓慢变化的现象，例如，许多粒子系统可以以半分辨率渲染。这种下采样的想法可以扩展到创建图像的mipmap，并从多层采样，以提高模糊过程的速度。</strong></p>
<h3 id="Bilateral-Filtering-双边滤波"><a href="#Bilateral-Filtering-双边滤波" class="headerlink" title="Bilateral Filtering 双边滤波"></a>Bilateral Filtering 双边滤波</h3><p><strong>使用某种形式的双边滤波器可以改进上采样结果和其他图像处理操作。这个想法是要抛弃或降低影响与中心样品表面无关的样品。这个过滤器是用来保留边缘的。想象一下，你把相机聚焦在远处蓝色物体前面的红色物体上，背景是灰色的。蓝色的物体应该是模糊的，红色的物体应该是锐利的。一个简单的双边过滤器将检查像素的颜色。如果是红色，就不会出现模糊——物体仍然是锐利的。否则，像素会被模糊。所有非红色的样本将被用来模糊像素。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017154803.png" class="" title="image-20211017154803">

<p>双边滤波器。左上方是原始图像。在左下角，我们模糊并使用那些非红色像素的样本。在右侧显示了一个像素的滤波核。红色像素在计算高斯模糊时被忽略。其余像素的颜色乘以相应的滤波器权重并相加，这些权重的总和也被计算出来。在这种情况下，权重之和为0.8755，因此计算出的颜色除以这个值。</p>
<p><strong>对于本例，我们可以通过检查像素的颜色来决定忽略哪些像素。联合或交叉双边滤波器使用额外的信息，如深度、法线、识别值、速度或其他数据，以确定是否使用邻近的样本。例如，Ownby等人展示了当仅使用少量样本进行阴影映射时，模式是如何产生的。模糊这些结果看起来好得多。然而，一个物体上的阴影不应该影响另一个不相关的模型，模糊会使阴影在物体的边缘外流血。他们使用双边滤波器，通过比较给定像素与其相邻像素的深度来丢弃不同表面上的样本。以这种方式减少一个区域的变异性被称为去噪，通常用于屏幕空间环境遮挡算法(章节11.3.6)。</strong></p>
<p><strong>仅使用与相机的距离来寻找边缘往往是不够的。例如，穿过两个立方体面之间形成的边缘的软阴影可能落在上面只有一张脸，另一张脸背光。当模糊时，仅仅使用深度可能会导致阴影从一张脸流到另一张脸，因为这个边缘不会被检测到。我们可以通过只使用那些深度和表面法线与中心样本相似的邻居来解决这个问题。这样做会限制样本跨越共享边缘，因此这种双边滤波器也被称为边缘保持滤波器。决定是否以及在多大程度上削弱或忽略邻近样本的影响取决于开发人员，并取决于诸如模型、渲染算法和查看条件等因素。</strong></p>
<p><strong>除了花费额外的时间检查邻居和加权，双边过滤还有其他性能代价。滤波优化方法如双通道可分滤波和双线性插值加权采样更难使用。我们事先不知道哪些样本应该被忽略或削弱影响，所以我们不能使用GPU在一次“点击”中收集多个图像像素的技术。也就是说，可分离双通滤波器的速度优势导致了近似方法的产生。</strong></p>
<p><strong>Paris等人讨论了双边滤波器的许多其他应用。双边滤波器应用于边缘必须保留但样本可以重复使用以减少噪声的地方。它们也被用来从几何体渲染的频率中分离阴影频率。例如，Yang等人以较低的分辨率进行阴影处理，然后使用法线和深度，在上采样期间进行双边滤波，形成最终帧。另一种方法是最接近深度滤波，即检索低分辨率图像中的4个样本，使用深度最接近高分辨率图像深度的样本。Hennessy和Pesce对这些方法和其他上采样方法进行了对比和比较。低分辨率渲染的一个问题是细节可能会丢失。Herzog等人通过利用时间相干和再投影进一步提高了质量。注意，双边滤波器是不可分离的，因为每个像素的样本数量可以变化。Green指出，将其视为可分离的伪影可以被其他着色效果隐藏。</strong></p>
<p><strong>实现后处理光线的一种常见方法是使用乒乓缓冲区。这只是在两个屏幕外缓冲区之间应用操作的想法，每个缓冲区用于保存中间或最终结果。对于第一次传递，第一个缓冲区是输入纹理，第二个缓冲区是输出发送的地方。在接下来的传递中，角色颠倒了，第二个作为输入纹理，第一个用于输出。在第二次传递中，第一个缓冲区的原始内容被覆盖——它是临时的，被用作处理传递的临时存储。管理和重用瞬态资源是设计现代渲染系统的关键因素。从架构的角度来看，让每个单独的通道执行特定的效果是很方便的。然而，为了提高效率，最好是将尽可能多的效果结合在一起。</strong></p>
<p><strong>在前几章中，访问相邻像素着色器用于形态反锯齿、软阴影、屏幕空间环境遮挡和其他技术。后期处理的效果一般是运行在最终的图像上，并且可以模仿热成像，再现膜粒和色差，进行边缘检测，产生热微光和波纹，分割图像，帮助渲染云，并执行大量其他操作。第15.2.3节介绍了一些用于非真实感渲染的图像处理技术。参见下图中的几个示例。它们都使用一个彩色图像作为唯一的输入。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017155210.png" class="" title="image-20211017155210">

<p>使用像素着色器的图像处理。对左上方的原始图像进行了各种处理。右上部分为高斯差分运算，左下部分为边缘检测，右下部分为边缘检测与原始图像混合后的合成图像。(图片由NVIDIA公司提供。)</p>
<p><strong>在本章结束时，我们将使用各种广告牌和图像处理技术实现一些效果，而不是继续穷尽(和耗尽)所有可能的算法。</strong></p>
<h2 id="Reprojection-Techniques-重投影技术"><a href="#Reprojection-Techniques-重投影技术" class="headerlink" title="Reprojection Techniques 重投影技术"></a>Reprojection Techniques 重投影技术</h2><p><strong>重投影是基于重用前一帧中计算的样本的思想。顾名思义，这些示例从一个新的查看位置和方向尽可能地重用。重投影方法的一个目标是摊销几帧的渲染成本，即利用时间一致性。因此，这也与5.4.2节中涉及的时间抗锯齿有关。另一个目标是，如果应用程序未能及时完成当前帧的渲染，则形成一个近似结果。这种方法在虚拟现实应用中尤其重要，以避免模拟出错(第21.4.1节)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017155347.png" class="" title="image-20211017155347">

<p>t−1时刻的绿色三角形和蓝色三角形以及t时刻之后的坐标系，三维点pi^t在两个像素中心的绿色三角形上，连同像素面积反向投影到点pi ^(t−1)上。可以看出，如果没有着色结果可以重用，当p0 ^t是可见的，p0 ^(t−1)是闭塞的。然而,p1 在t−1和t处都可见，那么着色可能会被重用。(Nehab等人的插图。)</p>
<p><strong>重投影方法分为反向重投影和正向重投影。反投影的基本思想如上图所示。呈现一个三角形在时间t时,顶点位置的计算当前帧(t)和前(t−1)。使用顶点着色,z和w的像素着色器可以计算一个插入值z / w,t和t−1,如果他们足够近,双线性查找在pi^(t−1)可以在前面的颜色缓冲中完成，并且可以使用那个着色值来代替计算一个新的着色值。对于之前被遮挡的区域，然后变得可见(例如，上图中的深绿色区域)，没有着色像素可用。这被称为缓存丢失。在这样的事件中，我们计算新的像素着色来填补这些洞。由于重用阴影值假设它们独立于任何类型的运动(物体，摄像机，光源)，明智的做法是不要在太多的帧中重复使用着色值。Ne- hab等人建议自动刷新应该总是发生在几帧重复使用之后。一种方法是将屏幕分成n组，每组都是2 × 2像素区域的伪随机选择。每一帧，一个组被更新，避免重用像素值太长时间。反向重投影的另一种变体是存储一个速度缓冲区并在屏幕空间中执行所有测试，这避免了顶点的双重转换。</strong></p>
<p><strong>为了更好的质量，还可以使用运行平均滤波器，它会逐渐淘汰旧值。这些特别推荐用于空间抗锯齿、软阴影和全局照明。过滤器描述为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211017161745.png" class="" title="image-20211017161745">

<p><strong>其中c (p^t)为 p^t处新着色像素值，c (p^(t−1)是前一帧的反投影颜色，cf (p^t)是应用滤镜后的最终颜色。Nehab等人在一些用例中使用α = 3/5，但建议根据渲染内容尝试不同的值。</strong></p>
<p><strong>正向重投影从帧t−1的像素开始工作，并将它们投影到帧t中，因此不需要双顶点着色。这意味着像素从t-1分散到t帧,而反向重投影方法收集来自t−1帧像素值t。这些方法还需要处理成为可见的闭塞的地区,这是通常使用不同的启发式hole-filling方法完成,即缺失区域的值是从周围像素推断出来的。Yu等人使用正向重投影以廉价的方式计算景深效应。Didyk等人利用基于运动向量的自适应生成框架t−1上的网格，避免了传统的孔洞填充。这个网格通过深度测试进行渲染，并投影到帧t中，这意味着遮挡和折叠是通过深度测试对自适应网格三角形进行栅格化处理的一部分。Didyk等人使用他们的方法从左眼重新投射到右眼，以便为虚拟现实生成一对立体图像，在虚拟现实中，两幅图像之间的相干性通常很高。后来，Didyk等人提出了一种感知动机的方法来执行时间上采样，例如，将帧率从40 Hz增加到120 Hz。</strong></p>
<p><strong>Yang和Bowles提出了将两个在t和t+1处的帧投影到两个帧之间的t+δt处的帧的方法，δt∈[0,1]。这些方法有更大的机会更好地处理遮挡情况，因为它们使用两个帧而不是一个。在游戏中使用这种方法可以将帧率从30帧提高到60帧，这是可能的，因为它们的方法运行时间不到1毫秒。我们推荐他们的课程笔记和Scherzer等人对时间相干方法的广泛调查。Valient在《Killzone: Shadow Fall》中也使用了重投影来加速渲染。请参阅5.4.2节末尾的大量参考资料，了解使用重投影进行时间抗锯齿的实现细节。</strong></p>
<h2 id="Lens-Flare-and-Bloom-镜头光晕和泛光"><a href="#Lens-Flare-and-Bloom-镜头光晕和泛光" class="headerlink" title="Lens Flare and Bloom 镜头光晕和泛光"></a>Lens Flare and Bloom 镜头光晕和泛光</h2><p><strong>镜头光晕是光线通过镜头或眼睛通过间接反射或其他非预期路径传播而引起的现象。光晕可以根据几种现象分类，最显著的是晕轮（halo）和纤毛冕（ciliary corona）。光晕是由透镜物质结构的径向纤维引起的。它看起来像光周围的一个环，外部边缘是红色的，内部是紫色的。不论光源的距离如何，光晕的视大小是恒定的。睫状日冕来自透镜的密度波动，表现为从一点辐射出来的射线，这一点可以延伸到光晕之外。</strong></p>
<p><strong>当镜头的一部分在内部反射或折射光线时，镜头也会产生二次效应。例如，由于相机的光圈叶片，可以出现多边形图案。由于玻璃上的小凹槽，也可以看到光条纹涂抹在挡风玻璃上。水华是由晶状体和眼睛其他部位的散射造成的，在光线周围产生辉光，并使场景其他部位的对比度变暗。摄像机通过利用电荷耦合器件(CCD)将光子转换成电荷来捕捉图像。当CCD中的电荷饱和并溢出到邻近的位置时，摄像机就会发生泛光。光晕、日冕和泛光作为一个类别被称为眩光效应。</strong></p>
<p><strong>事实上，随着相机技术的进步，大多数这样的人工制品越来越少被看到。更好的设计、镜头罩和抗反射涂层可以减少或消除这些杂散的鬼影现象。然而，这些效果现在通常是通过数字技术添加到真实照片中。由于计算机显示器产生的光强度是有限的，我们可以通过在图像中添加这样的效果来给场景或物体增加亮度的印象。由于泛光效果和镜头光晕的普遍使用，它们在照片、电影和交互式计算机图形中几乎是陈词滥调。然而，如果运用得当，这些效果可以给观众强烈的视觉暗示。</strong></p>
<p><strong>为了提供令人信服的效果，镜头光晕应该随光源的位置而变化。King创建了一组不同纹理的正方形来代表镜头光晕。然后将它们从屏幕上的光源位置通过屏幕中心指向一条直线。当光线远离屏幕中心时，这些正方形会变小，变得更透明;当光线向内移动时，这些正方形会变大，变得更不透明。Maughan通过使用GPU计算屏幕区域光源的遮挡来改变镜头光斑的亮度。他生成一个单像素强度纹理，然后用来减弱效果的亮度。Sekulic将光源渲染为单个多边形，使用遮挡查询硬件给出可见区域的像素计数(章节19.7.1)。为了避免GPU在等待查询返回一个值到CPU时陷入停滞，结果将在下一帧中用于确定衰减量。由于强度很可能以一种相当连续和可预测的方式变化，单个帧的延迟几乎不会引起知觉混乱。Gjøl和Svendsen首先生成一个深度缓冲器(他们也用于其他效果)，并以螺旋方式采样32次在镜头光晕将出现的区域的图案，使用结果来衰减光晕纹理。可见性采样是在渲染光晕几何图形时在顶点着色器中完成的，因此避免了硬件遮挡查询造成的延迟。</strong></p>
<p><strong>在一个场景中，明亮的物体或灯光的条纹可以通过类似的方式来执行，要么绘制半透明的广告牌，要么对明亮的像素本身执行后处理过滤。像《侠盗猎车手V》这样的游戏使用了一组纹理用于广告牌上的这些和其他效果。</strong></p>
<p><strong>Oat讨论了使用可操纵滤波器来产生条纹效应。这种类型的过滤器被指定一个方向，而不是在一个区域上对称地过滤。沿着这个方向的Texel值相加，产生条纹效果。使用一个向下采样到宽度和高度的四分之一的图像，并使用ping-pong缓冲区进行两次传递，给出一个令人信服的条纹效果。下图显示了这种技术的一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018142602.png" class="" title="image-20211018142602">

<p>镜头光晕，恒星眩光和泛光效果，以及景深和运动模糊。注意一些移动球的频闪伪影，因为积累了单独的图像。(图片来自川濑正树(Masaki Kawase)的《Rthdribl》。)</p>
<p><strong>许多其他的变化和技术存在，远远超出了广告牌。Mit- tring使用图像处理来分离明亮的部分，对它们进行取样，并在几个纹理中模糊它们。然后通过复制、缩放、镜像和着色，将它们重新合成到最终的图像上。使用这种方法，艺术家不可能独立地控制每个耀斑源的外观:对每个耀斑应用相同的过程。然而，图像的任何明亮部分都可能产生镜头耀斑，比如镜面反射或表面发射部分，或明亮的火花粒子。Wronski描述了变形镜头闪光，这是20世纪50年代使用的电影摄影设备的副产品。Hullin等人提供了各种重影伪影的物理模型，追踪光束束来计算效果。它给出了可信的结果，是基于镜头系统的设计，以及精度和性能之间的权衡。Lee和Eisemann在这项工作的基础上建立了一个线性模型，避免了昂贵的预处理。Hennessy给出了实施细节。下图显示了生产中使用的典型镜头光晕系统。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018142824.png" class="" title="image-20211018142824">

<p>在《巫师3》中产生太阳耀斑的过程。首先，将高对比度校正曲线应用于输入图像，以隔离未遮挡的太阳部分。接下来，以太阳为中心的径向模糊，应用到图像上。如左图所示，模糊是在一个系列中执行的，每一个操作都对前一个操作的输出进行操作。这样做可以创建一个平滑的、高质量的模糊，同时在每个通道中使用有限数量的样本来提高效率。所有模糊都以半分辨率执行，以减少运行时成本。最终的耀斑图像与原始场景渲染相结合。(CD PROJEKT R, The Witcher R是CD PROJEKT Capital Group的注册商标。The Witcher game c CD PROJEKT S.A.版权所有《巫师》游戏是根据Andrzej Sapkowski的散文改编的。所有其他版权和商标均为其各自所有者的财产。)</p>
<p><strong>bloom效果，即一个非常明亮的区域溢出到相邻的像素上，是通过结合几种已经提出的技术来实现的。主要思想是创建一个只包含要“过度曝光”的明亮物体的bloom图像，模糊它，然后合成它到正常的图像。使用的模糊通常是高斯，尽管最近与参考镜头的匹配显示其分布有更多的尖峰形状。制作这幅图像的常用方法是采用亮通滤波器:保留所有亮像素，将所有暗像素变为黑色，通常在过渡点进行一些混合或缩放。对于只有几个小对象的bloom，可以计算一个屏幕边界框来限制后期处理模糊和合成通道的范围。</strong></p>
<p><strong>这张bloom图像可以在低分辨率下进行渲染，例如，宽度和高度是原始图像的1 / 2到1 / 8。这样做可以节省时间，并有助于提高过滤效果。这张分辨率较低的图像被模糊，并与原始图像结合在一起。这种降低分辨率的方法用于许多后处理效果，如压缩或降低颜色分辨率的技术。bloom图像可以向下采样几次，并从生成的图像集中重新采样，在最小化采样成本的同时提供更宽的模糊效果。例如，一个明亮的像素在屏幕上移动可能会导致闪烁，因为它可能在某些帧中没有被采样。</strong></p>
<p><strong>因为目标是使图像在明亮的地方看起来过度曝光，所以这张图像的颜色被按所需的比例缩放，并添加到原始图像中。添加剂混合使颜色饱和，然后变成白色，这通常正是所需要的。下图显示了一个示例。Alpha混合可以用于更艺术的控制。可以对高动态范围图像进行过滤，而不是阈值处理，获得更好的结果。低和高动态范围花华可以分别计算和合成，以更令人信服的方式捕捉不同现象。其他的变体也是可能的，例如，前一帧的结果也可以添加到当前帧，给动画对象一个条纹辉光。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143114.png" class="" title="image-20211018143114">

<p>高动态范围色调映射和开花。下面的图像是通过在原始图像上使用色调映射，并添加一个后期处理bloom来生成的。(图片来自育碧的《孤岛惊魂》)</p>
<h2 id="Depth-of-Field-景深"><a href="#Depth-of-Field-景深" class="headerlink" title="Depth of Field 景深"></a>Depth of Field 景深</h2><p><strong>对于一个给定设置的相机镜头，有一个焦点范围，它的景深。超出这个范围的物体是模糊的——越远越模糊。在摄影中，这种模糊与光圈大小和焦距有关。减小孔径可以增加景深。聚焦深度范围更广，但会减少形成图像的光量(第9.2节)。在白天室外拍摄的照片通常有很大的景深，因为光线充足，可以使用小光圈，最好是针孔相机。在光线不好的房间里，景深会大大缩小。因此，控制景深效果的一种方法是将其与色调映射联系起来，使失焦的物体随着光阶的降低而变得更加模糊。另一种是允许手工艺术控制，改变焦点和增加景深，以获得所需的戏剧性效果。参见下图中的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143256.png" class="" title="image-20211018143256">

<p>景深取决于相机的焦距。(图片由Morgan McGuire提供，G3D渲染。)</p>
<p><strong>累积缓冲器可以用来模拟景深。参见下图。通过改变镜头上的视角位置并保持焦点固定，物体将相对于他们离这个焦点的距离变得模糊。然而，与其他累积效果一样，这种方法的成本很高，每张图像需要多次渲染。也就是说，它确实收敛于正确的地面真理图像，这对测试很有用。光线追踪也可以收敛到物理上正确的结果，通过改变眼睛光线在光圈上的位置。为了提高效率，许多方法可以对没有焦点的对象使用较低级别的细节。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143345.png" class="" title="image-20211018143345">

<p>通过积累的景深。观察者的位置被移动了一小部分，保持视角指向焦点。每个渲染的图像被加到一起，并显示所有图像的平均值。</p>
<p><strong>虽然对于交互式应用程序来说是不切实际的，但是移动镜头上的视图位置的累积技术提供了一种合理的方式来考虑在每个像素上应该记录什么。表面可以分为三个区域:靠近焦点距离的区域(焦点场或中间场)，那些在(远场)和那些更近的区域(近场)。对于焦距处的表面，每个像素都显示一个锐焦点区域，因为所有累积的图像的结果大致相同。聚焦场是一个深度范围，在这个范围内，物体只有轻微的焦距，例如，小于半像素。这个范围就是摄影师所说的景深。在交互式计算机图形中，我们默认使用具有完美焦距的针孔相机，因此景深是指模糊近场和远场内容的效果。平均图像中的每个像素都是在不同视图中看到的所有表面位置的混合，从而模糊了失焦区域，这些位置可能有很大的差异。</strong></p>
<p><strong>一个有限的解决方案是创建独立的图像层。仅渲染聚焦对象的图像，一个物体在远处，一个物体在近处。这可以通过改变近/远剪切平面的位置来实现。不久的然后对远场图像进行模糊处理，然后将三幅图像按前后顺序合成在一起。这种2.5维的方法，之所以称为2.5维方法，是因为二维图像被赋予了深度并进行了组合，在某些情况下提供了合理的结果。当目标跨越多个图像，突然从模糊变为聚焦时，这种方法就失效了。此外，所有经过过滤的物体都具有统一的模糊度，不会因为距离而产生任何变化。</strong></p>
<p><strong>观察这个过程的另一种方法是考虑景深如何影响表面上的单个位置。想象表面上的一个小点。当表面聚焦时，圆点通过单个像素可见。如果表面是失焦的，点将出现在附近的像素，这取决于不同的观点。在限制下，点将在像素网格上定义一个填充圆。这被称为混乱圈。</strong></p>
<p><strong>在摄影中，焦点场以外区域的审美质量被称为“散景”，这个词来自日语，意思是“模糊”。(这个词的发音是“bow-ke”，“bow”在“bow and arrow”中，“ke”在“kettle”中)通过光圈的光线通常是均匀分布的，而不是某种高斯分布。混淆区形状与孔径叶片的数量、形状以及尺寸有关。廉价的相机产生的模糊是五角形而不是完美的圆形。目前，大多数新相机都有7个叶片，高端机型有9个或更多。更好的相机有圆形的叶片，使得散景是圆形的。对于夜间拍摄，光圈尺寸更大，可以有一个更圆的图案。类似于镜头光晕和光华被放大的效果，我们有时渲染一个六角形的圆圈，以暗示我们是用物理相机拍摄。正如Barr´e-Brisebois所解释的那样，六边形是一种特别容易在可分离的双通道后处理模糊中产生的形状，因此被用于许多游戏中。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143538.png" class="" title="image-20211018143538">

<p>分散操作获取像素值并将其传播到邻近区域，例如通过渲染一个圆形精灵。在集合中，邻近的值被采样并用于影响一个像素。GPU的像素着色器经过优化，可以通过纹理采样执行收集操作。</p>
<p><strong>计算景深效果的一种方法是取每个像素在一个表面上的位置，并将其阴影值分散到这个圆或多边形内的邻居。如上图左侧所示。散射的概念不能很好地映射到像素着色器的能力。像素着色器可以有效地并行操作，因为它们不会将结果传播给邻居。一个解决方案是为每个近场和远场像素渲染精灵(章节13.5)。每个精灵都被渲染到一个独立的场层中，精灵的大小由混乱圈的半径决定。每一层存储所有重叠精灵的平均混合和，然后将各层合成到下一层。这种方法有时被称为正演映射技术。即使使用图像下采样，这种方法也会很慢，更糟糕的是，需要的时间也会变，特别是当焦点是浅的时候。性能的可变性意味着很难管理框架预算，例如，分配给执行所有呈现操作的时间量。不可预测性会导致帧数缺失和用户体验不均衡。</strong></p>
<p><strong>另一种思考混乱圈的方法是假设一个像素周围的局部邻域有相同的深度。有了这个想法，收集操作就可以完成了。如上图的右侧所示。像素着色器被优化以收集以前渲染通道的结果。因此，执行景深效果的一种方法是根据深度模糊每个像素的表面。深度定义了一个混乱圈，这是一个区域应该采样的宽度。这种集合方法称为向后映射或反向映射方法。</strong></p>
<p><strong>大多数实用的算法都是从一个角度的初始图像开始。这意味着，从一开始，就缺少一些信息。场景的其他视图将看到在这个单一视图中不可见的部分表面。正如Pesce所指出的，我们应该尽可能地利用现有的可见样本。</strong></p>
<p><strong>收集技术经过多年的发展，每个都改进了以前的工作。我们提出了Bukowski等人的方法及其所遇到问题的解决方案。他们的方案根据深度为每个像素生成一个有符号的值，表示混沌半径的圆。这个半径可以从相机设置和特性中得到，但美工通常喜欢控制效果，所以近场、焦距和远场的范围可以任意指定。半径符号指定像素是在近场还是远场，−0.5 &lt; r &lt; 0.5是在焦点场，其中半像素模糊被认为在焦点。</strong></p>
<p><strong>这个缓冲区包含混乱圆半径，然后用来将图像分割为两个图像，近场和其余的，每个图像都向下采样，并在两个通过与可分离的过滤器模糊。这种分离是为了解决一个关键问题，即近场中的物体边缘应该是模糊的。如果我们根据其半径模糊每个像素，并输出到单个图像，前景对象可能是模糊的，但有尖锐的边缘。例如，当通过剪影边缘从前景对象到焦点对象时，样本半径将降为零，因为焦点对象不需要模糊。这将导致前景对象对周围像素的影响有一个突然下降，导致尖锐的边缘。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143711.png" class="" title="image-20211018143711">

<p>近场模糊。左边是没有景深效应的原始图像。在中间，近场的像素被模糊，但在靠近焦点场的地方有一个锐利的边缘。右边显示了使用一个单独的近场图像合成在更远处的内容上的效果。(使用G3D生成的图像。)</p>
<p><strong>我们想要的是让近场中的物体平滑模糊，并产生超出它们边界的效果。这是通过在单独的图像中写入和模糊近场像素来实现的。此外，该近场图像的每个像素被赋予一个alpha值，表示其混合因子，这也是模糊的。在创建两个独立的图像时使用联合双边滤波和其他测试;详情请参阅文章和代码。这些测试有几个功能，例如，对于远场模糊，丢弃远比采样像素远得多的邻近物体。</strong></p>
<p><strong>在进行了基于模糊半径圆的分离和模糊后，进行合成。混沌圆半径被用来在原始聚焦图像和远场图像之间进行线性插值。这个半径越大，使用的远场结果就越模糊。alpha覆盖值在近场图像然后被用来混合近图像在这个插值结果。通过这种方式，近场模糊的内容适当地扩展到后面的场景之上。参见图12.10和下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143823.png" class="" title="image-20211018143823">

<p>《巫师3》中的景深。近场和远场模糊令人信服地与焦点场混合。(CD PROJEKT R, The Witcher R是CD PROJEKT Capital Group的注册商标。The Witcher game c CD PROJEKT S.A.版权所有《巫师》游戏是根据Andrzej Sapkowski的散文改编的。所有其他版权和商标均为其各自所有者的财产。)</p>
<p><strong>该算法进行了几次简化和调整，使其看起来合理。粒子可以用其他方法处理得更好，而透明度可能会导致问题，因为这些现象涉及每个像素多个z深度。尽管如此，只有颜色和深度缓冲区作为输入，并且只使用三个后处理通道，这种方法简单且相对健壮。基于混淆圆的采样和将近场和远场分离成单独的图像(或一组图像)的想法是已开发的用于模拟景深的广泛算法中的一个共同主题。我们将讨论一些在电子游戏中使用的新方法，因为这些方法必须是有效的，可靠的，并且具有可预测的成本。</strong></p>
<p><strong>第一种方法使用了一种我们将在下一节再次讨论的方法:运动模糊。回到混沌圆的概念，想象把图像中的每个像素都变成对应的混沌圆，其强度与圆的面积成反比。按顺序绘制这组圆会得到最好的结果。这就把我们带回到散点的概念，所以通常是不切实际的。正是这种思维模式在这里很有价值。给定一个像素，我们想要确定所有重叠位置的混乱圈，并将它们按顺序混合在一起。参见下图。使用场景的最大混乱圈半径，对于每个像素，我们可以检查这个半径内的每个邻居，并找出其混乱圈是否包含我们当前的位置。然后对所有这些影响像素的重叠邻居样本进行分类和混合。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018143925.png" class="" title="image-20211018143925">

<p>重叠的混乱圈。左边是一个有五个点的场景，都是聚焦的。假设红点在近场中离观众最近，紧接着是橙点;绿色的圆点在焦点范围内;蓝色和紫色的点在远场，按这个顺序。右图显示了由于应用景深而产生的圆圈混乱，圆圈越大，每像素的效果越差。绿色是不变的，因为它是焦点。中心像素只被红色和橙色的圆圈重叠，所以这些被混合在一起，红色在橙色之上，以赋予像素颜色。</p>
<p><strong>这种方法是理想的，但是对发现的碎片进行排序在GPU上是非常昂贵的。相反地，我们使用了一种名为“在收集时分散”的方法，即我们通过寻找哪些邻居将分散到像素的位置来进行聚集。选择z-深度最小(最近距离)的重叠邻域来表示较近的图像。任何其他在z深度上与之相当接近的重叠邻域都将添加它们的阿尔法混合贡献，取平均值，并将颜色和阿尔法存储在“前景”层中。这种类型的混合不需要分类。所有其他重叠的邻居都被相似地求和并平均，结果被放在一个单独的“背景”层中。前景和背景层并不对应于近场和远场，它们是在每个像素的区域中碰巧找到的。前景图像然后在背景上合成图像，产生近场模糊效果。虽然这种方法听起来很复杂，但应用各种采样和过滤技术可以使其高效。参阅Jimenez、Sousa、Sterna和Courr’eges的介绍，了解一些不同的实现，并查看下图中的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211018144039.png" class="" title="image-20211018144039">

<p>近和远景深与五角形散景在明亮的反射杆在前景。(使用BakingLab演示生成的图像，由Matt Pettineo提供。)</p>
<p><strong>在一些较早的电子游戏中使用的另一种方法是基于计算热扩散的理念。图像被认为是一个向外扩散的热分布，每个混乱的圆圈代表该像素的导热率。聚焦区域是完美的绝缘体，没有扩散。Kass等人描述了如何将一维热扩散系统视为一个三对角矩阵，该矩阵可以在每个样品常数时间内求解。存储和解决这种类型的矩阵在计算着色器上工作得很好，所以实践者已经开发了几种实现，在这些实现中，图像沿着每个轴分解成这些一维系统。困惑圈的可见性问题仍然存在，通常通过基于深度生成和合成单独的层来解决。这种技术不能很好地处理混乱圈中的不连续点，如果有的话，所以在今天基本上是一种好奇。</strong></p>
<p><strong>一种特殊的景深效应是由明亮的光源或框架中的反射引起的。光或镜面反射的混乱圈可能比在画面中它附近的物体要亮得多，即使它在一个区域中被分散的变暗效果也是如此。虽然将每个模糊像素渲染为精灵是昂贵的，但这些明亮的光源对比度更高，因此更清楚地显示出光圈形状。</strong></p>
<p><strong>其余的像素差别较小，所以形状不那么重要。有时“散景”一词(错误地)被用来描述这些明亮的区域。检测高对比度区域并将这些明亮像素作为精灵进行渲染，同时使用收集技术对其余像素进行渲染，从而得到一个具有定义的散景，同时也是高效的。参见上图。计算着色器也可以使用，为收集景深和散景有效的溅射创建高质量的总和面积表。</strong></p>
<p><strong>我们已经介绍了许多渲染景深和明亮焦景效果的方法中的一些，描述了一些用来使过程有效的技术。随机光栅化、光场处理和其他方法也进行了探索。Vaidyanathan等人的文章总结了之前的工作，McGuire对一些实现进行了总结。</strong></p>
<h2 id="Motion-Blur-运动模糊"><a href="#Motion-Blur-运动模糊" class="headerlink" title="Motion Blur 运动模糊"></a>Motion Blur 运动模糊</h2><p><strong>为了呈现令人信服的图像序列，重要的是要有一个足够稳定和高的帧率。流畅和连续的运动是最好的，太低的帧率会体验到不稳定的运动。电影以24帧/秒的速度放映，但影院很暗，眼睛的时间反应对昏暗光线下的闪烁不太敏感。此外，电影放映机以24帧每秒的速度改变图像，但通过在显示下一张图像之前重新显示每个图像2-4次来减少闪烁。也许最重要的是，每一帧胶片通常都是一幅运动模糊图像;默认情况下，交互式图形图像不是。</strong></p>
<p><strong>在电影中，运动模糊来自于画面中物体在屏幕上的移动或摄像机的运动。这种效果来自于相机的时间快门打开的时间是1/40到1/60秒，而每帧的打开时间是1/24秒。我们习惯于在电影中看到这种模糊，并认为这很正常，所以我们希望在电子游戏中也能看到这种情况。快门打开不到1/500秒就会产生一种过度运动的效果，这种效果首次出现在电影《Gladiator》和《Saving Private Ryan》中。</strong></p>
<p><strong>快速移动的物体在没有运动模糊的情况下会出现抖动，在帧间“跳跃”许多像素。这可以被认为是一种走样，类似于锯齿，但本质上是时间而不是空间。运动模糊可以被认为是时域的抗锯齿。正如提高显示分辨率可以减少但不能消除锯齿一样，提高帧率也不能消除运动模糊的需要。电子游戏的特点是摄像机和物体的快速运动，所以运动模糊可以显著改善游戏的视觉效果。事实上，带有运动模糊的30帧/秒通常比没有的60帧/秒更好。</strong></p>
<p><strong>运动模糊依赖于相对运动。如果一个物体在屏幕上从左到右移动，它就会在屏幕上水平模糊。如果摄像机在跟踪一个移动的物体，物体不会变得模糊——背景会。参见下图。这就是现实世界的相机是如何工作的，一个好的导演知道拍摄一个镜头，使感兴趣的区域在焦点和不模糊。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211019112135.png" class="" title="image-20211019112135">

<p>在左边，摄像机是固定的，汽车是模糊的。在右侧，摄像机跟踪着这辆车，背景变得模糊。(图片由Morgan McGuire等人提供。)</p>
<p><strong>与景深相似，积累一系列图像提供了一种创建运动模糊的方法。当快门打开时，帧有一个持续时间。场景在这个跨度的不同时间被渲染，摄像机和对象被重新定位。得到的图像混合在一起，得到一个模糊的图像，其中物体相对于相机的视野移动。对于实时渲染，这样的过程通常是适得其反的，因为它可以大大降低帧率。此外，如果物体快速移动，当个别图像变得可识别时，伪影是可见的。第525页的图12.7也显示了这个问题。随机栅格化可以避免多幅图像混合时出现的重影伪影，而不是产生噪声。</strong></p>
<p><strong>如果想要的是运动的暗示而不是纯粹的现实主义，那么积累的概念可以巧妙地运用。假设已经生成了一个模型的8帧，并将其归结为一个高精度缓冲区，然后将其平均并显示出来。在第九帧，模型被再次渲染累积，但也在这个时候，第一个帧的渲染再次执行，并从求和结果中减去。缓冲区现在有8帧模糊模型，从第2帧到第9帧。在下一帧，我们减去第二帧，加上第十帧，同样得到八帧的和，从3到10。这给了一个高度模糊的艺术效果，以每帧渲染场景两次为代价。</strong></p>
<p><strong>实时图形需要比多次渲染帧更快的技术。景深和运动模糊都可以通过平均一组视图来呈现，这表明了这两种现象之间的相似性。为了有效地渲染这些，这两种效果都需要将它们的样本分散到相邻的像素上，但我们通常会收集它们。他们还需要处理多个不同的模糊层，并根据单个起始帧的内容重建被遮挡的区域。</strong></p>
<p><strong>运动模糊有几个不同的来源，每一个都有可以应用到它的方法。这些可以分为摄像机方向变化、摄像机位置变化、对象位置变化和对象方向变化，其复杂度大致呈递增顺序。如果摄像机保持它的位置，整个世界可以被认为是围绕着观众的天空盒(第13.3节)。方向的改变会在整个图像上创建有方向的模糊。给定一个方向和速度，我们沿着这个方向对每个像素进行采样，速度决定了过滤器的宽度。这种方向模糊被称为线积分卷积(LIC)，它也被用于可视化流体流动。Mitchell讨论了给定运动方向的运动模糊立方环境映射。如果摄像机沿其视图轴旋转，则使用圆形模糊，每个像素的方向和速度相对于旋转中心发生变化。</strong></p>
<p><strong>如果相机的位置发生变化，视差就会起作用，例如，远处的物体移动得更慢，因此模糊程度也更小。当相机向前移动时，视差可能被忽略。放射状模糊可能是足够的，并可以夸大戏剧性的效果。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211019112325.png" class="" title="image-20211019112325">

<p>径向模糊增强运动的感觉。(图片来自育碧的《刺客信条》)</p>
<p><strong>为了增加真实感，比如在赛车游戏中，我们需要一个模糊的图像来正确计算每个物体的运动。如果在向前看的同时侧向移动，在计算机图形学中称为平移，深度缓冲告诉我们每个物体应该被模糊的程度。物体越靠近，就越模糊。如果向前移动，移动的量就更复杂了。Rosado描述了使用前一帧的相机视图矩阵来计算飞行速度。其想法是将像素的屏幕位置和深度转换回世界空间位置，然后使用前一帧的相机将这个世界点转换到屏幕位置。这些屏幕空间位置之间的区别是速度向量，它用于模糊该像素的图像。合成对象可以以四分之一屏幕大小渲染，既可以节省像素处理，又可以滤除采样噪声。</strong></p>
<p><strong>如果物体彼此独立运动，情况就会更加复杂。一个直接但有限的方法是建模和渲染模糊本身。这是绘制线段来表示运动粒子的基本原理。这个概念可以扩展到其他对象。想象一把剑划过天空。在叶片前后，沿着其边缘添加两个多边形。这些可以在运行中建模或生成。这些多边形每个顶点都使用alpha不透明度，所以当多边形遇到剑时，它是完全不透明的，而在多边形的外缘，alpha是完全透明的。这个模型在移动方向上是透明的，模拟的效果是，当(想象的)快门打开时，剑只在部分时间覆盖这些像素。</strong></p>
<p><strong>这种方法可以用于简单的模型，如摇摆的剑刃，但纹理、亮点和其他特征也应该是模糊的。每个移动的表面都可以看作是单个的样本。我们希望分散这些样本，早期的运动模糊方法就是这样做的，方法是沿着运动的方向扩展几何体。这种几何操作是昂贵的，所以就开发了“即聚即散”的方法。对于景深，我们将每个样本扩展到其混沌圆的半径。对于移动样本，我们代替将每个样本沿着它在帧内行进的路径拉伸，类似于LIC。一个快速移动的样本覆盖的面积更大，所以对每个地点的影响更小。理论上，我们可以在一个场景中取所有的样本，并把它们按照有序的顺序画成半透明的线段。如下图所示。随着采样次数的增加，产生的模糊在前后边缘有一个平滑的透明梯度，就像我们的剑的例子一样。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211019112459.png" class="" title="image-20211019112459">

<p>在左边，一个水平移动的样本给出一个透明的结果。在右侧，7个样本产生了渐缩效果，因为覆盖外部区域的样本更少。中间的区域是不透明的，因为在整个画面中它总是被一些样本覆盖着。(在吉梅内斯)。</p>
<p><strong>要使用这个想法，我们需要知道每个像素表面的速度。一个被广泛采用的工具是速度缓冲器的使用。要创建这个缓冲区，请在模型的每个顶点上插入屏幕空间速度。速度可以通过对模型应用两个建模矩阵来计算，一个用于前一帧，一个用于当前帧。顶点着色程序计算位置的差异，并将这个向量转换为相对的屏幕空间坐标。如下图所示。Wronski讨论了速度缓冲器的推导和运动模糊与时间抗锯齿的结合。Courr’eges简要说明了《毁灭战士》(2016)是如何实现这一组合的，并比较了结果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211019112601.png" class="" title="image-20211019112601">

<p>运动模糊由于物体和相机的运动。嵌入了深度和速度缓冲区的可视化。(图片由Morgan McGuire等人提供。)</p>
<p><strong>一旦形成了速度缓冲区，就可以知道每个像素处的每个对象的速度。未模糊的图像也被渲染。注意，我们在处理景深时也遇到了类似的问题，即计算效果所需的所有数据都无法从单一图像中获得。对于景深的理想情况是将多个视图平均在一起，其中一些视图将包括其他视图中看不到的对象。对于交互式运动模糊，我们从时间序列中取出一帧，并使用它作为代表图像。我们尽可能地使用这些数据，但重要的是要认识到所需的所有数据并不总是在那里，这可能会创建工件。</strong></p>
<p><strong>给定这一帧和速度缓冲，我们可以使用“散点即收集”的运动模糊系统，重建影响每个像素的对象。我们从McGuire等人描述的方法开始，并由Sousa和Jimenez进一步发展(Pettineo提供代码)。在第一遍中，计算屏幕各部分的最大速度，例如每个8 × 8像素贴图(第23.1节)。结果是每个贴图有一个最大速度的缓冲区，一个有方向和大小的矢量。在第二步中，每个贴图都会检查一个3 × 3的贴图结果缓冲区，以便找到最大值。这一关确保了在贴图中快速移动的物体会被相邻的贴图所影响。也就是说，我们对场景的初始静态视图将变成一个物体模糊的图像。这些模糊会重叠到相邻的贴图上，所以这些贴图必须检查足够宽的区域才能找到这些移动的物体。</strong></p>
<p><strong>最后对运动模糊图像进行了计算。类似于景深，每个像素的邻域检查可能快速移动和重叠像素的样本。不同之处在于，每个样本都有自己的速度，沿着自己的路径。已经开发了不同的方法来过滤和混合相关的样品。一种方法是利用最大速度的大小来确定核的方向和宽度。如果这个速度小于半个像素，则不需要运动模糊。否则，图像沿最大速度方向采样。注意，遮挡在这里很重要，因为它与景深有关。一个在静态对象后面快速移动的模型不应该让它的模糊效果在这个对象上扩散。如果发现相邻样本的距离与像素的z深度足够接近，则认为它是可见的。这些样品混合在一起形成前景的贡献。</strong></p>
<p><strong>在上上图中，运动模糊的物体有三个区域。不透明区域完全被前景对象覆盖，因此不需要进一步混合。在原始图像中，外部模糊区域(顶部一行有7个蓝色像素)有一个可用的背景颜色，在这些像素上可以混合前景。然而，内部模糊区域不包含背景，因为原始图像只显示前景。对于这些像素，背景估计是通过滤波的邻居采样的像素不在前景中，理由是任何对背景的估计总比什么都没有好。上图显示了一个示例。</strong></p>
<p><strong>有几种采样和过滤方法用于改进这种方法的外观。为了避免重影，样本位置随机抖动半个像素。在外部模糊区域，我们有正确的背景，但模糊一点可以避免与内部模糊估计的背景不连贯。一个像素点上的对象可能会以与3×3贴图组的主导速度不同的方向移动，因此在这种情况下可以使用不同的过滤方法。Bukowski等人提供了其他实现细节，并讨论了针对不同平台的扩展方法。</strong></p>
<p><strong>这种方法对运动模糊效果很好，但其他系统当然也有可能，在质量和性能之间进行权衡。例如，Andreev使用速度缓冲和运动模糊，以便在以30帧/秒渲染的帧之间插入，有效地提供60帧/秒的帧率。另一个概念是将运动模糊和景深结合到一个系统中。其核心思想是将速度矢量和混淆圆结合，得到统一的模糊核。</strong></p>
<p><strong>其他方法也被研究过，随着GPU的性能和性能的提高，研究还将继续。例如Munkberg等人使用随机和交错采样在低采样率下渲染景深和运动模糊。在随后的过程中，他们使用快速重建技术来减少采样伪影，恢复运动模糊的平滑特性和景深。</strong></p>
<p><strong>在电子游戏中，玩家的体验通常不像看电影，而是在他们的直接控制下，视角以不可预测的方式改变。在这种情况下，如果纯粹基于相机，运动模糊有时会应用得很糟糕。例如，在第一人称射击游戏中，有些用户发现旋转会让人分心或晕车。在《使命召唤:高级战争》中，有一个选项可以移除由于摄像机旋转而产生的运动模糊，所以这种效果只适用于移动的物体。美术团队在游戏过程中移除旋转模糊，并在一些电影序列中打开它。平移运动模糊仍然被使用，因为它有助于传达跑步时的速度。另外，艺术指导也可以用于修改运动模糊，这是物理电影摄像机无法模拟的。假设一艘飞船进入了用户的视野，而摄像机没有跟踪它，也就是说。玩家不会转过头。使用标准的运动模糊，船将是模糊的，即使玩家的眼睛在跟随它。如果我们假设玩家将追踪一个对象，我们便可以相应地调整算法，在观众的眼睛追随背景时模糊背景，并保持对象不模糊。</strong></p>
<p><strong>眼球追踪设备和更高的帧率可能有助于改进运动模糊的应用，或完全消除它。然而，这种效果会让人产生一种电影般的感觉，所以它可能会继续以这种方式使用，或出于其他原因，比如暗示生病或头晕。运动模糊很可能会得到持续的应用，应用它可以是一门艺术，也可以是一门科学。</strong></p>
<h1 id="13-Beyond-Polygons-剔除多边形"><a href="#13-Beyond-Polygons-剔除多边形" class="headerlink" title="13 Beyond Polygons 剔除多边形"></a>13 Beyond Polygons 剔除多边形</h1><p><strong>用三角形建模表面通常是解决场景中物体描绘问题的最直接的方法。然而，三角形只在一定程度上有用。用图像表示对象的一个很大的优点是，渲染成本与渲染的像素数成正比，而不是与几何模型中的顶点数成正比。因此，基于图像的渲染的一个用途是作为一种更有效的方式来渲染模型。然而，图像采样技术的用途要广泛得多。许多物体，如云和毛，都很难用三角形来表示。分层的半透明图像可以用来显示如此复杂的表面</strong></p>
<p><strong>本章首先对基于图像的绘制与传统的三角形绘制进行了比较和对比，并对算法进行了概述。然后我们将描述一些常用的技术，如精灵、广告牌、视点替用特效、粒子、点云和体素，以及更多实验方法。</strong></p>
<h2 id="The-Rendering-Spectrum-渲染谱"><a href="#The-Rendering-Spectrum-渲染谱" class="headerlink" title="The Rendering Spectrum 渲染谱"></a>The Rendering Spectrum 渲染谱</h2><p><strong>渲染的目标是在屏幕上描绘一个对象;如何实现这一目标是我们的选择。渲染场景没有单一正确的方法。每一种渲染方法都是真实的近似值，至少在以照片真实感为目标的情况下是这样。</strong></p>
<p><strong>三角形的优点是可以从任何角度以合理的方式表现物体。当摄像机移动时，物体的表现形式不必改变。然而，为了提高质量，我们可能希望替换一个更详细的模型，因为观众越来越接近的对象。相反地，如果距离很远，我们可能希望使用模型的简化形式。这些被称为水平细节技术(第19.9节)。它们的主要目的是使场景显示更快。</strong></p>
<p><strong>其他的渲染和建模技术可以发挥作用，当一个对象从观察者撤退。用图像代替三角形来表示物体可以获得速度。用可以快速发送到屏幕上的单一图像表示对象通常更便宜。一种表示绘制技术连续统一体的方法来自于Lengyel，如下图所示。首先，我们将从频谱的左边回到我们更熟悉的右边区域。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211019113526.png" class="" title="image-20211019113526">

<p>渲染谱。(在阿帕德)。</p>
<h2 id="Fixed-View-Effects-固定视口效果"><a href="#Fixed-View-Effects-固定视口效果" class="headerlink" title="Fixed-View Effects 固定视口效果"></a>Fixed-View Effects 固定视口效果</h2><p><strong>对于复杂的几何和阴影模型，以交互速率重新渲染整个场景可能是昂贵的。通过限制观看者的移动能力，可以实现各种形式的加速。最具限制性的情况是相机根本不移动。在这种情况下，很多渲染一次就可以完成。</strong></p>
<p><strong>例如，想象一个有栅栏的牧场作为场景的静态部分，有一匹马穿过它。牧场和围栏渲染一次，然后颜色和z缓冲区被存储起来。在每一帧中，这些缓冲用来初始化颜色和z缓冲。马本身是所有需要渲染的，以获得最终的图像。如果马在栅栏后面，存储和复制的z-depth值将使马变得模糊。注意，在这个场景下，马不会投射阴影，因为场景是不变的。可以进行进一步的阐述，例如，可以确定马的阴影的影响面积，然后只需要在存储的缓冲区上评估静态场景的这一小块区域。关键的一点是，在图像中设置每个像素的颜色的时间和方式没有限制。对于一个固定的视图，通过将一个复杂的几何模型转换成一组简单的缓冲区可以节省很多时间，这些缓冲区可以被许多帧重用。</strong></p>
<p><strong>在计算机辅助设计(CAD)应用程序中，所有建模对象都是静态的，当用户执行各种操作时，视图不会发生变化，这是很常见的道路。一旦用户移动到一个想要的视图，颜色和z缓冲区可以被存储以立即重用，用户界面和突出显示的元素然后绘制每帧。这允许用户快速注释、测量或与复杂的静态模型进行交互。通过在缓冲区中存储附加信息，可以执行其他操作。例如，三维绘制程序还可以通过存储给定视图的对象id、法线和纹理坐标，并将用户的交互转换为纹理本身的更改来实现。</strong></p>
<p><strong>与静态场景相关的概念是金线，也被称为适应性优化或渐进式优化。这个想法是，当观察者和场景是静态的，计算机可以随着时间的推移产生越来越好的图像。场景中的物体可以变得更逼真。这样高质量的渲染图可以突然交换，或者在一系列的帧中混合。这种技术在CAD和可视化应用中特别有用。可以进行许多不同类型的改进。随着时间的推移，可以在每个像素内的不同位置生成更多的样本，并在此过程中显示平均结果，从而提供抗锯齿。这同样适用于景深，其中样本在镜头和像素上随机分层。高质量的阴影技术可以用来创建更好的图像。我们也可以使用更复杂的技术，如光线或路径跟踪，然后在新图像中渐隐。</strong></p>
<p><strong>一些应用程序进一步采用了固定视图和静态几何的想法，以允许在电影质量的图像中进行交互编辑。这种方法被称为重照明，其原理是用户在场景中选择一个视图，然后使用它的数据进行脱机处理，而脱机处理又会产生一组缓冲区或更复杂的结构来表示场景。例如，Ragan-Kelley等人保持阴影样本与最终像素分离。这种方法允许他们执行运动模糊、透明效果和抗锯齿。他们还使用自适应细化来随着时间的推移提高图像质量。Pellacini等人扩展了基本的再照明，包括间接的全局照明。这些技术非常类似于在延迟着色方法中使用的技术(见第20.1节)。主要的区别是，在这里，这些技术被用来摊销昂贵的渲染在多帧上的成本，而延迟着色使用它们在一帧内加速渲染。</strong></p>
<h2 id="Skyboxes-天空盒"><a href="#Skyboxes-天空盒" class="headerlink" title="Skyboxes 天空盒"></a>Skyboxes 天空盒</h2><p><strong>环境地图(第10.4节)表示空间局部体积的入射辐亮度。虽然这种地图通常用于模拟反射，但它们也可以直接用于表示周围的环境。下图显示了一个示例。任何环境地图表示，如全景图或立方体地图，都可以用于此目的。它的网格被做得足够大，足以包含场景中的其他物体。这种网格被称为天空盒。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020104221.png" class="" title="image-20211020104221">

<p>Mission Dolores的全景图，从底部生成了三种视图。请注意，这些观点本身看起来是没有任何扭曲的。(图片由Ken Turkowski提供。)</p>
<p><strong>拿起这本书，越过左边或右边的边缘去看它后面的东西。用右眼看，然后是左眼。相比之下，这本书的优势发生了变化视差被称为视差。这种效应对附近的物体很重要，帮助我们在移动时感知相对深度。然而，对于一个或一组离观察者足够远、彼此足够近的物体，当观察者改变位置时几乎觉察不到任何视差效应。例如，如果你移动一米，甚至一千米，一座遥远的山本身通常看起来并没有明显的不同。当你移动时，它可能会被附近的物体挡住视线，但如果把这些物体拿走，山和它周围的环境看起来还是一样的。</strong></p>
<p><strong>天空盒的网格通常以观察者为中心，并与他们一起移动。天空盒网格不需要很大，因为通过保持相对位置，它看起来不会改变形状。对于一个如图13.2所示的场景，观众可能只移动了一小段距离，然后他们就会发现他们并没有相对于周围的建筑真正移动。对于更大规模的内容，如星形或远处的风景，用户通常不会移动得足够远和快，因为物体大小、形状或视差没有变化。</strong></p>
<p><strong>天空盒通常以立方体地图的形式呈现在盒子网格上，因为每个面上的纹理像素密度相对相等。为了让天空盒看起来更好，立方体贴图的纹理分辨率必须足够高。，每个屏幕像素一个像素。这个公式对于必要的解法是近似的</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020104451.png" class="" title="image-20211020104451">

<p><strong>fov是相机的视场。较低的视场值意味着立方体地图必须具有较高的分辨率，因为立方体表面的较小部分占用相同的屏幕大小。这个公式可以通过观察立方体地图的一个面的纹理必须覆盖一个视角(水平和垂直)为90度而得到。</strong></p>
<p><strong>除了盒子外，还有其他形状环绕着世界。例如，Gehling描述了一个系统，其中一个扁平的圆顶用来代表天空。这种几何形式被认为是模拟云层在头顶移动的最佳方法。云本身是通过组合和动画各种二维噪声纹理来表示的。</strong></p>
<p><strong>因为我们知道天空盒在所有其他物体的后面，所以我们可以做一些很小但很有价值的优化。天空盒从不需要写入z缓冲区，因为它从不阻塞任何东西。如果先绘制，天空盒也不必从z缓冲区读取，网格可以是任何尺寸，因为深度是无关紧要的。然而，在不透明对象之后，在透明对象之前绘制天空盒，这样做的好处是场景中的对象已经覆盖了几个像素，降低了渲染天空盒时所需的像素着色器调用的数量。</strong></p>
<h2 id="Light-Field-Rendering-光场渲染"><a href="#Light-Field-Rendering-光场渲染" class="headerlink" title="Light Field Rendering 光场渲染"></a>Light Field Rendering 光场渲染</h2><p><strong>亮度可以从不同的位置和方向，在不同的时间和变化的照明条件下捕捉。在现实世界中，计算摄影领域探索从这些数据中提取各种结果。对象的纯粹基于图像的表示可以用于显示。例如，Lumigraph和光场渲染技术试图从一组视点捕捉单个对象。给定一个新视图，这些技术在存储视图之间执行插值过程，以创建新视图。这是一个复杂的问题，存储所需的所有视图需要很高的数据要求。这个概念类似于全息术，二维的视图数组代表了物体。这种渲染形式的一个诱人的方面是能够捕获一个真实的物体，并能够从任何角度重新显示它。任何物体，无论表面和光线的复杂程度，都可以以几乎恒定的速度显示出来。关于这个主题的更多信息，请参阅Szeliski的书。近年来，人们对光场渲染重新产生了研究兴趣，因为它可以让眼睛使用虚拟现实显示器来适当调整焦点。这些技术目前在交互渲染中使用有限，但它们界定了计算机图形学领域的可能。</strong></p>
<h2 id="Sprites-and-Layers-精灵和图层"><a href="#Sprites-and-Layers-精灵和图层" class="headerlink" title="Sprites and Layers 精灵和图层"></a>Sprites and Layers 精灵和图层</h2><p><strong>精灵是最简单的基于图像的渲染原语之一。精灵是在屏幕上移动的图像，例如鼠标光标。精灵不需要有矩形形状，因为有些像素可以渲染成透明的。对于简单的精灵，存储的每个像素将被复制到屏幕上的一个像素。动画可以通过呈现一系列不同的精灵而生成。</strong></p>
<p><strong>更一般的精灵类型是将图像纹理渲染到总是面向观众的多边形上。这允许精灵调整大小和变形。图像的alpha通道可以为精灵的各种像素提供完全或部分透明度，因此也可以在边缘上提供抗锯齿效果(章节5.5)。这种类型的精灵可以有深度，也就是场景本身的位置。</strong></p>
<p><strong>我们可以把场景看作是一系列的图层，这在二维的cel动画中是很常见的。例如，在下图中，后挡板在鸡的前面，鸡在卡车驾驶室的前面，而卡车驾驶室又在道路和树木的前面。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020105224.png" class="" title="image-20211020105224">

<p>来自动画小鸡交叉，使用护身符模拟器渲染。在这个场景中，我们使用了80层精灵，其中一些被勾勒出来并显示在左边。由于鸡翅部分位于后挡板的前面和后面，两者被放置在一个精灵。(经微软公司许可转载)</p>
<p><strong>这种分层适用于大量的观点集。每个精灵层都有相应的深度。通过按照画家算法的前后顺序渲染，我们可以在不需要z缓冲区的情况下构建场景。相机缩放只是让对象变大，这很容易用相同的精灵或相关的mipmap来处理。移动相机实际上改变了前景和背景的相对覆盖，这可以通过改变每个精灵层的覆盖和位置来处理。当查看器横向或垂直移动时，层可以相对于它们的深度移动。</strong></p>
<p><strong>一组精灵可以代表一个对象，一个独立的精灵代表不同的视图。如果对象在屏幕上足够小，那么存储大量视图(即使是动画对象)也是可行的策略。视角的微小变化也可以通过扭曲精灵的形状来处理，尽管最终这种近似会被打破，需要生成一个新的精灵。具有不同表面的物体在小的旋转后会发生显著的变化，因为新的多边形变得可见，而其他的则被遮挡。</strong></p>
<p><strong>这一层和图像扭曲过程是90年代末微软支持的Talisman硬件架构的基础。虽然这个特定的系统由于许多原因而逐渐消失，但通过一个或多个基于图像的表示来表示模型的想法已经被发现是卓有成效的。使用不同容量的图像可以很好地映射到GPU的强度，基于图像的技术可以与基于三角形的渲染相结合。以下部分将讨论视点替用特效、深度精灵和其他使用图像代替多边形内容的方法。</strong></p>
<h2 id="Billboarding-公告牌"><a href="#Billboarding-公告牌" class="headerlink" title="Billboarding 公告牌"></a>Billboarding 公告牌</h2><p><strong>基于视图方向对一个有纹理的矩形进行定位称为公告牌，该矩形称为广告牌。当视图改变时，矩形的方向也随之改变。广告牌，结合alpha纹理和动画，可以代表许多现象，没有光滑的固体表面。草、烟、火、雾、爆炸、能量盾、蒸汽轨迹和云只是这些技术可以代表的对象中的一部分。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020105407.png" class="" title="image-20211020105407">

<p>代表雪、表面和人物的小广告牌。(来自three.js示例程序。)</p>
<p><strong>本节将介绍几种流行的广告牌形式。在每个，表面法线和向上的方向被发现为矩形的定向。这两个向量足以构成曲面的一组标准正交基。换句话说，这两个向量描述了将四边形旋转到最终方向所需的旋转矩阵(章节4.2.4)。在四边形上的锚点位置(例如，它的中心)然后用来确定它在空间中的位置。</strong></p>
<p><strong>通常，所要求的表面法向量n和上向量u不是垂直的。在所有的公告牌技术中，这两个向量中的一个被确定为必须在给定方向上保持的固定向量。使另一个向量垂直于这个固定向量的过程总是一样的。首先，创建一个“右”向量r，指向四边形右边的向量。这是通过求u和n的叉乘来完成的。将这个向量r标准化，因为它将被用作旋转矩阵的标准正交基的轴。如果向量r长度为零，则u和n必须是并行的，可以使用第4.2.4节中描述的技术。如果r的长度不是完全为零，而是接近于零，那么u和n几乎是平行的，就会出现精度误差。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020105700.png" class="" title="image-20211020105700">

<p>对于一个法向n和近似向上的向量方向u的广告牌，我们想要创建一个由三个相互垂直的向量组成的集合来定位广告牌。在中间的图中，右边的向量r是通过求u和n的叉乘得到的，所以它垂直于这两个向量。在右图中，固定向量n与r相交，得到相互垂直的向量u′。</p>
<p><strong>从(非并行)n和u向量计算r和新的第三个向量的过程如上图所示。如果正常的n保持不变，就像大多数公告牌技术一样，那么新的向上向量u′ 是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020105803.png" class="" title="image-20211020105803">

<p><strong>相反，如果向上的方向是固定的(对于轴向对齐的广告牌，如景观上的树)，那么新的法向量n ‘是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020105812.png" class="" title="image-20211020105812">

<p><strong>然后对新向量进行归一化，并用这三个向量形成一个旋转矩阵。例如，对于固定的法向量n和调整后的向量u ‘矩阵是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020105821.png" class="" title="image-20211020105821">

<p><strong>这个矩阵变换了一个四边形在xy平面与+y指向它的顶部边缘，并围绕其锚定位置为中心，以适当的方向。然后应用一个平移矩阵将四边形的锚点移动到所需的位置。</strong></p>
<p><strong>有了这些初步准备，剩下的主要任务是决定什么表面法线和向上的矢量用来定义广告牌的方向。下面几节将讨论几种构造这些向量的不同方法。</strong></p>
<h3 id="Screen-Aligned-Billboard-屏幕对齐公告牌"><a href="#Screen-Aligned-Billboard-屏幕对齐公告牌" class="headerlink" title="Screen-Aligned Billboard 屏幕对齐公告牌"></a>Screen-Aligned Billboard 屏幕对齐公告牌</h3><p><strong>最简单的广告牌形式是屏幕对齐的广告牌。这种形式与二维精灵相同，即图像始终与屏幕平行，并具有常量向上向量。摄像机将场景渲染到与近平面和远平面平行的视场平面上。我们经常在近平面的位置上想象这个假想平面。对于这种类型的广告牌，所需的表面法线是视平面法线的负，其中视平面法线vn 点远离视图位置。向上的向量u来自相机本身。它是视图平面上定义摄像机向上方向的向量。这两个向量已经是垂直的了，所以所需要的就是“右”方向向量r来形成广告牌的旋转矩阵。因为n和u对于摄像机来说是常数，所以这个旋转矩阵对于所有这种类型的广告牌都是相同的。</strong></p>
<p><strong>除了粒子效果，屏幕对齐的广告牌对于注释文本和地图placemark等信息也很有用，因为文本总是与屏幕本身对齐，因此得名“广告牌”。“请注意，在文本注释中，对象在屏幕上的大小通常是固定的。这意味着，如果用户放大或推离广告牌的位置，广告牌将增加世界空间的大小。因此，对象的大小依赖于视图，这可能会使锥角剔除等方案复杂化。</strong></p>
<h3 id="World-Oriented-Billboard-外向型公告牌"><a href="#World-Oriented-Billboard-外向型公告牌" class="headerlink" title="World-Oriented Billboard 外向型公告牌"></a>World-Oriented Billboard 外向型公告牌</h3><p><strong>我们希望广告牌能够显示玩家身份或位置名称。然而，如果摄像机倾斜，例如在飞行模拟中进入一个曲线，我们希望广告牌云倾斜响应。如果一个精灵代表一个物理对象，它通常是基于世界的向上方向，而不是摄像机的方向。圆形精灵不受倾斜的影响，但其他广告牌形状会受到影响。我们可能希望这些广告牌保持面向观众，但也要沿着它们的视图轴旋转，以保持面向世界。</strong></p>
<p><strong>对于这样的精灵，渲染它们的一种方法是使用这个世界上的向量来推导旋转矩阵。在这种情况下，法线仍然是视图平面法线的否定，这是固定的向量，一个新的垂直向上的向量是从世界上的上向量推导出来的，如前所述。与屏幕对齐的广告牌一样，这个矩阵可以在所有精灵中重复使用，因为这些向量不会在渲染场景中发生改变。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020110319.png" class="" title="image-20211020110319">

<p>有四个球体的视野，视野开阔。左上方是一个球体的广告牌纹理，使用视图平面对齐。右上角的广告牌是面向视点的。下面一行显示了两个真实的球体。</p>
<p><strong>在所有精灵中使用相同的旋转矩阵是有风险的。由于透视投影的性质，离视轴有一定距离的物体是弯曲的。见上图中底部的两个球体。由于在平面上的投影，球体变成椭圆形。这种现象不是错误，如果观众的眼睛与屏幕的距离和位置合适，它看起来很好。也就是说，如果虚拟相机的几何视场与人眼的显示视场匹配，那么这些球体看起来是不弯曲的。观察者不会注意到视野中高达10%-20%的轻微不匹配。然而，通常的做法是给虚拟相机一个更广阔的视野，以呈现更多的世界给用户。此外，匹配的视场将是有效的，只有当观众是在一个给定的距离前显示的中心。几个世纪以来，艺术家们已经意识到了这个问题，并做出了必要的补偿。被认为是圆的物体，如月亮，被画成圆形，而不管它们在画布上的位置。</strong></p>
<p><strong>当视场或精灵很小时，这种扭曲效果可以忽略，并使用一个与视图平面对齐的单一方向。否则，所需的法线需要等于从广告牌的中心到观众的位置的矢量。这就是我们所说的面向视点的广告牌。参见下图。使用不同对齐方式的效果如上图所示。可以看出，视图平面对准具有使广告牌不失真的效果，无论它在屏幕上的哪个位置。视点方向扭曲球体图像的方式与真实球体通过将场景投影到平面上而扭曲的方式相同。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020110440.png" class="" title="image-20211020110440">

<p>一个俯视图的两个广告牌对齐技术。这五块广告牌的正面不同，取决于使用的方法。</p>
<p><strong>外向型的广告牌对于呈现许多不同的现象是有用的。Guymon和Nguyen都讨论了制造令人信服的火焰、烟雾和爆炸。一种技术是以随机和混乱的方式聚集和重叠动画精灵。这样做有助于隐藏动画序列的循环模式，同时也避免让每次火灾或爆炸看起来都一样。</strong></p>
<p><strong>镂空纹理中的透明像素对最终图像没有影响，但必须由GPU处理，并在栅格化管道的后期丢弃，因为alpha是零。一组动画裁剪纹理通常会有特别大的透明像素边缘区域的框架。我们通常会考虑将纹理应用到矩形基元上。Persson注意到带有调整过的纹理坐标的更紧密的多边形能够更快速地渲染精灵，因为处理的像素更少。参见下图。他发现，一个只有四个顶点的新多边形可以提供实质性的性能改进，而使用超过8个顶点的新多边形将达到一个收益递减点。“粒子切割”工具是Unreal Engine 4的一部分，例如。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020110618.png" class="" title="image-20211020110618">

<p>云精灵包含一个大的透明条纹。使用绿色的凸包，红色的紧凑的四角和八角多边形可以包含更少的透明像素。与最左边的方形粒子相比，这样做可以使整体面积分别减少40%和48%。(图片由Emil Persson提供。)</p>
<p><strong>广告牌的一个常见用途是云渲染。Dobashi等人模拟云，并用广告牌渲染它们，并通过渲染同心半透明外壳来创建光轴。哈里斯和拉斯特拉也使用视点替用来模拟云。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020110810.png" class="" title="image-20211020110810">

<p>由一组面向世界的视点替用特效创建的云。(图片由北卡罗来纳大学教堂山分校的马克·哈里斯提供。)</p>
<p><strong>Wang详细介绍了在Mi- crosoft的飞行模拟器产品中使用的云建模和渲染技术。每块云是由5到400个广告牌组成的。只需要16种不同的基础精灵纹理，因为它们可以使用非均匀缩放和旋转来修改，以形成各种各样的云类型。根据离云中心的距离修改透明度，用于模拟云的形成和消散。为了节省处理时间，远处的云都被渲染到场景周围的一组8个全景纹理中，类似于天空盒。</strong></p>
<p><strong>平面广告牌并不是唯一可能的云渲染技术。例如，Elinas和Stuerzlinger通过渲染嵌套椭球集合来生成云，这些椭球集合在观测轮廓周围变得更加透明。Bahnassi和Bahnassi渲染椭球体，他们称之为“超级粒子”，然后使用模糊和屏幕空间的湍流纹理，以提供令人信服的云状外观。Pallister讨论了程序生成云图，并通过头顶的天空网格将其动画化。Wenzel用一系列的飞机在观察者上方观察远处的云。我们在这里专注于渲染和混合广告牌和其他原语。云广告牌的着色方面在第14.4.2节讨论，真实体积方法在第14.4.2节讨论。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020111030.png" class="" title="image-20211020111030">

<p>在左边，圈出的区域是由于灰尘云牌与物体相交而形成的边缘和带状。在右边，广告牌在靠近物体的地方淡出，避免了这个问题。在底部，较低的圆圈区域被放大以进行比较。(图片来自NVIDIA SDK 10样本“软粒子”，由NVIDIA公司提供。)</p>
<p><strong>如第5.5和6.6节所述，为了正确地执行合成，重叠的半透明广告牌应该按顺序呈现。当烟雾广告牌与固体物体相交时，会产生伪影。参见上图。这种错觉被打破了，因为应该是一个卷的东西被看作是一组层。一个解决方案是让像素着色程序在处理每个广告牌时检查底层对象的z深度。广告牌测试这一深度，但不取代它自己的，即不写z-depth。如果底层对象在像素处接近广告牌的深度，那么广告牌片段就会变得更加透明。这样，广告牌就更像一个体积，层工件就消失了。当达到最大衰落距离时，随深度线性衰落会导致不连续。s曲线衰减函数避免了这个问题。Persson指出，观察者与粒子的距离将改变如何最好地设置淡出范围。Lorach提供了更多的信息和实现细节。以这种方式改变其透明度的广告牌被称为软粒子。</strong></p>
<p><strong>使用软粒子的淡出解决了广告牌与实体物体相交的问题，如上图所示。其他藏物可能在爆炸时发生通过场景或观众在云中移动。在前一种情况下，广告牌可以在动画期间从一个物体的后面移动到前面。如果广告牌从完全不可见移动到完全可见，就会引起明显的弹出。类似地，当观众通过广告牌时，广告牌可以完全消失，因为它移动到近平面的前面，导致所看到的突然变化。一个快速的解决方法是让广告牌在靠近时变得更加透明，然后淡出以避免“流行”。</strong></p>
<p><strong>更现实的解决方案是可能的。Umenhoffer等人引入了球形广告牌的概念。广告牌对象被认为是在空间中定义一个球形体积。广告牌本身被渲染为忽略z深度读取;广告牌的目的纯粹是为了让像素着色程序在球体可能所在的位置执行。像素着色程序在这个球形体积上计算入口和出口位置，并使用实体对象根据需要改变出口深度和近剪辑平面来改变入口深度。通过这种方式，每个广告牌的球体可以适当地淡出，通过增加基于从相机的光线在剪切球体内旅行的距离的透明度。</strong></p>
<p><strong>在《孤岛危机》中使用了一种稍微不同的技术，使用盒形体积而不是球体来减少像素着色器成本。另一个优化是让广告牌代表音量的前面，而不是后面。这允许使用z-buffer测试跳过实体对象后面的卷部分。这种优化是可行的，只有当音量是已知的，完全在观众面前，所以广告牌不剪辑近视图平面。</strong></p>
<h3 id="Axial-Billboard-轴向广告牌"><a href="#Axial-Billboard-轴向广告牌" class="headerlink" title="Axial Billboard 轴向广告牌"></a>Axial Billboard 轴向广告牌</h3><p><strong>最后一种常见类型叫做轴向广告牌。在这种方案中，纹理对象通常不直接面对查看器。相反，它被允许围绕某个固定的世界空间轴旋转，并在这个范围内尽可能地面向观众。这种广告牌技术可以用于显示远处的树木。不是用一个实心的表面来表示一棵树，甚至是6.6节中描述的一对树的轮廓，而是使用一个单独的树广告牌。世界向上的向量是沿着树的树干的一个轴。随着查看器的移动，树面向查看器，如下图所示。此图像是一个面向摄像头的广告牌，与第203页图6.28所示的“十字树”不同。对于这种形式的广告牌，世界向上的矢量是固定的，视点方向是第二个可调节的矢量。一旦这个旋转矩阵形成，树就被平移到它的位置。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020111501.png" class="" title="image-20211020111501">

<p>当观众在场景周围移动时，灌木丛广告牌旋转面向前方。在这个例子中，灌木从南方被照亮，这样变化的视图使整体的着色随着旋转而变化。</p>
<p><strong>这种形式与面向世界的广告牌的不同之处在于什么是固定的，什么是允许旋转的。面向世界，广告牌直接面对观众，并可以沿着这个视图轴旋转。它被旋转，使广告牌的向上方向尽可能与世界的向上方向对齐。对于轴向广告牌，世界的向上方向定义了固定轴，广告牌围绕它旋转，使它尽可能面向观众。例如，如果观众是近在每一种类型的广告牌上方，面向世界的版本将完全面向它，而轴向的版本将更贴合场景。</strong></p>
<p><strong>由于这种行为，轴向广告牌的一个问题是，如果观察者从树的上方飞过并向下看，这种错觉就会被破坏，因为树几乎是在边缘上出现的，看起来就像它们原来的样子。一个解决方案是添加树的水平横截面纹理(不需要广告牌)来帮助改善问题。</strong></p>
<p><strong>另一种技术是使用细节级别技术将基于图像的模型转换为基于网格的模型。将树模型从三角形网格转换成一组广告牌的自动化方法将在第13.6.5节中讨论。Kharlamov等人提出了相关的树绘制技术，Klint解释了大量植被的数据管理和表示。第857页的图19.31显示了在商用SpeedTree包中用于渲染远处树的轴向广告牌技术。</strong></p>
<p><strong>就像屏幕对齐的广告牌适合表示对称的球形物体一样，轴向广告牌也适合表示圆柱形对称的物体。例如，激光光束效果可以用轴向广告牌渲染，因为它们的外观从轴的任何角度看起来都是一样的。如下图所示。第913页的图20.15显示了更多示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020111641.png" class="" title="image-20211020111641">

<p>广告牌的例子。平视显示器(HUD)图形和星形投射物是屏幕对齐的广告牌。右图中巨大的泪滴爆炸是一个面向视角的广告牌。曲线梁是由一组四边形连接而成的轴向广告牌。为了创造一个连续的梁，这些四边形在它们的角连接，因此不再是完全的矩形。(图片由Maxim Garber、Mark Harris、Vincent Scheib、Stephan Sherman和Andrew Zaferakis提供，来自《BHX: Beamrunner Hypercross》)</p>
<p><strong>这些类型的技术说明了这些算法的一个重要想法，即像素着色器的目的是评估真实的几何形状，丢弃在表示对象边界之外发现的碎片。对于广告牌来说，当图像纹理完全透明时，就会发现这样的碎片。正如将看到的，更复杂的像素着色器可以评估，以找到模型存在的地方。这些方法中的几何学功能是对像素着色器进行评估，并给出一些z深度的粗略估计，这可以通过像素着色器进行优化。我们想要避免在模型外计算像素上浪费时间，但我们也不想使几何形状如此复杂，顶点处理和不必要每个三角形外部的像素着色器调用(由于沿其边缘生成2 × 2个四边形;见18.2.3节)成为重大成本。</strong></p>
<h3 id="Impostors-视点替用"><a href="#Impostors-视点替用" class="headerlink" title="Impostors 视点替用"></a>Impostors 视点替用</h3><p><strong>视点替用特效是一个广告牌，它是通过将一个复杂的物体从当前的视点渲染成一个图像纹理来创建的，这个纹理被映射到广告牌上。视点替用特效可以用于对象的几个实例或几帧，从而摊销生成它的成本。本节将介绍更新视点替用特效的不同策略。Maciel和Shirley早在1995年就识别出了几种不同类型的视点替用，包括本节介绍的视点替用。从那时起，视点替用的定义就缩小到了我们在这里使用的。</strong></p>
<p><strong>视点替用特效图像在对象存在的地方是不透明的;其他地方都是完全透明的。它可以用几种方法来代替几何网格。例如，视点替用图像可以表示由小静态对象组成的杂波。视点替用特效对于快速渲染远处的物体很有用，因为一个复杂的模型被简化为一个单一的图像。另一种方法是使用最小级别的详细模型(第19.9节)。然而，这种简化的模型往往会丢失形状和颜色信息。视点替用特效没有这个缺点，因为生成的图像可以近似匹配显示器的分辨率。另一种使用视点替用特效的情况是，靠近观看者的物体在移动时暴露同一侧给观看者。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020112052.png" class="" title="image-20211020112052">

<p>在左侧，视点截锥从侧面观察的对象创建一个视点替用特效。视图的方向是指向对象的中心c，图像被渲染并用作视点替用特效纹理。如图所示，纹理应用于一个四边形。视点替用特效的中心等于对象的中心，而法线(从中心发出)直接指向视点。</p>
<p><strong>在渲染对象以创建视点替用特效图像之前，查看器被设置为查看对象边界框的中心，选择视点替用特效矩形以便它直接指向视点(上图中的左侧)。尺寸视点替用特效的四边形是包含物体投影边框的最小矩形。Alpha值被清除为零，在渲染对象的任何地方，Alpha值都被设置为1.0。然后，图像被用作面向视图的广告牌。如上图的右侧所示。当相机或视点替用特效对象移动时，纹理的分辨率可能会被放大，这可能会打破错觉。Schaufler和St¨urzlinger提出了决定视点替用图像何时需要更新的启发式方法。</strong></p>
<p><strong>Forsyth给出了许多在游戏中使用视点替用的实用技巧。例如，更频繁地更新靠近查看者或鼠标光标的对象可以提高感知质量。当视点替用特效被用于动态对象时，他描述了一种预处理技术，它决定了最大距离d，即在整个动画期间的任何顶点移动。这个距离除以动画中的时间步长数，因此∆= d/帧。如果一个视点替用特效被用于n帧而没有更新，则∆∗n被投影到图像平面上。如果此距离大于用户设置的阈值，则更新视点替用特效。</strong></p>
<p><strong>将纹理映射到面向观众的矩形上并不总是能产生令人信服的效果。问题是视点替用特效本身没有厚度，所以当与真实几何体结合时就会出现问题。参见图13.16中的右上方图像。Forsyth建议将纹理沿着视图方向投射到物体的边界框上。这至少给视点替用特效增加了一点几何效果。</strong></p>
<p><strong>通常最好是在物体移动时渲染几何体，当物体是静态时切换为视点替用特效。Kavan等人引入了polypostors，其中一个人的模型由一组视点替用代表，每个肢体一个和主干。这个系统试图在纯视点替用特效和纯几何之间取得平衡。Beacco等人描述了用于人群渲染的polypostors和其他大量与视点替用器相关的技术，并对每种技术的优缺点进行了详细的比较。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020112408.png" class="" title="image-20211020112408">

<p>一种视点替用特效技术，其中每个单独的动画元素都由一组图像来表示。这些是在一系列的掩蔽和合成操作中呈现的，这些操作结合起来为给定的视图形成一个令人信服的模型。(图片由Alejandro Beacco提供，版权c 2016 John Wiley &amp; Sons, Ltd.。)</p>
<h3 id="Billboard-Representation-广告牌表示"><a href="#Billboard-Representation-广告牌表示" class="headerlink" title="Billboard Representation 广告牌表示"></a>Billboard Representation 广告牌表示</h3><p><strong>视点替用特效的一个问题是，渲染后的图像必须继续面对观看者。如果远处的对象正在改变其方向，则必须重新计算视点替用特效。D´ecoret等人为了更像它们所代表的三角形网格，对远处的物体建模，提出了广告牌云的概念。一个复杂的模型通常可以由一小群重叠的镂空广告牌来表示。附加信息，如法线或位移贴图和不同的材料，可以应用到他们的表面，使这些模型更有说服力。</strong></p>
<p><strong>这种寻找一组平面的想法比剪纸的比喻所暗示的更普遍。广告牌可以相交，切口可以任意复杂。例如，一些研究人员将广告牌与树模型相匹配。从模型有成千上万的三角形，他们可以创建令人信服的广告牌云组成的不到100个纹理四边形。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211020112624.png" class="" title="image-20211020112624">

<p>左边是由20,610个三角形组成的树模型。在树的中间，有78块广告牌。重叠的广告牌显示在右边。(图片由犹他州大学Dylan Lacewell提供。)</p>
<p><strong>使用广告牌云可以导致相当多的透支，这可能是昂贵的。质量也会受到影响，因为交叉的切割可能意味着严格的前后绘制顺序无法实现。Alpha到覆盖(章节6.6)可以帮助渲染复杂的Alpha纹理集。为了避免透支，SpeedTree等专业软件包使用带有alpha纹理的树叶和树枝集合的大网格来表示和简化模型。虽然几何图形处理需要更多的时间，但这远远超过了较低的透支成本。第857页的图19.31显示了一些示例。另一种方法是使用体积纹理来表示这些对象，并将其作为一系列垂直于人眼视图方向的层进行渲染，如第14.3节所述。</strong></p>
<h2 id="Displacement-Techniques-置换技术"><a href="#Displacement-Techniques-置换技术" class="headerlink" title="Displacement Techniques 置换技术"></a>Displacement Techniques 置换技术</h2><p><strong>如果视点替用特效的纹理是用深度组件增强的，这就定义了一个称为深度精灵(depth sprite)或钉板(nailboard)的渲染原语。因此，纹理图像是一个RGB图像，每个像素增加一个∆参数，形成一个RGB∆纹理。∆存储从深度精灵矩形到深度精灵所代表的正确几何深度的偏差。这个∆通道是视野空间中的一个高场。因为深度精灵包含深度信息，所以它们优于视点替用特效，因为它们可以更好地与周围的对象合并。当深度精灵矩形穿透附近的几何图形时，这一点尤其明显。这种情况如下图所示。像素着色器能够通过改变每个像素的z深度来执行这个算法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021131307.png" class="" title="image-20211021131307">

<p>左上方的图像显示了一个简单的几何渲染场景。右上方的图像显示了当为立方体、圆柱体和圆锥体创建并使用视点替用特效时会发生什么。下图显示了使用深度精灵时的结果。左边图像中的深度精灵使用2位的深度偏差，而右边图像中的深度精灵使用8位的深度偏差。(图片由Gernot Schaufler提供)</p>
<p><strong>Shade等人也描述了一个深度精灵原语，他们使用扭曲来解释新的视点。他们引入了一种叫做分层深度图像的原语，每个像素有几个深度。多重深度的原因是为了避免由于解除遮挡而产生的间隙。在翘曲过程中，隐藏区域变得可见)。Schaufler和Meyer and Neyret也提出了相关技术。为了控制采样率，Chang等人提出了一种称为LDI树的层次表示。</strong></p>
<p><strong>与深度精灵相关的是Oliveira等人引入的浮雕纹理映射。浮雕纹理是一幅具有高度场的图像，它代表了表面的真实位置。与深度精灵不同，图像不是呈现在广告牌上，而是面向世界空间中的一个四边形。对象可以通过一组匹配接缝的浮雕纹理来定义。使用GPU，高度场可以映射到表面上，射线行进可以用来渲染它们，如第6.8.1节所述。浮雕纹理映射也类似于一种称为栅格化包围体层次的技术。</strong></p>
<p><strong>Policarpo和Oliveira在一个单独的四边形上使用一组纹理来保持高度场，并且每个纹理都是依次渲染的。简单类推，在注塑机中形成的任何物体都可以通过两个高度场来形成。每个高度场代表模具的一半。更精细的模型可以通过附加的高度场重建。给定一个模型的特定视图，所需的高度场数量等于任何像素重叠的最大表面数量。像球形广告牌一样，每个底层四边形的主要目的是通过像素着色器来评估高度场纹理。这种方法也可以用来创建复杂的几何细节的表面;参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021131505.png" class="" title="image-20211021131505">

<p>编织表面模型通过应用四个高度场纹理的表面，并使用浮雕映射渲染。(图片由Fabio Policarpo和Manuel M. Oliveira提供)</p>
<p><strong>Beacco等人在人群场景中使用浮雕视点替用。在这种表示中，生成了模型的颜色、法线和高度场纹理，并与盒子的每个面相关联。当一个人脸被渲染时，光线前进被执行以找到每个像素可见的表面，如果有的话。一个盒子与模型的每个刚性部分(“骨骼”)相关联，这样就可以执行动画了。在假设角色离得很远的情况下，剥皮不会完成。纹理提供了一种简单的方法来降低原始模型的细节级别。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021131628.png" class="" title="image-20211021131628">

<p>Relief impostor。角色的表面模型被划分为多个框，然后用于为每个框的面创建高度场、颜色和普通纹理。模型使用地形映射进行渲染。(图片由Alejandro Beacco提供，版权c 2016 John Wiley &amp; Sons, Ltd.。)</p>
<p><strong>Gu等介绍了几何图像。这个想法是将一个不规则的网格转换成一个保持位置值的方形图像。图像本身代表一个常规的网格,即形成的三角形是从网格位置隐式的。也就是说，图像中的四个相邻像素构成两个三角形。形成这一形象的过程是困难的，而且相当复杂;这里我们感兴趣的是编码模型的结果图像。图像可以用来生成网格。其主要特点是几何图像可以被映射。不同层次的mipmap金字塔形成了模型的简单版本。这种模糊的线之间的顶点和texel数据，网格和图像，是一个迷人和诱人的方式来思考建模。几何图像也被用于具有特征保留地图的地形，以建立悬架模型。</strong></p>
<p><strong>在本章的这一点上，我们留下了用图像表示整个多边形对象，因为讨论转移到在粒子系统和点云中使用断开的、单独的样本。</strong></p>
<h2 id="Particle-Systems-粒子系统"><a href="#Particle-Systems-粒子系统" class="headerlink" title="Particle Systems 粒子系统"></a>Particle Systems 粒子系统</h2><p><strong>粒子系统是使用某种算法设置运动的独立小物体的集合。应用包括模拟火、烟、爆炸、水流、旋转星系和其他现象。因此，粒子系统控制动画和渲染。用于在粒子生存期内创建、移动、更改和删除粒子的控件是系统的一部分。</strong></p>
<p><strong>与本章相关的是这些粒子建模和渲染的方式。每个粒子可以是单个像素或从粒子先前位置到当前位置的线段，但通常由广告牌表示。如13.6.2节所述，如果粒子是圆的，那么向上矢量与它的显示无关。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021131951.png" class="" title="image-20211021131951">

<p>粒子系统:一个烟雾模拟(左)，流体(中)，和流星路径对抗星系天空盒(右)。(WebGL节目包括关颖珊的《精神》、李大卫的《流体粒子》和伊恩·韦伯斯特的《南三角洲宝瓶座流星雨》。)</p>
<p><strong>换句话说，所需要的只是粒子的位置来确定它的方向。上图给出了一些粒子系统的例子。每个粒子的广告牌可以通过调用几何着色器生成，但在实践中使用顶点着色器生成精灵可能更快。除了表示粒子的图像纹理外，还可以包含其他纹理，如法线贴图。轴向广告牌可以显示较粗的线条。参见609页的图14.18，以获得使用线段的雨的示例。</strong></p>
<p><strong>如果用半透明的广告牌颗粒来表示烟雾等现象，那么就必须解决正确渲染透明物体的挑战。前后排序可能是需要的，但可能很昂贵。Ericson提供了一长组有效渲染粒子的建议;我们在这里列出了一些，以及相关文章:</strong></p>
<pre><code>**•从厚的切割纹理制作烟雾;避免半透明意味着不需要分类和混合。** 

**•如果需要半透明，考虑添加或减法混合，不需要分类。**

**•使用一些动画粒子可以提供类似的质量和更好的性能比许多静态粒子。**

**•为了保持帧率，对渲染的粒子数量使用一个动态上限值。**

**•让不同的粒子系统使用相同的着色器，以避免状态更改成本(章节18.4.2)。**

**•包含所有粒子图像的纹理图集或数组可以避免调用纹理更改。**

**•平滑地绘制变化的粒子，如烟雾到一个低分辨率的缓冲区并合并，或在MSAA解析后绘制。** 
</code></pre>
<p><strong>Tatarchuk等人进一步提出了最后一种观点。他们将烟雾渲染到一个相当小的缓冲区，大小为十六分之一，并使用一个方差深度图来帮助计算粒子效果的累积分布函数。详情请参阅他们的演讲。</strong></p>
<p><strong>如果有大量的粒子，一个完整的排序可能会很昂贵。美术指导可以指示渲染顺序，以正确地分层不同的效果，从而改善问题。对于小的或低对比度的粒子，可能没有必要进行分类。粒子有时也可以以某种排序的顺序释放出来。如果粒子相当透明，则可以使用不需要排序的加权混合透明度技术。更复杂的独立于订单的透明系统也是可能的。例如，K¨ohler将渲染粒子描绘成一个九层深的缓冲区，存储在一个纹理数组中，然后使用一个计算着色器来执行排序。</strong></p>
<h3 id="Shading-Particles-粒子着色"><a href="#Shading-Particles-粒子着色" class="headerlink" title="Shading Particles 粒子着色"></a>Shading Particles 粒子着色</h3><p><strong>对于着色，它取决于粒子。像sparks这样的发射器不需要着色，为了简单起见经常使用添加剂混合。Green描述了如何将流体系统作为球形粒子渲染到深度图像中，随后的步骤是模糊深度，从中提取法线，并将结果与场景合并。像灰尘或烟雾这样的小颗粒可以使用每个基本值或每个顶点值来着色。然而，这样的光照可以使具有不同表面的粒子看起来平坦。为粒子提供一个法线贴图可以给适当的表面法线来照亮它们，但代价是额外的纹理访问。对于圆形粒子，在粒子的四个角上使用四条发散法线可能就足够了。烟雾粒子系统可以有更精细的光散射模型。辐射法向映射(第11.5.2节)或球谐也被用于照亮粒子。镶嵌可以用在更大的粒子上，使用域着色器在每个顶点上累积光照。</strong></p>
<p><strong>可以对每个顶点的光照进行评估，并在粒子四边形上进行插值。这是快速的，但对大粒子产生低质量，在那里的顶点远离可能错过小光的贡献。一种解决方案是在每像素的基础上对一个粒子进行着色处理，但分辨率要低于最终图像的分辨率。为此，每个可见粒子在光贴图纹理中分配一个贴图。每个贴图的分辨率可以根据屏幕上的颗粒大小进行调整，例如根据屏幕上的投影面积在1 × 1到32 × 32之间。一旦贴图被分配，粒子将为每个贴图渲染，并将像素的世界位置写入次级纹理中。然后分配一个计算着色器来评估到达从次级纹理读取的每个位置的亮度。如第20章所述，亮度是通过对场景中的光源取样来收集的，使用一个加速结构来评估可能产生影响的光源。由此产生的亮度可以以一种简单的颜色或球谐的形式写入到光贴图纹理中。当每个粒子最终呈现在屏幕上时，光照是通过在粒子四边形上映射每个贴图和使用纹理获取采样每个像素的亮度来应用的。</strong></p>
<p><strong>通过为每个发射器分配贴图，也可以应用相同的原则。在这种情况下，有一个深的光贴图纹理将有助于给照明与许多粒子的效果体积。值得注意的是，由于粒子的平面性质通常与观察者对齐，如果观察点旋转任何粒子发射器，在本节中呈现的每个照明模型都会产生可见的闪烁伪影。</strong></p>
<p><strong>与光照平行，粒子的体积阴影和自阴影的生成需要特别注意。为了接收来自其他遮挡器的阴影，小颗粒通常可以在阴影地图上测试它们的顶点，而不是每个像素。因为粒子是分散的点，被渲染成简单的面向相机的四边形，阴影投射到其他物体上不能使用光线通过阴影贴图来实现。但是，可以使用飞溅方法(第13.9节)。为了将来自太阳的阴影投射到其他场景元素上，粒子可以被分割成纹理，乘以每像素的透射率Tr = 1−α在缓冲区首先清除到1。纹理可以由一个用于灰度的通道或三个用于彩色透射的通道组成。这些纹理，在阴影级联层之后，通过将透射率与常规不透明阴影级联产生的可见性相乘应用到场景中，如7.4节所示。这种技术有效地提供了一个透明的单层阴影。这种技术的唯一缺点是，粒子会不正确地将阴影投射到粒子和太阳之间的不透明元素上。谨慎的关卡设计通常可以避免这种情况。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021132615.png" class="" title="image-20211021132615">

<p>粒子使用傅里叶不透明度映射投射体积阴影。在左边，傅里叶不透明度映射包含从一个聚光灯的角度来看的函数系数。在中间，粒子没有阴影渲染。在右侧，体积阴影投射在场景的粒子和其他不透明表面上。(图片由NVIDIA提供。)</p>
<p><strong>为了实现粒子的自阴影，必须使用更高级的技术，如傅立叶不透明度映射(FOM)。参见上图。粒子首先从光线的角度进行渲染，有效地将它们的贡献添加到透射函数中，表示为不透明度映射的傅里叶系数。当从这个角度渲染粒子时，可以通过从傅立叶系数中采样不透明度映射来重建透射率信号。这种表示法可以很好地表达平滑的透过率函数。然而，由于它使用有限系数的傅立叶基来维持纹理记忆要求，因此在透光率上有很大的变化。这可能导致渲染粒子四边形上不正确的亮或暗区域。FOM非常适合粒子，但也可以使用其他有不同优缺点的方法。这些包括自适应体积阴影地图部分中描述14.3.2(类似于深阴影地图),GPU优化粒子阴影地图(类似于不透明阴影地图,但仅限于camera-facing粒子,所以它不会工作丝带或motion-stretched粒子),和透过率函数映射(类似于FOM)。</strong></p>
<p><strong>另一种方法是在包含消光系数σt 的体积中对粒子进行体素化。这些卷可以被放置在相机周围，类似于剪贴图。该方法是一种统一评价体积鲱鱼的方法同时来自粒子和参与媒体的ows，因为它们都可以在这些公共体积中被体素化。生成一个存储Tr 的深阴影地图从这些“消光体积”中的每体素将自动导致从两个来源投射的体积阴影。产生的交互作用有很多:粒子和参与的媒体可以相互投射阴影，也可以投射自阴影;参见第613页的图14.21。结果质量与体素大小有关，为了实现实时性能，体素大小可能会很大。这将产生粗糙但视觉上柔和的体积阴影。有关更多细节，请参阅14.3.2节。</strong></p>
<h3 id="Particle-Simulation-粒子模拟"><a href="#Particle-Simulation-粒子模拟" class="headerlink" title="Particle Simulation 粒子模拟"></a>Particle Simulation 粒子模拟</h3><p><strong>使用粒子的有效和令人信服的物理过程近似是一个广泛的主题，超出了这本书的意图，所以我们将参考一些资源。GPU可以为精灵生成动画路径，甚至执行碰撞检测。流输出可以控制粒子的生死。这是通过将结果存储在一个顶点缓冲区中并在GPU上每帧更新这个缓冲区来实现的。如果无序访问视图缓冲区可用，粒子系统可以完全基于GPU，由顶点着色器控制。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021133245.png" class="" title="image-20211021133245">

<p>《命运2》中使用的粒子系统。(图片c 2017 Bungie, Inc.版权所有。)</p>
<p><strong>Van der Burg的文章和Latta的概述形成了对模拟基础的快速介绍。布莱德森关于计算机图形流体模拟的书深入讨论了理论，包括模拟各种形式的水、烟和火的物理基础技术。一些实践者提出了关于交互渲染器中的粒子系统的讨论。惠特利详细介绍了为命运号2开发的粒子系统。参见上图中的示例图像。Evans和Kirczenow从Bridson的文本中讨论了他们的流体流算法的实现。Mittring给出了关于粒子是如何存在的简要细节由Unreal Engine 4控制。Vainio深入研究了游戏《inFAMOUS Second Son》的粒子效果的设计和渲染。Wronski提出了一个有效生成和渲染雨水的系统。Gjøl和Svendsen讨论了烟雾和火灾效应，以及许多其他基于样品的技术。Thomas通过一个基于计算着色器的粒子模拟系统运行，该系统包括碰撞检测、透明排序和高效的基于瓦片的渲染。Xiao等人提出了一种交互式物理流体模拟器，该模拟器还可以计算用于显示的等值面。Skillman和Demoreuille通过他们的粒子系统和其他基于图像的效果来将游戏Br¨utal Legend的体积调到11。</strong></p>
<h2 id="Point-Rendering-点渲染"><a href="#Point-Rendering-点渲染" class="headerlink" title="Point Rendering 点渲染"></a>Point Rendering 点渲染</h2><p><strong>1985年，Levoy和Whitted写了一份开创性的技术报告，他们建议使用点作为一种新的原始元素来渲染一切。一般的想法是使用大量的点来表示一个表面，并渲染这些点。在随后的过程中，执行高斯滤波以填充渲染点之间的间隙。高斯滤波器的半径取决于表面上点的密度，以及屏幕上的投影密度。Levoy和Whitted在VAX-11/780上实现了这个系统。</strong></p>
<p><strong>然而，直到大约15年后，基于点的渲染才再次引起人们的兴趣。这一复兴的两个原因是计算能力的提高在这个水平上，基于点的渲染可以以交互速率实现，并且可以从激光测距扫描仪获得非常详细的模型。从那时起，各种用于探测距离的RGB-D(深度)设备开始出现，从用于地形测绘的空中激光雷达(光探测和测距)仪器，到微软Kinect传感器、iPhone TrueDepth相机和谷歌的Tango设备用于近程数据捕捉。自动驾驶汽车上的激光雷达系统每秒可以记录数百万个点。通过摄影测量或其他计算摄影技术处理的二维图像也用于提供数据集。这些不同技术的原始输出是一组带有附加数据的三维点，通常是强度或颜色。还可以提供其他分类数据，例如，一个点是来自建筑物还是路面。这些点云可以通过多种方式进行操作和渲染。</strong></p>
<p><strong>这些模型最初被表示为不相连的三维点。参见Berger等人对点云过滤技术和将其转化为网格的方法的深入概述。Kotfis和Cozzi提出了一种以交互速率处理、体素化和渲染这些体素化的方法。这里我们讨论直接渲染点云数据的技术。</strong></p>
<p><strong>QSplat是一个有影响力的基于点数的渲染器，首次发布于2000年。它使用球体的层次结构来表示模型。这个树中的节点被压缩，以允许渲染由数亿个点组成的场景。一个点被渲染为一个具有半径的形状，称为splat。可以使用的不同的splat形状有正方形、不透明圆和模糊圆。换句话说，splats是粒子，尽管渲染的目的是表示一个连续的表面。参见下图中的示例。渲染可以在树中的任何一层停止。该级别的节点被渲染为与节点球体半径相同的splats。因此，边界球层次结构是这样构造的，以便在任何级别上都不可见孔洞。由于遍历树可以在任何级别停止，因此可以通过在时间耗尽时停止遍历来获得交互帧率。当用户停止移动时，渲染的质量可以被反复优化，直到到达层次结构的叶子为止。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021133608.png" class="" title="image-20211021133608">

<p>这些模型使用基于点的渲染，使用圆形splats进行渲染。左边的图像显示了一个名叫露西的天使的完整模型，有1000万个顶点。然而，在渲染中只使用了大约300万个splats。中间和右边的图像放大了头部。中间的图像在渲染过程中使用了大约40000个splats。当观察者停止移动时，结果就会汇聚到右边显示的图像上，有60万个splats。(图片由QSplat程序由Szymon Rusinkiewicz生成。露西的模型是由斯坦福图形实验室创造的。)</p>
<p><strong>大约在同一时间，Pfister等人提出了surfer - 一个表面单元。它也是一个基于点的基元，用来表示物体表面的一部分，因此总是包含一个法线。一个八叉树(章节19.1.3)用于存储采样的sursurels:位置，法线，和过滤texels。在渲染过程中，surfels被投射到屏幕上，然后一个可见性飞溅算法被用来填充任何创建的洞。QSplat和surfels的论文确定并解决了点云系统的一些关键问题:管理数据集大小和从给定的点集绘制令人信服的表面。</strong></p>
<p><strong>QSplat使用一个层次结构，但它被细分到单点的层次，内部的父节点是包围球体，每个节点包含一个点，这是它的子节点的平均值。Gobbetti和Marton介绍了分层点云，这是一种分层结构，可以更好地映射到GPU，而不会创建人工的“平均”数据点。每个内部节点和子节点包含的内容大致相同数个点，称为n，在一个API调用中呈现为一个集合。我们通过从整个集合中取n个点来形成根节点，作为模型的粗略表示。选择一个点之间距离大致相同的集合比随机选择的结果更好。法线或颜色的差异也可以用于集群选择。其余的点在空间上划分为两个子节点。在每个节点上重复这个过程，选择n个有代表性的点，并将其余的分成两个子集。这种选择和细分一直持续到每个孩子有n个或更少的点。参见下图。Botsch等人的工作是目前最先进的一个很好的例子，它使用延迟着色(第20.1节)和高质量滤波的GPU加速技术。在展示期间,可见节点被加载和渲染，直到满足某些限制。节点的相对屏幕大小可用于确定加载点集的重要性，并可提供呈现的广告牌大小的估计。由于不为父节点引入新的点，内存使用量与存储的点的数量成正比。这种方案的一个缺点是，当放大单个子节点时，所有父节点都必须通过管线发送，即使每个节点中只有几个点可见。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021133832.png" class="" title="image-20211021133832">

<p>分层的点云。在左侧，根节点包含从子节点数据中提取的稀疏子集。接下来将显示一个子节点，然后与根节点中的点组合显示，说明子节点的区域是如何填充的。最右边是完整的点云、根和所有子节点。(图片来自Potree文档，开源软件，potree.org。Figure after Adorjan .)</p>
<p><strong>在目前的点云绘制系统中，数据集可能是巨大的，由数千亿个点组成。因为这些集合不能完全加载到内存中，更不用说以交互速率显示了，所以几乎每个点云渲染系统都使用了层次结构来加载和显示。使用的方案可能会受到数据的影响，例如，四叉树通常比八叉树更适合地形。对于点云数据结构的高效创建和遍历已经有了相当多的研究。Scheiblauer概述了这一领域的研究，以及表面重建技术和其他算法。Ador- jan给出了几个系统的概述，重点是分享由摄影测量生成的建筑点云。</strong></p>
<p><strong>理论上，splats可以提供单独的法线和半径来定义一个表面。在实践中，这样的数据占用了太多的内存，并且只有在经过大量的预处理之后才可用，所以通常使用固定半径的广告牌。由于分类和混合的成本，正确渲染半透明的广告牌点可能是昂贵的和人工负载。不透明的广告牌——正方形或镂空的圆圈——经常被用来保持交互性和质量。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021133948.png" class="" title="image-20211021133948">

<p>选择500万个点来渲染一个包含1.45亿个点的小镇数据集。通过检测深度差异增强边缘。在数据稀疏或广告牌半径过小的地方会出现间隙。下面一行显示的是图像预算分别为50万、100万和500万点时的选定区域。(使用Potree生成的图片，开源软件potree.org。奥地利Retz模型，RIEGL提供，riegl.com)</p>
<p><strong>如果点没有法线，那么可以采用不同的技术来提供着色。一种基于图像的方法是计算某种形式的屏幕空间环境遮挡(第11.3.6节)。通常情况下，所有的点首先被渲染到深度缓冲区中，具有足够宽的半径来形成一个连续的表面。在随后的渲染过程中，每一个点的着色都与靠近观察者的邻近像素的数量成比例地变暗。眼球圆顶照明(EDL)可以进一步强调表面细节。EDL的工作原理是检查相邻像素的屏幕深度，并找到那些比当前像素更接近观众的像素。对于每个这样的邻居，计算与当前像素的深度差并相加。这些差异的平均值，被否定，然后乘以一个强度因子，用作指数函数exp的输入。见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021134131.png" class="" title="image-20211021134131">

<p>在左边，点与法线在一次通过渲染。中间是一个没有法线的点云的屏幕空间环境遮挡渲染;右边是圆顶灯。最后两个方法都需要首先执行一个步骤来建立图像中的深度。(使用CloudCompare、GPL软件、cloudcompare.org生成的图像。足迹模型由Eugene Liscio提供。)</p>
<p><strong>如果每个点都有一个颜色或亮度，那么照明已经在里面了，所以可以直接显示出来，尽管有光泽或反光的物体不会对视图的变化做出反应。其他非图形属性，如对象类型或高度，也可以用于显示点。我们只涉及了管理和渲染点云的基础知识。Schuetz讨论了各种渲染技术，并提供了实现细节，以及一个高质量的开源系统。</strong></p>
<p><strong>点云数据可以与其他数据源相结合。例如，铯项目可以将点云与高分辨率地形、图像、矢量地图数据和摄影测量生成的模型结合起来。另一个scan-related科技-Nique是将环境从一个角度捕捉到一个天空盒中，保存颜色和深度信息，使场景捕捉具有物理存在。例如，用户可以添加合成模型到场景中，并使它们与这种类型的天空盒适当地合并，因为深度是可用的，周围图像中的每个点。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021134222.png" class="" title="image-20211021134222">

<p>在每个像素处具有可用深度的环境。对于一个固定的视图位置(但不是方向)，用户可以在世界空间位置和位置虚拟对象之间进行测量，并正确处理遮挡。(图片使用Autodesk ReCap Pro生成，Autodesk, Inc.提供)</p>
<p><strong>目前的技术已经有了相当大的进步，这些技术正在数据捕获和显示领域之外的领域得到应用。作为一个例子，我们简要总结了Evan为游戏Dreams提出的基于点数的渲染系统。每个模型由群集的包围体层次(BVH)表示，其中每个群集为256个点。这些点是由带符号的距离函数生成的(章节17.3)。对于细节级别的支持，将为每个细节级别生成单独的BVH、集群和点。为了从高细节过渡到低细节，高密度子集群中的点的数量随机地减少到25%，然后交换低细节的父集群。的Renderer基于一个计算着色器，它使用原子将点splicing to a framebuffer以避免碰撞。它实现了一些技术，如随机透明、景深(使用基于混乱圆的抖动板)、环境遮挡和不完美的阴影地图。为了平滑伪影，执行时间抗锯齿(第5.4.2节)。</strong></p>
<p><strong>点云代表空间中的任意位置，因此渲染起来很有挑战性，因为点之间的间隙通常不知道或不容易获得。Kobbelt和Botsch调查了这个问题和其他与点云相关的研究领域。为了结束这一章，我们转向一个非多边形表示法，其中样本与其相邻样本之间的距离总是相同的。</strong></p>
<h2 id="Voxels-体素"><a href="#Voxels-体素" class="headerlink" title="Voxels 体素"></a>Voxels 体素</h2><p><strong>正如像素是“图片元素”，像素是“纹理元素”，体素是“体积元素”。“每个体素代表一个统一的三维网格中的空间体积，通常是一个立方体。体素是存储体积数据的传统方法，可以表示从烟雾到3D打印模型，从骨骼扫描到地形表示的对象。可以存储单个位元，表示体素的中心是在对象内部还是外部。对于医疗应用，可能提供密度或不透明度，可能还提供容积流速。还可以存储颜色、法线、带符号的距离或其他值，以方便呈现。每个体素不需要位置信息，因为网格中的索引决定了它的位置。</strong></p>
<h3 id="Applications-应用程序"><a href="#Applications-应用程序" class="headerlink" title="Applications 应用程序"></a>Applications 应用程序</h3><p><strong>模型的体素表示可以用于许多不同的目的。一个规则的数据网格适合于所有与整个对象有关的操作，而不仅仅是它的表面。例如，由体素表示的物体的体积就是它内部体素的总和。网格的规则结构和体素定义良好的局部邻域意味着可以用元胞自动机或其他算法模拟烟雾、侵蚀或云形成等现象。有限元分析利用体素来确定物体的拉伸强度。雕刻或雕刻一个模型变成了减去体素的问题。相反，构建精细的模型可以通过将一个多边形模型放入体素网格并确定它重叠的体素来完成。与必须处理奇点和精度问题的更传统的多边形工作流相比，这种建设性的实体几何建模操作是高效的、可预测的，并且保证工作。OpenVDB和NVIDIA GVDB Voxels等基于体素的系统被用于电影制作、科学和医疗可视化、3D打印和其他应用。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021134600.png" class="" title="image-20211021134600">

<p>体素的应用程序。在左侧，流体模拟直接在稀疏体素网格上计算，并呈现为一个体积。在右侧，一个多边形兔子模型被体素化成一个带符号的距离场，然后用一个噪声函数扰动它，并绘制一个等值面。(左图由NVIDIA R提供，基于Wu等人的研究。右图使用NVIDIA R GVDB Voxels渲染，由NVIDIA公司提供。)</p>
<h3 id="Voxel-Storage-体素存储"><a href="#Voxel-Storage-体素存储" class="headerlink" title="Voxel Storage 体素存储"></a>Voxel Storage 体素存储</h3><p><strong>体素的存储有重要的内存需求，随着体素分辨率的O(n³)数据的增长。例如，每个维度分辨率为1000的体素网格会产生10亿个位置。《我的世界》等基于体素的游戏可以拥有巨大的世界。在这款游戏中，数据以每个16 × 16 × 256体素块的形式流进，并以每个玩家为半径。每个体素存储一个标识符和额外的方向或样式数据。每个块类型都有自己的多边形表示，无论是使用立方体显示的坚实的石头块，使用alpha纹理的半透明窗口，还是使用一对镂空广告牌表示的草地。参见第529页的图12.10和842页的图19.19提供示例。</strong></p>
<p><strong>存储在体素网格中的数据通常具有很大的相干性，因为相邻的位置可能具有相同或相似的值。根据数据源的不同，绝大多数网格可能是空的，这被称为稀疏卷。相干性和稀疏性都导致紧凑的表示。例如，一个八叉树(章节19.1.3)可以被施加到网格上。在最低的八叉树水平，每个2 × 2 × 2的体素样本可能都是相同的，这可以在八叉树和被丢弃的体素中被记录下来。可以在上面的树上检测相似度，并丢弃相同的子八叉树节点。只有在数据不同的地方才需要存储它们。这种稀疏体素八树(SVO)表示导致了自然水平的细节表示，相当于mipmap的三维体积。请参见下两图。Laine和Karras为SVO数据结构提供了丰富的实现细节和各种扩展。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021134841.png" class="" title="image-20211021134841">

<p>稀疏体素八叉树，二维形式。给定左侧的一组体素，我们注意到在树的上面哪个父节点有任何体素。右边是最后一个八叉树的可视化，显示了每个网格位置存储的最深的节点。(参见莱恩和卡拉斯)</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021134852.png" class="" title="image-20211021134852">

<p>不同细节层次的体素射线追踪。从左到右，包含模型的体素网格的每个边缘的分辨率分别为256、512和1024。(使用Optix和NVIDIA R GVDB Voxels渲染的图像，由NVIDIA公司提供。)</p>
<h3 id="Generation-of-Voxels-体素的生成"><a href="#Generation-of-Voxels-体素的生成" class="headerlink" title="Generation of Voxels 体素的生成"></a>Generation of Voxels 体素的生成</h3><p><strong>体素模型的输入可以来自多种来源。例如，许多扫描设备在任意位置生成数据点。GPU可以加速体素化，即将点云、多边形网格或其他表示转换为一组体素的过程。对于网格，Karabassi等人提出的一种快速但粗略的方法是从6个正投影视图渲染对象:顶部、底部和四个侧面。每个视图都生成一个深度缓冲区，所以每个像素都保存从那个方向第一个可见体素的位置。如果体素的位置超出了存储在6个缓冲区中的深度，那么它是不可见的，因此被标记为在对象内部。这种方法将错过任何在任何六个视图中看不到的特征，导致一些体素被不当地标记为内部。不过，对于简单的模型来说，这种方法已经足够了。</strong></p>
<p><strong>受视觉船体的启发，Loop等人使用一种更简单的系统来创建现实世界中的人的体素化。一组人的图像被捕获，轮廓被提取出来。每个剪影都被用来切割一组给定其摄像机位置的体素——只有你能看到的人的像素才会有与它们相关联的体素。</strong></p>
<p><strong>体素网格也可以从图像集合中创建，比如使用医学图像设备生成切片，然后将切片堆叠起来。沿着同样的路线，网格模型可以被逐片渲染，并且在模型中发现的体素被适当地记录下来。近平面和远平面被调整以绑定每个切片，检查其中的内容。Eisemann和D´ecoret引入了切片映射的概念，32位目标被认为是32个独立的深度，每个深度都有一个位标记。渲染到这个体素网格的三角形的深度被转换为它的位等值并存储。32层可以在渲染通道中渲染，如果使用更宽的通道图像格式和多个渲染目标，则可以使用更多的体素层。Forest等人给出了实现细节，指出在现代GPU上，一次通过最多可以渲染1024层。注意，这个切片算法只识别模型的表面，它的边界表示。上面的六视图算法也识别(虽然有时错误分类)体素完全在模型内部。下图是三种常见的体素化类型。Laine对术语、各种体素化类型以及生成和使用它们所涉及的问题进行了全面的处理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021135147.png" class="" title="image-20211021135147">

<p>一个球体以三种不同的方式体素化，并显示其横截面。左边是固体体素化，通过测试每个体素在球体上的中心来确定。在中间是一个保守的体素化，其中任何与球体表面接触的体素都被选中。这个表面被称为26分离体素化，其中内部体素在其3 × 3 × 3邻域内不与外部体素相邻。换句话说，内部体素和外部体素从不共享一个面、边或顶点。右边是6分离体素化，其中边缘和角可以在内部和外部体素之间共享。(图接Schwarz和Seidel)</p>
<p><strong>更有效的体素化可能与现代GPU提供的新功能。Schwarz和Seidel和Pantaleoni提出了体素化系统tems使用计算着色器，它提供了直接构建SVO的能力。Crassin和Green描述了他们用于规则网格体素化的开源系统，该系统利用了OpenGL 4.2中可用的图像加载/存储操作。这些操作允许对纹理存储器进行随机读写访问。通过使用保守的栅格化(章节23.1.2)来确定重叠体素的所有三角形，他们的算法有效地计算体素占用率，以及平均颜色和法线。他们也可以用这种方法创建SVO，从上到下构建，并在它们下降时只对非空节点进行体素化，然后使用自底向上的过滤mipmap创建来填充结构。Schwarz给出了栅格化和计算核体素化系统的实现细节，并解释了各自的特征。Rauwendaal和Bailey包含了他们的混合系统的源代码。它们提供了并行体素化方案的性能分析，以及如何正确使用保守栅格化以避免误报的细节。Takeshige讨论了MSAA如何成为保守光栅化的可行替代方案，如果少量的误差是可以接受的。Baert等提出了一种高效运行出核SVOs的算法，即无需整个模型驻留在内存中，就能对场景进行高精度体素化。</strong></p>
<p><strong>考虑到对场景进行体素化需要大量的处理，动态对象——那些移动或动画的对象——对基于体素的系统来说是一个挑战。Gai- tatzes和Papaioannou通过逐步更新他们对场景的体素表示来解决这个任务。他们使用场景相机的渲染结果和生成的任何阴影图来清除和设置体素。体素是针对深度缓冲区进行测试的，那些被发现比记录的z-深度更接近的将被清除。缓冲区中的深度位置随后被视为一组点并转换到世界空间。这些点对应的体素被确定和设置，如果之前没有标记。这个清晰和设置的过程是依赖于视图的，这意味着当前没有摄像机看到的场景部分实际上是未知的，因此可能是错误的来源。然而，这种快速的近似方法使得计算基于体素的全局光照效果在动态环境中以交互速率执行(章节11.5.6)。</strong></p>
<h3 id="Rendering-渲染"><a href="#Rendering-渲染" class="headerlink" title="Rendering 渲染"></a>Rendering 渲染</h3><p><strong>体素数据存储在一个三维数组中，它也可以被认为是，也确实是存储为一个三维纹理。这样的数据可以以多种方式显示。下一章将讨论可视化体素数据的方法，这些数据是半透明的，比如雾，或者放置切片机来检查数据集，比如超声图像。这里我们将专注于渲染表示实体对象的体素数据。</strong></p>
<p><strong>想象一下最简单的体积表示，每个体素包含一个标记，它是在物体内部还是外部。有几种常用的方法来显示这些数据。一种方法是直接用光线投射体积确定每个方块最近的击中面。另一种技术是将体素立方体转换为一组多边形。尽管使用网格渲染速度很快，但这在体素化过程中会产生额外的成本，最适合静态体积。如果每个体素的立方体显示为不透明的，那么我们可以剔除两个立方体相邻的任何面，因为它们之间的共享正方形是不可见的。这个过程留给我们一个正方形的外壳，里面是中空的。简化技术(第16.5节)可以进一步减少多边形数量。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021135705.png" class="" title="image-20211021135705">

<p>多维数据集扑杀。在左边，17074体素实心球体由102444个四元体素组成，每体素6个。在中间，相邻实体体素之间的两个四边形被删除，计数减少到4770。外观和左边一样，因为外壳没有动过。在右侧，一个快速贪婪算法将表面合并成更大的矩形，得到2100个四边形。(图片来自Mikola Lysenko的筛选程序。)</p>
<p><strong>对这组立方体面进行着色对于代表曲面的体素来说是没有说服力的。给立方体着色的一种常见的替代方法是使用行进立方体(marching cubes)等算法创建一个更平滑的网格表面。这个过程称为表面提取或多边形化(又称多边形化)。我们不把每个体素看作一个盒子，而是把它看作一个点样本。然后，我们可以用8个相邻的样品在2 × 2 × 2的模式中形成一个立方体，形成角落。这八个角的状态可以定义一个通过立方体的表面。例如，如果立方体的顶部四个角在外面，底部四个角在里面，那么用水平正方形将立方体分成两半是猜测表面形状的一个好方法。一个角在外面，其余的在里面，形成了一个三角形，由三个立方体边的中点连接到外面的角。参见下图。的过程把一组多维数据集的角落变成对应的多边形网格有效,八个角位可以被转换成一个索引从0到255,用于访问一个表指定的数量和位置每个可能的三角形配置。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021135859.png" class="" title="image-20211021135859">

<p>多维数据集。在左侧，四个底部角是物体内部的体素中心，因此在底部和顶部四个角之间形成了一个由两个三角形组成的水平正方形。在中间，一个角在外面，这样就形成了一个三角形。在右侧，如果有符号的距离值存储在角上，那么我们可以在每条边上插值三角形顶点为0.0。注意，共享一条给定边的其他立方体将在沿那条边的相同位置有一个顶点，以确保表面没有裂缝。</p>
<p><strong>其他渲染体素的方法，如水平集，更适合光滑、弯曲的表面。假设每个体素存储了到被表示物体表面的距离，一个正值表示内部，一个负值表示外部。我们可以利用这些数据来调整形成的网格的顶点位置，使其更准确地表示曲面，如上图中右侧所示。或者,我们可以直接射线追踪等值为零的水平集。这种技术称为水平集渲染。它特别擅长在没有任何附加体素属性的情况下表示曲面和曲线模型的法线。</strong></p>
<p><strong>表示密度差异的体素数据可以通过决定表面的形式以不同的方式可视化。例如，一些给定的密度可以很好地显示肾脏，另一个密度可以显示任何肾结石。选择密度值定义了等值面，等值面是一组具有相同值的位置。能够改变这个值对于科学可视化特别有用。射线直接追踪任何等值面值都是水平集射线追踪的推广，其中目标值始终为零。或者，可以提取等值面并将其转换为多边形模型。</strong></p>
<p><strong>2008年Olick做了一个很有影响力的演讲，讨论了如何通过光线投射直接渲染稀疏体素表示，启发了进一步的工作。针对正则体素测试射线非常适合GPU实现，并且可以在交互帧率下完成。许多研究人员已经探索了渲染的这一领域。首先介绍一下Crassin的博士论文和SIGGRAPH的介绍，这两篇论文涵盖了基于体素的方法的优点。Crassin利用了数据的类似mimap的特性，使用了锥体追踪。一般的想法是利用体素表示的规则性和良好定义的局部性来定义几何和阴影属性的预滤波方案，从而允许使用线性滤波器。一条光线被追踪到整个场景，但是它能够通过一个从它的起始点发出的锥体获得一个近似值。当射线在空间中移动时，它感兴趣的半径会增长，这意味着体素层级会在链的更高处采样，类似于mipmap在单个像素中有更多像素时采样的更高处。这种抽样方式可以快速计算例如，软阴影和景深，因为这些效果可以分解为锥跟踪问题。面积采样对其他处理也有价值，如反锯齿和适当过滤变化的表面法线。Heitz和Neyret描述了以前的工作，并提出了一种新的数据结构，用于提高锥跟踪的可见性计算结果。Kasyan使用体素锥跟踪区域灯光，讨论了误差来源。对比如下图所示。最后的结果请参见264页上的图7.33。圆锥跟踪用于计算全局照明效果将在第11.5.7节中讨论和说明。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211021140038.png" class="" title="image-20211021140038">

<p>Cone-traced阴影。上图:在Maya中20秒内渲染的光线追踪球面区域光。下图:同一场景的体素化和锥跟踪耗时约20毫秒。模型用多边形渲染，体素化版本用于阴影计算。(图片由Crytek提供。)</p>
<p><strong>最近的趋势是在GPU上探索八叉树以外的结构。八叉树的一个关键缺点是，像射线跟踪这样的操作需要大量的树遍历跳，因此需要存储大量的中间节点。Hoet- zlein的研究表明，VDB树是一种网格层次结构，其GPU射线追踪可以比八元树获得显著的性能增益，并且更适合于体积数据的动态变化。Fogal等人证明了索引表，而不是八叉树，可以使用双通道方法实时绘制大量数据。第一步识别可见的子区域(砖)，以及来自磁盘的这些区域中的流。第二次传递呈现当前驻留在内存中的区域。Beyer等人对大规模体绘制进行了全面的研究。</strong></p>
<h3 id="Other-Topics-其他主题"><a href="#Other-Topics-其他主题" class="headerlink" title="Other Topics 其他主题"></a>Other Topics 其他主题</h3><p><strong>例如，表面提取通常用于可视化隐式表面(章节17.3)。有不同形式的基本算法和一些微妙的如何形成网格。例如，如果发现立方体的每个其他角都在里面，这些角应该在多边形网格中连接在一起，还是保持分离?参见de Ara´ujo等人的文章，了解隐式曲面的多边形化技术。Austin研究了各种一般多边形化方案的优缺点，发现立方体行进正方形具有最理想的特性。</strong></p>
<p><strong>当使用光线投射进行渲染时，除了完全多边形化之外，还有其他的解决方案。例如，Laine和Karras在每个接近表面的体素上附加一组平行平面，然后使用后处理模糊来掩盖体素之间的不连续。Heitz和Neyret以线性可过滤的表示法访问带符号的距离，这种表示法允许重建平面方程，并确定任意空间位置和分辨率在给定方向上的覆盖范围。</strong></p>
<p><strong>Eisemann和D´ecoret展示了体素表示如何用于执行深度阴影映射(章节7.8)，用于半透明重叠表面投射阴影的情况。正如K¨ampe, Sintorn等人所展示的，体素化场景的另一个优点是，相对于为每个光源生成一个阴影地图，所有光源的阴影射线都可以使用这一表示进行测试。与直接可见的表面绘制相比，眼睛更容易容忍次要效果中的小错误，如阴影和间接照明，这些任务需要的体素数据也少得多。当只跟踪一个体素占用时，许多稀疏体素节点之间可能存在极高的自相似性。例如，一堵墙会形成几层相同的体素集。这意味着树中的各个节点和整个子树都是相同的，因此我们可以为这些节点使用一个实例，并将它们存储在所谓的有向无环图中(章节19.1.5)。这样做通常会导致每个体素结构所需内存的大量减少。</strong></p>
<h1 id="14-Volumetric-and-Translucency-Rendering-体积和半透明渲染"><a href="#14-Volumetric-and-Translucency-Rendering-体积和半透明渲染" class="headerlink" title="14 Volumetric and Translucency Rendering 体积和半透明渲染"></a>14 Volumetric and Translucency Rendering 体积和半透明渲染</h1><p><strong>参与介质是用来描述充满粒子的体积的术语。顾名思义，它们是参与光传输的介质，换句话说，它们通过散射或吸收来影响通过它们的光。当渲染虚拟世界时，我们通常关注实体表面，简单而复杂。这些表面看起来是不透明的，因为它们是由光从稠密的粒子化介质(如介电介质或典型使用BRDF建模的金属)反射而定义的。密度较低的众所周知的介质是水、雾、蒸汽，甚至是空气，它们是由稀疏的分子组成的。根据介质的成分不同，介质与光的相互作用会有所不同——通过介质的光会被其粒子反射，这种现象通常被称为光散射。粒子的密度可以是均匀的，如空气或水的密度。或者它可能是不均匀的(不均匀的，随空间位置而变化)，就像云或蒸汽的情况一样。一些致密的材料通常呈现为固体表面，表现出高水平的光散射，如皮肤或蜡烛蜡。如第9.1节所示，漫射表面阴影模型是光在微观水平上散射的结果。一切都是散射。</strong></p>
<h2 id="Light-Scattering-Theory-光散射理论"><a href="#Light-Scattering-Theory-光散射理论" class="headerlink" title="Light Scattering Theory 光散射理论"></a>Light Scattering Theory 光散射理论</h2><p><strong>在本节中，我们将描述光在参与媒体中的模拟和渲染。这是对物理现象散射和吸收的定量处理，在9.1.1和9.1.2节中讨论过。在多重散射路径追踪的情况下，许多作者描述了辐射传输方程。在这里，我们将专注于单次散射，并建立一个关于它如何工作的良好直觉。单散射只考虑光的一次反弹构成参与媒体的粒子。多重散射跟踪每个光路的多次反射，因此要复杂得多。有和没有多次散射的结果可以在646页的图14.51中看到。用于表示散射方程中参与介质属性的符号和单位如下表所示。注意本章中的许多量，如σa,σs,σt,p,ρ,v和Tr 波长相关，这实际上意味着它们是RGB量。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022131125.png" class="" title="image-20211022131125">

<p>用于分散和参与媒体的符号。这些参数中的每一个都取决于波长(即波长)。， RGB)来实现对有色光的吸收或散射。相位函数的单位是反steradians(章节8.1.1)。</p>
<h3 id="Participating-Media-Material-参与媒介材质"><a href="#Participating-Media-Material-参与媒介材质" class="headerlink" title="Participating Media Material 参与媒介材质"></a>Participating Media Material 参与媒介材质</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022131614.png" class="" title="image-20211022131614">

<p>在参与的媒介中，不同的事件会沿一个方向d改变辐亮度。</p>
<p><strong>有四种类型的事件可以影响沿光线通过介质传播的亮度。如上图所示，并总结为:</strong></p>
<pre><code>**•吸收(函数σa)：光子被介质中的物质吸收，然后转化为热或其他形式的能量。**

**•向外散射(函数σs)：光子被介质物质中的粒子反弹而散射。这将根据描述光反射方向分布的相位函数p发生。**

**•发射：当介质达到高热时，例如火的黑体辐射，光就会被发射出来。关于排放的更多细节，请参考Fong等人的课程笔记。**

**•散射(函数σs)：光子从任何方向都可以散射到当前的光路径后反弹的粒子和贡献最后的光辉。从一个给定方向散射的光的数量也取决于该光方向的相位函数p。**
</code></pre>
<p><strong>综上所述，向路径添加光子是内散射σs 函数和发射。光子去除是消光函数σt =σa +σs，表示吸收和向外散射。如辐射传输方程所解释的一组系数表示位置x和朝向 v方向的辐射度相对于L(x, v)的导数。这就是为什么这些系数的值都在[0，+∞]范围内。详情见Fong等人的注释。散射和吸收系数决定了介质的反照率ρ，定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022132059.png" class="" title="image-20211022132059">

<p><strong>它表示了在考虑的每个可见光谱范围内介质中相对于吸收的散射的重要性，即媒介的整体反射性。ρ的值在[0,1]范围内。接近0的值表示大部分光线被吸收，导致介质浑浊，如深色的尾气烟雾。接近1的值表示大部分光线是散射的，而不是被吸收的，从而产生更明亮的介质，如空气、云或地球的大气层。</strong></p>
<p><strong>正如第9.1.2节所讨论的，介质的出现是它的散射和吸收特性的结合。已经测量并公布了真实参与媒体的系数值。例如，牛奶有很高的散射值，产生浑浊和不透明的外观。由于高反照率ρ &gt; 0.999，牛奶也呈现白色。另一方面，红葡萄酒的特点是几乎没有散射，而是高吸收，使其半透明和彩色的外观。参见下图中渲染的液体，并与301页图9.8中拍摄的液体进行对比。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022132209.png" class="" title="image-20211022132209">

<p>呈现的葡萄酒和牛奶，分别具有吸收和散射在不同的浓度。(图片由Narasimhan等人提供。)</p>
<p><strong>每个属性和事件都是波长相关的。这种依赖性意味着在给定的介质中，不同的光频率可能以不同的概率被吸收或散射。理论上，为了解释这一点，我们应该在渲染时使用光谱值。为了提高效率，在实时渲染中(也有一些例外在离线渲染中)我们使用RGB值。在可能的情况下，σa 和σs 应使用颜色匹配函数从光谱数据中预先计算(第8.1.3节)。</strong></p>
<p><strong>在前面的章节中，由于没有参与的介质，我们可以假设进入相机的辐亮度与离开最近表面的辐亮度相同。更确切地说，我们假设(在310页)Li(c, -v) = Lo(p, v)，其中c是摄像机位置，p是最近曲面与视图射线的交点，v是指向p到c的单位视图向量。</strong></p>
<p><strong>一旦引入了参与的媒体，这个假设就不再成立了，我们需要考虑沿视图射线的亮度变化。作为一个例子，我们将现在描述计算从准时光源散射光所涉及的计算。用一个无限小点表示的光源(第9.4节):</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022132444.png" class="" title="image-20211022132444">

<p><strong>其中Tr(c, x)为给定点x与摄像机位置c(章节14.1.2)和Lscat(x, v)之间的透射率是沿视场射线(章节14.1.3)上给定点x散射的光。计算的不同组成部分如下图所示，并在以下小节中进行解释。关于上式如何从辐射传递方程推导出来的更多细节可以在Fong等人的课程笔记中找到。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022132605.png" class="" title="image-20211022132605">

<p>点状光源的单次散射积分图解。沿视图射线的采样点显示为绿色，一个点的相位函数显示为红色，不透明表面S的BRDF显示为橙色。在这里,lc 是光中心的方向向量，plight 为光的位置，p为相位函数，v为能见度项。</p>
<h3 id="Transmittance-透光率"><a href="#Transmittance-透光率" class="headerlink" title="Transmittance 透光率"></a>Transmittance 透光率</h3><p><strong>透光率Tr 表示在一定距离内能够通过媒介的光的比率</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022132849.png" class="" title="image-20211022132849">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022133019.png" class="" title="image-20211022133019">

<p>透过率是深度的函数，σt =(0.5, 1.0, 2.0)。正如预期的那样，红色组分的消光系数越低，透射出的红色就越多。</p>
<p><strong>这种关系也被称为比尔-朗伯定律。光学深度τ无单位，表示光衰减量。消光或穿越距离越高，光学深度就越大，反过来，穿过介质的光就越少。当光学深度τ = 1时，约60%的光会被移除。例如，如果σt =(0.5, 1,2)，则通过深度d = 1米的光线为Tr = e^(−dσt)≈(0.61,0.37,0.14)。这种行为如上图所示。需要在(i)辐亮度Lo(p, v)上应用透射率来自不透明表面，(ii)辐射亮度Lscat(x, v)由内散射事件产生，以及(iii)从散射事件到光源的每条路径。从视觉上看，(i)将导致一些雾状的表面遮挡，(ii)将导致散射光遮挡，提供关于介质厚度的另一个视觉线索(见下下图)，(iii)将导致参与介质的体积自遮挡(见下图)。由于σt =σa +σs时，预期透过率同时受到吸收和向外散射分量的影响。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022133216.png" class="" title="image-20211022133216">

<p>由参与媒体制作的斯坦福兔子的体积阴影示例。左:无体积自阴影;中间:投影;右图:阴影投射到其他场景元素上。(模型由斯坦福计算机图形实验室提供。)</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022133227.png" class="" title="image-20211022133227">

<p>斯坦福龙与越来越多的媒体集中。从左到右:0.1、1.0、10.0，σs =(0.5、1.0、2.0)。(模型由斯坦福计算机图形实验室提供。)</p>
<h3 id="Scattering-Events-散射事件"><a href="#Scattering-Events-散射事件" class="headerlink" title="Scattering Events 散射事件"></a>Scattering Events 散射事件</h3><p><strong>对给定位置x场景中准时光源的散射积分从方向v可以做如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022133608.png" class="" title="image-20211022133608">

<p><strong>其中n为灯数，p()为相位函数，v()为能见度函数，lci是指向第i个光的方向向量，plighti是第i盏灯的位置。此外,clighti()是第i个光源的亮度作为其位置距离的函数，使用了第9.4节的定义和第5.2.2节的平方衰减反函数。可见性函数v(x, plighti)表示从光源plighti处到达位置x的光的比率</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022133753.png" class="" title="image-20211022133753">

<p><strong>其中volShad (x, plighti) = Tr (x,plighti)。在实时渲染中，阴影是由两种遮挡造成的:不透明遮挡和体积遮挡。不透明物体的阴影(shadowMap)传统上是通过使用阴影映射或第7章中的其他技术来计算的。</strong></p>
<p><strong>上式的体积阴影项volShad(x, plighti)表示光源位置plighti的透过率采样点x，其取值范围为[0,1]。由体积产生的遮挡是体积渲染的一个重要组成部分，其中体积元素可以自阴影或在其他场景元素上投射阴影。参见上上图。这种结果通常是通过从眼睛通过体积到第一个表面的主射线，然后沿着从每个样品到每个光源的次级射线路径来实现的。“光线行进”是指用n个样本对两点之间的路径进行采样，并对沿途的散射光和透射率进行积分。关于这种采样方法的更多细节，请参阅第6.8.1节，在这种情况下，它是用于渲染高度场的。光线行进与三维体相似，每条光线都是一步一步前进，并采样体材料或沿途的每一点照明。见图14.3，它显示了绿色的主射线和蓝色的次级阴影射线上的样本点。许多其他出版物也详细描述了射线行军。</strong></p>
<p><strong>O (n²)的复杂度，其中n是沿着每条路径的样本数量，射线快速前进将变得昂贵。作为质量和性能之间的权衡，特定的体积阴影表示技术可以用来存储传输从灯向外的方向。这些技术将在本章余下部分的适当章节中进行解释。</strong></p>
<p><strong>为了对介质中光散射和消光的行为有一些直观的认识，考虑σs =(0.5, 1,2)和σa =(0,0,0)。对于介质内的短光程，内散射事件将压倒消光，例如，在本例中，外散射事件，其中Tr 对于较小的深度≈1。该材料将显示蓝色，因为该通道的σs 值是最高的。光穿透介质越深，通过的光子就越少，这是由于消光造成的。在这种情况下，来自消光的透射色将开始占主导地位。这可以用σt =σs来解释,因为σa =(0,0,0)，因此，Tr = e^(−dσt)作为光学深度dσs的函数，将比散射光的线性积分下降得快得多使用方程14.2。对于这个例子，红光通道将较少受到消光通过介质，因为该通道的σt 价值是最低的，所以它将占主导地位。上图描述了这种行为，这正是在大气和天空中发生的事情。当太阳高的时候(例如，穿过大气层的短光，垂直于地面)，蓝色的光散射更多，使天空呈现出自然的蓝色。然而，当太阳在地平线上时，光线穿过大气层的路径很长，天空会显得更红，因为更多的红光被透射。这就产生了我们都知道的美丽的日出和日落过渡。有关大气物质组成的更多细节，请参阅14.4.1节。关于这种效果的另一个例子，请看299页图9.6右边的乳白色玻璃。</strong></p>
<h3 id="Phase-Functions-相位函数"><a href="#Phase-Functions-相位函数" class="headerlink" title="Phase Functions 相位函数"></a>Phase Functions 相位函数</h3><p><strong>参与的介质是由半径不同的粒子组成的。这些粒子的大小分布将影响光在特定方向散射的概率，相对于光的前进方向。这种行为背后的物理原理将在第9.1节中解释。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022134558.png" class="" title="image-20211022134558">

<p>图示相位函数(红色)及其对散射光的影响(绿色)作为θ的函数。</p>
<p><strong>在计算内散射时，使用相位函数在宏观水平上描述散射方向的概率和分布，如式14.4所示。如上图所示。红色的相位函数用参数θ表示，蓝色的是光的前进路径与绿色的v方向的夹角。注意这个相位函数例子中的两个主要的波瓣:一个在光路相反方向的小后向散射波瓣和一个大的前向散射波瓣。相机B处于大的前向散射波瓣方向，因此它接收到的散射辐亮度要比相机A大得多。在没有能量增益或损失的情况下，相位函数在单位球上的积分必须为1。</strong></p>
<p><strong>相位函数将根据到达该点的方向辐射信息改变该点的内散射。最简单的函数是各向同性的:光将均匀地向各个方向散射。这种完美但不现实的行为表现为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022134655.png" class="" title="image-20211022134655">

<p><strong>θ为入射光与向外散射方向的夹角，π为单位球的面积。</strong></p>
<p><strong>基于物理的相位函数依赖于相对大小sp</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022134704.png" class="" title="image-20211022134704">

<p><strong>其中r为粒子半径，λ为所考虑的波长:</strong></p>
<p><strong>•当sp ≪1，存在瑞利散射(如空气)。</strong></p>
<p><strong>•当sp ≈1，有米氏散射。</strong></p>
<p><strong>•当sp≫1，几何散射。</strong></p>
<h4 id="Rayleigh-Scattering-瑞利散射"><a href="#Rayleigh-Scattering-瑞利散射" class="headerlink" title="Rayleigh Scattering 瑞利散射"></a>Rayleigh Scattering 瑞利散射</h4><p><strong>瑞利勋爵(1842-1919)导出了光从空气分子散射的术语。在其他应用中，这些表达式被用来描述光在地球大气层中的散射。如图所示，这个相位函数有两个瓣在上图中，称为前后散射，相对于光的方向。这个函数在θ处计算，是入射光和向外散射方向的夹角。函数是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022135220.png" class="" title="image-20211022135220">

<p><strong>瑞利散射与波长高度相关。当把散射系数看成光波长λ的函数时，散射系数σs 因为瑞利散射与波长的四次方反比成正比:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022135249.png" class="" title="image-20211022135249">

<p><strong>这种关系意味着，短波长的蓝光或紫光比长波长的红光更容易散射。由上式得到的光谱分布可通过光谱颜色匹配函数(章节8.1.3)转换为RGB: σs =(0.490, 1.017, 2.339)。这个值被归一化为亮度1，并应根据所需的散射强度进行缩放。蓝光在大气中散射较多所产生的视觉效果，见14.4.1节。</strong></p>
<h4 id="Mie-Scattering-米氏散射"><a href="#Mie-Scattering-米氏散射" class="headerlink" title="Mie Scattering 米氏散射"></a>Mie Scattering 米氏散射</h4><p><strong>米氏散射是一个模型，当粒子的大小与光的波长大致相同时可以使用。这种类型的散射与波长无关。MiePlot软件可以用来模拟这一现象。米氏阶段对于特定粒径的函数通常是一个具有强烈而尖锐的方向性叶状的复杂分布，即表示在相对于光子旅行方向的特定方向上散射光子的高概率。为体积着色计算这样的相位函数是昂贵的，但幸运的是它很少需要。典型的介质具有颗粒尺寸的连续分布。对所有这些不同尺寸的Mie相函数进行平均，可以得到整个介质的平滑平均相函数。因此，可以用相对光滑的相位函数来表示米氏散射。</strong></p>
<p><strong>常用的一种相函数是Henyey-Greenstein (HG)相函数，它最初被用来模拟星际尘埃中的光散射。这个函数不能捕获每个真实世界散射行为的复杂性，但它可以很好地匹配代表一个相位函数瓣，即朝着主要的分散方向。它可以用来表示任何烟、雾或粉尘样的参与媒体。这种介质可以表现出强烈的向后或向前散射，导致光源周围出现大的视觉晕。例子包括雾中的聚光灯和在太阳方向的云的边缘有强烈的银衬效果。</strong></p>
<p><strong>HG相函数可以代表比瑞利散射更复杂的行为，并使用</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022135715.png" class="" title="image-20211022135715">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022135821.png" class="" title="image-20211022135821">

<p>。Henyey-Greenstein(蓝色)和Schlick近似(红色)相作为θ函数的极坐标图。光线从左边水平射入。参数g从0增加到0.3和0.6，导致在右侧有一个强烈的波瓣，这意味着光将沿着其前进的路径从左到右散射更多。</p>
<p><strong>它可以产生不同的形状，如上图所示。g参数可以用来表示后向(g &lt; 0)、各向同性(g = 0)或前向(g &gt; 0)散射，g在[-1,1]中。使用HG相函数的散射结果示例如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022135839.png" class="" title="image-20211022135839">

<p>参与媒体Stanford兔显示HG相功能影响，与g从各向同性到强正向散射。从左到右:g = 0.0, 0.5, 0.9, 0.99，和0.999。最下面一行使用了十倍密集的参与媒体。(模型由斯坦福计算机图形实验室提供。)</p>
<p><strong>获得与Henyey-Greenstein相函数相似结果的一种更快的方法是使用Blasi等人提出的近似方法第三作者作为Schlick阶段函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022140008.png" class="" title="image-20211022140008">

<p><strong>它不包括任何复杂的幂函数，而只是一个平方，这是更快的计算。为了将该函数映射到原始HG相函数，需要从g中计算k参数。对于具有恒定g值的参与介质，只需执行一次。在实际应用中，Schlick相位函数是一个很好的能量守恒近似，如上上图所示。</strong></p>
<p><strong>也可以混合多个HG或Schlick相函数，以表示更复杂的一般相函数范围。这使我们能够同时表示具有强前向散射和后向散射叶的相位函数，类似于云的行为，如14.4.2节所描述和说明的。</strong></p>
<h4 id="Geometric-Scattering-几何散射"><a href="#Geometric-Scattering-几何散射" class="headerlink" title="Geometric Scattering 几何散射"></a>Geometric Scattering 几何散射</h4><p><strong>几何散射发生在粒子明显大于光的波长的时候。在这种情况下，光可以在每个粒子内折射和反射。这种行为可能需要一个复杂的散射相位函数来在宏观层面上模拟它。光的偏振也会影响这种类型的散射。例如，一个真实的例子是视觉彩虹效应。它是由光线在空气中的水粒子内部的反射引起的，在一个小的视角(3度)上将太阳光散射成可见光谱。这种复杂的相位函数可以使用MiePlot软件进行模拟。第14.4.2节描述了这样一个相位函数的例子。</strong></p>
<h2 id="Specialized-Volumetric-Rendering-专业的体积渲染"><a href="#Specialized-Volumetric-Rendering-专业的体积渲染" class="headerlink" title="Specialized Volumetric Rendering 专业的体积渲染"></a>Specialized Volumetric Rendering 专业的体积渲染</h2><p><strong>本节以基本的、有限的方式介绍渲染体积效果的算法。有些人甚至会说，这些都是老掉牙的把戏，往往依赖于临时模型。它们被使用的原因是它们仍然工作得很好。</strong></p>
<h3 id="Large-Scale-Fog-大规模的雾"><a href="#Large-Scale-Fog-大规模的雾" class="headerlink" title="Large-Scale Fog 大规模的雾"></a>Large-Scale Fog 大规模的雾</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022140844.png" class="" title="image-20211022140844">

<p>雾过去常加重一种情绪。(图片由英伟达公司提供。)</p>
<p><strong>雾可以近似为基于深度的效果。它最基本的形式是根据与相机的距离在场景顶部的雾颜色的alpha混合，通常称为深度雾。这种效果对观众来说是一个视觉提示。首先，它可以提高现实主义和戏剧性的水平，如上图所示。其次，它是一个重要的深度线索，帮助场景的观众确定物体的位置。参见下图。第三，它可以用作遮挡剔除的一种形式。如果对象在距离太远时被雾完全遮挡，那么可以安全地跳过它们的渲染，从而提高应用程序的性能。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022140936.png" class="" title="image-20211022140936">

<p>在这张来自DICE游戏《战地1》的关卡图片中使用了雾，以揭示游戏玩法区域的复杂性。深度雾被用来揭示景物的大尺度性质。从右边的地面上可以看到高空雾，大量的建筑物拔地而起从山谷。(由DICE提供，2018年Electronic Arts Inc.)</p>
<p><strong>表示雾量的一种方法是用[0,1]中的f表示透射率，即f = 0.1表示10%的背景表面是可见的。假设曲面的输入颜色是ci 雾的颜色是cf ，则最后的颜色c由</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022141145.png" class="" title="image-20211022141145">

<p><strong>f的值可以用许多不同的方法计算。使用时雾可线性增加</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022141155.png" class="" title="image-20211022141155">

<p><strong>其中zstart 和zend 是用户参数，决定雾在哪里开始和结束(即变得完全雾蒙蒙)，zs 是从观察者到要计算雾的表面的线性深度。计算雾透过率的一种物理上准确的方法是使雾透过率随距离呈指数增长，从而遵循比尔-朗伯定律(第14.1.2节)。这种效果可以通过使用</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022141243.png" class="" title="image-20211022141243">

<p><strong>其中标量df 是控制雾密度的用户参数。这种传统的大尺度雾是对大气中光散射和吸收的粗略模拟(第14.4.1节)，但它仍然被用于今天的游戏中。参见上图。</strong></p>
<p><strong>这就是硬件雾如何暴露在遗留的OpenGL和DirectX API。对于硬件(如移动设备)上更简单的用例，考虑使用这些模型仍然是值得的。许多当前的游戏依赖于更高级的后期处理，如雾和光散射的大气效果。透视图中的雾的一个问题是深度缓冲值是用非线性方式计算的(第23.7节)。可以将非线性深度缓冲值转换回线性深度zs 使用逆投影矩阵数学。雾可以使用像素着色器作为全屏通道，从而实现更高级的结果，如高度依赖雾或水下着色。</strong></p>
<p><strong>高度雾代表一个单一板的参与媒体与参数化的高度和厚度。对于屏幕上的每个像素，密度和散射光被评估为视图射线在撞击表面之前穿过平板的距离的函数。Wenzel提出了一个封闭形式的解，该解对平板内参与介质的指数衰减进行f评估。这样做的结果是一个平滑的雾过渡附近的板的边缘。这在上图左侧的背景雾中可见。</strong></p>
<p><strong>雾的深度和高度可能有许多变化。cf 的颜色可以是单一的颜色，可以从使用视图向量采样的立方体地图读取，甚至可以是复杂的大气散射的结果，使用逐像素相位函数应用于方向颜色变化。也可以结合depth fd 和高度fh 雾透过率使用f = fdfh 并在一个场景中把两种类型的雾交织在一起。</strong></p>
<p><strong>深度雾和高度雾是大规模的雾效应。人们可能想要渲染更多的局部现象，如分离的雾区域，例如，在洞穴或墓地的几个坟墓周围。椭球或盒子等形状可以用于在需要的地方添加局部雾。这些雾元素使用它们的边界框从后到前渲染。前面的df 和db 在像素着色器中评估每个形状的视图向量的交集。使用容积深度d = max(0, min(zs,db)−df ),如果线性深度zs 代表最近的不透明表面，就有可能计算透射率Tr (第14.1.2节)，覆盖率为α = 1.0−Tr．散射光的量cf 加在上面可以被计算为αcf ．为了从网格中评估更多不同的形状，Oat和Scheuermann给出了一种聪明的单通道方法，计算体积中最近的入口点和最远的出口点。它们节省了表面距离ds，在一个通道的表面，并且1-ds 在另一个频道。通过设置alpha混合模式来保存找到的最小值，在渲染后，第一个通道的值df 最接近第二个通道的db值最大，编码为一维，允许恢复d。</strong></p>
<p><strong>水是一个参与的媒介，因此，展示了相同类型的基于深度的颜色衰减。沿岸水的透光率约为(0.3,0.73,0.63)/ m[261]，因此利用公式14.23可以得到σt =(1.2, 0.31, 0.46)。当使用不透明的表面渲染深色水时，当相机在水面以下时，可以启用雾逻辑，当相机在水面以上时，可以关闭雾逻辑。Wenzel提出了一个更先进的解决方案。如果相机在水下，散射和透光率是综合的，直到固体或水面被击中。如果在水面上，这些积分仅从水面到海床的固体几何形状之间的距离。</strong></p>
<h3 id="Simple-Volumetric-Lighting-简单的体积照明"><a href="#Simple-Volumetric-Lighting-简单的体积照明" class="headerlink" title="Simple Volumetric Lighting 简单的体积照明"></a>Simple Volumetric Lighting 简单的体积照明</h3><p><strong>光散射在参与媒体可能是复杂的评估。值得庆幸的是，在许多情况下，有许多有效的技术可以用来近似这种散射。</strong></p>
<p><strong>获得体积效果的最简单方法是在framebuffer上渲染混合的透明网格。我们将其称为飞溅方法(第13.9节)。要渲染穿过窗户，穿过茂密的森林，或来自聚光灯的光轴，一个解决方案是使用相机对齐的粒子，每个纹理。每个纹理四边形都沿着光轴的方向伸展，同时始终面对着摄像机(圆柱体约束)。</strong></p>
<p><strong>网格飞溅方法的缺点是，积累许多透明网格将增加所需的内存带宽，很可能导致瓶颈，并且面向摄像头的纹理四边形有时可以看到。为了解决这个问题，人们提出了使用闭形式解决光单散射的后处理技术。假设一个均匀的和球形的均匀相位函数，它是可能的积分散射光与正确的透过率沿路径假设一个恒定的介质。结果如下图所示。GLSL着色器代码片段显示了这种技术的一个实现示例:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022142146.png" class="" title="image-20211022142146">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022142022.png" class="" title="image-20211022142022">

<p>使用上面代码片段中的分析集成评估光源的体积光散射。它可以作为一个后期效果，假设均匀介质(左)或粒子，假设它们每个都是一个有深度的体积(右)。(图片由Miles提供<br>Macklin)。</p>
<p><strong>其中rayStart是射线的起始位置，rayDir是射线的归一化方向，rayDistance是沿光线的积分距离，lightPos是光源的位置。Sun等人的解还考虑了散射系数σs．它还描述了漫反射和镜面辐射在朗伯和冯氏表面的反弹应该受到光在击中任何表面之前在非直线路径中散射的影响。为了考虑透过率和相位函数，可以使用更重ALU的溶液[。所有这些模型在它们所做的事情上都是有效的，但不能考虑来自深度地图或异构参与媒体的阴影。</strong></p>
<p><strong>通过一种称为bloom的技术，可以近似地计算屏幕空间中的光散射。模糊framebuffer并将它的一小部分添加到上，会使每个明亮的对象在它周围散发出光辉。这种技术通常用于近似相机镜头中的缺陷，但在某些环境中，它是一种近似值，适用于短距离和无遮挡散射。第12.3节更详细地描述了bloom。</strong></p>
<p><strong>Dobashi等人提出了一种使用一系列平面对体积采样来绘制大尺度大气效应的方法。这些平面垂直于视图方向，并从后到前渲染。Mitchell也提出了相同的方法来渲染聚光灯轴，使用阴影贴图来投射不透明物体的体积阴影。在14.3.1节中详细描述了通过飞溅切片绘制体积的方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211022142544.png" class="" title="image-20211022142544">

<p>使用屏幕空间后期处理渲染的光轴。(图片由Kenny Mitchell提供。)</p>
<p><strong>Mitchell和Rohleder and Jamrozik提出了一种在屏幕空间工作的替代方法;参见上图。它可以用来渲染来自遥远光线(如太阳)的光轴。首先，一个伪明亮物体在远平面的太阳周围渲染为一个清除为黑色的缓冲区，并使用深度缓冲区测试接受非闭塞像素。其次，在图像上应用方向模糊，以泄漏之前积累的太阳辐射向外。可以使用可分离的滤波技术(章节12.1)，通过两个通道，每个使用n个样本，得到与n²相同的模糊结果样本，但渲染速度更快。最后，可以将最后的模糊缓冲添加到场景缓冲中。这项技术是有效的，尽管缺点是只有在屏幕上可见的光源才能投射光轴，但它以很小的成本提供了显著的视觉效果。</strong></p>
<h2 id="General-Volumetric-Rendering-普通的体积渲染"><a href="#General-Volumetric-Rendering-普通的体积渲染" class="headerlink" title="General Volumetric Rendering 普通的体积渲染"></a>General Volumetric Rendering 普通的体积渲染</h2><p><strong>在本节中，我们将介绍更多基于物理的体绘制技术，例如试图表现介质的材料及其与光源的相互作用(第14.1.1节)。一般的体绘制涉及到空间变化的参与媒体，通常使用体素(第13.10节)表示，体光相互作用导致视觉上复杂的散射和遮蔽现象。一个通用的体积渲染解决方案还必须考虑到体积与其他场景元素的正确组成，如不透明或透明表面。不同空间的媒体属性可能是烟雾和火灾模拟的结果，需要在游戏环境中渲染，以及体光和阴影的交互作用。另外，我们可能希望将固体材料表示为半透明体，用于医学可视化等应用。</strong></p>
<h3 id="Volume-Data-Visualization-体积数据可视化"><a href="#Volume-Data-Visualization-体积数据可视化" class="headerlink" title="Volume Data Visualization 体积数据可视化"></a>Volume Data Visualization 体积数据可视化</h3><p><strong>体积数据可视化是一种用于显示和分析体积数据的工具，通常是标量字段。计算机断层扫描(CT)和磁共振成像(MRI)技术可以用来创建临床诊断图像的内部身体结构。一个数据集可以是，比如说，256³ 体素，每个位置保存一个或多个值。这些体素数据可以用来形成三维图像。体素渲染可以显示一个实体模型，或使各种材料(如皮肤和头骨)呈现部分或完全透明。切割面可以用来只显示源数据的一个子卷或部分。除了在医学和石油勘探等不同领域的可视化使用，体积绘制还可以产生逼真的图像。</strong></p>
<p><strong>有许多体素绘制技术。在复杂的照明环境下，可以使用常规路径跟踪或光子映射来可视化体积数据。为了实现实时性能，已经提出了几种成本较低的方法。</strong></p>
<p><strong>对于实体对象，隐式曲面技术可用于将体素转换为多边形曲面，如17.3节所述。对于半透明现象，体积数据集可以通过一组垂直于视图方向的分层等间距切片进行采样。下图显示了其工作原理。也可以用这种方法渲染不透明的表面[797]。在这种情况下，当密度大于某一给定阈值时，考虑固体体积存在，法向n可被计算为密度场的三维梯度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023123528.png" class="" title="image-20211023123528">

<p>一个体块是由一系列平行于视图面的切片来渲染的。一些切片和它们与体积的交集显示在左边。中间显示渲染的结果这片。右边显示的是大量切片被渲染和混合后的结果。(数据由德国Siegen大学Christof Rezk-Salama提供。)</p>
<p><strong>对于半透明数据，可以存储每个体素的颜色和不透明度。为了减少内存占用并使用户能够控制可视化，已经提出了传递函数。第一个解决方案是使用一维传输纹理将体素密度标量映射到颜色和不透明度。然而，这并不允许识别特定的材料转变，例如，人类鼻窦骨到空气或骨到软组织，独立地，用不同的颜色。为了解决这个问题，Kniss等人建议使用基于密度d和密度场梯度长度||▽d||的二维传递函数。变化区域具有高梯度强度。这种方法使得密度转换的着色更有意义。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023123739.png" class="" title="image-20211023123739">

<p>使用一维(左)和二维(右)传递函数评估体积材料和不透明度。在第二种情况下，保持树干的棕色是可能的，而不用覆盖较浅密度的绿色代表叶子。图像底部为传递函数，x轴为密度，y轴为密度场的梯度长度||▽d||。(图片由Joe Michael Kniss提供。)</p>
<p><strong>Ikits等人深入讨论了这项技术和相关问题。Kniss等人扩展了这种方法，取而代之的是根据半角进行切片。切片仍然由后到前渲染，但朝向介于光线和视图方向之间。使用这种方法，可以从光的角度渲染亮度和遮挡，并在视图空间中积累每个切片。当绘制下一个切片时，可以使用切片纹理作为输入，使用光方向的遮挡来评估体积阴影，使用亮度来估计多次散射，即。即光线在到达人眼之前在介质中多次反射。由于前一个切片是根据圆盘上的多个样本进行采样的，因此该技术只能合成圆锥内的前向散射引起的地下现象。最后的图像质量很高。参见下图。Schott等人对这种半角方法进行了扩展，用于评估环境遮挡和景深模糊效果，提高了用户查看体素数据时的深度和体积感知。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023123923.png" class="" title="image-20211023123923">

<p>利用光通过半角切片传播的前向地下散射体渲染。(图片由Ikits等提供。)</p>
<p><strong>如上图所示，半角切片可以呈现高质量的次表面散射。然而，由于光栅化的内存带宽成本必须为每片支付。Tatarchuk和Shopf在着色器中使用射线行进进行医学成像，因此只需支付一次光栅化带宽成本。照明和阴影可以在下一节中描述。</strong></p>
<h3 id="Participating-Media-Rendering-参与媒体渲染"><a href="#Participating-Media-Rendering-参与媒体渲染" class="headerlink" title="Participating Media Rendering 参与媒体渲染"></a>Participating Media Rendering 参与媒体渲染</h3><p><strong>实时应用程序可以通过呈现参与的媒体来描绘更丰富的场景。这些效果变得更需要渲染时，如时间等因素一天，天气或环境的变化，如建筑物的破坏。例如，森林中的雾在中午或黄昏时看起来会有所不同。树与树之间的光柱应适应太阳变化的方向和颜色。光照轴也应该根据树木的运动而动画化。通过爆炸移除一些树木会导致该区域的散射光的变化，因为更少的遮挡物和产生的灰尘。营火、手电筒和其他光源也会在空气中产生散射。在本节中，我们将讨论可以实时模拟这些动态视觉现象的效果的技术。</strong></p>
<p><strong>一些技术专注于绘制从单一源的大规模阴影散射。Yusov深入描述了一种方法。它是基于沿极线散射的采样，极线是指投射到相机图像平面上的单线上的光线。从光线的角度看，深度图用于确定样本是否被阴影笼罩。该算法从摄像机开始执行射线行军。沿着光线的最小/最大层次用于跳过空白空间，而只在深度不连续处，即它实际上需要准确地评估体积阴影。不是沿着极线取样这些不连续，而是可以在视图空间中通过渲染一个由光空间深度图生成的网格来实现。在视图空间中，只需要正面和背面之间的体积来评估最终散射亮度。为此，内散射的计算是通过在视图中添加从正面产生的散射辐亮度，并减去从背面产生的散射辐亮度。</strong></p>
<p><strong>这两种方法都能有效地再现由不透明表面遮挡造成的阴影单次散射事件。然而，两者都不能代表异质的参与介质，因为它们都假设介质是一种恒定的材料。此外，这些技术不能考虑来自非不透明表面的体积阴影，例如来自参与介质的自阴影或来自粒子的透明阴影(章节13.8)。它们仍然在游戏中发挥着重要作用，因为它们可以以高分辨率呈现，而且速度很快，这多亏了空格跳过技术。</strong></p>
<p><strong>溅射法已被提出用于处理更普遍的均匀介质的情况，沿着射线对体积材料进行取样。Crane等人在不考虑任何输入照明的情况下，使用飞溅来渲染烟、火和水，这些都是流体模拟的结果。在烟雾和火灾的情况下，在每个像素处产生一条光线，光线穿过体积，沿着其长度的规则间隔从材料中收集颜色和遮挡信息。在水的情况下，一旦射线的第一个命中点与水面相遇，体积采样就终止了。表面法线被评估为密度场梯度在每个样品位置。为保证水面光滑，采用三次插值法过滤密度值。下图显示了使用这些技术的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023130039.png" class="" title="image-20211023130039">

<p>使用体积渲染技术结合GPU上的流体模拟来渲染雾和水。(左图来自《地狱之门:伦敦》，由旗舰工作室提供;右图由NVIDIA公司提供。)</p>
<p><strong>考虑到太阳，连同点光源和聚光灯，Valient将边界体集合渲染成一个半分辨率缓冲区，在那里每个光源的散射都应该发生。每个光体都以每像素随机偏移应用于光线行进的起始位置进行光线行进。这样做增加了一点噪声，它的优点是消除由恒定步进产生的带状伪影。在每一帧中使用不同的噪声值是一种隐藏伪影的方法。在对前一帧进行重投影并与当前帧混合后，噪声将被平均从而消失。通过将平面粒子体素化成三维纹理，以八分之一的屏幕分辨率映射到摄像机视锥上，来呈现异构媒体。这个体积在光线行进时作为材料密度使用。半分辨率散射结果可以在全分辨率主缓冲上进行合成，首先使用双边高斯模糊，然后使用双边上采样滤波器，考虑到像素之间的深度差异。当深度增量与中心像素相比过高时，样本将被丢弃。这种高斯模糊在数学上是不可分离的(第12.1节)，但它在实践中工作得很好。这种算法的复杂性取决于屏幕上的光体数量，作为它们的像素覆盖的函数。</strong></p>
<p><strong>这种方法通过使用蓝色噪声得到了扩展，蓝色噪声能够更好地在一帧像素上产生均匀分布的随机值。这样做的结果是更平滑的视觉时，上采样和混合样本空间与双边过滤器。用四个随机样本混合在一起，也可以实现半分辨率缓冲的上采样。结果仍然是噪声，但因为它给出了全分辨率逐像素噪声，它可以很容易地通过时间反锯齿后处理来解决(章节5.4)。</strong></p>
<p><strong>所有这些方法的缺点是，深度有序的体积元素与任何其他透明表面将永远不会给出视觉上正确的结果顺序，例如，大型非凸透明网格或大型粒子效果。当涉及到在透明表面上应用体光时，所有这些算法都需要一些特殊的处理，例如在体素中包含内散射和透射率的体积。那么，为什么不用基于体素的表示法开始时，不仅要表示空间上不同的参与介质特性，还要表示光散射和透过率所产生的辐亮度分布?这些技术在电影工业中使用已久。</strong></p>
<p><strong>Wronski提出了一种方法，将场景中来自太阳和光线的散射辐射体素化成三维体纹理V0 映射到视图剪辑空间上。对每个体素中心的世界空间位置进行散射辐亮度评估，其中体块的x轴和y轴对应于屏幕坐标，而z轴则映射到摄像机截锥深度上。这个体积纹理的分辨率比最终图像低得多。这种技术的典型实现使用x轴和y轴上的体素分辨率为屏幕分辨率的八分之一。沿着z坐标细分取决于质量和性能的权衡，64个切片是一个典型的选择。这个纹理包含散射的RGB亮度Lscat以及alpha消光σt 。从这个输入数据，最终散射体积Vf 是通过从近到远的迭代每个片生成的</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023130340.png" class="" title="image-20211023130340">

<p><strong>其中L′scat= V0[x, y, z−1]rgb，T ′r= V0[x, y, z−1]a和 Trslice= e^(−σtds)。这个更新根据世界空间切片深度ds从先前的切片z−1数据到切片z。这样做会导致Vf 包含到达观察者的散射辐射和每个体素背景上的透射率。在上式中，注意Lscatin受的影响只有先前切片的透射率T ′r。这种行为是错误的，因为Lscatin在也应受到由σt 在当前片内。</strong></p>
<p><strong>Hillaire讨论了这个问题。他提出了Lscatin积分的解析解对于恒定消光σt 对于给定的深度:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023130842.png" class="" title="image-20211023130842">

<p><strong>最终像素亮度Lo 亮度Ls 的不透明表面将由Lscat 和Tr 从Vf ，采样的裁剪空间坐标为Lo = TrLs + Lscat。因为Vf 是粗糙的，它是受混叠从相机运动和高频率的强光或阴影。前一帧Vf 可以重新投影并与新的Vf 结合使用指数移动平均。</strong></p>
<p><strong>在这个框架之上，Hillaire提出了一种基于物理的方法来定义参与媒体材料，如下:散射σs、吸收σa，相位函数参数g，发射辐亮度Le。这个材质被映射到摄像机的视锥，并存储到参与的媒体材质体积纹理Vpm中，是储存不透明表面材料的G-buffer的三维版本(章节20.1)。Hillaire指出，仅考虑单次散射，尽管体素离散化，但使用这种基于物理的材料表示可以获得接近路径跟踪的视觉效果。类似于网格，位于世界中的参与媒体体素化为Vpm (见下图)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023131109.png" class="" title="image-20211023131109">

<p>艺术家将参与的媒体体量放置在一个关卡中，并体素化到摄像机截锥空间中。左边是一个三维纹理，形状是在这个例子中，球体被映射到体积上。纹理定义了体积的外观，类似于三角形上的纹理。在右边，这个体积通过考虑它的世界变换而被体素化到摄像机的视锥中。计算着色器将贡献累加到体积所包含的每个体素中。得到的材料可以用来评估每个体素中的光散射相互作用。注意，当映射到相机剪辑空间时，体素呈小frusta的形状，被称为froxels。</p>
<p><strong>在每一个体量中，都定义了单一的材料，并添加了变化，谢谢到密度从一个三维输入纹理采样，导致异构的参与媒体。结果如下图所示。在Unreal Engine中也实现了同样的方法，但不是使用盒子体积作为参与媒体的来源，而是使用粒子，假设一个球形体积而不是一个盒子。也可以使用稀疏结构来表示材料体纹理，使用每个体素为空或指向包含参与媒体材料数据的细粒度体块的最上面的体块。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023131250.png" class="" title="image-20211023131250">

<p>没有(上)而有(下)体积照明和阴影渲染的场景。场景中的每一盏灯都与参与的媒体相互作用。每个光的亮度、IES剖面和阴影图被用来积累其散射光的贡献。(图片由Frostbite,§c2018年Electronic Arts Inc.)</p>
<p><strong>基于摄像机截锥体积的方法的唯一缺点是，为了在功能较弱的平台上达到可接受的性能(并使用合理的内存)，需要较低的屏幕空间分辨率。这就是前面解释的飞溅方法的优点，因为它们产生了清晰的视觉细节。如前所述，溅射需要更多的内存带宽，并提供更少的统一解决方案，例如，它很难应用于任何其他透明表面，而没有分类问题或有参与的媒体在自身上投下体积阴影。</strong></p>
<p><strong>不仅是直接的光，而且已经反射或散射的光也可以通过介质散射。类似于Wronski，Unreal Engine使其能够烘焙体积光地图，存储在体积的辐照度，并使其散射回媒体时，体素化的视图体积。为了实现参与媒体的动态全局照明，也可以依赖光的传播体积。</strong></p>
<p><strong>一个重要的特点是体积阴影的使用。如果没有它们，在浓雾弥漫的场景中，最终的图像看起来会过于明亮和平坦。此外，阴影是一个重要的视觉线索。它们帮助观众感知深度和体积，产生更真实的图像，并可以导致更好的浸没式。Hillaire提出了一个统一的解决方案来实现体积阴影。根据clipmap分布方案，参与的介质体积和粒子被体素化为围绕相机级联的三个体积，称为消光体积。这些包含消光σt计算Tr 所需的值并代表了一个统一的数据源来采样，以便使用不透明度阴影图来实现体积阴影。参见下图。这种解决方案使粒子和参与的媒体能够自我阴影，并相互投射阴影，以及场景中任何其他不透明和透明的元素。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023131531.png" class="" title="image-20211023131531">

<p>在顶部，场景渲染没有(左)和(右)体积阴影。在底部，体素化粒子消光(左)和体阴影(右)的调试视图。更环保的意味着透射率更低[742]。(图片由Frostbite提供，§c2018年Electronic Arts Inc.)</p>
<p><strong>体积阴影可以用不透明度阴影贴图来表示。然而，如果需要高分辨率来捕捉细节，我们使用体积纹理很快就会成为一个限制。因此，提出了替代表示Tr 的方法更有效，例如使用函数的正交基，如傅立叶或离散余弦变换。详情见第7.8节。</strong></p>
<h2 id="Sky-Rendering-天空渲染"><a href="#Sky-Rendering-天空渲染" class="headerlink" title="Sky Rendering 天空渲染"></a>Sky Rendering 天空渲染</h2><p><strong>渲染一个世界本质上需要一个星球的天空，大气效果和云。我们所谓的地球上的蓝天，就是阳光在大气的参与介质中散射的结果。为什么白天的天空是蓝色的，太阳在地平线时是红色的，请参见14.1.3节。大气也是一个关键的视觉线索，因为它的颜色与太阳的方向有关，而太阳的方向又与一天中的时间有关。大气(有时)雾蒙蒙的外观有助于观众感知场景中元素的相对距离、位置和大小。因此，准确地渲染这些组件非常重要，因为越来越多的游戏和其他应用都需要这些组件，这些组件具有动态的一天时间，影响云形状的天气变化，以及用于探索、驾驶甚至飞越的大型开放世界。</strong></p>
<h3 id="Sky-and-Aerial-Perspective-天空和空中透视"><a href="#Sky-and-Aerial-Perspective-天空和空中透视" class="headerlink" title="Sky and Aerial Perspective 天空和空中透视"></a>Sky and Aerial Perspective 天空和空中透视</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023132131.png" class="" title="image-20211023132131">

<p>两种不同类型的大气光散射:顶部的瑞利散射和底部的常规瑞利散射的米氏散射。从左到右:密度为0，规则密度如[203]所述，并夸大了密度。(图片由Frostbite提供，c2018年电子艺界公司[743])。</p>
<p><strong>为了渲染大气效果，我们需要考虑两个主要组件，如上图所示。首先，我们模拟阳光与空气粒子的相互作用，产生波长相关的瑞利散射。这将导致天空的颜色和薄雾，也称为空中透视。其次，我们需要研究集中在地面附近的大颗粒对阳光的影响。这些物质的浓度大颗粒取决于天气条件和污染等因素。大粒子引起波长无关的米氏散射。这种现象会在太阳周围产生明亮的光晕，特别是在粒子浓度较大的情况下。</strong></p>
<p><strong>第一个基于物理的大气模型从太空渲染了地球及其大气，模拟了单次散射。使用O ‘Neil提出的方法也可以得到类似的结果。地球可以在一个单通道着色器中使用光线行进从地面渲染到太空。当渲染天空穹顶时，每个顶点都要进行昂贵的射线行军来整合Mie和瑞利散射。然而，视觉高频相位函数是在像素着色器中评估的。这使得外观平滑，避免了由于插值而暴露天空的几何形状。通过将散射存储在纹理中并将评估分布在几帧上，接受更新延迟以获得更好的性能，也可以获得相同的结果。</strong></p>
<p><strong>分析技术使用测量到的天空辐射的拟合数学模型，或使用大气中光散射的昂贵路径跟踪生成的参考图像。与参与的媒体材料相比，输入参数集通常是有限的。例如，浊度表示导致Mie散射的粒子的贡献，而不是σs 和σt 系数。Preetham等人提出的这种模型利用浑浊度和太阳高度来评估任何方向的天空亮度。通过增加对光谱输出的支持、对太阳周围散射辐射更好的方向性以及新的地面反照率输入参数，它得到了改进。分析天空模型的评估速度很快。然而，它们仅限于地面视图，大气参数不能被改变来模拟地外行星或实现特定的艺术驱动的视觉效果。</strong></p>
<p><strong>渲染天空的另一种方法是假设地球是完美的球形，周围有一层由不同的参与媒体组成的大气层。Bruneton和Neyret以及Hillaire对大气成分作了广泛的描述。利用这些事实，可以使用预先计算的表格来存储根据当前视图高度r(视图向量角相对于天顶的余弦)的透射率和散射率µv，即太阳方向角相对于天顶的余弦µs，以及视矢量角相对于太阳方向在方位角平面ν的余弦值。例如，从视点到大气边界的透射率可以用两个参量r和µv来参数化．在预计算步骤中，透光率可以集成到大气中，并存储在一个二维查找表(LUT)纹理Tlut 中可以在运行时使用相同的参数进行采样。这个纹理可以用于应用大气透过率的天空元素，如太阳，星星，或其他天体。</strong></p>
<p><strong>考虑到散射，Bruneton和Neyret描述了一种将其存储在四维LUT Slut 中的方法由前一段的所有参数参数化。它们还提供了一种方法来计算n阶的多次散射(i)计算单次散射表Slut， (ii)使用Slut^(n-1 评估Slut^n， (iii)将结果添加到Slut中．做(ii)和(iii) n-1次。Bruneton和Neyret提供了该过程的更多细节以及源代码。结果示例见下图。Bruneton和Neyret的参数化有时会在视界上显示出视觉伪影。Yusov提出了一个改进的改造方案。也可以通过忽略ν来使用唯一的三维LUT。使用这种方案，地球不会在大气中投下阴影，这是一个可以接受的权衡。其优点是这个LUT将更小，更新和取样的成本更低。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023132829.png" class="" title="image-20211023132829">

<p>使用查找表从地面(左)和从空间(右)实时渲染地球大气。(图片由Bruneton和Neyret提供。)</p>
<p><strong>这种最后的三维LUT方法被许多Electronic Arts Frostbite即时游戏所使用，如Need for Speed, Mirror’s Edge Catalyst, FIFA。在这种情况下，艺术家可以驱动物理基础大气参数，以达到目标天空视觉，甚至模拟地外大气。参见下图。当大气参数发生变化时，必须重新计算LUT。为了更有效地更新这些LUTs，还可以使用一个函数来近似大气中材料的积分，而不是射线穿过它[。通过临时分配LUTs的评估和多重散射，更新LUTs的成本可以摊销到原来的6%。这是只需更新Slut^n的一个子部分即可实现对于给定的n阶散射，则插入最后两个已解决的LUTs，接受一些延迟帧。作为另一种优化，为了避免对每个像素的不同LUTs进行多次采样，Mie和Rayleigh散射被烘焙在相机的锥视图映射的低分辨率体积纹理的体素中。为了在太阳周围产生平滑的散射晕，在像素着色器中评估视觉高频相位函数。使用这种类型的体纹理也允许对场景中任何透明物体的每个顶点应用空中透视。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023133219.png" class="" title="image-20211023133219">

<p>使用完全参数化模型进行实时渲染，可以模拟地球的大气层(顶部)和其他行星的大气层，比如火星的蓝色日落(底部)。(顶部图片由Bruneton和Neyret提供，底部图片由Frostbite提供，2018年电子艺界公司。)</p>
<h3 id="Clouds-云"><a href="#Clouds-云" class="headerlink" title="Clouds 云"></a>Clouds 云</h3><p><strong>云是天空中复杂的元素。当代表即将到来的风暴时，它们看起来可能是危险的，也可能是谨慎的、史诗般的、纤细的或巨大的。云变化缓慢，其大尺度形状和小尺度细节都随着时间的推移而演变。带有天气和时间变化的大型开放世界游戏更复杂，需要动态云渲染解决方案。根据目标性能和视觉质量，可以使用不同的技术。</strong></p>
<p><strong>云是由水滴组成的，具有高散射系数和复杂的相位函数，结果是一个特定的外观。如第14.1节所述，它们经常使用参与介质进行模拟，并且它们的材料已经被测量为具有高的单次散射反照率ρ = 1和消光系数σt 在层云(低空水平云层)的范围[0.04,0.06]和积云(孤立的低空棉花状蓬松云)的范围[0.05,0.12]。参见下图。假设ρ接近于1，σs =σt 可以假定。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023133510.png" class="" title="image-20211023133510">

<p>地球上不同类型的云。(图片由Valentin de Bruyn提供。)</p>
<p><strong>云渲染的一个经典方法是使用alpha混合在天空上合成一个全景纹理。这在渲染静态天空时很方便。Guerrette提出了一种视觉流动技术，它给出了云在天空中运动的错觉，受全球风向的影响。这是一种有效的方法，改进了全景云纹理静态集的使用。然而，它将不能表示云形状和光照的任何变化。</strong></p>
<h4 id="Clouds-as-Particles-云作为粒子"><a href="#Clouds-as-Particles-云作为粒子" class="headerlink" title="Clouds as Particles 云作为粒子"></a>Clouds as Particles 云作为粒子</h4><p><strong>Harris将云渲染成粒子和视点替用器的体积。参见第557页第13.6.2节和图13.9。</strong></p>
<p><strong>另一种基于粒子的云绘制方法由Yusov提出。他使用被称为体积粒子的渲染原语。每一个都由一个四维LUT表示，允许检索散射光和透光率在面向视图的四粒子上作为太阳光线和视图方向的函数。参见下图。这种方法非常适合渲染层积云。参见上图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023133722.png" class="" title="image-20211023133722">

<p>以粒子体积呈现的云。(图片由Egor Yusov提供)</p>
<p><strong>当将云渲染为粒子时，可以看到离散化和弹出伪影，特别是当围绕云旋转时。这些问题可以通过使用体积感知混合来避免。这种能力是通过使用一种称为光栅化顺序视图的GPU特性实现的(章节3.8)。体积感知混合使每个原语的资源上的像素着色操作同步，允许震撼性自定义混合操作。最接近的n个粒子的深度层以与渲染目标相同的分辨率保存在一个缓冲区中。这缓冲区被读取并用于混合当前渲染的粒子，通过考虑交集深度，然后最后再次写入下一个要渲染的粒子。结果如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023133751.png" class="" title="image-20211023133751">

<p>在左边，云粒子以通常的方式呈现。在右边，粒子渲染与体积感知混合。(图片由Egor Yusov提供。)</p>
<h4 id="Clouds-as-Participating-Media-云作为参与媒体"><a href="#Clouds-as-Participating-Media-云作为参与媒体" class="headerlink" title="Clouds as Participating Media 云作为参与媒体"></a>Clouds as Participating Media 云作为参与媒体</h4><p><strong>Bouthors等人认为云是孤立的元素，他们将云分为两部分:一是网格，显示其整体形状;二是超纹理，在网格表面下添加高频细节，使其在云内部达到一定深度。使用这种表示方法，云的边缘可以被精细地射线行进以收集细节，而云的内部可以被认为是均匀的。当光线在云结构中行进时，融合辐亮度，并根据散射顺序使用不同的算法收集散射辐亮度。使用14.1节中描述的解析方法对单次散射进行积分。利用位于云表面的圆盘形光收集器的离线预计算转换表，可以加速多重散射评估。最终的结果具有很高的视觉质量，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023134025.png" class="" title="image-20211023134025">

<p>使用网格和超纹理渲染的云。(图片由Bouthors等提供。)</p>
<p><strong>与其将云渲染为孤立的元素，还可以将它们建模为大气中参与介质的一层。Schneider和Vos提出了一种利用射线行进的方法来渲染云。只需要几个参数，就可以在动态的光照条件下渲染复杂的、动画的和详细的云形状，如下图所示。层是使用两级程序噪声构建。第一层给出了云的基本形状。第二层通过侵蚀这个形状来增加细节。在这种情况下，据报道，Perlin和Worley噪声的混合是花椰菜状积云和类似云的良好代表。生成这些纹理的源代码和工具已经公开共享。照明是通过利用沿视图射线分布在云层中的样本来整合来自太阳的散射光来实现的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023134130.png" class="" title="image-20211023134130">

<p>使用Perlin-Worley噪声和动态体光照和阴影的动态云渲染。(Results by Schneider and Vos，版权所有§c 2017 Guerrilla Games。)</p>
<p><strong>体积阴影可以通过评估层内几个样品的透光率来实现，并以二次射线行进的方式对太阳进行测试。对于这些阴影样本，可以对噪声纹理的较低的mipmap级别进行采样，以获得更好的性能，并在只使用少量样本的情况下平滑可见的伪影。避免二次射线在每个样本中移动的另一种方法是使用许多可用的技术之一(第13.8节)，在每帧纹理中编码一次来自太阳的透射曲线。例如，游戏《最终幻想XV》使用了透射函数映射。</strong></p>
<p><strong>如果我们想要捕捉每一个小细节，用光线行进来渲染高分辨率的云会变得非常昂贵。为了获得更好的性能，可以用低分辨率渲染云。一种方法是在每个4X4块中只更新一个像素，然后重新投影之前的帧数据来填充剩余的帧数据。Hillaire提出了一种变化，即始终以固定的较低分辨率呈现，并在视图射线行进起始位置添加噪声。前一帧的结果可以通过指数移动平均重新投影，并与新帧相结合。这种方法渲染的分辨率较低，但收敛速度更快。</strong></p>
<p><strong>云的相位函数是复杂的。在这里，我们提出了两种可用于实时评估它们的方法。可以将函数编码为纹理，并基于θ对其进行采样。如果这样做需要太多的内存带宽，可以通过结合第14.1.4节中的两个Henyey-Greenstein相位函数来近似该函数</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023134317.png" class="" title="image-20211023134317">

<p><strong>其中两个主要散射偏心g0 和g1，以及混合因子可以由一位艺术家创作。这在表示主的时候是很重要的向前和向后散射方向，当远离或朝向光源(如太阳或月亮)时，揭示云中的细节。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023134412.png" class="" title="image-20211023134412">

<p>如Hillaire所述，使用基于物理的参与媒体表示的动态照明和阴影，使用光线行进的云层渲染云。来自BioWare的S¨oren Hesse(上)和Ben McGrath(下)，来自2018EAInc .)</p>
<p><strong>有不同的方法来近似云中周围光线的散射光。一个简单的解决方案是使用一个单一的亮度输入，统一地从天空渲染到一个立方体贴图纹理。一个自下而上的，从暗到光的梯度也可以用来缩放环境光线，以接近云层本身的遮挡。也可以将输入亮度分离为底部和顶部，例如地面和天空。假设介质密度恒定，则环境散射可以解析地对两种贡献进行积分云层。</strong></p>
<h4 id="Multiple-Scattering-Approximation-多次散射近似"><a href="#Multiple-Scattering-Approximation-多次散射近似" class="headerlink" title="Multiple Scattering Approximation 多次散射近似"></a>Multiple Scattering Approximation 多次散射近似</h4><p><strong>云的明亮和白色的外观是光在其中散射多次的结果。如果没有多次散射，厚厚的云层的边缘大部分会被照亮，而其他地方则会显得黑暗。多重散射是使云看起来不烟雾或阴暗的关键组成部分。用路径跟踪来计算多次散射是非常昂贵的。Wreninge提出了一种近似射线行进时这种现象的方法。它集成了o倍频的散射，并将它们相加为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023135640.png" class="" title="image-20211023135640">

<p><strong>当求Lscat时，要做以下替换(例如,使用σ′s而不是σs):σ′s=σsa^n, σ′e=σeb^n和p′(θ)= p(θc^n)，其中a、b、c为在[0,1]中的用户控制参数将让光穿透参与媒体。当这些值接近0时，云看起来更柔和。为了确保这个技术是节能的，当评估Lmultiscat(x, v)时，必须保证a≤b。否则，更多的光会散射，因为方程σt =σa +σs 将不会被遵守，如σs 会比σt大．这个解决方案的优点是，当光线行进时，它可以在飞行中集成每个不同八度的散射光。视觉效果的改善见下图。缺点是，当光线可以向任何方向散射时，它在复杂的多重散射行为上做得很差。然而，云的外观得到了改善，这种方法允许照明艺术家通过一些参数轻松地控制视觉效果，并表达他们的视觉效果，这得益于更广泛的可实现的结果。通过这种方法，光线可以穿透介质，揭示更多的内部细节。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023140030.png" class="" title="image-20211023140030">

<p>使用公式14.18渲染的云作为多次散射的近似。从左到右，n设为1，2，3。这使阳光能穿透云层可信的时尚。(图片由Frostbite提供，§c电子艺界公司.)</p>
<h4 id="Clouds-and-Atmosphere-Interactions-云与大气的相互作用"><a href="#Clouds-and-Atmosphere-Interactions-云与大气的相互作用" class="headerlink" title="Clouds and Atmosphere Interactions 云与大气的相互作用"></a>Clouds and Atmosphere Interactions 云与大气的相互作用</h4><p><strong>当渲染一个有云的场景时，为了视觉上的一致性，考虑与大气散射的交互是很重要的。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211023140253.png" class="" title="image-20211023140253">

<p>完全覆盖天空的云被考虑到大气。左:没有大气散射应用于云，导致不连贯的视觉效果。中:有大气散射，但没有西晒时环境显得太亮。右图:云层遮蔽了天空，从而影响了光在大气中的散射从而产生连贯的视觉效果。(图片由Frostbite提供，§c电子艺界公司.)</p>
<p><strong>由于云是大尺度的元素，应该对其应用大气散射。可以对第14.4.1节中提出的大气散射进行评估对于通过云层采集的每个样本，但这样做很快就会变得昂贵。相反，可以根据代表平均云层深度和透光率的单一深度对云应用大气散射。</strong></p>
<p><strong>如果增加云层覆盖率来模拟下雨的天气，云层下面的阳光在大气中的散射应该减少。只有穿过云层的光线才会散射到云层下的大气中。可以通过减少天空的光照对空中透视的贡献，并将散射光添加回大气中来修改光照。可视的改进如上图所示。</strong></p>
<p><strong>综上所述，云渲染可以通过先进的基于物理的材料表示和光照来实现。逼真的云形状和细节可以通过使用程序噪声来实现。最后，如本节所述，为了获得连贯的视觉效果，记住全局也很重要，例如云与天空的相互作用。</strong></p>
<h2 id="Translucent-Surfaces-半透明表面"><a href="#Translucent-Surfaces-半透明表面" class="headerlink" title="Translucent Surfaces 半透明表面"></a>Translucent Surfaces 半透明表面</h2><p><strong>半透明表面通常是指具有高吸收率和低散射系数的材料。这些材料包括玻璃杯、水或592页图14.2所示的葡萄酒。此外，本节还将讨论具有粗糙表面的半透明玻璃。这些主题在许多出版物中也有详细介绍。</strong></p>
<h3 id="Coverage-and-Transmittance-覆盖和透光率"><a href="#Coverage-and-Transmittance-覆盖和透光率" class="headerlink" title="Coverage and Transmittance 覆盖和透光率"></a>Coverage and Transmittance 覆盖和透光率</h3><p><strong>正如第5.5节所讨论的，透明表面可以被视为具有以α为代表的覆盖层，例如，不透明的织物或组织纤维隐藏了其背后部分的百分比。对于玻璃和其他材料，我们想要计算透明度，在固体体积中，每一种波长的百分比都可以通过，作为背景的滤光片，作为透射率Tr的函数14.1.2(部分)。输出颜色为co，表面辐射度cs，底色为cb，透明度即覆盖表面的混合操作是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024134514.png" class="" title="image-20211024134514">

<p><strong>在半透明表面的情况下，混合操作将是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024134616.png" class="" title="image-20211024134616">

<p><strong>其中cs 包含固体表面的镜面反射，即玻璃或凝胶。请注意,Tr 是一个三值透射率色向量。要实现彩色半透明，可以使用任何现代图形API的双源颜色混合特性，以指定这两种输出颜色与目标缓冲色cb混合．Drobot介绍了不同的混合操作，可以使用取决于是否，对于一个给定的表面，反射和透光率是有色与否。</strong></p>
<p><strong>在一般情况下，可以使用共同的混合操作来同时指定覆盖和半透明。在本例中使用的混合函数是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024134806.png" class="" title="image-20211024134806">

<p><strong>当厚度变化时，透射光量可由式14.3计算，可简化为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024134835.png" class="" title="image-20211024134835">

<p><strong>d是通过物质体积的距离。物理消光参数σt 表示光通过介质时衰减的速率。对于艺术家的直观创作，Bavoil设置了目标颜色tc 为某一给定距离d处的透射率，则消光σt 可以恢复为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024135159.png" class="" title="image-20211024135159">

<p><strong>例如，以目标透射率为颜色tc =(0.3, 0.7, 0.1)和距离d = 4.0米，我们有</strong></p>
 <img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024135307.png" class="" title="image-20211024135307">

<p><strong>注意，透光率为0需要作为特殊情况处理。一种解决方法是从Tr的每个分量中减去一个小的值，例如0.000001．滤色效果如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024135434.png" class="" title="image-20211024135434">

<p>通过多层网格的不同吸收因子的半透明。(图片由Louis Bavoil提供。)</p>
<p><strong>在一个空的壳网格的情况下，其表面由一薄层半透明材料组成，背景颜色应该被遮挡作为一个功能光在介质中传播的路径长度d。因此，沿着它的法线或切线观看表面将导致不同数量的背景遮挡作为其厚度t的函数，因为路径长度随角度而变化。Drobot提出了这样一种方法，其中透过率Tr 评估是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024135554.png" class="" title="image-20211024135554">

<p><strong>下图显示了结果。有关薄膜和多层表面的更多细节，请参阅第9.11.2节。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024135710.png" class="" title="image-20211024135710">

<p>彩色透射率是根据视场射线v在厚度为t的透明表面上移动的距离d计算出来的(右图由动视出版公司提供，2018年)。</p>
<p><strong>以固体半透明网格为例，计算光线穿过传输介质的实际距离有很多方法。一种常见的方法是首先渲染视图射线离开体积的表面。这个表面可能是水晶球的背面，也可能是海底。也就是水的尽头)。存储该表面的深度或位置。然后渲染体积的表面。在着色器中访问存储的出口深度，并计算它与当前像素表面之间的距离。然后用这个距离计算应用在背景上的透光率。</strong></p>
<p><strong>如果保证体积是封闭的和凸的，即每个像素有一个入口点和一个出口点，就像水晶球一样。我们的海床例子也适用，因为一旦我们离开水，我们会遇到一个不透明的表面，所以进一步的透光不会发生。对于更精细的模型，例如玻璃雕塑或其他有凹孔的物体，两个或更多独立的跨度可以吸收射入的光线。使用深度剥离，如在第5.5节中讨论的，我们可以以精确的前后顺序渲染体积表面。当每个正面被渲染时，通过体积的距离被计算并用于计算透光率。依次应用每一种方法就可得到适当的最终透过率。注意，如果所有卷都是由如果表面没有反射成分，则同一材料在相同浓度下的透射率可以在最后用求和的距离计算一次。在最近的GPUs上，也可以使用A-buffer或K-buffer方法直接在单次传递中存储对象片段，以提高效率。如上上图所示为多层透光率的例子。</strong></p>
<p><strong>在大规模海水的情况下，场景深度缓冲器可以直接作为背面海床的表示。当渲染透明表面时，必须考虑菲涅尔效应，如第9.5节所述。大多数发射介质的折射率都明显高于空气的折射率。在反光角度，所有的光都会从界面反射回来，没有一个会被传送出去。下图显示了这种效果，当直接往水中看时，水下的物体是可见的，但往更远的地方看，以掠射的角度看，水面基本上隐藏了波浪下面的东西。有几篇文章解释了处理大面积水体的反射、吸收和折射。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024135906.png" class="" title="image-20211024135906">

<p>考虑了透光率和反射效应的水渲染。往下看，因为透光率很高，所以我们可以看到水是浅蓝色的。在地平线附近，由于透光率较低(因为光线必须传播很远)，海底变得不那么可见<br>由于菲涅耳效应，反射以牺牲透射为代价而增加。(图片来自Crytek公司的《孤岛危机》)</p>
<h3 id="Refraction-折射"><a href="#Refraction-折射" class="headerlink" title="Refraction 折射"></a>Refraction 折射</h3><p><strong>对于透光率，我们假设入射光直接来自网格体之外的直线。这是一个合理的假设，当网格的前表面和后表面是平行的，厚度不是很大，例如，窗格的玻璃。对于其他透明介质，折射率起着重要的作用。斯涅尔定律描述了当网格表面遇到时光线如何改变方向，描述在第9.5节。</strong></p>
<p><strong>由于能量守恒，任何未被反射的光都被透射，因此透射光通量与入射光通量的比例为1-f，其中f是反射光的量。然而，透射与入射辐亮度的比例是不同的。由于入射光和透射光的投影面积和立体角不同，所以辐亮度关系为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024143843.png" class="" title="image-20211024143843">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024144043.png" class="" title="image-20211024144043">

<p>折射和透射亮度与入射角θi 的关系透射角θt。</p>
<p><strong>这种行为如上图所示。斯涅尔定律结合上式得到了透射辐亮度的不同形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024144614.png" class="" title="image-20211024144614">

<p><strong>Bec提出了一种计算折射矢量的有效方法。为了便于阅读(因为在斯涅尔公式中n通常被用来表示折射率)，我们定义N为表面法线，l为光线方向:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024144717.png" class="" title="image-20211024144717">

<p><strong>其中n = n1/ n2 是相对折射率，和</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024144827.png" class="" title="image-20211024144827">

<p><strong>得到的折射矢量t被归一化返回。水的折射率约为1.33，玻璃的折射率一般在1.5左右，空气的折射率有效地为1.0。</strong></p>
<p><strong>折射率随波长而变化。也就是说，透明的介质会使每种颜色的光以不同的角度弯曲。这种现象被称为色散，它解释了为什么棱镜将白光扩散成彩虹色的光锥，以及为什么会出现彩虹。色散会引起透镜的问题，称为色差。在摄影中，这种现象被称为紫色边缘，在日光下沿着对比度高的边缘可以特别明显。在计算机图形学中，我们通常忽略这一效应，因为它通常是一个要避免的人工产物。为了正确模拟这种效果，需要进行额外的计算，因为进入透明表面的每一条光线都会生成一组必须被跟踪的光线。因此，通常使用单折射光线。值得注意的是，一些虚拟现实渲染器应用反色差变换，以补偿头戴式的镜头。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024145238.png" class="" title="image-20211024145238">

<p>左:立方体环境地图的玻璃天使折射，地图本身用作天空盒背景。右图:带有色差的玻璃球的反射和折射。(左图来自three.js示例webgl materials cube map refraction，来自Stanford 3D扫描库的Lucy模型，由Humus纹理。右图由Lee Stemkoski提供)</p>
<p><strong>给人一种折射的印象的一般方法是生成一个立方体的环境从折射物体的位置映射(EM)。当这个物体被渲染时，可以通过计算前表面的折射方向来访问EM。上图显示了一个示例。Sousa提出了一种屏幕空间方法，而不是使用EM。首先，场景像往常一样被渲染，没有任何折射物体进入场景纹理s。其次，折射物体被渲染到最初被清除为1的s的alpha通道中。如果像素通过深度测试，则写入一个值0。最后，折射物体被完全渲染，并在像素着色器中根据屏幕上的像素位置采样，扰动偏移来自，例如，缩放表面的法切线xyz分量，模拟折射。在这种情况下，只有当α = 0时，才考虑扰动样本的颜色。这个测试是为了避免使用来自折射物体前面表面的样品，从而使它们的颜色被拉进来，就像它们在后面一样。注意，不需要设置α = 0，场景深度图可以用来比较像素着色器深度与受扰动的场景样本深度。如果中心像素距离较远，则偏移样本距离较近;然后它被忽略并被常规场景样本代替，就好像没有折射一样。</strong></p>
<p><strong>这些技术给人以折射的印象，但与物理现实几乎没有相似之处。当光线进入透明物体时，它会被重定向，但是当光线应该离开物体时，它不会第二次弯曲。这个退出接口永远不起作用。这个缺陷有时并不重要，因为人类的眼睛会原谅正确的外观。</strong></p>
<p><strong>许多游戏都通过一个单层来突出折射。对于粗糙的折射表面，根据材料的粗糙度对背景进行模糊处理，以模拟由微基因组法向分布引起的折射光线方向的扩散。在游戏《毁灭战士》(2016)中，场景首先像往常一样渲染。然后将其降采样到一半分辨率，并进一步降至四个mipmap级别。根据模拟GGX BRDF波瓣的高斯模糊对每个mipmap级别进行下采样。在最后一步中，在全分辨率场景上渲染折射网格。背景是通过对场景的mipmapping纹理采样，并将材质的粗糙度映射到mipmap级别，在表面后面合成的。表面越粗糙，背景就越模糊。Drobot使用一般的材料表示，也提出了相同的方法。McGuire和Mara的统一透明框架中也使用了类似的技术。在这种情况下，高斯点扩散函数是用来采样的背景在一个单一的通过。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024145525.png" class="" title="image-20211024145525">

<p>图像底部的透明玻璃具有基于粗糙度的背景散射。玻璃后面的元素或多或少显得模糊，模拟了折射光线。(图片由Frostbite提供，§c2018年Electronic Arts Inc.)</p>
<p><strong>它也可以处理更复杂的情况下，折射通过多层。每个层都可以用纹理中存储的深度和法线进行渲染。然后，可以使用一个符合地形映射(第6.8.1节)精神的程序来跟踪通过层的光线。存储的深度被视为一个高度场，每条射线走，直到找到交叉点。Oliveira和Brauwers提出了这样一个框架，通过网格的背面处理折射。此外，附近的不透明对象可以转换成颜色和深度地图，提供最后一个不透明层。所有这些图像空间折射方案的一个限制是，屏幕边界之外的东西不能折射或被折射。</strong></p>
<h3 id="Caustics-and-Shadows-焦散线和阴影"><a href="#Caustics-and-Shadows-焦散线和阴影" class="headerlink" title="Caustics and Shadows 焦散线和阴影"></a>Caustics and Shadows 焦散线和阴影</h3><p><strong>评估由折射和衰减光产生的阴影和焦散是一项复杂的任务。在非实时环境中，可以使用多种方法来实现这一目标，如双向路径跟踪或光子映射。幸运的是，许多方法提供了这种现象的实时近似。</strong></p>
<p><strong>焦散是光从直线路径发散出来的视觉结果，例如玻璃或水面。结果是光线在一些区域会散焦，产生阴影，而在另一些区域会集中，光线路径变得更密集，从而产生更强的入射光。这种路径取决于光遇到的曲面。反射的一个经典例子是咖啡杯内的心形腐蚀剂。折射焦散更明显，例如光通过水晶饰品、透镜或一杯水聚焦。参见下图。焦散也可以产生由于光被一个弯曲的水面反射和折射，无论是在上面和下面。当光线汇聚时，会集中在不透明的表面上并产生焦散。当在水面以下时，汇聚光路将在水体积内变得可见。这将产生众所周知的光轴，光子散射穿过水粒子。焦散是一个单独的因素，超出了来自体积边界的菲涅耳相互作用和穿过它时的透射率的光还原。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024145751.png" class="" title="image-20211024145751">

<p>真实世界的焦散来自反射和折射。</p>
<p><strong>为了从水面生成焦散，你可以应用离线生成的焦散动画纹理作为应用在表面上的光贴图，潜在地添加到通常的光贴图上。许多游戏都利用了这种方法，如运行在CryEngine上的《孤岛危机3》。在一个关卡中，水的面积是使用水的体积绘制的。体积的顶部表面可以使用凹凸贴图纹理动画或物理模拟。当垂直投影在水面上和水面下时，可以使用凹凸贴图产生的法线，从它们的方向映射到辐射贡献来生成焦散。距离衰减使用艺术家创作的基于高度的最大影响距离进行控制。水面也可以被模拟，对世界上的物体运动做出反应，从而产生与环境中发生的情况相匹配的焦散事件。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024145837.png" class="" title="image-20211024145837">

<p>演示在水中的腐蚀性效应。(图片来自Evan Wallace提供的WebGL Water演示。)</p>
<p><strong>当在水下时，同样的动态水面也可以用于水介质中的焦散。Lanza提出了一种两步生成光轴的方法。首先，从光的角度渲染光的位置和折射方向，并保存到纹理中。线可以栅格化从水面开始，并延伸到视野中的折射方向。它们通过添加混合来累积，最后一个后期模糊可以用来模糊结果，以掩盖低数量的线条。</strong></p>
<p><strong>Wyman提出了一种用于苛性渲染的图像空间技术。它的工作原理是通过透明物体的正面和背面折射后，首先计算光子的位置和入射方向。这是通过使用14.5.2节介绍的背景折射技术实现的。但是，由于菲涅耳效应，纹理被用来存储场景的交点位置、折射后的入射方向和透射率，而不是存储折射亮度。每个像素存储一个光子，然后可以以正确的强度溅射回视野。为了实现这一目标，有两种可能:在视野空间或光空间中以四倍频散射光子，并伴有高斯衰减。其中一个结果如下图所示。McGuire和Mara提出了一种更简单的方法来处理焦散类阴影，方法是根据透明表面的法线变化透射率，如果垂直于入射面透射率更高，由于菲涅耳效应，否则透射率更低。其他的体积阴影技术将在第7.8节中描述。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024150002.png" class="" title="image-20211024150002">

<p>在左边，佛陀折射附近的物体和周围的天空盒。在右边，焦散是通过本质上类似于阴影图的层次图生成的。(图片由爱荷华大学克里斯·怀曼提供。)</p>
<h2 id="Subsurface-Scattering-次表面散射-1"><a href="#Subsurface-Scattering-次表面散射-1" class="headerlink" title="Subsurface Scattering 次表面散射"></a>Subsurface Scattering 次表面散射</h2><p><strong>次表面散射是一种复杂的现象，存在于具有高散射系数的固体材料中(详见9.1.4节)。这些材料包括蜡、皮肤和牛奶，如图592页的图14.2所示。</strong></p>
<p><strong>一般的光散射理论已在14.1节中解释。在某些情况下，散射的尺度相对较小，如对于光学深度较高的介质，如人类皮肤。散射光被重新发射从表面接近其最初的进入点。这种位置上的偏移意味着地下散射不能被模拟带有BRDF(章节9.9)。也就是说，当散射发生在大于一个像素的距离上时，其更全局的性质是明显的。必须使用特殊的方法来渲染这种效果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024150133.png" class="" title="image-20211024150133">

<p>通过物体散射的光。最初，射入物体的光以折射方向传播，但散射导致它反复改变方向，直到它消失离开了物质。通过材料的每条路径的长度决定了光因吸收而损失的百分比。</p>
<p><strong>上图显示光线通过物体散射。散射使入射光走许多不同的路径。由于单独模拟每个光子是不切实际的(即使是离线渲染)，这个问题必须用概率的方法来解决，通过对可能的路径进行积分或通过近似这样的积分。除了散射，光在这种材料中传播还会被吸收。</strong></p>
<p><strong>区别上图中不同光路的一个重要因素是散射事件的数量。对于某些路径，光在散射一次后离开物质;对于其他人，光被散射两次，三次，甚至更多。散射路径通常分为单散射和多次散射。每个组通常使用不同的渲染技术。对于某些材料来说，单次散射在总效应中是相对较弱的一部分，而多次散射则占主导地位，例如蒙皮。由于这些原因，许多次表面散射技术都侧重于模拟多次散射。在本节中，我们将介绍几种近似次表面散射的技术。</strong></p>
<h3 id="Wrap-Lighting-包裹照明"><a href="#Wrap-Lighting-包裹照明" class="headerlink" title="Wrap Lighting 包裹照明"></a>Wrap Lighting 包裹照明</h3><p><strong>也许最简单的次表面散射方法是包裹照明。382页讨论过这种近似面积光源的方法。当用于近似地下散射时，我们可以添加一个颜色移位。这计算了光通过这种材料时的部分吸收。例如，在渲染皮肤时，可以应用红色移位。</strong></p>
<p><strong>当以这种方式使用时，包裹照明试图在曲面的阴影上模拟多重散射的效果。光线从相邻的点“泄漏”到当前的着色点软化了从亮到暗的过渡区域，在那里表面弯曲远离光源。Kolchin指出，这种效应取决于表面曲率，他得出了一个基于物理的版本。尽管派生表达式的计算代价有点高，但其背后的思想是有用的。</strong></p>
<h3 id="Normal-Blurring-法线模糊"><a href="#Normal-Blurring-法线模糊" class="headerlink" title="Normal Blurring 法线模糊"></a>Normal Blurring 法线模糊</h3><p><strong>Stam指出，多重散射可以模拟为扩散过程。Jensen等人进一步发展了这一想法，推导了解析双向表面散射分布函数(BSSRDF)模型。BSSRDF是BRDF在全局次表面散射情况下的推广。扩散过程对出射亮度有空间模糊作用。</strong></p>
<p><strong>这种模糊只适用于漫反射。镜面反射发生在材料表面，不受次表面散射的影响。由于法线映射通常编码小规模的变化，一个有用的地下散射技巧是只对镜面反射应用法线映射。平滑的，无扰动的法线用于漫反射。由于不需要额外的成本，因此在使用其他地下散射方法时，通常值得应用这种技术。</strong></p>
<p><strong>对于许多材料，多次散射发生在一个相对较小的距离。皮肤是一个重要的例子，大多数散射发生在几毫米的距离。对于这类材料，不扰动漫反射线的技术本身可能就足够了。Ma等人在实测数据的基础上扩展了这种方法。他们确定了散射物体的反射光，并发现，虽然镜面反射是基于几何表面法线，但次表面散射使漫反射表现为使用模糊表面法线。此外，模糊的数量可以在可见光谱上变化。他们提出了一种实时着色技术，使用独立获取的法线贴图来获取镜面反射和漫反射的R、G和B通道。对每个通道使用不同的法线贴图会导致颜色出血。因为这些分散的法线贴图通常类似于镜面映射的模糊版本,直接修改该技术使用一个单一的法线贴图,调整产生的水平,但代价是失去正常以来颜色转变为每个通道都是一样的。</strong></p>
<h3 id="Pre-Integrated-Skin-Shading-预先集成的皮肤着色"><a href="#Pre-Integrated-Skin-Shading-预先集成的皮肤着色" class="headerlink" title="Pre-Integrated Skin Shading 预先集成的皮肤着色"></a>Pre-Integrated Skin Shading 预先集成的皮肤着色</h3><p><strong>Penner结合了包裹照明和法线模糊的想法，提出了一种预集成的皮肤阴影解决方案。</strong></p>
<p><strong>散射和透射被集成并存储在一个二维查找表中。LUT的第一个轴基于n·l索引，第二个轴为基于1/r =||∂n/∂p||索引，表示曲面曲率。曲率越高，对透射色和散射色的影响越大。因为每个三角形的曲率都是常数，所以这些值必须离线进行烘焙和平滑处理。</strong></p>
<p><strong>为了处理次表面散射对小表面细节的影响，Penner对Ma等人的技术进行了修正，该技术在前一节中讨论过。Penner没有为R、G和B的漫反射获取单独的法线贴图，而是根据每个颜色通道的地下材料的扩散剖面，模糊原始法线贴图来生成它们。由于使用四个独立的非普通映射是内存密集型的，作为优化，他使用一个平滑的普通映射每个颜色通道与顶点法线混合的映射。</strong></p>
<p><strong>这种技术将忽略光线在阴影边界的扩散，因为默认情况下它只依赖于曲率。为了使散射轮廓跨越阴影边界，可以使用阴影半影轮廓对LUT坐标进行偏置。因此，这种快速技术能够近似于下一节中提出的高质量方法。</strong></p>
<h3 id="Texture-Space-Diffusion-纹理空间扩散"><a href="#Texture-Space-Diffusion-纹理空间扩散" class="headerlink" title="Texture-Space Diffusion 纹理空间扩散"></a>Texture-Space Diffusion 纹理空间扩散</h3><p><strong>模糊的漫射法线解释了一些视觉效果的多重散射，但不为其他，如软化阴影边缘。纹理空间扩散的概念可以用来解决这些限制。这个想法是由Lensch等人作为另一种技术的一部分提出的，但Borshukov和Lewis提出的版本影响最大。他们将多重散射的概念形式化为模糊过程。首先，表面辐照度(漫射照明)被渲染成纹理。这是通过使用纹理坐标作为栅格化的位置来实现的。真实的位置被分别插入用于阴影。这个纹理是模糊的，然后在渲染时用于漫反射着色。滤光片的形状和大小取决于材料和波长。例如，对于皮肤，R通道使用比G或B更宽的过滤器进行过滤，导致阴影边缘附近变红。在大多数材料中，用来模拟次表面散射的正确滤波器在中心有一个狭窄的尖峰，底部宽而浅。该技术最初被提出用于离线渲染，但实时GPU实现很快被NVIDIA和ATI的研究人员提出。</strong></p>
<p><strong>d’Eon和Luebke的介绍代表了该技术最完整的处理方法之一，包括支持模拟多层次表面结构效果的复杂滤波器。Donner和Jensen指出，这种结构产生了最真实的皮肤效果图。由d’Eon和Luebke提供的完整的NVIDIA皮肤渲染系统产生了非常好的结果(参见下图为例)，但是非常昂贵，需要大量的模糊通道。但是，它可以很容易地缩减以提高性能。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024151502.png" class="" title="image-20211024151502">

<p>纹理空间多层扩散。六种不同的模糊使用RGB权重组合。最终的图像是这种线性组合加上一个高光项的结果。(图片由NVIDIA公司提供。)</p>
<p><strong>替代应用多个高斯通道，Hable提出了一个12样本核。过滤器可以应用于纹理空间作为预处理或在像素着色器时栅格在屏幕上的网格。这使得面部渲染非常多速度更快，但代价是一些现实主义。当靠近时，少量的采样可以成为可见的颜色带。然而，从一个中等的距离，质量的差异是不明显的。</strong></p>
<h3 id="Screen-Space-Diffusion-空间内扩散"><a href="#Screen-Space-Diffusion-空间内扩散" class="headerlink" title="Screen-Space Diffusion 空间内扩散"></a>Screen-Space Diffusion 空间内扩散</h3><p><strong>渲染光地图并模糊场景中的所有网格，无论是在计算上还是在内存上，都会很快变得非常昂贵。此外，网格需要渲染两次，一次在光图中，一次在视图中，光图需要有一个合理的分辨率，以便能够代表小规模细节的地下散射。</strong></p>
<p><strong>为了解决这些问题，Jimenez提出了一种屏幕空间方法。首先，场景像往常一样渲染，需要次表面散射的网格，例如人脸，将被记录在模板缓冲区中。然后，在存储的亮度上应用一个双通道屏幕空间过程来模拟地下散射，使用模板测试只在需要的地方应用昂贵的算法，在包含半透明材料的像素中。额外的通道应用两个一维和双边模糊图像，水平和垂直。彩色模糊核是可分离的，但由于两个原因，它不能以完全可分离的方式应用。首先，必须考虑线性视图深度，根据表面距离将模糊拉伸到正确的宽度。二是双向过滤，避免不同深度的材料漏光。在不应该相互作用的表面之间。此外，法线方向必须考虑到模糊过滤器不仅适用于屏幕空间，而且切向表面。最后，这使得模糊核的可分性近似，但仍然是高质量的。随后，提出了改进的可分离滤波器提出了。由于依赖于屏幕上的材料区域，这种算法对于脸部特写来说是昂贵的。然而，这一成本是合理的，因为在这些领域的高质量正是所需要的。当场景中有很多角色时，这种算法尤其有价值，因为他们将同时被处理。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024151825.png" class="" title="image-20211024151825">

<p>高质量的渲染扫描模型的脸。屏幕空间次表面散射使得在许多角色上使用一个后期处理渲染真实的人类皮肤材料成为可能。(左图:由萨拉戈萨大学Jorge Jimenez和Diego Gutierrez提供。扫描场地,XYZRGB Inc.的tesy。右图:由Jorge Jimenez等人、动视出版公司(Activision Publishing, Inc, 2013)和萨拉戈萨大学(universsidad de Zaragoza)提供。Lee Perry-Smith的《无限现实》提供了扫描。)</p>
<p><strong>为了进一步优化过程，可以将线性深度存储在场景纹理的alpha通道中。一维模糊依赖于少量的样本，因此在近距离观察面部时可以看到欠采样。为了避免这个问题，可以每像素旋转内核，这将隐藏带有噪声的重影伪影。这种噪声的可见性可以通过使用时间反锯齿显著降低(章节5.4.2)。当实现屏幕空间扩散时，必须注意只模糊辐照度而不是漫射反照率或镜面照明。实现这一目标的一种方法是将辐照度和镜面照明渲染到单独的屏幕空间缓冲中。如果使用了延迟着色(第20.1节)，那么已经有了漫反射的缓冲区。为了减少内存带宽，Gallagher和Mittring提出使用棋盘格模式在单个缓冲区中存储辐照度和镜面照明。在辐照度被模糊后，最终的图像是由漫反射的倍数合成的反照率与模糊的辐照度，并添加镜面照明在顶部。</strong>         </p>
<p><strong>在这个屏幕空间框架内，也可以渲染大规模的表面下散射现象，例如光通过鼻子或耳朵。呈现网状漫射照明时,提出的技术吉梅内斯等。还增加了地下传输从抽样入射光线沿墙的贡献从另一侧使用否定表面法线的-n。结果是调制的透光率值估计使用由采样深度恢复传统的阴影地图呈现从光的角度来看,同样到下一节介绍的Dachsbacher和Stamminger的方法。为了表示圆锥中的前向散射，可以对阴影图进行多次采样。为了使用每个像素较低的样本计数来降低渲染成本，可以使用每个像素随机偏移或旋转的两个阴影样本。这样做会产生很多不必要的视觉噪音。值得庆幸的是，这种噪声可以被实现半透明的亚表面光扩散所需的屏幕空间亚表面模糊内核自动免费过滤掉。因此，在每个光源只有一个额外的深度图样本的情况下，就有可能渲染高质量的半透明效果，模拟光在一个锥体中通过脸的薄部分的前向散射。</strong></p>
<h3 id="Depth-Map-Techniques-深度贴图技术"><a href="#Depth-Map-Techniques-深度贴图技术" class="headerlink" title="Depth-Map Techniques 深度贴图技术"></a>Depth-Map Techniques 深度贴图技术</h3><p><strong>到目前为止所讨论的技术模拟的是相对较小距离的光散射，例如，皮肤。对于表现出大规模散射的材料，例如光通过手的传播，还需要其他的技术。其中许多聚焦于单次散射，这比多次散射更容易建模。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024152702.png" class="" title="image-20211024152702">

<p>左边是光线进入和离开物体时发生折射的理想状态;所有在离开物体时会适当折射的散射贡献都是通过在材料内行进的光线正确收集的。每个路径的长度将被计算评估灭绝σt。这可以通过路径跟踪或一些实时近似来实现。中间的图像显示了一种计算上更简单的情况，光线只在出射时折射。这是在实时渲染中通常做的近似，因为根据折射，从样本点(黄色)找到入口点(红色)并不简单。右图显示的是一个近似值，因此它更快，这里只考虑一条射线，而不是沿着折射射线的多个样本。</p>
<p><strong>在上图的左边可以看到大尺度单次散射的理想模拟。由于折射，光路在进入和离开物体时改变方向。所有路径的效果需要相加，以阴影一个单一的表面点。吸收也需要考虑在内——路径上的吸收量取决于它在材料内部的长度。即使对离线渲染器来说，计算单个阴影点的所有这些折射光线也很昂贵，所以通常忽略进入材料时的折射，只考虑出材料时方向的变化。由于光线投射总是在光线的方向上，Hery指出，通常用于阴影的光空间深度映射可以被访问，而不是执行光线投射。见上图的中间部分。对于按相位函数散射光的介质，散射角也影响散射光的量。</strong></p>
<p><strong>执行深度图查找比光线投射快，但是需要多个样本使得Hery的方法对于大多数实时渲染应用程序来说太慢。Green提出了一种更快的近似方法，如上图所示。尽管这种方法不是基于物理的，但它的结果是令人信服的。一个问题是，物体背面的细节可以显示出来，因为物体厚度的每一个变化都会直接影响着色颜色。尽管如此，格林的近似法还是非常有效，足以被皮克斯用于制作《料理鼠王》(Ratatouille)等电影。皮克斯将这种技术称为gummi lights。Hery实现的另一个问题是深度图不应该包含多个对象，或者高度非凸的对象。这是因为我们假设在阴影点(蓝色)和交点(红色)之间的整个路径都在物体内部。皮克斯通过使用一种深度阴影地图来解决这个问题。</strong></p>
<p><strong>实时建模大尺度多次散射是相当困难的，因为每个表面点都可能受到来自任何其他表面点的光的影响。Dachs- bacher和Stamminger提出了阴影映射的扩展，称为分阴影映射，用于建模多重散射。其他信息，如辐照度和表面法线，存储在光空间纹理中。从这些纹理中提取几个样本，包括深度图，并结合起来形成散射辐亮度的估计。NVIDIA的皮肤渲染系统使用了一种改进的技术。Mertens等人提出了类似的方法，但在屏幕空间中使用纹理而不是光空间。</strong>     </p>
<p><strong>树上的叶子也表现出强烈的次表面散射效应，当光线从后面射入时呈现出明亮的绿色。除了反照率和普通纹理，还有一个纹理代表透射率Tr 通过叶卷可以映射到表面上。然后，一个特别的模型可以用来近似来自光的额外地下贡献。由于叶片是薄元素，负法线可用作对边法线n的近似。背光贡献可计算为(l•-n)+•(-v•l)+，其中l为光方向，v为视图方向。然后，它可以与表面反照率相乘，并添加到直接光的贡献之上。</strong></p>
<p><strong>以类似的方式，Barr´e-Brisebois和Bouchard出了一种廉价的、特别的网格大规模次表面散射近似方法。首先，对于每个网格，它们生成一个存储平均局部厚度的灰度纹理，即1减去从面向内的法向量−n计算的环境遮挡。这种纹理叫做tss，被认为是一个近似的透光率，可以应用于从表面的另一边来的光。次表面散射添加到常规表面照明的评估为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024153223.png" class="" title="image-20211024153223">

<p><strong>其中l和v分别是归一化的光和视图向量，p是近似相位函数的指数(如图599页的图14.10所示)，css 为地下反照率。然后将这个表达式与光的颜色、强度和距离衰减相乘。这个模型不是基于物理或节能，但它能够快速渲染看似合理的地下照明效果在一次通过。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211024153302.png" class="" title="image-20211024153302">

<p>在左边，为Hebe雕像生成的局部厚度纹理。中间是用它可以达到的次表面光散射效果。在右边，另一个使用相同技术渲染的半透明立方体场景。(图片由Colin Barr´e-Brisebois和<br>马克·布沙尔)。</p>
<h2 id="Hair-and-Fur-头发和毛发"><a href="#Hair-and-Fur-头发和毛发" class="headerlink" title="Hair and Fur 头发和毛发"></a>Hair and Fur 头发和毛发</h2><p><strong>毛发是从哺乳动物的真皮层中生长出来的蛋白质丝。就人类而言，头发分散在身体的不同部位，包括头顶、胡须、眉毛和睫毛。其他哺乳动物通常被皮毛覆盖(密集的、长度有限的毛发)，动物身体不同部位的皮毛属性往往不同。头发可以是直的、波状的或卷曲的，每一种都有不同的强度和粗糙度。发缕可以是自然的黑色、棕色、红色、金色、灰色或白色，并且可以染成(不同的成功)彩虹的所有颜色。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025132823.png" class="" title="image-20211025132823">

<p>一根头发的纵向切割，呈现出不同的材料组成它，以及沿着方向ω入射光产生的照明组件ωi．</p>
<p><strong>毛发和皮毛的结构基本相同。由三层组成，如上图所示:</strong></p>
<pre><code>**•外面是角质层，代表纤维的表面。这个表面不是光滑的，而是由倾斜约为α = 3◦的重叠鳞片组成与头发的方向相比，头发的方向是向根部倾斜的。**

**•中间是皮层，含有黑色素，使纤维具有颜色。其中一种色素是真黑色素，表示棕色用σa,e  =(0.419, 0.697, 1.37)，另一种是褐黑素，表示红发用σa,p =(0.187, 0.4, 1.05)。**

**•内部是髓质。它很小，在建模人类头发时经常被忽略。然而，它在动物皮毛中占毛体积的比例较大，具有更大的意义。**
</code></pre>
<p><strong>我们可以把头发纤维看作类似于粒子的东西，看作是体积的离散化，但是用曲线代替点。用双向散射分布函数(BSDF)描述了头发纤维的光相互作用。这相当于一个BRDF，但是光在一个球体上积分，而不仅仅是一个半球。BSDF通过不同的纤维层聚集了发生在头发纤维内部的所有相互作用。在14.7.2节中有详细描述。光在纤维中散射，但也会从许多纤维中反弹，从而产生复杂的彩色辐射。此外，由于纤维吸收光作为其材料和色素的功能，它也很重要的代表体积的自我阴影，发生在头发体积。在这一节中，我们将描述最近的技术如何允许我们渲染短头发，如胡须，头发，最后，毛皮。</strong></p>
<h3 id="Geometry-and-Alpha-几何和Alpha"><a href="#Geometry-and-Alpha-几何和Alpha" class="headerlink" title="Geometry and Alpha 几何和Alpha"></a>Geometry and Alpha 几何和Alpha</h3><p><strong>头发线可以被渲染为挤压的头发四边形使用顶点着色器代码周围的头发引导曲线由艺术家绘制，产生了一条丝带的四边形遵循指导。每个四色丝带遵循其匹配的头发引导曲线，根据皮肤和代表一团头发的指定方向。这种方法非常适合胡须或短而静态的头发。它也是有效的，因为大的四边形可以导致更多的视觉覆盖，因此更少的丝带将需要覆盖头部，这反过来提高了性能。如果需要更多的细节，例如在物理模拟的细长长发的情况下，它是可能使用更细的四带和渲染数以千计的他们。在这种情况下，最好也使用沿着头发曲线切线的圆柱体约束来将生成的四边形朝向视图。即使头发模拟只使用了一些头发指南，新的头发也可以通过插入周围头发指南的属性来实例化。</strong></p>
<p><strong>所有这些元素都可以被渲染为阿尔法混合几何体。如果使用，头发的排列顺序必须正确，以避免出现透明的伪影(第5.5节)。为了缓解这个问题，可以使用预先排序的索引缓冲区，将靠近头部的头发重新排序，最后再将外层头发重新排序。这种方法对于短而无生气的头发很有效，但对于交错而有生气的长发就不适用了。依靠深度测试来修复排序问题可以使用alpha测试。然而，这可能导致高频几何和纹理严重的混叠问题。可以使用MSAA，对每个样本进行alpha测试，但要付出额外的样本和内存带宽的代价。另外，也可以使用任意顺序无关的透明方法，例如在第5.5节中讨论的方法。例如，TressFX存储k = 8最近的片段，更新在像素着色器中，以保持仅前7层有序，从而实现多层 alpha混合。</strong></p>
<p><strong>另一个问题是由mmap alpha小型化产生的alpha测试工件(章节6.6)。解决这个问题的两种方法是执行更智能的alpha mipmap生成或使用更高级的哈希alpha测试。当染细长发时，也可以根据它的像素覆盖来修改头发的不透明度。</strong></p>
<p><strong>像胡须、睫毛和眉毛这样的小头发比整头的头发更容易渲染。睫毛和眉毛甚至可以是几何形状的皮肤，以匹配头部和眼睑的运动。这些小元素上的毛发表面可以使用不透明的BRDF材料照明。也可以通过使用BSDF来遮蔽发丝，如下节所述。</strong></p>
<h3 id="Hair-头发"><a href="#Hair-头发" class="headerlink" title="Hair 头发"></a>Hair 头发</h3><p><strong>Kajiya和Kay开发了BRDF模型，以渲染由组织和无限小的圆柱形纤维组成的体积。这个模型，在9.10.3节中讨论，最初是通过光线穿过一个表示表面上密度的体纹理来渲染毛茸茸的元素。BRDF用于表示高射光和漫射光响应与体积，也可以用于头发。</strong></p>
<p><strong>Marschner等人的开创性工作测量了人类头发纤维中的光散射，并基于这些观察提出了一个模型。在一根发丝中观察到不同的散射成分。这些都在上图中描述。首先，一个R分量表示光在角质层的空气/纤维界面的反射，这导致白色镜面峰向根方向偏移。第二，TT分量表示光通过头发纤维的传播，一次从空气传输到头发材料，第二次从头发传输到空气。最后，第三个TRT组件表示光在头发纤维中通过被传输，被纤维的另一侧反射，然后传输回毛发材料之外。变量名中的“R”表示一个内部反射。TRT组件被认为是一个次级镜面高光，与R相比发生了偏移，并且由于光在穿过纤维材料时被吸收而被着色。</strong></p>
<p><strong>视觉上，R分量被认为是头发上无色的镜面反射。当大量头发从后面被点燃时，TT组件被认为是一个明亮的高光。TRT组件是至关重要的渲染现实的头发，因为它将导致闪烁的头发与偏心，即。在现实生活中，头发的横截面不是一个完美的圆形，而是一个椭圆形。闪光对于可信度很重要，因为这会让头发看起来不一样。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025133608.png" class="" title="image-20211025133608">

<p>路径跟踪参考金色(左)和棕色(右)头发渲染的高光闪烁导致纤维偏心。(图片由d ‘Eon等人提供。)</p>
<p><strong>Marschner等人提出了将R、TT和TRT组件分别作为毛发BSDF的一部分进行功能建模，该BSDF代表了毛发纤维对光的响应。该模型恰当地考虑了透射和反射时的菲涅耳效应，但忽略了其他更复杂的光路，如TRRT、TRRRT和更长的光路。</strong></p>
<p><strong>然而，这个原始模型并不是节能的。这已经在d ‘Eon等人的工作中进行了研究和确定。通过更好地考虑粗糙度和镜面锥的收缩，对BSDF组件进行了改进，从而节约了能量。组件也被扩展到包括更长的路径，如TR*T。透过率也通过测量黑色素消光系数来控制。与Marschner等人的工作类似，他们的模型能够忠实地渲染带有偏心的线上的闪烁。Chiang等人提出了另一种节能模型。这个模型提供了粗糙度和多重散射颜色的参数化，这对艺术家来说更直观，而不是让他们调整高斯方差或黑色素浓度系数。</strong></p>
<p><strong>艺术家可能想要在角色的头发上创建一个特殊的高光术语，例如，通过改变粗糙度参数。通过物理上的能量守恒和能量守恒模型，散射光在头发的体积也会发生变化。为了更好的艺术控制，可以将前几个散射路径(R, TT, TRT)和多个散射部分分开。这是通过保持第二组BSDF参数来实现的，仅用于多个散射路径。此外，BSDF R、TT和TRT组件可以用简单的数学形状表示，艺术家可以理解并调整这些形状，以进一步优化外观。根据输入和输出方向对BSDF进行归一化，使整套系统仍然保持节能。</strong></p>
<p><strong>上面给出的每个BSDF模型都很复杂，评估成本很高，并且大多用于电影制作路径跟踪环境。值得庆幸的是，存在实时版本。Scheuermann提出了一种特别的BSDF模型，该模型易于实现，渲染速度快，并且在将头发渲染为大的四束缎带时看起来很有说服力。更进一步，可以通过将BSDF存储在LUT纹理中(由进方向和出方向索引)作为参数来实时使用Marschner模型。然而，这种方法很难渲染具有空间变化外观的头发。为了避免这个问题，最近一个基于物理的实时模型用简化的数学方法近似了以前工作中的组件，以获得令人信服的结果。参见下图。然而，与离线结果相比，所有这些实时头发渲染模型的质量存在差距。简化算法通常不具有高级的体积阴影或多重散射。这种效果对于吸收率低的头发尤其重要，比如金发。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025133911.png" class="" title="image-20211025133911">

<p>实时毛发渲染与R, TT，和TRT，以及多重散射组件。(图片来源:Epic Games, Inc.)</p>
<p><strong>在体积阴影的情况下，最近的解决方案依赖于一个透过率值，使用d作为沿光方向从第一根头发接触到当前光纤的距离，根据恒定的吸收计算σa．这种方法是实用和直接的，因为它依赖于在任何引擎中可用的通常阴影贴图。然而，它不能代表由于头发聚集而导致的局部密度变化，这对明亮的头发尤其重要。参见下图。来为了解决这个问题，可以使用体积阴影表示(章节7.8)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025134120.png" class="" title="image-20211025134120">

<p>左:使用与第一个遮光器不同的深度和恒定的消光系数会导致体积阴影过于平滑。中间:使用深阴影图可以实现更多的透射变化，匹配毛发聚集在一起的方式在头发体积内。右图:基于到第一个遮挡器的距离，将深阴影贴图与PCSS相结合，可以获得更平滑的体度量阴影(详见第7.6节)。(图片由USC-HairSalon提供的头发模型渲染。)</p>
<p><strong>当渲染头发时，多重散射是一个昂贵的术语。适合实时实现的解决方案并不多。Karis提出了一个近似多次散射的方法。这个特别的模型使用假法线(类似于弯曲法线)，缠绕漫射照明，头发的基本颜色提高到深度依赖的功率之前，它与照明相乘，在光线分散通过许多股后接近颜色饱和度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025134237.png" class="" title="image-20211025134237">

<p>前两幅图像呈现的头发使用路径跟踪作为三个头发散射组件(R, TT, TRT)的参考，然后添加了多重散射。最后两幅图像采用双散射近似:轨迹跟踪，然后在GPU上实时渲染。(图片由Arno Zinke和Cem Yuksel提供)</p>
<p><strong>Zinke等人提出了一种更先进的双散射技术。参见上图。它是双重的，因为它根据两个因素来评估散射光的数量。第一，全局透射系数Ψ^G 结合被阴影像素与光线位置之间遇到的每根发丝的BSDF进行评估。因此, Ψ^G给出在阴影位置入射辐射的透射率。这个值可以在GPU上通过计算头发的数量和计算光路径上的平均线方向来计算，后者会影响BSDF和透光率。这些数据的累积可以使用深度不透明度映射或占用地图来实现。第二，局部散射分量 Ψ^L 近似地说明在阴影位置的透射辐亮度将分散在电流周围的毛发纤维中并对辐亮度作出贡献。这两个术语都被添加为Ψ^G + Ψ^G Ψ^L 并通过像素链BSDF馈入，积累光源贡献。这种技术更昂贵，但它是一个准确的实时近似光多重散射现象在头发体积。它也可以用于本章介绍的任何BSDFs。</strong></p>
<p><strong>环境照明是另一个复杂的输入，以评估动画半透明材料。简单地从球面谐波中取样辐照度是很常见的。照明也可以通过非定向预集成的双向闭塞计算从头发在其休息位置。用同样的假对于多重散射，Karis提出了一种特别的环境照明模型。</strong></p>
<p><strong>欲了解更多信息，Yuksel和Tariq提供了一个全面的实时头发绘制课程。在阅读研究论文和学习更多细节之前，本课程将教你所有关于头发渲染的许多领域，如模拟，碰撞，几何，BSDF，多重散射，和体积阴影。头发在实时应用中看起来很有说服力。然而，仍然需要大量的研究来更好地逼近物理环境照明和头发中的多重散射。</strong></p>
<h3 id="Fur-皮毛"><a href="#Fur-皮毛" class="headerlink" title="Fur 皮毛"></a>Fur 皮毛</h3><p><strong>与毛发不同，皮毛通常被认为是短而半有组织的，通常是在动物身上发现的。与使用纹理层进行体绘制方法相关的一个概念是体纹理，它是由二维、半透明纹理层表示的体描述。</strong></p>
<p><strong>例如，Lengyel等人使用一组8种纹理来代表表面上的皮毛。每个纹理代表了从表面给定距离通过一组毛发的切片。模型被渲染了8次，每次都用一个顶点着色程序沿着顶点法线向外移动每个三角形。通过这种方法，每个连续的模型都描绘了地表以上不同的高度。以这种方式创建的嵌套模型称为shell。这种渲染技术沿着物体轮廓的边缘分解，因为毛发随着层的扩散而分解成点。为了隐藏这个人工制品，皮毛也通过在轮廓边缘生成的鳍上应用不同的头发纹理来表示。参见下图和图19.28。轮廓鳍挤压的想法可以用于创建其他类型的模型的视觉复杂性。例如，Kharlamov等人使用鳍和地形映射来提供具有复杂轮廓的树网格。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025134727.png" class="" title="image-20211025134727">

<p>毛皮使用体积纹理。模型被渲染了8次，每次经过时表面向外扩张少量。左边是八次传球的结果。注意头发的轮廓。中间是鳍的渲染图。右边是最终渲染，使用鳍和壳。(图片来自NVIDIA SDK 10样本“毛皮外壳和鳍”，由NVIDIA公司提供。)</p>
<p><strong>几何着色器的引入使得用皮毛挤压表面的polyline毛发成为可能。《失落的星球》使用了这种技术。表面被渲染，值被保存在每个像素上:毛皮颜色、长度和角度。几何着色器然后处理这个图像，把每个像素变成半多边形-父折线。通过创建每个像素覆盖一根头发，细节水平自动保持。毛皮渲染分两步进行。在屏幕空间中指向下方的皮毛首先呈现，从屏幕底部到顶部排序。通过这种方式，混合被正确地执行，从后到前。在第二步中，剩下的毛发从上到下被渲染，再次正确地混合。随着GPU的发展，新技术成为可能并有利可图。</strong></p>
<p><strong>也可以使用前面几节中介绍的技术。股可以被渲染为四边形挤压作为几何体从一个皮肤表面，如星球大战前线游戏中的楚巴卡或TressFX鼠演示。Ling-Qi等人在将发丝描绘成细丝时证明，仅仅将头发模拟成均匀的圆柱体是不够的。对于动物的皮毛，髓质相对于毛发半径要深得多，也大得多。这减少了光散射的影响。因此，提出了一种双圆柱纤维BSDF模型，可以模拟更大范围的毛发和毛皮。它考虑了更详细的路径，如TttT、TrRrT、TttRttT等等，其中小写字母表示与髓质的交互。这种复杂的方法会产生更逼真的视觉效果，特别是对粗糙皮毛和精细的散射效果的模拟。这样的皮毛呈现技术包括许多链实例的栅格化，任何有助于减少渲染时间的方法都是受欢迎的。Ryu[1523]提出，根据运动幅度和距离，将大量的链实例渲染为一个细节级别方案。这种方法被用于离线电影渲染，在实时应用中似乎很容易应用。</strong></p>
<h2 id="Unified-Approaches-统一的方法-1"><a href="#Unified-Approaches-统一的方法-1" class="headerlink" title="Unified Approaches 统一的方法"></a>Unified Approaches 统一的方法</h2><p><strong>我们已经达到了一个点，体积渲染已经成为负担得起的实时应用。在未来可能实现什么?</strong></p>
<p><strong>在本章的开头，我们说过“一切都是分散的”。“看看参与的介质材料，有可能使用高散射系数σs 以实现不透明的媒介。这，加上复杂的各向异性相位函数驱动漫反射和镜面反射，将导致不透明的表面材料。鉴于此，是否有一种方法来统一实体和体积材料表示?</strong></p>
<p><strong>到今天为止，体积渲染和不透明材质渲染是分开的，因为GPU当前的计算能力迫使我们使用特定的方法，在某些用例中是有效的。我们为不透明的表面使用网格，为透明材料使用阿尔法混合网格，为烟雾量使用粒子广告牌，为参与媒体中的一些体积照明效果使用光线行进。</strong></p>
<p><strong>正如Dupuy等所暗示的，使用统一的表示来表示实体和参与的媒体是可能的。一种可能的表示方法是使用对称GGX (SGGX)，它是9.8.1节中给出的GGX正态分布函数的扩展。在这种情况下，微片理论表示在一个体积内的定向片粒子取代microfacet理论用于表面正态分布表示。从某种意义上说，与网格相比，细节级别将变得更加实用，因为它可以简单地成为对材料属性的体积过滤。这可能导致更连贯的照明和大细节世界的表现，同时保持照明，形状，遮挡，或应用在背景上的透光率。例如,如下图,呈现一片森林与体积过滤树表示将消除可见树网LOD切换,提供一个平滑滤波的薄几何和避免混叠树枝造成的,同时也提供正确的闭塞价值的背景考虑底层树几何在每个体素。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211025134947.png" class="" title="image-20211025134947">

<p>在顶部使用SGGX渲染的森林，从左到右的细节层次减少。底部部分显示了未经过滤的原始体素。(图片由Eric Heitz等人提供。)</p>
<h1 id="15-Non-Photorealistic-Rendering-非真实渲染"><a href="#15-Non-Photorealistic-Rendering-非真实渲染" class="headerlink" title="15 Non-Photorealistic Rendering 非真实渲染"></a>15 Non-Photorealistic Rendering 非真实渲染</h1><p><strong>真实感渲染是指使图像与照片难以区分。非真实感渲染(NPR)，也称为风格化渲染，有广泛的目标。某些形式的NPR的一个目标是创建类似于技术插图的图像。只有那些与特定应用程序的目标相关的细节阳离子是应该显示的。例如，在向客户销售汽车时，一张闪亮的法拉利引擎的照片可能很有用，但要修复引擎，一张带有相关部件的简化线条图可能更有意义(打印成本也更低)。</strong></p>
<p><strong>NPR的另一个领域是模拟绘画风格和自然媒体，如钢笔和墨水，木炭和水彩。这是一个巨大的领域，它允许自己拥有同样巨大的各种算法，试图捕捉各种媒体的感觉。下图中显示了一些示例。两本较老的书提供了技术上和绘画上的NPR算法的覆盖。考虑到这一广度，我们将重点放在绘制笔画和线条的技术上。我们的目标是实时给出一些用于NPR的算法。本章以详细讨论实现卡通渲染风格的方法开始，然后讨论NPR领域中的其他主题。本章以各种线绘制技术结束。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026133638.png" class="" title="image-20211026133638">

<p>应用于咖啡研磨机的各种非逼真的渲染风格。(使用LiveArt从Viewpoint DataLabs生成。)</p>
<h2 id="Toon-Shading-卡通阴影"><a href="#Toon-Shading-卡通阴影" class="headerlink" title="Toon Shading 卡通阴影"></a>Toon Shading 卡通阴影</h2><p><strong>就像不同的字体会给文本带来不同的感觉一样，不同的渲染风格也有自己的情绪、含义和词汇。有一个特别形式的NPR, cel或卡通渲染已经给予了大量的关注。由于这种风格被认为是卡通风格，它有幻想和童年的内涵。最简单的方法是，用实线将不同的纯色区域分隔开来。这种风格流行的一个原因是McCloud在他的经典著作《理解漫画》中所说的“简化放大”。通过简化和剔除杂乱，人们可以放大与演示相关的信息的效果。对于卡通人物，更广泛的观众会认同那些风格简单的人物。</strong></p>
<p><strong>卡通渲染风格已经在计算机图形学中使用了几十年，用于集成三维模型和二维cel动画。与其他NPR风格相比，它易于定义，因此很适合计算机自动生成。许多电子游戏都很好地利用了它。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026134145.png" class="" title="image-20211026134145">

<p>一个来自游戏Okami的实时NPR渲染的例子。(图片来源:Capcom Entertainment, Inc.)</p>
<p><strong>物体的轮廓通常用黑色渲染，这样可以放大卡通的效果。寻找和渲染这些轮廓将在下一节中处理。有几种不同的方法来处理椿象表面的阴影。两种最常见的方法是用纯色(非光照)填充网格区域，或者使用双色调方法，代表光照和阴影区域。双色方法，有时称为硬着色，是简单地在像素着色器中执行，当着色法和光源方向的点积高于某个值时使用较浅的颜色，如果不是，则使用较深的色调。当光照较复杂时，另一种方法是对最终图像本身进行量化。也称为色调转换，这是一个过程，取一个连续的值范围，并转换为几个色调，每个色调之间有一个急剧的变化。参见下图。量化RGB值会导致不愉快的色调变化，因为每个单独的通道的变化方式与其他的不密切相关。工作的色调,保留颜色空间，如HSV、HSL或Y’cbcr是更好的选择。或者，可以定义一维函数或纹理，将强度级别重新映射到特定的色调或颜色。纹理也可以使用量化或其他过滤器进行预处理。665页的图15.16显示了另一个带有更多颜色级别的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026134331.png" class="" title="image-20211026134331">

<p>左边的基本渲染依次使用了实填充、色调分离和铅笔着色技术。(Quidam的Jade2模型，wismo发布，Creative Commons 2.5署名许可。)</p>
<p><strong>Barla等人通过使用二维地图代替一维阴影纹理来添加依赖视图的效果。第二个维度是通过表面的深度或方向来获得的。例如，当远处或快速移动时，这允许物体平滑地软化对比。这种算法，结合各种其他阴影方程和绘制纹理，被用于游戏《军团要塞2》中，以混合卡通和现实风格。卡通着色器的变化可以用于其他目的，如在表面或地形上可视化特征时夸大对比。</strong></p>
<h2 id="Outline-Rendering-轮廓渲染"><a href="#Outline-Rendering-轮廓渲染" class="headerlink" title="Outline Rendering 轮廓渲染"></a>Outline Rendering 轮廓渲染</h2><p><strong>用于cel边缘绘制的算法反映了NPR的一些主要主题和技术。我们在这里的目标是提出一种算法，为该领域提供一种风味。使用的方法可以大致分为基于表面阴影、程序几何、图像处理、几何边缘检测或这些的混合方法。</strong></p>
<p><strong>有几种不同类型的边缘可以在卡通渲染中使用:</strong> </p>
<pre><code>**•边界或边沿不是两个三角形共用的，例如一张纸的边沿。实心物体通常没有边界边。 **

**•折痕、硬边或特征边是两个三角形共享的边，两个三角形之间的角(称为二面角)大于某个预定义值。一个好的默认折痕角是60度。例如，一个立方体有折痕边。折痕边可以进一步细分为脊边和谷边。**

**•当共享材质的两个三角形材质不同或导致材质变化时，材质边就会出现。它也可以是艺术家希望一直显示的一条边，例如，额头的线条或分隔同一颜色的裤子和衬衫的线条。**

**•轮廓边是两个相邻三角形相对于某个方向向量(通常是来自眼睛的方向向量)面向不同方向的边。** 

**•轮廓边是沿着物体轮廓的轮廓边，即它将物体从图像平面的背景中分离出来。** 
</code></pre>
<p><strong>参见下图。这种分类是基于文献中的常见用法，但也有一些变化，例如，我们称为折痕和材料边有时被称为边界边。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026134917.png" class="" title="image-20211026134917">

<p>顶部打开的盒子，正面有条纹。边界(B)，折痕(C)，材料(M)和轮廓(S)边缘显示。在给定的定义中，没有一条边界边被认为是剪影边，因为这些边只有一个相邻的多边形。</p>
<p><strong>我们在这里区分轮廓边和轮廓边。两者都是沿着表面的一部分面向观察者，另一部分面向外的边缘。轮廓边是轮廓边的子集，轮廓边将物体从另一个物体或背景中分离出来。例如，在头部的侧视图中，耳朵形成轮廓边缘，即使它们出现在头部轮廓内。上上图中的其他例子包括鼻子、两个弯曲的手指和毛发部分。在一些早期的文献中，等高线边缘被称为轮廓，但等高线边缘的全部类别通常是指。此外，等高线边缘不应与地形图上使用的等高线混淆。</strong></p>
<p><strong>请注意，边界边与轮廓边或剪影边不同。轮廓线和剪影边由视图方向定义，而边界边与视图无关。暗示性轮廓是由几乎是原始视点轮廓的位置构成的。它们提供额外的边来帮助传达物体的形状。参见下图。而我们这里的重点主要是检测-轮廓边缘的绘制和绘制，已经为其他类型的笔画做了大量的工作。我们还主要关注于为多边形模型寻找这样的边。B´enard等人讨论了寻找由细分曲面或其他高阶定义组成的模型轮廓的方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026135148.png" class="" title="image-20211026135148">

<p>从左到右:轮廓、轮廓、轮廓以及暗示性轮廓边缘。(图片由Doug DeCarlo、Adam Finkelstein、Szymon Rusinkiewicz和Anthony Santella提供。)</p>
<h3 id="Shading-Normal-Contour-Edges-着色法线轮廓边缘"><a href="#Shading-Normal-Contour-Edges-着色法线轮廓边缘" class="headerlink" title="Shading Normal Contour Edges 着色法线轮廓边缘"></a>Shading Normal Contour Edges 着色法线轮廓边缘</h3><p><strong>类似于第15.1节中的表面着色器，着色法线和眼睛方向之间的点积可以用来给出轮廓边缘。如果这个值接近于零，那么该表面几乎是与眼睛的边缘重合，因此很可能接近轮廓边缘。将这些区域涂成黑色，随着点积的增加逐渐变为白色。参见下图。在可编程着色器之前，该算法是使用带有黑色环的球形环境地图实现的，或将mipmap金字塔纹理的最顶层着色为黑色。今天这种类型的着色是直接在像素着色器中实现的，当屏幕法线变得垂直于视图方向时变为黑色。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026135529.png" class="" title="image-20211026135529">

<p>轮廓边缘的阴影通过暗表面，因为它的阴影法线成为垂直于视图方向。通过扩大跌落角，显示较厚的边缘。(图片由肯尼霍夫提供。)</p>
<p><strong>这种阴影在某种意义上与边缘照明相反，边缘照明照亮物体的轮廓;在这里，场景从眼睛的位置照明，下降是夸张的，使边缘变暗。它也可以被认为是图像处理中的阈值过滤器，当图像表面低于一定强度时，图像被转换为黑色，否则转换为白色。</strong></p>
<p><strong>这种方法的一个特点或缺点是，等高线的宽度是可变的，取决于曲面的曲率。这种方法适用于没有折痕边缘的曲面模型，例如，沿着轮廓的区域，通常会有法线指向几乎垂直于视图方向的像素。</strong></p>
<p><strong>该算法在模型上失败，如立方体，因为表面面积附近的折痕边缘将没有这个性质。即使在曲面上，它也会破裂，看起来也很糟糕，因为当物体距离较远时，轮廓边缘附近的一些法线采样可能不是几乎垂直的。Goodwin等人注意到这个基本概念作为视觉线索是如何有效的，并讨论了如何结合光照、曲率和距离来确定笔画厚度。</strong></p>
<h3 id="Procedural-Geometry-Silhouetting-程序几何轮廓"><a href="#Procedural-Geometry-Silhouetting-程序几何轮廓" class="headerlink" title="Procedural Geometry Silhouetting 程序几何轮廓"></a>Procedural Geometry Silhouetting 程序几何轮廓</h3><p><strong>最早的实时轮廓边缘绘制技术之一是由Rossignac和van Emmerik提出的，后来由Raskar和Cohen提炼出来。一般的想法是渲染正面正常，然后渲染背面的方式，使他们的轮廓边缘可见。呈现这些背面有各种各样的方法，每种方法都有自己的优点和缺点。每个方法的第一步都是绘制正面。然后打开正面剔除，关闭背面剔除，这样只渲染背面。</strong></p>
<p><strong>渲染轮廓的一种方法是只绘制背面的边缘(而不是正面)。使用偏倚或其他技术(第15.4节)确保有些线恰好画在正面的前面。这样，只有正面和背面的边缘是可见的。</strong></p>
<p><strong>使这些线条更宽的一种方法是将背面自己渲染成黑色，同样是向前倾斜。Raskar和Cohen给出了几种偏倚方法，如按固定的量进行平移，或按补偿z-depth非线性性质的量进行平移，或使用深度-斜率偏差调用，如OpenGL的glPolygonOffset。Lengyel讨论了如何通过修改透视矩阵来提供更精细的深度控制。所有这些方法的一个问题是，它们不能创建宽度一致的线条。要做到这一点，向前移动的量不仅取决于背面，也取决于相邻的正面。参见下图。背面的斜度可以用来使多边形向前倾斜，但线条的粗细也取决于正面的角度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026140052.png" class="" title="image-20211026140052">

<p>轮廓的z偏置方法，通过将背面向前平移来完成。如果正面是在不同的角度，如右图所示，不同数量的背面是可见的。(Raskar和Cohen的插图。)</p>
<p><strong>Raskar和Cohen解决了这个邻居依赖问题，方法是将每个背面三角形沿其边缘增粗，以确保看到一条始终很粗的线。也就是说，三角形的斜率和与观察者的距离决定了三角形的扩展程度。一种方法是将每个三角形的三个顶点沿其平面向外展开。绘制三角形的一种更安全的方法是将三角形的每条边向外移动并连接这些边。这样做可以避免让顶点远离原始三角形。参见下图。注意，这种方法不需要偏移，因为后面的面扩展到前面面的边缘之外。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026140212.png" class="" title="image-20211026140212">

<p>三角形边缘增粗。在左边，背面三角形沿其平面展开。每个边缘在世界空间中移动不同的数量，从而使结果边缘在屏幕空间中具有相同的厚度。对于细三角形来说，当一个角被拉长时，这种方法就失效了。在右侧，将三角形的边展开并连接，形成斜接角，避免了这个问题。</p>
<p><strong>三种方法的结果见下图。这种增肥技术更具可控制性和一致性，并已成功应用于《波斯王子》和《非洲武士》等电子游戏中的角色轮廓。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026140326.png" class="" title="image-20211026140326">

<p>使用厚线、z偏斜和增厚三角形算法绘制的背面边缘渲染轮廓边缘。由于小特征上的偏置问题，背面边缘技术使线之间的连接差和不均匀的线。由于依赖于正面的角度，z偏置技术给出了非均匀的边宽。(图片由Raskar和Cohen提供。)</p>
<p><strong>在刚才给出的方法中，背面三角形沿原平面展开。另一种方法是通过沿共享顶点法线移动它们的顶点向外移动，并与它们到眼睛的z-距离成比例。这被称为外壳或光晕方法，因为移动的背面形成外壳围绕原始对象。想象一个球体。正常渲染球体，然后扩展球体半径，相对于球体的中心宽度为5像素。也就是说，如果移动球体的中心一个像素相当于在世界空间中移动3毫米，那么将球体的半径增加15毫米。只渲染这个扩展版本的背面为黑色。轮廓边缘宽度为5像素。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026140503.png" class="" title="image-20211026140503">

<p>三角形壳技术通过沿顶点法线移动曲面来创建第二个曲面。</p>
<p><strong>对顶点着色器来说，沿着法线向外移动顶点是一个完美的任务。这种类型的展开有时被称为shell映射。该方法实现简单，效率高，鲁棒性好，性能稳定。参见下图。力场或晕轮效应可以通过进一步扩大和阴影这些背面取决于他们的角度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026140522.png" class="" title="image-20211026140522">

<p>一个来自游戏Cel Damage的实时卡通风格渲染的例子，使用背面外壳扩展来形成轮廓边，以及显式的折痕边绘制。(图片由Pseudo Interactive Inc.提供)</p>
<p><strong>这种shell技术有几个潜在的缺陷。想象一下，正面看一个立方体，只有一个面是可见的。形成轮廓边的四个背面都将向对应的立方体面方向移动，因此在角上留下缝隙。这是因为虽然每个角上都有一个顶点，但每个面都有不同的顶点法线。问题是，展开的立方体并没有真正形成壳层，因为每个角顶点都在不同的方向展开。一种解决方案是强迫相同位置的顶点共享一个新的平均顶点法线。另一种技术是在折痕处创建退化的几何图形，然后将其扩展成三角形。Lira等人使用一个额外的阈值纹理来控制每个顶点移动多少。</strong></p>
<p><strong>壳和增粗技术浪费了一些填充物，因为所有的背面都被送进了管线。所有这些技术的其他限制是，几乎没有控制边缘的外观，半透明的表面很难正确渲染，这取决于使用的透明算法。</strong></p>
<p><strong>这类几何技术的一个有价值的特点是在绘制过程中不需要连接信息或边列表。每个三角形都独立于其他三角形进行处理，因此这种技术适合GPU实现。</strong></p>
<p><strong>这类算法只渲染轮廓边缘。Raskar提出了一种聪明的解决方案，可以在变形模型上绘制山脊折痕边，而无需创建和访问边连接数据结构。这个想法是沿着被渲染的三角形的每条边生成一个额外的多边形。这些边多边形通过用户定义的临界二面角从三角形的平面弯曲，这决定了折痕何时应该可见。如果在任何给定时刻，两个相邻三角形的折痕角大于此折痕角，则边缘多边形将可见，否则它们将被三角形隐藏。参见下图。谷边也可以使用类似的技术，但需要一个模板缓冲区和多个通道。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026140732.png" class="" title="image-20211026140732">

<p>一个侧面的两个三角形连接在一个边缘，每个都有一个小的“鳍”连接。当两个三角形沿着边缘弯曲时，鳍就会变得清晰可见。在右边的鳍是暴露的。漆成黑色，这些看起来像山脊边缘。</p>
<h3 id="Edge-Detection-by-Image-Processing-图像处理的边缘检测"><a href="#Edge-Detection-by-Image-Processing-图像处理的边缘检测" class="headerlink" title="Edge Detection by Image Processing 图像处理的边缘检测"></a>Edge Detection by Image Processing 图像处理的边缘检测</h3><p><strong>上一节中的算法有时被归类为基于图像的，因为屏幕分辨率决定了它们是如何执行的。另一种算法是更直接地基于图像，因为它完全操作存储在图像缓冲区中的数据，而不修改(甚至不直接知道)场景中的几何形状。</strong></p>
<p><strong>Saito和Takahashi首先介绍了G-buffer的概念，它也用于延迟着色(章节20.1)。Decaudin扩展了G缓冲器的使用来执行卡通渲染。其基本思想很简单:NPR可以通过在不同的信息缓冲区上执行图像处理算法来实现。通过寻找相邻z缓冲区的不连续点，可以找到许多等高线的位置。相邻表面法线值的不连续通常是轮廓和边界边缘位置的信号。渲染场景在环境颜色或与目标识别值可以用来检测材料，边界，和真实的剪影边缘。</strong></p>
<p><strong>这些边缘的检测和绘制由两部分组成。首先，渲染场景的几何图形，使用像素着色器保存深度、法线、对象IDs或其他所需的数据到各种渲染目标。然后以类似于第12.1节所述的方式执行后处理过程。后处理通过对每个像素周围的邻域进行采样，并基于这些样本输出结果。例如，假设我们对场景中的每个对象都有一个唯一的识别值。在每个像素上，我们可以对这个ID进行采样，并将其与测试像素角上的四个相邻像素ID值进行比较。如果任何一个IDs与测试像素的IDs不同，则输出黑色，否则输出白色。对所有8个相邻像素进行采样更简单，但采样代价更高。这种简单的测试可以用来绘制大多数对象的边界和轮廓边缘(真正的轮廓)。材质IDs可以用来寻找材质边缘。</strong></p>
<p><strong>轮廓边缘可以通过在正常和深度缓冲区上使用各种过滤器来找到。例如，如果相邻像素之间的深度差超过某个阈值，则可能存在轮廓边缘，因此像素被染黑。不是简单地判断相邻像素是否与样本匹配，而是需要其他更复杂的边缘检测操作符。我们在这里不讨论各种边缘检测滤波器的优缺点，如Roberts cross、Sobel和Scharr，因为图像处理文献广泛地涵盖了这些。因为这些操作符的结果不一定是布尔值，所以我们可以调整它们的阈值，或者在某些区域中在黑白之间淡出。注意，法线缓冲区也可以检测折痕边缘，因为法线之间的巨大差异可以表示轮廓或折痕边缘。Thibault和Cavanaugh讨论了他们如何使用这种技术为《无主之地》添加深度缓冲。在其他技术中，他们修改了Sobel滤波器，使其创建单像素宽的轮廓和深度计算，以提高精度。参见下图。也可以往另一个方向去，只在阴影周围添加轮廓，忽略相邻深度差异很大的边缘。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026141322.png" class="" title="image-20211026141322">

<p>修改了《无主之地》中的Sobel边缘检测。最终发布的版本(这里没有显示)进一步改进了前景中草的边缘。(图片由Gearbox Software, LLC提供)</p>
<p><strong>膨胀算子是一种形态算子，用于加厚检测到的边缘。边缘图像生成后，应用一个单独的通道。在每个像素，像素的值和它周围的值在一些半径内被检查。找到的最暗像素值作为输出返回。这样，一条细的黑线将被搜索区域的直径加粗。多个通过可以应用于进一步加粗的线条，其代价是额外通过的成本被每一通过所需的样品大大减少所抵消。不同的结果可以有不同的厚度，例如，轮廓边可以比其他轮廓边更厚。相关的侵蚀运算符可用于减薄线或其他影响。一些结果见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026141501.png" class="" title="image-20211026141501">

<p>法线图(左上)和深度图(中上)的值采用了Sobel边缘检测，结果分别显示在左下和中下。右上方的图像是经过膨胀处理的增厚复合图像。在右下角的最终渲染是通过使用Gooch着色和在边缘合成来实现的。(图片由ATI技术公司的Drew Card和Jason L. Mitchell提供)</p>
<p><strong>这种算法有几个优点。它可以处理所有类型的表面，不管是平面还是曲面，这与大多数其他技术不同。网格不需要连接，甚至不需要一致，因为该方法是基于图像的。</strong></p>
<p><strong>这种技术的缺陷相对较少。对于接近边缘的表面，z深度比较滤波器可以错误地检测出整个表面的轮廓边缘像素。z-depth比较的另一个问题是，如果差异很小，则可能会错过轮廓边缘。例如，桌子上的一张纸通常会缺边。同样，法线贴图过滤器也会忽略这张纸的边缘，因为法线是相同的。这仍然不是万无一失的;例如，一张纸折叠起来会产生无法检测到的边缘，这些边缘重叠在一起。生成的线显示阶梯混叠，但不同第5.4.2节中描述的形态反锯齿技术可以很好地处理这种高对比度输出，以及posterization等技术，以改善边缘质量。</strong></p>
<p><strong>检测也可能以相反的方式失败，在本不存在边缘的地方创建边缘。确定什么构成边并不是一种万无一失的操作。例如，想象玫瑰的茎，一个薄圆筒。关闭，我们的样本像素附近的干法线没有变化那么多，所以没有检测到边缘。当我们远离玫瑰时，法线将在像素间快速变化，直到在某个点，由于这些差异，可能会在边缘附近发生假边缘检测。同样的问题也会发生在从深度图中检测边缘时，视角对深度的影响是一个需要补偿的额外因素。Decaudin提供了一种改进的方法，通过处理法线和深度图的梯度来寻找变化，而不仅仅是值本身。决定不同的像素差异如何转化为颜色变化是一个经常需要针对内容进行调整的过程。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026141611.png" class="" title="image-20211026141611">

<p>各种边缘的方法。褶皱等特征边是纹理本身的一部分，由艺术家提前添加。人物的轮廓是通过背面挤压产生的。采用图像处理的边缘检测方法生成不同权重的轮廓边缘。左边图像的权重太小，所以这些边缘很模糊。中间显示轮廓，特别是鼻子和嘴唇的轮廓边缘。右边显示的是来自太大重量的伪影。(Afro Samurai R &amp; c 2006冈崎隆，GONZO / Samurai项目。Program c 2009 BANDAI NAMCO Entertainment America Inc.)</p>
<p><strong>一旦产生了笔画，就可以按照需要进行进一步的图像处理。由于笔画可以在单独的缓冲区中创建，它们可以自己修改，然后在表面上合成。例如，可以使用噪声函数分别磨损和晃动线条和表面，在两者之间创建小的间隙，并给出一个手绘的外观。纸张的高度场可以用来影响渲染效果，固体材料如在凸起处沉积的木炭或在山谷中聚集的水彩画。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026141722.png" class="" title="image-20211026141722">

<p>左边的鱼模型通过边缘检测、posterization、噪声扰动、模糊和混合在纸张顶部呈现在右边。(图片由Autodesk, Inc.提供)</p>
<p><strong>我们在这里重点讨论了使用几何或其他非图形数据(如法线、深度和IDs)来检测边缘。自然地，图像处理技术发展为图像，这种边缘检测技术可以应用于色彩缓冲。一种方法叫做差分高斯滤波器(DoG)，图像用两个不同的高斯滤波器处理两次，其中一个减去另一个。这种边缘检测方法已经被发现可以为NPR产生特别令人满意的结果，用于生成各种艺术风格的图像，如铅笔阴影和粉彩。</strong></p>
<p><strong>图像后处理操作员在许多NPR技术模拟艺术媒体，如水彩画和丙烯酸颜料突出。在这个领域有相当多的研究，对于交互式应用程序来说，最大的挑战是尝试用最少的纹理样本做最多的事情。可以在GPU上使用双边、均值偏移和Kuwahara过滤器来保留边缘和平滑区域，使其看起来就像绘制的。Kyprianidis等人对该领域的图像处理效果进行了全面回顾和分类。Montesdeoca等人的工作是一个很好的例子，将许多直接的技术结合到以交互速率运行的水彩画效果中。水彩样式渲染的模型如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026141912.png" class="" title="image-20211026141912">

<p>在左边，一个标准的现实渲染。在右侧，水彩风格通过均值移位颜色匹配软化纹理，并增加对比度和饱和度，以及其他技术。(水彩图片由Autodesk, Inc.提供)</p>
<h3 id="Geometric-Contour-Edge-Detection-几何轮廓边缘检测"><a href="#Geometric-Contour-Edge-Detection-几何轮廓边缘检测" class="headerlink" title="Geometric Contour Edge Detection 几何轮廓边缘检测"></a>Geometric Contour Edge Detection 几何轮廓边缘检测</h3><p><strong>到目前为止给出的方法的一个问题是，边缘的风格化充其量是有限的。我们不能轻易地使线条看起来虚线，更不用说看起来手绘或像笔触。对于这种操作，我们需要找到轮廓边缘并直接渲染它们。有了独立的边缘实体，就有可能创建其他效果，比如在网格冻结时，轮廓突然跳跃。</strong></p>
<p><strong>等高线是指两个相邻三角形中的一个面向观者，另一个远离观者。测试是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026142214.png" class="" title="image-20211026142214">

<p><strong>其中n₀ 和n₁ 是两个三角形的法线，v是从眼睛到边缘的视图方向(即到任何一个端点)。为了使该测试正确工作，表面必须保持一致的朝向(第16.3节)。</strong></p>
<p><strong>在模型中寻找轮廓边缘的蛮力方法是遍历边缘列表并进行测试。Lander指出，一个有价值的优化是识别并忽略平面多边形内部的边。也就是说，给定一个连通三角形网格，如果一条边的两个相邻三角形位于同一平面上，那么这条边就不可能是一条等高线。在一个简单的时钟模型上实现这个测试将边缘数从444条下降到256条。此外，如果模型定义的是实心物体，则凹边永远不可能是轮廓边。Buchanan和Sousa通过对每个单独的面重复使用点积测试，避免了对每条边进行单独的点积测试。</strong></p>
<p><strong>从头开始检测每一帧的轮廓边缘代价很高。如果摄像机视图和物体在帧与帧之间移动很少，则可以合理地假设前一帧的轮廓边缘仍然是有效的轮廓边缘。Aila和Miettinen为每条边关联一个有效距离。这个距离是观察者可以移动，但轮廓边缘仍然保持其状态。在任何实体模型中，每个单独的轮廓总是由一个封闭的曲线组成，称为轮廓环，或者更恰当地说，轮廓环。对于对象边界内的轮廓，循环的某些部分可能会被遮挡。甚至实际的轮廓也可能由几个环组成，部分环在轮廓内或被其他表面隐藏。由此可知，每个顶点的等高线边必须是偶数。参见下图。注意，当跟随网格边缘时，循环在三维空间中经常是锯齿状的，z深度变化非常明显。如果需要形成平滑曲线的边缘，例如根据距离改变厚度，可以进行额外的处理，在三角形的法线之间插值，以近似三角形内部的真实轮廓边缘。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026142416.png" class="" title="image-20211026142416">

<p>轮廓循环。左边是相机的模型视图。中间用蓝色显示背对镜头的三角形。右侧显示的是脸部一个区域的特写。注意复杂性和一些轮廓环是如何隐藏在鼻子后面的。(模型由Chris Landreth提供，图片由Pierre B´enard和Aaron Hertzmann提供。)</p>
<p><strong>从一帧到另一帧跟踪循环位置可能比从头开始创建循环更快。Markosian等人从一组循环开始，并使用随机搜索算法在摄像机移动时更新这组循环。轮廓环也会随着模型方向的改变而被创建和破坏。Kalnins等人指出，当两个循环合并时，需要采取纠正措施，否则从一帧到下一帧会出现明显的跳跃。他们使用像素搜索和“投票”算法，试图保持帧与帧之间的轮廓一致性。</strong></p>
<p><strong>这种技术可以极大地提高性能，但可能并不精确。线性方法是精确但昂贵的。分层方法利用摄像机获取轮廓边缘，结合了速度和精度。对于非动画模型的正投影视图，Gooch等人使用高斯图的层次结构来确定轮廓边缘。Sander等人使用n元树的标准锥体(章节19.3)。Hertzmann和Zorin使用了模型的双空间表示，允许他们在模型的边缘施加层次。</strong></p>
<p><strong>所有这些显式边缘检测方法都是CPU密集型的，缓存一致性差，因为形成轮廓的边缘分散在边缘列表中。为了避免这些代价，顶点着色器可以用来检测和渲染轮廓边缘。其思想是将模型的每条边作为两个三角形沿管道向下，形成一个退化的四边形，两个相邻的三角形法线连接到每个顶点。当发现一条边是等高线的一部分时，四边线的点被移动，使其不再退化(即可见)。然后画出这个薄薄的四边形鳍。该技术基于与为阴影体创建寻找轮廓边缘(章节7.3)相同的思想。如果几何着色器是管线的一部分，这些额外的鳍四边形不需要存储，但可以在飞行中生成。一个幼稚的实现将在鳍之间留下裂缝和缝隙，可以通过修改鳍的形状来修正。</strong></p>
<h3 id="Hidden-Line-Removal-移除隐藏线"><a href="#Hidden-Line-Removal-移除隐藏线" class="headerlink" title="Hidden Line Removal 移除隐藏线"></a>Hidden Line Removal 移除隐藏线</h3><p><strong>一旦找到等高线，线条就被渲染出来。明确地找到边缘的一个好处是，您可以将这些样式化为钢笔笔触、绘画笔触或任何您想要的其他媒介。笔触可以是基本线条、纹理视点替用特效(第13.6.4节)、原语集或任何你想尝试的东西。</strong></p>
<p><strong>尝试使用几何边的一个更复杂的问题是，并不是所有的边都是可见的。绘制表面以建立z缓冲区可以掩盖隐藏的几何边，这对于简单的样式(如虚线)可能已经足够了。Cole和Finkelstein通过沿着直线本身的脊取样z-深度，将这种方法推广到代表直线的四边形上。然而，使用这些方法，直线上的每个点都是独立呈现的，因此没有预先知道明确定义的开始和结束位置。对于轮廓环或其他边缘，线段是用来定义笔触或其他连续对象的，我们需要知道每个笔触首次出现和消失的时间。确定每个线段的可见性称为隐藏线段呈现，其中处理一组线段以获取可见性，并返回一组较小的(可能是剪切的)线段。</strong></p>
<p><strong>Northrup和Markosian通过绘制所有对象的三角形和轮廓边，并为每个对象分配不同的识别码来解决这个问题。这个ID缓冲区被读回，可见的轮廓边缘由它确定。这些可见的部分然后检查重叠和链接在一起形成平滑的笔画路径。如果屏幕上的线段很短，这种方法是有效的，但它不包括线段本身的剪辑。然后沿着这些重建路径渲染程式化的笔画。笔画本身可以用许多不同的方式进行程式化，包括锥度、光晕、摆动、过冲和褪色的效果，以及深度和距离提示。下图显示了一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211026142826.png" class="" title="image-20211026142826">

<p>使用诺斯鲁普和马尔科斯混合技术生成的图像。找到轮廓边缘，构建成链，并呈现为笔画。(图片由Lee Markosian提供。)</p>
<p><strong>Cole和Finkelstein提出了一种边缘集的可见性计算方法。它们将每个线段存储为两个世界空间坐标值。一系列通道运行一个像素着色器在整个片段集合，剪辑和确定长度在每个像素中，然后为每个潜在像素位置创建一个图集并确定可见性，然后使用这个图集创建可见的笔画。虽然复杂，但这个过程在GPU上相对较快，并提供了一组已知起始和结束位置的可见笔画。</strong></p>
<p><strong>程式化通常包括应用一个或多个预先制作的纹理到线四边。Rougier讨论了一种不同的方法，程序化地渲染虚线模式。每个线段访问存储所需的所有虚线图案的纹理。每个模式都被编码为一组命令，这些命令指定虚线模式以及使用的端点和连接类型。使用四边形的纹理坐标，每个图案控制着色器对四边形中每个点上的线覆盖像素的多少进行一系列测试。</strong></p>
<p><strong>确定轮廓的边缘，将它们连接成连贯的链，然后确定每个链的可见性来形成一个笔画是很难完全平行的。在制作高质量的线条程式化时，另一个问题是，在下一帧中，每个笔画将再次绘制，改变长度或可能首次出现。B´enard等人提出了一项绘制方法的综述，该方法为沿边缘和表面图案的笔画提供了时间连贯性。这不是一个已解决的问题，而且可以计算，因此研究仍在继续。</strong></p>
<h2 id="Stroke-Surface-Stylization-尝试表面风格化"><a href="#Stroke-Surface-Stylization-尝试表面风格化" class="headerlink" title="Stroke Surface Stylization 尝试表面风格化"></a>Stroke Surface Stylization 尝试表面风格化</h2><p><strong>虽然卡通渲染是一种流行的风格，试图模拟，有无限多种其他风格应用到表面。效果可以从修改现实纹理，使算法程序生成从帧到帧的几何装饰。在本节中，我们将简要介绍与实时渲染相关的技术。</strong></p>
<p><strong>Lake等人讨论了使用漫反射阴影术语来选择在表面上使用的纹理。当漫反射变暗时，就会使用带有深色印象的纹理。纹理应用于屏幕空间坐标，以提供一个手绘的外观。为了进一步增强草图的外观，纸的纹理也被应用到屏幕空间的所有表面。参见下图。这类算法的一个主要问题是淋浴门效果，在动画期间，物体看起来像是通过有图案的玻璃观看的。物体感觉就像在纹理中游泳一样。Breslav等人通过确定什么样的图像变换最匹配一些底层模型位置的移动来保持二维纹理查找。这可以保持与基于屏幕的填充模式的连接，同时给予与对象更强的连接。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027130404.png" class="" title="image-20211027130404">

<p>使用纹理调色板、纸张纹理和轮廓边缘渲染生成的图像。(转载由亚当·雷克和卡尔·马歇尔，英特尔公司的许可，版权为英特尔公司2002。)</p>
<p><strong>一个解决方案是显而易见的:直接将纹理应用到表面。挑战是，基于笔画的纹理需要保持一个相对统一的笔画厚度和密度，以看起来令人信服。如果纹理被放大，笔画显得太粗;如果它被缩小，笔画要么是模糊的，要么是薄和噪声(取决于是否使用mipmapping)。Praun等人提出了一种实时生成笔画纹理mipmaps的方法，并将这些纹理平滑地应用到表面上。这样做可以保持屏幕上的描边密度作为对象的距离的变化。第一步是形成要使用的纹理，称为色调艺术地图(TAMs)。这是通过在mipmap级别中绘制笔触来实现的。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027130522.png" class="" title="image-20211027130522">

<p>色调艺术地图(TAMs)。笔画被绘制到mipmap级别中。每一个mipmap级别包含所有的笔画从纹理到它的左边和上面。通过这种方式，mip级别和相邻纹理之间的插值是平滑的。(图片由普林斯顿大学Emil Praun提供。)</p>
<p><strong>Klein等人在他们的“艺术地图”中使用了一个相关的概念来维护NPR纹理的笔画大小。有了这些纹理，模型通过插值每个顶点所需的色调来渲染。这种技术产生的图像具有手绘的感觉。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027130621.png" class="" title="image-20211027130621">

<p>使用色调艺术地图(TAMs)渲染的两个模型。样本显示了用于渲染每个纹理的重叠纹理模式。(图片由普林斯顿大学Emil Praun提供。)</p>
<p><strong>Webb等对TAMs进行了两种扩展，获得了更好的结果，一种是使用体积纹理，允许使用颜色，另一种是使用阈值方案，改进了抗锯齿。Nuebel给出了一种相关的木炭渲染方法。他使用了一个从黑暗到光明的噪音纹理一个轴。强度值沿着这个轴访问纹理。Lee等人使用TAMs和其他技术生成令人印象深刻的图像，看起来像是用铅笔绘制的。</strong></p>
<p><strong>至于笔画，除了已经讨论过的操作外，还有许多其他可能的操作。为了获得草图效果，边缘可以抖动或超调其原始位置，如图651页图15.1的右上和中下图像所示。</strong></p>
<p><strong>Girshick等人讨论了沿着曲面上的主曲线方向线绘制笔画。也就是说，从曲面上任意一点，都有一个指向最大曲率方向的第一个主方向切向量。第二个主要方向是垂直于第一个矢量的切向量，它给出了曲面弯曲最小的方向。这些方向线在感知曲面时很重要。对于静态模型，它们还具有只需生成一次的优点，因为这些笔画独立于光照和阴影。Hertzmann和Zorin讨论了如何清理和平滑主方向。大量的研究和开发已经探索了使用这些方向和其他数据在任意表面上应用纹理，在驾驶模拟动画和其他应用。以Vaxman等人的报告为起点。</strong></p>
<p><strong>嫁接的想法是可以根据需要在表面添加几何或贴花纹理，以产生特定的效果。它们可以由所需的细节水平、表面对眼睛的方向或其他因素来控制。这些也可以用来模拟钢笔或毛笔的笔触。下图显示了一个示例。几何移植物是一种程序建模形式。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027130955.png" class="" title="image-20211027130955">

<p>两种不同的嫁接方式造就了斯坦福兔。(图片由布鲁斯·古奇和马特·卡普兰，犹他大学提供)</p>
<p><strong>这一章仅仅触及了NPR研究所采取的几个方向。请参阅末尾的“进一步阅读和参考资料”部分，了解更多信息。在这个领域中，我们通常很少或根本没有可以作为基本真理的物理正确答案。这既是问题，也是解放。技术给出了速度和质量之间的权衡，以及实现成本。在交互渲染速率的时间约束下，大多数方案在一定条件下会发生弯曲和断裂。在应用程序中，确定哪些工作很好或足够好是使该领域成为一个迷人的挑战的原因。</strong></p>
<p><strong>我们的大部分注意力都集中在一个特定的主题上，轮廓边缘检测和渲染。最后，我们将把注意力转向线条和文本。这两种非写实的原语使用频率很高，也有自己的一些挑战，所以值得单独报道。</strong></p>
<h2 id="Lines-线"><a href="#Lines-线" class="headerlink" title="Lines 线"></a>Lines 线</h2><p><strong>渲染简单的实心“硬”线通常被认为是相对无趣的。然而，它们在CAD等领域非常重要，用于查看底层模型面和识别对象的形状。它们在突出显示选定对象和技术插图等领域也很有用。此外，所涉及的一些技术也适用于其他问题。</strong></p>
<h3 id="Triangle-Edge-Rendering-三角形边缘渲染"><a href="#Triangle-Edge-Rendering-三角形边缘渲染" class="headerlink" title="Triangle Edge Rendering 三角形边缘渲染"></a>Triangle Edge Rendering 三角形边缘渲染</h3><p><strong>在填充的三角形上正确地渲染边缘比它最初看起来要困难得多。如果一条直线与三角形处于完全相同的位置，我们如何确保直线总是呈现在前面呢?一个简单的解决方法是用固定的偏置渲染所有的线条。也就是说，每一条线都被渲染得比实际更接近，这样它就会在表面之上。如果固定偏差太大，应该隐藏的部分边缘就会出现，破坏效果。如果偏置过小，接近边的三角形面会隐藏部分或全部边。正如在第15.2.2节中提到的，API调用，比如OpenGL的glPolygonOffset，可以根据它们的斜率，将曲面向后移动到线条下方。这种方法相当有效，但并不完美。</strong></p>
<p><strong>Herrell等人的一个方案完全避免了偏见。它使用一系列步骤来标记和清除模板缓冲区，以便正确地在三角形上绘制边。除了最小的三角形集合外，这种方法对任何三角形都是不切实际的，因为每个三角形都必须单独绘制，并且为每个三角形清除模板缓冲区，这使得这个过程非常耗时。</strong></p>
<p><strong>Bærentzen等人提出了一种可以很好地映射到GPU的方法。他们使用一个像素着色器，使用三角形的重心坐标来确定到最近边缘的距离。如果像素接近边缘，则使用边缘颜色绘制。边缘厚度可以是任何想要的值，并可以受距离或保持不变。参见下图。它的主要缺点是轮廓线的厚度只有内线的一半，因为每个三角形都是内线厚度的一半。在实践中，这种不匹配往往不明显。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027131255.png" class="" title="image-20211027131255">

<p>像素着色器生成线。左边是抗锯齿的单像素宽边缘;右边是带有光晕的可变粗细线。(图片由J. Andreas b . ærentzen提供。)</p>
<p><strong>Celes和Abraham对这一观点进行了扩展和简化，并对之前的工作进行了全面的总结。他们的想法是为每个三角形边使用一组一维的纹理坐标，1.0为定义边的两个顶点，0.0为另一个顶点。他们利用纹理映射和mip链来提供恒定宽度的边缘。这种方法易于编码，并提供一些有用的控件。例如，可以设置最大密度，这样稠密的网格就不会完全被边缘填充，从而变成纯色。</strong></p>
<h3 id="Rendering-Obscured-Lines-渲染模糊线条"><a href="#Rendering-Obscured-Lines-渲染模糊线条" class="headerlink" title="Rendering Obscured Lines 渲染模糊线条"></a>Rendering Obscured Lines 渲染模糊线条</h3><p><strong>在普通的线框图中，没有绘制表面，模型的所有边缘都是可见的。为了避免绘制被表面隐藏的线，将所有填充的三角形只绘制到z缓冲区中，然后正常绘制边缘。如果您不能在绘制所有线条之前绘制所有的表面，一个稍微昂贵一点的解决方案是用与背景匹配的纯色绘制表面。</strong></p>
<p><strong>线也可以绘制为部分模糊，而不是完全隐藏。例如，隐藏的线可以显示为浅灰色，而不是根本不画。这可以通过适当设置z-buffer的状态来实现。像以前一样绘制，然后反转z缓冲区的感觉，以便只绘制超出当前像素的z深度的线。同时关闭z缓冲区的修改，这样绘制的线不会改变任何深度值。用模糊的风格再画一遍线。只有那些被隐藏然后被画。对于行的程式化版本，可以使用完整的隐藏行删除过程。</strong></p>
<h3 id="Haloing-光晕"><a href="#Haloing-光晕" class="headerlink" title="Haloing 光晕"></a>Haloing 光晕</h3><p><strong>当两条线交叉时，通常的约定是擦除较远的线的一部分，使顺序明显。这可以相对容易地完成，每条线画两次，一次有一个光晕。此方法通过在其上绘制背景色来消除重叠。首先，在z-buffer中绘制所有的线条，将每条线表示为代表光晕的粗四边形。一个几何着色器可以帮助创建这样的四边形。然后，用正常的颜色画每一条线。被z-buffer绘制所掩盖的区域将隐藏其后面绘制的线。必须使用偏置或其他方法来确保每一条细黑线位于粗z缓冲区四边形的顶部。</strong></p>
<p><strong>相交于顶点的线可能被相互竞争的光晕部分隐藏。缩短产生光晕的四边形会有帮助，但也会导致其他的伪影。Bærentzen等人的线绘制技术也可以用于光晕。参见上图。晕圈是每个三角形产生的，所以没有干涉问题。另一种方法是使用图像后处理(章节15.2.3)来检测和绘制光晕。</strong></p>
<p><strong>下图显示了这里讨论的一些不同的线绘制方法的结果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027131552.png" class="" title="image-20211027131552">

<p>四行渲染样式。从左到右:线框、隐藏线、模糊线和晕线。</p>
<h2 id="Text-Rendering-文本渲染"><a href="#Text-Rendering-文本渲染" class="headerlink" title="Text Rendering 文本渲染"></a>Text Rendering 文本渲染</h2><p><strong>考虑到阅读文本对文明的重要性，人们花费大量的精力来渲染文本也就不足为奇了。与许多其他对象不同，单个像素的变化可以产生显著的差异，例如将“l”变成“1”。本节总结了用于文本渲染的主要算法方法。</strong></p>
<p><strong>眼睛对亮度的差异比对颜色的差异更敏感。这一事实至少在Apple II时代就已经被用于提高感知空间分辨率。这个想法的一个应用是微软的ClearType技术，它是建立在液晶显示(LCD)显示器的一个特性之上的。液晶显示器上的每个像素都由三个垂直的彩色矩形组成，红色、绿色和蓝色——使用液晶显示器上的放大镜，你可以自己看。不考虑这些亚像素矩形的颜色，这种配置提供的水平分辨率是像素的三倍。使用不同的阴影填充不同的亚像素，因此这种技术有时被称为亚像素渲染。眼睛将这些颜色混合在一起，红色和蓝色的条纹变得无法检测。参见下图。这项技术于1998年首次公布，对大型、低DPI LCD显示器有很大帮助。微软在Word 2013中停止使用ClearType，显然是因为混合不同背景颜色的文本存在问题。Excel、各种网络浏览器、Adobe的CoolType、苹果的Quartz 2D以及FreeType和SubLCD等库都使用了这种技术。Shemanarev的一篇古老而深入的文章涵盖了这种方法的各种微妙之处和问题。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027131845.png" class="" title="image-20211027131845">

<p>放大的灰度抗锯齿和亚像素抗锯齿版本的同一个词。当一个彩色像素显示在LCD屏幕上时，组成该像素的相应彩色垂直亚像素矩形被点亮。这样做提供了额外的水平空间分辨率。(图片由Steve Gibson的“Free &amp; Clear”程序生成。)</p>
<p><strong>这种技术是一个很好的例子，说明在清晰地呈现文本上花费了多少精力。一种字体中的字符，称为字形，通常由一系列线段和二次或三次B´ezier曲线来描述。参见第726页的图17.9以获得一个示例。所有字体渲染系统的工作都是确定字形如何影响它重叠的像素。像FreeType和Anti-Grain Geometry这样的库通过为每个符号生成一个小纹理并在需要时重用它们来工作。不同的纹理为每个字体大小和重点，即斜体或粗体。</strong></p>
<p><strong>这些系统假设每个纹理都是像素对齐的，每个像素一个像素，就像它通常用于文档一样。当文本应用于三维表面时，这些假设可能不再成立。使用带有一组符号的纹理是一种简单而流行的方法，但也有一些潜在的缺点。应用程序仍然可以将文本对齐到面向观众，但缩放和旋转将打破每像素一个像素的假设。即使屏幕对齐，字体提示也可能不被考虑在内。提示是调整字形轮廓以与像素单元匹配的过程。例如，一个像素宽的“I”的垂直杆最好是覆盖一列像素而不是半覆盖两个相邻的列。参见下图。所有这些因素都意味着光栅纹理会出现模糊或混叠问题。Rougier全面介绍了纹理生成算法涉及的问题，并展示了FreeType的提示如何在基于OpenGL的符号绘制系统中使用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027132013.png" class="" title="image-20211027132013">

<p>Verdana字体呈现无提示(上)和有提示(下)。(图片由Nicolas Rougier提供。)</p>
<p><strong>Pathfinder库是使用GPU生成符号的最新成果。它具有较低的设置时间和最少的内存使用，并优于竞争对手CPU-based引擎。它使用镶嵌和计算着色器来生成和总结每个像素上的曲线效果，并在性能较差的gpu上使用几何着色器和OpenCL。像FreeType一样，这些符号被缓存和重用。它的高质量反锯齿，再加上高密度显示器的使用，使得暗示几乎过时了。</strong></p>
<p><strong>在不需要精心设计的GPU支持的情况下，以不同大小和方向将文本应用到任意表面上，同时仍然提供合理的抗锯齿。Green提出了这样一个系统，最初是Valve在《军团要塞2》中使用的。该算法采用Frisken等人引入的采样距离场数据结构。每个texel保存符号到符号最近边缘的距离。距离字段试图在纹理描述中编码每个符号的精确边界。双线性插值然后给出一个很好的近似的alpha覆盖的字母在每个样本。如下图所示。尖锐的角可以通过双线性插值来平滑，但可以通过在四个单独的通道中编码更多的距离值来保留。这种方法的一个限制是，创建这些带符号的距离纹理非常耗时，因此需要预先计算和存储它们。然而，一些字体渲染库是基于这种技术的，并且它很好地适应于移动设备。Reshetov和Luebke总结了这些工作，并给出了他们自己的方案，这是基于在放大过程中调整样品的纹理坐标。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211027132129.png" class="" title="image-20211027132129">

<p>矢量纹理。在左边，字母“g”在它的距离域中表示。在右边，“禁止侵入”的标志是从远处的区域显示出来的。通过将特定的距离范围映射到轮廓颜色，可以添加文本周围的轮廓。(左图由ARM有限公司提供。右图来自Valve公司的《军团要塞2》。)</p>
<p><strong>例如，即使没有缩放和旋转问题，使用汉字的语言的字体也可能需要数千或更多的字形。高质量的大字符需要更大的纹理。如果以一定角度观察字形，则可能需要对纹理进行各向异性过滤。直接从它的边缘和曲线描述渲染符号将避免任意大纹理的需要，并避免来自采样网格的工件。Loop-Blinn方法使用像素着色器直接评估B´ezier曲线，将在17.1.2节中讨论。这种技术需要一个镶嵌步骤，在加载时执行这个步骤可能会非常昂贵。Dobbie通过为每个字符的边界框绘制一个矩形，并在一次通过中评估所有字形轮廓，避免了这个问题。Lengyel提出了一个健壮的评估器，用于判断一个点是否在符号内，这对于避免伪影至关重要，并讨论了评估优化和效果，如发光、阴影和多种颜色(如表情符号)。</strong></p>
<h1 id="16-Polygonal-Techniques-多边形技术"><a href="#16-Polygonal-Techniques-多边形技术" class="headerlink" title="16 Polygonal Techniques 多边形技术"></a>16 Polygonal Techniques 多边形技术</h1><p><strong>到目前为止，我们已经假设我们渲染的模型以我们需要的格式提供，并且具有适量的细节。在现实中，我们很少有这么幸运的。建模器和数据捕获设备有它们自己的特殊癖好和限制，这会在数据集和呈现中产生歧义和错误。通常需要在存储大小、呈现效率和结果质量之间进行权衡。在本章中，我们讨论了在多边形数据集中遇到的各种问题，以及这些问题的一些修复和变通方法。然后我们将介绍有效渲染和存储多边形模型的技术。</strong></p>
<p><strong>交互式计算机图形中多边形表示的首要目标是视觉的准确性和速度。“准确性”是一个取决于上下文的术语。例如，工程师希望以交互速度检查和修改一个机器部件，并要求物体上的每个斜角和倒角时刻可见。在游戏中，如果帧率足够高，那么在给定帧中出现的小错误或不准确是允许的，因为它们可能不会在注意力集中的地方出现，或者可能在下一帧中消失。在交互图形工作中，了解所解决问题的边界是很重要的，因为这些边界决定了可以应用什么类型的技术。</strong></p>
<p><strong>本章涉及的领域是镶嵌、巩固、优化、简化和压缩。多边形可以有许多不同的形式，通常必须被分割成更易于处理的原语，如三角形或四边形。这个过程叫做三角剖分，或者更通俗地说，镶嵌。整合是我们的术语，它包括将单独的多边形合并成一个网格结构，以及产生新的数据，如用于表面着色的法线。优化意味着在网格中对多边形数据进行排序，从而使其渲染更快。简化就是取一个网格并删除其中不重要的特征。压缩是关于最小化存储空间所需的各种元素描述的网格。</strong></p>
<p><strong>三角剖分确保给定的网格描述正确显示。通过允许共享计算并减少内存中的大小，合并进一步改善了数据显示，并经常提高速度。优化技术可以进一步提高速度。通过删除不必要的三角形，简化可以提供更快的速度。压缩可用于进一步减少总体内存占用，进而通过减少内存和总线带宽提高速度。</strong></p>
<h2 id="Sources-of-Three-Dimensional-Data-三维数据来源"><a href="#Sources-of-Three-Dimensional-Data-三维数据来源" class="headerlink" title="Sources of Three-Dimensional Data 三维数据来源"></a>Sources of Three-Dimensional Data 三维数据来源</h2><p><strong>有几种方法可以创建或生成多边形模型:</strong></p>
<pre><code>**•直接输入几何描述。**

**•编写创建此类数据的程序。这被称为过程建模。**

**•将其他形式的数据转化为表面或体积，例如，将蛋白质数据转化为一组球体和圆柱体。** 

**•使用建模程序建立或雕刻一个对象。**

**•从同一物体的一张或多张照片重建表面，称为摄影测量。**

**•使用三维扫描仪、数字化仪或其他传感设备，在不同的点对真实模型进行采样。** 

**•生成一个等值面，在空间的某些体积中表示相同的值，如CAT或MRI医学扫描的数据，或大气中测量的压力或温度样本。**

**•结合使用这些技术。** 
</code></pre>
<p><strong>在建模领域，有两种主要类型的建模器:基于实体的和基于表面的。基于实体的建模器通常出现在计算机辅助设计(CAD)领域，并且经常强调与实际加工过程相对应的建模工具，如切割、钻孔和刨平。在内部，他们将有一个计算引擎，严格地操作对象的底层拓扑边界。为了显示和分析，这些建模器都有面板。faceter是一种将内部模型表示转换成可以显示的三角形的软件。例如，一个球体在数据库中可以用一个中心点和一个半径来表示，而曲面可以将球体转换成任意数量的三角形或四边形来表示它。有时，最好的渲染加速是最简单的:当使用faceter时，降低所需的视觉精度可以提高速度，并通过生成更少的三角形节省存储空间。</strong></p>
<p><strong>CAD工作中一个重要的考虑因素是所使用的面是否是为图形渲染而设计的。例如，有限元方法(FEM)的面，旨在将表面分割成几乎相等面积的三角形。这种镶嵌是简化的有力候选，因为它们包含了许多在图形上无用的数据。类似地，一些面产生的三角形集合非常适合使用3D打印创建真实世界的对象，但缺乏顶点法线，通常不适合快速图形显示。</strong></p>
<p><strong>像Blender或Maya这样的建模器并不是基于内置的可靠性概念。相反，对象是由它们的表面定义的。像实体建模一样，这些基于表面的系统可以使用内部表示和面来显示物体，如样条或细分曲面(第17章)。它们还允许对曲面进行直接操作，例如添加或删除三角形或顶点。然后，用户可以手动降低模型的三角形计数。</strong></p>
<p><strong>还有其他类型的建模器，如隐式曲面(包括“blobby”metaball)创建系统，它们处理混合、权重和字段等概念。这些建模者可以通过生成由函数f(x, y, z) = 0的解定义的曲面来创建有机形式。然后使用多边形化技术(例如移动立方体)来创建用于显示的三角形集(第17.3节)。</strong></p>
<p><strong>点云是简化技术的有力候选者。这些数据通常是定期采样的，因此，许多采样对形成的表面的视觉感知的影响可以忽略不计。研究人员花了几十年的时间研究从点云中过滤缺陷数据和重建网格的技术。有关该区域的更多信息，请参阅第13.9节。</strong></p>
<p><strong>可以对由扫描数据生成的网格执行任意数量的清理或更高阶的操作。例如，分割技术分析一个多边形模型并试图识别单独的部分。这样做可以帮助创建动画、应用纹理地图、匹配形状和其他操作。</strong></p>
<p><strong>还有许多其他方法可以生成多边形数据来表示表面。关键是要理解数据是如何创建的，以及目的是什么。通常，生成数据不是为了有效的图形显示。此外，有许多不同的三维数据文件格式，在任何两种格式之间进行转换通常都不是无损操作。理解传入数据可能遇到的各种限制和问题是本章的主要主题。</strong></p>
<h2 id="Tessellation-and-Triangulation-镶嵌细分和三角测量"><a href="#Tessellation-and-Triangulation-镶嵌细分和三角测量" class="headerlink" title="Tessellation and Triangulation 镶嵌细分和三角测量"></a>Tessellation and Triangulation 镶嵌细分和三角测量</h2><p><strong>镶嵌是将一个曲面分割成一组多边形的过程。在这里，我们集中在镶嵌多边形表面;曲面镶嵌将在第17.6节中讨论。由于各种原因，可以进行多边形镶嵌。最常见的是所有的图形API和硬件都是为三角形优化的。三角形几乎就像原子一样，任何表面都可以用它们来制作和渲染。把一个复杂的多边形转换成三角形叫做三角剖分。</strong></p>
<p><strong>在划分多边形时有几个可能的目标。例如，要使用的算法可能只处理凸多边形。这种镶嵌称为凸划分。表面可能需要细分(网格)，以使用全局照明技术在每个顶点存储阴影或相互反射的效果。下图显示了这些不同类型的镶嵌的例子。镶嵌的非图形性原因包括一些要求，如没有三角形大于某些给定的面积，或三角形顶点上的角都大于某些最小角。Delaunay三角剖分要求每个三角形的顶点组成的每个圆不包含任何剩余的顶点，这使得最小角度最大化。虽然这些限制通常是非图形应用(如有限元分析)的一部分，但它们也可以改善表面的外观。长而细的三角形通常是值得避免的，因为当在远处的顶点上插入时，它们可能会造成伪影。栅格化也可能效率低下。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028120349.png" class="" title="image-20211028120349">

<p>各种类型的镶嵌。最左边的多边形不镶嵌，下一个被划分为凸区域，下一个被三角化，最右边被均匀网格化。</p>
<p><strong>大多数镶嵌算法在二维空间中工作。他们假设多边形上的所有点都在同一平面上。然而，一些模型创建系统可以生成严重扭曲和非平面的多边形面。这个问题的一个常见的例子是几乎边对边观察的扭曲四边形;这可能会形成所谓的沙漏或蝴蝶结四边形。参见下图。虽然这个特殊的多边形可以简单地通过创建一个对角线边来三角化，但更复杂的扭曲多边形却不容易管理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028120507.png" class="" title="image-20211028120507">

<p>弯曲的四边形，形成一个不明确的领结或沙漏形身材，以及两个可能的三角形。</p>
<p><strong>当可以弯曲多边形时，一个快速的纠正操作是将顶点投影到一个垂直于多边形近似法线的平面上。这个平面的法线通常是通过计算xy, xz, yz三个正交平面上的投影面积得到的。也就是说，去掉x坐标后，在yz平面上的多边形面积就是x分量的值，在xz平面上是y分量，在xy平面上是z分量。这种计算平均法线的方法被称为Newell公式。</strong></p>
<p><strong>投射到这个平面上的多边形可能仍然存在自交问题，即它的两条或多条边交叉。因此需要更精细和计算昂贵的方法。Zou等人讨论了以前基于最小化曲面面积或所得到镶嵌的二面角的工作，并提出了在一个集合中同时优化几个非平面多边形的算法。</strong></p>
<p><strong>Schneider和Eberly、Held、O ‘Rourke和de Berg等人各自对各种三角测量方法进行了概述。最基本的三角剖分算法是检查多边形上任意两个给定点之间的每一条线段，看它是否与多边形的任何边相交或重叠。如果是这样，线段就不能用来分割多边形，所以我们检查下一对可能的点。否则，使用此段将多边形分成两部分，并用相同的方法对这些新多边形进行三角化。这种方法在O(n³)时极其缓慢。</strong></p>
<p><strong>一种更有效的方法是剪耳(ear clipping)，这是O(n²)时，作为两个过程。首先，通过在多边形上寻找耳朵，也就是说，查看顶点索引为i， (i + 1)， (i + 2)(模n)的所有三角形，并检查线段i， (i + 2)是否与任何多边形边相交。如果没有，则三角形(i + 1)形成一个耳朵。参见下图。每个可用的耳朵依次从多边形中移除，顶点i和(i + 2)处的三角形重新检查，看看它们现在是不是耳朵。最后，所有的耳朵都被删除，多边形被三角化。其他更复杂的三角剖分方法是O(n log n)，有些方法对于典型情况是有效的O(n)。Schneider和Eberly给出了用于剪耳和其他更快的三角测量方法的伪代码。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028120834.png" class="" title="image-20211028120834">

<p>剪耳。有潜在耳朵的多边形在v2, v4,v5 处显示。在右边，耳朵在v4 是删除。相邻的顶点v3 和v5 重新检查它们是否形成了耳朵;v5 所做的事。</p>
<p><strong>与三角剖分相比，将多边形划分为凸区域在存储和进一步计算成本方面都更有效。鲁棒凸性代码检验由Schorn和Fisher给出。如第16.4节所述，凸多边形可以很容易地用扇形或三角形条来表示。有些凹多边形可以当作扇形处理(这种多边形称为星形)，但检测这些扇形需要更多的工作。Schneider和Eberly给出了两种凸划分方法，一种是快速脏法，另一种是最优法。</strong></p>
<p><strong>多边形并不总是由单一的轮廓线组成。下图显示了由三个轮廓组成的多边形，也称为循环或等高线。通过在循环之间小心地生成连接边(也称为钥匙孔边或桥边)，这样的描述总是可以转换为单轮廓多边形。Eberly]讨论了如何找到定义这些边的相互可见的顶点。这个转换过程也可以反过来检索单独的循环。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028121114.png" class="" title="image-20211028121114">

<p>一个有三个轮廓的多边形转换成一个单轮廓多边形。连接边用红色表示。多边形内的蓝色箭头表示访问顶点的顺序，以形成单个循环。</p>
<p><strong>编写一个健壮而通用的三角测量器是一项困难的任务。各种微妙的错误、病理情况和精度问题使得创建简单的代码非常棘手。解决三角剖分问题的一种方法是使用图形加速器本身直接渲染一个复杂的多边形。多边形被渲染为一个三角形扇形到模具缓冲区。通过这样做，应该填充的区域绘制奇数次，凹洞和洞绘制偶数次。通过使用模板缓冲区的反转模式，在第一次传递结束时只标记填充的区域。参见下图。在第二次传递中，使用模板缓冲区只允许绘制填充区域，再次渲染三角形扇形。这种方法甚至可以通过绘制每个循环形成的三角形来渲染具有多个轮廓的多边形。主要的缺点是，每个多边形必须使用两个通道渲染，模具缓冲区清除每一帧，深度缓冲区不能直接使用。该技术可以用于显示某些用户交互，例如显示动态绘制的复杂选择区域的内部。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028121155.png" class="" title="image-20211028121155">

<p>光栅化的三角测量，使用奇数/偶数奇偶校验的区域是可见的。左边的多边形作为从顶点0开始的三个三角形组成的扇形绘制到模具缓冲区中。第一个三角形[0,1,2] (左中)填充其区域，包括多边形外的空间。三角形[0,2,3] (右中)填充其区域，将区域A和区域B的奇偶校验变为偶数，从而使它们为空。三角形[0,3,4] (右)填充多边形的其余部分。</p>
<h3 id="Shading-Problems-着色问题"><a href="#Shading-Problems-着色问题" class="headerlink" title="Shading Problems 着色问题"></a>Shading Problems 着色问题</h3><p><strong>有时数据会以四边形网格的形式到达，为了显示，必须将其转换成三角形。在很长一段时间内，一个四边形将是凹的，在这种情况下，只有一种方法来三角化它。否则，我们可以从两者中任选其一对角线分割它。花一点时间选择更好的对角线有时可以得到明显更好的视觉效果。</strong></p>
<p><strong>有几种不同的方法来决定如何分割一个四边形。关键思想是最小化新边顶点的差异。对于顶点上没有额外数据的平面四边形，通常最好选择最短的对角线。对于每个顶点都有颜色的简单烘烤全局照明解决方案，选择颜色之间差异较小的对角线。参见下图。这种由启发式方法确定的连接两个最小不同角的想法，在最小化工件方面通常是有用的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028121455.png" class="" title="image-20211028121455">

<p>左边的图形被渲染成一个四边形;中间是两个三角形，右上和左下角相连;右边显示使用另一条对角线时会发生什么。中间的人比右边的人在视觉上要好。</p>
<p><strong>有时三角形不能正确地捕捉设计师的意图。如果一个纹理被应用到一个扭曲的四边形上，那么任何对角线的分割都不会保留意图。也就是说，在非三角形四边形上进行简单的水平插值。从左边缘到右边缘的插值值也失败了。下图显示了这个问题。出现这个问题是因为应用到表面上的图像在显示时将被扭曲。一个三角形只有三个纹理坐标，所以它可以建立仿射变换，而不是扭曲。三角形上的基本(u, v)纹理最多只能被剪切，不能被扭曲。Woo等人进一步讨论了这个问题。有几种可能的解决方案:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028121550.png" class="" title="image-20211028121550">

<p>左上角显示了设计师的意图，一个带有“R”的方形纹理贴图的扭曲四边形。“右边的两张图片显示了两种三角测量法以及它们的不同之处。底部行旋转所有多边形;非三角形四边形改变了它的外观。</p>
<p><strong>•弯曲纹理，并重新应用这个新图像，新的纹理坐标。</strong> </p>
<p><strong>•将表面镶嵌成更细的网格。这只会减轻问题。</strong></p>
<p><strong>•使用投射纹理在飞行中扭曲纹理。这就产生了表面纹理间距不均匀的不良影响。</strong></p>
<p><strong>•使用双线性映射方案。这可以通过每个顶点的额外数据实现。</strong> </p>
<p><strong>虽然纹理失真听起来像是一种病理情况，但在某种程度上，它会在应用的纹理数据与基础四边形的比例不匹配时发生。，几乎在任何曲面上。一个极端的情况发生在一个常见的原语上:圆锥。当一个圆锥体被纹理化和刻面化时，圆锥体顶端的三角形顶点有不同的法线。这些顶点法线不是由相邻三角形共享的，因此出现着色不连续现象。</strong></p>
<h3 id="Edge-Cracking-and-T-Vertices-边缘开裂和T-顶点"><a href="#Edge-Cracking-and-T-Vertices-边缘开裂和T-顶点" class="headerlink" title="Edge Cracking and T-Vertices 边缘开裂和T -顶点"></a>Edge Cracking and T-Vertices 边缘开裂和T -顶点</h3><p><strong>曲面，在第17章详细讨论，通常被镶嵌成网格来绘制。这种镶嵌是通过沿着样条曲线步进定义曲面，从而计算顶点位置和法线来完成的。当我们使用一个简单的步进方法时，问题可能会发生在样条曲面相遇的地方。在共用边，两个表面的点需要重合。由于模型的性质，有时可能会发生这种情况，但通常情况下，如果没有足够的小心，为一条样条曲线生成的点不会与它的邻居生成的点相匹配。这种效果被称为边缘开裂，当观众透过表面窥视时，它会导致令人不安的视觉伪影。即使观众不能透过裂缝看到，接缝经常是可见的，因为在着色的方式是内插。</strong></p>
<p><strong>修补这些裂缝的过程叫做边缝。目标是确保沿着(曲线)共享边的所有顶点被两个样条曲面共享，这样就不会出现裂缝。参见下图。第17.6.2节讨论了使用自适应镶嵌避免花键表面开裂。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028121851.png" class="" title="image-20211028121851">

<p>左边的图显示了两面相交处的裂缝。中间显示通过匹配边缘点固定的裂缝。右边显示修正后的网格。</p>
<p><strong>连接平面时遇到的一个相关问题是T顶点的问题。当两个模型的边相遇，但不共享它们周围的所有顶点时，就会出现这种问题。即使从理论上讲，边缘应该是完美的，但如果渲染器没有足够的精度来表示屏幕上的顶点位置，裂缝就会出现。现代图形硬件使用亚像素寻址来帮助避免这个问题。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211028122023.png" class="" title="image-20211028122023">

<p>在顶部行中，一个表面的底层网格显示了一个着色不连续。顶点b是一个T顶点，因为它属于它左边的三角形，但不是三角形acd的一部分。一个解决方案是将这个T顶点添加到这个三角形中，并创建三角形abd和bcd(没有显示出来)。长而细的三角形更有可能导致其他着色问题，所以重测通常是一个更好的解决方案，如下面一行所示。</p>
<p><strong>更明显的是可能出现的着色伪影，这与精度无关。上图显示了这个问题，可以通过找到这些边并确保与边界面共享公共顶点来解决这个问题。另外一个问题是使用简单的扇形算法生成退化(零面积)三角形的危险。例如，在图中，假设右上方的四边形abcd被三角形化成了三角形abc和acd。三角形abc是一个退化的三角，所以点b是T顶点。Lengyel讨论了如何找到这样的顶点，并提供了适当重新排列凸多边形的代码。Cignoni等人描述了一种方法，在已知T顶点位置时避免创建退化(零面积)三角形。他们的算法是O(n)，并保证最多产生一个三角形带和扇形。</strong></p>
<h2 id="Consolidation-整合"><a href="#Consolidation-整合" class="headerlink" title="Consolidation 整合"></a>Consolidation 整合</h2><p><strong>一旦模型通过了任何需要的镶嵌算法，我们就剩下一组代表模型的多边形。有一些操作可能对显示这些数据有用。最简单的方法是检查多边形本身是否正确形成，它是否至少有三个唯一的顶点位置，以及它们是否共线。例如，如果一个三角形中的两个顶点匹配，那么它就没有面积可以丢弃。请注意，在这一节中，我们真正指的是多边形，而不仅仅是三角形。根据您的目标，存储每个多边形可能更有效，而不是立即将其转换为三角形以供显示。三角剖分会产生更多的边，这又会为后续的操作增加更多的工作量。</strong></p>
<p><strong>一个通常应用于多边形的过程是合并，它在面之间找到共享的顶点。另一种操作叫做定位，在这个操作中，形成一个表面的所有多边形都面向相同的方向。对于不同的算法，如背面剔除、折痕边缘检测和正确的碰撞检测和响应，网格的方向是很重要的。与方向相关的是顶点法向生成，曲面看起来很光滑。我们称所有这些类型的技术为整合算法。</strong></p>
<h3 id="Merging-合并"><a href="#Merging-合并" class="headerlink" title="Merging 合并"></a>Merging 合并</h3><p><strong>一些数据以不连通多边形的形式出现，通常被称为多边形汤或三角形汤。存储单独的多边形会浪费内存，显示单独的多边形效率非常低。由于这些原因和其他原因，单个多边形通常合并到一个多边形网格中。简单地说，一个网格由一组顶点和一组轮廓线组成。每个顶点包含一个位置和其他可选数据，如着色法线、纹理坐标、切线向量和颜色。每个多边形轮廓都有一个整数索引列表。每个索引是一个从0到n−1的数字，其中n是顶点的数量，所以指向列表中的一个顶点。通过这种方式，每个顶点可以只存储一次，并被任意数量的多边形共享。三角形网格是一种只包含三角形的多边形网格。第16.4.5节深入讨论了网格存储方案。</strong></p>
<p><strong>给定一组不相连的多边形，合并可以有几种方法。一种方法是使用哈希。将顶点计数器初始化为零。对于每个多边形，尝试依次将其每个顶点添加到哈希表中，并基于顶点值进行哈希。如果一个顶点不在表中，将它与顶点计数器值一起存储在那里，然后递增;也将顶点存储在最后的顶点列表中。如果找到匹配的顶点，则检索它的存储索引。保存指向顶点的索引多边形。处理完所有多边形后，顶点和索引列表就完成了。</strong></p>
<p><strong>模型数据有时会带有分离多边形的顶点非常接近，但不完全相同的情况。合并这些顶点的过程称为焊接。有效地焊接顶点可以通过使用排序和一个较松的位置相等函数来完成。</strong></p>
<h3 id="Orientation-取向"><a href="#Orientation-取向" class="headerlink" title="Orientation 取向"></a>Orientation 取向</h3><p><strong>一个与模型数据质量相关的问题是面向面。有些模型数据的方向是正确的，表面法线或显式或隐式指向正确的方向。例如，在CAD工作中，标准是顶点在多边形轮廓中，当看到正面时，沿逆时针方向进行。这叫做弯曲方向三角形使用右手定则。想象你右手的手指以逆时针的顺序环绕多边形的顶点。然后你的拇指指向多边形的法线方向。这个方向独立于使用的左手或右手视图空间或世界坐标方向，因为它完全依赖于世界中的顶点的顺序，当观察三角形的前面时。也就是说，如果一个反射矩阵被应用到一个有方向的网格上，每个三角形的法线将与它的缠绕方向相反。</strong></p>
<p><strong>给定一个合理的模型，这里有一个方法来定位多边形网格:</strong></p>
<pre><code>**1.为所有多边形形成边面结构。** 

**2.对边进行排序或散列，以找到匹配的边。** 

**3.找到一组互相接触的多边形。** 

**4.对于每一组，根据需要翻脸以获得一致性。**
</code></pre>
<p><strong>第一步是创建一组半边对象。半边是多边形的一条边，它有一个指向其相关面(多边形)的指针。由于一条边通常由两个多边形共享，因此这种数据结构称为半边。使用排序顺序创建每个半边，将其第一个顶点存储在第二个顶点之前。如果一个顶点的x坐标较小，那么它的排序顺序是在另一个顶点之前。如果x坐标相等，则使用y值;如果匹配，则使用z。例如，顶点(- 3,5,2)在顶点(- 3,6，- 8)之前;−3s匹配，但5 &lt; 6。</strong></p>
<p><strong>目标是找出哪些边是相同的。由于每条边的存储都是为了让第一个顶点小于第二个顶点，所以比较边就是比较第一个顶点和第二个顶点。不需要将一条边的第一个顶点与另一条边的第二个顶点进行比较。哈希表可以用来查找匹配的边。如果所有的顶点之前已经被合并，因此半边使用相同的顶点索引，那么每个半边都可以通过将其放在与其第一个顶点索引相关联的临时列表中进行匹配。一个顶点平均有6条边附加在其上，使得一旦分组后的边匹配非常迅速。</strong></p>
<p><strong>一旦这些边被匹配，相邻多边形之间的连接就被知道了，形成了一个邻接图。对于三角形网格，这可以表示为每个三角形的(最多)三个相邻三角形面的列表。任何没有两个相邻多边形的边都是边界边。由边连接的多边形集合形成一个连续的组。例如，茶壶模型有两组，壶和盖。</strong></p>
<p><strong>下一步是给网格方向一致性，例如，我们通常希望所有的多边形都有逆时针的轮廓。对于每一组连续的多边形，选择一个任意的起始多边形。检查每一个邻近的多边形，确定方向是否一致。如果两个多边形的遍历方向相同，则相邻的多边形必须翻转。看到下图。递归地检查这些邻居的邻居，直到连续组中的所有多边形都被测试一次。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029155452.png" class="" title="image-20211029155452">

<p>选择一个起始多边形S并检查它的邻居。因为S和B共享的边的顶点是以相同的顺序(从x到y)遍历的，所以B的轮廓需要颠倒，以遵循右手法则。</p>
<p><strong>虽然在这一点上所有的面都是正确的方向，但它们都可能是向内的。在大多数情况下，我们希望它们面向外部。一个快速测试是否所有面都应该翻转的方法是计算组的带符号体积并检查符号。如果它是负的，反转所有的循环和法线。通过计算每个三角形的带符号的体积标量三重积来计算这个体积，然后把它们加起来。在realtimerendering.com的在线线性代数附录中查找体积计算。</strong></p>
<p><strong>这种方法适用于固体物体，但并非万无一失。例如，如果物体是一个形成房间的盒子，用户希望它的法线面向相机。如果对象不是实体，而是一个表面描述，那么面向每个表面的问题就会变得难以自动执行。假如，两个立方体沿着一条边接触，并且是同一网格的一部分，那么这条边将被四个多边形共享，从而使方向更加困难。像M¨obius条这样片面的物体永远不能完全朝向，因为内部和外部没有分离。即使是性能良好的表面网格，也很难确定哪一边应该朝外。Takayama等人讨论了以前的工作，并提出了他们自己的解决方案，从每个面投射随机光线，并确定哪个方向从外部更可见。</strong></p>
<h3 id="Solidity-坚固"><a href="#Solidity-坚固" class="headerlink" title="Solidity 坚固"></a>Solidity 坚固</h3><p><strong>非正式地说，如果一个网格是有方向的，并且所有从外部可见的多边形都有相同的方向，那么它就会形成一个实体。换句话说，只有网格的一面是可见的。这种多边形网格被称为封闭的或水密的。</strong></p>
<p><strong>知道一个物体是实心的意味着可以使用背面剔除来提高显示效率，如19.2节中讨论的那样。对于投射阴影的物体(第7.3节)和其他一些算法来说，实心度也是一个关键属性。例如，3D打印机要求打印的网格是固体的。</strong></p>
<p><strong>最简单的实性测试是检查网格中的每个多边形边缘是否恰好由两个多边形共享。这个测试对于大多数数据集来说已经足够了。这样的曲面松散地称为流形，具体地说，是两流形。从技术上讲，一个流形表面是没有任何拓扑不一致的，例如有三个或更多的多边形共享一条边，或两个或更多的角相互接触。形成立体的连续曲面是没有边界的流形。</strong></p>
<h3 id="Normal-Smoothing-and-Crease-Edges-常规平滑和折痕边缘"><a href="#Normal-Smoothing-and-Crease-Edges-常规平滑和折痕边缘" class="headerlink" title="Normal Smoothing and Crease Edges 常规平滑和折痕边缘"></a>Normal Smoothing and Crease Edges 常规平滑和折痕边缘</h3><p><strong>一些多边形网格形成曲面，但是多边形顶点没有法向量，所以它们不能被渲染成曲率的假象。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029155900.png" class="" title="image-20211029155900">

<p>左边的对象没有每个顶点的法线;右边的有。</p>
<p><strong>许多模型格式不提供表面边缘信息。有关各种类型的边，请参阅第15.2节。这些边的重要性有几个原因。它们可以突出显示由一组多边形组成的模型区域，也可以帮助进行非照片渲染。因为它们提供了重要的视觉线索，这样的边缘通常是为了避免被渐进网格算法简化(第16.5节)。</strong></p>
<p><strong>合理的折痕边和顶点法线通常可以成功地从一个有方向的网格中导出。一旦方向一致，并且推导出邻接图，顶点法线就可以通过平滑技术生成。模型的格式可以通过为多边形指定平滑组来提供帮助网。平滑组值用于明确定义组中的哪些多边形属于一起组成曲面。不同平滑组之间的边缘被认为是锐利的。</strong></p>
<p><strong>另一种光滑多边形网格的方法是指定一个折痕角度。这个值与二面角相比较，二面角是两个多边形的平面法线之间的夹角。值的范围通常在20到50度之间。如果两个相邻多边形之间的二面角小于指定的折痕角，则认为这两个多边形属于同一平滑组。这种技术有时被称为边缘保存。</strong></p>
<p><strong>使用折痕角度有时会给一个不适当的平滑，圆角的边缘应该被折痕，或反之亦然。经常需要试验，没有一个单一的角度可以完美地工作一个网格。即使是平滑组也有局限性。举个例子，当你把一张纸夹在中间。这张纸可以被认为是一个单独的平滑组，但是它里面有折痕，一个平滑组会将其平滑。然后建模者需要多个重叠平滑组，或直接在网格上定义折痕边缘。另一个例子是由三角形构成的圆锥。光滑圆锥的整个表面给出了特殊的结果，尖端有一个法线直接指向沿着圆锥的轴线。锥尖是一个奇点。为了完美地表示插值法线，每个三角形需要更像一个四边形，在这个尖端位置有两个法线。</strong></p>
<p><strong>幸运的是，这种有问题的情况通常很少见。一旦找到平滑组，可以计算组内共享顶点的顶点法线。寻找顶点法线的标准教科书解决方案是平均共享顶点的多边形的表面法线。然而，这种方法可能导致不一致的和糟糕的加权结果。Th¨urmer和W¨uthrich提出了一种替代方法，在这种方法中，每个多边形法线的贡献由它在顶点处形成的角度加权。该方法具有无论共享顶点的多边形是否三角化都能得到相同结果的理想特性。如果镶嵌多边形变成了，比如说，两个共享顶点的三角形，平均法将错误地施加两倍于两个三角形的影响，就像它对原始多边形的影响一样。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029160030.png" class="" title="image-20211029160030">

<p>在左边，一个四边形和两个三角形的表面法线被平均给一个顶点法线。在中间，四边形被三角化了。这将导致平均法线移动，因为每个多边形的法线是同等权重的。在右边，Th¨urmer和W¨uthrich的方法用构成它的两条边之间的夹角来加权每个法线的贡献，因此三角剖分不会移动法线。</p>
<p><strong>Max给出了一种不同的加权方法，基于长边构成的多边形对法线的影响较小的假设。当使用简化技术时，这种类型的平滑可能是更好的，因为形成的较大的多边形将不太可能遵循表面的曲率。</strong></p>
<p><strong>Jin等人对这些方法和其他方法进行了全面的调查，得出结论，按角度加权要么是最佳方法，要么是在各种条件下的最佳方法之一。Cignoni实现了Meshlab中的一些方法，并对此进行了注释。他还警告不要用相关三角形的面积来衡量每条法线的贡献。</strong></p>
<p><strong>对于高度场，Shankel展示了如何利用角度加权方法在每个轴上取相邻点的高度差来快速近似平滑。对于给定的点p和四个相邻点p^(x−1) 和在高度场的x轴上为p^(x +1)，在y轴上为p^(y−1) 和p^(y+1), p处(非标准化)法线的近似值为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029160243.png" class="" title="image-20211029160243">

<h2 id="Triangle-Fans-Strips-and-Meshes-三角形、条形和网格体"><a href="#Triangle-Fans-Strips-and-Meshes-三角形、条形和网格体" class="headerlink" title="Triangle Fans, Strips, and Meshes 三角形、条形和网格体"></a>Triangle Fans, Strips, and Meshes 三角形、条形和网格体</h2><p><strong>三角形列表是存储和显示一组三角形的最简单、通常也是效率最低的方法。每个三角形的顶点数据一个接一个地放在一个列表中。每个三角形都有自己独立的三个顶点集合，所以三角形之间不共享顶点数据。提高图形性能的标准方法是通过图形管道发送共享顶点的三角形组。共享意味着对顶点着色器的调用更少，因此需要转换的点和法线更少。在这里，我们描述了共享顶点信息的各种数据结构，从三角形扇形和条形开始，逐步发展到更精细、更高效的曲面渲染形式。</strong></p>
<h3 id="Fans-扇"><a href="#Fans-扇" class="headerlink" title="Fans 扇"></a>Fans 扇</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029160708.png" class="" title="image-20211029160708">

<p>左图说明了三角形扇子的概念。三角形T0 发送顶点v0 (中心顶点)，v1和v2。接下来的三角形Ti (i &gt; 0)，只发送顶点vi+2．右图是一个凸多边形，它总是可以变成一个三角形扇形。</p>
<p><strong>三角形风扇外观如上图所示。这个数据结构展示了我们如何形成三角形，并使每个三角形的存储成本小于3个顶点。所有三角形共享的顶点称为中心顶点，在图中为顶点0。对于开始三角形0，发送顶点0、1和2(按此顺序)。对于后续三角形，中心顶点总是与之前发送的顶点和当前正在发送的顶点一起使用。三角形1是通过发送顶点3而形成的，从而创建一个由顶点0(总是包含)，2(之前发送的顶点)和3定义的三角形。三角形2是通过发送顶点4来构造的，以此类推。请注意，一般的凸多边形用三角形扇形表示是不重要的，因为它的任何点都可以用作起点，中心顶点。</strong></p>
<p><strong>一个有n个顶点的三角形扇形被定义为一个有序的顶点列表</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029160824.png" class="" title="image-20211029160824">

<p><strong>在v0 是中心顶点，带有一个结构强加在列表上，表示三角形i是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029160832.png" class="" title="image-20211029160832">

<p><strong>其中0≤i &lt; n−2。</strong></p>
<p><strong>如果一个三角形扇形由m个三角形组成，则第一个三角形发送3个顶点，其余m-1三角形再发送1个顶点。这意味着顶点的平均数量va，表示为长度为m的连续三角形扇</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029161052.png" class="" title="image-20211029161052">

<p><strong>很容易看出，va→1表示m→∞。这似乎与现实世界的情况没有太大关联，但考虑一个更合理的值。如果m = 5，那么va = 1.4，这意味着，平均而言，每个三角形只有1.4个顶点被发送。</strong></p>
<h3 id="Strips-条"><a href="#Strips-条" class="headerlink" title="Strips 条"></a>Strips 条</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029161306.png" class="" title="image-20211029161306">

<p>可以表示为一个三角形带的三角形序列。注意，在条形图中，三角形的方向会随着三角形的不同而变化，条形图中的第一个三角形会设置所有三角形的方向。在内部，通过遍历顶点[0,1,2]，[1,3,2]，[2,3,4]，[3,5,4]等来保持逆时针顺序。</p>
<p><strong>三角形带就像三角形扇子，之前三角形中的顶点被重用。不是一个中心点和前面的顶点被重用，而是前一个三角形的两个顶点帮助形成下一个三角形。考虑上图。如果这些三角形被视为一条长条，然后可能会有一种更紧凑的方式将它们发送到渲染管道。对于第一个三角形(表示为T0)，所有三个顶点(记为v0, v1v2)，按此顺序发送。对于这个条带中的后续三角形，只需要发送一个顶点，因为其他两个顶点已经与前一个三角形一起发送了。例如，发送三角形T1，只有顶点v3 发送，顶点v1 和v2 从三角形T0 用来构成三角形T1．对于三角形T2，只有顶点v4 发送，以此条的其余部分。</strong></p>
<p><strong>一个有n个顶点的连续三角形带被定义为一个有序的顶点列表，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029161429.png" class="" title="image-20211029161429">

<p><strong>加上一个结构来表示三角形i是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029161442.png" class="" title="image-20211029161442">

<p><strong>其中0≤I &lt; n−2。这种条带被称为连续的，因为顶点是按照给定的顺序发送的。这个定义意味着一个有n个顶点的连续三角形带有n - 2个三角形。</strong></p>
<p><strong>分析长度为m的三角形带的平均顶点数。(由m个三角形组成)，也记为va，与三角形粉丝相同(见公式16.4)，因为它们有相同的启动阶段，然后每个新三角形只发送一个顶点。同理，当m→∞时，va 对于三角形来说，条带自然也倾向于每个三角形的一个顶点。对于m = 20, va = 1.1，比3好很多，接近1.0的极限。与三角形扇形一样，第一个三角形的启动成本(通常需要花费3个顶点)会平摊到后面的三角形上。</strong></p>
<p><strong>三角带的吸引力源于这个事实。根据瓶颈在渲染管道中的位置，有可能保存到三分之二的时间花在渲染简单的三角形列表上。这种加速是为了避免冗余操作，比如将每个顶点两次发送到图形硬件，然后对每个顶点执行矩阵转换、剪切和其他操作。三角形条带对于草的叶片或其他边缘顶点不被其他条带重用的对象很有用。由于它的简单性，当输出多个三角形时，几何着色器使用条带。</strong></p>
<p><strong>在三角形条带上有几种变体，例如不对三角形施加严格的序列，或使用双顶点或重新启动索引值，以便多个断开的条带可以存储在一个缓冲区中。曾经有很多关于如何最好地将任意三角形网格分解成条状的研究。随着索引三角形网格的引入，顶点数据可以更好地重用，这使得显示速度更快，通常需要的内存也更少。</strong></p>
<h3 id="Triangle-Meshes-三角形网格"><a href="#Triangle-Meshes-三角形网格" class="headerlink" title="Triangle Meshes 三角形网格"></a>Triangle Meshes 三角形网格</h3><p><strong>三角形扇形和条形仍然有它们的用途，但所有现代GPU的标准是使用带有单个索引列表的三角形网格(章节16.3.1)用于复杂模型。条形和扇形允许一些数据共享，但网状存储允许更多。在网格中，一个额外的索引数组跟踪哪些顶点构成三角形。这样，一个顶点可以与几个三角形相关联。</strong></p>
<p><strong>连通平面图的Euler-Poincar´e公式有助于确定形成封闭网格的顶点的平均数量:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029161803.png" class="" title="image-20211029161803">

<p><strong>这里v是顶点的数目，e是边的数目，f是面的数目，g是genus。genus是指物体上的孔数。例如，球面的genus为0，环面的genus为1。假设每个面都有一个环。如果面可以有多个循环，公式就变成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029161812.png" class="" title="image-20211029161812">

<p><strong>其中l是循环的个数。</strong></p>
<p><strong>对于一个封闭(实体)模型，每条边有两个面，每条面至少有三条边，因此2e≥3f。如果网格都是三角形，按照GPU的要求，则2e = 3f。假设genus为0，用1.5f代入公式中的e，得到f≤2v−4。如果所有面都是三角形，则f = 2v−4。</strong></p>
<p><strong>对于大型闭合三角形网格，经验法则是三角形的数量大约等于顶点数量的两倍。类似地，我们发现每个顶点平均连接着近6个三角形(因此，6条边)。连接到一个顶点的边的数目称为顶点的价。注意，网格的网络不会影响结果，只有三角形的数量会影响结果。由于条带中每个三角形的平均顶点数接近于1，而顶点是三角形的两倍，如果一个大网格由三角形条表示，每个顶点平均要发送两次。在极限情况下，三角形网格可以向每个三角形发送0.5个顶点。</strong></p>
<p><strong>注意，这种分析只适用于光滑的、封闭的网格。一旦有边界边(两个多边形之间没有共享的边)，顶点与三角形的比率就会增加。Euler-Poincar´e公式仍然成立，但网格的外部边界必须被视为与所有外部边缘接壤的单独的(未使用的)面。类似地，在任何模型中，每个平滑组实际上是它自己的网格，因为GPU需要在两组相交的锐边有不同法线的单独顶点记录。例如，立方体的一个角落将在一个位置上有三个法线，因此将存储三个顶点记录。纹理或其他顶点数据的变化也会导致不同顶点记录的数量增加。</strong></p>
<p><strong>理论预测我们需要处理每个三角形大约0.5个顶点。在实践中，顶点由GPU进行转换，并放入先进先出(FIFO)缓存，或近似于最近使用(LRU)系统。这个缓存保存通过顶点着色器运行的每个顶点的变换后结果。如果一个进入的顶点位于这个缓存中，那么缓存的后转换结果可以在不调用顶点着色器的情况下使用，提供了一个显著的性能提高。如果三角形网格中的三角形以随机顺序向下发送，那么缓存就不太可能有用。三角形带算法优化缓存大小为2，即使用的最后两个顶点。Deering和Nelson首先探索了将顶点数据存储在一个更大的FIFO缓存中的想法，使用一种算法来确定将顶点添加到缓存中的顺序。</strong></p>
<p><strong>FIFO缓存的大小是有限的。例如，PLAYSTATION 3系统包含大约24个顶点，这取决于每个顶点的字节数。新的GPU并没有显著增加这个缓存，32个顶点是典型的最大值。</strong></p>
<p><strong>Hoppe引入了一个衡量缓存重用的重要指标——平均缓存miss比率(ACMR)。这是每个三角形需要处理的顶点的平均数量。它可以从3(每个三角形的每个顶点每次都必须被重新处理)到0.5(在一个大型封闭网格上的完美重用;没有顶点被重新处理)。如果缓存大小与网格本身一样大，则ACMR与理论顶点与三角形的比值相同。对于给定的缓存大小和网格顺序，可以精确地计算ACMR，从而描述针对该缓存大小的任何给定方法的效率。</strong></p>
<h3 id="Cache-Oblivious-Mesh-Layouts-缓参无关网格布局"><a href="#Cache-Oblivious-Mesh-Layouts-缓参无关网格布局" class="headerlink" title="Cache-Oblivious Mesh Layouts 缓参无关网格布局"></a>Cache-Oblivious Mesh Layouts 缓参无关网格布局</h3><p><strong>网格中三角形的理想顺序是最大限度地使用顶点缓存。Hoppe提出了一种最小化网格ACMR的算法，但是缓存的大小必须事先知道。如果假设的缓存大小大于实际的缓存大小，那么得到的网格的好处就会大大减少。解决不同大小的缓存可能会产生不同的最优排序。针对目标缓存大小未知的情况，提出了缓参无关网格布局算法这就产生了无论大小都能正常运行的订单。这种排序有时被称为通用索引序列。</strong></p>
<p><strong>Forsyth和Lin and Yu提供了使用相似原理的快速贪婪算法。顶点根据它们在缓存中的位置和附加在它们上的未处理三角形的数量得到分数。接下来处理组合顶点得分最高的三角形。通过对最近使用的三个顶点的评分稍微低一些，算法避免了简单地制作三角形条，而是创建类似于希尔伯特曲线的模式。通过给仍然连接的三角形较少的顶点更高的分数，该算法倾向于避免留下孤立的三角形。达到的平均缓存miss比率可与那些更昂贵和复杂的算法相媲美。Lin和Yu的方法稍微复杂一些，但使用了相关的思想。当缓存大小为12时，一组30个未优化模型的平均ACMR为1.522;优化之后，平均下降到0.664或更低，具体取决于缓存大小。</strong></p>
<p><strong>Sander等人概述了之前的工作，并介绍了他们自己的更快(虽然不是与缓存大小无关)方法Tipsify。另外，他们还努力将最外面的三角形放在列表的早期，以减少透支(第18.4.5节)。例如，想象一个咖啡杯。通过先绘制杯子外部的三角形，之后的内部三角形可能会被隐藏起来。</strong></p>
<p><strong>Storsj¨o对比和比较了Forsyth和Sander的方法，并提供了这两种方法的实现。他总结道，这些方法提供的布局接近于理论极限。Kapoulkine的一项最新研究比较了三家硬件供应商的GPU上的四种感知缓存的顶点排序算法。他的结论是，英特尔使用128条目的FIFO，每个顶点使用3个或更多条目，而AMD和NVIDIA的系统近似使用16条目的LRU缓存。这种架构差异显著影响算法行为。他发现Tipsify和Forsyth算法在这些平台上的表现相对较好。</strong></p>
<p><strong>综上所述，对三角形网格进行离线预处理可以显著提高顶点缓存性能，且该顶点阶段的总体帧率是瓶颈。它在实践中是快速、有效的O(n)。有几个可用的开源版本。考虑到这样的算法可以自动应用到网格中，并且这样的优化没有额外的存储成本，也不影响工具链中的其他工具，这些方法通常是成熟开发系统的一部分。例如，Forsyth的算法似乎是PLAYSTATION网格处理工具链的一部分。虽然由于现代GPU采用了统一的着色器架构，顶点变换后缓存得到了发展，但避免缓存丢失仍然是一个重要的问题。</strong></p>
<h3 id="Vertex-and-Index-Buffers-Arrays-顶点和索引缓冲区-数组"><a href="#Vertex-and-Index-Buffers-Arrays-顶点和索引缓冲区-数组" class="headerlink" title="Vertex and Index Buffers/Arrays 顶点和索引缓冲区/数组"></a>Vertex and Index Buffers/Arrays 顶点和索引缓冲区/数组</h3><p><strong>提供带有模型数据的现代图形加速器的一种方法是使用DirectX调用顶点缓冲区和OpenGL调用顶点缓冲区对象(VBOs)。我们将在本节中使用DirectX术语。提出的概念具有OpenGL等价物。</strong></p>
<p><strong>顶点缓冲区的思想是将模型数据存储在一个连续的内存块中。顶点缓冲区是一种特定格式的顶点数据数组。格式指定顶点是否包含法线、纹理坐标、颜色或其他特定信息。每个顶点在一个组中都有它的数据，一个顶点接着一个顶点。顶点的字节大小称为它的步幅。这种类型的存储器称为交错缓冲器。或者，可以使用一组顶点流。例如，一个流可以保存一个位置数组{p0p1p2…}和另一个单独的法线数组{n0n1n2…}。在实践中，在GPU上，一个包含每个顶点所有数据的缓冲区通常更有效，但并不需要避免多个流。多流的主要成本是额外的API调用，如果应用程序是CPU绑定的，但在其他方面并不重要的话，可能值得避免。</strong></p>
<p><strong>Wihlidal讨论了多流帮助呈现系统性能的不同方法，包括API、缓存和CPU处理优势。例如，用于CPU上的向量处理的SSE和AVX更容易应用于单独的流。使用多流的另一个原因是为了更有效地更新网格。如果，比如说，只有顶点位置流在随时间变化，那么更新这个属性缓冲区的成本要比形成并发送整个交错流的成本要低。</strong></p>
<p><strong>如何访问顶点缓冲区取决于设备的DrawPrimitive方法。数据可视为:</strong></p>
<pre><code>**1.单个点的列表。** 

**2.不连通线段的列表，即顶点对。** 

**3.一个单一的多段线。** 

**4.一种三角形列表，其中每组三个顶点组成一个三角形，例如，顶点[0,1,2]组成一个，顶点[3,4,5]组成下一个，以此类推。** 

**5.一种三角形扇形，其中第一个顶点与每一对连续的顶点组成一个三角形，例如，[0,1,2]，[0,2,3]，[0,3,4]。** 

**6.一种三角形带，其中每一组连续的顶点构成一个三角形，例如, [0, 1, 2], [1, 2, 3], [2, 3, 4]。**
</code></pre>
<p><strong>在DirectX 10中，三角形和三角形带也可以包含相邻的三角形顶点，用于几何着色器(章节3.7)。</strong></p>
<p><strong>顶点缓冲区可以被索引缓冲区直接使用或引用。索引缓冲区中的索引保存顶点缓冲区中的顶点位置。索引存储为16位无符号整数，如果网格较大且GPU和API支持，则存储为32位整数(章节16.6)。索引缓冲区和顶点缓冲区的组合用于显示与“原始”顶点缓冲区相同类型的绘制原语。不同之处在于索引/顶点缓冲区组合中的每个顶点只需要存储只在顶点缓冲区中执行一次，而不需要索引就可以在顶点缓冲区中执行重复。</strong></p>
<p><strong>三角形网格结构由索引缓冲器表示。存储在索引缓冲区中的前三个索引指定第一个三角形，后三个索引指定第二个三角形，以此类推。这种排列称为索引三角形列表，其中索引本身构成三角形列表。OpenGL将索引缓冲区和顶点缓冲区与顶点数组对象(VAO)中的顶点格式信息绑定在一起。索引也可以按三角形带顺序排列，这样可以节省索引缓冲区空间。这种格式，索引三角形带，很少在实践中使用，因为为大型网格创建这样的带集需要一些努力，所有处理几何的工具也需要支持这种格式。顶点和索引缓冲区结构的例子见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029163105.png" class="" title="image-20211029163105">

<p>定义原语的不同方法，按照从上到下的内存使用的大致顺序:分开的三角形，作为一个顶点三角形列表，作为两个或一个数据流的三角形带，以及作为一个索引缓冲区，列出分开的三角形或按三角形带顺序。</p>
<p><strong>使用哪种结构由原语和程序决定。显示一个简单的矩形很容易，只需要一个顶点缓冲区，使用四个顶点作为一个两个三角形的三角形或扇形。如前所述，索引缓冲区的一个优点是数据共享。另一个优点是简单，三角形可以是任何顺序和配置，而不是三角形带的锁步要求。最后，当使用索引缓冲区时，需要在GPU上传输和存储的数据量通常会更小。包含索引数组的小开销远远大于共享顶点所节省的内存。</strong></p>
<p><strong>索引缓冲区和一个或多个顶点缓冲区提供了一种描述多边形网格的方法。然而，数据存储的目标通常是GPU渲染效率，而不是最紧凑的存储。例如，存储立方体的一种方法是将它的8个角位置保存在一个数组中，将它的6个不同的法线保存在另一个数组中，以及定义它的面的6个四索引循环。然后，每个顶点位置由两个索引描述，一个用于顶点列表，一个用于普通列表。纹理坐标由另一个数组和第三个索引表示。这种紧凑的表示在许多模型文件格式中使用，如Wavefront OBJ。在GPU上，只有一个索引缓冲区可用。一个顶点缓冲区将存储24个不同的顶点，因为每个角位置有三个独立的法线，每个相邻的面。索引缓冲区将存储定义构成曲面的12个三角形的索引。Masserann讨论了如何有效地将这种文件描述转换为紧凑而高效的索引/顶点缓冲区，而不是不共享顶点的未索引三角形列表。更紧凑的方案是可能的，例如将网格存储在纹理映射或缓冲区纹理中，并使用顶点着色器的纹理获取或拉取机制，但它们的性能代价是不能使用转换后的顶点缓存。</strong></p>
<p><strong>为了获得最大的效率，顶点缓冲区中的顶点的顺序应该与索引缓冲区访问它们的顺序相匹配。也就是说，索引缓冲区中第一个三角形引用的前三个顶点应该是顶点缓冲区中的前三个顶点。当索引缓冲区中遇到新顶点时，它应该是顶点缓冲区中的下一个顶点。给出这个顺序可以使变换前的顶点缓存的缓存丢失最小化，而变换前的顶点缓存与变换后的缓存是分开的16.4.4节。对顶点缓存中的数据重新排序是一项简单的操作，但对于性能来说，它与为变换后的顶点缓存找到一个有效的三角形顺序同样重要。</strong></p>
<p><strong>还有一些更高级的方法用于分配和使用顶点和索引缓冲区，以实现更高的效率。例如，一个不改变的缓冲区可以存储在GPU上以使用每一帧，并且一个对象的多个实例和变体可以从同一个缓冲区生成。第18.4.2节将深入讨论此类技术。</strong></p>
<p><strong>使用管线的流输出功能(章节3.7.1)将处理过的顶点发送到一个新的缓冲区的能力允许在GPU上处理顶点缓冲区而不渲染它们。例如，描述三角形网格的顶点缓冲区可以在初始过程中被视为简单的点集。顶点着色器可以用来执行每个顶点的计算，结果通过流输出发送到一个新的顶点缓冲区。在后续的过程中，这个新的顶点缓冲区可以与描述网格连通性的原始索引缓冲区配对，以进一步处理和显示生成的网格。</strong></p>
<h2 id="Simplification-简化"><a href="#Simplification-简化" class="headerlink" title="Simplification 简化"></a>Simplification 简化</h2><p><strong>网格简化，也被称为数据减少或抽取，是一个过程，采取一个详细的模型，减少其三角形计数，同时试图保持其外观。对于实时工作，这个过程是为了减少存储和发送到管道的顶点的数量。这对于使应用程序具有可伸缩性非常重要，因为功能较弱的机器可能需要显示较低数量的三角形。模型数据也可以通过比合理表示所必需的更多的镶嵌来接收。下图给出了如何通过数据简化技术来减少存储的三角形的数量。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029232902.png" class="" title="image-20211029232902">

<p>左上方是用20万个三角形渲染的火山口湖的高度场。右上方的图显示了这个模型简化为1000个三角形不规则网络(TIN)中的三角形。下面的简化网格显示在底部。(图片由迈克尔·加兰提供。)</p>
<p><strong>Luebke指出了三种类型的网格简化:静态的、动态的和依赖视图的。静态简化是指在渲染开始之前创建单独的细节级别(LOD)模型，由渲染器在这些模型中进行选择。本表格涵盖于第19.9节。离线简化也可以用于其他任务，如为细分曲面提供粗网格以细化。动态简化提供了LOD模型的连续谱，而不是少数的离散模型，因此这种方法被称为连续细节水平(continuous level of detail, CLOD)算法。依赖视图的技术适用于模型中细节级别不同的地方。具体来说，地形渲染是一种情况下，附近的区域需要详细的表示，而那些在远处的细节水平较低。本节将讨论这两种类型的简化。</strong></p>
<h3 id="Dynamic-Simplification-动态简化"><a href="#Dynamic-Simplification-动态简化" class="headerlink" title="Dynamic Simplification 动态简化"></a>Dynamic Simplification 动态简化</h3><p><strong>减少三角形数量的一种方法是使用边折叠操作，即通过移动其两个顶点使其重合来删除一条边。请参见下图，以查看该操作的实际示例。对于实体模型，边折叠总共删除了两个三角形、三条边和一个顶点。所以，一个有3000个三角形的封闭模型将会有1500条折边应用到它上，以将它减少到零面。经验法则是，一个有v个顶点的封闭三角形网格大约有2v个面和3v条边。这条规则可以通过Euler-Poincar´e公式导出，该公式为固体表面的f - e + v = 2(第16.4.3节)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029233309.png" class="" title="image-20211029233309">

<p>左边是uv边缘坍塌之前的图形;右图显示了点u坍缩成点v，从而去掉了三角形A和B以及边uv。</p>
<p><strong>边缘坍塌过程是可逆的。通过将边缘折叠的顺序存储，我们可以从简化的模型开始，从简化的模型开始重构复杂的模型。这个特性对于模型的网络传输非常有用，因为数据库的边缘折叠版本可以以有效压缩的形式发送，并在模型接收时逐步建立和显示。由于这个特性，这种简化过程通常被称为独立于视图的渐进式网格划分(VIPM)。</strong></p>
<p><strong>在上图中，u被折叠成v的位置，但v也可以被折叠成u。一个限制于这两种可能性的简化系统是使用子集布局策略。这种策略的一个优点是，如果我们限制可能性，我们可以含蓄地编码所做的选择。这个策略它更快，因为需要评估的可能性更少，但它也可能产生低质量的近似，因为检查了更小的解空间。</strong></p>
<p><strong>当使用最优放置策略时，我们检查了更广泛的可能性。不是将一个顶点压缩成另一个顶点，而是将一条边的两个顶点压缩到一个新的位置。Hoppe研究了u和v同时移动到连接它们的边缘上的某个位置的情况。他指出，为了改进最终数据表示的压缩，搜索可以局限于检查中点。Garland和Heckbert更进一步，解了一个二次方程来找到一个最佳位置，一个可能位于边缘之外的位置。最优布局策略的优势在于，它们倾向于提供更高质量的网格。缺点是需要额外的处理、代码和内存来记录更大范围的可能位置。</strong></p>
<p><strong>为了确定最佳的点位置，我们对局部邻域进行了分析。由于以下几个原因，这种局部性是一个重要而有用的特性。如果边折叠的代价只取决于几个局部变量(例如边长和边附近的面法线)，代价函数很容易计算，而且每次折叠只影响它的几个邻居。例如，假设一个模型有3000条可能的折叠边，这些边在一开始就被计算出来了。执行成本-功能值最低的边缘折叠。因为它只影响附近的几个三角形及其边，只有那些代价函数受这些变化影响的边坍塌可能性需要重新计算(比如，10而不是3000)，并且这个列表只需要少量的诉诸。因为边折叠只影响其他几个边折叠代价值，维护这个代价值列表的一个好的选择是使用堆或其他优先级队列。</strong></p>
<p><strong>无论成本如何，必须避免某些收缩。参见下图中的示例。这些可以通过检查相邻三角形是否由于坍缩而翻转其法线方向来检测。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029233508.png" class="" title="image-20211029233508">

<p>这是一个严重崩溃的例子。左边是顶点u折叠成v之前的网格，右边是折叠之后的网格，显示了现在的边是如何交叉的。</p>
<p><strong>折叠操作本身就是对模型数据库的编辑。用于存储这些崩溃的数据结构有很好的文档记录。用代价函数对每条边的折叠进行分析，并对代价值最小的边进行折叠下一个。最佳成本函数可以也将随模型类型和其他因素而变化。根据所解决的问题，成本函数可以在速度、质量、健壮性和简单性之间进行权衡。它也可以被裁剪以保持表面边界，材料位置，照明效果，沿轴的对称，纹理放置，体积，或其他约束。</strong></p>
<p><strong>我们将提出Garland和Heckbert的二次误差度量(QEM)代价函数，以给出这种函数如何工作的感觉。这个功能在很多情况下都是通用的。相比之下，在早期的研究中，Garland和Heckbert发现使用Hausdorff距离是简化地形的最佳方法，其他人也证实了这一点。这个函数就是简化网格中的顶点与原始网格之间的最长距离。上上图显示了使用此度量的结果。</strong></p>
<p><strong>对于一个给定的顶点，有一组共享它的三角形，每个三角形都有一个与之相关的平面方程。移动顶点的QEM成本函数是每个平面与新位置之间距离的平方和。更正式地,</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029233647.png" class="" title="image-20211029233647">

<p><strong>新位置v和m个平面的成本函数，其中ni 平面i的法线，di 是它与原点的偏移量。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029233923.png" class="" title="image-20211029233923">

<p>左边的图形显示了一个立方体，沿着一条边有一个额外的点。中间的图显示了当点e缩到角c时会发生什么。右边的图显示c缩到角e。</p>
<p><strong>上图显示了同一条边的两个可能收缩的例子。假设这个立方体有两个单位宽。崩溃的成本函数e为c (e→c)将是0,因为点e不离开平面的股票时c。c→e的成本函数是1,因为c远离平面向右转的多维数据集的平方距离1。因为它的成本更低，所以e→c坍塌比c→e更可取。</strong></p>
<p><strong>这个成本函数可以用各种方法修改。想象两个三角形共享一条形成尖锐边缘的边，例如，它们是鱼鳍或涡轮机叶片的一部分。在这条边上坍缩顶点的代价函数很低，因为沿一个三角形滑动的点不会远离另一个三角形的平面。基本功能的成本值与去除特征的体积变化有关，但不能很好地反映其视觉重要性。有一种方法来保持一条有尖锐折痕的边是添加一个额外的平面，包括这条边，并有一个法线，即两个三角形法线的平均值。现在，远离这条边的顶点将有一个更高的代价函数。一种变化是通过三角形面积的变化来加权代价函数。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029234222.png" class="" title="image-20211029234222">

<p>网格简化。左上显示原始网格13546个面，右上被简化为1000个面，左下为500个面，右下为150个面。(图片c 1996微软。版权所有。)</p>
<p><strong>另一种类型的扩展是使用基于维护其他表面特征的成本函数。例如，模型的折痕和边界边在描绘它时很重要，所以应该尽量减少修改的可能性。参见上图。其他值得保留的表面特征是有材质变化的位置、纹理贴图边缘和每顶点颜色变化的位置。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029234239.png" class="" title="image-20211029234239">

<p>网格简化。顶行:用网格和简单的灰色材质。底部一行:带有纹理。从左到右:模型包含51123、6389和1596个三角形。模型上的纹理被尽可能地维护，尽管一些失真会随着三角形计数的下降而增加。(图片c 2016微软。版权所有。)</p>
<p><strong>大多数简化算法都存在一个严重的问题，即纹理通常会明显偏离其原始外观。当边缘被折叠时，纹理到表面的底层映射可能会被扭曲。此外，纹理坐标值可以在边界上匹配，但属于纹理应用的不同区域，例如，沿着模型镜像的中心边缘。Caillaud等人研究了以前的各种方法，并提出了他们自己的处理纹理接缝的算法。</strong></p>
<p><strong>速度可能是另一个问题。在用户创建自己内容的系统中，例如在CAD系统中，需要动态地创建详细级别模型。使用GPU进行简化已经取得了一些成功。另一种方法是使用更简单的简化算法，如顶点集群。这种方法的核心思想是用三维体素网格或类似的结构覆盖模型。体素中的任何顶点都被移动到该单元格的“最佳”顶点位置。这样做可能会消除一些三角形，当每个三角形的两个或多个顶点落在同一位置时，使其退化。该算法具有较好的鲁棒性，不需要网格间的连通性，且易于对分离的网格进行聚合成一个。然而，基本的顶点集群算法很少能给出完整的QEM方法那样好的结果。Willmott(1890)讨论了他的团队是如何将这种集群方法有效地应用于《孢子》中的用户创造内容。</strong></p>
<p><strong>将表面的原始几何形状转化为凹凸贴图的法线贴图是一个与简化相关的想法。小的特征，如纽扣或皱纹，可以用纹理来表示，在保真度上几乎没有损失。Sander等人讨论了这一领域以前的工作，并提供了解决方案。这种算法通常用于开发交互式应用程序的模型，将高质量的模型烘焙到纹理表示中。</strong></p>
<p><strong>简化技术可以从单个复杂模型生成大量的详细程度(LOD)模型。在使用LOD模型时发现的一个问题是，如果一个模型在一帧和下一帧之间立即替换另一个模型，有时可以看到过渡。这个问题叫做“弹出”。“一种解决方案是使用地貌来增加或减少细节水平。因为我们知道复杂模型中的顶点是如何映射到简单模型的，所以可以创建一个平滑的过渡。有关更多细节，请参阅19.9.1节。</strong></p>
<p><strong>使用与视图无关的渐进式网格的一个优点是，单个顶点缓冲区可以一次性创建，并在相同模型的不同细节级别之间共享。然而，在基本方案下，需要为每个副本创建一个单独的索引缓冲区。另一个问题是效率。由于折叠的顺序决定了三角形的显示顺序，顶点缓存一致性较差。Forsyth讨论了在形成和共享索引缓冲区时提高效率的几种实用解决方案。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029234550.png" class="" title="image-20211029234550">

<p>对称问题。左边的圆柱体有10个平面(包括顶部和底部)。中间气缸有9个平面，1个平面通过自动减薄消除。右圆柱体有9个平面后被建模的faceter再生。</p>
<p><strong>网格缩减技术可能是有用的，但完全自动化的系统不是万灵药。保持对称的问题如上图所示。一个天才的模型制作者可以创造出低三角数的物体，质量比由自动化程序生成的。例如，眼睛和嘴巴是脸部最重要的部分。一个幼稚的算法会把这些当成无关紧要的事情处理掉。Retopology是在使用建模、平滑或简化技术时，将边缘添加到模型中以保持不同的特征分离的过程。与简化相关的算法将继续发展并尽可能实现自动化。</strong></p>
<h2 id="Compression-and-Precision-压缩和精度"><a href="#Compression-and-Precision-压缩和精度" class="headerlink" title="Compression and Precision 压缩和精度"></a>Compression and Precision 压缩和精度</h2><p><strong>三角形网格数据可以以各种方式压缩其数据，并可以获得类似的好处。正如PNG和JPEG图像文件格式使用无损和有损压缩纹理，各种算法和格式已经开发用于三角形网格数据的压缩。</strong></p>
<p><strong>压缩最小化了数据存储所花费的空间，以花费在编码和解码上的时间为代价。传输较小表示所节省的时间必须超过用于解压缩数据的额外时间。当在互联网上传输时，缓慢的下载速度意味着可以使用更复杂的算法。使用MPEG-4中采用的TFAN可以压缩和有效解码网格连接性。像Open3DGC、OpenCTM和Draco这样的编码器可以创建模型文件，与仅使用gzip压缩相比，这些文件的大小可以是四分之一或更小。使用这些方案的解压缩是一次性的操作，速度相对较慢——每秒几百万个三角形，但节省了传输数据的时间，这比支付成本还划算。Maglo等人对算法进行了全面的回顾。在这里，我们主要关注与GPU本身直接相关的压缩技术。</strong></p>
<p><strong>本章的大部分内容都是关于最小化三角形网格存储的各种方法。这样做的主要动机是提高渲染效率。在几个三角形之间重用顶点数据，而不是重复，将会减少缓存丢失。删除几乎没有视觉影响的三角形可以节省顶点处理和内存。更小的内存会导致更低的带宽成本和更好的缓存使用。GPU在内存中存储的东西也有限制，所以数据缩减技术可以让更多的三角形被显示出来。</strong></p>
<p><strong>顶点数据可以使用固定速率压缩，原因与纹理压缩类似(章节6.2.6)。通过固定速率压缩，我们指的是最终压缩存储大小已知的方法。每个顶点都有一个自包含的压缩形式，这意味着解码可以在GPU上进行。Calver提出了各种使用顶点着色器进行解压的方案。Zarge指出，数据压缩还可以帮助将顶点格式对齐到高速缓存行。Purnomo等人将简化和顶点量化技术结合起来，使用图像空间度量对给定的目标网格尺寸进行网格优化。</strong></p>
<p><strong>在索引缓冲区的格式中可以找到一种简单的压缩形式。索引缓冲区由一个无符号整数数组组成，该数组给出顶点缓冲区中顶点的数组位置。如果小于等于2^16 顶点缓冲区中的顶点，那么索引缓冲区就可以使用unsigned short而不是unsigned long。一些API对小于2^8的网格支持无符号字节顶点，但是使用这些会导致昂贵的对齐问题，所以通常是避免的。值得注意的是，OpenGL ES 2.0，未扩展的WebGL 1.0，以及一些旧的台式机和笔记本电脑GPU都有不支持无符号长索引缓冲区的限制，所以必须使用无符号短索引缓冲区。</strong></p>
<p><strong>另一个压缩机会是使用三角形网格数据本身。作为一个基本的例子，一些三角形网格为每个顶点存储一个或多个颜色，以表示内置光照、模拟结果或其他信息。在典型的监视器上，颜色由红色、绿色和蓝色的8位表示，因此数据可以以3个无符号字节而不是3个浮点数存储在顶点记录中。GPU的顶点着色器可以将这个字段转换成单独的值，然后在三角遍历期间进行插值。但是，应该注意许多体系结构。例如，苹果建议iOS将3字节的数据字段填充为4字节，以避免额外处理。参见下图中的中间插图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211029235006.png" class="" title="image-20211029235006">

<p>顶点数据的典型固定速率压缩方法。(来自Cigolle等，由Morgan McGuire提供。)</p>
<p><strong>另一种压缩方法是不存储任何颜色。例如，如果颜色数据显示温度结果，则温度本身可以存储为一个数字，然后转换为一维纹理中的颜色索引。更好的是，如果不需要温度值，那么可以使用一个无符号字节来引用这个颜色纹理。</strong></p>
<p><strong>即使温度本身被储存，它可能只需要几个小数点后的位置。浮点数的总精度为24位，比7位小数稍多一点。注意，16位几乎给出了5个精确的十进制数字。温度值的范围可能非常小，因此浮点格式的指数部分是不必要的。通过使用最小值作为偏移量和最高值减去最低值作为一个尺度，值可以在有限的范围内均匀分布。例如，如果值的范围从28.51到197.12，那么一个无符号短值将被转换为温度，首先将其除以2^16−1，然后乘以(197.12−28.51)的比例因子，最后加上偏移量28.51。通过存储数据集的比例和偏移因子，并将这些传递给顶点着色程序，数据集本身可以存储在一半的空间中。这种类型的变换称为标量量化。</strong></p>
<p><strong>顶点位置数据通常是这种缩减的一个很好的候选数据。单个网格在空间中跨度很小，所以为整个场景使用一个比例和偏移向量(或4 × 4矩阵)可以节省相当大的空间，而不会显著降低保真度。对于某些场景，可能会为每个对象生成一个比例和偏移量，从而增加每个模型的精度。然而，这样做可能会导致分离网格接触处出现裂缝。顶点最初在相同的世界位置，但在单独的模型可能被缩放和偏移到稍微不同的位置。当所有模型相对于场景整体来说都比较小时，一种解决方案是对所有模型使用相同的比例并对齐偏移量，这样可以增加一些精度。</strong></p>
<p><strong>有时，即使是顶点数据的浮点存储也不足以避免精度问题。一个经典的例子是在地球上空渲染的航天飞机。航天飞机模型本身可以精确到毫米尺度，但地球表面距离地球超过10万米，因此在尺度上相差8位。当航天飞机的世界空间位置相对于地球计算时，生成的顶点位置需要更高的精度。当没有采取任何纠正措施时，当观众靠近它时，梭子会在屏幕周围抖动。虽然航天飞机的例子是这个问题的一个极端版本，但如果在整个游戏中使用单一的坐标系统，大型多人游戏世界也会受到同样的影响。边缘上的物体会失去足够的精度，问题就会变得可见——动画的物体会晃动，单个顶点会在不同的时间被捕捉，阴影贴图的像素会随着相机的轻微移动而跳跃。一种解决方案是重做转换管道，这样，对于每个以原点为中心的对象，世界和摄像机的平移首先被连接在一起，所以基本上抵消了。另一种方法是分割世界并重新定义原点，使其位于每个部分的中心，然后将挑战从一个部分转移到另一个部分。Ohlarik和Cozzi and Ring对这些问题和解决方法进行了深入探讨。</strong></p>
<p><strong>其他顶点数据可能具有与之相关的特定压缩技术。纹理坐标通常被限制在[0.0,1.0]的范围内，因此通常可以安全地减少为无符号短裤，隐式偏移量为0，比例因子为2^16−1。通常有成对的值，可以很好地容纳两个unsigned short，甚至仅仅3字节，这取决于精度要求。</strong></p>
<p><strong>不同于其他坐标系，法线通常是标准化的，所以所有标准化法线的集合形成一个球体。由于这个原因，研究人员研究了球面到平面上的变换，以有效地压缩法线。Cigolle等人分析了各种算法的优势和权衡，并给出了代码样本。他们得出结论，八分仪和球面投影是最实用的，在有效解码和编码的同时最小化误差。Pranckeviˇcius和Pesce讨论了在为延迟着色生成G缓冲区时的正常压缩(第20.1节)。</strong></p>
<p><strong>其他数据可能具有可用于减少存储的属性。例如，法线、切线和双切线向量通常用于法线映射。当这三个向量相互垂直(不倾斜)，并且如果旋向是一致的，那么只有两个向量可以存储，第三个向量可以由叉乘导出。更紧凑的是，一个4字节的四元数用一个惯用位加上一个7位w可以表示基形成的旋转矩阵。为了更精确，可以省略四个四元数中最大的值，其他三个值以10位的方式存储。剩下的2位标识四个值中哪个没有被存储。由于四元数的平方和为1，我们可以从其他三个值推导出第四个值。Doghramachi等人使用正切/双正切/法线方案存储轴和角度。它也是4字节，与四元数存储相比，需要大约一半的着色器指令来解码。</strong></p>
<p><strong>一些固定速率压缩方法的总结见上图。</strong></p>
<h1 id="17-Curves-and-Curved-Surfaces-曲线和曲面"><a href="#17-Curves-and-Curved-Surfaces-曲线和曲面" class="headerlink" title="17 Curves and Curved Surfaces 曲线和曲面"></a>17 Curves and Curved Surfaces 曲线和曲面</h1><p><strong>三角形是一个基本的原子渲染原语。它是图形硬件调优后快速转换成阴影片段并放入framebuffer中的内容。然而，在建模系统中创建的对象和动画路径可以有许多不同的底层几何描述。曲线和曲面可以用方程精确地描述。对这些方程进行评估，然后创建一组三角形，并将其发送到管线中进行渲染。</strong></p>
<p><strong>使用曲线和曲面的好处至少有四:(1)它们具有比一组三角形更紧凑的表示，(2)它们提供可伸缩的几何原语，(3)它们提供比直线和平面三角形更平滑和更连续的原语，(4)动画和碰撞检测可能变得更简单和更快。</strong></p>
<p><strong>紧凑曲线表示为实时渲染提供了几个优势。首先，节省了模型存储的内存(从而提高了内存缓存效率)。这对于游戏机尤其有用，因为游戏机通常没有PC那么大的内存。变换曲面通常涉及的矩阵乘法比变换曲面的网格要少。如果图形硬件可以直接接受这样的曲面描述，主机CPU必须发送到图形硬件的数据量通常比发送一个三角形网格要少得多。</strong></p>
<p><strong>曲线模型描述，如PN三角形和细分曲面，有价值的性质，一个模型与少数多边形可以使更有说服力和现实。单个多边形被视为曲面，因此在曲面上创建更多的顶点。更高的顶点密度的结果是更好的光照表面和轮廓边缘与更高的质量。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031102405.png" class="" title="image-20211031102405">

<p>这是《使命召唤:高级战争》中的一个场景，角色Ilona的脸是使用Catmull-Clark细分曲面，使用第17.6.3节中的自适应四分树算法渲染的。(图片来源:动视出版公司2018年《使命召唤》)</p>
<p><strong>曲面的另一个主要优点是它们是可伸缩的。一个曲面描述可以变成2个三角形或2000个三角形。曲面是细节建模的一种自然形式:当曲面物体靠近时，对解析表示进行更密集的采样，生成更多的三角形。为在动画中，曲面的优点是需要动画的点数量要少得多。这些点可以用来形成一个曲面，然后可以生成一个光滑的镶嵌。此外，碰撞检测可能会更加高效和准确。</strong></p>
<p><strong>曲线和曲面的主题一直是整本书的主题。我们的目标是覆盖实时渲染中常见的曲线和表面。</strong></p>
<h2 id="Parametric-Curves-参数曲线"><a href="#Parametric-Curves-参数曲线" class="headerlink" title="Parametric Curves 参数曲线"></a>Parametric Curves 参数曲线</h2><p><strong>在这一节中，我们将介绍参数曲线。它们在许多不同的上下文中使用，并使用许多不同的方法实现。对于实时图形，参数曲线通常用于沿着预定义的路径移动查看器或某些对象。这可能包括改变位置和方向。然而，在本章中，我们只考虑位置路径。有关方向插值的信息，请参见第4.3.2节。另一个用途是渲染头发，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031102739.png" class="" title="image-20211031102739">

<p>使用镶嵌立方曲线绘制头发。(图片来自NVIDIA公司的“Nalu”演示。)</p>
<p><strong>假设您想要在一定的时间内将摄像机从一个点移动到另一个点，这与底层硬件的性能无关。举个例子，假设相机在这些点之间移动需要一秒钟，而渲染一帧需要50毫秒。这意味着我们将能够在这一秒内渲染20帧。在更快的计算机上，一帧可能只需要25毫秒，相当于每秒40帧，所以我们想要把摄像机移到40个不同的位置。用参数曲线可以找到任意一组点。</strong></p>
<p><strong>使用一些公式参数曲线描述点参数t的函数,在数学上,我们写成p (t),这意味着这个函数提供一个点的每个值t。参数t可能属于一些间隔,称为域,例如,t∈[a, b]。生成的点是连续的，即ε→0，则p(t + ε)→p(t)。松散地说，这意味着如果ε是一个很小的数字，那么p(t)和p(t + ε)是两个非常接近的点。</strong></p>
<p><strong>在下一节中，我们将从B´ezier曲线(一种常见的参数曲线形式)的直观和几何描述开始，然后将其放入数学设置中。然后讨论了如何使用分段B´ezier曲线，并解释了曲线连续性的概念。在17.1.4和17.1.5节中，我们将介绍另外两条有用的曲线，即三次Hermite和Kochanek-Bartels样条。最后，我们将在17.1.2节中介绍使用GPU渲染B´ezier曲线。</strong></p>
<h3 id="B´ezier-Curves-贝塞尔曲线"><a href="#B´ezier-Curves-贝塞尔曲线" class="headerlink" title="B´ezier Curves 贝塞尔曲线"></a>B´ezier Curves 贝塞尔曲线</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031103448.png" class="" title="image-20211031103448">

<p>两点之间的线性插值是直线上的路径(左)。对于7个点，线性插值显示在右上角，一些更平滑的插值显示在右下角。使用线性插值最令人反感的是线段之间连接处的不连续变化(突然的抖动)。</p>
<p><strong>线性插值在两点p之间画出一条路径，这是一条直线p0 和p1．这再简单不过了。参见上图中的左边插图。给定这些点，下面的函数描述了一个线性插值点p(t)，其中t是曲线参数，t∈[0,1]:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031103537.png" class="" title="image-20211031103537">

<p><strong>参数t控制点p(t)在直线上的位置;p (0) = p0， p(1) = p1， 0 &lt; t &lt; 1是p0 和p1之间直线上的一个点．如果我们想把摄像机从p0到p1 一秒内20步线性，然后我们用ti = i/(20−1)，其中i是帧号(从0开始到19结束)。</strong></p>
<p><strong>当你只在两点之间进行插值时，线性插值可能就足够了，但如果在一条路径上有更多的点，通常就不行了。例如，当插入几个点时，连接两段的点(也称为关节)上的突然变化是不可接受的。如上图右侧所示。</strong></p>
<p><strong>为了解决这个问题，我们进一步采用了线性插值的方法，并进行了多次线性插值。通过这样做，我们得到了B´ezier(发音为beh-zee-eh)曲线的几何结构。作为一个历史笔记，B´ezier曲线是由Paul de Casteljau和Pierre B´ezier独立开发的，用于法国汽车工业。它们被称为B´ezier曲线，因为B´ezier能够在de Casteljau之前公开他的研究，尽管de Casteljau在B´ezier之前写了他的技术报告。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031103925.png" class="" title="image-20211031103925">

<p>重复线性插值给出了B´ezier曲线。曲线被定义为三个控制点,a, b和c。如果我们想要找到曲线上的点的参数t = 1/3,我们第一次线性插入a和b之间d。接下来,e是插值b和c。最后一点,p (1/3) = f 是在d和e之间的插值。</p>
<p><strong>首先，为了能够重复插值，我们必须添加更多的点。例如，可以使用三个点，a、b和c，称为控制点。我们想求出p(1/3)也就是t = 1/3时，曲线上的点。我们使用t = 1/3，通过a &amp; b和b &amp; c的线性插值计算两个新点d和e。参见上图。最后，我们用d和e的线性插值来计算t = 1/3。我们定义p(t) = f，利用这种方法，我们得到如下关系:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031104042.png" class="" title="image-20211031104042">

<p><strong>这是一条抛物线，因为t的最大次数是2。事实上，给定n + 1个控制点，曲线的自由度是n。这意味着更多的控制点会给曲线更多的自由度。一阶曲线称为直线(称为线性曲线)，二阶曲线称为二次曲线，三阶曲线称为三次曲线，四阶曲线称为四次曲线，以此类推。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031104212.png" class="" title="image-20211031104212">

<p>从五个点重复线性插值得到四度(四次)B´ezier曲线。曲线位于控制点的凸包(绿色区域)内，用黑点标记。同样，在第一点，曲线与第一点和第二点之间的直线相切。这同样适用于曲线的另一端。</p>
<p><strong>这种重复或递归线性插值通常被称为de Casteljau算法。上图显示了使用5个控制点时的示例。为了一般化，不像本例中那样使用a-f点，而是使用以下符号。控制点用pi表示，所以在这个例子中，p0 = a, p1 = b, p2 = c，然后线性插值k次，得到中间控制点pi^k。在我们的例子中,我们有p₀¹ = d, p₁¹ = e, p₀² = f。n + 1个控制点的B´ezier曲线可以用下面的递归公式描述，其中pi⁰ = pi 是最初的控制点:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031104616.png" class="" title="image-20211031104616">

<p><strong>注意曲线上的一个点用p(t) = p0^n (t)来描述.这并不像看起来那么复杂。再考虑一下，当我们从三个点p0，p1和p2，相当于p₀⁰ , p₁⁰ 和p₂⁰。三个控制点表示n = 2。为了简化公式，有时把“(t)”从p中去掉。第一步k = 1，得到p10 =(1−t)p0 + tp1， p11 =(1−t)p1 + tp2．最后，对于k = 2，我们得到p₀² =(1−t)p₀¹ + tp₁¹，这和求p(t)是一样的。下图展示了其工作原理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031105050.png" class="" title="image-20211031105050">

<p>说明重复线性插值如何工作的B´ezier曲线。在本例中，给出了四次曲线的插值。这意味着有5个控制点，pi⁰ ， I = 0, 1, 2, 3, 4，如下所示。图应该是自下而上的阅读,也就是说,p₀¹由p₀⁰加权构成权重为1−t和加权p₁⁰以t加权。这继续,直到曲线的点p (t)获得。(高盛之后的插图。)</p>
<p><strong>现在我们已经掌握了B´ezier曲线的基本原理，我们可以看看对相同曲线的更数学的描述。</strong></p>
<h4 id="Bezier-Curves-Using-Bernstein-Polynomials-使用Bernstein多项式的贝塞尔曲线"><a href="#Bezier-Curves-Using-Bernstein-Polynomials-使用Bernstein多项式的贝塞尔曲线" class="headerlink" title="Bezier Curves Using Bernstein Polynomials 使用Bernstein多项式的贝塞尔曲线"></a>Bezier Curves Using Bernstein Polynomials 使用Bernstein多项式的贝塞尔曲线</h4><p><strong>如公式17.2所示，二次B´ezier曲线可以用代数公式来描述。原来每一条B´ezier曲线都可以用这样一个代数公式来描述，这意味着你不需要做重复的插值。如下式17.4所示，得到的曲线与式17.3所描述的曲线相同。这种B´ezier曲线的描述被称为Bernstein形式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031122705.png" class="" title="image-20211031122705">

<p><strong>该函数包含Bernstein多项式，有时也称为B´ezier基函数，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031122735.png" class="" title="image-20211031122735">

<p><strong>这个方程的第一项二项式系数在第一章的式1.6中定义。Bernstein多项式的两个基本性质如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031122751.png" class="" title="image-20211031122751">

<p><strong>第一个公式表示Bernstein多项式在0到1之间当t也在0到1之间。第二个公式表示方程17.4中所有Bernstein多项式项对曲线的所有不同度求和为1(如下图所示)。松散地说，这意味着曲线将保持“接近”控制点pi．事实上，整个B´ezier曲线将位于控制点的凸包(参见我们的在线线性代数附录)，它遵循方程17.4和17.6。当计算曲线的边界面积或体积时，这是一个有用的属性。参见上上图中的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031122919.png" class="" title="image-20211031122919">

<p>n = 1, n = 2, n = 3的伯恩斯坦多项式(从左到右)。左图为线性插值，中间为二次插值，右图为三次插值。这些是B´ezier曲线的Bernstein形式中使用的混合函数。因此，要计算某一特定t值的二次曲线(中间图)，只需在x轴上找到t值，然后垂直移动，直到遇到三条曲线，这就给出了三个控制点的权重。注意，当t∈[0,1]时，Bin(t)≥0，以及这些混合函数的对称性:Bi^n(t) = Bn−i^n(1−t)。</p>
<p><strong>上图给出了n = 1, n = 2, n = 3时的Bernstein多项式。这些也被称为混合函数。n = 1(线性插值)的情况是有说明意义的，因为它显示了y = 1−t和y = t的曲线。这意味着当t = 0时，p(0) = p0，当t增大时，p0 减小，而p1 增加相同的数量，保持权重的总和等于1。最后，当t = 1时，p(1) = p1．一般情况下，对于p(0) = p0 p(1) = pn的所有B´ezier曲线均成立，端点被插值(即在曲线上)。曲线与向量p1 −p0相切也是正确的从t = 0到t = 1时pn −pn−1 。另一个有用的特性是，可以先旋转控制点，然后再计算曲线上的点，而不是先计算B´ezier曲线上的点，然后再旋转曲线。在曲线上通常控制点比生成的点要少，所以先对控制点进行变换效率更高。</strong></p>
<p><strong>以Bernstein版本的B´ezier曲线为例，假设n = 2，即一条二次曲线。则式17.4为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031123314.png" class="" title="image-20211031123314">

<p><strong>与17.2式相同。注意，上面的混合函数(1−t)²,2t(1−t)和t²是上图中间显示的函数。用同样的方法，将三次曲线简化为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031123439.png" class="" title="image-20211031123439">

<p><strong>方程可以写成矩阵形式</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031123449.png" class="" title="image-20211031123449">

<p><strong>这在做数学化简时很有用。</strong></p>
<p><strong>通过收集形式为t^k 的项由式17.4可以看出，每条B´ezier曲线都可以写成如下形式，称为幂次形式，其中ci 是通过收集条款而产生的观点:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031123537.png" class="" title="image-20211031123537">

<p><strong>为了得到B´ezier曲线的导数，可以直接对方程17.4进行微分。重组和收集项后的结果如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031123604.png" class="" title="image-20211031123604">

<p><strong>实际上，导数也是一条B´ezier曲线，但比p(t)低一度。</strong></p>
<p><strong>B´ezier曲线的一个潜在缺点是，它们不能通过所有的控制点(除了端点)。另一个问题是，随着控制点的增加，这种程度也在增加，使得评价变得越来越昂贵。解决这个问题的方法是在每一对后续控制点之间使用一条简单的低度曲线，并确保这种分段插值具有足够高的连续性。这是17.1.3-17.1.5节的主题。</strong></p>
<h4 id="Rational-Bezier-Curves-有理贝塞尔曲线"><a href="#Rational-Bezier-Curves-有理贝塞尔曲线" class="headerlink" title="Rational Bezier Curves 有理贝塞尔曲线"></a>Rational Bezier Curves 有理贝塞尔曲线</h4><p><strong>虽然B´ezier曲线可以用于许多事情，但它们没有那么多的自由度——只有控制点的位置可以自由选择。同时，并不是每一条曲线都能用B´ezier曲线来描述。例如，圆通常被认为是一个简单的形状，但它不能由一条或一组B´ezier曲线定义。一种选择是理性的B´ezier曲线。这种类型的曲线由式17.12所示的公式描述:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031125606.png" class="" title="image-20211031125606">

<p><strong>分母是Bernstein多项式的加权和，分子p(t) = Pi=0</strong></p>
<p><strong>是标准B´ezier曲线的加权版本(公式17.4)。对于这种类型的曲线，用户拥有权值wi，作为额外的自由度。关于这些曲线的更多信息可以在Hoschek和Lasser的和Farin的书中找到。Farin还描述了如何用三条有理B´ezier曲线来描述圆。</strong></p>
<h3 id="Bounded-B´ezier-Curves-on-the-GPU-GPU上有界贝塞尔曲线"><a href="#Bounded-B´ezier-Curves-on-the-GPU-GPU上有界贝塞尔曲线" class="headerlink" title="Bounded B´ezier Curves on the GPU GPU上有界贝塞尔曲线"></a>Bounded B´ezier Curves on the GPU GPU上有界贝塞尔曲线</h3><p><strong>本文将介绍在GPU上绘制B´ezier曲线的方法。具体来说，目标是“有界B´ezier曲线”，即填充曲线和第一个和最后一个控制点之间的直线之间的区域。有一种非常简单的方法可以做到这一点，即使用专门的像素着色器渲染一个三角形。</strong></p>
<p><strong>我们用二次方程，也就是二度，B´ezier曲线，控制点p0,p1和p2．如果我们设置这些顶点的纹理坐标为t0 = (0,0)， t1 = (0.5, 0) ，t2 =(1,1)，纹理坐标将在渲染三角形∆p0p1p2时像往常一样被插值．我们还计算每个像素在三角形内的标量函数，其中u和v是插值的纹理坐标:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031130152.png" class="" title="image-20211031130152">

<p><strong>像素着色器然后确定像素是在内部(f(u, v) &lt; 0)还是在外部。如下图所示。当使用这个像素着色器渲染透视投影三角形时，我们将得到相应的投影B´ezier曲线。Loop和Blinn给出了证明。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031130302.png" class="" title="image-20211031130302">

<p>有界B´ezier曲线渲染。左:曲线显示在标准纹理空间。右:曲线在屏幕空间中呈现。如果使用条件f(u, v)≥0来杀死像素，则渲染会产生浅蓝色区域。</p>
<p><strong>例如，这种技术可以用于渲染TrueType字体。如下图所示。Loop和Blinn还演示了如何渲染有理二次曲线曲线和三次曲线，以及如何使用这种表示来抗锯齿。由于文本呈现的重要性，这一领域的研究仍在继续。相关算法请参见第15.5节。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031130443.png" class="" title="image-20211031130443">

<p>一个e由几条直线和二次B´ezier曲线(左)表示。在中间，这个表示被“镶嵌”成几个有边界的B´ezier曲线(红色和蓝色)和三角形(绿色)。最后一个字母显示在右边。(经微软公司许可转载)</p>
<h3 id="Continuity-and-Piecewise-B´ezier-Curves-贝塞尔曲线"><a href="#Continuity-and-Piecewise-B´ezier-Curves-贝塞尔曲线" class="headerlink" title="Continuity and Piecewise B´ezier Curves 贝塞尔曲线"></a>Continuity and Piecewise B´ezier Curves 贝塞尔曲线</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031131233.png" class="" title="image-20211031131233">

<p>该图从左到右显示了两条三次B´ezier曲线(各有四个控制点)之间C⁰、G¹和C¹的连续性。上面一行显示控制点，下面一行显示曲线，左边曲线有10个样本点，右边曲线有20个样本点。以下时间点对用于本示例：(0.0, q0), (1.0, q3)和 (3.0, r3)．与C⁰ 连续性，在连接处有一个突然的震动(q³ = r⁰)。G¹改进了这一点，使连接处的切线平行(长度相等)。然而，由于3.0−1.0 ≠ 1.0−0.0，这并没有给C¹连续性。这可以在连接处看到，在那里有一个突然的加速度的样本点。实现C¹，连接点的右切线必须是左切线的两倍长。</p>
<p><strong>假设我们有两条三次B´ezier曲线，也就是说，每条曲线由四个控制点定义。第一条曲线由qi定义，第二个是ri， i = 0,1,2,3。为了连接这些曲线，我们可以设置q3 = r0．这个点叫做关节(joint)。然而，如上图所示，使用这种简单的技术，关节不会平滑。由若干条曲线(本例为两条)组成的复合曲线称为分段B´ezier曲线，这里用p(t)表示。更进一步，假设我们想要p(0) = q0， p(1) = q3 = r0， p(3) = r3．因此，当我们到达q0的时候,q3 = r0和r3,t0 = 0.0,t1 = 1.0, t2 = 3.0。参见上图的表示法。从上一节我们知道B´ezier曲线被定义为t∈[0,1]，所以这对于由qi定义的第一个曲线段来说是很好的从q0 是0.0,到q3 是1.0时间。但是当1.0 &lt; t≤3.0时会发生什么呢?答案很简单:我们必须使用第二段曲线，然后从[t1，t2]开始平移和缩放参数区间到[0,1]。这可以使用下面的公式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031132131.png" class="" title="image-20211031132131">

<p><strong>因此，它是t′ 输入由r定义的B´ezier曲线段i的年代。这很容易推广到将几个B´ezier曲线拼接在一起。</strong></p>
<p><strong>连接曲线的一个更好的方法是，在B´ezier曲线的第一个控制点，切线平行于q1 −q0 (部分17.1.1)。同样，在最后一个控制点，三次曲线与q3−q2相切。这种行为是显而易见的如图17.5所示。所以，为了使两条曲线在关节处相切，第一条曲线和第二条曲线的切线应该在这里平行。更正式的说法是:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031132242.png" class="" title="image-20211031132242">

<p><strong>这简单地说就是输入的切线 q3 −q2，在关节处的方向应该与向外的切线r1 −r0方向相同．</strong></p>
<p><strong>有可能达到比这更好的连续性，在上式中使用由下式定义的c:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031132449.png" class="" title="image-20211031132449">

<p><strong>这也显示在上图中。如果我们设t2 = 2.0，则c = 1.0，因此当各曲线段的时间间隔相等时，则入射和输出的切向量应该相同。然而，当t2 = 3.0。曲线看起来是相同的，但是p(t)在复合曲线上的移动速度将不是平滑的。方程17.16中的常数c处理了这个问题。</strong></p>
<p><strong>使用分段曲线的一些优点是可以使用低阶曲线，并且生成的曲线将经过一组点。在上面的例子中，三级，即为两个曲线段的每一个使用立方。三次曲线通常用于此，因为这些是最低度曲线，可以描述一个S形曲线，称为拐点。得到的曲线p(t)插值，即经过点q0,q3 = r0和r3．</strong></p>
<p><strong>在这一点上，通过实例介绍了两个重要的连续性措施。下面是曲线连续性概念的一个稍微数学化的表述。对于一般的曲线，我们用C^n 区分关节处不同类型的连续性的符号。这意味着所有的n阶导数在曲线上都是连续的非零的。C⁰的连续性意味着线段应该在同一点上连接，所以线性插值满足这个条件。本节中的第一个示例就是这样。C¹的连续性意味着，如果我们在曲线上的任何一点(包括关节)推导一次，结果也应该是连续的。这是本节中的第三个示例的情况，其中使用了方程17.16。</strong></p>
<p><strong>还有一个度量，表示为G^n。让我们以G¹(几何)连续性为例。因此，在一个关节处相交的曲线段的切向量应该是平行的，并且有相同的方向，但是没有关于长度的假设。换句话说，G¹的连续性比C¹弱，而C¹的曲线总是G¹，除非两条曲线在相交点的速度为零且在相交点之前有不同的切线。几何连续性的概念可以推广到高维空间。上图中间的插图显示了G¹连续性。</strong></p>
<h3 id="Cubic-Hermite-Interpolation-立方Hermite插值"><a href="#Cubic-Hermite-Interpolation-立方Hermite插值" class="headerlink" title="Cubic Hermite Interpolation 立方Hermite插值"></a>Cubic Hermite Interpolation 立方Hermite插值</h3><p><strong>B´ezier曲线很好地描述了平滑曲线构建背后的理论，但有时无法预测使用。在本节中，我们将介绍三次埃尔米特插值，这些曲线往往更容易控制。原因是，三次埃尔米特曲线不是用四个控制点来描述三次B´ezier曲线，而是用起点和终点 p0 和p1来定义三次埃尔米特曲线，开始和结束切线 m0 和m1．Hermite插值，p(t)，其中t∈[0,1]，为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031133337.png" class="" title="image-20211031133337">

<p><strong>我们也称p(t)为埃尔米特曲线段或三次样条曲线段。这是一个三次插值，因为在上面的公式中，t³是混合函数的最高指数。对于这条曲线，下面是成立的:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031133454.png" class="" title="image-20211031133454">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031133623.png" class="" title="image-20211031133623">

<p>埃尔米特三次插值的混合函数。注意切线混合函数的不对称性。对混合函数t³−t²和m1求反在公式17.17中会给出一个对称的外观。</p>
<p><strong>这意味着埃尔米特曲线插值p0 和p1，这些点的切线是m0 和m1．式17.17中的混合函数如上图所示，可以由式17.4和17.18推导得到。三次Hermite插值的一些例子如下图所示。所有这些例子都插值相同的点，但有不同的切线。还要注意不同的长度的切线给出不同的结果;更长的切线对整体形状有更大的影响。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031133722.png" class="" title="image-20211031133722">

<p>埃尔米特插值。曲线由两个点定义，p0和p1，以及一个切线m0 和m1，在每个点。</p>
<p><strong>在Nalu演示中使用Cubic Hermite插值来渲染头发。参见图17.2。粗控制毛发用于动画和碰撞检测，计算切线，立方曲线被镶嵌和渲染。</strong></p>
<h3 id="Kochanek-Bartels-Curves-Kochanek-Bartels曲线"><a href="#Kochanek-Bartels-Curves-Kochanek-Bartels曲线" class="headerlink" title="Kochanek-Bartels Curves  Kochanek-Bartels曲线"></a>Kochanek-Bartels Curves  Kochanek-Bartels曲线</h3><p><strong>当在两个以上的点之间进行插值时，可以连接几条埃尔米特曲线。然而，当这样做时，在选择提供不同特性的共享切线时有一定的自由度。在这里，我们将介绍一种计算切线的方法，称为Kochanek-Bartels曲线。假设有n个点p0，…pn−1，需要用n−1条埃尔米特曲线段进行插值。我们假设在每个点上只有一条切线，然后我们开始考虑“内切线”m1，…,mn−2．pi 点的切线可以计算为两个和弦的组合:pi −pi−1和pi+1 −pi，如下图中左侧所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134135.png" class="" title="image-20211031134135">

<p>计算切线的一种方法是使用和弦的组合(左)。右上一行为三条不同张力参数的曲线(a)，左图为a≈1，表示张力高;中间曲线a≈0，为默认张力;右曲线为a≈−1，即低张力。右边两条曲线的底部一行显示了不同的偏差参数。左边的曲线有负偏倚，右边的曲线有正偏倚。</p>
<p><strong>首先，引入了一个张力参数a，它改变了切向量的长度。这控制了在关节处曲线的尖锐程度。正切计算为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134008.png" class="" title="image-20211031134008">

<p><strong>上图右上一行显示了不同的张力参数。默认值是a = 0;较高的值会有更尖锐的弯曲(如果&gt; 1，将会有一个在关节处的环)，和负值给出较少的紧曲线附近的关节。其次，引入了一个影响切线方向(以及间接影响切线长度)的偏置参数b。同时使用张力和偏差</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134307.png" class="" title="image-20211031134307">

<p><strong>其中，默认值是b = 0。正偏置使弯曲更倾向于弦pi −pi−1，而一个负的偏向则使一个弯更倾向于另一个弦:pi+1 −pi．如上图中右下角所示。用户既可以设置张力和偏差参数，也可以让它们具有默认值，这就产生了通常所说的卡特穆尔-罗姆(Catmull-Rom)样条。第一个和最后一个点的切线也可以用这些公式计算，其中一个弦的长度被简单地设为零。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134445.png" class="" title="image-20211031134445">

<p>Kochanek-Bartels曲线的进出切线。在每个控制点pi，是时间ti 也显示了，其中ti &gt; ti−1对于所有的i。</p>
<p><strong>此外，控制关节行为的另一个参数可以纳入正切方程。然而，这需要在每个关节处引入两个切线，一个进入的切线，记为si (表示源)和一个输出，记为di (目的地)。参见上图。注意，pi 和pi+1 用切线di 和si+1．切线计算如下，其中c为连续性参数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134455.png" class="" title="image-20211031134455">

<p><strong>同样，c = 0是默认值，这使得si = di．设置c =−1给出si = pi −pi−1和di = pi+1 −pi，在关节处产生一个尖角，也就是C⁰．增加c的值等于si 和di 越来越像了。对于c = 0，那si = di．当c = 1时，得到si = pi+1 −pi和di = pi −pi−1．因此，连续性参数c是给用户更多控制的另一种方法，如果需要，它可以在关节处得到尖角。</strong></p>
<p><strong>张力、偏差和连续性的组合，其中默认参数值为a = b = c = 0，为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134942.png" class="" title="image-20211031134942">

<p><strong>只有当所有曲线段使用相同的时间间隔长度时，方程17.20和17.22才有效。为了考虑曲线段的不同时间长度，必须调整切线，类似于第17.1.3节所做的。调整过的切线，记为s′i 和d′i,都是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031134952.png" class="" title="image-20211031134952">

<p><strong>其中，∆i = ti+1−ti。</strong></p>
<h3 id="B-Splines-B样条"><a href="#B-Splines-B样条" class="headerlink" title="B-Splines B样条"></a>B-Splines B样条</h3><p><strong>在这里，我们将简要介绍B样条的主题，我们将特别关注三次均匀B样条。一般来说，B样条与B´ezier曲线非常相似，可以表示为t(使用移位基函数)的函数βn (由控制点加权)，ck:例如,</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031140132.png" class="" title="image-20211031140132">

<p><strong>在这个例子中，这是一条曲线，其中t是x轴，sn(t)是y轴，控制点是均匀间隔的y值。要了解更广泛的报道，请参阅the Killer B ‘s、Farin和Hoschek and Lasser的文章。</strong></p>
<p><strong>在这里，我们将遵循rujters等人的介绍，并介绍均匀三次B样条的特殊情况。基函数，β3(t)，由三片拼接在一起:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031140342.png" class="" title="image-20211031140342">

<p><strong>这个基础函数的构造如下图所示。这函数处处具有C²连续性，这意味着如果将几个b样条曲线段拼接在一起，复合曲线也是C²。三次曲线具有C²连续性，n次曲线具有C^(n−1)连续性。一般来说，基本函数的创建如下所示。β0(t)是一个“平方”函数，即， |t| &lt; 0.5时为1，|t| = 0.5时为0.5，其他地方为0。下一个基函数，β1(t)由β0(t)积分得到给出了一个帐篷函数。之后的基函数是通过对β1(t)积分得到的给出了一个更平滑的函数，即C¹．这个过程重复得到C²，等等。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031140921.png" class="" title="image-20211031140921">

<p>左:β3(t)基函数表示为一条肥黑曲线，由两个分段三次函数(红色和绿色)构成。当|t| &lt; 1时，使用绿色曲线，红色曲线当1≤|t| &lt; 2，其他地方曲线为零。右:使用四个控制点ck， k∈{i−1,i, i + 1, i + 2}来创建曲线段，我们只会得到一条在ci 和ci + 1的t坐标之间的曲线。将α输入到w函数中以评估基函数，然后将这些值乘以相应的控制点。最后，所有的值加在一起，就得到了曲线上的一个点。参见下图。(rujters等人后右侧插图。)</p>
<p><strong>如何计算曲线段如上图中右侧所示，其公式为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031141218.png" class="" title="image-20211031141218">

<p><strong>注意，任何时候只会使用四个控制点，这意味着曲线有局部支持，即需要有限数量的控制点。函数wk(α)用β3()定义</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031141306.png" class="" title="image-20211031141306">

<p><strong>rujters等人表明这些可以重写为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031141335.png" class="" title="image-20211031141335">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031141411.png" class="" title="image-20211031141411">

<p>控制点ck (绿色圆圈)在这个例子中定义一个均匀三次样条。只有两条胖曲线是分段B样条曲线的一部分。左边(绿色)曲线是正确的 由最左边的四个控制点决定，右边(红色)曲线由最右边的四个控制点决定点。曲线在t = 1处相交，具有C²连续性。</p>
<p><strong>在上图中，我们展示了将两条均匀三次B样条曲线拼接成一条的结果。一个主要的优点是这些曲线是连续的，与三次B样条的基函数β(t)具有相同的连续性，β(t)是C²。从图中可以看出，并不能保证曲线将通过任何一个控制点。注意，我们还可以为x坐标创建B样条，它将给出平面上的一般曲线(而不仅仅是函数)。得到的二维点将是(s3^x (i + α)， s3^y (i + α))，即简单的对方程17.26的两个不同的计算，一个对x，一个对y。</strong></p>
<p><strong>我们已经展示了如何只使用均匀的B样条。如果控制点之间的间距是非均匀的，方程就会变得更复杂，但也更灵活。</strong></p>
<h2 id="Parametric-Curved-Surfaces-参数曲面"><a href="#Parametric-Curved-Surfaces-参数曲面" class="headerlink" title="Parametric Curved Surfaces 参数曲面"></a>Parametric Curved Surfaces 参数曲面</h2><p><strong>参数曲线的自然扩展是参数曲面。一个类比是，三角形或多边形是线段的延伸，我们从一到二维度。参数曲面可以用来建模带有曲面的物体。参数曲面由少量控制点定义。参数曲面的镶嵌是在几个位置评估曲面表示的过程，并将这些连接起来形成近似真实曲面的三角形。这样做是因为图形硬件可以有效地渲染三角形。在运行时，曲面可以被分割成尽可能多的三角形。因此，参数化表面是在质量和速度之间进行权衡的完美选择，因为更多的三角形需要更多的时间来渲染，但会提供更好的阴影和轮廓。参数曲面的另一个优点是控制点可以被动画化，然后曲面可以被镶嵌。这与直接动画一个大的三角形网格相反，后者可能更昂贵。</strong></p>
<p><strong>本节首先介绍B´ezier 贴片，这是带有矩形域的曲面。这些也被称为张量积B´ezier曲面。然后给出了具有三角域的B´ezier三角形，然后在第17.2.3节讨论了连续性。在17.2.4和17.2.5节中，有两种方法将每个输入三角形替换为B´ezier三角形。这些技术分别被称为PN三角形和Phong镶嵌。最后，在第17.2.6节给出了B样条贴片。</strong></p>
<h3 id="B´ezier-Patches-贝塞尔贴片"><a href="#B´ezier-Patches-贝塞尔贴片" class="headerlink" title="B´ezier Patches 贝塞尔贴片"></a>B´ezier Patches 贝塞尔贴片</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144005.png" class="" title="image-20211031144005">

<p>使用四个点的双线性插值。</p>
<p><strong>在17.1.1节中介绍的B´ezier曲线的概念可以从使用一个参数扩展到使用两个参数，从而形成曲面而不是曲线。让我们从线性插值扩展到双线性插值开始。现在，我们不再使用两个点，而是使用四个点，称为a、b、c和d，如上图所示。我们不再使用一个叫做t的参数，而是使用两个参数(u, v)。使用u线性插值a &amp; b和c &amp; d得到e和f:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144050.png" class="" title="image-20211031144050">

<p><strong>接下来，线性插值点e和f在另一个方向上线性插值，使用v。这就产生了双线性插值:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144214.png" class="" title="image-20211031144214">

<p><strong>注意，这与用于纹理映射的双线性插值的方程类型相同(第179页的方程6.1)。式17.30描述了最简单的非平面参数曲面，其中(u, v)的不同值生成了曲面上的不同点。有效值集为(u, v)∈[0,1]×[0,1]，即u和v都属于[0,1]。当域是矩形时，得到的曲面通常称为贴片。</strong></p>
<p><strong>为了从线性插值扩展B´ezier曲线，添加更多的点并重复插值。同样的策略也可以用于补丁。假设使用了9个点，排列在3 × 3的网格中。如下图所示，其中还显示了符号。为了从这些点形成一个双二次B´ezier patch，我们首先需要双线性插值4次，以创建4个中间点，如下图所示。接下来，曲面上的最后一点是由先前创建的点进行双线性插值。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144403.png" class="" title="image-20211031144403">

<p>左:一个双二次B´ezier曲面，由9个控制点定义，pij ．右:在B´ezier曲面上生成一个点，四个点p¹ij 首先从最近的控制点使用双线性插值创建。最后，点曲面p(u, v) = p²00是由这些创建的点进行双线性插值。</p>
<p><strong>上面描述的重复双线性插值是de Castel- jau算法在贴片上的扩展。现在我们需要定义一些符号。曲面的度数是n，控制点是pi,j ，其中i和j属于[0…n]。因此，(n + 1)² 控制点用于度n的贴片。注意控制点应该上标一个0，即p⁰i,j ，但这经常被省略，有时我们使用下标 ij 而不是 i,j 当没有混乱的时候。使用de Casteljau算法的B´ezier补丁描述如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144643.png" class="" title="image-20211031144643">

<p><strong>与B´ezier曲线相似，B´ezier贴片上的(u, v)点为p^n 0,0(u, v)。B´ezier patch也可以用Bernstein多项式的Bernstein形式来描述，如式17.32所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144735.png" class="" title="image-20211031144735">

<p><strong>注意，在17.32式中，有两个参数m和n表示曲面的度。“复合”度有时用m × n表示，通常m = n，这使实现稍微简化了一点。m &gt;n的结果是，首先双线性插值n次，然后线性插值m - n次。如下图所示。对17.32式的另一种解释是将其改写为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144820.png" class="" title="image-20211031144820">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144835.png" class="" title="image-20211031144835">

<p>不同的方向有不同的度。</p>
<p><strong>其中<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031144953.png" class="" title="image-20211031144953">从公式17.33的下面一行可以看出，当我们固定v值时，这只是一条B´ezier曲线。假设v = 0.35，点qi(0.35)可由B´ezier曲线计算得到，则式17.33描述了B´ezier曲面上的B´ezier曲线，此时v = 0.35。</strong></p>
<p><strong>接下来，我们将介绍B´ezier贴片的一些有用特性。通过在公式17.32中设置(u, v) = (0,0)， (u, v) = (0,1)， (u, v) =(1,0)和(u, v) =(1,1)，很容易证明B´ezier patch插值，即通过拐角控制点p0,0，p0,n，pn,0和pn,n．并且，每个贴片的边界都由边界上的控制点形成的n度B´ezier曲线来描述。因此，拐角控制点的切线是由这些边界B´ezier曲线定义的。每个角控制点都有两条切线，分别在u和v方向上。与B´ezier曲线的情况一样，贴片也位于其控制点的凸包内，并且</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031145148.png" class="" title="image-20211031145148">

<p><strong>(u, v)∈[0,1]×[0,1]。最后，旋转控制点并在贴片上生成点在数学上与在贴片上生成点然后旋转这些点是相同的(尽管通常比这更快)。</strong></p>
<p><strong>部分微分式17.32可得:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031145248.png" class="" title="image-20211031145248">

<p><strong>可以看出，贴片的程度在分化方向上减少了1。非归一化法向量的形式为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031145321.png" class="" title="image-20211031145321">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031145403.png" class="" title="image-20211031145403">

<p>左:一个3 × 3度的4 × 4b´ezier贴片的控制网格。在表面生成的四边形。右图:着色B´ezier贴片。</p>
<p><strong>在上图中，显示了控制网格和实际的B´ezier贴片。移动控制点的效果如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031145425.png" class="" title="image-20211031145425">

<p>这组图像显示当一个控制点被移动时，B´ezier贴片会发生什么。大部分更改都在移动的控制点附近。</p>
<h4 id="Rational-Bezier-Patches-有理贝塞尔贴片"><a href="#Rational-Bezier-Patches-有理贝塞尔贴片" class="headerlink" title="Rational Bezier Patches 有理贝塞尔贴片"></a>Rational Bezier Patches 有理贝塞尔贴片</h4><p><strong>正如B´ezier曲线可以扩展为有理B´ezier曲线(章节17.1.1)，从而引入更多的自由度，B´ezier 贴片也可以扩展为有理B´ezier 贴片:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031145745.png" class="" title="image-20211031145745">

<p><strong>查阅Farin的书和PHochek Pand Lasser的书了解这种类型的贴片。类似地，有理B´ezier三角形是B´ezier三角形的扩展，接下来处理。</strong></p>
<h3 id="B´ezier-Triangles-贝塞尔三角形"><a href="#B´ezier-Triangles-贝塞尔三角形" class="headerlink" title="B´ezier Triangles 贝塞尔三角形"></a>B´ezier Triangles 贝塞尔三角形</h3><p><strong>尽管三角形通常被认为是比矩形更简单的几何元素，但当涉及到B´ezier曲面时，情况并非如此:B´ezier三角形不像B´ezier patches那样简单。这种类型的补丁是值得展示的，因为它用于形成PN三角形和Phong镶嵌，这是快速和简单的。请注意，有些游戏引擎，如Unreal Engine、Unity和Lumberyard，支持Phong镶嵌和PN三角形。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031150128.png" class="" title="image-20211031150128">

<p>三次B´ezier三角形的控制点。</p>
<p><strong>控制点位于三角形网格中，如上图所示。B´ezier三角形的度数是n，这意味着每条边有n + 1个控制点。这些控制点用p⁰i,j,k表示有时缩写为pijk．注意，对于所有控制点，i + j + k = n，并且i, j, k≥0。因此，控制点总数为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031150359.png" class="" title="image-20211031150359">

<p><strong>毫无疑问，B´ezier三角形也是基于重复插值的。但是，由于域的三角形形状，必须使用重心坐标(章节22.8)进行插值。回想一下，三角形∆p0p1p2中的一个点 ，可以描述为p(u, v) = p0 + u (p1 −p0) + v (p2 −p0) =(1−u−v) p0 +up1 +vp2，其中(u, v)为质心坐标。对于三角形内部的点，以下必须保持:u≥0,v≥0，和1−(u + v)≥0 &lt;=&gt; u + v≤1。基于此，针对B´ezier三角形的de Casteljau算法是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031150804.png" class="" title="image-20211031150804">

<p><strong>B´ezier三角形的最后一点(u, v)是p^n 000(u, v)伯恩斯坦形式的B´ezier三角形是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031150849.png" class="" title="image-20211031150849">

<p><strong>Bernstein多项式现在同时依赖于u和v，因此计算方法不同，如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031150924.png" class="" title="image-20211031150924">

<p><strong>偏导数是:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031151018.png" class="" title="image-20211031151018">

<p><strong>B´ezier三角形的一些不足为奇的特性是，它们插值(通过)三个角控制点，每个边界都是由边界上的控制点描述的B´ezier曲线。曲面位于控制点的凸包内。一个B´ezier三角形如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031151045.png" class="" title="image-20211031151045">

<p>左:B´ezier三角形的线框。右:着色表面和控制点。</p>
<h3 id="Continuity-连续性"><a href="#Continuity-连续性" class="headerlink" title="Continuity 连续性"></a>Continuity 连续性</h3><p><strong>当从B´ezier表面构造一个复杂的物体时，人们经常想把几个不同的B´ezier表面缝在一起，形成一个复合表面。为了得到好看的结果，必须注意确保表面的合理连续性。这与第17.1.3节中描述曲线的精神是相同的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031151330.png" class="" title="image-20211031151330">

<p>如何用C¹把两个B´ezier贴片缝在一起连续性。加粗线上的所有控制点必须共线，并且它们在两个线段长度之间的比例必须相同。请注意,a3j = b0j 以获得贴片之间的共享边界。在下图的右侧也可以看到这一点。</p>
<p><strong>假设两个双三次B´ezier贴片应该拼接在一起。它们各有4 × 4个控制点。如上图所示，左边的贴片有控制点aij ，右边是控制点bij ，对于0≤i, j≤3。确保C⁰ 连续性，这些贴片必须在边界上共享相同的控制点，也就是说，a3j = b0j。</strong></p>
<p> <strong>然而，这并不足以得到一个好看的复合表面。相反，我们将提出一种简单的技术，使C¹具有连续性。为了实现这一点，我们必须约束最接近共享控制点的两行控制点的位置。这些行是a2j 和b1j ．对于每个j，点a2j,b0j和b1j 一定是共线的，也就是说，它们一定在一条直线上。而且，它们必须具有相同的比例，即||a2j −b0j | | = k | | b0j −b1j | |。这里k是常数，对于所有j k必须是相同的。示例如上图和下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031151713.png" class="" title="image-20211031151713">

<p>左列显示了两个B´ezier贴片，只有C⁰连续性。很明显，在这些斑块之间有一个不连续性的着色。右列为类似的斑块连接C¹连续性，看起来更好。在顶部一行中，虚线表示两个连接贴片之间的边界。在右上方，黑线表示连接贴片的控制点的共线性。</p>
<p><strong>这种构造使用了设置控制点的许多自由度。这一点在把共用一个角落的四个补丁拼接在一起时可以看得更清楚。其结构如下图所示。结果显示在该图的右侧，其中显示了共享控制点周围的8个控制点的位置。这9个点必须在同一平面上，并形成一个双线性贴片，如图17.17所示。如果满足角的G1连续性(且仅在那里)，就足以使9个点共面。它使用更少的自由度。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031151946.png" class="" title="image-20211031151946">

<p>(a)将F、G、H和I四个贴片缝合在一起，所有贴片共享一个角落。(b)在垂直方向上，三组三点(每条粗体线上)必须使用相同的比例k。这个关系在这里没有显示;见最右边的图。对于(c)也进行了类似的处理，其中，在水平方向上，两个贴片必须使用相同的比例l。(d)当缝合在一起时，所有四个补丁必须垂直使用比例k，水平使用比例l。(e)结果显示，最接近(和包括)共用控制点的9个控制点的比率得到正确计算。</p>
<p><strong>B´ezier三角形的连续性通常更复杂，以及B´ezier 贴片和三角形的G¹条件。当构建一个包含许多B´ezier曲面的复杂物体时，通常很难看到它能够跨越所有边界获得合理的连续性。解决这个问题的一个方法是转向细分表面，在17.5节中讨论过。</strong></p>
<p><strong>请注意C¹连续性对于跨边界的好看纹理是必需的。对于反射和着色，G¹连续性得到了一个合理的结果。C¹或更高会得到更好的结果。如上上图所示。</strong></p>
<p><strong>在接下来的两个小节中，我们将介绍两种方法，利用三角形顶点的法线来推导每个输入(平面)三角形的B´ezier三角形。</strong></p>
<h3 id="PN-Triangles-PN三角形"><a href="#PN-Triangles-PN三角形" class="headerlink" title="PN Triangles PN三角形"></a>PN Triangles PN三角形</h3><p><strong>给定一个在每个顶点上都有法线的输入三角形网格，Vlachos等人的PN三角形方案的目标是构建一个比仅使用三角形更好看的表面。字母“PN”是“点和法线”的缩写，因为这是生成曲面所需的所有数据。它们也被称为N-patches。这个方案试图通过创建一个曲面来代替每个三角形来改善三角形网格的阴影和轮廓。镶嵌硬件能够动态地生成每个曲面，因为镶嵌是由每个三角形的点和法线生成的，不需要邻居信息。如下图所示。本文提出的算法建立在van Overveld和Wyvill的基础上。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031154759.png" class="" title="image-20211031154759">

<p>这些列显示了同一模型的不同级别的详细信息。左边显示的是原始三角形数据，由414个三角形组成。中间的模型有3726个三角形，右边的模型有20286个三角形，都是用该算法生成的。注意轮廓和阴影是如何改善的。下面一行显示了线框中的模型，这表明每个原始三角形生成相同数量的子三角形。模型由id软件提供。图片来自ATI技术公司演示。)</p>
<p><strong>假设有一个顶点为p300，p030和p003 的三角形与法线n200，n020和n002．基本的想法是使用这些信息为每个原始三角形创建一个立方体B´ezier三角形，并从B´ezier三角形生成尽可能多的三角形。</strong></p>
<p><strong>为了简化符号，将使用w = 1−u−v。一个三次B´ezier三角形由</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031154928.png" class="" title="image-20211031154928">

<p><strong>参见图17.22。为了保证两个PN三角形之间的边界上的C⁰连续性，可以通过角控制点和角上的法线来确定边上的控制点。(假设相邻三角形共享法线)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031155030.png" class="" title="image-20211031155030">

<p>B´ezier如何指向p210 是用在p300的法向量n200 和两个角点p300 和p030 来计算的，．</p>
<p><strong>假设我们想计算p210 使用控制点p300，p030 以及法向量n200 在p300，如上图所示。简单地取点2/3p300+ 1/3p030 然后投影到法向量n200的方向上，到由p300 和n200定义的切平面上。假设标准化的法线，点p210 是计算</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031155405.png" class="" title="image-20211031155405">

<p><strong>其他边界控制点也可以类似地计算，因此只剩下计算内部控制点p111．这如下面的方程所示，这个选择遵循一个二次多项式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031155417.png" class="" title="image-20211031155417">

<p><strong>Vlachos等选择插值法向，而不是使用方程17.42计算曲面上的两条切线，然后计算法线一个二次方案，如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031155512.png" class="" title="image-20211031155512">

<p><strong>这可以被认为是一个2度的B´ezier三角形，其中控制点是6个不同的法线。在17.46式中，度的选择，即因为导数比实际的B´ezier三角形低一度，而且法线的线性插值无法描述拐点。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031155605.png" class="" title="image-20211031155605">

<p>这个图说明了为什么法线的二次插值是需要的，为什么是线性插值是不够的。左列显示了当使用法线的线性插值时会发生什么。当法线描述一个凸面(顶部)时，这种方法可以很好地工作，但当表面有一个弯曲(底部)时，这种方法就失效了。右列表示二次插值。(van Overveld和Wyvill的插图。)</p>
<p><strong>为了能够使用方程17.46，法向控制点n110，n101和n011 需要计算。一个直观但有缺陷的解决方案是使用n200 和n020 (原三角形顶点的法线)的平均值来计算n110．然而,当n200 = n020，则再次遇到上图左下角所示的问题。相反,n110 是通过先取n200 和n020的平均值来构造的，然后在下图所示的π平面上反射这条法线。这个平面的法线平行于端点p300 和p030之间的差．由于只有法向量会在π上反射，我们可以假设π通过原点，因为法向量与平面上的位置无关。另外，注意每个法线都应该标准化。数学上，n110 的非标准化版本表示为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031155943.png" class="" title="image-20211031155943">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031160000.png" class="" title="image-20211031160000">

<p>n110 构造为PN三角形。虚线法线是n200 n020和n110的平均值是在π平面上反射的法线。π平面有一条平行于p030−p300的法线。</p>
<p><strong>最初，van Overveld和Wyvill在这个等式中使用了3/2而不是2。从图像中很难判断哪个值是最好的，但使用2可以很好地解释平面上的真实反射。</strong></p>
<p><strong>此时，三次B´ezier三角形的所有B´ezier点和二次插值的所有法向量都已经计算出来了。它只剩下在B´ezier三角形上创建三角形，以便它们可以被渲染。这种方法的优点是表面得到更好的轮廓和形状相对较低的成本。</strong></p>
<p><strong>指定详细级别的一种方法如下。原始三角形数据被认为LOD 0。然后LOD数随着三角形边上新引入的顶点数的增加而增加。因此，LOD 1为每条边引入了一个新顶点，因此在B´ezier三角形上创建了四个子三角形，LOD 2为每条边引入了两个新顶点，生成了9个子三角形。一般而言，LOD n生成(n + 1)² 子三角形。为了防止B´ezier三角形之间的裂缝，网格中的每个三角形必须用相同的LOD镶嵌。这是一个严重的缺点，因为一个小三角形会像一个大三角形一样被镶嵌。可以使用自适应镶嵌(第17.6.2节)和分数形镶嵌(第17.6.1节)等技术来避免这些问题。</strong></p>
<p><strong>PN三角形的一个问题是，折痕很难控制，通常需要在想要的折痕附近插入额外的三角形。B´ezier三角形之间的连续性只有C⁰，但在许多情况下，它们看起来仍然是可以接受的。这主要是因为法线在三角形之间是连续的，所以一组PN三角形模拟了G¹表面。Boubekeur等人提出了一个更好的解决方案，顶点可以有两条法线，这两个连通的顶点生成一条折痕。注意，为了获得好看的纹理，需要跨越三角形(或贴片)之间的边界的C¹连续性。同样值得知道的是，如果两个相邻的三角形不共享相同的法线，就会出现裂缝。Gr¨un描述了一种进一步提高PN三角形连续性质量的技术。Dyken等人提出了一种受PN三角形启发的技术，只有从观察者那里看到的轮廓是自适应镶嵌的，因此变得更弯曲。这些剪影曲线的推导方法与PN三角形曲线相似。为了获得平滑的过渡，它们混合了粗糙的轮廓和镶嵌的轮廓。为了改进连续性，F¨unzig等人提出了PNG1三角形，它是具有G¹的PN三角形的修正连续性无处不在。McDonald和Kilgard提出了PN三角形的另一种扩展，它可以处理相邻三角形上的不同法线。</strong></p>
<h3 id="Phong-Tessellation-冯氏镶嵌"><a href="#Phong-Tessellation-冯氏镶嵌" class="headerlink" title="Phong Tessellation 冯氏镶嵌"></a>Phong Tessellation 冯氏镶嵌</h3><p><strong>Boubekeur和Alexa提出了一种名为Phong tesselation的表面构造，它与PN三角形有许多相似之处，但评估更快，实现更简单。称底边三角形的顶点为p0，p1和p2，并设相应的标准化法线为n0，n1和n2．首先，回想一下在底边三角形的重心坐标(u, v)处的一个点被计算为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031160631.png" class="" title="image-20211031160631">

<p><strong>在Phong着色中，法线被插值到平面三角形上，同样使用上面的方程，但是用法线代替点。Phong镶嵌尝试使用重复插值创建一个Phong着色法线插值的几何版本，结果是一个B´ezier三角形。对于这个讨论，我们将参考下图。第一步是创建一个函数，将一个点q投影到一个点和一条法线所定义的切平面上。这是这样做的</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031160724.png" class="" title="image-20211031160724">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031160737.png" class="" title="image-20211031160737">

<p>用曲线代替曲面说明了Phong镶嵌结构，这意味着p(u)只是u的函数而不是(u, v)，对于ti也是类似的．注意，p(u)首先投影到切平面上，生成t0 和t1．在那之后,p* (u)由t0 和t1的线性插值得到．作为最后一步，形状因子α被用来混合基三角形和,p* (u)在这个例子中，我们使用α = 0.75。</p>
<p><strong>不是使用三角形顶点进行线性插值(方程17.48)，而是使用函数ti进行线性插值，其结果是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031161034.png" class="" title="image-20211031161034">

<p><strong>为了增加一些灵活性，添加了一个形状因子α，在基础三角形和方程17.50之间插入，这导致了Phong镶嵌的最终公式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031161043.png" class="" title="image-20211031161043">

<p><strong>其中α = 0.75是推荐设置。生成这个曲面所需的唯一信息是基础三角形的顶点和法线以及用户提供的α，使这个表面的评估快速。得到的三角路径是二次的，即小于PN三角形的度。法线是简单的线性插值，就像标准的Phong着色。如下图所示的例子说明了Phong镶嵌应用于网格的效果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031161159.png" class="" title="image-20211031161159">

<p>Phong嵌应用于怪物青蛙。从左到右:带有平着色的基础网格，带有Phong着色的基础网格，最后，Phong镶嵌应用到基础网格。注意改进的轮廓。在这个例子中，我们使用α = 0.6。(使用Tamy Boubekeur的演示程序生成的图片。)</p>
<h3 id="B-Spline-Surfaces-B样条曲面"><a href="#B-Spline-Surfaces-B样条曲面" class="headerlink" title="B-Spline Surfaces B样条曲面"></a>B-Spline Surfaces B样条曲面</h3><p><strong>第17.1.6节简要介绍了B样条曲线，在这里我们将以同样的方式介绍B样条曲面。第732页的公式17.24可以推广到B样条贴片为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031161352.png" class="" title="image-20211031161352">

<p><strong>这与B´ezier贴片公式相当相似(式17.32)。请注意,sn(u, v)是平面上的三维点。如果这个函数用于纹理过滤，方程17.52将是一个高度场和ck,l 是一维的，也就是高度。</strong></p>
<p><strong>对于双三次B样条贴片， β3(t)函数将用在17.52式中。共4×4控制点，ck,l，式17.52所描述的实际表面贴片位于最内层2 × 2控制点的内部。如下图所示。注意，双三次B样条贴片对于Catmull-Clark细分曲面(章节17.5.2)也是必不可少的。有很多关于B样条曲面的好书。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211031161640.png" class="" title="image-20211031161640">

<p>双三次B样条的设置，它有4 × 4个控制点，ck,l．(u, v)的定义域是右边所示的单位平方。</p>
<h2 id="Implicit-Surfaces-隐式曲面"><a href="#Implicit-Surfaces-隐式曲面" class="headerlink" title="Implicit Surfaces 隐式曲面"></a>Implicit Surfaces 隐式曲面</h2><p><strong>到此为止，只讨论了参数曲线和曲面。隐式曲面是表示模型的另一个有用类。而不是使用一些参数，比如u和v，用来显式地描述曲面上的一个点，使用了下面的形式，称为隐函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101103146.png" class="" title="image-20211101103146">

<p><strong>这是解释如下:点p是隐式表面如果结果是0点时插入到隐函数f。隐式表面往往与射线相交测试使用(章节22.6 - -22.9),因为他们可能比相应的简单相交(如果有的话)参数表面。隐式曲面的另一个优点是构造立体几何算法可以很容易地应用于它们，也就是说，物体之间可以相互减去，逻辑上可以与对方进行AND:ed或OR:ed。此外，对象可以很容易地混合和变形。</strong></p>
<p><strong>一些位于原点的隐式曲面的例子如下</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101103253.png" class="" title="image-20211101103253">

<p><strong>这些都需要一些解释。球面就是从p到原点的距离减去半径，所以是fs(p, r)等于0，如果p在半径为r的球面上。否则，返回一个有符号的距离，其中负表示p在球面内，正表示在球面外。因此，这些函数有时也称为带符号距离函数(SDFs)。平面fxz(p)就是p的y坐标，即y轴为正的一侧。对于圆角框的表达式，我们假设每个分量计算绝对值(|p|)和向量的最大值。同样，d是方框半边的向量。见下图圆形框;这个公式在说明文字中作了说明。要得到一个非圆角框，只需设置r = 0。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101103651.png" class="" title="image-20211101103651">

<p>左:一个非圆角框，其带符号的距离函数为|| max(|p|−d, 0)||，其中p为待测点，d分量为如图所示的半边。注意|p|使其余的计算发生在右上象限(2D)。减去d等于|px|−dx 如果p沿x在方框内，则为负，其他轴也是如此。只有正值被保留，而负值被max()固定为零。因此，|| max(|p|−d, 0)||计算到框边的最近距离，这意味着如果在计算max()后有多个值为正值，则框外的带符号距离字段将四舍五入。右:圆角方框由非圆角方框减去r得到，非圆角方框向四面扩展r。</p>
<p><strong>隐式曲面的法线由偏导数描述，称为梯度，并记为∇f:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101103819.png" class="" title="image-20211101103819">

<p><strong>为了能够准确地计算它，方程17.55中的f必须是可微的，因此也是连续的。在实践中，人们经常使用一种叫做中心差分的数值技术，它使用场景函数f进行采样:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101103856.png" class="" title="image-20211101103856">

<p><strong>∇fy 和∇fz也是如此．回想一下,ex = (1,0,0)， ey = (0,1,0)， ez = (0,0,1)， ε是一个小数字。</strong></p>
<p><strong>要使用公式17.54中的原语构建场景，需要使用联合操作符∪。例如，f(p) = fs(p, 1)∪fxz(p)是由一个球体和一个平面组成的场景。联合运算符是通过取其两个操作数中最小的一个来实现的，因为我们想要找到离p最近的曲面。fs(p - t, 1)是一个被t平移的球体。将反变换应用到p上。使用r = mod(p, c)−0.5c而不是p作为带符号距离函数的参数，也可以直接在整个空间中重复一个对象。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101104114.png" class="" title="image-20211101104114">

<p>左:一对球体混合不同的增加(从左到右)混合半径和一层由重复的圆形盒子组成。右:三个球体混合在一起。</p>
<p><strong>隐式曲面的混合是一个很好的特征，可以用于通常被称为斑点建模、软对象或元球。一些示例请参见上图。基本思想是使用几个简单的原语，例如将它们平滑地混合在一起。每一个物体都可以看作一个原子，混合后得到原子的分子。混合可以有很多不同的方法。一种常用的混合两个距离的方法d1 和d2，半径为rb,是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101104212.png" class="" title="image-20211101104212">

<p><strong>其中d为混合距离。虽然这个函数只混合到两个对象的最短距离，但是这个函数可以重复使用来混合更多的对象(见上图的右半部分)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101104428.png" class="" title="image-20211101104428">

<p>Ray marching用带符号的距离场行进。虚线表示从它们的中心到最近的表面的距离。一个位置可以沿着射线前进到先前位置的圆的边界。</p>
<p><strong>要将一组隐函数形象化，通常使用的方法是射线行进。一旦你可以射线穿过一个场景，它也可能产生阴影，重新弯曲、环境遮挡和其他效果。上图说明了射线在带符号的距离域内行进。在射线上的第一点p处，求值到现场的最短距离d。因为这表明周围是一个球体半径d，p没有其他对象更近,我们可以把雷d单元沿射线方向等等,直到我们到达表面内一些,或者当一个预定义的ray-march步骤已经满足,在这种情况下,我们可以假设背景是打击。下图中显示了两个很好的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101104441.png" class="" title="image-20211101104441">

<p>雨林(左)和蜗牛(右)用带符号的距离函数和射线行进程序创建。树是用带有程序噪声的椭球体生成的。(图像由Shadertoy生成，使用I ~ nigo Quilez程序。)</p>
<p><strong>每个隐式曲面也可以变成由三角形组成的曲面。有几种算法可用于执行该操作。一个众所周知的例子是移动立方体算法，见第13.10节。使用Wyvill和Bloomenthal算法执行多边形化的代码可以在web上找到，de Ara´ujo等人对隐式曲面多边形化的最新技术进行了综述。Tatarchuk和Shopf描述了一种他们称之为行进四面体的技术，在这种技术中，GPU可以用来在三维数据集中寻找等值面。第48页的图3.13显示了一个使用几何着色器的等值面提取的例子。Xiao等人提出了一个流体模拟系统，在该系统中，GPU计算100k粒子的位置，并使用它们来显示等值面，所有这些都以交互速率进行。</strong></p>
<h2 id="Subdivision-Curves-细分曲线"><a href="#Subdivision-Curves-细分曲线" class="headerlink" title="Subdivision Curves 细分曲线"></a>Subdivision Curves 细分曲线</h2><p><strong>细分技术用于创建平滑的曲线和表面。在建模中使用它们的一个原因是，它们在离散曲面(三角形网格)和连续曲面(例如，B´ezier patches的集合)之间搭建了桥梁，因此可以用于细节级别技术(章节19.9)。在这里，我们将首先描述细分曲线如何工作，然后讨论更流行的细分曲面方案。</strong></p>
<p><strong>细分曲线最好用一个使用切角的例子来解释。参见下图。最左边的多边形的角被切掉，创建一个新的多边形有两倍的顶点。然后这个新多边形的角被切掉，以此类推直到无穷远(或者，更实际一点，直到我们看不到任何区别)。由此得到的曲线称为极限曲线，它是光滑的，因为所有的角都被截断了。这个过程也可以被认为是低通滤波器，因为所有尖角(高频)被去除。这个过程通常写成P0 →P1 →P2 ···→p∞, P0 是起始多边形，也称为控制多边形，P∞ 是极限曲线。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101110809.png" class="" title="image-20211101110809">

<p>Chaikin的细分计划正在实施。初始控制多边形P0 再次细分为P1和P2。可以看到，在细分的过程中，每个多边形的圆角pi都被切掉了。经过无穷次细分，得到了极限曲线P∞。这是一个近似方案，因为曲线不经过初始点。</p>
<p><strong>这个细分过程可以用许多不同的方法来完成，每一种方法都有一个细分方案。上图所示的方案称为Chaikin方案，其工作原理如下:假设一个多边形的n个顶点为P0 = {p₀⁰，…, p⁰n−1}，其中上标表示细分级别。Chaikin的方案在原多边形的每一对后续顶点之间创建两个新顶点，如pi^k 和 pi+1^k</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101111242.png" class="" title="image-20211101111242">

<p><strong>可以看出，上标从k到k + 1，这意味着我们从一个细分层到下一个细分层，即Pk →Pk+1．在这个细分步骤完成后，原始的顶点被丢弃，新的点被重新连接。这种行为可以从上图中看到，其中新点被创建，距离原始顶点1/4，距离相邻顶点。细分方案的美妙之处在于快速生成光滑曲线的简单性。然而，您并不会立即得到第17.1节中所述的曲线的参数形式，尽管可以证明Chaaikin算法生成了二次B样条。到目前为止，所提出的方案适用于(闭合)多边形，但大多数方案也可以扩展到开放折线。在Chaikin的例子中，唯一的区别是折线的两个端点在每个细分步骤中都被保留(而不是被丢弃)。这使得曲线经过端点。</strong></p>
<p><strong>有两种不同的细分方案，即近似和插值。一般来说，Chaaikin的格式是近似的，就像极限曲线一样不在初始多边形的顶点上。这是因为顶点被丢弃(或者更新，对于某些方案)。相反，插值格式保留了之前细分步骤中的所有点，因此极限曲线P∞ 通过P0P1P2的所有点，等等。这意味着该方案将插值初始多边形。如下图所示，使用与上图相同的多边形。该方案使用最近的四个点创建一个新点:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101111435.png" class="" title="image-20211101111435">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101111453.png" class="" title="image-20211101111453">

<p>4点细分方案。这是曲线经过初始点时的插值格式，一般是曲线Pi+1 经过P点i．注意，上上图中使用了相同的控制多边形。</p>
<p><strong>方程17.59中的第一行简单地表示，我们保留了前一步中的点，而不改变它们(即:第二行用于在pi^k 和 pi+1^k之间创建一个新点。重量w称为张力参数。当w = 0时，结果是线性插值，但当w = 1/16时，我们得到的行为如上图所示。可以看出，当0 &lt; w &lt; 1/8，得到的曲线为C¹。对于开放折线，我们会在端点处遇到问题因为我们需要在新点的两边都有两个点，而我们只有一个。如果端点旁边的点跨端点反射，就可以解决这个问题。对于折线的开始，p1 通过p0 反射获得p−1．然后在细分过程中使用这一点。p−1 的产生如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101111815.png" class="" title="image-20211101111815">

<p>反射点p−1的建立，用于开放折线。反射点计算为:p−1 = p0−(p1−p0) = 2p0−p1。</p>
<p><strong>另一种近似方案使用以下细分规则:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101111904.png" class="" title="image-20211101111904">

<p><strong>第一行更新已有的点，第二行计算相邻两点之间线段上的中点。该方案生成三次B样条曲线(第17.1.6节)。参考SIGGRAPH关于细分的课程，Killer B的书，Warren和Weimer的细分书，或者Farin的CAGD书了解更多关于这些曲线的信息。</strong></p>
<p><strong>给定点p及其相邻点，有可能直接将该点“推”到极限曲线，即确定p在p∞上的坐标．这对于切线也是可能的。例如，乔伊在网上对这个话题的介绍。</strong></p>
<p><strong>细分曲线的许多概念也适用于细分曲面，下面将介绍。</strong></p>
<h2 id="Subdivision-Surfaces-细分曲面"><a href="#Subdivision-Surfaces-细分曲面" class="headerlink" title="Subdivision Surfaces 细分曲面"></a>Subdivision Surfaces 细分曲面</h2><p><strong>细分曲面是定义具有任意拓扑的网格的光滑、连续、无裂纹曲面的强大范例。与本章中的所有其他表面一样，细分表面也提供了无限层次的细节。也就是说，您可以生成任意多的三角形或多边形，并且原始的表面表示是紧凑的。下图显示了一个被细分的曲面的例子。另一个优点是细分规则简单且易于执行。缺点是表面连续性的分析往往涉及数学问题。然而，这类分析往往只对那些希望创建新的细分方案的人感兴趣，超出了本书的范围。关于这些细节，可以参考Warren和Weimer的书和SIGGRAPH关于细分的课程。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101112132.png" class="" title="image-20211101112132">

<p>左上角的图像显示了控制网格，即这个原始的网格，是描述最终细分曲面的唯一几何数据。下面的图像被细分为一、二、三次。可以看到，越来越多的多边形被生成，表面变得越来越光滑。这里使用的方案是Catmull-Clark方案，见第17.5.2节。</p>
<p><strong>一般来说，曲面(和曲线)的细分可以被认为是一个两阶段的过程。从一个多边形网格开始，称为控制网格或控制笼，第一个阶段，称为细化阶段，创建新的顶点并重新连接以创建新的、更小的三角形。第二个阶段称为平滑阶段，通常为网格中的一些或所有顶点计算新的位置。如下图所示。这两个阶段的细节就是细分方案的特征。在第一阶段，一个多边形可以以不同的方式分割，而在第二阶段，细分规则的选择给出了不同的特征，如连续性水平，曲面是近似还是插值，这些特性在第17.4节中描述。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101112231.png" class="" title="image-20211101112231">

<p>细分为细化和平滑。细化阶段创建新的顶点并重新连接以创建新的三角形，平滑阶段为顶点计算新的位置。</p>
<p><strong>细分方案的特征可以是平稳的或非平稳的，均匀的或非均匀的，是基于三角形的还是基于多边形的。静态方案在每个细分步骤使用相同的细分规则，而非平稳可能会根据当前正在处理的步骤改变规则。下面处理的方案都是固定的。统一方案对每个顶点或边使用相同的规则，而非统一方案可能对不同的顶点或边使用不同的规则。例如，曲面边界上的边通常使用一套不同的规则。基于三角形的方案只作用于三角形，因此只生成三角形，而基于多边形的方案作用于任意多边形。</strong></p>
<p><strong>接下来介绍了几种不同的细分方案。接下来，介绍了两种扩展细分曲面使用的技术，以及细分法线、纹理坐标和颜色的方法。最后给出了一些实用的细分和绘制算法。</strong></p>
<h3 id="Loop-Subdivision-循环细分"><a href="#Loop-Subdivision-循环细分" class="headerlink" title="Loop Subdivision 循环细分"></a>Loop Subdivision 循环细分</h3><p><strong>Loop方法是第一个三角形细分方案。它类似于第17.4节中的最后一个方案，因为它是近似的，它更新每个现有的顶点，并为每条边创建一个新顶点。这个方案的连通性如下图所示。可以看到，每个三角形被细分为四个新的三角形，所以经过n个细分步骤，一个三角形被细分为4^n个三角形。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101112935.png" class="" title="image-20211101112935">

<p>两个细分步骤的连通性，如Loop方法。每个三角形生成四个新三角形。</p>
<p><strong>首先，让我们关注一个已经存在的顶点p^k，其中k为细分步骤的个数。这意味着p⁰是控制网格的顶点。</strong></p>
<p><strong>经过一个细分步骤，p⁰变成了p¹。一般为p⁰→p¹→p2→···→p∞，其中p∞为极限值。如果p^k有n个相邻顶点，则 pi^k, i∈{0,1，…， n−1}，则我们说p^k的价为n。上面描述的表示法见下图。此外，价为6的顶点被称为正顶点或普通顶点。否则就被称为不规则的或不寻常的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101113310.png" class="" title="image-20211101113310">

<p>用于循环的细分方案的符号。左邻域被细分为右邻域。中心点p^k被 p^(k+1)更新替换，对于 p^k和 pi^k之间的每条边，都创建一个新点( pi^(k+1), i∈1，…, n)。</p>
<p><strong>下面给出Loop方案的细分规则，其中第一个公式是将现有顶点p^k更新为 p^(k+1)的规则，第二个公式是创建新顶点 pi^(k+1), p^k和每一个 pi^k之间。n是 p^k的价</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101113708.png" class="" title="image-20211101113708">

<p><strong>注意，我们假设下标是以n为模计算的，所以如果i = n−1，那么对于i + 1，我们使用下标0，同样地，当i = 0时，对于i−1，我们使用下标n−1。这些细分规则可以很容易地可视化为蒙版，也称为模板。参见下图。它们的主要用途是，只用一个简单的插图就可以传达几乎整个细分方案。注意，两个掩码的权重总和都是1。这是一个对所有细分方案都适用的特征，其基本原理是一个新点应该位于加权点的邻域内。在17.61式中，常数β实际上是n的函数，由</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101113807.png" class="" title="image-20211101113807">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101113821.png" class="" title="image-20211101113821">

<p>Loop的细分方案的掩码(黑色圆圈表示更新/生成的顶点)。掩码显示了每个相关顶点的权重。例如，当更新一个已存在的顶点时，权值1- nβ用于已存在的顶点，权值β用于所有相邻的顶点，称为1环。</p>
<p><strong>对于β函数，Loop的建议给出了一个在每个正则顶点上的C²连续曲面，以及在其他地方的C¹连续曲面，即在所有不规则顶点上。由于在细分过程中只创建规则顶点，因此曲面在我们在控制网格中有不规则顶点的地方。下图是一个用Loop方法细分网格的例子。公式17.62的一个变体，避免了三角函数，由Warren和Weimer给出:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101113945.png" class="" title="image-20211101113945">



<p>用Loop的<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101113957.png" class="" title="image-20211101113957">细分方案对蠕虫进行了三次细分。</p>
<p><strong>对于规则的价，这里有一个C²面，还有其他的C¹面。由此产生的表面很难与常规的环路表面区分。对于一个没有闭合的网格，我们不能使用所提供的细分规则。相反，这些边界必须使用特殊的规则。对于Loop格式，可以使用公式17.60的反射规则。这也将在17.5.3节中讨论。</strong></p>
<p><strong>经过无穷多个细分步骤的曲面称为极限曲面。极限曲面点和极限切线可以用封闭形式表达式计算。用公式17.61第一行的公式计算顶点的极限位置，将β(n)替换为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101114127.png" class="" title="image-20211101114127">

<p><strong>顶点p^k的两个极限切线可以通过相邻顶点的权值计算，称为1环或1邻域，如下所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101114225.png" class="" title="image-20211101114225">

<p><strong>法线是n = tu ×tv．注意，这通常比第16.3节中描述的方法便宜，后者需要计算相邻三角形的法线。更重要的是，这给出了该点的确切法线。</strong></p>
<p><strong>近似细分方案的一个主要优点是得到的曲面趋于均匀。公平，松散地说，与曲线或表面弯曲的平滑程度有关。更高的公平性意味着更平滑的曲线或表面。另一个优点是近似格式比插值格式收敛得快。然而，这意味着形状通常会收缩。这对于小的凸网格是最显著的，如下图所示的四面体。减少这种效果的一种方法是在控制网格中使用更多的顶点。，建模时必须小心。Maillot和Stam提出了一个结合细分方案的框架，以便控制收缩。一个有时可以用来发挥巨大优势的特性是，Loop曲面包含在原始控制点的凸包内。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211101114322.png" class="" title="image-20211101114322">

<p>一个四面体用循环细分五次√3，和改性蝴蝶（MB）方案。循环和√3-方案都是近似的，而MB是插值的，后者意味着初始顶点位于最终曲面上。我们只包括由于其在游戏和离线渲染中的流行性，本书中采用了近似方案。</p>
<p><strong>循环细分方案生成一个广义的三向四次箱样条。因此，对于只包含规则顶点的网格，我们实际上可以将曲面描述为一种样条曲面。但是，这种描述对于不规则的设置是不可能的。能够从任意顶点网格生成光滑的表面是细分方案的一大优点。对于使用Loop方案的细分曲面的不同扩展，请参见17.5.3和17.5.4节。</strong></p>
<h3 id="Catmull-Clark-Subdivision-Catmull-Clark细分"><a href="#Catmull-Clark-Subdivision-Catmull-Clark细分" class="headerlink" title="Catmull-Clark Subdivision Catmull-Clark细分"></a>Catmull-Clark Subdivision Catmull-Clark细分</h3><p><strong>两种最著名的可以处理多边形网格(而不仅仅是三角形)的细分方案是catmula - clark和Doo-Sabin。在这里，我们只简单介绍前者。Catmull-Clark的表面被用于皮克斯的短片《盖里的游戏》，《玩具总动员2》，以及皮克斯的所有后续故事片。这种细分方法也经常用于制作游戏模型，并且可能是最受欢迎的方法。正如DeRose等、Catmull-所指出的克拉克表面倾向于产生更对称的表面。例如，一个长方形的盒子会产生一个对称的椭球面，这与直觉是一致的。相反，基于三角形的细分方案将每个立方体面视为两个三角形，因此根据正方形的分割方式产生不同的结果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102142142.png" class="" title="image-20211102142142">

<p>Catmull-Clark细分的基本思想。每个多边形生成一个新点，每条边生成一个新点。然后像右边显示的那样连接起来。这里没有显示原始点的权重。</p>
<p><strong>上图显示了Catmull-Clark曲面的基本思想，757页图17.41显示了一个Catmull-Clark细分的实际例子。可以看出，该方案只生成四个顶点的面。事实上，在第一个细分步骤之后，只生成了价4的顶点，因此这些顶点被称为普通或规则(与三角方案的价6相比)。</strong></p>
<p><strong>按照Halstead等人的表示法，让我们关注顶点v^k 有n个周边边点ei^k，其中i = 0…n−1。参见下图。对于每一个面，都有一个新的面点f^(k+1) 为面形质心，即面上各点的平均值。鉴于此，细分规则为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102142421.png" class="" title="image-20211102142421">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102142704.png" class="" title="image-20211102142704">

<p>在细分之前，我们有蓝色顶点和相应的边和面。经过一步Catmull-Clark细分，我们得到红色顶点，所有新面都是四边形。(参见Halstead等人的插图。)</p>
<p><strong>可以看出，顶点v^(k+1)的计算方式为考虑的顶点的权重、边缘点的平均值和新创建的面点的平均值。另一方面，新的边缘点是通过考虑的顶点、边缘点和两个新创建的以边缘为邻居的面点的平均值来计算的。</strong></p>
<p><strong>Catmull-Clark曲面描述了一种广义双三次B样条曲面。因此，对于只由规则顶点组成的网格，我们实际上可以将曲面描述为双三次B样条曲面(章节17.2.6)。然而，这对于不规则的网格设置是不可能的，能够使用细分曲面处理这些是该方案的优点之一。极限位置和切线也可以使用显式公式计算，即使参数值是任意的。Halstead等人描述了一种计算极限点和法线的不同方法。</strong></p>
<p><strong>有关使用GPU渲染Catmull-Clark细分曲面的一组有效技术，请参见17.6.3节。</strong></p>
<h3 id="Piecewise-Smooth-Subdivision-分段平滑细分"><a href="#Piecewise-Smooth-Subdivision-分段平滑细分" class="headerlink" title="Piecewise Smooth Subdivision 分段平滑细分"></a>Piecewise Smooth Subdivision 分段平滑细分</h3><p><strong>从某种意义上说，曲面可能被认为是无趣的，因为它们缺乏细节。改进这种表面的两种方法是使用凹凸贴图或位移贴图(章节17.5.4)。这里描述了第三种方法，分段平滑细分。基本的想法是改变细分规则，使省道，角落，折痕可以使用。这增加了可以建模和表示不同表面的范围。Hoppe等人首先对Loop的细分曲面进行了描述。下图是标准Loop细分曲面和分段平滑细分曲面的比较。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102144725.png" class="" title="image-20211102144725">

<p>顶部的行显示了一个控制网格，以及使用标准Loop细分方案的极限曲面。下面一行显示了使用Loop方案的分段平滑细分。左下角的图像显示了带有标记边缘(锐)的控制网格，用浅灰色显示。由此产生的表面显示在右下角，带有角落、飞镖和折痕。(图片由Hugues Hoppe提供。)</p>
<p><strong>为了能够在表面上使用这些特征，我们想要锐利的边缘首先被标记，所以我们知道在哪里细分不同。锋利边缘的数量在一个顶点表示s。然后顶点分为:光滑(s = 0),飞镖(s = 1),折痕(s = 2),和角落(s &gt; 2)。因此,折痕表面是一条曲线,曲线是C⁰连续性。飞镖是一个非边界顶点，其中折痕结束并平滑地融入曲面。最后，一个角是三个或更多折痕在一起的顶点。边界可以通过将每个边界边缘标记为锐来定义。</strong></p>
<p><strong>在对各种顶点类型进行分类后，Hoppe等人使用一个表来确定对各种组合使用哪个掩码。它们还展示了如何计算极限曲面点和极限切线。Biermann等人提出了几种改进的细分规则。例如，当特殊顶点位于边界上时，前面的规则可能会导致间隙。新规则避免了这种情况。此外，它们的规则使指定顶点的法线成为可能，结果曲面将适应获得该点的法线。DeRose等人提出了一种创建软折痕的技术。它们允许边首先细分为尖锐的多次(包括分数)，然后使用标准细分。</strong></p>
<h3 id="Displaced-Subdivision-置换的细分"><a href="#Displaced-Subdivision-置换的细分" class="headerlink" title="Displaced Subdivision 置换的细分"></a>Displaced Subdivision 置换的细分</h3><p><strong>凹凸贴图(章节6.7)是一种为光滑表面添加细节的方法。然而，这只是一个错觉，改变了每个像素的正常或局部遮挡。不管有没有凹凸贴图，物体的轮廓看起来是一样的。凹凸映射的自然扩展是位移映射，其中表面是位移的。这通常是沿着法线的方向进行的。如果曲面上的点是p，它的标准化法线是n，那么移位曲面上的点是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102145611.png" class="" title="image-20211102145611">

<p><strong>标量d是p点的位移。位移也可以是向量值。</strong></p>
<p><strong>在本节中，将给出位移细分曲面。一般的想法是将一个移位的表面描述为一个粗控制网格，它被细分为一个光滑的表面，然后沿着其法线使用标量场移位。在位移细分曲面的情况下，式17.67中p为粗控制网格细分曲面上的极限点，n为在p处的归一化法线，计算为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102145719.png" class="" title="image-20211102145719">

<p><strong>在方程17.68中，pu 和pv 为细分曲面的一阶导数。因此，他们在p。 Lee等人中描述了两条切线，使用了粗控制网格的Loop细分曲面，其切线可由式17.65计算。注意这里的符号略有不同;我们使用pu 和pv 而不是tu 和tv．方程17.67描述了最终曲面的位移位置，但我们还需要一个法线ns，以便正确地渲染细分表面。分析计算如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102145812.png" class="" title="image-20211102145812">

<p><strong>为了简化计算，Blinn提出，如果位移较小，可以忽略第三项。否则，可使用以下表达式计算nu (同样的nv) :</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102145845.png" class="" title="image-20211102145845">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102150006.png" class="" title="image-20211102150006">

<p>在Loop的细分方案中一个普通顶点的掩模。注意，在使用这些掩码之后，结果的总和应该按如下所示进行分割。(参见Lee等人的插图。)</p>
<p><strong>请注意,n¯u 不是任何新的符号，它仅仅是计算中的一个“临时”变量。对于一个普通顶点(价n = 6)，第一和第二阶导数特别简单。他们的掩码如上图所示。对于一个特殊顶点(价n6 = 6)，方程17.69中第一行和第二行的第三项被省略。下图显示了一个使用带有Loop细分的位移映射的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102150106.png" class="" title="image-20211102150106">

<p>左边是一个粗糙的网格。在中间，它使用Loop的细分方案进行细分。右图显示了移位的细分表面。(图片由Aaron Lee、Henry Moreton和Hugues Hoppe提供。)</p>
<p><strong>当一个被置换的表面远离观察者时，标准凹凸贴图可以用来产生这种置换的错觉。这样做可以节省几何处理。一些凹凸映射方案需要顶点处的切空间坐标系统，可以使用以下方法:(b, t, n)，其中t = pu/ | | pu| |,b = n × t。</strong></p>
<p><strong>Nießner和Loop提出了与Lee等人类似的方法，但他们采用Catmull-Clark曲面，直接求位移函数的导数，速度更快。它们还使用硬件镶嵌管道(第3.6节)进行快速镶嵌。</strong></p>
<h3 id="Normal-Texture-and-Color-Interpolation-法线、纹理和颜色插值"><a href="#Normal-Texture-and-Color-Interpolation-法线、纹理和颜色插值" class="headerlink" title="Normal, Texture, and Color Interpolation 法线、纹理和颜色插值"></a>Normal, Texture, and Color Interpolation 法线、纹理和颜色插值</h3><p><strong>在本节中，我们将介绍不同的策略来处理法线，纹理坐标和每个顶点的颜色。</strong></p>
<p><strong>如第17.5.1节Loop格式所示，极限切线和极限法线可以显式计算。这涉及到三角函数，计算起来可能很昂贵。Loop和Schaefer提出了一种近似技术，其中Catmull-Clark曲面总是用双三次B´ezier曲面来近似(第17.2.1节)。对于法线，导出了两个切线，一个在u方向，一个在v方向。法向量就是这些向量之间的叉乘。一般来说，B´ezier patch的导数是用公式17.35计算的。但是，由于导出的B´ezier patches近似于Catmull-Clark surface，因此切线patches不会形成一个连续的法向场。参考Loop和Schaefer关于如何克服这些问题的论文。Alexa和Boubekeur认为，细分法线可以在每次计算的质量方面更有效，这在阴影中提供了更好的连续性。关于如何细分法线的细节，我们参阅他们的论文。在Ni等人的SIGGRAPH课程中还可以找到更多类型的近似。</strong></p>
<p><strong>假设网格中的每个顶点都有一个纹理坐标和颜色。为了能够使用这些细分表面，我们还必须为每个新生成的顶点创建颜色和纹理坐标。最明显的方法是使用与我们用于细分多边形网格相同的细分方案。例如，您可以将颜色视为四维向量(RGBA)，并将其细分为新的顶点创建新的颜色。这是一种合理的方法，因为颜色将有一个连续的导数(假设细分方案至少为C¹)，从而避免在表面上颜色的突然变化。当然，纹理坐标也可以这样做。然而，当纹理空间有边界时，必须小心。例如，假设我们有两个共享一条边的贴片，但是沿着这条边有不同的纹理坐标。几何图形应该像往常一样用表面规则进行细分，但是纹理坐标应该用边界规则进行细分。</strong></p>
<p><strong>Piponi和Borshukov给出了一种复杂的纹理细分曲面方案。</strong></p>
<h2 id="Efficient-Tessellation-高效曲面细分"><a href="#Efficient-Tessellation-高效曲面细分" class="headerlink" title="Efficient Tessellation 高效曲面细分"></a>Efficient Tessellation 高效曲面细分</h2><p><strong>为了在实时渲染环境中显示曲面，我们通常需要创建曲面的三角形网格表示。这个过程被称为镶嵌。最简单的镶嵌形式叫做均匀镶嵌。假设我们有一个参数B´ezier patch, p(u, v)，如公式17.32所述。我们想要通过计算每个贴片边11个点来镶嵌这个贴片，结果是10 × 10 × 2 = 200个三角形。最简单的方法是对紫外线空间进行均匀采样。因此，我们求p(u, v)对所有(uk, vl) = (0.1k, 0.1l)，其中k和l都可以是任意值0 ~ 10之间的整数。这可以通过两个嵌套的for循环来实现。可以为平面上的四个点p(uk, vl)、p (uk+1, vl)、p (uk+1, vl+1), p (uk, vl+1)．</strong></p>
<p><strong>虽然这很简单，但有更快的方法。比起通过总线从CPU到GPU发送由许多三角形组成的镶嵌曲面，将曲面表示发送给GPU并让它处理数据扩展更有意义。回想一下，镶嵌阶段在第3.6节中有描述。快速浏览，请参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102150659.png" class="" title="image-20211102150659">

<p>管线与硬件镶嵌，其中的新阶段显示在中间的三个(蓝色)框。我们在这里使用DirectX的命名约定，括号里是OpenGL的对应项。壳着色器计算控制点的新位置和计算镶嵌因子，这决定了后续步骤应该生成多少个三角形。镶嵌器在紫外线空间中生成点，在这种情况下是一个单位正方形，并将它们连接成三角形。最后，域着色器使用控制点计算每个uv坐标的位置。</p>
<p><strong>镶嵌器可以使用分数镶嵌技术，这将在下一节中描述。最后，我们描述了如何用镶嵌硬件渲染Catmull-Clark曲面和位移映射曲面。</strong></p>
<h3 id="Fractional-Tessellation-部分镶嵌"><a href="#Fractional-Tessellation-部分镶嵌" class="headerlink" title="Fractional Tessellation 部分镶嵌"></a>Fractional Tessellation 部分镶嵌</h3><p><strong>为了获得参数曲面更平滑的细节水平，Moreton引入了分数阶镶嵌因子。这些因素使自适应镶嵌的有限形式成为可能，因为不同的镶嵌因素可以在参数曲面的不同侧面使用。下面将介绍这些技术的工作原理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102155722.png" class="" title="image-20211102155722">

<p>左:普通镶嵌-一个因子用于行，另一个用于列。右:四条边的独立镶嵌因子。(参考莫尔顿的插图。)</p>
<p><strong>在上图中，左侧为行和列的常量镶嵌因子，右侧为所有四条边的独立镶嵌因子。注意，一条边的镶嵌因子是在那条边上生成的点的数目，减去1。在右边的贴片中，这两条边的内部使用了较大的顶部和底部因子，同样的，左右因子的较大也用于内部。因此，基本镶嵌率为4 × 8。对于因数较小的边，沿边填充三角形。Moreton更详细地描述了这个过程。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102155911.png" class="" title="image-20211102155911">

<p>上图:整数镶嵌。中间:分数镶嵌，分数向右。下:分数镶嵌，分数在中间。这种配置避免了相邻贴片之间的裂缝。</p>
<p><strong>分数阶镶嵌因子的概念如上图所示。对于n的整数镶嵌因子，在k/n处生成n + 1个点，其中k = 0，…对于分数阶镶嵌因子，在k/r处生成r，⌈r⌉点，式中k = 0，…,⌊r⌋。在这里，⌈r⌉计算r的上限，这是最接近+∞的整数，而数组元素⌊r⌋的值则计算下限，这是最接近−∞的整数。然后，最右边的点被“折断”到最右边的端点。从上图中间的插图可以看出，这个模式不是对称的。这就导致了问题，因为相邻的补丁可能会在另一个方向产生点，从而在表面之间产生裂缝。Moreton通过创建对称的点模式解决了这个问题，如上图底部所示。参见下图中的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102160312.png" class="" title="image-20211102160312">

<p>矩形区域被分割成小块的一种贴片。(参考莫尔顿的插图。)</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102160445.png" class="" title="image-20211102160445">

<p>三角形的分数阶镶嵌，镶嵌因子显示。请注意，镶嵌因子可能与实际的镶嵌硬件所产生的不完全一致。(图源自Tatarchuk)</p>
<p><strong>到目前为止，我们已经看到了用矩形域镶嵌曲面的方法，例如，B´ezier patches。然而，三角形也可以用分数进行镶嵌，如上图所示。像四边形一样，也可以为每个三角形的边指定一个独立的分数阶镶嵌率。如前所述，这启用了自适应镶嵌(第17.6.2节)，如下图所示，其中渲染了位移映射的地形。一旦创建了三角形或四边形，就可以将它们转发到管线中的下一个步骤，这将在下一个小节中处理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102160532.png" class="" title="image-20211102160532">

<p>使用自适应分数阶镶嵌的移位地形绘制。从右侧的放大网格可以看出，红色三角形的边缘使用独立的分数形镶嵌率，这给了我们自适应镶嵌。(图片由Advanced Micro Devices, Inc. Game Computing Applications Group提供)</p>
<h3 id="Adaptive-Tessellation-适应性镶嵌"><a href="#Adaptive-Tessellation-适应性镶嵌" class="headerlink" title="Adaptive Tessellation 适应性镶嵌"></a>Adaptive Tessellation 适应性镶嵌</h3><p><strong>当采样率足够高时，均匀镶嵌可以得到较好的结果。然而，在表面的某些区域可能不像在其他区域那样需要高镶嵌。这可能是因为表面在某些区域弯曲得更快，因此可能需要更高的镶嵌，而表面的其他部分几乎是平的或远的，只需要几个三角形来近似它们。解决产生不必要三角形问题的一个方法是自适应镶嵌，这是指根据某些度量来适应镶嵌率的算法(例如曲率，三角形边长，或一些屏幕尺寸测量)。上图显示了地形自适应镶嵌的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102160927.png" class="" title="image-20211102160927">

<p>在左边，两个区域之间可以看到一条裂缝。这是因为右边的镶嵌率比左边的高。问题在于右侧区域已经计算了有黑色圆圈的表面，而左侧区域没有。标准溶液在右边。</p>
<p><strong>必须小心避免在不同的镶嵌区域之间出现裂缝。参见上图。当使用分式镶嵌时，通常基于仅来自边缘本身的信息来确定边缘镶嵌因子，因为所有的边缘数据都是在两个连接的小块之间共享的。这是一个很好的开始，但由于浮点数不准确，仍然可能出现裂缝。Nießner等人讨论了如何使计算完全不漏水，例如，通过确保，对于一条边，无论是否从p0 p1进行镶嵌，返回的是完全相同的点，反之亦然。</strong></p>
<p><strong>在本节中，我们将介绍一些通用的技术，这些技术可以用来计算分数镶嵌率，或者决定何时终止进一步的镶嵌，以及何时将更大的块分割成一组更小的块。</strong></p>
<h4 id="Terminating-Adaptive-Tessellation-终止自适应镶嵌"><a href="#Terminating-Adaptive-Tessellation-终止自适应镶嵌" class="headerlink" title="Terminating Adaptive Tessellation 终止自适应镶嵌"></a>Terminating Adaptive Tessellation 终止自适应镶嵌</h4><p><strong>为了提供自适应镶嵌，我们需要确定何时停止镶嵌，或者等价地如何计算分数阶镶嵌因子。您可以只使用一条边的信息来确定镶嵌是否应该终止，或者使用来自整个三角形或组合的信息。</strong></p>
<p><strong>还应该注意的是，使用自适应镶嵌，如果某条边的镶嵌因素在一帧到下一帧之间变化太多，那么在帧之间就会出现“游泳”或“弹出”的伪影。这也可能是计算镶嵌因子时要考虑的因素。给定一条边(a, b)和一条相关曲线，即我们可以试着估计曲线在a和b之间的平坦程度，见下图。在参数空间中找到a与b之间的中点，并计算其三维对应点c。最后，计算c和它在a和b之间的投影d之间的长度l。这个长度l用来确定那条边上的曲线段是否足够平。如果l足够小，它就被认为是平的。注意，这种方法可能错误地认为s形曲线段是平的。解决这个问题的方法是随机扰动参数采样点。l的另一种用法是比值l/||a−b||，给出一个相对测度。注意，这种技术也可以扩展到考虑一个三角形，您只需计算三角形中间的曲面点，并使用从这个点到三角形平面的距离。为了确定这种类型的算法终止，通常会设置一些可以进行多少细分的上限。当达到这个极限时，再细分就结束了。对于分数镶嵌，从c到d的矢量可以投影到屏幕上，它的(缩放的)长度用作镶嵌率。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102161558.png" class="" title="image-20211102161558">

<p>点a和点b已经在这个曲面上生成了。问题是:应该在曲面上生成一个新的点c吗?</p>
<p><strong>到目前为止，我们已经讨论了如何仅从曲面的形状来确定镶嵌率。其他通常用于动态镶嵌的因素包括顶点的局部邻域是否为:</strong></p>
<p><strong>1.在视图截锥内。</strong></p>
<p><strong>2.朝前的面。</strong></p>
<p><strong>3.占据较大的屏幕空间。</strong></p>
<p><strong>4.接近物体的轮廓。</strong></p>
<p><strong>这些因素将在这里依次讨论。对于视图截锥剔除，可以放置一个球体来包围边缘。然后在视图截锥上测试这个球体。如果它在外面，我们就不进一步细分那条边。</strong></p>
<p><strong>对于表面剔除，在a, b和可能的c处的法线可以从表面描述中计算出来。这些法线，连同a,b,c，定义了三个平面。如果所有的都是背面的，很可能不需要进一步细分的边缘。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102161832.png" class="" title="image-20211102161832">

<p>线段的屏幕空间投影s的估计。</p>
<p><strong>有许多不同的方法可以实现屏幕空间覆盖(请参见第19.9.2节)。所有的方法都将一些简单的物体投射到屏幕上，并估计屏幕空间的长度或面积。一个大的面积或长度意味着镶嵌应该进行。从a到b的线段的屏幕空间投影的快速估计如上图所示。首先，线段被平移，使其中点在视图射线上。然后，假设线段平行于近平面n，屏幕空间投影s从这条线段计算出来。使用图中线段a ‘和b ‘向右的点，屏幕空间投影就完成了</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102161939.png" class="" title="image-20211102161939">

<p><strong>分子就是线段的长度。除以从眼睛到线段中点的距离e。然后将计算得到的屏幕空间投影s与表示屏幕空间中最大边长的阈值t进行比较。重写前一个方程，避免计算平方根，如果满足以下条件，镶嵌继续:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102162017.png" class="" title="image-20211102162017">

<p><strong>注意，t²是常数，所以可以预先计算。对于分数镶嵌，可以使用公式17.71中的s作为镶嵌率，可能还应用了比例因子。另一种测量投影边长的方法是将一个球体置于边缘的中心，使半径为边缘长度的一半，然后利用球体的投影作为边缘镶嵌因子。这个测试与面积成正比，而上面的测试与边长成正比。</strong></p>
<p><strong>增加轮廓的镶嵌率是很重要的，因为它们对物体的感知质量起着主要作用。通过测试a点的法向量和从眼睛到a的向量之间的点积是否接近于零，可以确定一个三角形是否靠近轮廓边。如果这对a, b或c中的任何一个都成立，就应该做进一步的镶嵌。</strong></p>
<p><strong>对于移位细分，Nießner和Loop对每个基网格顶点v使用下列因素之一，该顶点与n个边向量ei相连，i ∈ {0, 1, . . . , n − 1}:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102162215.png" class="" title="image-20211102162215">

<p><strong>当循环的下标i遍历所有连接到v的n条边ei时，c的位置是和ki 是用户提供的常数。在这里,f1 是简单地基于从摄像机到顶点的距离f2 计算连接v和f3的四边形的面积使用最大的边长。顶点的镶嵌因子是然后计算为该边的两个基顶点的镶嵌因子的最大值。内镶嵌因子的计算是对边的镶嵌因子的最大值(以u和v为单位)。这种方法可以用于本节中介绍的任何边缘镶嵌因子方法。</strong></p>
<p><strong>值得注意的是，Nießner等人建议对字符使用单个全局镶嵌因子，这取决于与字符的距离。细分的数量是⌈log₂f⌉，其中f是每个字符的镶嵌因子，可以使用上面的任何方法计算。</strong></p>
<p><strong>很难说什么方法在所有应用程序中都有效。最好的建议是测试几个给出的启发式方法，以及它们的组合。</strong></p>
<h4 id="Split-and-Dice-Methods-分割法"><a href="#Split-and-Dice-Methods-分割法" class="headerlink" title="Split and Dice Methods 分割法"></a>Split and Dice Methods 分割法</h4><p><strong>Cook等人引入了一种叫做分割和骰子的方法，其目标是对曲面进行镶嵌，使每个三角形都变成像素大小，以避免几何混叠。为了实时目的，镶嵌阈值应该增加到GPU能够处理的范围。每个patch首先被递归地分割成一组子patch，直到估计如果对某个子patch使用均匀镶嵌，三角形将具有所需的大小。因此，这也是一种自适应镶嵌。</strong></p>
<p><strong>想象一下，一块大的土地被用作景观。一般来说，分数镶嵌是不可能适应的，例如，在靠近相机的地方镶嵌率更高，在离相机较远的地方镶嵌率更低。因此，分割和骰子的核心可能对实时渲染有用，即使在我们的情况下，目标镶嵌率是拥有比像素大小更大的三角形。</strong></p>
<p><strong>接下来，我们描述了在实时图形场景中分割和骰子的一般方法。假设使用矩形补丁。然后用整个参数域开始一个递归例程，即从(0,0)到(1,1)的平方。使用刚才描述的自适应终止准则，测试曲面是否足够镶嵌。如果是，则终止镶嵌。否则，将这个域分割成四个大小相同的不同的正方形，并递归地为每一个子正方形调用例程。继续递归，直到曲面被足够镶嵌或达到预定义的递归级别。这种算法的本质意味着在镶嵌过程中递归地创建四叉树。然而，如果相邻的子方块被镶嵌到不同的水平，就会产生裂缝。标准的解决方法是确保两个相邻的子平方至多只在一个水平上不同。这叫做受限四叉树。然后使用如图17.59中右侧所示的技术来填充裂缝。这种方法的缺点是簿记比较复杂。</strong></p>
<p><strong>Liktor等人提出了一种用于GPU的分裂和骰子的变体。问题是，避免游泳和弹出伪影的影响突然决定再次分裂，因为，例如，相机已经移动到一个表面更近。为了解决这个问题，他们使用了分数分割方法，这是受到分数镶嵌的启发。如下图所示。由于分裂是平滑地引入从一边的曲线中心，或向中心的贴片的一面，游泳和弹出的伪影。当自适应镶嵌的终止准则为，每个剩余的子patch也使用分数镶嵌由GPU进行镶嵌。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102162837.png" class="" title="image-20211102162837">

<p>分数分裂应用于三次B´ezier曲线。每条曲线的镶嵌率t被显示出来。分裂点是一个大的黑色圆圈，它从曲线的右侧向曲线的中心移动。为了分割三次曲线，黑点被平滑地移向曲线的中心，原始曲线被两个三次B´ezier分段代替，它们一起生成原始曲线。在右边，同样的概念演示了一个patch，它被分成了四个更小的子patch，其中1.0表示分裂点在边缘的中心点，0.0表示它在patch的角落。(参考Liktor等的插图。)</p>
<h3 id="Fast-Catmull-Clark-Tessellation-快速卡特穆尔-克拉克镶嵌"><a href="#Fast-Catmull-Clark-Tessellation-快速卡特穆尔-克拉克镶嵌" class="headerlink" title="Fast Catmull-Clark Tessellation 快速卡特穆尔-克拉克镶嵌"></a>Fast Catmull-Clark Tessellation 快速卡特穆尔-克拉克镶嵌</h3><p><strong>Catmull-Clark曲面(章节17.5.2)经常用于建模软件和故事片渲染，因此能够使用图形硬件高效地渲染这些曲面是很有吸引力的。卡特莫尔-克拉克曲面的快速镶嵌方法是近年来研究的热点。在这里，我们将展示其中的一些方法。</strong></p>
<h4 id="Approximating-Approaches-近似的方法"><a href="#Approximating-Approaches-近似的方法" class="headerlink" title="Approximating Approaches 近似的方法"></a>Approximating Approaches 近似的方法</h4><p><strong>Loop和Schaefer提出了一种技术，将Catmull-Clark曲面转换为一种可以在域着色器中快速评估的表示，而不需要知道多边形的邻居。</strong></p>
<p><strong>如17.5.2节所述，Catmull-Clark曲面可以描述为许多小B样条曲面，且所有顶点都是普通的。Loop和Schaefer将原始Catmull-Clark细分网格中的四边形(quad)多边形转换为双立方B´ezier曲面(章节17.2.1)。这对于非四边形是不可能的，所以我们假设没有这样的多边形(回想一下，在细分的第一步之后，只有四边形多边形)。当一个顶点的效价不同于4时，就不可能创建一个与Catmull-Clark曲面相同的双三次B´ezier贴片。因此，本文提出了一种近似表示方法，该方法适用于具有四个顶点的四边形，并且在其他地方与Catmull-Clark曲面很接近。为此，使用了几何小块和切线小块，下面将对此进行描述。</strong></p>
<p><strong>几何贴片只是一个带有4 × 4控制点的双三次B´ezier贴片。我们将描述如何计算这些控制点。一旦完成，贴片可以镶嵌和域着色器可以快速评估B´ezier贴片在任意坐标(u,v)。所以，假设我们有一个网格，只包含顶点为4的四边形，我们想要计算网格中特定四边形的相应B´ezier patch的控制点。为此，需要院子周围的社区。这样做的标准方法如下图所示，其中显示了三个不同的掩码。这些可以旋转和反射，以创建所有16个控制点。注意，在实现中，掩码的权重总和应该为1，为了清晰起见，这里省略了这个过程。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102163542.png" class="" title="image-20211102163542">

<p>左:一个四边形网格的一部分，我们想为灰色四边形计算一个B´ezier补丁。注意，灰色四边形的顶点只有值为4。蓝色的顶点是相邻四边形的顶点，绿色的圆圈是B´ezier补丁的控制点。下面的三个插图显示了用于计算绿色控制点的不同掩码。例如，要计算一个内部控制点，需要使用右中蒙版，并且用蒙版中显示的权重对四边形的顶点进行加权。</p>
<p><strong>上述技术为普通情况计算一个B´ezier补丁。当至少有一个特殊顶点时，我们计算一个特殊patch。用于此的遮罩如下图所示，其中灰色四边形中的左下角顶点是一个特殊顶点。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102163725.png" class="" title="image-20211102163725">

<p>左:一个B´ezier补丁的灰色四边形的网格将被生成。灰色四边形的左下角顶点是不寻常的，因为它的效价是n≠4。蓝色的顶点是相邻四边形的顶点，绿色的圆圈是B´ezier补丁的控制点。下面的三个插图显示了用于计算绿色控制点的不同掩码。</p>
<p><strong>注意，这导致了一个patch，近似于Catmull-Clark细分表面，并且，它只是C⁰ 沿着顶点特殊的边。当添加着色时，这通常看起来会分散注意力，因此建议使用类似于N-patches(第17.2.4节)的技巧。然而，为了减少计算复杂度，有两个导出了切块:一个在u方向，一个在v方向。法向量就是这些向量之间的叉乘。一般来说，B´ezier patch的导数是用公式17.35计算的。但是，由于导出的B´ezier patches近似于Catmull-Clark surface，因此切线patches不会形成一个连续的法向场。参考Loop和Schaefer关于如何克服这些问题的论文。下图显示了可能出现的工件类型的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102163911.png" class="" title="image-20211102163911">

<p>左:网格的四边形结构。白色四边形很普通，绿色四边形有一个特别的顶点，蓝色四边形有不止一个顶点。中左:几何贴片近似。中右:带有切线块的几何块。注意，明显的(红色圆圈)着色效果消失了。右图:卡特莫尔-克拉克表面。(图片由Charles Loop和Scott Schaefer提供，经微软公司许可转载。)</p>
<p><strong>Kovacs等人描述了如何将上述方法扩展到同样处理折痕和拐角(章节17.5.3)，并在Valve的Source引擎中实现这些扩展。</strong></p>
<h4 id="Feature-Adaptive-Subdivision-and-OpenSubdiv-特征自适应细分和OpenSubdiv"><a href="#Feature-Adaptive-Subdivision-and-OpenSubdiv-特征自适应细分和OpenSubdiv" class="headerlink" title="Feature Adaptive Subdivision and OpenSubdiv 特征自适应细分和OpenSubdiv"></a>Feature Adaptive Subdivision and OpenSubdiv 特征自适应细分和OpenSubdiv</h4><p><strong>皮克斯提出了一个叫做OpenSubdiv的开源系统，它实现了一套叫做特征自适应细分(FAS)的技术。基本方法与前面讨论的技术有很大不同。这项工作的基础在于，对于正则面，细分等价于双三次B样条patch(章节17.2.6)，即:四边形中每个顶点都是规则的，这意味着顶点有四价。因此，细分只递归地继续为非规则面，直到达到某个最大的细分级别。如下图所示。FAS还可以处理折痕和半光滑折痕，FAS算法还需要围绕这些折痕进行细分，如下图的右侧所示。双三次B样条贴片可以直接用镶嵌流水线进行渲染。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102164234.png" class="" title="image-20211102164234">

<p>左:围绕一个特殊顶点的递归细分，即中顶点有三条边。随着递归的继续，它会在后面留下一组规则的补丁(有四个顶点，每个顶点有四条进入的边)。右:围绕中间粗线表示的平滑折痕进行细分。(图接Nießner等。)</p>
<p><strong>该方法首先使用CPU创建一个表。该表对顶点的索引进行编码，这些顶点在细分到指定级别时需要被访问。因此，基础网格可以是动画的，因为索引独立于顶点位置。一旦生成了一个双三次B样条补丁，就不需要继续递归了，这意味着表通常会变得相对较小。将基础网格、索引表、附加价和折痕数据上传到GPU一次。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102164453.png" class="" title="image-20211102164453">

<p>红色方块是过渡补丁，每个都有四个直接邻居，它们要么是蓝色(当前细分级别)，要么是绿色(下一个细分级别)。这张图展示了五种可能出现的配置，以及它们是如何拼接在一起的。(图接Nießner等。)</p>
<p><strong>要细分网格一步，首先计算新的面点，然后是新的边缘点，最后更新顶点，每个类型使用一个计算着色器。在渲染方面，我们区分了完整补丁和过渡补丁。一个完整的patch (FP)只与相同细分级别的patch共享边，而一个规则的FP使用GPU镶嵌流水线直接渲染为一个双三次B样条patch。否则继续细分。自适应细分过程保证相邻块之间最多存在一个细分级别的差异。一个过渡patch (TP)与至少一个邻居的细分水平存在差异。为了得到无裂纹的渲染图，每个TP被分成几个子patch，如上图所示。用这种方法，镶嵌的顶点沿着每条边的两边匹配。每种类型的子补丁都使用不同的外壳和实现插值变体的域着色器进行渲染。例如，上图中最左边的情况被渲染为三个三角形B样条补丁。在特殊顶点周围，使用另一个域着色器，使用Halstead等人的方法计算极限位置和极限法线。下图显示了一个使用OpenSubdiv的Catmull-Clark表面渲染的例子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102164509.png" class="" title="image-20211102164509">

<p>左图:绿色和红色线条的控制网格，灰色表面(8k顶点)，使用一个细分步骤生成。中间:网格再细分两个步骤(102k顶点)。右:使用自适应镶嵌生成的表面(28k顶点)。(使用OpenSubdiv的dxViewer生成的图像。)</p>
<p><strong>FAS算法处理折痕、半光滑折痕、层次细节和自适应细节水平。详见FAS论文和Nießner博士论文。Sch¨afer等人提出了FAS的一种变体，称为DFAS，它甚至更快。</strong></p>
<h4 id="Adaptive-Quadtrees-自适应四叉树"><a href="#Adaptive-Quadtrees-自适应四叉树" class="headerlink" title="Adaptive Quadtrees 自适应四叉树"></a>Adaptive Quadtrees 自适应四叉树</h4><p><strong>Brainerd等人提出了一种称为自适应四叉树的方法。它类似于Loop和Schaefer的近似方案，每个原始基网格的四瓣都提交一个单一的镶嵌基元。此外，它预计算一个细分计划，这是一个四叉树，从一个输入面编码层次细分(类似于特征自适应细分)，直到某个最大细分级别。细分计划还包含细分面所需控制点的模板掩码列表。</strong></p>
<p><strong>在绘制过程中，遍历四叉树，使得将(u, v)坐标映射到细分层次结构中的一个patch成为可能，这个patch可以直接被求值。四叉树叶是原始人脸域的子区域，该子区域内的曲面可以直接使用模板中的控制点进行计算。在域着色器中使用迭代循环遍历四叉树，其输入是参数(u, v)坐标。遍历需要继续，直到到达(u, v)坐标所在的叶节点。根据四叉树中到达的节点类型，将采取不同的操作。例如，当到达一个可以直接评估的子区域时，它对应的双三次B样条补丁的16个控制点被检索，着色器继续评估该补丁。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102164844.png" class="" title="image-20211102164844">

<p>左图:根据特征自适应细分(FAS)的分层细分，其中每个三角形和四边形被渲染为一个单独的镶嵌基元。右图:使用自适应四叉树进行分层细分，整个四叉树被渲染为一个单一的镶嵌基元。(Brainerd等人的插图。)</p>
<p><strong>参见第718页的图17.1，以获得使用这种技术呈现的示例。这种方法是迄今为止最快的精确渲染卡特穆尔-克拉克细分曲面的方法，并处理折痕和其他拓扑特征。与FAS相比，使用自适应四叉树的另一个优势如上图所示，并进一步如下图所示。自适应四叉树还提供了更统一的镶嵌，因为在每个提交的四叉树和镶嵌基元之间存在一对一的映射。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211102164901.png" class="" title="image-20211102164901">

<p>使用自适应四叉树细分补丁。每个patch，对应一个基本网格面，被黑色曲线包围在表面上，细分步骤在每个patch内部分层说明。可以看到，在中间有一块颜色一致的斑块。这意味着它被渲染为一个双三次B样条补丁，而其他(特殊顶点)清楚地显示它们的底层自适应四叉树。(图片由Wade Brainerd提供。)</p>
<h1 id="18-Pipeline-Optimization-管线优化"><a href="#18-Pipeline-Optimization-管线优化" class="headerlink" title="18 Pipeline Optimization 管线优化"></a>18 Pipeline Optimization 管线优化</h1><p><strong>在这本书中，算法已经在质量、内存和性能权衡的背景下被提出。在本章中，我们将讨论与特定算法无关的性能问题和机会。瓶颈检测和优化是重点，从进行小的、本地化的更改开始，到构建整个应用程序以利用多处理功能的技术结束。</strong></p>
<p><strong>正如我们在第二章中看到的，渲染图像的过程是基于流水线架构的，有四个概念阶段:应用程序、几何处理、光栅化和像素处理。总有一个阶段是瓶颈——管道中最慢的进程。这意味着这个瓶颈阶段为吞吐量设置了限制，即总的渲染性能，因此是一个主要的候选优化。</strong></p>
<p><strong>优化渲染流水线的性能类似于优化流水线处理器(CPU)，它主要由两个步骤组成。首先，确定管线的瓶颈。第二，这个阶段在某种程度上是优化的;在那之后，如果没有达到性能目标，就重复第一步。注意，在优化步骤之后，瓶颈可能位于，也可能不在同一个位置。最好只花足够的精力来优化瓶颈阶段，使瓶颈转移到另一个阶段。在此阶段再次成为瓶颈之前，可能需要对其他几个阶段进行优化。因此，不应该把精力浪费在过度优化阶段上。</strong></p>
<p><strong>瓶颈的位置可能在一帧中改变，甚至在一个draw调用中。在某一时刻，几何阶段可能是瓶颈，因为许多小三角形被渲染。之后的帧像素处理可能会成为瓶颈，因为重量级程序着色器在每个像素处进行评估。在像素着色器中，执行可能会因为纹理队列已满而暂停，或者在到达特定循环或分支时花费更多时间。所以，当我们谈到，比如说，应用阶段是瓶颈，我们的意思是在这一帧的大部分时间里都是瓶颈。瓶颈很少只有一个。</strong></p>
<p><strong>另一种利用流水线结构的方法是认识到，当最慢的阶段不能进一步优化时，其他阶段可以像最慢的阶段一样工作。这不会改变性能，因为最慢阶段的速度不会改变，但额外的处理可以用来改善图像质量。例如，假设瓶颈在应用阶段，该阶段生成一帧需要50毫秒，而其他阶段生成一帧需要25毫秒。这意味着不改变渲染管线的速度(50毫秒等于20帧每秒)，几何和光栅化阶段也可以在50毫秒内完成他们的工作。例如，我们可以使用更复杂的照明模型，或者使用阴影和反射来增加真实感，假设这不会增加应用阶段的工作量。</strong></p>
<p><strong>计算着色器也改变了我们对瓶颈和未使用资源的看法。例如，如果正在渲染阴影地图，顶点和像素着色器很简单，如果固定功能阶段(如光栅化或像素合并)成为瓶颈，GPU计算资源可能未得到充分利用。使用异步计算着色器重叠这些绘制可以在这些条件出现时保持着色器单元繁忙。本章的最后一节将讨论基于任务的多处理。</strong></p>
<p><strong>管线优化是一个过程，在这个过程中，我们首先最大化渲染速度，然后允许不是瓶颈的阶段消耗和瓶颈一样多的时间。也就是说，这并不总是一个简单的过程，因为GPU和驱动程序可以有自己的特性和快速路径。当阅读这一章时，格言</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211103110256.png" class="" title="image-20211103110256">

<p>知道你的架构</p>
<p><strong>应该始终牢记于心，因为优化技术对于不同的架构有很大的不同。也就是说，要谨慎地基于特定GPU的功能实现进行优化，因为硬件可能也会随着时间的推移而变化。一个相关的格言，简单地说，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211103110306.png" class="" title="image-20211103110306">

<p>测量，测量，测量</p>
<h2 id="Profiling-and-Debugging-Tools-分析和调试工具"><a href="#Profiling-and-Debugging-Tools-分析和调试工具" class="headerlink" title="Profiling and Debugging Tools 分析和调试工具"></a>Profiling and Debugging Tools 分析和调试工具</h2><p><strong>分析和调试工具对于发现代码中的性能问题是非常有用的。能力各不相同，可以包括:</strong></p>
<pre><code>**•帧捕获和可视化。通常一步一步的帧重放是可用的，显示使用中的状态和资源。**

**•分析CPU和GPU花费的时间，包括调用图形API的时间。**

**•着色器调试，并可能热编辑，以查看更改代码的效果。**

**•在应用程序中使用调试标记，以帮助识别代码区域。**
</code></pre>
<p><strong>分析和调试工具因操作系统、图形API以及GPU供应商而异。大多数组合都有工具，这就是为什么神创造了谷歌。也就是说，我们将提到几个包的名称专门为交互式图像，让你开始你的任务:</strong></p>
<pre><code>**•RenderDoc是一个用于DirectX, OpenGL和Vulkan的高质量Windows调试器，最初由Crytek开发，现在是开源的。**

**•GPU PerfStudio是AMD的图形硬件套件，适用于Windows和Linux。一个值得注意的工具是静态着色分析器，它可以在不运行应用程序的情况下给出性能评估。AMD的Radeon GPU Profiler是一个独立的相关工具。**

**•NVIDIA Nsight是一个性能和调试系统，具有广泛的功能。它集成了Windows上的Visual Studio和Mac OS和Linux上的Eclipse。**

**•Xbox开发人员长期使用微软的PIX，并已在Windows上的DirectX 12中重新启用。Visual Studio的图形诊断功能可以用于DirectX的早期版本。**

**•来自微软的GPUView使用了Windows事件跟踪(ETW)，一个有效的事件日志系统。GPUView是ETW会话的几个消费者程序之一。重点研究了CPU与GPU之间的交互，指出了哪个是瓶颈。**

**•图形性能分析仪(GPA)是一套来自英特尔的套件，不专门针对其图形芯片，专注于性能和帧分析。**

**•OSX上的Xcode提供了Instruments，它有几个用于计时、性能、网络、内存泄漏等的工具。值得一提的是OpenGL ES Analysis，它检测性能和正确性问题并提出解决方案，以及Metal System Trace，它提供来自应用程序、驱动程序和GPU的跟踪信息。**
</code></pre>
<p><strong>这些是已经存在了几年的主要工具。也就是说，有时没有工具可以完成这项工作。定时器查询调用被内置在大多数API中，以帮助分析GPU的性能。一些供应商也提供了访问GPU计数器和线程跟踪的库。</strong></p>
<h2 id="Locating-the-Bottleneck-定位瓶颈"><a href="#Locating-the-Bottleneck-定位瓶颈" class="headerlink" title="Locating the Bottleneck 定位瓶颈"></a>Locating the Bottleneck 定位瓶颈</h2><p><strong>优化管线的第一步是找出最大的瓶颈。找到瓶颈的一种方法是设置多个测试，每个测试都减少特定阶段执行的工作量。如果其中一个测试导致每秒帧数增加，则发现瓶颈阶段。测试一个阶段的相关方法是减少其他阶段的工作负载，而不减少被测试阶段的工作负载。如果性能没有改变，那么瓶颈就是工作负载没有改变的阶段。性能工具可以提供关于哪些API调用是昂贵的详细信息，但不一定确切地指出管道中的哪个阶段减慢了其他阶段的速度。即使他们这样做了，理解每个测试背后的想法也是很有用的。</strong></p>
<p><strong>下面是一些用于测试不同阶段的想法的简要讨论，以便对这种测试是如何完成的有一个大致的了解。统一着色器架构的出现是理解底层硬件重要性的一个完美例子。从2006年底开始，它形成了许多GPU的基础。其理念是，顶点、像素和其他着色器都使用相同的功能单位。GPU负责负载平衡，改变分配给顶点和像素着色的单位比例。例如，如果渲染一个较大的四边形，只有少数着色器单元可以被分配到顶点变换，而大块则被分配到碎片处理的任务。确定瓶颈是在顶点着色阶段还是像素着色阶段并不明显。无论是作为一个整体着色处理还是另一个阶段仍然是瓶颈，然而，所以我们轮流讨论每个可能性。</strong></p>
<h3 id="Testing-the-Application-Stage-测试应用阶段"><a href="#Testing-the-Application-Stage-测试应用阶段" class="headerlink" title="Testing the Application Stage 测试应用阶段"></a>Testing the Application Stage 测试应用阶段</h3><p><strong>如果所使用的平台附带一个实用工具来测量处理器上的工作负载，则可以使用该实用工具来查看您的程序是否使用了100%(或接近100%)的CPU处理能力。如果CPU经常被使用，那么您的程序很可能是CPU有限的。这并不总是万无一失的，因为应用程序有时可能会等待GPU完成一帧。我们说一个程序受到CPU或GPU的限制，但是瓶颈在一帧的生命周期中会发生变化。</strong></p>
<p><strong>测试CPU限制的一个更聪明的方法是向下发送数据，导致GPU做很少或不做工作。对于某些系统，这可以通过简单地使用一个空驱动程序(一个接受调用但什么也不做的驱动程序)而不是一个真正的驱动程序来实现。这有效地设置了整个程序运行速度的上限，因为您不使用图形硬件，也不调用驱动程序，因此，CPU上的应用程序始终是瓶颈。通过执行此测试，您可以了解在应用程序阶段中不运行的基于GPU的阶段还有多少改进空间。也就是说，要注意，使用空驱动程序也可以隐藏由于驱动程序处理本身以及CPU和GPU之间的通信造成的任何瓶颈。驱动程序通常是CPU端瓶颈的原因，我们将在后面深入讨论这个话题。</strong></p>
<p><strong>另一种更直接的方法是降低CPU的时钟，如果可能的话。如果性能下降与CPU速率成正比，则应用程序至少在一定程度上是CPU绑定的。同样的降频方法也可以用于GPU。如果GPU速度变慢，性能下降，那么至少在某些时候应用程序是GPU绑定的。这些降频方法可以帮助识别瓶颈，但有时会导致之前不是瓶颈的阶段变成瓶颈。另一种选择是超频，但这里没有提到。</strong></p>
<h3 id="Testing-the-Geometry-Processing-Stage-测试几何处理阶段"><a href="#Testing-the-Geometry-Processing-Stage-测试几何处理阶段" class="headerlink" title="Testing the Geometry Processing Stage 测试几何处理阶段"></a>Testing the Geometry Processing Stage 测试几何处理阶段</h3><p><strong>几何学阶段是最难测试的阶段。这是因为如果这个阶段的工作负载发生了变化，那么其他阶段的一个或两个工作负载通常也会发生变化。为了避免这个问题，Cebenoyan给出了一系列光栅化阶段的测试。</strong></p>
<p><strong>在几何阶段有两个主要的瓶颈:顶点获取和处理。要查看瓶颈是否由于对象数据传输，请增加顶点格式的大小。例如，这可以通过向每个顶点发送几个额外的纹理坐标来实现。如果性能下降，这个区域就是瓶颈。</strong></p>
<p><strong>顶点处理由顶点着色器完成。对于顶点着色器瓶颈，测试包括使着色器程序更长。必须小心确保编译器没有优化掉这些额外的指令。</strong></p>
<p><strong>如果你的管道也使用几何着色器，它们的性能是输出大小和程序长度的函数。如果你使用镶嵌着色器，同样，程序长度影响性能，以及镶嵌因子。改变这些元素中的任何一个，同时避免在其他阶段执行的工作中发生变化，可以帮助确定是否有任何一个是瓶颈。</strong></p>
<h3 id="Testing-the-Rasterization-Stage-测试栅格化阶段"><a href="#Testing-the-Rasterization-Stage-测试栅格化阶段" class="headerlink" title="Testing the Rasterization Stage 测试栅格化阶段"></a>Testing the Rasterization Stage 测试栅格化阶段</h3><p><strong>这个阶段包括三角形设置和三角形遍历。使用极其简单的像素着色器的阴影地图生成，可能会在光栅化或合并阶段遇到瓶颈。虽然通常很少见，但三角形设置和栅格化可能成为镶嵌或草或树叶等物体的小三角形的瓶颈。然而，小三角形也可以增加顶点和像素着色器的使用。在一个给定的区域中，更多的顶点显然会增加顶点着色器的负载。像素着色器负载也增加了，因为每个三角形是由一组2 × 2的四边形光栅化的，所以每个三角形外的像素数量增加。这有时被称为四角遮蔽(第23.1节)。为了找出光栅化是否是真正的瓶颈，通过增加顶点和像素着色器的程序大小来增加它们的执行时间。如果每帧渲染时间没有增加，那么瓶颈就在光栅化阶段。</strong></p>
<h3 id="Testing-the-Pixel-Processing-Stage-测试像素处理阶段"><a href="#Testing-the-Pixel-Processing-Stage-测试像素处理阶段" class="headerlink" title="Testing the Pixel Processing Stage 测试像素处理阶段"></a>Testing the Pixel Processing Stage 测试像素处理阶段</h3><p><strong>像素着色程序的效果可以通过改变屏幕分辨率来测试。如果较低的屏幕分辨率导致帧率明显上升，那么像素着色器很可能是瓶颈，至少在某些时候是这样。如果有一个详细的系统，就必须小心。更小的屏幕还可能简化显示的模型，减轻几何阶段的负担。</strong></p>
<p><strong>降低显示分辨率还会影响三角遍历、深度测试和混合以及纹理访问等方面的成本。为了避免这些因素并隔离瓶颈，有一种方法与使用顶点着色程序相同，即添加更多指令以查看对执行速度的影响。同样，确定这些额外的指令没有被编译器优化掉是很重要的。如果帧渲染时间增加，像素着色器就会成为瓶颈(或者至少在执行成本增加时成为瓶颈)。或者，像素着色器可以简化到最少的指令数，这在顶点着色器中通常很难做到。如果总体渲染时间减少，就会发现瓶颈。纹理缓存失败的代价也很高。如果将纹理替换为1 × 1分辨率的版本能够获得相当快的性能，那么纹理内存访问将成为一个瓶颈。</strong></p>
<p><strong>着色器是独立的程序，有自己的优化技术。Persson介绍了几个低级的着色器优化，以及关于图像硬件如何发展和最佳实践如何改变的细节。</strong></p>
<h3 id="Testing-the-Merging-Stage-测试归并阶段"><a href="#Testing-the-Merging-Stage-测试归并阶段" class="headerlink" title="Testing the Merging Stage 测试归并阶段"></a>Testing the Merging Stage 测试归并阶段</h3><p><strong>在此阶段，将进行深度和模具测试，进行混合，并将幸存的结果写入缓冲区。改变这些缓冲区的输出位深度是改变这个阶段的带宽成本的一种方法，看看它是否会成为瓶颈。为不透明对象打开alpha混合或使用其他混合模式也会影响内存访问和光栅操作执行的处理数量。</strong></p>
<p><strong>这个阶段可能是后期处理通道、阴影、粒子系统渲染的瓶颈，在较小程度上，也可能是毛发和草的渲染，因为顶点和像素着色器很简单，所以几乎不需要做什么工作。</strong></p>
<h2 id="Performance-Measurements-性能度量"><a href="#Performance-Measurements-性能度量" class="headerlink" title="Performance Measurements 性能度量"></a>Performance Measurements 性能度量</h2><p><strong>为了优化，我们需要测量。这里我们讨论GPU速度的不同度量。图形硬件制造商过去常常呈现峰值速率，如每秒的顶点数和每秒的像素数，这是很难达到的。此外，由于我们处理的是流水线系统，真正的性能并不像列出这些类型的数字那么简单。这是因为瓶颈的位置可能从一个时间移动到另一个时间，不同的管道阶段在执行期间以不同的方式交互。由于这种复杂性，GPU的性能部分取决于它们的物理属性，比如核心的数量和时钟速率、内存大小、速度和带宽。</strong></p>
<p><strong>综上所述，GPU计数器和线程跟踪，如果可用的话，在使用得当的情况下，是重要的诊断工具。如果已知某个给定部件的峰值性能，且计数较低，那么该区域不太可能成为瓶颈。一些供应商提供计数器数据作为每个阶段的利用率百分比。这些值是在瓶颈可以移动的给定时间范围内的，因此并不完美，但在查找瓶颈方面有很大帮助。</strong></p>
<p><strong>越多越好，但即使是看起来简单的物理测量也很难进行精确的比较。例如，同一GPU的时钟速率在IHV合作伙伴之间可能会有所不同，因为每个合作伙伴都有自己的冷却解决方案，所以会超时其GPU到它认为安全的程度。即使是在单个系统上进行FPS基准比较，也并不总是像听起来那么简单。NVIDIA的GPU Boost和AMD的PowerTune技术都是我们格言“了解你的架构”的好例子。“英伟达的GPU Boost之所以出现，部分原因是一些综合基准同时运行GPU管道的许多部分，从而将功耗推到了极限，这意味着英伟达不得不降低其基本时钟速率，以防止芯片过热。许多应用程序不会在这种程度上执行管道的所有部分，因此可以安全地以较高的时钟速率运行。GPU Boost技术跟踪GPU的功率和温度特性，并相应地调整时钟速率。AMD和英特尔的GPU也有类似的功率/性能优化。这种可变性可能会导致相同的基准以不同的速度运行，这取决于GPU的初始温度。为了避免这个问题，微软在DirectX 12中提供了一种锁定GPU核心时钟频率的方法，以获得稳定的计时。其他API也可以检查功率状态，但要复杂得多。</strong></p>
<p><strong>在衡量CPU的性能时，趋势是避免IPS(每秒指令数)、FLOPS(每秒浮点操作数)、千兆赫和简单的短期基准测试。相反，首选的方法是测量一系列不同的、真实的程序的挂钟时间，然后比较这些程序的运行时间。随着这一趋势的发展，大多数独立的图像基准会测量特定场景的实际帧率，以及各种不同的屏幕分辨率，以及抗锯齿和质量设置。许多需要大量图像的游戏都包含一个基准测试模式，或者有一个由第三方创建的基准测试模式，这些基准测试通常用于比较gpu。</strong></p>
<p><strong>虽然FPS是比较GPU运行基准的有用缩写，但在分析一系列帧率时应该避免使用它。FPS的问题在于，它是一种相互度量，而非线性度量，因此可能导致分析错误。例如，假设您发现应用程序在不同时间的帧率分别是50fps、50fps和20fps。如果你将这些值平均，你将得到40 FPS。这个价值充其量是误导。这些帧速率转换为20、20和50毫秒，因此平均帧时间为30毫秒，即33.3 FPS。同样，在衡量单个算法的性能时，毫秒也是非常必要的。对于特定的基准测试情况在给定的测试和给定的机器上，可能会说某些特定的阴影算法或后处理效果“成本”为7 FPS，基准测试的运行速度要慢得多。然而，概括这句话是没有意义的，因为这个值还取决于处理帧中其他所有内容所花费的时间，因为你不能将不同技术的FPS相加(但你可以添加时间)。</strong></p>
<p><strong>为了能够看到管道优化的潜在效果，在禁用双缓冲的情况下测量每帧的总渲染时间是很重要的。在单缓冲模式下，关闭垂直同步。这是因为启用了双重缓冲后，缓冲区的交换只发生在与监视器频率同步的情况下，正如2.1节中的示例所解释的那样。De Smedt讨论了分析帧时间来发现和修复CPU工作负载峰值造成的帧断断续续问题，以及其他优化性能的有用技巧。使用统计分析通常是必要的。也可以使用GPU时间戳来了解帧内发生了什么。</strong></p>
<p><strong>原始速度很重要，但对于移动设备来说，另一个目标是优化功耗。故意降低帧率，但保持应用程序的交互性可以显著延长电池寿命，对用户体验几乎没有影响。Akenine-M¨oller和Johnsson注意到，每瓦特的性能就像每秒帧数，与FPS有相同的缺点。他们认为一个更有用的度量是焦耳每任务，例如，焦耳每像素。</strong></p>
<h2 id="Optimization-优化"><a href="#Optimization-优化" class="headerlink" title="Optimization 优化"></a>Optimization 优化</h2><p><strong>一旦找到了瓶颈，我们希望优化该阶段以提高性能。在本节中，我们将介绍应用、几何、光栅化和像素处理阶段的优化技术。</strong></p>
<h3 id="Application-Stage-应用阶段"><a href="#Application-Stage-应用阶段" class="headerlink" title="Application Stage 应用阶段"></a>Application Stage 应用阶段</h3><p><strong>应用程序阶段通过使代码更快和程序的内存访问更快或更少来优化。这里我们将介绍一些适用于CPU的代码优化的关键元素。</strong></p>
<p><strong>对于代码优化，定位代码中花费时间最多的位置是至关重要的。一个好的代码分析器对于查找这些代码热点非常关键，因为大部分时间都花在这些代码热点上。然后在这些地方进行优化工作。程序中的这些位置通常是内部循环，即每一帧执行多次的代码片段。</strong></p>
<p><strong>优化的基本规则是尝试各种策略:重新检查算法、假设和代码语法，尽可能地尝试变体。CPU架构和编译器性能通常会限制用户对如何编写最快代码的直觉形成的能力，所以请质疑您的假设，并保持开放的心态。</strong></p>
<p><strong>第一步是对编译器的优化标志进行试验。通常有许多不同的旗子可以尝试。对于所使用的优化选项，尽量少做假设。例如，将编译器设置为使用更积极的循环优化可能导致代码变慢。此外，如果可能的话，尝试不同的编译器，因为这些编译器以不同的方式进行了优化，有些编译器明显更好。你的分析工具可以告诉你任何变化的影响。</strong></p>
<h4 id="Memory-Issues-内存问题"><a href="#Memory-Issues-内存问题" class="headerlink" title="Memory Issues 内存问题"></a>Memory Issues 内存问题</h4><p><strong>几年前，算术指令的数量是衡量算法效率的关键;现在关键是内存访问模式。处理器速度的增长比DRAM的数据传输速率要快得多，因为DRAM的数据传输速率受到引脚数的限制。从1980年到2005年，CPU性能每两年翻一番，DRAM性能每6年翻一番。这个问题被称为冯·诺伊曼瓶颈或记忆墙。面向数据的设计将缓存一致性作为一种优化手段。</strong></p>
<p><strong>在现代GPU上，重要的是数据传输的距离。速度和动力成本与这个距离成正比。缓存访问模式可以造成数量级的性能差异。高速缓存是一个小的快速存储区域，因为通常在一个程序中有很多一致性，高速缓存可以利用。也就是说，内存中邻近的位置往往是一个接一个地被访问(空间局部性)，而代码通常是按顺序访问的。此外，内存位置往往被重复访问(时间局域性)，缓存也利用了这一点。处理器缓存访问起来很快，速度仅次于寄存器。许多快速算法的工作是尽可能地在本地访问数据。</strong></p>
<p><strong>寄存器和本地缓存形成内存层次结构的一端，它扩展到动态随机访问内存(DRAM)，然后存储在SSDs和硬盘上。顶部是少量快速而昂贵的内存，底部是大量缓慢而廉价的存储。在每个层次之间，速度下降了一些明显的因素。参见下图。例如，处理器寄存器通常在一个时钟周期内被访问，而L1缓存存储器则在几个周期内被访问。通过这种方式，级别的每一次更改都会增加延迟。正如第3.10节所讨论的，有时延迟可以被架构隐藏，但它始终是必须记住的一个因素。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104111448.png" class="" title="image-20211104111448">

<p>内存层次结构。速度和成本随着金字塔的下降而下降。</p>
<p><strong>在分析器中很难直接检测到糟糕的内存访问模式。好的模式需要从一开始就嵌入到设计中。下面是在编程时应该考虑的指针列表。</strong></p>
<pre><code>**•在代码中顺序访问的数据也应该顺序存储在内存中。例如，当渲染一个三角形网格时，将纹理坐标#0、法向量#0、颜色#0、顶点#0、纹理坐标#1和法向量#1按顺序存储在内存中。这也可以是在GPU上非常重要，就像变换后的顶点缓存(章节16.4.4)一样。为什么存储单独的数据流是有益的，请参见第16.4.5节。**

**•避免指针间接、跳转和函数调用(在代码的关键部分)，因为这些可能会显著降低CPU性能。当你沿着一个指针指向另一个指针时，你会得到指针间接指向，以此类推。现代的CPU尝试投机性地执行指令(分支预测)和获取内存(缓存预取)，以保持所有的功能单元忙于运行代码。当代码流在循环中保持一致时，这些技术非常有效，但在分支数据结构(如二叉树、链表和图)时就失败了;尽可能使用数组。McVoy和Staelin给出了一个通过指针跟随链表的代码示例。这将导致数据在缓存之前和之后都没有缓存，并且他们的例子使CPU的延迟时间比跟随指针所花费的时间长100倍以上(如果缓存可以提供指针的地址)。Smits指出，将基于指针的树扁平化为带有跳过指针的列表，可以显著改善层次遍历。使用van Emde Boas布局是避免缓存遗漏的另一种方法，请参阅19.1.4节。高分枝树通常比二叉树更可取，因为它们减少了树的深度，从而减少了间接的数量。**

**•将经常使用的数据结构对齐到缓存线大小的倍数可以显著提高整体性能。例如，64字节高速缓存线在Intel和AMD处理器上很常见。编译器选项可能会有帮助，但明智的做法是在设计数据结构时使用对齐(称为填充)。Windows和Linux的VTune和CodeAnalyst、Mac的Instruments以及Linux的开源Valgrind等工具可以帮助识别缓存瓶颈。对齐也会影响GPU着色器的性能。**

**•尝试不同的数据结构组织。例如，Hecker展示了如何通过测试一个简单矩阵乘法器的各种矩阵结构来节省惊人的大量时间。一组结构，**
</code></pre>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104111916.png" class="" title="image-20211104111916">

<p><strong>或者数组结构，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104111929.png" class="" title="image-20211104111929">

<p><strong>对于给定的架构可能会更好。第二种结构更适合使用SIMD命令，但是随着顶点数量的增加，缓存丢失的几率也会增加。随着数组大小的增加，一个混合方案，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104111947.png" class="" title="image-20211104111947">

<p><strong>可能是最好的选择。</strong></p>
<pre><code>**•通常在启动时为相同大小的对象分配一个大的内存池，然后使用你自己的分配和空闲例程来处理池中的内存。Boost等库提供池分配。一组连续的记录比那些由单独分配创建的记录更可能是缓存一致的。也就是说，对于使用垃圾收集的语言，如C#和Java，池实际上会降低性能。**
</code></pre>
<p><strong>虽然与内存访问模式没有直接关系，但避免在呈现循环中分配或释放内存是值得的。只使用一次池和分配一次临时空间，让堆栈、数组和其他结构只增长(使用变量或标志来说明哪些元素应该被视为已删除)。</strong></p>
<h3 id="API-Calls-API调用"><a href="#API-Calls-API调用" class="headerlink" title="API Calls API调用"></a>API Calls API调用</h3><p><strong>在本书中，我们根据硬件的一般趋势给出了建议。例如，索引顶点缓冲对象通常是为加速器提供几何数据的最快方法(章节16.4.5)。这一节是关于如何最好地调用图形API本身。大多数图形API都有类似的架构，并且有行之有效的方法来有效地使用它们。</strong></p>
<p><strong>理解对象缓冲区分配和存储是高效渲染的基础。对于一个有CPU和独立的GPU的桌面系统，每个CPU通常都有自己的内存。图形驱动程序通常控制对象驻留的位置，但它可以得到最好存储对象的提示。一个常见的分类是静态缓冲区和动态缓冲区。如果缓冲区的数据每一帧都在变化，最好使用动态缓冲区，它不需要GPU上的永久存储空间。控制台、集成了低功耗GPU的笔记本电脑和移动设备设备通常有统一的内存，其中GPU和CPU共享相同的物理内存。即使在这种情况下，在正确的资源池中分配资源也很重要。正确地将资源标记为仅CPU或仅GPU仍然可以带来好处。一般来说，如果一个内存区域必须同时被两个芯片访问，那么当一个芯片向它写入数据时，另一个芯片必须使它的缓存失效——这是一个昂贵的操作——以确保不会得到过时的数据。</strong></p>
<p><strong>如果一个对象没有变形，或者变形完全可以通过着色程序(如蒙皮)执行，那么将对象的数据存储在GPU内存中是有益的。该对象的不变性质可以通过将其存储为静态缓冲区来表示。通过这种方式，它不需要在每一帧渲染时都通过总线发送，从而避免了管线这一阶段的任何瓶颈。GPU上的内部内存带宽通常比CPU和GPU之间的总线高得多。</strong></p>
<h4 id="State-Changes-状态改变"><a href="#State-Changes-状态改变" class="headerlink" title="State Changes 状态改变"></a>State Changes 状态改变</h4><p><strong>调用API有几个相关的成本。在应用程序方面，更多的调用意味着花费更多的应用程序时间，而不管调用实际做什么。这种成本可以是最小的，或者是显而易见的，空驱动程序可以帮助识别它。依赖于GPU值的查询函数可能会由于与CPU同步时的延迟而使帧率减半。在这里，我们将深入研究优化一个常见的图形操作，准备管道来绘制一个网格。这个操作可能涉及到改变状态，例如，设置着色器及其制服，附加纹理，改变混合状态或使用的颜色缓冲，等等。</strong></p>
<p><strong>应用程序提高性能的一个主要方法是通过将具有相似呈现状态的对象分组来最小化状态更改。因为GPU是一个极其复杂的状态机，可能是计算机科学中最复杂的，改变状态可能是昂贵的。虽然一小部分成本涉及GPU，但大部分成本来自驱动程序在CPU上的执行。如果GPU能够很好地映射到API上，那么状态改变的成本是可以预测的，尽管仍然是巨大的。如果GPU有严格的功率限制或有限的硅足迹，如一些移动设备，或有一个硬件缺陷，驱动程序可能不得不执行英雄壮举，导致意外的高成本。状态改变的成本主要在CPU方面，在驱动程序中。</strong></p>
<p><strong>一个具体的例子是PowerVR架构如何支持混合。在较早的API中，混合是使用固定函数类型的接口指定的。PowerVR的混合是可编程的，这意味着他们的驱动程序必须将当前的混合状态添加到像素着色器中。在这种情况下，更高级的设计不能很好地映射到API，因此会在驱动程序中产生巨大的设置成本。在这一章中，我们注意到硬件架构和运行它的软件会影响各种优化的重要性，对于状态更改成本来说尤其如此。甚至特定的GPU类型和驱动程序发布也可能会有影响。阅读时，请在本节的每一页上用红色大字标出“你的里程可能不同”这句话。</strong></p>
<p><strong>Everitt和McDonald指出，不同类型的状态变化在成本上差别很大，并给出了一个粗略的概念，即在NVIDIA OpenGL驱动程序上每秒可以执行多少次。以下是他们2014年的顺序，从最贵到最低:</strong></p>
<pre><code>**•渲染目标(framebuffer对象)，约60k/秒。**

**• 着色程序, ∼300 k /秒。**

**• 纹理绑定, ∼1.5米/秒。**

**•顶点格式。**

**•统一缓冲对象(UBO)绑定。**

**•顶点绑定。**

**• 统一更新, ∼10米/秒。**
</code></pre>
<p><strong>这个近似的成本顺序是由其他人证实的。一个更昂贵的改变是GPU的渲染模式和计算着色模式之间的切换。避免状态改变可以通过按着色器对要显示的对象进行排序来实现，然后按使用的纹理等按成本顺序进行分组。按状态排序有时称为批处理。</strong></p>
<p><strong>另一种策略是重构对象的数据，以便进行更多的共享。最小化纹理绑定更改的常见方法是将多个纹理图像放入一个大纹理中，或者更好的是将其放入纹理数组中。如果API支持它，那么无绑定纹理是避免状态更改的另一个选项(章节6.2.5)。与更新制服相比，改变着色程序通常是相对昂贵的，所以在一个使用“if”语句的单一着色器中，材质类的变化可能会更好地表示。你也可以通过共享着色器来制作更大的批量。然而，让着色器更复杂也会降低GPU的性能。通过测量来了解什么是有效的，这是唯一的万无一失的方法。</strong></p>
<p><strong>对图形API进行更少、更有效的调用可以获得额外的节省。例如，通常可以将多个统一缓冲区对象定义并设置为一个组，因此绑定一个统一缓冲区对象的效率要高得多。在DirectX中，这些被称为常量缓冲区。正确使用这些函数可以节省每个函数的时间，也可以节省在每个API调用中检查错误的时间。</strong></p>
<p><strong>现代驱动程序通常将设置状态推迟到遇到第一个平局调用时。如果在此之前进行了多余的API调用，驱动程序将过滤掉这些调用，从而避免了执行状态更改的需要。通常，dirty标志用于表示需要更改状态，因此在每次draw调用之后返回基本状态可能会变得非常昂贵。例如，您可能希望假定状态X在大约时默认为关闭画一个物体。实现这一点的一种方法是“Enable(X); Draw(M1); Disable(X);“ 然后”Enable(X); Draw(M2); Disable(X);”这样在每次抽完之后恢复状态。然而，在两个draw调用之间再次设置状态也可能会浪费大量时间，即使它们之间没有发生实际的状态更改。</strong></p>
<p><strong>通常，应用程序对于何时需要状态更改具有更高层次的知识。例如，将不透明表面的“替换”混合模式更改为透明表面的“过渡”模式通常需要在帧期间完成一次。在渲染每个对象之前使用混合模式是很容易避免的。Galeano显示了忽略这种过滤和发出不必要的状态调用将如何使WebGL应用程序的成本高达将近2毫秒/帧。然而，如果驱动程序已经有效地进行了这种冗余过滤，那么在应用程序中每次调用执行相同的测试可能是一种浪费。过滤API调用的工作量主要取决于底层驱动程序。</strong></p>
<h4 id="Consolidating-and-Instancing-巩固和实例化"><a href="#Consolidating-and-Instancing-巩固和实例化" class="headerlink" title="Consolidating and Instancing 巩固和实例化"></a>Consolidating and Instancing 巩固和实例化</h4><p><strong>有效地使用API可以避免CPU成为瓶颈。API的另一个问题是小批量问题。如果忽略这一点，这将成为影响现代API性能的一个重要因素。简单地说，几个三角形填充的网格比许多小的、简单的网格渲染效率更高。这是因为每个draw调用都有固定成本开销，处理原语的成本，无论大小如何。</strong></p>
<p><strong>早在2003年，Wloka就指出，每批绘制两个(相对较小的)三角形距离GPU测试的最大吞吐量是375倍。2在2.7 GHz的CPU上，每秒的三角形数不是1.5亿个，而是40万个。对于由许多小而简单的对象(每个对象只有几个三角形)组成的渲染场景，性能完全受API的CPU限制;GPU没有能力增加它。也就是说，CPU上绘制调用的处理时间大于GPU实际绘制网格的时间，所以GPU很紧张。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104124949.png" class="" title="image-20211104124949">

<p>使用NVIDIA G80 GPU，运行DirectX 10的Intel Core 2 Duo 2.66 GHz CPU的批量性能基准。不同大小的批次在不同的条件下运行和计时。“低”条件是指只有位置和固定颜色像素着色器的三角形;另一组测试是合理的网格和阴影。“单”是多次渲染单个批次。“实例化”重用网格数据，并将每个实例的数据放在一个单独的流中。” Constants “是一个DirectX 10方法，实例数据被放在常量内存中。可以看到，小批量会损害所有方法，但是实例化的性能要快得多。在几百个三角形时，性能就会下降，因为瓶颈变成了从顶点缓冲区和缓存中检索顶点的速度。(图表由英伟达公司提供)</p>
<p><strong>Wloka的经验法则是“你每帧可以获得X批。“这是你每一帧的最大绘制调用数，纯粹是因为CPU是限制因素。在2003年，API成为瓶颈的断点大约是每个对象130个三角形。上图显示了断点是如何在2006年上升到每个网格510个三角形的。时代已经变了。我们做了很多工作来改善这个draw call问题，CPUs变得更快了。2003年的建议是每帧300个调用;在2012年，每帧16,000个抽签是一个球队的上限。尽管如此，对于一些复杂的场景来说，这个数字还是不够的。使用DirectX 12、Vulkan和Metal等现代API，驱动程序本身的成本可能会降到最低——这是它们的主要优势之一。然而，GPU在每个网格上有自己的固定成本。</strong></p>
<p><strong>减少绘制调用次数的一种方法是将几个对象合并到一个网格中，这只需要一个绘制调用来渲染集合。对于使用相同状态且静态的对象集合，至少相对于其他对象而言，可以进行一次合并，批处理可以重用每个帧。能够整合网格是考虑使用公共着色器和纹理共享技术避免状态变化的另一个原因。整合节省的成本不仅仅是避免API调用。应用程序本身处理更少的对象也可以节省开支。然而，如果批量比需要的大得多，那么其他算法(如截锥剔除)的效率就会降低。一种做法是使用边界卷层次结构来帮助查找和分组彼此相邻的静态对象。合并的另一个问题是选择，因为所有静态对象在一个网格中都是无差别的。一个典型的解决方案是在网格中的每个顶点存储一个对象标识符。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104125446.png" class="" title="image-20211104125446">

<p>植被实例化。下面图像中所有相同颜色的对象都在一个单独的绘制调用中进行渲染。(图片来自Crytek提供的CryEngine1)</p>
<p><strong>最小化应用程序处理和API成本的另一种方法是使用某种形式的实例化。大多数API支持拥有一个对象，并在单个调用中多次绘制它。这通常是通过指定一个基本模型并提供一个独立的数据结构来保存关于所需的每个特定实例的信息来实现的。除了位置和方向，其他属性也可以在每个实例中指定，比如叶子颜色或由于风的曲率，或任何其他可以被着色程序用来影响模型的属性。丰富的丛林场景可以创建通过自由使用实例。参见上图。人群场景是一个很好的例子，每个角色通过从一系列选择中选择不同的身体部位而呈现出独特的效果。进一步的变化可以通过随机着色和贴花添加。实例化也可以与细节水平技术相结合。参见下图中的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104125501.png" class="" title="image-20211104125501">

<p>人群场景。使用实例化最小化了需要的绘制调用的数量。细节级别技术也被使用，例如渲染远处模型的视点替用特效。(图片由Jonathan Ma¨ım、Barbara Yersin、Mireille Clavien和Daniel Thalmann提供。)</p>
<p><strong>将合并和实例化结合在一起的概念称为合并实例化，其中合并的网格包含可以被实例化的对象。</strong></p>
<p><strong>理论上，几何着色器可以用于实例化，因为它可以创建传入网格的重复数据。在实践中，如果需要许多实例，这种方法可能比使用实例化API命令慢。几何着色器的目的是执行局部、小规模的数据放大。此外，对于一些架构，如马里的基于瓦片的渲染器，几何着色器是在软件中实现的。引用马里的最佳实践指南:“找到解决问题的更好办法。几何着色器不是你的解决方案。”</strong></p>
<h3 id="Geometry-Stage-几何阶段"><a href="#Geometry-Stage-几何阶段" class="headerlink" title="Geometry Stage 几何阶段"></a>Geometry Stage 几何阶段</h3><p><strong>几何阶段负责变换、逐顶点光照、剪切、投影和屏幕映射。其他章节讨论了减少流经管道的数据量的方法。高效的三角形网格存储、模型简化和顶点数据压缩(第16章)都节省了处理时间和内存。像截锥和遮挡剔除(第19章)这样的技术避免了将完整的原语本身发送到管线中。在CPU上添加这样大规模的技术可能会完全改变应用程序的性能特征，因此值得在开发早期进行尝试。在GPU上，这样的技术并不常见。一个值得注意的例子是，计算着色器可以用来执行各种类型的剔除。</strong></p>
<p><strong>光照元素的效果可以根据每个顶点、每个像素(在像素处理阶段)或两者计算。光照计算可以通过几种方式进行优化。首先，应该考虑所用光源的类型。所有三角形都需要照明吗?有时一个模型只需要纹理，在顶点上使用颜色纹理，或者只是在顶点上使用颜色。</strong></p>
<p><strong>如果光源相对于几何是静态的，那么漫反射和环境光照可以被预先计算并存储为顶点的颜色。这样做通常被称为在灯光上“烘焙”。预照明的一个更精细的形式是预计算场景中漫反射的全局照明(章节11.5.1)。这样的光照可以存储为顶点的颜色或强度，或者作为光照地图。</strong></p>
<p><strong>对于正向渲染系统，光源的数量会影响几何舞台的性能。更多的光源意味着更多的计算。减少工作的常见方法是禁用或削减局部照明，而使用环境地图(章节10.5)。</strong></p>
<h3 id="Rasterization-Stage-光栅化阶段"><a href="#Rasterization-Stage-光栅化阶段" class="headerlink" title="Rasterization Stage 光栅化阶段"></a>Rasterization Stage 光栅化阶段</h3><p><strong>栅格化可以通过几种方法进行优化。对于封闭(实体)对象和永远不会显示其背面的对象(例如，房间里的墙的背面)，应该打开背面剔除(章节19.3)。这减少了大约一半要栅格化的三角形数量，从而减少了三角形遍历的负载。此外，当像素着色计算很昂贵时，这尤其有用，因为背面永远不会着色。</strong></p>
<h3 id="Pixel-Processing-Stage-像素处理阶段"><a href="#Pixel-Processing-Stage-像素处理阶段" class="headerlink" title="Pixel Processing Stage 像素处理阶段"></a>Pixel Processing Stage 像素处理阶段</h3><p><strong>优化像素处理通常是有利可图的，因为通常要着色的像素比顶点多得多。也有一些明显的例外。顶点总是需要处理的，即使绘制结束时没有生成任何可见的像素。渲染引擎中无效的剔除可能会导致顶点着色成本超过像素着色。太小的三角形不仅会导致更多的顶点着色评估需要的，但也可以创建更多的部分覆盖四方，造成额外的工作。更重要的是，只覆盖几个像素的纹理网格通常线程占用率很低。正如在章节3.10中讨论的，采样纹理会有很大的时间开销，GPU通过切换到其他片段上执行着色程序来隐藏纹理，然后在获取纹理数据后返回。低占用率会导致较差的延迟隐藏。使用大量寄存器的复杂着色器也可以通过允许更少的线程同时可用来减少占用(章节23.3)。这种情况称为高寄存器压力。还有其他微妙之处，例如，频繁切换到其他扭曲可能会导致更多的缓存丢失。Wronski讨论了各种占用问题和解决方案。</strong></p>
<p><strong>首先，使用原生纹理和像素格式，即使用图形加速器内部使用的格式，以避免从一种格式到另一种格式的可能昂贵的转换。另外两种与纹理相关的技术是只加载所需的mipmap级别(章节19.10.1)和使用纹理压缩(章节6.2.6)。通常，更小和更少的纹理意味着更少的内存使用，这反过来意味着更低的传输和访问时间。纹理压缩也可以提高缓存性能，因为相同数量的缓存内存被更多的像素所占用。</strong></p>
<p><strong>细节技术的一个层次是使用不同的像素着色程序，这取决于物体与观察者的距离。例如，在一个场景中有三个飞碟模型，最接近的可能有一个复杂的凹凸贴图来显示表面的细节，而远处的两个则不需要。此外，为了简化计算和减少“萤火虫”，最远的飞碟可能会简化或完全删除高光。，因为取样不足而产生的闪光伪影。在简化模型中每个顶点使用一种颜色可以带来额外的好处，即不需要因为纹理变化而改变状态。</strong></p>
<p><strong>当三角形栅格化时片段是可见的，像素着色器才会被调用。GPU的早期z测试(章节23.7)根据z缓冲区检查碎片的z深度。如果不可见，碎片被丢弃，没有任何像素着色器评估，节省了相当多的时间。虽然z深度可以通过像素着色器修改，但这样做意味着早期z测试无法执行。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104130555.png" class="" title="image-20211104130555">

<p>左边场景的深度复杂性显示在右边。(使用NVIDIA公司的NVPerfHUD创建的图像。)</p>
<p><strong>为了理解程序的行为，特别是像素处理阶段的负载，可视化深度复杂性是很有用的，深度复杂性是指覆盖一个像素的表面的数量。上图显示了一个示例。生成深度复杂度图像的一个简单方法是使用类似OpenGL的glBlendFunc(GL One,GL One)的调用，禁用z缓冲。首先，图像被清除为黑色。场景中的所有物体都用颜色渲染(1/ 255,1 / 255,1 /255)。混合函数设置的效果是，对于每个渲染的原语，所写像素的值将增加一个强度级别。深度复杂度为0的像素为黑色，深度复杂度为255的像素为全白(255,255,255)。</strong></p>
<p><strong>像素透支的数量与实际渲染的表面数量有关。像素着色器被评估的次数可以通过再次渲染场景找到，但是启用了z缓冲区。透支是努力的数额浪费计算一个表面的着色，然后被后面的像素着色器调用隐藏。延迟渲染(第20.1节)和光线追踪的一个优点是，着色是在所有可见性计算完成后执行的。</strong></p>
<p><strong>假设两个三角形覆盖一个像素，所以深度复杂度是2。如果较远的三角形先绘制，则较近的三角形将对其进行透支，透支量为1。如果先画较近的三角形，则较远的三角形没有通过深度测试而不画，因此没有透支。对于覆盖一个像素的随机不透明三角形集合，绘制的平均次数为谐波级数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104130711.png" class="" title="image-20211104130711">

<p><strong>这背后的逻辑是，第一个三角形渲染是一个绘图。第二个三角形在第一个三角形的前面或后面，概率是50/50。与前两个三角形相比，第三个三角形可以有三个位置中的一个，有三分之一的机会是最前面的。当n趋于无穷时，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104130737.png" class="" title="image-20211104130737">

<p><strong>式中γ = 0.57721，…是欧拉-马斯切罗尼常数。当深度复杂性较低时，透支会迅速上升，但很快就会逐渐消失。例如，深度复杂度为4的玩家平均抽到2.08次，11的玩家平均抽到3.02次，但深度复杂度为12,367的玩家平均抽到10.00次。</strong></p>
<p><strong>所以，透支不一定像看起来那么糟糕，但我们仍然希望在不花费太多CPU时间的情况下最小化它。粗略排序，然后按照大致的前后顺序(从近到远)绘制场景中的不透明对象，是减少透支的常用方法。稍后绘制的闭塞对象将不会写入颜色或z-缓冲区(即减少透支)。此外，像素碎片可以在到达之前被遮挡剔除硬件拒绝像素着色程序(第23.5节)。排序可以通过任意数量的方法来完成。基于所有不透明对象的质心沿视图方向的距离的显式排序是一种简单的技术。如果一个边界体层次结构或其他空间结构已经被用于截锥剔除，我们可以选择更近的子层首先被遍历，沿着层次结构向下。</strong></p>
<p><strong>另一种技术可以用于复杂的像素着色程序的表面。执行z- preass首先将几何图形渲染到z-buffer中，然后整个场景正常渲染。这消除了所有的透支着色器评估，但以整个独立运行的所有几何为代价。Pettineo写道，他的团队在电子游戏中使用深度预估的主要原因是为了避免透支。然而，大致的从前到后的顺序可以提供很多相同的好处，而不需要额外的工作。一种混合方法是识别并首先绘制几个可能带来最大好处的大、简单的遮挡器。正如McGuire所指出的，在他的特殊系统中，全抽签预赛并不能帮助表现。度量是了解哪种技术(如果有的话)对您的应用程序最有效的唯一方法。</strong></p>
<p><strong>之前我们建议通过shader和纹理进行分组，以最小化状态变化;这里我们讨论的是按距离排序的渲染对象。这两个目标通常会给出不同的目标绘制顺序，从而产生冲突。对于给定的场景和视角，总是有一些理想的绘制顺序，但这很难事先找到。混合方案是可能的，例如，根据深度对附近的对象进行排序，而根据材料对其他所有东西进行排序。一个常见的、灵活的解决方案是为每个对象创建一个排序键，通过给每个对象分配一组位来封装所有相关的标准。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104131031.png" class="" title="image-20211104131031">

<p>示例排序键绘制顺序。键是由低到高排序的。设置透明度位意味着对象是透明的，因为透明对象是在所有不透明对象之后渲染的。物体到相机的距离存储为一个精度较低的整数。对于透明对象，距离是反向或负的，因为我们希望对象按前后顺序排列。着色器和纹理都有一个唯一的标识号。</p>
<p><strong>我们可以选择通过距离进行排序，但通过限制存储深度的比特数，我们可以允许在给定距离范围内的对象通过着色器进行分组。即使只有两到三个深度分区，对draw进行排序也是很常见的。如果某些对象具有相同的深度和使用相同的着色器，则使用纹理标识符对对象进行排序，然后将具有相同纹理的对象组合在一起。</strong></p>
<p><strong>这是一个简单的例子，并且是视情况而定的，例如，渲染引擎本身可能会将不透明和透明的对象分开，因此不需要透明度位。其他字段的位数当然随最大值而变化着色器和纹理的数量。可以添加或替换其他字段，例如一个用于混合状态，另一个用于z缓冲区读写。最重要的是架构。例如，移动设备上的一些基于瓦片的GPU渲染器不能从前后排序中获得任何好处，所以状态排序是唯一需要优化的重要元素。这里的主要思想是，将所有属性放在一个整数键中，可以让您执行有效的排序，从而尽可能减少透支和状态更改。</strong></p>
<h3 id="Framebuffer-Techniques-帧缓冲区技术"><a href="#Framebuffer-Techniques-帧缓冲区技术" class="headerlink" title="Framebuffer Techniques 帧缓冲区技术"></a>Framebuffer Techniques 帧缓冲区技术</h3><p><strong>渲染一个场景通常会引起对帧缓冲区的大量访问和许多像素着色器的执行。为了减少缓存层次结构的压力，一个常见的建议是减少framebuffer中每个像素的存储大小。虽然每个颜色通道的16位浮点值提供了更多的准确性，但8位值的大小是前者的一半，这意味着在准确性足够的情况下，访问速度会更快。在JPEG和MPEG等图像和视频压缩方案中，色度经常被下采样。由于人类的视觉系统对亮度比对色度更敏感，这通常可以忽略不计的视觉效果。例如，Frostbite游戏引擎就使用了色度子采样的想法，以减少后续处理每通道16位图像的带宽成本。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104131231.png" class="" title="image-20211104131231">

<p>左:4 × 2像素，每个存储4个颜色组件(RGBA)。右:一种替代表示，其中每个像素存储亮度Y和第一个(Co)或第二(Cg )颜色成分，在棋盘图案中。</p>
<p><strong>Mavridis和Papaioannou提出，在栅格化过程中，使用有损YCoCg变换来实现颜色缓冲的类似效果，如197页所述。它们的像素布局如上图所示。与RGBA相比，这一半的颜色缓冲存储需求(假设A不需要)，并经常提高性能，这取决于架构。由于每个像素只有一个色度分量，在显示前将每个像素转换回RGB之前，需要一个重建滤波器来推断出完整的YCoCg。对于缺少Co-value的像素，例如，最接近的四个Co-values的平均值可以使用。然而，这并不能像期望的那样重建边缘。因此，我们使用了一种简单的边缘感知滤波器，实现为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104131513.png" class="" title="image-20211104131513">

<p><strong>对于没有Co的像素,其中Co,i 和Li 为当前像素的左、右、上、下的值，L为当前像素的亮度，t为边缘检测的阈值。Mavridis和Papaioannou使用t = 30/255。如果x &lt; 0, step(x)函数为0，否则为1。因此，滤波器权重为wi 是0或1，当亮度梯度|Li −L|，大于t。WebGL演示和源代码可以在网上找到。</strong></p>
<p><strong>由于显示分辨率的不断提高和着色器执行成本的节省，使用棋盘模式渲染已经在几个系统中使用。对于虚拟现实应用程序，Vlachos使用棋盘模式来表示视图周围的像素，而Answer将每个2 × 2的四边形减少1到3个样本。</strong></p>
<h3 id="Merging-Stage-合并阶段"><a href="#Merging-Stage-合并阶段" class="headerlink" title="Merging Stage 合并阶段"></a>Merging Stage 合并阶段</h3><p><strong>确保只在有用的时候启用混合模式。理论上，“over”合成可以设置为每个三角形，不透明的或透明的，因为不透明的表面使用“over”将完全覆盖像素中的值。然而，这比简单的“替换”光栅操作成本更高，所以用裁剪纹理和透明材质跟踪对象是值得的。或者，有一些光栅操作不需要额外的成本。例如，当z-buffer被使用时，在某些系统中访问模板buffer并不需要额外的时间。这是因为8位的模板缓冲区值与24位的z-depth值存储在同一个单词中。</strong></p>
<p><strong>考虑何时需要使用或清除各种缓冲区是值得的。由于GPU有快速清除机制(章节23.5)，建议总是清除颜色和深度缓冲区，因为这增加了这些缓冲区的内存传输效率。</strong></p>
<p><strong>如果可以的话，你应该避免将渲染目标从GPU读回CPU。CPU对framebuffer的任何访问都会导致整个GPU管线在渲染返回之前被刷新，从而失去所有的并行性。</strong></p>
<p><strong>如果您确实发现合并阶段是您的瓶颈，那么您可能需要重新考虑您的方法。您是否可以使用精度较低的输出目标，比如通过压缩?有没有办法重新调整你的算法来减轻这个阶段的压力?对于阴影，有没有方法缓存和重用没有移动的部分?</strong></p>
<p><strong>在本节中，我们讨论了通过搜索瓶颈和调优性能来很好地使用每个阶段的方法。也就是说，要意识到重复优化算法的危险，因为使用完全不同的技术可能会更好。</strong></p>
<h2 id="Multiprocessing-多处理"><a href="#Multiprocessing-多处理" class="headerlink" title="Multiprocessing 多处理"></a>Multiprocessing 多处理</h2><p><strong>传统APIs已经发展到发出更少的调用，每个调用做更多的事情。新一代的APIs——DirectX 12, Vulkan, Metal——采取了不同的策略。</strong></p>
<p><strong>对于这些APIs，驱动程序是流线型的和最小的，有很多复杂性和责任来验证状态转移到调用的应用程序，以及内存分配和其他功能。这种重新设计在很大程度上是为了减少绘制调用和状态更改的开销，这些开销来自于必须将旧APIs映射到现代GPUs。这些新APIs鼓励的另一个元素是使用多个CPU处理器来调用API。</strong></p>
<p><strong>在2003年左右，由于一些物理问题，如散热和功耗，CPU时钟速度不断上升的趋势在3.4 GHz左右趋于平缓。这些限制导致了多处理CPU的出现，在这种情况下，更多的CPU被放在一个芯片上，而不是更高的时钟速率。事实上，许多小核在单位面积上提供了最好的性能，这是GPU本身如此有效的主要原因。从那时起，创建利用并发性的高效、可靠的程序就一直是一个挑战。在这一节中，我们将讨论CPU核上高效多处理的基本概念，最后讨论图形API是如何进化来支持驱动程序本身的更多并发性的。</strong></p>
<p><strong>多处理器计算机可以大致分为消息传递体系结构和共享内存多处理器。在消息传递设计中，每个处理器都有自己的内存区域，处理器之间发送消息来传递结果。这些在实时渲染中并不常见。共享内存多处理器就像它们的名字一样;所有处理器共享一个逻辑地址空间的内存。大多数流行的多处理器系统使用共享内存，其中大多数都有对称多处理(SMP)设计。SMP意味着所有的处理器都是相同的。多核PC系统是对称多处理体系结构的一个例子。</strong></p>
<p><strong>在这里，我们将介绍两种使用多处理器实时图形的一般方法。第一种方法——多处理器流水线，也称为时间对等——将比第二种并行处理(也称为空间并行)更详细地介绍。这两种方法如下图所示。然后将这两种类型的并行性与基于任务的多处理结合在一起，应用程序创建的作业可以由单独的核心提取和处理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104132322.png" class="" title="image-20211104132322">

<p>使用多处理器的两种不同方式。在顶部，我们展示了如何在一个多处理器管道中使用三个处理器(CPU)，在底部，我们展示了在三个cpu上的并行执行。这两种实现之间的区别之一是，如果使用底部的配置，可以实现更低的延迟。另一方面，使用多处理器管线可能更容易。这两种构型的理想加速都是线性的，即。如果使用n个CPU，则加速为n倍。</p>
<h3 id="Multiprocessor-Pipelining-多处理器管线"><a href="#Multiprocessor-Pipelining-多处理器管线" class="headerlink" title="Multiprocessor Pipelining 多处理器管线"></a>Multiprocessor Pipelining 多处理器管线</h3><p><strong>正如我们所看到的，管线是一种通过将作业划分为并行执行的某些管线阶段来加快执行速度的方法。一个管线阶段的结果被传递到下一个阶段。理想的加速是n个管线阶段的n倍，而最慢的阶段(瓶颈)决定了实际的加速。到目前为止，我们已经看到了使用单个CPU核和GPU并行运行应用程序、几何处理、光栅化和像素处理。当主机上有多个处理器时，也可以使用管线，在这些情况下，它被称为多进程管线或软件管线。</strong></p>
<p><strong>这里我们描述了一种软件流水线。可能有无穷无尽的变化，方法应适合于特定的应用。在本例中，应用阶段分为三个阶段:APP, CULL, DRAW。这是粗粒度的流水线，这意味着每个阶段都相对较长。APP阶段是流程中的第一阶段，因此控制着其他阶段。在这个阶段，应用程序程序员可以添加额外的代码，例如，碰撞检测。这个阶段也更新了视点。CULL阶段可以执行:</strong></p>
<pre><code>**•场景图上的遍历和层次视图截锥剔除(章节19.4)。**

**•细节级别选择(第19.9节)。**

**•状态排序，如18.4.5节所述。**

**•最后(总是执行)，生成一个应该渲染的所有对象的简单列表。**
</code></pre>
<p><strong>DRAW阶段从CULL阶段获取列表，并发出该列表中的所有图形调用。这意味着它只是简单地遍历列表并为GPU提供信息。下图显示了如何使用此管线的一些示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104132651.png" class="" title="image-20211104132651">

<p>多处理器管线的不同配置。粗线表示阶段之间的同步，下标表示帧号。在顶部，显示了单个CPU管线。在中间和底部显示了使用两个CPU的两个不同的管线细分。中间有一个APP和CULL的流水线阶段，一个DRAW的流水线阶段。如果DRAW要做的工作比其他的要多，这是一个合适的细分。在底部，APP有一个管线阶段，其他两个有另一个管线阶段。如果APP比其他APP有更多的工作，这是合适的。注意，底部的两个配置有更多的时间用于APP、CULL和DRAW阶段。</p>
<p><strong>如果一个处理器核心可用，那么所有三个阶段都在该核心上运行。如果有两个CPU核可用，则可以在一个核上执行APP和CULL，在另一个核上执行DRAW。另一种配置是在一个核和CULL上执行APP在另一边画。哪个是最好的取决于不同阶段的工作负载。最后，如果主机有三个可用的核心，那么每个阶段都可以在单独的核心上执行。这种可能性如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104132842.png" class="" title="image-20211104132842">

<p>在顶部，显示了一个三级管线。与上图中的配置相比，该配置为每个管线阶段提供了更多的时间。下面的插图显示了一种减少延迟的方法:CULL和DRAW与FIFO缓冲之间重叠。</p>
<p><strong>这种技术的优点是吞吐量，即渲染速度增加。缺点是，与并行处理相比，延迟更大。延迟，或暂时延迟，是从轮询用户的操作到最终图像所花费的时间。这不应该与帧速率混淆，帧速率是每秒显示的帧数。例如，假设用户正在使用一个头戴显示设备。头部位置的确定可能需要10毫秒到达CPU，然后需要15毫秒渲染帧。从初始输入到显示的延迟是25毫秒。即使帧速率为66.7 Hz(1/0.015秒)，如果没有进行位置预测或其他补偿，交互也会因为向CPU发送位置变化的延迟而感到缓慢。如果忽略由用户交互引起的延迟(这在两个系统中都是一个常量)，多处理比并行处理有更多的延迟，因为它使用了管线。正如下一节将详细讨论的那样，并行处理将框架的工作分解为并发运行的部分。</strong></p>
<p><strong>与在主机上使用单个CPU相比，多处理器流水线提供了更高的帧速率，由于同步的成本，延迟大约相同或略高。延迟随着管道中的阶段数量的增加而增加。对于平衡良好的应用程序，n个CPU的加速是n倍。</strong></p>
<p><strong>减少延迟的一种技术是在APP阶段结束时更新视点和其他延迟关键参数。这将(大约)减少一帧延迟。另一种减少延迟的方法是执行CULL和DRAW重叠。这意味着CULL的结果一旦准备好渲染，就会发送到DRAW。为了使它工作，在这些阶段之间必须有一些缓冲，通常是FIFO。这些阶段在空空如也的情况下停止运转;即当缓冲区满时，CULL必须停止，而当缓冲区空时，DRAW必须饿死。缺点是不能在相同程度上使用状态排序等技术，因为原语必须在CULL处理后立即呈现。上图显示了这种延迟减少技术。</strong></p>
<p><strong>图中的管线最多使用3个CPU，各个阶段有特定的任务。然而，这种技术并不局限于此配置——相反，您可以使用任意数量的CPU并以任何您想要的方式分配工作。关键是对整个工作进行明智的划分，使管道趋于平衡。多处理器流水线技术需要最小的同步，因为它只需要在切换帧时进行同步。还可以使用额外的处理器进行并行处理，这需要更频繁的同步。</strong></p>
<h3 id="Parallel-Processing-并行处理"><a href="#Parallel-Processing-并行处理" class="headerlink" title="Parallel Processing 并行处理"></a>Parallel Processing 并行处理</h3><p><strong>使用多处理器管道技术的一个主要缺点是延迟往往会增加。对于某些应用程序，如飞行模拟器、第一人称射击游戏和虚拟现实渲染，这是不可接受的。当移动视点时，您通常希望立即(下一帧)响应，但当延迟较长时，这将不会发生。也就是说，这要视情况而定。如果多处理将帧速率从30帧每秒(1帧延迟)提高到60帧每秒(2帧延迟)，额外的帧延迟不会有明显的差别。</strong></p>
<p><strong>如果有多个处理器可用，还可以尝试并发运行部分代码，这可能会缩短延迟。要做到这一点，程序的任务必须具有并行性。有几种不同的算法并行化方法。假设有n个处理器可用。使用静态分配，将整个工作包(如加速结构的遍历)划分为n个工作包。然后每个处理器处理一个工作包，所有处理器并行地执行它们的工作包。当所有处理器都完成了它们的工作包时，可能需要合并来自处理器的结果。为了实现这一点，工作负载必须是高度可预测的。</strong></p>
<p><strong>如果不是这样，可以使用适应不同工作负载的动态分配算法。它们使用一个或多个工作池。当生成作业时，它们被放入工作池中。然后，当CPU完成当前任务时，可以从队列中获取一个或多个任务。必须小心，以使只有一个CPU可以获取特定的作业，并使维护队列的开销不会损害性能。较大的作业意味着维护队列的开销变得不那么严重，但是，另一方面，如果作业太大，那么由于系统中的不平衡，性能可能会降低。一个或多个CPU可能会饿死。</strong></p>
<p><strong>对于多处理器流水线，运行在n个处理器上的并行程序的理想加速是n倍。这叫做线性加速。尽管线性加速很少发生，但实际结果有时很接近。</strong></p>
<p><strong>在807页的图18.8中，显示了一个多处理器管线和一个有三个CPU的并行处理系统。暂时假设它们对每一帧做同样的工作，并且两种配置都实现线性加速。这意味着执行速度是串行执行的三倍。在单个CPU上)。此外，我们假设每帧的总工作量需要30毫秒，这意味着单个CPU上的最大帧速率将是1/0.03≈33帧每秒。</strong></p>
<p><strong>多处理器管线(理想情况下)将工作划分为三个大小相同的工作包，并让每个CPU负责一个工作包。然后，完成每个工作包需要10毫秒。如果我们沿着流水线的工作流程，我们将看到流水线中的第一个CPU工作了10毫秒(即10毫秒)。(即任务的三分之一)，然后将其发送到下一个CPU。然后，第一个CPU开始处理下一帧的第一部分。当一帧最终完成时，它需要30毫秒才能完成，但由于工作是在流水线中并行完成的，每10毫秒就会完成一帧。因此，延迟是30毫秒，加速是3倍(30/10)，结果是100帧每秒。</strong></p>
<p><strong>同一个程序的并行版本也将作业划分为三个工作包，但这三个工作包将在三个CPU上同时执行。这意味着延迟将是10毫秒，一帧的工作也将花费10毫秒。结论是，使用并行处理时的延迟要比使用多处理器管线时短得多。</strong></p>
<h3 id="Task-Based-Multiprocessing-基于任务的多处理"><a href="#Task-Based-Multiprocessing-基于任务的多处理" class="headerlink" title="Task-Based Multiprocessing 基于任务的多处理"></a>Task-Based Multiprocessing 基于任务的多处理</h3><p><strong>了解管线和并行处理技术，很自然地结合起来两者都在一个系统中。如果只有几个处理器可用，它可能会有一个简单的系统来显式地将系统分配给特定的核心是有意义的。然而，考虑到许多CPU上有大量的内核，现在的趋势是使用基于任务的多处理。正如一个人可以为自己创建多个任务（也称为作业）作为一个可以并行化的过程，这个想法可以扩展到包括流水线。任何核心生成的任何任务都会在生成时放入工作池。免费的处理器获取要处理的任务。</strong></p>
<p><strong>转换为多处理的一种方法是采用应用程序的工作流和确定哪些系统依赖于其他系统。见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104133634.png" class="" title="image-20211104133634">

<p>Frostbite CPU作业图，一个小的放大部分插入。</p>
<p><strong>如果处理器在等待同步时停止，则意味着基于任务的应用程序版本可能会变得更慢，这是由于这个成本和任务管理开销造成的。然而，许多程序和算法确实有大量的任务可以在同一时间执行，因此可以受益。</strong></p>
<p><strong>下一步是确定每个系统的哪些部分可以分解为任务。如果一段代码是一个很好的候选任务，它的特征包括:</strong></p>
<pre><code>**•任务有明确定义的输入和输出。**

**•任务在运行时是独立的和无状态的，并且总是完成。**

**•它不是一个大任务，它经常成为唯一运行的进程。**
</code></pre>
<p><strong>像C++ 11这样的语言都内置了多线程工具。在英特尔兼容的系统上，英特尔的开源线程构建块(TBB)是一个高效的库，它简化了任务生成、池和同步。</strong></p>
<p><strong>当性能至关重要时，让应用程序创建自己的多处理任务集(如模拟、碰撞检测、遮挡测试和路径规划)是给定的。我们在这里再次注意到，GPU内核有时也会处于空闲状态。例如，这些通常在阴影地图生成或深度预渲染时未被充分使用。在这种空闲时间，计算着色器可以应用到其他任务。根据架构、API和内容，有时候渲染管道不能让所有的着色器都忙起来，这意味着总有一些可用的池来计算着色。我们不会讨论优化这些着色器的话题，因为Lauritzen提出了一个令人信服的论点，即由于硬件差异和语言限制，编写快速和便携的计算着色器是不可能的。如何优化核心渲染管线本身是下一节的主题。</strong></p>
<h3 id="Graphics-API-Multiprocessing-Support-图形API多处理支持"><a href="#Graphics-API-Multiprocessing-Support-图形API多处理支持" class="headerlink" title="Graphics API Multiprocessing Support 图形API多处理支持"></a>Graphics API Multiprocessing Support 图形API多处理支持</h3><p><strong>并行处理通常不会映射到硬件约束。例如，DirectX 10及更早的版本一次只允许一个线程访问图形驱动程序，因此实际绘制阶段的并行处理就比较困难。</strong></p>
<p><strong>图形驱动程序中有两种操作可以使用多个处理器:资源创建和呈现相关调用。创建纹理和缓冲区等资源可以是纯粹的CPU端操作，因此自然是并行的。也就是说，创建和删除也可以阻塞任务，因为它们可能会触发GPU上的操作或需要特定的设备上下文。无论如何，旧API是在消费者级多处理CPU出现之前创建的，因此需要重写以支持这种并发性。</strong></p>
<p><strong>使用的关键结构是命令缓冲区或命令列表，它可以追溯到OpenGL的一个古老的概念，称为显示列表。命令缓冲区(CB)是API状态更改和绘制调用的列表。这样的列表可以被创建、存储和重放为想要的。它们也可以组合成更长的命令缓冲区。只有单个CPU处理器通过驱动程序与GPU通信，因此可以发送一个CB给它执行。但是，每个处理器(包括这个单个处理器)都可以并行地创建或连接存储的命令缓冲区。</strong></p>
<p><strong>例如，在DirectX 11中，与驱动程序通信的处理器将其渲染调用发送到所谓的即时上下文。其他处理器都使用一个延迟上下文来生成命令缓冲区。顾名思义，这些不会直接发送给驱动程序。相反，它们被发送到直接上下文进行呈现。参见下图。另外，可以将命令缓冲区发送到另一个延迟上下文，后者将其插入到自己的CB中。除了向驱动程序发送命令缓冲区以供执行外，直接上下文可以执行而延迟上下文不能执行的主要操作是GPU查询和读回。否则，命令缓冲区管理从任何类型的上下文来看都是相同的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211104133950.png" class="" title="image-20211104133950">

<p>命令缓冲区。每个处理器使用其延迟上下文(橙色)来创建和填充一个或多个命令缓冲区(蓝色)。每个命令缓冲区被发送到进程#1，进程#1使用它的直接上下文(显示为绿色)按需要执行这些命令。进程#1可以在等待进程#3的命令缓冲区N的同时执行其他操作。(源自Zink等人。)</p>
<p><strong>命令缓冲区及其前身显示列表的一个优点是，它们可以被存储和回放。命令缓冲区在创建时没有完全绑定，这有助于它们的重用。例如，假设一个CB包含一个视图矩阵。摄像机移动，所以视图矩阵改变。然而，视图矩阵存储在一个常量中缓冲区。常量缓冲区的内容不存储在CB中，只存储对它们的引用。可以在不重建CB的情况下更改常量缓冲区的内容。决定如何最好地最大化并行性涉及选择合适的粒度(每个视图、每个对象、每个材料)来创建、存储和组合命令缓冲区。</strong></p>
<p><strong>在命令缓冲区成为现代api的一部分之前，这种多线程绘制系统已经存在很多年了。API支持使这个过程更简单，并允许更多的工具使用所创建的系统。然而，命令列表确实有相关的创建和内存成本。同样，在DirectX 11和OpenGL中，将API的状态设置映射到底层的GPU仍然是一个昂贵的操作，如18.4.2节所讨论的。在这些系统中，当应用程序成为瓶颈时，命令缓冲区可以起到帮助作用，但当驱动程序成为瓶颈时，命令缓冲区可能是有害的。</strong></p>
<p><strong>这些早期API中的某些语义不允许驱动程序并行化各种操作，这有助于推动Vulkan、DirectX 12和Metal的开发。一个可以很好地映射到现代GPU的瘦的绘图提交接口将这些新API的驱动成本降至最低。命令缓冲区管理、内存分配和同步决策由应用程序而不是驱动程序负责。此外，使用这些较新的API的命令缓冲区在形成时进行一次验证，因此重复播放的开销比使用较早的api(如DirectX 11)的开销更小。所有这些元素结合起来可以提高API的效率，允许多处理，并减少驱动程序成为瓶颈的可能性。</strong></p>
<h1 id="19-Acceleration-Algorithms-加速算法"><a href="#19-Acceleration-Algorithms-加速算法" class="headerlink" title="19 Acceleration Algorithms 加速算法"></a>19 Acceleration Algorithms 加速算法</h1><p><strong>关于计算机的一个伟大的神话是，总有一天我们会有足够的处理能力。即使是在一个相对简单的应用程序中，如文字处理，我们发现额外的功能也可以应用于各种功能，如即时拼写和语法检查、文本抗锯齿显示和听写。</strong></p>
<p><strong>在实时渲染中，我们至少有四个性能目标:每秒更多的帧数，更高的分辨率和采样率，更真实的材料和照明，以及增加几何复杂度。通常认为60-90帧每秒的速度已经足够快了。即使使用运动模糊，可以降低图像质量所需的帧率，在与场景交互时仍然需要一个快速的帧率来最小化延迟。</strong></p>
<p><strong>今天，我们有分辨率为3840×2160的4k显示器;8k分辨率为7680×4320的显示器已经存在，但还不常见。4k显示器通常有每英寸140-150个点(DPI)，有时也称为每英寸像素(PPI)。移动电话显示器的值可达400 DPI左右。如今许多打印机公司都能提供1200 DPI的分辨率，这是4k显示器像素的64倍。即使有屏幕分辨率的限制，抗锯齿也增加了生成高质量图像所需的样本数量。正如在第23.6节中讨论的，每个颜色通道的比特数也可以增加，这就需要更高的精度(因此更昂贵)计算。</strong></p>
<p><strong>正如前面的章节所展示的，描述和计算一个对象的材料可能是计算复杂的。光和表面相互作用的建模可以消耗任意数量的计算能力。这是真的，因为从光源到眼睛的无数路径的光最终会形成图像。</strong></p>
<p><strong>帧率、分辨率和着色总是可以变得更复杂，但增加任何一项都会带来收益递减的感觉。然而，没有场景复杂度的真正上限。波音777的效果图包括132,500个独特的部件和超过3,000,000个紧固件，这产生了一个超过5亿个多边形的多边形模型。参见下图。即使这些物体中的大多数由于体积小或位置小而看不到，也必须做一些工作来确定这是事实。z缓冲和射线追踪都不能处理这样的模型，除非使用技术来减少所需的计算数量。我们的结论是:总是需要加速算法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105120832.png" class="" title="image-20211105120832">

<p>一个“简化”的波音模型，仅用光线追踪渲染了3.5亿个三角形。切片是通过使用用户定义的剪切平面来执行的。图片由萨尔兰大学计算机图形组提供。来源3D数据由波音公司提供并经许可使用。)</p>
<p><strong>在本章中，我们提供了一系列加速计算机图形渲染的算法，特别是大量几何图形的渲染。许多这类算法的核心是基于空间数据结构的，这将在下一节中描述。基于这些知识，我们继续使用剔除技术。这些算法试图快速确定哪些物体是可见的，需要进一步处理。细节级别技术降低了渲染其余对象的复杂性。在本章的最后，我们讨论了渲染大型模型的系统，包括虚拟纹理、流、转码和地形渲染。</strong></p>
<h2 id="Spatial-Data-Structures-空间数据结构"><a href="#Spatial-Data-Structures-空间数据结构" class="headerlink" title="Spatial Data Structures 空间数据结构"></a>Spatial Data Structures 空间数据结构</h2><p><strong>空间数据结构是指组织某个n维空间中的几何结构。本书只使用了二维和三维结构，但这些概念通常可以很容易地扩展到高维。这些数据结构可用于加速查询几何实体是否重叠。这样的查询被用于各种各样的操作，如剔除算法，在交叉测试和光线追踪期间，以及碰撞检测。</strong></p>
<p><strong>空间数据结构的组织通常是分层的。这意味着，松散地说，最高层包含一些子层，每个子层定义自己的子层空间的体积，反过来又包含它自己的子元素。因此，该结构是嵌套的，具有递归性质。这个层次结构中的一些元素引用了几何体。使用层次结构的主要原因是,不同类型的查询得到更快,通常一个进步从O (n) O (log n)。也就是说,与其搜索所有n对象,我们访问一小部分在执行操作,比如寻找最接近的对象在一个给定的方向。空间数据结构的构造时间可能非常昂贵，并且取决于其内部几何形状的数量和所需的数据结构的质量。然而，该领域的重大进展大大减少了施工时间，在某些情况下可以实时完成。使用惰性计算和增量更新，可以进一步减少构建时间。</strong></p>
<p><strong>一些常见的空间数据结构类型是包围体层次结构、二进制空间分区(BSP)树的变体、四叉树和八叉树。BSP树和八叉树是基于空间细分的数据结构。这意味着场景的整个空间被细分并编码在数据结构中。例如，所有叶节点空间的并集等于场景的整个空间。一般情况下，叶节点的体积不重叠，除了一些不太常见的结构，如松散八叉树。BSP树的大多数变体都是不规则的，这意味着空间可以更随意地细分。八叉树是规则的，这意味着空间是以统一的方式分割的。尽管有更多的限制，但这种一致性往往是效率的一个来源。另一方面，包围卷层次结构不是空间细分结构。相反，它包围了几何物体周围的空间区域，因此BVH不需要在每一层包围所有空间。</strong></p>
<p><strong>BVHs、BSP树和八叉树都将在接下来的章节中描述，以及场景图，它是一种更关注模型关系而不是有效渲染的数据结构。</strong></p>
<h3 id="Bounding-Volume-Hierarchies-包围体次结构"><a href="#Bounding-Volume-Hierarchies-包围体次结构" class="headerlink" title="Bounding Volume Hierarchies 包围体次结构"></a>Bounding Volume Hierarchies 包围体次结构</h3><p><strong>包围体(BV)是一个包含一组对象的卷。BV的想法是，它应该是一个比包含的对象更简单的几何形状，因此使用BV的测试可以比使用对象本身更快地完成。BV的例子有球体、轴向包围盒(AABBs)、定向包围盒(OBBs)和k- DOPs。参见第22.2节的定义。BV对渲染的图像没有视觉上的贡献。相反，它被用作一个代理来代替有界对象，以加速呈现、选择、查询和其他计算。</strong></p>
<p><strong>对于三维场景的实时绘制，通常使用包围体层次进行分层视图截锥剔除(章节19.4)。场景组织在一个层次树结构，由一组连接的节点组成。最上面的节点是根节点，它没有父节点。内部节点有指向它的子节点(即其他节点)的指针。因此，根是一个内部节点，除非它是树中唯一的节点。叶节点保存要渲染的实际几何图形没有任何子节点。树中的每个节点(包括叶节点)都有一个包围体，该包围体将几何图形包围在它的整个子树中。还可以决定从叶节点中排除bv，而将它们包含在每个叶节点上方的内部节点中。这个设置就是名称包围卷层次结构的来源。每个节点的BV包含了其子树中所有叶子节点的几何形状。这意味着根具有包含整个场景的BV。下图显示了BVH的一个示例。注意，一些较大的边界圈可以变得更紧，因为每个节点只需要包含其子树中的几何图形，而不需要包含后代节点的bv。对于包围圆(或球体)，形成如此紧密的节点可能是昂贵的，因为它的子树中的所有几何都必须由每个节点检查。在实践中，一个节点的BV通常是通过树“自下而上”形成的，通过创建一个包含其子节点BV的BV。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105125416.png" class="" title="image-20211105125416">

<p>左边部分显示了一个简单的场景，有五个对象，在右侧的包围体层次中使用了包围圈。一个圆包住所有的对象，然后小的圆以递归的方式在大的圆里面。右侧显示了用于表示左侧对象层次结构的包围体层次结构(树)。</p>
<p><strong>BVH的底层结构是树，在计算机科学领域，关于树数据结构的文献是大量的。这里只会提到几个重要的结果。如需了解更多信息，请参见Cormen等人的《算法导论》一书。</strong></p>
<p><strong>考虑一个k-ary树，即每个内部节点都有k个子节点的树。只有一个节点(根)的树被称为高度为0。根的叶节点高度为1，依此类推。平衡树是指所有叶节点高度为h或h−1的树。一般来说，平衡树的高度h是⌊logk n⌋， 其中n是树中节点(内部节点和叶子节点)的总数。注意，k越高，树的高度越低，这意味着遍历树的步骤越少，但在每个节点上也需要做更多的工作。二叉树通常是最简单的选择，并且具有合理的性能。然而,在是证据，较高的k(例如，k = 4或k = 8)为某些应用程序提供更好的性能。使用k = 2, k = 4，或k = 8可以使构造树变得简单;只要沿着k = 2的最长轴细分，k = 4的两个最长轴，以及k = 8的所有轴。更难养成良好的为其他的k值树。树更高的数字,例如,k = 8,每个节点的子节点往往喜欢从性能的角度而言,因为他们减少平均树深度和间接的数量(从父母到孩子指针)。</strong></p>
<p><strong>BVHs非常适合执行各种查询。例如，假设一条射线与场景相交，找到的第一个交集应该返回，就像阴影射线的情况一样。要为此使用BVH，测试从根开始。如果射线错过了它的BV，那么射线就错过了包含在BVH中的所有几何图形。否则，测试将继续递归进行，即测试根的子节点的BV。一旦射线错过了BV, BVH的子树上的测试就会终止。如果射线命中了一个叶节点的BV，射线就会在这个节点的几何体上进行测试。性能提高的部分原因是使用BV测试射线速度很快。这就是为什么像球体和盒子这样的简单物体被用作BV。另一个原因是BV的嵌套，这使得我们可以避免由于在树中提前终止而测试大区域的空间。</strong></p>
<p><strong>往往最接近的路口，不是最先发现的，是最渴望的。唯一需要的额外数据是遍历树时发现的最近对象的距离和身份。在遍历过程中，当前最近的距离也被用来剔除树。如果一个BV是相交的，但是它的距离超过了目前为止找到的最近的距离，那么BV可以被丢弃。当检查父框时，我们交叉所有子BV并找到最近的。如果在这个BV的后代中发现了交集，则使用这个新的最近距离来挑选是否需要遍历其他的后代。我们可以看到，BSP树比普通BVHs更有优势，因为它可以保证从前到后的排序，而不是BVHs提供的这种粗略排序。</strong></p>
<p><strong>BVHs也可以用于动态场景。当包含在BV中的对象移动时，只需检查它是否仍然包含在其父BV中。如果是，则BVH仍然有效。否则，将删除对象节点并重新计算父节点的BV。然后将节点从根递归插入到树中。另一种方法是增大父节点的BV，以便在需要时递归地向上保存子节点。使用任何一种方法，当执行越来越多的编辑时，树都可能变得不平衡和低效。另一种方法是在物体在一段时间内的移动范围周围放置一个BV。这被称为暂时边界体积。例如，一个钟摆可以有一个包围盒，它的运动可以包围整个体积。人们也可以进行自下而上的改装，或者选择树的一部分来改装或重建。</strong></p>
<p><strong>要创建BVH，首先必须能够围绕一组对象计算紧BV。本主题将在第22.3节中讨论。然后，必须创建BV的实际层次结构。参见realtimerendering.com的碰撞检测章节，了解更多关于BV建造策略的内容。</strong></p>
<h3 id="BSP-Trees-BSP树"><a href="#BSP-Trees-BSP树" class="headerlink" title="BSP Trees BSP树"></a>BSP Trees BSP树</h3><p><strong>二进制空间划分树，简称BSP树，在计算机图形学中以两种明显不同的形式存在，我们称之为轴对齐树和多边形对齐树。树是通过使用平面将空间分成两部分，然后将几何图形分类到这两个空间中来创建的。这个除法是递归的。一个有价值的特性是，如果以某种方式遍历BSP树，树的几何内容可以从任何角度从前到后排序。这种排序对于轴对齐的BSPs是近似的，对于多边形对齐的BSP是精确的。注意，轴对齐的BSP树也称为k-d树</strong></p>
<h4 id="Axis-Aligned-BSP-Trees-k-D-Trees-轴向BSP树-k-D树"><a href="#Axis-Aligned-BSP-Trees-k-D-Trees-轴向BSP树-k-D树" class="headerlink" title="Axis-Aligned BSP Trees (k-D Trees)  轴向BSP树(k-D树)"></a>Axis-Aligned BSP Trees (k-D Trees)  轴向BSP树(k-D树)</h4><p><strong>以如下方式创建轴向BSP树。首先，整个场景被包围在一个轴对齐的包围框(AABB)中。接下来的想法是递归地将这个框细分为更小的框。现在，考虑任意递归级别的方框。选择盒子的一个轴，生成一个垂直的平面，将空间分成两个盒子。有些方案确定了这个划分平面，以便将盒子精确地分成两半;另一些允许平面改变位置。通过改变平面位置，称为非均匀细分，得到的树可以变得更加平衡。对于固定的平面位置，称为均匀细分，节点在内存中的位置由其在树中的位置隐式给出。</strong></p>
<p><strong>与平面相交的物体可以用多种方法处理。例如，它可以存储在树的这一层，或者成为两个子框的成员，或者被平面分割成两个独立的对象。在树级别存储的好处是树中只有一个对象的副本，这使得删除对象很简单。然而，被分裂平面相交的小物体会卡在树的上层，这往往是低效的。将相交的对象放置到两个子对象中可以使较大的对象具有更紧密的边界，因为所有对象都向下渗透到一个或多个叶节点，但只有那些它们重叠的叶节点。每个子框包含一定数量的对象，这个平面分割过程重复进行，递归地细分每个AABB，直到满足某个条件停止该过程。下图是轴对齐的BSP树的示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105125953.png" class="" title="image-20211105125953">

<p>Axis-aligned BSP树。在这个例子中，空间分区允许位于轴线上的任何位置，而不仅仅是中点。形成的空间体块被标记为A到E。右边的树显示了底层的BSP数据结构。每个叶节点代表一个区域，该区域的内容显示在其下方。注意，这个三角形位于两个区域C和E的对象列表中，因为它重叠了这两个区域。</p>
<p><strong>粗略的前后排序是如何使用轴对齐BSP树的一个例子。这对于遮挡剔除算法是有用的(章节19.7和23.7)，以及通过最小化像素透支来减少像素着色器成本。假设当前遍历一个名为N的节点。这里，N是遍历开始时的根。检查N的分裂平面，然后递归地在查看器所在平面的一侧继续遍历树。因此，只有当整个树的一半被遍历时，我们才开始遍历另一边。由于叶节点的内容没有排序，而且对象可能位于树的许多节点中，因此这种遍历不会给出精确的前后排序。然而，它给出了一个粗略的排序，这通常是有用的。与查看器的位置相比，通过在节点平面的另一侧开始遍历，粗略的前后排序可以被获得。这对于透明排序很有用。BSP遍历也可以用来测试光线对场景几何的影响。射线的来源只是用来交换观察者的位置。</strong></p>
<h4 id="Polygon-Aligned-BSP-Trees-多边形对称BSP树"><a href="#Polygon-Aligned-BSP-Trees-多边形对称BSP树" class="headerlink" title="Polygon-Aligned BSP Trees 多边形对称BSP树"></a>Polygon-Aligned BSP Trees 多边形对称BSP树</h4><p><strong>另一种类型的BSP树是多边形对齐的形式。这种数据结构对于按照精确排序的顺序呈现静态或刚性几何图形特别有用。这种算法在《毁灭战士》(2016)等游戏中很受欢迎，当时还没有硬件z缓冲区。它仍然有偶尔的用途，如碰撞检测和交叉测试。</strong></p>
<p><strong>在该方案中，选择一个多边形作为分隔器，将空间分成两半。也就是说，在根节点，选择一个多边形。多边形所在的平面用于将场景中的其余多边形划分为两个集合。任何被分割平面相交的多边形沿着相交线被分割成两个独立的部分。现在在剖分平面的每个半空间中，选择另一个多边形作为分割器，只分割其半空间中的多边形。这个过程是递归的，直到所有的多边形都在BSP树中。创建高效的多边形对齐BSP树是一个耗时的过程，这样的树通常只计算一次并存储以供重用。这类BSP树如下图所示。一般来说，形成一棵平衡的树是最好的。其中每个叶节点的深度相同，或最多相差1。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105130935.png" class="" title="image-20211105130935">

<p>Polygon-aligned BSP树。多边形A到G如图所示。首先用多边形A分割空间，然后用B和C分别分割每个半空间。由多边形B形成的分割平面与左下角的多边形相交，将其分割成单独的多边形D和E。</p>
<p><strong>多边形对齐的BSP树有一些有用的属性。一个是，对于给定的视图，结构可以严格从后到前(或从前到后)遍历。</strong></p>
<p><strong>这与轴对齐的BSP树相比，后者通常只给出粗略排序的顺序。确定相机位于根平面的哪一边。在这个平面的远侧的多边形集合在近侧的集合之外。现在远侧的设置，采取下一层的划分平面，并确定相机在哪一边。远端的子集也是离摄像机最远的子集。通过继续递归，这个过程建立了严格的前后顺序，可以使用画家的算法来渲染场景。画家的算法不需要z缓冲区。如果所有对象都是按照前后顺序绘制的，那么每一个较近的对象就会被画在它后面的对象的前面，这样就不需要z-depth比较了。</strong></p>
<p><strong>例如，考虑查看器v在上图中看到的内容。不管观察方向和截锥体,v是左边的分裂面形成的,所以C、F和G B, D和E。v C的分裂面比较,我们发现G的对面这个平面,所以它显示。对B平面的测试确定E应该在D之前显示，那么从后到前的顺序是G, C, F, A, E, B, D。注意，这个顺序并不能保证一个物体比另一个物体离观众更近。相反，它提供了一个严格的闭塞顺序，一个微妙的区别。例如，多边形F比多边形E更接近v，尽管它在闭塞顺序上更靠后。</strong></p>
<h3 id="Octrees-八叉树"><a href="#Octrees-八叉树" class="headerlink" title="Octrees 八叉树"></a>Octrees 八叉树</h3><p><strong>八叉树类似于轴对齐的BSP树。一个盒子沿三个轴同时分裂，分裂点必须是盒子的中心。这将创建8个新框——因此命名为八叉树。这使结构变得规则，从而使某些查询更有效。</strong></p>
<p><strong>八叉树是通过将整个场景包围在一个最小的轴对齐框中来构建的。该过程的其余部分本质上是递归的，并在满足停止条件时结束。与轴对齐的BSP树一样，这些标准可以包括达到最大递归深度，或者在一个方框中获得一定数量的原语。如果满足条件，算法将原语绑定到方框并终止递归。否则，它将盒子沿着其主轴使用三个平面细分，从而形成八个大小相同的盒子。每个新盒子都经过测试，并可能再次细分为2 × 2 × 2个更小的盒子。这在下图的二维空间中进行了说明，其中的数据结构称为四叉树。四叉树是二维的八叉树，第三个轴被忽略。在沿着三个轴对数据进行分类没有什么好处的情况下，它们可能很有用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105131314.png" class="" title="image-20211105131314">

<p>四叉树的构造。构造从左侧开始，将所有对象包围在一个包围框中。然后，这些盒子被递归地分成四个大小相同的盒子，直到每个盒子(在本例中)是空的或包含一个对象。</p>
<p><strong>八叉树可以以与轴对齐的BSP树相同的方式使用，因此可以处理相同类型的查询。事实上，BSP树可以给出与八叉树相同的空间分区。如果第一个细胞分裂的中间,说,x轴,然后两个孩子沿中间分割、说,y,最后那些孩子被划分在中间沿z, 8个大小相同的细胞形成的一样由一个应用程序是一个八叉树分裂。八叉树的一个效率来源是它不需要存储更灵活的BSP树结构所需要的信息。例如，分裂平面的位置是已知的，因此不必明确地描述。这种更紧凑的存储方案还通过在遍历期间访问更少的内存位置来节省时间。轴对齐的BSP树仍然更有效，因为获取分裂平面位置所需的额外内存成本和遍历时间可以被更好的平面放置所节省的成本所抵消。没有全面的最佳效率方案;它取决于底层几何结构的性质、结构如何被访问的使用模式，以及运行代码的硬件体系结构，等等。通常，内存布局的缓存友好性的位置和级别是最重要的因素。这是下一节的重点。</strong></p>
<p><strong>在上面的描述中，对象总是存储在叶节点中。因此，某些对象必须存储在多个叶节点中。另一种选择是将对象放置在包含整个对象的最小方框中。例如，图中的星形对象应该放在左边第二个插图的右上方的框中。这有一个明显的缺点，例如，位于八叉树中心的(小)对象将被放置在最上面(最大)的节点中。这是不有效的，因为一个微小的物体被包围在包围整个场景的盒子里。一种解决方案是拆分对象，但这会引入更多的原语。另一种方法是在对象所在的每个叶框中放置一个指向对象的指针，这样会降低效率，并使八叉树编辑更加困难。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105131438.png" class="" title="image-20211105131438">

<p>普通八叉树与松散八叉树的比较。圆点表示框的中心点(在第一个细分中)。在左边，恒星穿过普通八叉树的一个分裂平面。因此，一种选择是把星星放在最大的方框中(根的方框)。右边显示的是k = 1.5的松散八叉树(即盒子大50%)。这些盒子稍微移位了一下，这样就能被认出来。星星现在可以完全放置在左上方的红色方框中。</p>
<p><strong>Ulrich提出了第三种解决方案，松散八叉树。松散八叉树的基本思想与普通八叉树相同，但每个盒子大小的选择是宽松的。如果一个普通盒子的边长是l，那么用kl代替，其中k &gt; 1。上图展示了k = 1.5时的情况，并与普通八叉树进行了比较。注意，盒子的中心点是相同的。通过使用更大的方框，穿过分裂平面的对象的数量就减少了，这样对象就可以被放置在八叉树的更深处。一个对象总是只被插入到一个八叉树节点中，因此从八叉树中删除是很简单的。使用k = 2会产生一些好处。首先，插入和删除对象是O(1)。知道对象的大小意味着立即知道它可以成功插入的八叉树的级别，完全适合于一个松散的盒子。在实践中，有时可以将对象推到八叉树中更深的方框中。同样，如果k &lt; 2，如果对象不适合树，那么它可能不得不向上推。</strong></p>
<p><strong>对象的质心决定了它被放入哪个松散的八叉树盒中。由于这些特性，这种结构很适合绑定动态对象，但会牺牲一些BV效率，并在遍历结构时失去强排序顺序。此外，物体通常只是在帧与帧之间轻微移动，因此前一个盒子在下一帧仍然有效。因此，只有一小部分动画松散八叉树中的对象需要更新每一帧。Cozzi指出，在将每个对象/原语分配给松八叉树后，可以围绕每个节点中的对象计算一个最小的AABB，在那一点上它本质上成为一个BVH。这种方法避免了跨节点分割对象。</strong></p>
<h3 id="Cache-Oblivious-and-Cache-Aware-Representations-支持缓存和缓存无关表示"><a href="#Cache-Oblivious-and-Cache-Aware-Representations-支持缓存和缓存无关表示" class="headerlink" title="Cache-Oblivious and Cache-Aware Representations 支持缓存和缓存无关表示"></a>Cache-Oblivious and Cache-Aware Representations 支持缓存和缓存无关表示</h3><p><strong>由于内存系统的带宽和CPU的计算能力之间的差距每年都在增加，因此在设计算法和空间数据结构表示时考虑缓存是至关重要的。在这一节中，我们将介绍缓存敏感(或缓存敏感)和缓存无关的空间数据结构。感知缓存的表示假设缓存块的大小是已知的，因此我们针对特定的体系结构进行优化。相反，缓参无关算法被设计用于所有类型的缓参大小，因此是平台无关的。</strong></p>
<p><strong>要创建支持缓存的数据结构，您必须首先确定您的体系结构的缓存块的大小。例如，这可能是64字节。然后尽量减少数据结构的大小。例如，Ericson展示了k-d树节点仅使用32位就足够了。这部分是通过占用节点的32位值的两个最低有效位来实现的。这2位可以表示4种类型:叶节点，或者在三个轴之一上分裂的内部节点。对于叶节点，上30位包含一个指向对象列表的指针;对于内部节点，这些表示一个(精度稍低的)浮点分割值。因此，在一个64字节的缓存块中存储一个有15个节点的四层深度二叉树是可能的。第16个节点表示存在哪些子节点以及它们所在的位置。详情请参阅他的书。关键的概念是，通过确保结构整洁地打包到缓存边界，数据访问得到了相当大的改进。</strong></p>
<p><strong>一种流行且简单的对树的缓存无关排序是van Emde Boas布局。假设我们有一棵高度为h的树T，目标是计算树中节点的缓参无关布局或顺序。关键思想是，通过递归地将一个层次结构分解成越来越小的块，在某种程度上，一组块将适合缓存。这些块在树中彼此靠近，因此缓存数据的有效时间将比我们简单地从顶层向下列出所有节点的时间更长。这样的简单清单会导致内存位置之间的大跳转。</strong></p>
<p><strong>我们将T的van Emde Boas布局表示为v(T)。这种结构是递归定义的，树中单个节点的布局就是节点本身。如果T中有一个以上的节点，那么树的高度就会减半，数组元素的值就会减半，⌊h/2⌋ 。数组元素中最顶层的⌊h/2⌋ 值被放在一个表示T0的树中，以及从T0 的叶节点开始的子树是T1，…Tn．树的递归性质被描述为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105132152.png" class="" title="image-20211105132152">

<p><strong>请注意，所有子树Ti, 0 ≤ i≤ n、 也由上面的递归定义。这意味着，例如，T1必须在其高度的一半处拆分，以此类推。下图为示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105132244.png" class="" title="image-20211105132244">

<p>树T的van Emde Boas布局是通过拆分树的高度h创建的一分为二这将创建子树T0，T1，…,Tn，每个子树在同一个树中递归拆分直到每个子树只剩下一个节点为止。</p>
<p><strong>一般来说，创建缓存无关布局包括两个步骤：集群和簇的排序。对于van Emde Boas布局，集群如下所示：子树和顺序隐含在创建顺序中。Yoon等人开发专门为有效包围体积而设计的技术层次结构和BSP树。他们开发了一个概率模型，该模型考虑了父对象与其子对象之间的位置以及空间位置。想法是通过确保孩子们很容易接触到。此外，相互靠近的节点是按顺序更紧密地分组。提出了一种贪婪集群算法具有最高概率的节点。性能得到了大幅提高在不改变底层算法的情况下，它只不过是网络中节点的顺序BVH，是不同的。</strong></p>
<h3 id="Scene-Graphs-场景图"><a href="#Scene-Graphs-场景图" class="headerlink" title="Scene Graphs 场景图"></a>Scene Graphs 场景图</h3><p><strong>BVHs、BSP树和八叉树都使用某种树作为其基本数据结构。信息技术关键在于它们如何划分空间并存储不同的几何体。他们也以分层方式存储几何对象，而不是其他对象。然而，渲染三维场景不仅仅是几何图形。控制动画、可见性和其他元素的显示通常使用场景图执行，在glTF中称为节点层次结构。这是一个面向用户的树结构增加了纹理、变换、细节级别、渲染状态（例如材质本身、领带）、光源以及其他任何合适的内容。它是代表通过一棵树，并以某种顺序遍历该树以渲染场景。例如光源可以放在内部节点上，这只影响其内部节点的内容子树。另一个示例是在树中遇到材质时。材料可以应用于该节点子树中的所有几何图形，也可以由孩子的环境。另请参见第861页图19.34，了解不同的详细程度可以在场景图中支持。从某种意义上说，每个图形应用程序都使用一些形式的场景图，即使图只是一个根节点和一列要显示的子节点。</strong></p>
<p><strong>动画对象的一种方法是改变树中的内部节点的转换。场景图实现然后转换该节点的子树的全部内容。由于转换可以放在任何内部节点中，所以可以进行分层动画。例如，汽车的轮子可以旋转，汽车作为一个整体可以向前移动。</strong></p>
<p><strong>当多个节点指向同一个子节点时，这种树结构称为有向无环图(DAG)。非循环的意思是它不能包含任何循环或循环。有向的意思是，当两个节点由一条边连接时，它们也按照一定的顺序连接，例如从父节点到子节点。场景图通常是DAGs，因为它们允许实例化。，当我们想要复制一个对象的多个副本(实例)而不复制其几何形状时。下图显示了一个示例，其中两个内部节点对它们的子树应用了不同的转换。使用实例可以节省内存，GPU可以通过API调用快速渲染一个实例的多个副本(章节18.4.2)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105132811.png" class="" title="image-20211105132811">

<p>将不同变换M和N应用于内部节点及其各自的子树的场景图。注意，这两个内部节点也指向相同的对象，但由于它们进行了不同的转换，因此出现了两个不同的对象(其中一个是旋转和缩放的)。</p>
<p><strong>当物体在场景中移动时，场景图必须更新。这可以通过对树结构的递归调用来实现。变换在从根到叶的过程中被更新。矩阵在此遍历中相乘并存储在相关节点中。但是，当转换被更新时，任何附加的BVs都是过时的。因此，BVs在从叶向根返回的过程中被更新。过于松散的树形结构使这些任务变得非常复杂，所以通常会避免使用DAGs，或者使用有限形式的DAGs，其中只共享叶节点。有关这个主题的更多信息，请参阅Eberly的书。还需要注意的是，当使用基于JavaScript的APIs(如WebGL)时，将尽可能多的工作转移到GPU，而尽可能少的反馈给CPU是非常重要的。</strong></p>
<p><strong>场景图本身可以提供一些计算效率。场景图中的节点通常都有一个包围体积，因此非常类似于BVH。场景图中的叶子存储几何图形。重要的是要认识到，完全无关的效率方案可以与一个场景图一起使用。这就是空间化的思想，在这种思想中，用户的场景图被一个单独的数据结构(例如，BSP树或BVH)扩充，为不同的任务创建，如更快的挑选或挑选。大多数模型所在的叶节点是共享的，因此额外的空间效率结构的成本相对较低。</strong></p>
<h2 id="Culling-Techniques-剔除技术"><a href="#Culling-Techniques-剔除技术" class="headerlink" title="Culling Techniques 剔除技术"></a>Culling Techniques 剔除技术</h2><p><strong>cull的意思是“从鸟群中移除”，在计算机图形学中，这正是cull技术的作用。鸟群是我们想要渲染的整个场景，而移除仅限于那些被认为对最终图像没有贡献的场景部分。场景的其余部分通过渲染管道发送。因此，术语“可见性剔除”也经常用于渲染上下文中。然而，筛选也可以用于程序的其他部分。例子包括碰撞检测(通过对屏幕外或隐藏物体进行较不精确的计算)，物理计算和AI。这里只介绍与渲染相关的裁剪技术。这些技术的例子有背面剔除、视图截锥剔除和遮挡剔除。如下图所示。背面剔除消除了面对观众的三角形。视图截锥剔除视图截锥外的一组三角形。遮挡剔除剔除被一组其他对象隐藏的对象。这是最复杂的剔除技术，因为它需要计算对象如何相互影响。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105133207.png" class="" title="image-20211105133207">

<p>不同的筛选技术。剔除的几何图形是虚线。(参见Cohen-Or等人的插图。)</p>
<p><strong>实际的剔除理论上可以发生在渲染管道的任何阶段，对于一些遮挡剔除算法，它甚至可以预先计算。对于GPU上实现的剔除算法，我们有时只能禁用/禁用或设置一些参数，剔除功能。最快的三角形渲染是从未发送到GPU的。其次，管道筛选越早发生越好。剔除通常是通过使用几何计算来实现的，但绝不仅限于这些。例如，算法也可以使用帧缓冲区的内容。</strong></p>
<p><strong>理想的剔除算法将只通过管线发送准确的可见集合(EVS)的原语。在本书中，EVS被定义为所有部分或完全可见的原语。允许理想剔除的数据结构之一是方面图，在给定任何观点的情况下，都可以从中提取EVS。创建这样的数据结构在理论上是可能的，但在实践中是不可能的，因为最坏时间的复杂性可能与O(n⁹)一样糟糕。相反，实用的算法试图找到一个集合，称为潜在可见集(PVS)，这是对EVS的预测。如果PVS完全包含EVS，只丢弃不可见的几何形状，则PVS被称为保守型。一个PVS也可能是近似的，其中没有完全包括电动汽车。因此，这种类型的PVS可能生成不正确的图像。目标是让这些错误越小越好。由于保守的PVS总是生成正确的图像，所以通常认为它更有用。通过过高估计或接近EVS，其想法是PVS可以更快地计算。难点在于如何进行这些估计以获得总体性能。例如，一个算法可以处理不同粒度的几何图形，例如。三角形、整体或一组物体。当找到一个PVS时，它将使用z缓冲区进行渲染，这将解析最终的逐像素可见性。</strong></p>
<p><strong>请注意，有一些算法可以重新排序网格中的三角形，以提供更好的遮挡剔除，即减少了透支，同时改进了顶点缓存局部性。虽然这些都与淘汰有一定的关系，但我们将感兴趣的读者参考参考文献。</strong></p>
<p><strong>在19.3-19.8节中，我们处理了背面剔除、视图截锥剔除、门户剔除、细节剔除、遮挡剔除和剔除系统。</strong></p>
<h2 id="Backface-Culling-背面剔除"><a href="#Backface-Culling-背面剔除" class="headerlink" title="Backface Culling 背面剔除"></a>Backface Culling 背面剔除</h2><p><strong>假设你正在一个场景中观察一个不透明的球体。球体的大约一半是看不见的。从这个观察得出的结论是，不可见的东西不需要被渲染，因为它对图像没有贡献。因此，球体的背面不需要处理，这就是背面剔除的思想。这种类型的剔除也可以一次对整个组进行，因此被称为集群背面剔除。</strong></p>
<p><strong>假设相机在外部，并且没有穿透，如果相机是透明物体的一部分，那么所有的背面三角形都可以从进一步的处理中剔除(例如，近夹入)，对象。如果已知投影三角形在屏幕空间中是顺时针方向的，则一个一致方向的三角形(第16.3节)是背向的。这个测试可以通过计算二维屏幕空间中三角形的带符号的面积来实现。带负号的面积表示三角形应该被剔除。这可以在屏幕映射过程发生后立即执行。</strong></p>
<p><strong>另一种确定三角形是否面向背面的方法是创建一个向量，从三角形所在平面上的任意点(其中一个顶点是最简单的选择)到观察者的位置。对于正投影，眼睛位置的矢量被替换为负视图方向，这对于场景是恒定的。计算这个向量和三角形的法向量的点积。负的点积意味着两个向量之间的夹角大于π/2弧度，所以三角形不是面向观众的。这个测试等价于计算从观察者的位置到三角形平面的标记距离。如果符号是正的，三角形是正面的。注意，距离只有在法线被标准化的情况下才能获得，但在这里这并不重要，因为只有符号才是我们感兴趣的。或者，在应用了投影矩阵之后，将顶点ˉv = (vx, vy, vw)，并计算行列式d = |ˉv0, ˉv1, ˉv2|。如果d≤0，则可以剔除三角形。这些剔除技术如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105134214.png" class="" title="image-20211105134214">

<p>确定三角形是否背朝的两个不同的测试。左图显示了测试是如何在屏幕空间中完成的。左边的两个三角形是正面的，右边的三角形是背面的，可以省略。右图显示了如何在视图空间中完成背面测试。三角形A和B是正面的，而C是背面的。</p>
<p><strong>Blinn指出，这两种测试在几何上是相同的。理论上，区分这些测试的是计算测试的空间，而不是其他。在实践中，屏幕空间测试通常更安全，因为在视图空间中看起来稍微向后的边三角形在屏幕空间中可能会稍微向前。这是因为视图空间坐标四舍五入到屏幕空间亚像素坐标。</strong></p>
<p><strong>使用诸如OpenGL或DirectX之类的API，背面剔除通常通过一些功能来控制，这些功能要么启用背面剔除，要么启用正面剔除，要么禁用所有剔除。请注意，镜像转换(即一种负缩放操作)将面向后的三角形变成面向前的三角形，反之亦然(第4.1.3节)。最后，可以在像素着色器中找出一个三角形是否正对。在OpenGL中，这是通过测试gl_FrontFacing来完成的，在DirectX中它被称为SV_IsFrontFace。在此之前，主要方式显示双面对象正确的做法是将它们渲染两次，首先剔除背面，然后剔除正面，并反转法线。</strong></p>
<p><strong>关于标准背面剔除的一个常见误解是，它减少了大约一半的三角形渲染的数量。虽然背面剔除将移除许多物体中大约一半的三角形，但它将为某些类型的模型提供很少的增益。例如，室内场景的墙壁、地板和天花板通常是面向观众的，所以在这些场景中，这些类型的背面相对较少。类似地，在地形渲染中，大多数三角形都是可见的，只有那些在山或峡谷的背面的三角形受益于这种技术。</strong></p>
<p><strong>虽然背面剔除是一种避免对单个三角形进行栅格化的简单技术，但如果可以通过一个测试来决定是否可以剔除整个三角形集合，那么它将会更快。这些技术被称为集群背面剔除算法，我们将在这里回顾其中的一些。许多这样的算法使用的基本概念是法向锥。对于曲面的某些部分，创建一个截锥，它包含所有的法线方向和所有的点。注意，沿着法线的两段距离需要截断圆锥体。参见下图中的示例。可以看出，圆锥是由法线n和半角α和锚点c以及沿法线截断圆锥的一些偏移距离定义的。在下图的右侧，一个法向锥的横截面被显示出来。Shirman和Abi-Ezzi证明，如果观察者位于前面向锥体，那么锥体中的所有面都是前面向的，后面向锥体也是如此。Engel使用了一个类似的概念，称为GPU剔除的排除体积。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105134531.png" class="" title="image-20211105134531">

<p>左:一组三角形及其法线。左中:法线被收集(上)，最小锥(下)，由一个法线n定义，半角α，被构造。中右:圆锥被锚定在点c上，并被截断，以便它也包含三角形上的所有点。右图:截去的圆锥的横截面。顶部的浅灰色区域为前视锥，底部的浅灰色区域为后视锥。点f和点b分别是前锥和后锥的顶点。</p>
<p><strong>对于静态网格，Haar和Aaltonen建议在n个三角形周围计算一个最小的立方体，每个立方体面被分割成r ×r“像素”，每个编码一个n位掩码，表示相应的三角形是否在其上可见“像素。下图说明了这一点。如果相机在立方体外面，就可以找到相机所在的相应截锥，并且可以立即查找它的位掩码并知道哪些三角形是背向的(保守地)。如果摄像机在立方体内部，所有三角形都被认为是可见的(除非有人想要执行进一步的计算)。Haar和altonen在每个立方体面只使用一个位掩码，一次编码n = 64个三角形。通过计算位掩码中设置的比特数，可以有效地为未剔除的三角形分配内存。《刺客信条:大革命》也使用了这种方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105134719.png" class="" title="image-20211105134719">

<p>一组五个静态三角形，从边缘上看，被二维的正方形包围着。左边的方形面被分割成4个“像素”，我们关注从顶部开始的一秒，它在盒子外面的截锥被涂成蓝色。三角形平面形成的正半空间用一个半圆(红色和绿色)表示。所有三角形在其正半空间中没有蓝色截锥的任何部分，都从截锥的所有点保守地向后(标记为红色)。绿色表示那些正面的。</p>
<p><strong>接下来，我们将使用一个未截断的法锥，与上上图中的一个相反，因此它仅由中心点c、法向n和角度α定义。要计算这样一个由多个三角形组成的法锥，取三角形平面的所有法线，将它们放在相同的位置，在包含所有法线的单位球面上计算一个最小圆。作为第一步，假设从点e开始，我们要测试圆锥中共享原点c的所有法线。如果下列条件成立:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105134827.png" class="" title="image-20211105134827">

<p><strong>所有的几何图形都在一个圆心为c，半径为r的球体内，然而，这个测试只在所有几何图形位于c的情况下有效</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105134915.png" class="" title="image-20211105134915">

<p><strong>其中sin β = r/||c−e||。推导这个测试所涉及的几何图形如下图所示。量子化的法线可以存储在8 × 4位，这对于某些应用可能已经足够了。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105134947.png" class="" title="image-20211105134947">

<p>这种情况显示了限制正常的锥时,定义为c, n,α,只是将成为可见e从最关键的点在圆半径和中心c点。这发生在e点的向量之间的夹角等圆,圆的切线向量,法锥的边是π/2弧度。注意，法锥已经从c向下平移，所以它的原点与球面边界重合。</p>
<p><strong>最后，我们注意到，对于运动模糊三角形(每个顶点在一帧上都有一个线性运动)的后端面剔除并不像人们想象的那么简单。一个顶点随时间线性移动的三角形可以在一帧开始时向后转，然后再向后转，所有这些都在同一帧内。因此，如果在帧的开始和结束时由于运动模糊的三角形背向而剔除三角形，将会产生不正确的结果。Munkberg和Akenine-M¨oller提出了一种将标准后端面测试中的顶点替换为线性移动三角形顶点的方法。将检验重写为Bernstein形式，并利用B´ezier曲线的凸性作为保守检验。对于景深，如果整个镜头在三角形的负半空间(换句话说，在它后面)，三角形可以被安全地剔除。</strong></p>
<h2 id="View-Frustum-Culling-视锥剔除"><a href="#View-Frustum-Culling-视锥剔除" class="headerlink" title="View Frustum Culling 视锥剔除"></a>View Frustum Culling 视锥剔除</h2><p><strong>正如在第2.3.3节中看到的，只有完全或部分位于视图截屏内的原语需要被渲染。加速渲染过程的一种方法是将每个对象的边界体积与视图截锥进行比较。如果BV在截锥外，那么它所包含的几何图形可以从渲染中省略。如果BV在截锥内部或与截锥相交，那么BV的内容可能是可见的，必须通过渲染管道发送。参见第22.14节，了解各种边界体与视图截锥之间交集的测试方法。</strong></p>
<p><strong>通过使用空间数据结构，这种选择可以分层应用。对于一个包围体层次，从根开始的预定遍历是否工作。每个具有包围体的节点都在截锥上进行测试。如果节点的BV在截锥外，则该节点不会被进一步处理。树被修剪了，因为BV的内容和子节点都在视图之外。如果BV完全在截锥内部，它的内容必须全部在截锥内部。遍历还在继续，但是对于这个子树的其余部分不需要进一步的截锥测试。如果BV与截锥相交，则遍历将继续进行，并对其子节点进行测试。当一个叶节点被发现相交时，它的内容(即它的几何形状)通过管线发送。叶子的原语不能保证在视图截锥内。视图截锥裁剪的一个例子如下图所示。也可以对一个对象或单元格使用多个BV测试。例如，如果发现单元周围的球体BV与截锥重叠，如果已知这个立方体比球体小得多，则可能值得执行更精确(尽管更昂贵)的OBB截锥测试。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105201316.png" class="" title="image-20211105201316">

<p>一组几何体和它的边界体(球体)显示在左边。这个场景是通过从眼睛的角度剔除视图截锥来渲染的。右侧显示BVH。根的BV与截锥相交，遍历过程继续测试其子的BV。左子树的BV与之相交，并且该子树的一个子树与之相交(因此被渲染)，而另一个子树的BV在外部，因此不会通过管线发送。根的中间子树的BV完全在内部，并立即呈现。根的右子树的BV也完全在里面，因此整个子树不需要进一步的测试就可以渲染。</p>
<p><strong>对于“相交截锥”情况，一个有用的优化方法是跟踪BV完全位于哪个截锥平面内。该信息通常存储为位掩码，然后可以通过交点来测试该BV的子节点。这种技术有时被称为平面掩蔽，因为只有那些与BV相交的平面需要对儿童进行测试。根BV最初将针对所有6个截锥平面进行测试，但随着连续的测试，每个孩子所做的平面/BV测试的数量将下降。Assarsson和M¨oller注意到时间一致性可以也被使用。拒绝BV的截锥平面可以与BV存储在一起，然后在下一帧中作为第一个拒绝测试的平面。Wihlidal指出，如果在CPU上对每个对象进行视图截锥剔除，那么当在GPU上进行更细粒度的剔除时，对左、右、下和上平面执行视图截锥剔除就足够了。此外，为了提高性能，可以使用顶点映射的构造来提供更紧密的边界体积。这在22.13.4节中有更详细的描述。有时在远处使用雾是为了避免物体突然在远处的平面上消失的影响。</strong></p>
<p><strong>对于大型场景或特定的摄像机视图，只有场景的一小部分可能是可见的，而且只有这个部分需要通过渲染管道发送。在这种情况下，速度有望大幅提高。视图截锥裁剪技术利用了场景中的空间相干性，因为彼此靠近的对象可以被包围在一个BV中，而附近的BV可以分层集群。</strong></p>
<p><strong>需要注意的是，有些游戏引擎并不使用分层BVs，而是使用线性BVs列表，每个BVs对应场景中的每个对象。主要的动机是使用SIMD和多线程更容易实现算法，从而提供更好的性能。然而，对于一些应用程序，如CAD，大多数或所有的几何是在截锥内，在这种情况下，应该避免使用这些类型的算法。层次视图截锥裁剪仍然可以应用，因为如果一个节点在截锥内部，它的几何形状可以立即绘制出来。</strong></p>
<h2 id="Portal-Culling-门户剔除"><a href="#Portal-Culling-门户剔除" class="headerlink" title="Portal Culling 门户剔除"></a>Portal Culling 门户剔除</h2><p><strong>对于体系结构模型，有一组称为门户筛选的算法。第一个是由Airey等人介绍的。后来，Teller和S´equin以及Teller和Hanrahan构建了更高效、更复杂的门户筛选算法。所有门户剔除算法的基本原理是墙壁通常在室内场景中充当大型遮挡物。因此，门户剔除是一种遮挡剔除，将在下一节中讨论。这种遮挡算法通过每个入口(如门或窗)使用一个视图截锥剔除机制。当横越门脉时，截锥缩小以紧贴门脉。因此，该算法也可以看作是视图截锥剔除的一种扩展。视图截锥外的门户被丢弃。</strong></p>
<p><strong>门户筛选方法以某种方式对场景进行预处理。场景被划分为若干个单元，通常与建筑中的房间和走廊相对应。连接相邻房间的门窗称为门户。单元格中的每个对象和单元格的壁都存储在与单元格相关联的数据结构中。我们还在邻接图中存储关于相邻单元和连接它们的门户的信息。Teller给出了计算这张图的算法。虽然这项技术在1992年被引入时就已经开始工作了，但对于现代复杂的场景来说，自动化过程是极其困难的。因此，定义单元格和创建图形目前都是手工完成的。</strong></p>
<p><strong>Luebke和Georges使用一种简单的方法，只需要少量的预处理。所需要的唯一信息是与每个单元相关联的数据结构，如上所述。关键思想是，每个门户都定义了进入其房间内外的视图。想象一下，你正从一扇门往一个有三扇窗户的房间里看。门道定义了一个截锥，你可以用它来剔除房间中不可见的对象，然后渲染那些可以看到的对象。你无法通过门口看到两扇窗户，所以通过这些窗户可以看到的细胞可以被忽略。第三扇窗户可以看到，但部分被门框挡住了。只有通过通道和窗口可见的单元格中的内容需要通过管道发送。单元格呈现过程依赖于以递归的方式跟踪这种可见性。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105201728.png" class="" title="image-20211105201728">

<p>门户剔除:从A到H枚举单元，门户是连接单元的开口。只有通过入口看到的几何图形被渲染。例如，F单元格中的星号被剔除。</p>
<p><strong>上图给出了一个示例，说明了门户剔除算法。观察者或眼睛位于单元格E，因此与它的内容一起呈现。邻近的细胞是C、D和F。原始截体无法看到细胞D的入口，因此在进一步处理中省略了。单元格F是可见的，因此视图截屏被缩小，以便它通过连接到F的门户。F的内容随后用缩小的截屏呈现。然后，检查F的邻近细胞——从缩小的截锥看不到G，因此省略，而H是可见的。同样，截锥随着H的入口而缩小，然后呈现H的内容。H没有没有被访问过的邻居，所以遍历到这里就结束了。现在，递归返回到单元C的门户。截锥被缩小以适应C的门户，然后在C中渲染对象，使用截锥剔除。没有更多的门户是可见的，所以呈现完成了。</strong></p>
<p><strong>每个对象在呈现后都可以被标记，以避免多次呈现对象。例如，如果一个房间有两扇窗户，里面的东西房间的各个部分分别针对每个截锥进行裁剪。如果没有标记，一个物体可以通过两个窗口看到，那么它将被渲染两次。这不仅效率低下，还会导致呈现错误，比如当对象是透明的时候。为了避免必须清除每个帧的标签列表，每个对象在访问时都被标记为帧号。只有存储当前帧号的对象已经被访问过。</strong></p>
<p><strong>一个值得实现的优化是使用模板缓冲区进行更精确的筛选。在实践中，门户被高估了AABB;真正的门户很可能会更小。模板缓冲区可用于屏蔽真实门户之外的呈现。类似地，可以为GPU设置一个围绕门户的剪接矩形，以提高性能。使用模板和剪刀功能还避免了执行标记的需要，因为透明对象可能被渲染两次，但只会影响每个门户中的可见像素一次。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105201935.png" class="" title="image-20211105201935">

<p>门户剔除。左图是布鲁克斯住宅的俯视图。右边的图片是从主卧看到的。传送门的筛选框是白色的，镜子是红色的。(图片由北卡罗来纳大学教堂山分校的David Luebke和Chris Georges提供。)</p>
<p><strong>有关门户使用的另一个视图，请参见上图。这种形式的门脉剔除也可以用于平面反射的内容修剪(第11.6.2节)。左边的图片显示了从顶部看到的一座建筑;白线表示截锥随每个门而缩小的方式。红线是通过在镜子上反射锥体而产生的。实际视图显示在右边的图像中，白色的矩形是入口，镜子是红色的。注意，渲染的只是视锥体内部的对象。其他转换可以用来创建其他效果，比如简单的折射。</strong></p>
<h2 id="Detail-and-Small-Triangle-Culling-细节和小三角形剔除"><a href="#Detail-and-Small-Triangle-Culling-细节和小三角形剔除" class="headerlink" title="Detail and Small Triangle Culling 细节和小三角形剔除"></a>Detail and Small Triangle Culling 细节和小三角形剔除</h2><p><strong>细节剔除是一种为了速度而牺牲质量的技术。细节剔除的基本原理是场景中的小细节对渲染效果的贡献很小当观众在运动时的图像。当查看器停止时，细节剔除通常被禁用。考虑一个有边界体的物体，并将这个BV投影到投影平面上。然后以像素估计投影的面积，如果像素的数量低于用户定义的阈值，则该对象将从进一步处理中省略。由于这个原因，细节剔除有时被称为屏幕大小剔除。细节剔除也可以在场景图上分层进行。这些类型的技术通常用于游戏引擎。</strong></p>
<p><strong>在每个像素的中心有一个样本，小三角形很可能落在样本之间。此外，小三角形的栅格化效率很低。一些图形硬件实际上会剔除落在样本之间的三角形，但当使用GPU上的代码进行剔除时(章节19.8)，添加一些代码来剔除小三角形可能是有益的。Wihlidal提出了一种简单的方法，首先计算三角形的AABB。如果以下条件成立，三角形可以在着色器中被剔除:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105202249.png" class="" title="image-20211105202249">

<p><strong>其中min和max表示三角形周围的二维AABB。如果任意一个向量分量为真，函数any将返回真。还记得像素中心位于(x+0.5, y +0.5)，这意味着如果x坐标或y坐标或两者都四舍五入到相同的坐标，则上式为真。下图显示了一些示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105202304.png" class="" title="image-20211105202304">

<p>小三角形剔除使用any(round(min) == round(max))。红色三角形被剔除，而绿色三角形需要渲染。左:绿色三角形与样本重叠，不能剔除。红色三角形都围绕所有AABB坐标到相同的像素角。右:红色三角形可以被剔除，因为AABB坐标中的一个被舍入为相同的整数。绿色三角形没有重叠任何样本，但不能被此测试剔除。</p>
<h2 id="Occlusion-Culling-遮挡剔除"><a href="#Occlusion-Culling-遮挡剔除" class="headerlink" title="Occlusion Culling 遮挡剔除"></a>Occlusion Culling 遮挡剔除</h2><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105202704.png" class="" title="image-20211105202704">

<p>说明遮挡剔除是如何有用的。10个球体被放置在一条直线上，观察者沿着这条直线(左)用透视法观察。中间的深度复杂度图像显示一些像素被写入了几次，尽管最终图像(在右边)只显示了一个球体。</p>
<p><strong>正如我们所看到的，可见性可以通过z缓冲区来解决。尽管它正确地解决了可见性问题，但是z-buffer是相对简单和暴力的，所以并不总是如此最有效的解决方案。例如，想象观众沿着一条有10个球体的线看。如上图所示。从这个视角渲染的图像将只显示一个球体，即使所有10个球体将被栅格化并与z缓冲区进行比较，然后可能写入颜色缓冲区和z缓冲区。上图的中间部分显示了这个场景在给定视角下的深度复杂性。深度复杂性是指一个像素所覆盖的表面的数量。在10个球体的情况下，由于所有10个球体都位于那里，假设进行了背面剔除，所以中间的像素的深度复杂度为10。如果场景由后向前渲染，中间的像素将被像素阴影10倍，即有9个不必要的像素着色执行。即使场景是由前到后渲染，所有10个球体的三角形仍然会被栅格化，深度将被计算，并与z缓冲区中的深度进行比较，即使只生成了一个球体的图像。这种无趣的场景不太可能在现实中找到，但它(从给定的观点)描述了一个人口稠密的模型。这些类型的配置在真实场景中都能找到，比如雨林、引擎、城市和摩天大楼的内部。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105202813.png" class="" title="image-20211105202813">

<p>一个名为Neu Rungholt的《我的世界》场景，通过遮挡剔除显示了观众位于右下角的位置。轻微着色的几何体被剔除，而较暗的被渲染。最后的图像显示在左下角。(转载由Jon Hasselgren, Magnus Andersson和Tomas Akenine-M¨oller和英特尔公司许可，版权为英特尔公司，2016年。Neu Rungholt地图由kescha提供。)</p>
<p><strong>鉴于前面的例子，一种避免这种效率低下的算法方法可能会在性能上获得回报，这似乎是合理的。这种方法被称为遮挡剔除算法，因为它们试图剔除被遮挡的对象，即被场景中其他对象隐藏的对象。最优的遮挡剔除算法将只选择可见的对象。从某种意义上说，z-buffer只选择和渲染那些可见的对象，但并非没有通过大部分管道发送视图截屏内的所有对象。高效遮挡剔除算法背后的思想是在早期执行一些简单的测试来剔除隐藏对象集。在某种意义上，背面剔除是遮挡剔除的一种简单形式。如果我们提前知道一个对象是固体和不透明的，那么背面被正面遮挡，因此不需要渲染。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105202951.png" class="" title="image-20211105202951">

<p>左图显示了基于点的可见性，而右图显示了基于单元格的可见性，其中单元格是一个框。可以看到，从视点左侧的圆圈被遮挡。然而，在右边，圆圈是可见的，因为光线可以从细胞内的某个地方绘制到圆圈，而不与任何遮挡器相交。</p>
<p><strong>遮挡剔除算法主要有两种形式，即基于点的和基于单元的。如上图所示。基于点的可见性只是在渲染中通常使用的，也就是说，从单个视图位置看到的内容。另一方面，基于单元格的可见性是针对单元格进行的，单元格是包含一组观察位置的空间区域，通常是一个盒子或一个球体。基于单元格可见性的不可见对象必须从单元格内的所有点都不可见。的优势基于单元格的可见性是，一旦为单元格计算了它，它通常可以用于几个帧，只要查看器在单元格内。然而，与基于点的可见性相比，计算它通常要花费更多的时间。因此，它通常作为预处理步骤进行。基于点和基于单元的可见性在本质上与点和区域光源相似，在这些光源中，光可以被认为是观看场景。对于一个看不见的物体，这相当于它在本影区，即完全处于阴影之中。</strong></p>
<p><strong>人们还可以将遮挡剔除算法分类为在图像空间、对象空间或光线空间中操作的算法。图像空间算法在经过一些投影后进行二维可见性测试，而物体空间算法则使用原始的三维物体。射线空间方法在双空间中进行测试。每个感兴趣的点，通常是二维的，在这个对偶空间中被转换成射线。对于实时图形，在三种算法中，图像空间遮挡剔除算法是应用最广泛的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105203102.png" class="" title="image-20211105203102">

<p>一个通用的遮挡剔除算法的伪代码。G包含场景中的所有物体，OR 为遮挡表示。P是一组电位闭塞体，合并到OR 当它包含足够多的对象时。</p>
<p><strong>一种类型的遮挡剔除算法的伪代码如上图所示，其中isOccluded函数，通常称为可见性测试，检查对象是否被遮挡。G是要渲染的几何对象集合，OR 是闭塞表示，P是一组潜在闭塞器，可以与OR．取决于特定的算法，OR 表示某种遮挡信息。OR 开始时设置为空。然后，处理所有对象(通过视图截锥剔除测试的对象)。</strong></p>
<p><strong>考虑一个特定的对象。首先，我们测试对象是否相对于遮挡表示OR．如果它被阻塞，那么它就不被处理此外，因为我们知道它不会对图像有贡献。如果不能确定物体被遮挡，那么该物体必须被渲染，因为它可能对图像有贡献(在渲染的那个点上)。然后将对象加入到P中，如果P中的对象数量足够大，则可以将这些对象的遮挡能力合并到OR中．因此，P中的每个对象都可以用作遮挡器。</strong></p>
<p><strong>注意，对于大多数遮挡剔除算法，性能取决于对象绘制的顺序。举个例子，考虑一辆里面装有马达的汽车。如果汽车的引擎盖是先拉的，那么发动机(可能)将被剔除。另一方面，如果电机是首先被拉，那么什么也不会被淘汰。按照粗略的从前到后的顺序排序和渲染可以获得相当大的性能增益。此外，值得注意的是，小物体可能是优秀的遮挡器，因为距离遮挡器决定了它可以遮挡多少。举个例子来说，如果观看者离火柴盒足够近，火柴盒就会挡住金门大桥。</strong></p>
<h3 id="Occlusion-Queries-遮挡查询"><a href="#Occlusion-Queries-遮挡查询" class="headerlink" title="Occlusion Queries 遮挡查询"></a>Occlusion Queries 遮挡查询</h3><p><strong>GPU通过使用一种特殊的渲染模式来支持遮挡剔除。用户可以查询GPU，以确定与z缓冲区的当前内容相比，一组三角形是否可见。三角形通常形成一个更复杂物体的包围体(例如，一个盒子或k-DOP)。如果这些三角形都不可见，那么对象就会被剔除。GPU对查询的三角形进行栅格化，并将它们的深度与z缓冲区进行比较。，它在图像空间中运行。生成了这些三角形可见的像素数n，尽管实际上没有修改像素或任何深度。如果n为零，则所有三角形被遮挡或剪切。</strong></p>
<p><strong>然而，计数为零不足以确定边界卷是否不可见。更准确地说，摄像机截锥的可见近平面的任何部分都不应该在包围体内。假设满足此条件，则整个包围体被完全遮挡，包含的对象可以安全地丢弃。如果n &gt; 0，则有一部分像素没有通过测试。如果n小于阈值像素数，则该对象可能会被丢弃，因为它对最终图像的贡献不大。通过这种方式，速度可以换取可能的质量损失。另一个用途是让n帮助确定对象的LOD(章节19.9)。如果n很小，那么对象(可能)可见的部分就更小，因此可以使用不太详细的LOD。</strong></p>
<p><strong>当发现包围体被遮挡时，我们通过避免通过渲染管道发送潜在的复杂对象来提高性能。然而，如果测试失败，我们实际上会损失一些性能，因为我们花了额外的时间测试这个边界卷，但没有任何好处。</strong></p>
<p><strong>这种测试有多种变体。出于筛选的目的，不需要可见片段的确切数量——只要一个布尔值表示是否至少就足够了一个片段通过了深度测试。OpenGL 3.3和DirectX 11以及之后的版本支持这种类型的遮挡查询ANY_SAMPLES_PASSED ，枚举为OpenGL中通过的任何样本。这些测试可以更快，因为它们可以在一个片段可见时终止查询。OpenGL 4.3及其后续版本还允许该查询的更快变体，称为ANY_SAMPLES_PASSED_CONSERVATIVE。实现可以选择提供一个不那么精确的测试，只要它是保守的，并且错误在正确的一边。例如，硬件供应商可以通过只对粗深度缓冲区(第23.7节)而不是逐像素深度执行深度测试来实现这一点。</strong></p>
<p><strong>查询的延迟通常是相对较长的时间。通常，数百或数千个三角形可以在这个时间内被渲染，参见第23.3节更多关于延迟的内容。因此，这种基于GPU的遮挡剔除方法是值得的，当包围盒包含大量的对象和相对大量的遮挡发生时。GPU使用一个闭塞查询模型，CPU可以向GPU发送任意数量的查询，然后它定期检查是否有可用的结果，也就是说，查询模型是异步的。GPU执行每个查询，并将结果放入队列中。CPU的队列检查非常快，CPU可以继续发送查询或实际的可渲染对象，而不必停止。DirectX和OpenGL都支持断言/条件闭塞查询，其中查询和对应的draw调用的ID都是同时提交的。只有当表明遮挡查询的几何形状是可见的时，对应的绘制调用才会由GPU自动处理。这使得模型更加有用。</strong></p>
<p><strong>一般来说，应该对最有可能被阻塞的对象执行查询。Koval ‘e´ık和Sochor在应用程序运行时，收集每个对象在多个帧上的查询的运行统计信息。一个物体被发现被隐藏的帧数会影响它在未来被测试遮挡的频率。也就是说，可见的对象可能会保持可见，因此可以较少地测试。如果可能，隐藏对象在每一帧都要进行测试，因为这些对象最有可能从遮挡查询中受益。Mattausch等人提出了几种不含谓词/条件渲染的遮挡查询(OCs)优化方法。他们使用批量OCs，将几个OCs组合成一个OC，使用几个边界框而不是一个更大的框，并使用临时抖动采样来调度先前可见的对象。</strong></p>
<p><strong>这里所讨论的方案给出了闭塞剔除方法的潜力和问题。什么时候使用遮挡查询，或者使用大多数遮挡方案，通常都不清楚。如果所有东西都是可见的，遮挡算法只会花费额外的时间，永远不要保存它。一个挑战是迅速确定算法没有帮助，因此减少徒劳的节省时间的尝试。另一个问题是决定使用什么对象集作为遮挡器。截屏内的第一个对象必须是可见的，所以在这些对象上花费查询是很浪费的。在大多数遮挡剔除算法中，决定渲染的顺序和何时测试遮挡都是一个难题。</strong></p>
<h3 id="Hierarchical-Z-Buffering-分层z缓冲"><a href="#Hierarchical-Z-Buffering-分层z缓冲" class="headerlink" title="Hierarchical Z-Buffering 分层z缓冲"></a>Hierarchical Z-Buffering 分层z缓冲</h3><p><strong>分层z缓冲(HZB)对遮挡剔除研究产生了重要影响。虽然原始的CPU端形式很少被使用，但该算法是GPU硬件方法z-剔除(章节23.7)和使用GPU或CPU上运行的软件进行自定义遮挡剔除的基础。我们首先描述基本算法，然后是如何在各种渲染引擎中采用这种技术。</strong></p>
<p><strong>该算法将场景模型保持在八叉树中，帧的z缓冲区作为图像金字塔，我们称之为z金字塔。因此，该算法在图像空间中操作。八叉树使场景中被遮挡区域的分级剔除成为可能，而z金字塔使原语的分级z缓冲成为可能。因此，z金字塔是该算法的遮挡表示。这些数据结构的示例如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105204339.png" class="" title="image-20211105204339">

<p>用HZB算法遮挡剔除的例子，显示了一个深度复杂度高的场景(右下)，对应的z-金字塔(左上)和八叉树细分(右上)。通过从前面到后面遍历八叉树并剔除遇到的被遮挡的八叉树节点，该算法只访问可见的八叉树节点及其子节点(右上角的节点)，并仅在可见框中呈现三角形。在这个例子中，剔除闭塞的八叉树节点将深度复杂度从84降低到2.5。</p>
<p><strong>z金字塔的最精细(最高分辨率)级别只是一个标准的z缓冲区。在所有其他级别上，每个z值是相邻的更细级别对应的2 × 2窗口中最远的z。因此，每个z值表示屏幕正方形区域中最远的z。无论何时z值在z缓冲区中被覆盖，它都会通过z金字塔的粗糙层传播。这是递归地完成的，直到到达图像金字塔的顶部，那里只剩下一个z值。下图显示了金字塔的形成。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105204447.png" class="" title="image-20211105204447">

<p>在左边，显示了一个4 × 4的z缓冲区。数值是实际的z值。这被向下采样到一个2×2的区域，其中每个值都是左边四个2×2区域中最远(最大)的。最后，计算其余四个z值中最远的值。这三个映射组成了一个图像金字塔，称为层次z缓冲区。</p>
<p><strong>八叉树节点的分级剔除方法如下:大致按照从前到后的顺序遍历八叉树节点。使用扩展的遮挡查询(章节19.7.1)在z-金字塔上测试八叉树的包围框。我们从最粗糙的z-金字塔单元格开始测试，该单元格包含盒子的屏幕投影。方框在单元格内最近的深度(znear)然后与z金字塔值进行比较，如果znear 越远，盒子就被遮挡。这个测试递归地沿着z-金字塔向下进行，直到发现盒子被遮挡，或者直到到达z-金字塔的底层，在这一点上盒子是可见的。对于可见的八叉树盒，在八叉树中继续递归地向下进行测试，最终将潜在可见的几何图形呈现到分层的z缓冲区中。这样做是为了在后续测试中使用先前渲染对象的遮挡能力。</strong></p>
<p><strong>完整的HZB算法目前还没有被使用，但它已经被简化并适应了GPU上使用自定义剔除或CPU上使用软件光栅化的计算通道。一般来说，大多数基于HZB的遮挡剔除算法是这样工作的:</strong></p>
<pre><code>**1.使用闭塞器表示生成一个完整的层次z金字塔。**

**2.要测试对象是否被遮挡，将其包围体投影到屏幕空间，并估计z-金字塔中的mip水平。**

**3.测试闭塞对选定的mip水平。如果结果不明确，可选择继续使用更精细的mip水平进行测试。**
</code></pre>
<p><strong>大多数实现不使用八叉树或任何BVH，也不更新z金字塔后，一个对象已经被渲染，因为这被认为是太昂贵的执行。</strong></p>
<p><strong>步骤1可以使用“最佳”闭塞器，它可以被选为n个对象中最近的集合，使用简化的艺术家生成的闭塞器原语，或者使用关于在前一帧可见的对象集合的统计数据。或者，可以使用上一帧的z缓冲区，但这不是保守的，因为有时对象可能会因为不正确的剔除而弹出，特别是在快速相机或对象移动下。Haar和Aaltonen都渲染了最好的遮光器，并将它们与前一帧深度的1/16低分辨率的重新投影相结合。然后使用GPU构建z-金字塔，如上图所示。一些使用AMD GCN架构的HTILE(章节23.10.3)来加速z-金字塔的生成。</strong></p>
<p><strong>在步骤2中，物体的边界体积被投影到屏幕空间。BVs的常见选择是球体、AABBs和OBBs。用投影BV的最长边l(以像素为单位)计算mip水平λ，如</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105204839.png" class="" title="image-20211105204839">

<p><strong>其中n是z-金字塔中mip层的最大数目。马克斯操作符是否存在以避免获得负的mip水平，并且最小值避免访问不存在的mip水平。上方程选择最低的整数mip水平，使投影的BV最多覆盖2 × 2的深度值。这种选择的原因是它使成本可预测—最多需要读取和测试四个深度值。此外，Hill和Collin认为，这种测试可以被视为“概率性的”，因为大物体比小物体更容易被看到，所以没有理由在这些情况下读取更多的深度值。</strong></p>
<p><strong>当到达第3步时，我们知道投影的BV在该mip水平上以一组最大为2 × 2的深度值为界。对于给定大小的BV，它可能完全落在mip水平的一个深度texel内。然而，取决于它如何落在网格上，它可能覆盖所有四个像素。最小深度的BV计算，或精确或保守。对于视图空间中的AABB，这个深度就是盒子的最小深度，对于OBB，可以将所有顶点投影到视图向量上并选择最小的距离。对于球面，Shopf等人计算出球面上最近的点为c−rc/||c||，其中c为视图空间中的球面中心，r为球面半径。注意，如果摄像机在一个BV内，那么BV将覆盖整个屏幕，然后对象被渲染。最小深度zmin，将BV的(最大)2 × 2深度与层次z缓冲区的(最大)2 × 2深度进行比较，如果zmin 总是较大，则BV被遮挡。如果对象没有被检测到被遮挡，可以在这里停止测试并只是渲染对象。</strong></p>
<p><strong>你也可以继续针对金字塔中的下一个更深层次(更高分辨率)进行测试。我们可以通过使用另一个存储最小深度的z形金字塔来验证这种测试是否有效。我们测试最大距离zmax，到BV在这个新缓冲区中对应的深度。如果zmax 比所有这些深度都小，那么BV肯定是可见的，可以立即渲染。否则,zmin 和zmax 在这种情况下，Kaplanyan建议在更高分辨率的mip水平上继续进行测试。请注意，在单一深度的层次z-buffer中测试2 × 2像素与百分比接近滤波非常相似(章节7.5)。事实上，可以使用带有百分比接近滤波的双线性滤波来完成测试，如果测试返回一个正值，那么至少有一个texel是可见的。</strong></p>
<p><strong>Haar和Altonen也提出了一种双通道方法，它总是至少呈现所有可见物体。首先，针对前一帧的z-金字塔对所有对象进行遮挡剔除，并渲染“可见”对象。或者，可以使用最后一帧的可见性列表直接渲染z-金字塔。虽然这是一个近似值，但所有被渲染的对象都可以作为当前帧的“最佳”遮挡器的最佳猜测，特别是在帧与帧之间具有高相干性的场景中。第二步使用这些渲染对象的深度缓冲并创建一个新的z-金字塔。然后，在第一次通过被遮挡剔除的对象进行遮挡测试，如果没有被遮挡则进行渲染。这种方法生成完全正确的图像，即使相机快速移动或物体在屏幕上快速移动。Kubisch和Tavenrath使用了类似的方法。</strong></p>
<p><strong>Doghramachi和Bucci对前一帧的深度缓冲区进行光栅化，该缓冲区已经向下采样并重新弹出。它们迫使着色器使用early-z(章节23.7)，并且对于每个盒子，可见片段将对象标记为缓冲区中可见的位置，这是由对象ID唯一确定的。这提供了更高的剔除率，因为使用了面向框，并且完成了逐像素测试，而不是使用自定义测试，使用19.5式。</strong></p>
<p><strong>Collin使用256 × 144浮点z缓冲区(非分层)，栅格化艺术家生成的复杂度较低的遮挡器。这可以通过使用CPU或SPUs(在PLAYSTATION 3上)的软件实现，这些软件具有高度优化的SIMD代码。为了执行遮挡测试，计算对象的屏幕空间AABB及其zmin 与小z缓冲区中的所有相关深度进行比较。只有那些在淘汰中存活下来的对象才会被发送到GPU。这种方法可以工作，但不是保守正确的，因为使用的分辨率比最终的帧缓冲区的分辨率低。Wihlidal建议也使用低分辨率的z缓冲区来加载zmax-数值进入GPU的HiZ(章节23.7)，例如，启动AMD GCN上的HTILE结构。或者，如果HZB用于计算通道的剔除，则可以使用z-buffer软件来生成z-金字塔。这样，算法利用软件中生成的所有信息。</strong></p>
<p><strong>Hasselgren等人提出了一种不同的方法，其中每个8 × 4贴图每个像素有一个比特和两个zmax-值，导致每像素3位的总成本。通过使用zmax-值时，可以更好地处理深度间断，因为背景对象可以使用其中一个zmax的值和前景对象使用另一个。这种表示称为掩码层次深度缓冲区(MHDB)，是保守的，也可用于zmax剔除。在软件三角形栅格化过程中，每个tile只生成覆盖掩码和一个最大深度值，这使得栅格化到MHDB快速有效。在对三角形进行栅格化的同时，还可以对三角形进行遮挡测试，从而优化了栅格化器。MDHB会针对每个三角形进行更新，这是其他方法所不具备的优势。评估了两种使用模式。第一种方法是使用特殊的遮挡网格，并使用软件光栅化器将这些网格渲染到MDHB上。然后，遍历掩码上方的AABB树，并针对MDHB进行层次测试。这非常有效，特别是当场景中有许多小物体时。对于第二种方法，整个场景存储在AABB树中，并使用堆大致按照从前到后的顺序遍历场景。在每一步中，对MDHB进行截锥剔除和遮挡查询。每当呈现一个对象时，MDHB也会更新。下图19.19中的场景就是使用这种方法渲染的。开源代码对AVX2进行了大量优化。</strong></p>
<p><strong>还有一些中间件包专门用于剔除，特别是用于遮挡剔除。Umbra就是这样一个框架，它已经被广泛地集成到各种游戏引擎中。</strong></p>
<h2 id="Culling-Systems-剔除系统"><a href="#Culling-Systems-剔除系统" class="headerlink" title="Culling Systems 剔除系统"></a>Culling Systems 剔除系统</h2><p><strong>这些年来，筛选系统已经有了相当大的发展，并将继续这样做。在本节中，我们将描述一些概括性的观点，并指出相关文献的细节。一些系统在GPU的计算着色器中有效地执行所有的剔除，而另一些系统结合了CPU上的粗剔除和GPU上稍后的细剔除。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105205445.png" class="" title="image-20211105205445">

<p>一个在三种不同粒度上工作的筛选系统示例。首先，剔除是在每个对象层面上完成的。然后在每个集群级别剔除幸存的对象。最后进行三角形剔除，如下图所示。</p>
<p><strong>典型的扑杀系统可以在许多粒度上工作，如上图所示。一个对象的一组或一组仅仅是该对象的三角形的子集。例如，可以使用带有64个顶点的三角形条，或者由256个三角形组成的组。在每一个步骤中，都可以使用一系列的剔除技术。El Mansouri使用小三角剔除、细节剔除、视锥剔除和物体遮挡剔除。由于集群在几何上比对象小，所以即使对集群使用相同的剔除技术也是有意义的，因为它们更有可能被剔除。例如，可以在集群上使用细节、截锥、集群背面和遮挡剔除。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211105205601.png" class="" title="image-20211105205601">

<p>三角形剔除系统，其中一组剔除算法首先应用于所有单独的三角形。能够使用间接绘图，即在没有GPU/CPU循环的情况下，幸存的三角形会被压缩成更短的列表。这个列表是由GPU使用间接绘图渲染的。</p>
<p><strong>在每个集群级别进行剔除后，可以执行一个额外的步骤，在每个三角形级别进行剔除。为了让这种情况完全发生在GPU上，可以使用上图所示的方法。三角形的剔除技术包括除以w后的截锥剔除，即将三角形的范围与±1进行比较，背面测试，退化三角形剔除，小三角形剔除，以及可能的遮挡剔除。然后，所有剔除测试后剩下的三角形被压缩到一个最小列表中，这样做是为了在下一个步骤中只处理幸存的三角形。这个想法是为了指导裁剪计算着色器在这个步骤中从GPU发送一个绘制命令给它自己。这是使用间接绘制命令完成的。这些调用在OpenGL中称为“multi-draw indirect”，在DirectX中称为“execute indirect”。将三角形的数量写入GPU缓冲区中的一个位置，并将其与压缩列表一起用于GPU渲染三角形列表。</strong></p>
<p><strong>有很多方法可以将剔除算法与它们执行的地方结合起来，例如，无论是在CPU上还是在GPU上，每种剔除算法也有许多不同的风格。最终的组合还没有找到，但是可以肯定地说，最佳的方法取决于目标体系结构和要呈现的内容。接下来，我们指出了在CPU/GPU剔除系统领域的一些重要工作，这些工作对该领域产生了巨大的影响。Shopf等人在GPU上对角色进行了所有AI模拟，因此，每个角色的位置只能在GPU内存中使用。这导致他们使用计算着色器探索淘汰和LOD管理，大多数系统都受到了他们的工作的严重影响。Haar 和 Aaltonen描述了他们为《刺客信条:大革命》开发的系统。Wihlidal解释了冻伤引擎中使用的筛选系统。Engel提出了一个筛选系统，它可以帮助改进使用可见性缓冲区的管道(章节20.5)。Kubisch和Tavenrath描述了绘制包含大量零件的大规模模型的方法，并使用不同的剔除方法和API调用进行优化。一个值得注意的方法，他们使用遮挡-剔除框是创建一个边界框的可见边使用几何着色器，然后让early-z快速剔除遮挡的几何。</strong></p>
<h2 id="Level-of-Detail-细节层次"><a href="#Level-of-Detail-细节层次" class="headerlink" title="Level of Detail 细节层次"></a>Level of Detail 细节层次</h2><p><strong>细节层次(LODs)的基本思想是使用对象的简单版本，因为它对渲染图像的贡献越来越小。例如，考虑一辆由上百万个三角形组成的小车。当观众靠近汽车时，可以使用这种表示。当物体较远时，比如只覆盖200像素，我们不需要所有的100万个三角形。相反，我们可以使用一个简化的模型，比如说，只有1000个三角形。由于距离的关系，简化版本看起来与更详细的版本大致相同。参见下图。通过这种方式，可以预期显著的性能提高。为了减少应用LOD技术所涉及的总工作量，最好在剔除技术之后应用LOD技术。例如，LOD选择仅对视图截锥内的对象进行计算。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107140951.png" class="" title="image-20211107140951">

<p>在这里，我们展示了C4炸药模型(上)和猎人模型(下)的三个不同的细节层次。元素在较低的细节级别被简化或删除。小的插入图像显示了简化模型的相对尺寸，在它们可能被使用。(上图由Crytek提供;底部排由Valve公司提供)</p>
<p><strong>LOD技术也可以用于使应用程序在一系列具有不同性能的设备上以所需的帧率工作。在速度较慢的系统上，可以使用不太详细的LOD来提高性能。注意，虽然LOD技术首先有助于减少顶点处理，它们还降低了像素阴影的成本。这是因为模型的所有三角形边长的总和将会更低，这意味着四边形的遮挡减少了(章节18.2和23.1)。</strong></p>
<p><strong>第14章描述的Fog和其他参与媒体可以与LODs一起使用。例如，这允许我们完全跳过对象进入完全不透明雾的渲染。此外，雾化机制可以用于实现时间关键的渲染(章节19.9.3)。通过将远平面移动到更接近观察者的地方，更多的对象可以在早期被剔除，从而提高帧率。此外，在雾中通常可以使用较低的LOD。</strong></p>
<p><strong>一些物体，如球体、B´ezier曲面和细分曲面，作为其几何描述的一部分，具有细节层次。底层几何图形是弯曲的，一个独立的LOD控制决定如何将其镶嵌成可显示的三角形。有关适应参数曲面和细分曲面镶嵌质量的算法，请参见17.6.2节。</strong></p>
<p><strong>LOD算法一般由生成、选择和切换三大部分组成。LOD生成是使用不同数量的细节生成模型的不同表示的部分。可以使用第16.5节中讨论的简化方法来生成所需的LOD数量。另一种方法是手工制作带有不同数量三角形的模型。选择机制根据一些标准选择详细程度模型，比如屏幕上估计的面积。最后，我们需要从一个细节级别切换到另一个，这个过程被称为LOD切换。本节将介绍不同的LOD切换和选择机制。</strong></p>
<p><strong>虽然本节的重点是在不同的几何表示中进行选择，但LOD背后的思想也可以应用到模型的其他方面，甚至是使用的渲染方法。较低细节级别的模型也可以使用较低分辨率的纹理，从而进一步节省内存，并可能改善缓存访问。着色器本身可以根据距离、重要性或其他因素进行简化。Kajiya提出了一个比例层次，显示表面光照模型如何重叠纹理映射方法，而纹理映射方法又重叠几何细节。另一项技术是，较少的骨骼可以用于远处物体的剥皮手术。</strong></p>
<p><strong>当静态对象相对较远时，广告牌和视点替用特效(第13.6.4节)是一种自然的方式，以很少的成本来表示它们。其他的表面渲染方法，如凹凸或浮雕映射，可以用来简化模型的表示。下图给出了一个示例。Teixeira讨论了如何使用GPU将法线贴图烘焙到表面上。这种简化技术最明显的缺陷是轮廓失去了曲率。Lovis- cache提出了一种沿轮廓边缘挤压鳍的方法，以产生弯曲的轮廓。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107141243.png" class="" title="image-20211107141243">

<p>在左边，原始模型由150万个三角形组成。在右边，模型有1100个三角形，表面细节存储为高度场纹理，并使用浮雕贴图进行渲染。(图片由ATI研究公司Natalya Tatarchuk提供)</p>
<p><strong>可以用来表示对象的技术范围的一个例子来自于Lengyel等人。在这项研究中，毛皮在非常近的时候用几何图形表示，在较远的时候用阿尔法混合折线表示，然后用阿尔法混合体积纹理“贝壳”，最后在远处通过纹理贴图。参见下图。知道何时以及如何最好地从一套建模和渲染技术切换到另一套，从而最大化帧率和质量仍然是一门艺术，是一个有待探索的开放领域。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107141404.png" class="" title="image-20211107141404">

<p>从远处看，兔子的皮毛是用体积纹理渲染的。当兔子靠近时，毛发就会被阿尔法混合折线渲染。当靠近时，沿着剪影的皮毛被移植的鳍渲染。(图片由微软研究院Jed Lengyel和Michael Cohen提供。)</p>
<h3 id="LOD-Switching-LOD切换"><a href="#LOD-Switching-LOD切换" class="headerlink" title="LOD Switching LOD切换"></a>LOD Switching LOD切换</h3><p><strong>当从一个LOD切换到另一个LOD时，突然的模型替换往往是显而易见的和令人分心的。这种差异被称为“弹出”。这里将描述几种执行这种切换的不同方法，它们都有不同的弹出特性。</strong></p>
<h4 id="Discrete-Geometry-LODs-离散几何的LODs"><a href="#Discrete-Geometry-LODs-离散几何的LODs" class="headerlink" title="Discrete Geometry LODs 离散几何的LODs"></a>Discrete Geometry LODs 离散几何的LODs</h4><p><strong>在LOD算法最简单的类型中，不同的表示是包含不同数量的原语的同一对象的模型。这种算法非常适合现代图形硬件，因为这些单独的静态网格可以存储在GPU内存中并重用(章节16.4.5)。一个更详细的LOD有更多的原语。对象的三个LOD如图19.26和下图所示。第一个图还显示了不同距离的LOD。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107141731.png" class="" title="image-20211107141731">

<p>悬崖的一部分，有三个不同层次的细节，从左到右有72,200,13,719和7,713个三角形。(图片由Quixel Megascans提供。)</p>
<p><strong>从一个LOD切换到另一个LOD是突然的。也就是说，在当前帧上使用某个LOD，然后在下一帧上，选择机制选择另一个LOD并立即使用它进行渲染。弹出通常是这类LOD方法中最糟糕的，但如果切换发生在距离上，当渲染LOD的差异几乎不可见时，它可以工作得很好。下面将介绍更好的替代方案。</strong></p>
<h4 id="Blend-LODs-混合LODs"><a href="#Blend-LODs-混合LODs" class="headerlink" title="Blend LODs 混合LODs"></a>Blend LODs 混合LODs</h4><p><strong>从概念上讲，切换的一种简单方法是在短时间内在两个LODs之间进行线性混合。这样做肯定会使转换更平稳。为一个对象呈现两个LOD自然比仅呈现一个LOD要昂贵得多，因此这在某种程度上违背了LOD的目的。然而，LOD切换通常只会在很短的时间内发生，而且通常不会同时对场景中的所有对象进行切换，所以提高质量可能是值得的。</strong></p>
<p><strong>假设需要在两个LOD(比如LOD1和lod2)之间进行转换，并且LOD1是当前正在呈现的LOD。问题在于如何以合理的方式渲染和混合两个LODs。使两个LODs都是半透明的将导致在屏幕上呈现一个半透明(尽管有点不透明)的对象，这看起来很奇怪。</strong></p>
<p><strong>Giegl和Wimmer提出了一种混合方法，该方法在实践中工作得很好，而且易于实现。首先在framebuffer中不透明地绘制LOD1(包括颜色和z)，然后将LOD2的alpha值从0增加到1，并使用“over”混合模式。当LOD2已经淡入，因此它是完全不透明的，它会变成当前的LOD，然后LOD1会淡出。褪色的LOD (in或out)应该在启用z-test和禁用z-write的情况下呈现。为了避免后期绘制的遥远对象在渲染褪色LOD的结果上绘制，只需按照所有不透明内容之后的顺序绘制所有褪色LOD，就像通常对透明对象所做的那样。注意，在转换的中间，两个lod都是不透明的，一个在另一个上面。如果转换间隔很短，这种技术效果最好，这也有助于保持较小的渲染开销。Mittring讨论了一种类似的方法，除了screen-door透明度(可能在亚像素级)用于溶解版本之间。</strong></p>
<p><strong>Scherzer和Wimmer通过在每一帧上只更新一个LOD并重用前一帧的另一个LOD来避免渲染两个LOD。前一帧的反投影与使用可见纹理的组合通道一起执行。更快的渲染和更好的转换是主要的结果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107142106.png" class="" title="image-20211107142106">

<p>树枝(和它们的叶子，没有显示)会收缩，然后随着观察者离开树模型而移除。(图片由SpeedTree提供。)</p>
<p><strong>有些对象适合使用其他转换技术。例如，SpeedTree包平滑地移动或缩放其树LOD模型的部分，以避免pop。如上图所示。一组LOD如下图所示，以及用于远处树木的广告牌LOD技术。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107142122.png" class="" title="image-20211107142122">

<p>树LOD模型，近到远。当树在远处时，它会被一组广告牌中的一个所代表，如图所示。每个广告牌都是从不同的角度渲染树，由颜色和法线贴图组成。选择最面向观众的广告牌。实际上形成了8到12个广告牌(这里显示了6个)，透明部分被修剪掉，以避免浪费时间丢弃完全透明的像素(章节13.6.2)。(图片由SpeedTree提供。)</p>
<h4 id="Alpha-LODs-阿尔法LODs"><a href="#Alpha-LODs-阿尔法LODs" class="headerlink" title="Alpha LODs 阿尔法LODs"></a>Alpha LODs 阿尔法LODs</h4><p><strong>避免突然弹出的一个简单方法是使用我们称为alpha LOD的方法。这种技术可以单独使用，也可以与其他LOD切换技术结合使用。它用于最简单的可见LOD，如果只有一个LOD可用，则可以是原始模型。当用于LOD选择的度量(例如，到这个对象的距离)增加时，对象的整体透明度增加(α减少)，当它达到完全透明(α = 0.0)时，对象最终消失。发生这种情况当度量值大于用户定义的不可见阈值时。当达到不可见阈值时，只要度量值保持在阈值以上，对象就不需要通过渲染管道发送。当一个物体已经不可见，并且它的指标低于不可见阈值时，它的透明度就会降低，并重新开始可见。另一种方法是使用第19.9.2节中描述的迟滞法。</strong></p>
<p><strong>单独使用这种技术的好处是，它比离散几何LOD方法更连续，因此避免了弹出。此外，由于对象最终完全消失，不需要渲染，可以预期一个显著的加速。缺点是对象完全消失，只有在这一点上才能获得性能的提高。下图显示了alpha LOD的一个示例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107142546.png" class="" title="image-20211107142546">

<p>中间的圆锥体使用alpha LOD渲染。圆锥的透明度随着距离的增加而增加，最终消失。左边的图像从相同的距离显示，以方便查看，而右边的图像以不同的尺寸显示。</p>
<p><strong>使用alpha透明度的一个问题是，需要按深度排序，以确保透明对象正确混合。为了淡化远处的植被，Whatley讨论了如何使用噪声纹理来提高屏风门的透明度。这有一个溶解的效果，随着距离的增加物体上更多的像素消失。虽然质量不如真正的阿尔法淡出，屏幕门的透明度意味着没有分类或混合是必要的。</strong></p>
<h4 id="CLODs-and-Geomorph-LODs-CLODs-和-地形LODs"><a href="#CLODs-and-Geomorph-LODs-CLODs-和-地形LODs" class="headerlink" title="CLODs and Geomorph LODs CLODs 和 地形LODs"></a>CLODs and Geomorph LODs CLODs 和 地形LODs</h4><p><strong>网格简化过程可用于从单个复杂对象创建各种LOD模型。执行这种简化的算法将在第16.5.1节中讨论。一种方法是创建一组离散LOD，并像前面讨论的那样使用它们。然而，边缘折叠方法有一个属性，允许其他方式在LOD之间进行转换。在这里，我们提出两种利用这些信息的方法。这些是有用的背景，但目前很少在实践中使用。</strong></p>
<p><strong>一个模型每执行一次边折叠操作后，会少两个三角形。在边折叠中，边会收缩直到它的两个端点相遇，然后消失。如果这个过程是动画的，那么在原始模型和稍微简化的模型之间就会发生平滑的过渡。对于每条边的折叠，一个顶点与另一个顶点连接在一起。在一系列的边缘折叠过程中，一组顶点移动到其他顶点之间。通过存储一系列折叠的边缘，这个过程可以被逆转，因此一个简化的模型可以随着时间的推移变得更加复杂。边缘折叠的反转称为顶点分裂。因此，改变对象细节级别的一种方法是精确地以LOD选择值上可见的三角形数量为基础。在100米之外，模型可能由1000个三角形组成，移动到101米，它可能会下降到998个三角形。这种方案称为连续细节级别(CLOD)技术。因此，可供展示的模型并不是一组离散的模型，而是一组巨大的模型，每一个模型都比它更复杂的邻居少两个三角形。</strong></p>
<p><strong>虽然很吸引人，但在实践中使用这样的方案也有一些缺点。并非CLOD流中的所有模型看起来都很好。三角形网格的渲染速度比单个三角形要快得多，使用CLOD技术比使用静态模型要困难得多。如果场景中有多个相同对象的实例，那么每个CLOD对象都需要指定自己特定的三角形集合，因为它不匹配任何其他对象。Forsyth讨论了这些问题和其他问题的解决方案。虽然大多数CLOD技术在本质上是相当串行的，但它们并不适合在GPU上实现。因此，Hu等人提出了一种更适合GPU并行特性的CLOD修改。他们的技术也依赖于视图，因为如果一个物体与视图截锥的左侧相交，截锥外可以使用更少的三角形，连接到内部密度更高的网格。</strong></p>
<p><strong>在顶点分割中，一个顶点变成两个。这意味着一个复杂模型上的每个顶点都来自于一个简单模型上的某个顶点。地形LOD是一组通过简化而建立的离散模型，保持顶点之间的连通性。当从一个复杂模型切换到一个简单模型时，复杂模型的顶点被插入到它们的原始位置和那些简单模型的顶点之间。当转换完成时，将使用更简单的细节级别模型来表示对象。参见下图以获得一个转换示例。地貌有几个优点。为了保证模型的质量，可以提前选择单独的静态模型，并且可以很容易地转换成三角形网格。与CLOD一样，通过平滑过渡也可以避免弹出。主要的缺点是每个顶点都需要插值;CLOD技术通常不使用插值，因此顶点位置集本身不会改变。另一个缺点是，物体似乎总是在变化，这可能会分散注意力。对于纹理对象尤其如此。Sander和Mitchell描述了一个系统，其中地貌与静态的、GPU驻留的顶点和索引缓冲区结合使用。也可以将Mittring(如上所述)的屏蔽门透明度与地貌相结合，以实现更平滑的过渡。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107144703.png" class="" title="image-20211107144703">

<p>左边和右边的图像显示了一个低细节模型和一个高细节模型。中间的图像显示了在左右模型中间插入的地貌模型。注意，中间的奶牛和右边的模型有同样多的顶点和三角形。(使用Melax的“Polychop”简化演示生成的图像。)</p>
<p><strong>GPU支持一种被称为小数镶嵌的相关思想。在这种方案中，曲面的镶嵌因子可以设置为任意的浮点数，从而避免了弹出。例如，分数阶镶嵌可以用于B´ezier补丁和位移映射原语。有关这些技术的更多信息，请参见17.6.1节。</strong></p>
<h3 id="LOD-Selection-LOD选择"><a href="#LOD-Selection-LOD选择" class="headerlink" title="LOD Selection LOD选择"></a>LOD Selection LOD选择</h3><p><strong>考虑到一个对象存在不同的细节级别，必须选择渲染哪个，或者混合哪个。这是LOD选择的任务，这里将介绍一些不同的技术。这些技术也可以用于选择好的遮挡剔除算法。</strong></p>
<p><strong>通常，一个指标(也称为受益函数)会根据当前的视点和对象的位置进行评估，这个指标的值会选择一个适当的LOD。这个度量可能基于，例如，物体的边界体积的投影面积或从视点到物体的距离。收益函数的值在这里用r表示。参见17.6.2节如何快速估计直线在屏幕上的投影。</strong></p>
<h4 id="Range-Based-基于范围"><a href="#Range-Based-基于范围" class="headerlink" title="Range-Based 基于范围"></a>Range-Based 基于范围</h4><p><strong>选择LOD的常用方法是将对象的不同LOD与不同的距离范围相关联。最详细的LOD范围从零到一些用户定义的值r1，这意味着当到物体的距离小于r1时，LOD是可见的．下一个LOD的范围从r1到r2 其中r2 &gt; r1．如果到物体的距离大于等于r1 并且小于r2，则使用此LOD，以此类推。下图给出了四种不同LOD及其范围的示例，以及在场景图中使用的相应LOD节点。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107145420.png" class="" title="image-20211107145420">

<p>图的左侧显示了基于范围的lod是如何工作的。注意，第四个LOD是一个空对象，所以当对象距离r3更远时，什么也不会画出来，因为对象对图像的贡献不够大，不值得这样做。右边部分显示了场景图中的LOD节点。LOD节点中只有一个子节点是基于r下行的。</p>
<p><strong>如果用于确定要使用哪个LOD的度量在不同帧之间围绕某个值r而变化，就会发生不必要的弹出i．关卡之间可能会出现快速循环。这可以通过在ri附近引入一些滞后来解决。下图显示了基于范围的LOD，但适用于任何类型。这里，LOD范围的上一行仅在r增加时使用。当r减小时，使用范围的底部行。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107145541.png" class="" title="image-20211107145541">

<p>彩色区域表示LOD技术的滞后区域。</p>
<p><strong>在过渡范围内混合两个LODs如下图所示。然而，这不是理想的，因为对象的距离可能停留在过渡范围很长一段时间，这增加了渲染的负担，因为混合两个LODs。相反，Mittring在有限的时间内，当对象达到一定的过渡范围时，执行LOD切换。为了获得最好的结果，这应该与上面的迟滞方法相结合。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107145644.png" class="" title="image-20211107145644">

<p>彩色区域说明了在两个最近的LOD之间进行混合的范围，其中b01表示在LOD0和LOD1之间进行混合，而LODk表示只有LODk在相应的范围内进行渲染。</p>
<h4 id="Projected-Area-Based-基于投影面积"><a href="#Projected-Area-Based-基于投影面积" class="headerlink" title="Projected Area-Based 基于投影面积"></a>Projected Area-Based 基于投影面积</h4><p><strong>另一个用于LOD选择的常见度量是边界体的投影面积，或者它的估计。这里，我们将展示它的像素数面积，称为屏幕空间覆盖，可以估计球体和盒子的透视视图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107150304.png" class="" title="image-20211107150304">

<p>这张图显示了当距离增加一倍时，没有任何厚度的物体的投影大小减半。</p>
<p><strong>从球体开始，这个估计是基于这样一个事实，即物体的投影尺寸随着与观察者的距离沿观察方向的减小而减小。如上图所示，它说明了如果距离观众的距离加倍，投影的大小就会减半，这对于面向观众的平面物体来说也是如此。我们通过球的中心点c和半径r来定义一个球。观察者沿着标准化方向向量d位于v处。沿着视图方向从c到v的距离就是球的中心在视图向量上的投影:d·(v−c).我们还假设从观看者到视锥近平面的距离为n。近平面用于估计，以便位于近平面上的物体返回其原始尺寸。然后估计出投影球面的半径</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107150356.png" class="" title="image-20211107150356">

<p><strong>投影的像素面积为πp²wh，其中w×h为屏幕分辨率。较高的值选择更详细的LOD。这是近似值。事实上,三维球体的投影是椭圆，如Mara和McGuire所示。他们还导出了一种计算保守边界多边形的方法，即使在球面与近平面相交的情况下。</strong></p>
<p><strong>通常的做法是简单地在对象的边界框周围使用一个边界球。另一个估计是使用边界框的屏幕边界。然而，薄的或平的物体在实际覆盖的投影面积上可以有相当大的变化。例如，想象一根意大利面条的一端在屏幕的左上角，另一端在右下角。它的边界球体将覆盖屏幕，它的边界框的最小和最大二维屏幕边界也是如此。</strong></p>
<p><strong>Schmalstieg和Tobler提出了一种快速计算方框投影面积的程序。这个想法是将相机的视点相对于盒子进行分类，并使用这个分类来确定哪些投影顶点包含在投影盒子的剪影中。这个过程是通过查找表完成的。使用这些顶点，可以计算视图中的面积。分类分为三个主要的案例，如下图所示。实际上，这种分类是通过确定视点位于边界框平面的哪一边来完成的。为了提高效率，将视点转换为方框的坐标系，只需要比较即可进行分类。比较的结果被放入位掩码中，该位掩码用作LUT的索引。这个LUT决定了从视点看到的轮廓中有多少个顶点。然后，使用另一个查找来实际找到轮廓顶点。当它们被投影到屏幕上后，轮廓的面积就被计算出来了。为了避免(有时剧烈的)估计错误，有必要将形成的多边形裁剪到视图截锥的侧面。源代码可以在网上找到。Lengyel对该方案进行了优化，可以使用更紧凑的LUT。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107150537.png" class="" title="image-20211107150537">

<p>立方体投影的三个例子，显示(从左到右)一个，两个，三个正面。轮廓线分别由4个、6个和6个顶点组成，每个轮廓线的面积将针对所形成的每个多边形进行计算。(参考Schmalstieg和Tobler的插图。)</p>
<p><strong>仅仅根据距离或投影来选择LOD并不总是一个好主意。例如，如果一个物体有一个AABB，其中有一些大三角形和一些小三角形，那么小三角形可能会混淆严重，并由于四边形遮挡而降低性能。如果另一个物体具有完全相同的AABB，但带有介质以及其中的大三角形，那么基于距离和基于投影的选择方法都会选择相同的LOD。为了避免这种情况，Schulz和Mader使用几何平均值g来帮助选择LOD:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107150635.png" class="" title="image-20211107150635">

<p><strong>其中ti是物体的三角形的大小。使用几何平均值而不是算术平均值的原因是，即使有几个大三角形，许多小三角形也会使g变小。对于最高分辨率的模型，该值是离线计算的，并用于预先计算第一个开关应该发生的距离。随后的开关距离是第一个距离的简单函数。这允许他们的系统更频繁地使用低LODs，从而提高性能。</strong></p>
<p><strong>另一种方法是计算每个离散LOD的几何误差。估计简化后的模型与原始模型最多偏离多少米。然后可以投影这个距离，以确定屏幕空间中使用LOD的效果。然后选择最低的LOD(也满足用户定义的屏幕空间错误)。</strong></p>
<h4 id="Other-Selection-Methods-其他的选择方法"><a href="#Other-Selection-Methods-其他的选择方法" class="headerlink" title="Other Selection Methods 其他的选择方法"></a>Other Selection Methods 其他的选择方法</h4><p><strong>基于范围和基于投影区域的LOD选择通常是最常用的度量。然而，还有许多其他的可能性，我们将在这里提到一些。除了投影面积，Funkhouser和S´equin还建议使用物体的重要性(例如，墙壁比墙上的时钟更重要)、运动、迟滞(切换LOD时，好处降低)和聚焦。最后一点，观众的注意力焦点，可能是一个重要因素。例如，在体育游戏中，控制球的人物是用户最关注的地方，所以其他角色的细节级别相对较低。类似地，当在虚拟现实应用程序中使用眼球追踪时，应该在观察者看到的地方使用更高的LOD。</strong></p>
<p><strong>根据应用程序的不同，其他策略也可能是有效的。可以使用整体能见度，例如，通过浓密的树叶看到的附近的物体可以用较低的LOD渲染。更多的全局度量是可能的，例如限制使用的高度详细LOD的总体数量，以保持在给定的三角形预算之内。有关这个主题的更多信息，请参阅下一节。其他因素包括能见度、颜色和纹理。感知指标也可以用来选择LOD。</strong></p>
<p><strong>McAuley提出了一个植被系统，其中树干和叶子集群在成为视点之前有三个LODs。他从不同的角度和不同的距离对每个对象的簇之间的可见性进行预处理。由于树后面的集群可能被更近的集群完全隐藏，因此即使树很近，也可以为这样的集群选择较低的LOD。对于草地渲染，通常使用靠近观察者的几何图形，广告牌稍微远一点，以及在显著距离上使用简单的地面纹理。</strong></p>
<h3 id="Time-Critical-LOD-Rendering-时间关键的LOD渲染"><a href="#Time-Critical-LOD-Rendering-时间关键的LOD渲染" class="headerlink" title="Time-Critical LOD Rendering 时间关键的LOD渲染"></a>Time-Critical LOD Rendering 时间关键的LOD渲染</h3><p><strong>一个渲染系统通常需要一个恒定的帧率。事实上，这就是所谓的“硬实时”或时间关键渲染。这样的系统被赋予了一个特定的时间量，比如16毫秒，并且必须在这个时间内完成它的任务(例如，渲染图像)。当时间到了，系统必须停止处理。如果场景中的物体由LOD表示，那么硬实时渲染系统将能够在每一帧向用户展示更多或全部场景，而不是在分配的时间内只绘制几个非常详细的模型。</strong></p>
<p><strong>Funkhouser和S´equin提出了一种启发式算法，该算法对场景中所有可见物体的细节级别进行选择，以满足恒定帧率的要求。该算法是预测性的，它选择的LOD可见对象的基础上的期望帧率和对象是可见的。这种算法与反应式算法形成对比，后者基于渲染前一帧所花费的时间进行选择。</strong></p>
<p><strong>一个对象被称为O，并在一个名为L的细节级别上呈现，它为对象的每个LOD给出(O, L)。然后定义了两个启发式。一种启发式方法估计在特定细节水平上渲染对象的成本:Cost (O, L)。另一种方法估计在特定细节水平上渲染对象的效益:Benefit (O, L)。效益函数估计在特定LOD上对对象图像的贡献。</strong></p>
<p><strong>假设在视图截锥内或相交的对象被称为S，算法背后的主要思想是使用启发式选择函数优化对象S的LODs选择。具体来说，我们想要最大化</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107151336.png" class="" title="image-20211107151336">

<p><strong>约束条件下</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107151346.png" class="" title="image-20211107151346">

<p><strong>其中T是目标帧时间。</strong></p>
<p><strong>换句话说，我们想要为对象选择在理想的帧率内提供“最佳图像”的细节级别。然后我们描述了成本和效益函数的估计方法，并给出了上述方程的优化算法。</strong></p>
<p><strong>成本函数和效益函数都很难定义，所以它们在所有情况下都能工作。成本函数可以通过用不同的观看参数对LOD的渲染进行多次计时来估计。有关不同的利益函数，请参见第19.9.2节。在实践中，对象的BV的投影面积可以作为一个效益函数。</strong></p>
<p><strong>最后，我们将讨论如何为场景中的对象选择细节级别。首先，我们注意到以下几点:对于某些视点，场景可能过于复杂而无法跟上所需的帧率。为了解决这个问题，我们可以定义一个LOD每个对象在其最低细节级别，这只是一个没有原语的对象——即我们避免渲染对象-。使用这个技巧，我们只渲染最重要的对象，而忽略不重要的对象。</strong></p>
<p><strong>为了为一个场景选择“最佳”LOD，需要在如式19.9所示的约束条件下对式19.8进行优化。这是一个NP—完全问题，这意味着要正确地解决它，唯一要做的就是测试所有不同的组合，并选择最好的。这对任何算法来说都是不可行的。一种更简单、更可行的方法是使用贪婪算法，试图最大化每个对象Value = Benefit(O, L)/Cost(O, L)。该算法处理视图截屏内的所有对象，并选择按降序渲染对象，即也就是值最高的那个。如果一个对象在多个LOD中具有相同的值，则选择效益最高的LOD进行渲染。这种方法最能“物有所值”。“对于视图截屏内的n个对象，算法运行时间为O(n log n)，它产生的解决方案至少是最好的一半。也可以利用帧对帧的一致性来加快值的排序。</strong></p>
<p><strong>关于LOD管理以及LOD管理与门户筛选结合的更多信息可以在Funkhouser的博士论文中找到。Maciel和Shirley结合LOD和视点替用特效，提出了一种近似恒定时间的室外场景渲染算法。一般的想法是使用对象的不同表示的层次结构(例如，一组LOD和分层视点替用器)。然后以某种方式遍历树，给出给定时间内的最佳图像。Mason和Blake提出了一种增量层次LOD选择算法。同样，对象的不同表示可以是任意的。Eriksson等人提出了层次细节层次(HLODs)。使用这些，场景也可以用恒定的帧率渲染，或者渲染到渲染错误是有限的。与此相关的是功率预算。Wang等人提出了一个优化框架，选择好的参数来降低功耗，这对手机和平板电脑很重要。</strong></p>
<p><strong>与时间关键渲染相关的是另一组适用于静态模型的技术。当相机不移动时，整个模型被渲染，累积缓冲可以用于抗锯齿、景深和软阴影，并进行渐进式更新。而当相机移动时，可以降低所有物体的细节水平，并使用细节剔除来完全剔除小物体，以满足一定的帧率。</strong></p>
<h2 id="Rendering-Large-Scenes-渲染大场景"><a href="#Rendering-Large-Scenes-渲染大场景" class="headerlink" title="Rendering Large Scenes 渲染大场景"></a>Rendering Large Scenes 渲染大场景</h2><p><strong>到目前为止，已经暗示要渲染的场景适合装入计算机的主存储器。情况可能并不总是如此。例如，一些主机只有8GB的内存，而一些游戏世界可以包含数百GB的数据。因此，我们提出了流和转码的方法纹理，一些通用的流技术，最后是地形渲染算法。请注意，这些方法几乎总是与剔除技术和详细程度方法相结合，本章前面已经描述过了。</strong></p>
<h3 id="Virtual-Texturing-and-Streaming-虚拟纹理和流"><a href="#Virtual-Texturing-and-Streaming-虚拟纹理和流" class="headerlink" title="Virtual Texturing and Streaming 虚拟纹理和流"></a>Virtual Texturing and Streaming 虚拟纹理和流</h3><p><strong>想象一下，你想要使用一个分辨率非常高的纹理来渲染一个巨大的地形数据集，而这个纹理太大了，无法放入GPU内存中。例如，《RAGE》中的一些虚拟纹理的分辨率为128k×128k，这将消耗64 GB的GPU内存。当CPU上的内存有限时，操作系统使用虚拟内存进行内存管理，根据需要将数据从驱动器交换到CPU内存。这种功能正是稀疏纹理所提供的，它使得分配巨大的虚拟纹理成为可能，也被称为megatexture。这些技术有时被称为虚拟纹理或部分驻留纹理。应用程序决定每个mipmap级别的哪些区域(瓷砖)应该驻留在GPU内存中。一个贴图通常是64 kB，它的纹理分辨率取决于纹理格式。在这里，我们介绍了虚拟纹理和流技术。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107172359.png" class="" title="image-20211107172359">

<p>在虚拟纹理中，一个具有mipmap层次结构的大型虚拟纹理被划分为每个128 × 128像素的tiles(左图)。只有一小部分(在这个例子中是3 × 3的贴图)能够容纳物理内存(右)。为了找到虚拟纹理贴图的位置，需要从虚拟地址转换到物理地址，这是通过页表完成的。注意，为了减少混乱，并不是物理内存中的所有贴图都有来自虚拟纹理的箭头。(伊朗巴斯曼火山的图像纹理。来自NASA的“可见地球”项目。)</p>
<p><strong>关于使用mipmapping的高效纹理系统的关键观察是，理想情况下所需的像素数应该与最终渲染图像的分辨率成正比，而不依赖于纹理本身的分辨率。因此，我们只要求物理GPU内存中可见的像素，与整个游戏世界中的所有像素相比，这是一个相当有限的集合。主要的概念如上图所示，其中整个mipmap链被划分为虚拟内存和物理内存中的tiles。这些结构有时被称为虚拟mipmaps或clipmaps，后者指的是较大的mipmap中的一小部分被剪掉以供使用。由于物理内存的大小比虚拟内存小得多，只有一小部分虚拟纹理块可以装入物理内存。几何图形使用全局uv参数化到虚拟纹理中，并且在像素着色器中使用这些uv坐标之前，它们需要被转换为纹理坐标，指向物理纹理内存。这是使用GPU支持的页面表(如上图所示)或间接纹理完成的，如果在GPU上的软件中完成。任天堂GameCube的GPU支持虚拟纹理。最近，PLAYSTATION 4、Xbox One和许多其他GPU都支持硬件虚拟纹理。当贴图映射和未映射到物理内存时，间接纹理需要用正确的偏移量进行更新。使用一个巨大的虚拟纹理和一个小的物理纹理效果很好，因为远处的几何图形只需要加载一些高级的mipmap贴图到物理内存中，而靠近相机的几何图形可以加载一些低级的mipmap贴图。注意，虚拟纹理可以用于流从磁盘的巨大纹理，但也用于稀疏的阴影映射，例如。</strong></p>
<p><strong>由于物理内存有限，所有使用虚拟纹理的引擎都需要一种方法来确定哪些贴图应该驻留。，位于物理内存中。有几种这样的方法。Sugden和Iwanicki使用了一种反馈渲染方法，在第一个渲染通道中写下所有需要的信息，以知道碎片将访问哪个纹理贴图。当传递完成时，纹理被读回CPU并分析哪些贴图是需要的。不驻留的瓦片被读取并映射到物理内存，物理内存中不需要的瓦片被取消映射。他们的方法不适用于阴影、反射和透明度。然而，屏蔽门技术(第5.5节)可以用于透明效果，效果相当好。van Waveren和Hart也使用了反馈渲染。注意，这样的通道可以是一个单独的渲染通道，也可以与z- preass结合使用。当使用单独的通道时，可以使用只有80 × 60像素的分辨率作为近似，以减少处理时间。Hollemeersch等人使用计算通道而不是将反馈缓冲区读入CPU。结果是在GPU上创建一个紧凑的平铺标识符列表，并发送回CPU进行映射。</strong></p>
<p><strong>在GPU支持的虚拟纹理中，驱动程序负责创建和销毁资源，映射和取消贴图，并确保物理分配得到虚拟分配的支持。对于GPU硬件虚拟纹理，sparseTexture查找除了返回过滤后的值(用于常驻贴图)外，还返回一个代码，指示对应的贴图是否常驻。有了软件支持的虚拟纹理，所有这些任务都由开发者来完成。我们参考van Waveren的报告了解更多关于这个主题的信息。</strong></p>
<p><strong>为了确保所有内容都适合物理内存，van Waveren调整全局纹理LOD偏差，直到工作集适合。此外，当只有更高级别的mipmap块可用时，就需要使用更高级别的mipmap块，直到更低级别的mipmap块可用为止。在这种情况下，更高级别的mipmap贴图可以立即升级并使用，然后新的贴图可以随着时间的推移混合在一起，以便在它变得可用时实现平滑过渡。</strong></p>
<p><strong>Barb相反，总是加载所有小于或等于64kb的纹理，因此，一些纹理总是可以完成的，尽管如果还没有加载更高分辨率的mipmap级别，质量会更低。他使用离线反馈渲染来预计算，对于不同的位置，在名义纹理和屏幕分辨率下，每个mipmap级别覆盖了每个材质在玩家周围的多少立体角度。在运行时，这些信息被输入，并根据每种材质的纹理分辨率和最终屏幕分辨率进行调整。这将产生每个纹理、每个mipmap的重要值。然后将每个重要值除以对应的mipmap级别的像素数，生成一个合理的最终度量，因为它是不变的，即使一个纹理被细分为更小的、相同的映射纹理。更多信息请参见Barb的介绍。下图显示了一个示例渲染。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107172752.png" class="" title="image-20211107172752">

<p>在《毁灭战士》(2016)中使用纹理流访问巨大的图像数据库的高分辨率纹理映射。(图片来自游戏《毁灭战士》，由id Software提供)</p>
<p><strong>Widmark描述了如何将流与过程纹理生成相结合，以获得更多样化和更详细的纹理。Chen扩展了Widmark的方案来处理更大数量级的纹理。</strong></p>
<h3 id="Texture-Transcoding-纹理转码"><a href="#Texture-Transcoding-纹理转码" class="headerlink" title="Texture Transcoding 纹理转码"></a>Texture Transcoding 纹理转码</h3><img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107172949.png" class="" title="image-20211107172949">

<p>一个使用带有转码的虚拟纹理的纹理流系统。(van Waveren和Hart的插图。)</p>
<p><strong>为了使虚拟纹理系统工作得更好，可以将其与转码结合起来。这是一个从磁盘读取通常使用可变速率压缩方案(如JPEG)压缩的图像，对其进行解码，然后使用GPU支持的纹理压缩方案之一对其进行编码的过程(章节6.2.6)。上图展示了一个这样的系统。反馈渲染通道的目的是确定当前帧需要哪些贴图，章节19.10.1中描述的任何一种方法都可以在这里使用。取取步骤通过存储层次获取数据，从光存储或硬盘驱动器(HDD)，通过一个可选的磁盘缓存，然后通过一个由软件管理的内存缓存。Unmapping指的是释放常驻贴图。当新的数据被读取时，它被转换编码并最终映射到一个新的常驻tile。</strong></p>
<p><strong>使用转码的优点是当纹理数据存储在磁盘上时可以使用更高的压缩比，并且当通过纹理采样器访问纹理数据时使用GPU支持的纹理压缩格式。这既需要对可变速率压缩格式进行快速解压缩，也需要快速压缩到GPU支持的格式。也可以对已经压缩的纹理进行压缩以进一步减小文件大小。这种方法的优点是，当纹理从磁盘读取并解压缩时，它已经是GPU可以使用的纹理压缩格式。使用免费源代码的crunch库使用了类似的方法，结果为每像素1-2位。参见下图中的示例。其继承者称为基，是一种对块具有可变位压缩的专有格式，它可以快速地转换为纹理压缩格式。对于BC1/BC4、BC6H/BC7和PVRTC， GPU上的快速压缩方法是可用的。Sugden和Iwanicki使用Malvar压缩方案的变体来实现磁盘上的可变速率压缩方案。对于法线，他们达到40:1压缩-对于反照率纹理60:1使用YCoCg变换(在第197页的公式6.6中描述)。Khronos正在开发一种用于纹理的标准通用压缩文件格式。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107173125.png" class="" title="image-20211107173125">

<p>转码质量的说明。从左到右:原始的部分鹦鹉图像、眼睛放大后的原始图像(每像素24位)、ETC压缩图像(每像素4位)和压缩后的ETC图像(每像素1.21位)。(图片由Unity压缩。)</p>
<p><strong>当需要高纹理质量且纹理加载时间需要很小时，Olano等人使用可变速率压缩算法将压缩纹理存储在磁盘上。纹理也会在GPU内存中被压缩，直到它们被需要，这时GPU会使用自己的算法来解压缩它们，之后，它们就会以未压缩的形式被使用。</strong></p>
<h3 id="General-Streaming-通用流"><a href="#General-Streaming-通用流" class="headerlink" title="General Streaming 通用流"></a>General Streaming 通用流</h3><p><strong>例如，在模型比物理内存大的游戏或其他实时渲染应用程序中，实际几何体、脚本、粒子和AI也需要流系统。平面可以通过使用三角形、正方形或六边形的正凸多边形进行平铺。因此，这些也是流系统的常见构建块，其中每个多边形都与该多边形中的所有资产相关联。如下图所示。需要注意的是，正方形和六边形最常用，可能是因为它们的近邻比三角形少。查看器位于下图中的深蓝色多边形中，流系统确保直接邻居(浅蓝色和绿色)被加载到内存中。这是为了确保周围的几何图形是可渲染的，并确保当观察者移动到邻近的多边形时数据是存在的。注意，三角形和正方形有两种邻居:一种共享一条边，另一种只共享一个顶点。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107175453.png" class="" title="image-20211107175453">

<p>使用三角形(左)、正方形(中)和六边形(右)的正多边形对二维平面进行平铺。从上方看，贴图通常覆盖在游戏世界上，多边形内的所有资产都与该多边形相关联。假设查看器位于深蓝色的多边形中，相邻的多边形的资源也会被加载。</p>
<p><strong>Ruskin使用六边形，每个六边形都有一个低和高分辨率的几何LOD。由于低分辨率LOD的内存占用很小，所以整个世界的低分辨率LOD都一直在加载。因此，只有高分辨率的LOD和纹理会进出内存。Bentley使用正方形，每个正方形占地100 × 100平方米。高分辨率的mipmaps与其他资产分离。这个系统使用1-3 LODs用于近中距离观看，然后烘培视点替用用于远距离观看。至于赛车游戏，泰克多代替了它随着赛车前进，沿着赛道装载数据。他将使用zip格式压缩的数据存储在磁盘上，并将数据块加载到压缩的软件缓存中。然后根据需要将块解压缩，并由CPU和GPU的内存层次结构使用。</strong></p>
<p><strong>在某些应用中，可能需要平铺三维空间，而不是像上面描述的那样仅仅使用二维平铺。请注意，立方体是唯一的正多面体，也瓷砖三维空间，所以它是这样的应用程序的自然选择。</strong></p>
<h3 id="Terrain-Rendering-地形渲染"><a href="#Terrain-Rendering-地形渲染" class="headerlink" title="Terrain Rendering 地形渲染"></a>Terrain Rendering 地形渲染</h3><p><strong>地形渲染是许多游戏和应用的重要组成部分，例如谷歌Earth和Cesium的大型世界渲染开源引擎。下图显示了一个示例。我们描述了几种在当前GPU上表现良好的流行方法。需要注意的是，这些都可以添加分形噪声，以便在放大地形时提供高水平的细节。此外，许多系统会在加载游戏或关卡时自动生成地形。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107180239.png" class="" title="image-20211107180239">

<p>由航空摄影测量拍摄的钱伯林山50厘米地形和25厘米图像。(图片由Cesium和Fairbanks Fodar提供。)</p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107180346.png" class="" title="image-20211107180346">

<p>左:几何剪贴图结构，在每个分辨率级别缓存一个大小相等的正方形窗口。右图:几何图形的俯视图，观察者在中间紫色区域。注意，最精细的关卡渲染整个正方形，而其他关卡则是中空的。(Asirvatham和Hoppe的插图。)</p>
<p><strong>其中一种方法是几何剪贴图。它与texture clipmaps相似，使用了与mipmapping相关的层次结构，即几何体被过滤成一个由越来越粗糙的层次组成的金字塔。如上图所示。在绘制庞大的地形数据集时，只有n × n个样本，即高度，缓存在内存中为查看器周围的每一层。当查看器移动时，上图中的窗口会相应地移动，并加载新的数据，旧的数据可能会被移除。为了避免水平之间的裂缝，每两个连续水平之间使用一个过渡区域。在这样一个过渡级别中，几何和纹理都被平滑地插值到下一个粗糙级别中。这在顶点和像素着色器中实现。Asirvatham和Hoppe提出了一种高效的GPU实现，其中地形数据存储为顶点纹理。顶点着色器访问这些以获得地形的高度。普通地图用于增强地形上的视觉细节，当近距离放大时，Losasso和Hoppe还添加了分形噪声位移以获得进一步的细节。参见下图中的示例。Gollent在《巫师3》中使用了一种几何剪贴图的变体。Pangerl和Torchelsen等人给出了几何剪贴图的相关方法，这些方法也非常适合GPU的能力。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107180457.png" class="" title="image-20211107180457">

<p>几何clipmapping。左:线框渲染，不同的mipmap层次清晰可见。右图:蓝色过渡区域表示水平之间发生插值。(使用微软的“使用几何剪贴图渲染地形”程序生成的图像。)</p>
<p><strong>有几个方案专注于创建tiles和渲染它们。一种方法是将高度场数组分解为每个17 × 17个顶点的tiles。对于一个非常详细的视图，可以渲染一个瓷砖，而不是向GPU发送单独的三角形或小扇子。一个贴图可以有多个细节层次。例如，在每个方向上只使用其他顶点，就可以形成一个9×9贴图。使用第四个顶点得到一个5 × 5的贴图，每8个顶点得到一个2 × 2的贴图，最后四个角得到一个由两个三角形组成的1 × 1的贴图。需要注意的是，原来的17 × 17顶点缓冲区可以存储在GPU上并重复使用;只需要提供不同的索引缓冲区来更改呈现的三角形的数量。接下来介绍一种使用此数据布局的方法。</strong></p>
<p><strong>另一种在GPU上快速绘制大型地形的方法叫做分块LOD。这个想法是使用n个离散的细节层次来表示地形，其中每个更细的LOD与其父LOD相比被分割4倍，如下图所示。然后将该结构编码到四叉树中，并从根遍历以进行呈现。当一个节点被访问时，如果它的屏幕空间错误(将在下面的描述)低于某个像素错误阈值τ，它将被渲染。否则，将递归访问四个子节点。这将在需要的地方产生更好的分辨率，例如，靠近查看器。在一个更高级的变体中，地形四元根据需要从磁盘加载。遍历与上面描述的方法类似，不同之处在于，只有当子节点已经(从磁盘)加载到内存中时，才会递归地访问它们。如果未加载，则将它们排队等待加载，并呈现当前节点。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107180624.png" class="" title="image-20211107180624">

<p>地形的分块LOD表示。(图片由撒切尔·乌尔里希提供。)</p>
<p><strong>Ulrich将屏幕空间错误计算为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107180650.png" class="" title="image-20211107180650">

<p><strong>w是屏幕的宽度,d是相机的距离地面瓷砖,θ是弧度的水平视野,ǫ是几何误差在同一单位作为几何误差项,d。经常使用两个网格之间的Hausdorf距离。对于原始网格上的每个点，找到其在简化网格上最近的点，并将这些距离中最小的称为d1．现在对简化后的网格上的每个点执行相同的过程，找到原始网格上最近的点，并将距离的最小值称为d2．Hausdorff距离为ε = max(d1,d2)．如下图所示。注意，从o点到简化网格的最近点是s，而从s点到原始网格的最近点是a，这就是为什么必须在两种组合中进行测量的原因，从原始网格到简化网格，反之亦然。直观上，Hausdorff距离是用简化网格代替原始网格时的误差。如果应用程序无法计算Hausdorff距离，则可以使用为每次简化而手工调整的常数，或者查找简化过程中的错误。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107181018.png" class="" title="image-20211107181018">

<p>原始网格与简化网格之间的Hausdorff距离。(参考Sellers等人的插图。)</p>
<p><strong>为了避免在从一个LOD切换到另一个LOD时产生弹出效果，Ulrich提出了一种简单的变形技术，即从高分辨率贴图中的顶点(x, y, z)与顶点(x, y′，z)线性插值，这是从父贴图近似得到的(例如，使用双线性插值)。线性插值因子计算为2sτ−1，固定在[0,1]。注意，在变形过程中只需要高分辨率的贴图，因为下一个低分辨率的贴图的顶点也在高分辨率的贴图中。</strong></p>
<p><strong>启发法，如公式19.10中的启发法，可以用来确定每个贴图的细节级别。瓷砖方案的主要挑战是裂纹修复。例如，如果一个砖块的分辨率是33 × 33，而它的相邻砖块的分辨率是9 × 9，那么它们相遇的边缘就会出现裂缝。一种矫正措施是沿着边缘去除高度细节化的三角形，然后形成一组恰当地连接两个瓷砖之间的三角形。当两个相邻区域的细节水平不同时，就会出现裂缝。Ulrich描述了一种使用额外的带状几何的方法，如果τ被设置为小于5像素，这是一个合理的解决方案。Cozzi和Bagnell使用屏幕空间的后处理通道填充裂缝，其中裂缝周围的碎片，而不是裂缝内部的碎片，使用高斯核加权。Strugar采用了一种优雅的方法来避免裂缝，无需使用屏幕空间方法或额外的几何形状。如下图所示，可以用一个简单的顶点着色器实现。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107181030.png" class="" title="image-20211107181030">

<p>使用Strugar的分块LOD系统来避免裂纹。左上角显示了一个高分辨率的贴图，它在右上方变成了一个低分辨率的地形贴图。在这两者之间，我们展示了两个插值和变形的变体。实际上，当LOD发生改变时，这是以一种平滑的方式发生的，这在底部的屏幕截图中显示。(下图由Filip Strugar的程序生成。)</p>
<p><strong>为了提高性能，Sellers等人将分块LOD与视图截锥剔除和水平剔除结合起来。Kang等人提出了一种类似于分块LOD的方案，最大的区别是他们使用基于GPU的镶嵌对节点进行镶嵌，并确保边缘镶嵌因子匹配以避免裂缝。它们还展示了具有特征保留地图的几何图像是如何实现的用于渲染带有悬垂的地形，这是基于高度场的地形无法处理的。Strugar提出了分块LOD方案的扩展，三角形的分布更好、更灵活。与Ulrich的方法(使用每个节点的LOD)不同，Strugar使用具有单个细节级别的每个顶点的变形。虽然他只使用距离作为确定LOD的衡量标准，但也可以使用其他因素，如附近有多少深度变化，这可以生成更好的轮廓。</strong></p>
<p><strong>源地形数据通常用均匀高程网格表示。可以对这些数据使用与视图无关的简化方法，如图705页的图16.16所示。对模型进行简化，直到满足某一极限准则。小的表面细节可以通过颜色或凹凸贴图纹理捕获。生成的静态网格通常称为不规则三角网(TIN)，当地形面积较小且各区域相对平坦时，它是一种有用的表示方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107181325.png" class="" title="image-20211107181325">

<p>地形贴图的一种受限四叉树，其中每个贴图最多可以与相邻的贴图在细节层次上高一点或低一点。每个贴图有5 × 5个顶点，除了左上角，那里有2 × 2个更高分辨率的贴图。其余的地形由三个低分辨率的贴图填充。在左侧，左上方的贴图边缘上的顶点与相邻的低分辨率贴图上的顶点不匹配，这将导致开裂。在右侧，更详细的贴图的边缘被修改以避免这个问题。每个贴图在一个单独的绘制调用中呈现。(Andersson后面的插图)</p>
<p><strong>Andersson使用受限四叉树来弥补缺口，并降低大型地形所需的draw调用总数。他使用的不是以不同分辨率呈现的瓷砖的统一网格，而是瓷砖的四叉树。每个贴图都有相同的33 × 33分辨率，但每个贴图可以覆盖不同数量的区域。受限四叉树的理念是，每个贴图的邻居之间的细节差异不能超过一个层次。参见上图。这种限制意味着相邻贴图的分辨率不同的情况是有限的。与其创建间隙并渲染额外的索引缓冲区来填充这些间隙，我们的想法是存储所有可能的索引缓冲区的排列，从而创建一个包含间隙过渡三角形的平铺。每个索引缓冲区由全分辨率构成边(一条边上有33个顶点)和较低层次的细节边(只有17个顶点，因为四叉树是受限制的)。下图显示了一个现代地形渲染的例子。Widmark描述了一个完整的地形渲染系统，在Frostbite 2引擎中使用。它有有用的功能，如贴花，水，地形装饰，使用艺术家生成的或程序生成的遮罩的不同材质着色器的组成，和程序地形位移。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107181339.png" class="" title="image-20211107181339">

<p>地形渲染在许多层次的细节在行动。(Courtesy of DICE, c 2016 Electronic Arts Inc.)</p>
<p><strong>一种用于海洋渲染的简单技术是使用统一的网格，将每一帧转换到相机空间。如下图所示。鲍尔斯提供了许多克服某些质量问题的技巧。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211107181513.png" class="" title="image-20211107181513">

<p>左:一个统一的网格。右图:网格转化为摄像机空间。请注意转换后的网格是如何让查看者更接近更高的细节的。</p>
<p><strong>除了上述的地形技术(它倾向于减少需要随时保存在内存中的数据集的大小)，还可以使用压缩技术。Yusov使用四叉树数据结构压缩顶点，使用一个简单的预测方案，其中只有差异被编码(使用少量位)。Schneider和Westermann使用由顶点着色器解码的压缩格式，并探索细节层次之间的地貌，同时最大化缓存一致性。Lindstrom和Cohen使用具有线性预测和残差编码的流编解码器进行无损压缩。此外，它们使用量化来进一步提高压缩率，尽管结果是有损的。解压可以使用GPU完成，压缩率从3:1到12:1。</strong></p>
<p><strong>还有许多其他的地形渲染方法。Kloetzli在《文明V》中使用自定义计算着色器为地形创建自适应镶嵌，然后将其提供给GPU进行渲染。另一种技术是使用GPU的镶嵌器来处理每个补丁的镶嵌。注意，许多用于地形渲染的技术也可以用于水渲染。例如，Gonzalez- Ochoa和Holder在《神秘海域3》中使用了一种适合于水的几何剪辑地图。他们通过在关卡之间动态添加三角形来避免T形连接。随着GPU的发展，这方面的研究还将继续。</strong></p>
<h1 id="20-Efficient-Shading-高效着色"><a href="#20-Efficient-Shading-高效着色" class="headerlink" title="20 Efficient Shading 高效着色"></a>20 Efficient Shading 高效着色</h1><p><strong>对于简单的场景——相对较少的几何图形，基本的材质，少量的灯光——我们可以使用标准的GPU管线来渲染图像，而不用担心保持帧率。只有当一个或多个元素变得昂贵时，我们才需要使用更复杂的技术来控制成本。在前一章中，我们重点讨论了从后续处理中剔除三角形和网格。在这里，我们专注于在评估材料和灯光时降低成本的技术。对于许多这些方法，有额外的处理费用，希望这笔费用由所节省的费用弥补。另一些则在带宽和计算之间进行权衡，经常转移瓶颈。与所有此类方案一样，最佳方案取决于硬件、场景结构和许多其他因素。</strong></p>
<p><strong>评估一个材质的像素着色器是很昂贵的。这个成本可以通过各种着色器级别的细节简化技术来降低，如第19.9节所述。当有几个光源影响一个表面时，可以采用两种不同的策略。一个是创建一个支持多个光源的着色器，这样只需要一个通道。另一个是多通道着色，我们为一个光创建一个简单的单光像素着色器，并对它进行评估，将每个结果添加到帧缓冲区中。因此，对于三盏灯，我们会绘制三次原语，为每一次评估改变灯光。第二种方法可能比单通道系统更有效，因为每个着色器使用更简单和更快。如果一个渲染器有许多不同类型的光，一个一次性的像素着色器必须包括它们所有，并测试每一个是否被使用，使一个复杂的着色器。</strong></p>
<p><strong>在第18.4.5节中，我们讨论了通过最小化或消除透支来避免不必要的像素着色器评估。如果我们可以有效地确定一个表面对最终图像没有影响，那么我们就可以节省花在着色上的时间。一种技术执行z- preass，其中渲染不透明的几何图形，只写入z-depth。几何图形再次完全着色，第一次通过的z-buffer会剔除所有不可见的片段。这种类型的通过是一个尝试去耦的过程，从发现什么几何体是可见的操作，随后着色该几何体。将这两个过程分离的想法是贯穿本章的一个重要概念，并且被一些替代的渲染方案所采用。</strong></p>
<p><strong>例如，使用z- preass的一个问题是，你必须渲染几何图形两次。与标准渲染相比，这是一种额外的开销，而且花费的时间可能比节省的时间要多。如果网格是通过镶嵌、蒙皮或其他一些涉及的过程形成的，这一添加通道的成本可能是相当大的。带有剪切alpha值的对象需要在每次通过时都获得其纹理的alpha值，这增加了成本，或者必须完全忽略并只在第二次通过时进行渲染，这可能会浪费像素着色器的评估。由于这些原因，有时在这个初始过程中只绘制大的遮挡(屏幕或世界空间)。其他屏幕空间效果(如环境遮挡或反射)也可能需要执行完整的预渲染。在本章中介绍的一些加速技术需要一个精确的z- preass，然后用来帮助筛选光的列表。</strong></p>
<p><strong>即使没有透支，为可见表面评估大量动态光源也会产生巨大的费用。假设你在一个场景中有50个光源。一个多通道系统可以成功渲染场景，但代价是每个对象经过50个顶点和着色器。降低成本的一种技术是将每个局部光源的效果限制在一个半径一定的球体、一定高度的圆锥或其他有限形状上。假设每一种光的作用在超过一定距离后就变得微不足道。在本章的剩余部分，我们将把灯的体积称为球体，同时理解其他形状也可以使用。通常光的强度是决定其半径的唯一因素。Karis讨论了有光泽的镜面材料的存在将如何增加这个半径，因为这样的表面受光线的影响更明显。对于非常光滑的表面，这个距离可能会无穷大，因此可能需要使用环境地图或其他技术。</strong></p>
<p><strong>一个简单的预处理是为每个网格创建一个影响它的光的列表。我们可以把这个过程看作是在网格和光线之间执行碰撞检测，发现那些可能重叠的。当给网格着色时，我们使用这个灯光列表，从而减少应用的灯光数量。这种方法存在一些问题。如果物体或灯光移动，这些变化会影响列表的组成。为了提高性能，共享相同材质的几何体通常被合并到更大的网格中(章节18.4.2)，这可能导致单个网格在其列表中包含场景中的一些或所有灯光。也就是说，网格可以合并，然后在空间上进行分割，以提供更短的列表。</strong></p>
<p><strong>另一种方法是将静态光烘烤到世界空间数据结构中。例如，在《Just Cause 2》的照明系统中，世界空间自上而下的网格存储场景的照明信息。网格单元格代表一个4米× 4米的区域。每个细胞都以像素的形式存储在RGBα纹理中，因此拥有一个最多4个光源的列表。当渲染一个像素时，检索其区域内的列表并应用相关的光。缺点是存储数量有一个固定的限制影响给定区域的灯光。虽然可能对精心设计的室外场景有用，但有许多层的建筑可以迅速压倒这种存储方案。</strong></p>
<p><strong>我们的目标是以一种有效的方式处理动态网格和灯光。同样重要的是可预测的性能，在视图或场景中的一个小变化不会导致渲染成本的大变化。《毁灭战士》(2016)中的某些关卡有300个可见光;《奇点灰烬》中的一些场景有10000个。参见下图和第913页的图20.15。在一些渲染器中，大量的粒子可以被视为小光源。其他技术使用光探头(第11.5.4节)照亮附近的表面，可以认为是短程光源。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108124656.png" class="" title="image-20211108124656">

<p>一个复杂的照明情况。注意肩膀上的小光源和建筑结构上的每个亮点都是光源。右上方远处的灯光是光源，它们被渲染为该距离的点精灵。(图片来自雪崩工作室提供的《正当防卫3》。)</p>
<h2 id="Deferred-Shading-延迟渲染"><a href="#Deferred-Shading-延迟渲染" class="headerlink" title="Deferred Shading 延迟渲染"></a>Deferred Shading 延迟渲染</h2><p><strong>到目前为止，在本书中，我们已经描述了前向着色，即每个三角形沿管线向下发送，在其旅行的最后，屏幕上的图像将更新其着色值。延迟着色背后的想法是在执行任何材料照明计算之前执行所有可见性测试和表面属性评估。该概念最早于1988年在硬件架构中引入，后来作为实验性PixelFlow系统的一部分，并作为离线软件解决方案，通过图像处理帮助生成非照片真实风格。Calver在2003年中期的文章中阐述了基本的在GPU上使用延迟着色的想法。Hargreaves和Harris和Thibieroz在第二年推广了它的使用，当时书写多个渲染目标的能力正变得越来越普遍。</strong></p>
<p><strong>在前向着色中，我们使用一个着色器和一个网格来计算最终的图像。通道获取材质属性——常量、插值参数或纹理中的值——然后对这些值应用一组光。前向渲染的z- preass方法可以被看作是几何渲染和着色的轻度解耦，因为第一个几何通道的目的只是确定可见性，而所有的着色工作，包括材料参数检索，被推迟到第二个几何通道执行，以着色所有可见像素。对于交互式渲染，延迟着色特别意味着所有与可见对象相关的材质参数都是通过初始几何通道生成和存储的，然后使用后处理将光线应用到这些存储的表面值。保存在第一个通道的值包括位置(存储为z-depth)、法线、纹理坐标和各种材质参数。这个通道为像素建立了所有的几何和材料信息，所以对象不再需要，即模型的几何形状的贡献已经完全从照明计算中分离出来。注意，在这个初始过程中可能会发生透支，不同的是着色器的执行是相当少的将值传输到缓冲区，而不是评估一组光对材质的影响。在正向着色中也有更少的额外成本，有时2×2四边形中的所有像素都在三角形的边界内，但所有像素都必须完全着色(章节23.8)。这听起来像是一个小效果，但想象一个网格，其中每个三角形覆盖一个像素。将生成四个完全着色的样本，其中三个用正向着色丢弃。使用延迟着色，每个着色器调用的代价更低，因此丢弃的样本的影响相当低。</strong></p>
<p><strong>用来存储表面属性的缓冲器通常被称为G -缓冲器，是“几何缓冲器”的缩写。这种缓冲区有时也被称为深度缓冲区，尽管这个术语也可以指每个像素存储多个表面(碎片)的缓冲区，所以我们在这里避免使用它。下图显示了一些G -buffer的典型内容。一个G缓冲区可以存储任何程序员想要它包含的东西，例如来完成所需的后续光照计算。每个G-buffer都是一个单独的渲染目标。通常情况下，3到5个渲染目标被用作G缓冲区，但系统已经高达8个。拥有更多的目标将使用更多的带宽，这将增加该缓冲区成为瓶颈的可能性。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108134114.png" class="" title="image-20211108134114">

<p>用于延迟着色的几何缓冲，在某些情况下转换为颜色以实现可视化。左列，从上到下:深度映射，正常缓冲区，粗糙度缓冲区，和阳光遮挡。右栏:纹理颜色(也就是反照纹理)，光强度，镜面强度和接近最终的图像(没有运动模糊)。(图片来自Guerrilla BV提供的《杀戮地带2》。)</p>
<p><strong>创建G -buffer之后，使用一个单独的进程来计算光照效果。一种方法是一个接一个地应用每个光，使用G缓冲器来计算它的效果。对于每个光源，我们绘制一个屏幕填充四边形(章节12.1)，并访问G缓冲区作为纹理。在每个像素上，我们可以确定最近的表面的位置，以及它是否在光线的范围内。如果是，我们计算光的效果，并将结果放入输出缓冲区。我们依次为每个光做这个，通过混合添加它的贡献。最后，我们应用了所有灯光的贡献。</strong></p>
<p><strong>这个过程是使用G缓冲区最低效的方式，因为每个存储的像素都被访问每个光，类似于基本的正向渲染将所有的光应用到所有的表面碎片。由于写入和读取G缓冲区的额外成本这种方法最终可能会比前向着色慢。作为一个开始为了提高性能，我们可以确定一个轻体(球体)的屏幕边界，并用它们绘制一个覆盖图像较小部分的屏幕空间四边形。以这种方式，像素处理被减少，通常是显著的。绘制一个代表球体的椭圆可以进一步修剪光线体积之外的像素处理。我们还可以使用第三个屏幕尺寸，z深度。通过绘制一个包含体积的粗略球体网格，我们可以进一步修剪球体的效果区域。例如，如果球体被深度缓冲隐藏，光的体积就在最近的表面后面，所以没有效果。概括地说，如果球体在一个像素处的最小深度和最大深度没有重叠最近的表面，那么光线就不能影响这个像素。Hargreaves和Valient讨论了有效、正确地确定这种重叠的各种选项和注意事项，以及其他优化方法。我们将看到在前面的几个算法中测试表面和光线之间的深度重叠。哪种效率最高取决于具体情况。</strong></p>
<p><strong>对于传统的正向渲染，顶点和像素着色程序检索每个光和材料的参数，并计算一个对另一个的影响。前向着色需要一个复杂的顶点和像素着色器来覆盖所有可能的材质和灯光组合，或者更短的、专门的着色器来处理特定的组合。带有动态分支的长着色器通常运行得相当慢，所以大量较小的着色器可以更高效，但也需要更多的工作来生成和管理。由于所有的着色功能都是在一个单一的过程中通过正向着色完成的，当下一个物体被渲染时，着色器很可能需要改变，这导致了交换着色器的效率低下(章节18.4.2)。</strong></p>
<p><strong>渲染的延迟着色方法允许光照和材质定义之间的强烈分离。每个着色器专注于参数提取或照明，但不是两者。较短的着色器运行得更快，这是由于长度和优化它们的能力。着色器中使用的寄存器的数量决定了占用率(章节23.3)，这是有多少着色器实例可以并行运行的关键因素。灯光和材质的解耦也简化了材质系统的管理。例如，这种分离使得实验变得容易，因为只需要为一个新的光源或材料类型添加一个新的着色器到系统中，而不是为每个组合添加一个。这是可能的，因为材料评估在第一次通过，然后照明应用到这个存储的表面参数集在第二次通过。</strong></p>
<p><strong>对于单通道前向渲染，所有的阴影贴图通常必须同时可用，因为所有的灯光都是一次性评估的。由于每个光都被完全处理在一个单通道中，延迟着色允许在内存中一次只有一个阴影贴图。然而，这种优势随着我们后面介绍的更复杂的光分配方案而消失，因为光是分组评估的。</strong></p>
<p><strong>基本的延迟着色只支持一个单一的材质着色器和一组固定的参数，这限制了什么材质模型可以被描绘。支持不同材质描述的一种方法是存储每个像素的材质ID或蒙版一些给定的字段。然后着色器可以根据G缓冲区的内容执行不同的计算。这种方法还可以根据ID或掩码值修改G缓冲区中存储的内容。例如，一种材料可能使用32位存储第二层颜色和混合因子在G缓冲区，而另一种材料可能使用这些相同的位存储它需要的两个切向量。这些方案需要使用更复杂的着色器，这可能会有性能影响。</strong></p>
<p><strong>基本的延迟着色还有其他一些缺点。G-buffer的显存需求可能非常大，重复访问这些缓冲区的相关带宽成本也是如此。我们可以通过存储精度较低的值或压缩数据来降低这些成本。下图显示了一个示例。在第16.6节中，我们讨论了网格的世界空间数据压缩。G-buffers可以包含世界空间或屏幕空间坐标中的值，这取决于渲染引擎的需要。Pesce讨论了G缓冲区在压缩屏幕空间和世界空间法线时的权衡，并提供了指向相关资源的指针。世界空间的八面体法线映射是一种常见的解决方案，因为它具有高精度和快速的编码和解码时间。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108134440.png" class="" title="image-20211108134440">

<p>一个可能的G缓冲布局的例子，在彩虹6围攻中使用。除了深度和模具缓冲，四个渲染目标(RTs)也被使用。可以看到，任何东西都可以放到这些缓冲区中。RT0中的“GI”字段为“GI正常偏置(A2)”。(以El Mansouri为例。)</p>
<p><strong>延迟着色的两个重要技术限制涉及透明度和抗锯齿。基本的延迟着色系统不支持透明度，因为每个像素只能存储一个表面。一种解决方案是在不透明表面使用延迟着色后对透明对象使用前向渲染。对于早期的延迟系统，这意味着场景中的所有灯光都必须应用到每个透明物体上，这是一个昂贵的过程，或者必须执行其他简化操作。正如我们将在接下来的章节中探索的那样，改进的GPU能力已经导致了对延迟着色和前向着色剔除光的方法的开发。虽然现在可以存储像素的透明表面列表，并使用纯延迟方法，但规范是混合延迟和前向着色，以满足透明度和其他效果的需要。</strong></p>
<p><strong>正演方法的一个优点是容易支持诸如MSAA这样的抗锯齿方案。对于N× MSAA，正向技术只需要每个像素存储N个深度和颜色样本。延迟着色可以将每个元素的所有N个样本存储在G -buffer中以执行反锯齿，但内存成本、填充率和计算量的增加使这种方法代价高昂。为了克服这个限制，Shishkovtsov使用边缘检测方法来逼近边缘覆盖计算。其他形态学后处理方法用于抗走样(章节5.4.2)也可以使用，以及时间反走样。几种延迟MSAA方法通过检测哪些像素或瓦片有边缘来避免计算每个样本的着色。只有那些有边缘的需要对多个样本进行评估。Sousa基于这种方法，使用模板识别需要更复杂处理的多个样本像素。Pettineo描述了一种跟踪此类像素的新方法，使用计算着色器将边缘像素移动到线程组内存中的列表中，以实现高效的流处理。</strong></p>
<p><strong>Crassin等人的抗锯齿研究注重高质量的结果，并总结了该领域的其他研究。他们的技术执行深度和法向几何学预压，并将类似的子样品分组在一起。然后，他们生成G缓冲，并对每组子样本使用的最佳值进行统计分析。然后使用这些深度边界值为每个组着色，并将结果混合在一起。虽然在撰写本文时，这种以交互速度进行的处理对于大多数应用程序来说是不切实际的，但这种方法可以让我们了解到能够并将用于改善图像质量的计算能力的数量。</strong></p>
<p><strong>即使有这些限制，延迟着色仍然是商业程序中使用的一种实用的渲染方法。它自然地从阴影中分离几何，从材料中分离照明，这意味着每个元素都可以自行优化。一个特别感兴趣的领域是贴花渲染，它对任何渲染管线都有影响。</strong></p>
<h2 id="Decal-Rendering-贴花渲染"><a href="#Decal-Rendering-贴花渲染" class="headerlink" title="Decal Rendering 贴花渲染"></a>Decal Rendering 贴花渲染</h2><p><strong>贴花是一些设计元素，如图片或其他纹理，应用在表面的顶部。在电子游戏中，贴花通常以轮胎印、弹孔或玩家标签等形式出现。贴花用于应用标识、注释或其他内容的其他应用。例如，对于地形系统或城市，贴花可以让艺术家通过在细节纹理上分层或以不同方式重新组合各种图案来避免明显的重复。</strong></p>
<p><strong>贴花可以通过多种方式与底层材料混合。它可能会修改潜在的颜色，但不会修改凹凸贴图，比如纹身。或者，它可能只是替换凹凸贴图，比如浮雕logo。它可以定义一种完全不同的材料，例如，在车窗上贴一个贴纸。多个贴花可以应用到相同的几何图形上，例如路径上的脚印。一个贴花可能跨越多个模型，比如地铁车厢表面的涂鸦。这些变化对正向和延迟遮阳系统存储和处理贴花的方式有影响。</strong></p>
<p><strong>首先，贴花必须像其他纹理一样映射到表面。由于多个纹理坐标可以存储在每个顶点，它可以绑定一些贴花到一个单一的表面。这种方法是有限的，因为值的数量每个顶点可以保存的相对较低。每个贴花需要它自己的一组纹理坐标。大量的小贴花应用到一个表面意味着在每个顶点保存这些纹理坐标，即使每个贴花只影响网格中的几个三角形。</strong></p>
<p><strong>要将贴花渲染到网格上，一种方法是让像素着色器采样每个贴花，并将一个贴花混合在另一个贴花之上。这使着色器变得复杂，如果贴花的数量随时间变化，可能需要频繁的重新编译或其他措施。另一种保持着色器独立于贴花系统的方法是为每一个贴花再次渲染网格，分层和混合每一个通道在前一个。如果一个贴花仅仅跨越了几个三角形，那么可以创建一个单独的、较短的索引缓冲区来渲染这个贴花的子网格。另一种贴花方法是修改材料的纹理。如果只在一个网格上使用，比如在一个地形系统中，修改这个纹理提供了一个简单的“设置它然后忘记它”的解决方案。如果材质纹理被用在一些物体上，我们需要创建一个新的材质和贴花合成在一起。这个烘焙解决方案避免了着色器的复杂性和浪费的透支，但代价是纹理管理和内存使用。分别渲染贴花是一种规范，因为不同的分辨率可以应用到相同的表面，并且基础纹理可以重复使用，而不需要在内存中添加额外的修改副本。</strong></p>
<p><strong>这些解决方案对于计算机辅助设计包来说是合理的，用户可以只添加一个标识，其他的就很少了。它们也用于贴花应用到动画模型，其中贴花需要在变形前被投影，这样它就像对象一样拉伸。然而，这种技术变得效率低下和繁琐的超过几个贴花。</strong></p>
<p><strong>对于静态或刚性物体，一种流行的解决方案是将贴花处理为通过有限体积投影的纹理。一个有方向的盒子被放置在场景中，贴花从盒子的一个面投射到另一个面，就像电影放映机一样。参见下图。盒子的表面被栅格化，作为一种驱动像素着色器执行的方法。任何几何发现在这个卷有贴花应用在其材料。这是通过将表面的深度和屏幕位置转换为体积中的一个位置来完成的，然后为贴花提供一个(u, v)纹理坐标。另外，贴花可以是一个真正的卷纹理。通过分配ID、分配模板位或依赖于渲染顺序，贴花只能影响体积中的某些对象。它们也经常褪色或夹紧到表面和投影方向的角度，以避免在表面变得更接近边缘的地方产生贴花拉伸或扭曲。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108134929.png" class="" title="image-20211108134929">

<p>一个方框定义了一个贴花投影，在该方框内的表面应用贴花。盒子被用夸张的厚度显示，以显示投影仪及其效果。在实践中，盒子被做得尽可能的薄和紧的表面，以减少在贴花应用过程中测试的像素数量。</p>
<p><strong>延迟遮光在渲染这类贴花方面很出色。与标准的前向着色不同的是，贴花的效果可以应用到G -缓冲器上。例如，如果一个轮胎的胎面标记的贴花取代了表面上的阴影法线，这些变化是直接对适当的G缓冲。每个像素随后仅使用G -buffer中的数据进行灯光着色，从而避免了前向着色时发生的着色透支。自贴花的效果可以完全被G缓冲存储器捕获，贴花在遮光期间就不需要了。这种集成还避免了多通道前向着色的问题，即一个通道的表面参数可能会影响另一个通道的光照或着色。这种简单性是决定Frostbite 2引擎从正向着色切换到延迟着色的主要因素，例如贴花可以被认为与灯光相同，因为它们都是通过渲染空间来确定其在封闭表面上的效果。正如我们将在第20.4节中看到的，通过使用这一事实，经过修改的前向着色形式可以利用类似的效率和其他优势。</strong></p>
<p><strong>Lagarde和de Rousiers描述了延迟设置中贴花的几个问题。在管线的合并阶段，混合操作受限于可用的操作。如果材料和贴花都有法线贴图，实现适当的混合结果可能是困难的，如果使用一些凹凸纹理过滤技术就更难了。可以出现黑色或白色边缘工件，如第6.5节所述。有符号距离场等技术可以用来对这些材料进行精确分割，尽管这样做可能会导致混叠问题。另一个问题是贴花的轮廓边缘，这是由于将屏幕空间的信息投影回世界空间而导致的梯度误差造成的。一种解决方案是限制或忽略此类贴花的mipmapping;Wronski讨论了更详细的解决方案。</strong></p>
<p><strong>贴花可以用于动态元素，如刹车痕迹或弹孔，但也可以用于给不同的位置一些变化。下图显示了一个应用于建筑墙壁和其他地方的贴花场景。墙壁纹理可以重复使用，而贴花提供定制的细节，给每个建筑一个独特的特点。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108135211.png" class="" title="image-20211108135211">

<p>在顶部的图像中，颜色和凹凸贴花重叠的区域用棋盘显示。中间是没有贴花的建筑。下面的图片显示了应用了大约200个贴花的场景。(图片由IO Interactive提供。)</p>
<h2 id="Tiled-Shading-平铺着色"><a href="#Tiled-Shading-平铺着色" class="headerlink" title="Tiled Shading 平铺着色"></a>Tiled Shading 平铺着色</h2><p><strong>在基本的延迟着色中，每个光源被分别计算，结果被添加到输出缓冲区中。这是早期GPU的一个特性，由于着色器复杂性的限制，评估多个光源是不可能的。延迟着色可以处理任意数量的灯光，代价是每次都要访问G -buffer。对于成百上千的光源，基本的延迟着色变得非常昂贵，因为所有的光源都需要为每个重叠的像素处理，并且每个像素上的光源都需要单独的着色器调用。在一个着色器调用中评估几个光源更有效。在接下来的章节中，我们将讨论几种算法，用于在交互速率下快速处理大量的光，包括延迟着色和前向着色。</strong></p>
<p><strong>多年来，人们开发了各种混合G缓冲系统，在材料和光存储之间实现了平衡。例如，想象一个带有漫反射和高光术语的简单着色模型，其中材质的纹理只影响漫反射术语。我们可以先分别计算每个光的漫反射和镜面条件，然后存储这些结果，而不是从G缓冲中获取每个光的纹理颜色。这些累积的项被加在基于光的G缓冲器中，有时也被称为L缓冲器。最后，我们检索纹理的颜色一次，乘以漫反射项，然后添加镜面。纹理的效果被排除在等式之外，因为它只对所有的光使用一次。通过这种方式，每次光访问更少的G缓冲区数据点，节省了带宽。一个典型的存储方案是累积漫反射颜色和镜面强度，这意味着四个值可以通过加性混合输出到一个缓冲区。Engel讨论了几种早期延迟照明技术，也被称为预照明或光预压方法。Kaplanyan比较了不同的方法，旨在最小化G缓冲区的存储和访问。Thibieroz也强调了较浅的G缓冲器，对比了几种算法的优缺点。Kircher描述了使用低分辨率的G缓冲器和L缓冲器进行照明，它们在最后的前向着色过程中进行上采样和双边滤波。这种方法在某些材质上效果很好，但如果光照的效果变化很快，就会产生伪影，例如，将粗糙度或法线贴图应用到反射表面上。Sousa等人使用了子采样和反照率纹理的Y ‘CbCr颜色编码的思想，以帮助降低存储成本。反照率影响扩散分量，而扩散分量不太容易受到高频变化的影响。</strong></p>
<p><strong>还有很多这样的方案，每个方案都不同，比如哪些组件被存储和分解，执行哪些通道，以及如何渲染阴影、透明度、抗锯齿和其他现象。所有这些技术的一个主要目标是相同的——高效地渲染光源——这种技术至今仍在使用。一些方案的一个限制是，它们可能需要更严格的材料和照明模型。例如，Shulz指出，向基于物理的材料模型移动意味着需要存储镜面反射率，以根据光照计算菲涅尔项。光照预压要求的增加帮助他的团队从光照预压系统转移到完全延迟的着色系统。</strong></p>
<p><strong>即使每光访问少量的G -buffer也会产生巨大的带宽成本。更快的方法是在一次通过中只评估影响每个像素的光。Zioma是最早探索创建前向着色光源列表的人之一。在他的方案中，光体被渲染，光的相对位置、颜色和衰减因子被存储在每个重叠像素上。深度剥离用于存储重叠相同像素的光源信息。然后使用存储的光表示来渲染场景的几何图形。虽然可行，但这个方案受限于任何像素可以重叠的光线数量。Trebilco进一步提出了每像素创建光列表的想法。他执行z- preass，以避免透支和剔除隐藏的光源。光体被渲染并存储为每个像素的ID值，然后在正向渲染过程中访问这些值。他给出了几种在单个缓冲区中存储多个光源的方法，包括位移和混合技术，该技术允许在不需要多次深度剥离通道的情况下存储四个光源。</strong></p>
<p><strong>2008年，Balestra和Engstad在《Uncharted: Drake’s Fortune》中首次提出了贴图着色，随后又介绍了它在Frostbite engine和PhyreEngine中的使用情况。平铺底纹的核心思想是将光源分配给像素平铺，从而限制每个表面需要评估的光源数量，以及所需的工作量和存储空间。这些每个平铺的光源列表然后在一个着色器调用中被访问，而不是延迟的着色方法为每个光源调用一个着色器。</strong></p>
<p><strong>用于灯光分类的贴图是屏幕上的一组方形像素，例如，大小为32 × 32像素。注意，还有其他方法可以用于交互式渲染;例如，移动处理器通过处理贴图来渲染图像，GPU架构使用屏幕贴图来完成各种任务(第23章)。在这里，tiles是由开发人员选择的构造，通常与底层硬件关系不大。光体的平铺渲染有点像场景的低分辨率渲染，可以在CPU上执行，也可以在GPU上的计算着色器中执行。</strong></p>
<p><strong>可能影响贴图的灯光记录在一个列表中。当执行渲染时，给定平铺中的像素着色器使用平铺对应的灯光列表来给表面着色。下图的左侧说明了这一点。可以看到，不是所有的灯光都与每个贴图重叠。贴图的屏幕空间边界形成了一个不对称的截锥，用于确定重叠。每个光的球形体积效果可以在CPU上快速测试，或者在计算着色器中与每个贴图的截锥重叠。只有当有重叠时，我们才需要为贴图中的像素进一步处理光线。通过存储每个贴图而不是每个像素的光列表，我们错误地倾向于保守——一个光的体积可能不会重叠整个贴图——以大大减少处理、存储和带宽成本。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108140004.png" class="" title="image-20211108140004">

<p>瓷砖的插图。左图:画面被划分为6 × 6的贴图，3个光源(1-3)照亮了这个场景。观察A - C瓦片，我们可以看到A瓦片受到灯光1和2的影响，B瓦片受到灯光1 - 3的影响，C瓦片受到灯光3的影响。右图:从上方可以看到左边的黑色线条。对于平铺B，深度边界用红线表示。在屏幕上，砖块B似乎与所有灯光重叠，但只有灯光1和2与深度边界重叠。</p>
<p><strong>为了确定光线是否与贴图重叠，我们可以对球体使用截锥测试，这在22.14节中有描述。这里的测试假定一个大而宽的截锥和相对较小的球体。然而，由于这里的截锥来自屏幕空间贴图，它通常是又长又细且不对称的。这降低了筛选的效率，因为报告的交叉点的数量可以增加(即假阳性)。参见下图的左侧部分。相反，在对截锥的平面进行测试之后，可以添加一个球/箱测试(章节22.13.2)，如下图中的右侧所示。Mara和McGuire对投影球体进行了替代测试，包括他们自己的GPU高效版本。Zhdan指出，这种方法在聚光灯下效果不佳，并讨论了使用分层剔除、栅格化和代理几何的优化技术。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108140133.png" class="" title="image-20211108140133">

<p>左:在简单的球体/截锥测试中，这个圆会被报告为相交的，因为它与截锥的底部和右侧平面重叠。中间:左边的测试说明，这里的截锥已经增长，圆的原点(加号)只针对黑色的厚平面进行测试。绿色区域报告了虚假相交。右:在截锥周围放置一个用虚线表示的盒子，在中间的平面测试之后添加一个球/盒子测试，形成所示的粗轮廓形状。注意这个测试是如何在它的绿色区域产生其他假交叉的，但是两个测试都应用了，这些区域会减少。由于球体的原点在形状的外面，球体被正确地报告为不重叠截锥。</p>
<p><strong>这种光线分类过程可以用于延迟着色或前向渲染，Olsson和Assarsson对此进行了详细描述。对于平铺延迟着色，G缓冲器是像往常一样建立的，每个光源的体积被记录在它重叠的平铺中，然后这些列表被应用到G缓冲器中来计算最终结果。在基本的延迟着色中，每个光源都是通过渲染一个代理对象(如一个四边形)来应用，以迫使像素着色器对该光源进行评估。使用平铺着色，一个计算着色器或为屏幕或每个平铺渲染的四边形用于驱动每个像素的着色器评估。当一个片段被评估时，该tile列表中的所有灯光都会被应用。申请灯光清单有几个优点，包括:</strong></p>
<pre><code>**•对于每个像素，G -buffer最多读取一次，而不是每个重叠光读取一次。**

**•输出图像缓冲区只写入一次，而不是累积每个光的结果。**

**•着色器代码可以在渲染方程中分解出任何通用术语并计算一次，而不是每光。**

**•贴图中的每个片段评估相同的光源列表，确保GPU扭曲的一致性执行。**

**•在所有不透明对象渲染后，透明对象可以使用前向着色，使用相同的光列表。**
</code></pre>
<p><strong>•由于所有灯光的效果都是在单一通道中计算的，如果需要的话，帧缓冲区的精度可以很低。</strong></p>
<p><strong>最后一项，帧缓冲区精度，在传统的延迟着色引擎中非常重要。每一种光都被应用在一个单独的通道中，所以如果结果在一个每个颜色通道只有8位的帧缓冲区中积累，最终的结果可能会受到条带和其他伪影的影响。也就是说，能够使用较低的精度与许多现代渲染系统无关，因为这些系统需要更高精度的输出来执行色调映射和其他操作。</strong></p>
<p><strong>平铺灯光分类也可以用于正向渲染。这种类型的系统被称为平铺前向着色或前向+。首先，几何体的z预压被执行，既避免在最终通过透支，又允许进一步的光剔除。一个计算着色器按瓷砖分类灯。第二个几何通道然后执行前向着色，每个着色器访问基于碎片的屏幕空间位置的光列表。</strong></p>
<p><strong>平铺前向着色已经被用于像《秩序:1886》这样的游戏中。Pettineo提供了一个开源测试套件，用于比较延迟和前向分类的平铺底纹实现。为了抗锯齿，在使用延迟着色时，每个样本都被存储。结果是混合的，每个方案优于其他在各种测试条件下。在没有反锯齿的情况下，当光照数量增加到1024时，延迟在许多GPU上往往会胜出，而前向在抗锯齿级别增加时表现更好。Stewart和Thomas通过更广泛的测试分析了一个GPU模型，发现了相似的结果。</strong></p>
<p><strong>z-pre - ass还可以用于另一个目的，通过深度筛选光。这个想法如上图20.6中所示。第一步是找到贴图中物体的最小和最大深度zmin 和zmax．这些都是通过执行一个reduce操作来决定的，在这个操作中，一个着色器被应用到tile的数据zmin 和zmax 数值是通过一次或多次采样来计算的。例如，Harada等人使用一个计算着色器和无序访问视图来有效地执行截锥剔除和减少贴图。这些值可以用来快速剔除贴图中不重叠此范围的任何灯光。空瓷砖，例如，只有天空可见，也可以忽略。场景的类型和应用程序影响是否值得计算和使用最小值、最大值或两者都使用。这种方法也可以应用于平铺延迟着色，因为深度在G -buffer中。</strong></p>
<p><strong>因为深度界限是在不透明的表面上找到的，所以透明度必须单独考虑。为了处理透明表面，Neubelt和Pettineo渲染了一组额外的通道来创建每个瓷砖的灯，用于光和阴影只透明表面。首先，透明表面被渲染在不透明几何体的z- preass缓冲区之上。zmin ，而zmax 的不透明表面用于盖锥的远端。第二次通过执行一个单独的光分类通过，其中生成新的每个贴图的光列表。第三个通道只发送透明的表面通过渲染器，类似于平铺前着色。所有这些表面都被新的光列表遮蔽和照亮。</strong></p>
<p><strong>对于有大量灯光的场景，有效z值的范围对于从进一步处理中剔除大部分是至关重要的。然而，这种优化对于深度不连续这种常见情况没有什么好处。例如，一个瓷砖包含一个附近的人物，以远处的山为背景。两者之间的z范围是巨大的，所以基本上是无用的筛选光。这个深度范围问题会影响场景的很大一部分，如下图所示。这个例子不是一个极端的例子。在森林中，或者有高草或其他植被的场景中，瓷砖的不连续率可能更高。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108140645.png" class="" title="image-20211108140645">

<p>存在较大深度不连续的瓦片的可视化。(图片来自雪崩工作室提供的《正义事业3》。)</p>
<p><strong>一种解决方法是在zmin 和zmax的中间做一次分割．这种测试被称为双峰簇或HalfZ，它将相交的光分类为与中点相比的更近、更远或全范围的重叠。这样做会直接攻击贴图中的两个对象，一个是近的，一个是远的。它不能解决所有的问题，例如，轻量既不重叠物体，也不重叠两个以上的物体在不同深度重叠。尽管如此，它可以提供一个明显的减少照明计算的整体。</strong></p>
<p><strong>Harada等人提出了一种更精细的称为2.5D剔除的算法，其中每个贴图的深度范围为zmin 和zmax，沿深度方向分为n个单元。这个过程如下图所示。创建一个n位的几何位掩码，有几何位的每个位都设置为1。为了提高效率，他们使用n = 32。迭代所有的光，并创建一个光位掩码为每个光重叠的平铺截锥。光位掩码指示光位于哪个单元格中。几何位掩码是AND:ed，带有光掩码。如果结果是零，那么光线不会影响贴图中的任何几何形状。如下图中的右侧所示。否则，灯光将被附加到贴图的灯光列表中。对于一个GPU架构，Stewart和Thomas发现，当光的数量上升到512以上时，HalfZ的表现开始优于基本的平铺延迟，当光的数量上升到2300以上时，2.5D淘汰开始占据主导地位，尽管不是很明显。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108140914.png" class="" title="image-20211108140914">

<p>左图:蓝色的圆台，黑色的几何图形，黄色的光源。中间:用平铺剔除zmin 和zmax 红色的值用于剔除不与灰色区域重叠的光源。右:对于聚集淘汰，z之间的区域min 和zmax 被分割为n个单元格，在本例中n = 8。使用像素的深度计算几何位掩码(10000001)，并为每个光计算光位掩码。如果这些之间的位AND是0，那么光不会被认为是进一步的瓷砖。最上面的光有11000000，所以是唯一的光将被处理为照明计算，因为11000000 AND 10000001给出10000000，这是非零。</p>
<p><strong>Mikkelsen通过使用不透明物体的像素位置进一步简化了光列表。对于每个16 × 16像素的贴图，将生成一个列表，每个光源的屏幕空间边界矩形以及zmin 和zmax 剔除的几何边界。然后这个列表被进一步剔除，让64个计算着色器线程中的每个线程比较贴图中的4个像素对每个光。如果在一个贴图中没有一个像素的世界空间位置在光的体积内，那么光就会从列表中剔除。得到的光集可以相当精确，因为只有那些保证影响至少一个像素的光才会被保存。Mikkelsen发现，在他的场景中，使用z轴的进一步筛选程序会降低整体性能。</strong></p>
<p><strong>随着灯光放置到列表中并作为一个集合进行评估，延迟系统的着色器复杂性可以变得相当复杂。一个着色器必须能够处理所有的材料和所有的光类型。Tiles可以帮助降低这种复杂性。这个想法是在每个像素中存储一个位掩码，每个位与材质在那个像素中使用的着色器特征相关联。对于每个贴图，这些位掩码用OR:ed在一起，以确定该贴图中使用的最小特征数量。位遮罩也可以AND:ed在一起，以找到所有像素使用的特征，这意味着着色器不需要一个“如果”测试来检查是否执行这段代码。一个满足这些要求的着色器被用于平铺中的所有像素。这个着色器专门化是重要的，不仅因为需要执行的指令更少，而且因为生成的着色器可能达到更高的占用率(章节23.3)，否则着色器必须为最坏情况的代码路径分配寄存器。除了材质和灯光之外的属性可以被跟踪并用于影响着色器。例如，在《Split/Second》这款游戏中，Knight等人根据砖块是否完全或部分处于阴影中，是否包含需要抗锯齿的多边形边缘，以及其他测试对4 × 4砖块进行分类。</strong></p>
<h2 id="Clustered-Shading-集群着色"><a href="#Clustered-Shading-集群着色" class="headerlink" title="Clustered Shading 集群着色"></a>Clustered Shading 集群着色</h2><p><strong>平铺灯光分类使用平铺的二维空间范围和可选的几何深度边界。集群的着色将视图截锥分割开来形成一组三维细胞，称为细胞簇。不像z-depth方法用于平铺着色，这个细分是在整个视图锥面上执行的，独立于场景中的几何形状。所得到的算法随着摄像机位置的变化性能变化较小，当贴图包含深度不连续时性能更好。集群着色可以应用于前向和延迟着色系统。</strong></p>
<p><strong>由于透视图，贴图的横截面面积会随着距离相机的距离增加而增加。统一的细分方案将为瓦片的截锥创建压扁的或长而薄的体素，这不是最优的。为了补偿，Olsson等人在视图空间中以指数方式集群几何，而不依赖于几何的zmin 和zmax，使集群更立方体化。例如，《Just Cause 3》的开发者使用64 × 64像素的贴图，带有16个深度切片，并在每个轴上尝试了更大的分辨率，以及使用固定数量的屏幕贴图(不管分辨率如何)。Unreal Engine使用相同大小的贴图和典型的32个深度切片。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108201842.png" class="" title="image-20211108201842">

<p>平铺和集群着色，显示在二维。视锥被细分，场景的光体根据重叠区域进行分类。平铺着色在屏幕空间中细分，而聚集也通过z-depth切片进行划分。每一卷都包含一个灯光列表;长度为2或2以上的列表将显示值。如果zmin 并且zmax不计算场景几何体的平铺着色(未显示)，光列表可能包含大量不需要的光。聚集着色不需要渲染的几何体来剔除它的列表，尽管这样一个通道可以帮助。(参见Persson。)</p>
<p><strong>光根据它们重叠的簇进行分类，然后形成列表。通过不依赖于场景几何的z深度，集群可以仅从视图和灯光集计算。每个表面，不透明或透明，然后使用它的位置来检索相关的光列表。集群提供了一个有效的、统一的照明解决方案，适用于场景中的所有对象，包括透明和体积的对象。</strong></p>
<p><strong>与平铺方法一样，使用集群的算法可以与前向着色或延迟着色相结合。例如，Forza Horizon 2在GPU上计算其集群，然后使用前向着色，因为这提供了MSAA支持，而没有任何额外的工作。虽然在单次前向着色时可以实现透支，但其他方法，如粗略的前到后排序或仅对对象的子集执行预处理，可以避免在没有第二次完整几何通过的情况下大量透支。Pettineo发现，即使使用这样的优化，使用单独的z- preass也更快。另外，可以对不透明表面执行延迟着色，使用相同的光列表结构，然后用于透明表面的前向着色。在Just Cause 3中使用了这种方法，它在CPU上创建了light列表。Dufresne也在CPU上并行地生成集群光列表，因为这个过程不依赖于场景中的几何形状。</strong></p>
<p><strong>集群光照分配为每个列表提供更少的光照，并且与平铺方法相比具有更少的视图依赖性。由tiles定义的长而薄的frusta可以从相机的微小移动中产生相当大的内容变化。例如，一排笔直的街灯就可以填满一块瓷砖。即使使用z-depth细分方法，每个贴图的近距离和远距离也会因为单个像素的变化而发生剧烈的变化。集群不太容易受到此类问题的影响。</strong></p>
<p><strong>如前所述，Olsson等人和其他人探索了集群着色的几种优化。一种技术是为光线形成一个BVH，然后用它来快速确定哪些光线体积重叠在给定的簇上。这个BVH需要重建只要至少有一个光移动。一种可用于延迟着色的选项是使用量子化的法线方向剔除集群中的表面。Olsson等人将表面法线按方向分类为一个结构，在一个立方体上每个面拥有3× 3个方向集，共54个位置，以形成一个法锥(第19.3节)。在创建集群列表时，可以使用这个结构进一步剔除光源。也就是集群中所有表面后面的那些。对于大量的光源来说，排序可能会变得非常昂贵，van Oosten探索了各种策略和优化。</strong></p>
<p><strong>当可见的几何位置是可用的，如延迟着色或从z- preass，其他优化是可能的。不包含几何图形的集群可以从处理中消除，从而提供一个需要更少处理和存储的稀疏网格。这样做意味着必须首先对场景进行处理，以找出哪些集群被占用。因为这需要访问深度缓冲区数据，所以集群形成必须在GPU上执行。与星团的体积相比，星团的几何重叠程度可能较小。通过使用这些样品形成一个紧密的AABB来测试，可以筛选出更多的光。优化后的系统可以处理超过100万个光源，并且随着光源数量的增加，其规模也会扩大，同时对少数光源也很有效。</strong></p>
<p><strong>没有必要使用指数函数来细分屏幕z轴，这种细分可能会对有许多远处灯光的场景产生负面影响。在指数分布下，星团体积随深度增加而增加，这可能导致遥远星团的光列表过长。限制了集群集合的最大距离，即光集群的“远平面”，是一种解决方案，更远处的光会逐渐消失，以粒子或眩光表示，或在中烘培。更简单的着色器，lightcuts，或其他层次的细节技术也可以使用。相反地，距离观众最近的音量可能相对较少，但被大量细分。一种方法是将分类截锥的“近平面”强迫到某个合理的距离，并将比这个深度更近的光进行分类，使其落入第一个深度切片。</strong></p>
<p><strong>在《毁灭战士》(2016)中，开发人员使用Olsson等人和Persson的集群方法组合实现了他们的正向着色系统。他们首先执行z-prepass，这大约需要0.5毫秒。他们的列表构建方案可以被认为是剪切空间体素化。光源、环境光探头和贴花通过测试每个单元与代表每个单元的AABB的交集来插入。添加贴花是一个显著的改进，因为集群前向系统获得了延迟着色对这些实体的优势。在前进遮阳引擎循环通过所有贴花发现在一个细胞。如果贴花与表面位置重叠，它的纹理值将被检索并融合。贴花可以以任何想要的方式与底层表面混合，而不是仅限于混合阶段可用的操作，如延迟着色。与群集向前着色贴花也可以呈现在透明的表面。然后应用单元中所有相关的光。</strong></p>
<p><strong>CPU可以用来构建光列表，因为场景的几何形状不是必需的，而且分析测试光体积球体和集群盒的重叠是不贵的。然而，如果涉及到聚光灯或其他光体形状，在它周围使用球形包围体可能会导致在许多没有影响的星团中添加这样的光，而且精确的解析交叉测试可能会很昂贵。沿着这些思路，Persson提供了一种将球体体素化成一组簇的快速方法。</strong></p>
<p><strong>GPU的栅格化流水线可以用来对光体进行分类，以避免这些问题。Ortegren¨和Persson描述了建立光列表的两步过程。在壳层通道中，每个光都由一个低分辨率的网格包围。保守栅格化(章节23.1.2)用于将这些壳渲染到集群网格中，记录每个重叠的最小和最大集群。在填充通道中，计算着色器将光线添加到这些边界之间的每个集群的链表中。使用网格而不是球体的边界为聚光灯提供了更紧密的边界，几何体可以直接遮挡光的可见性，进一步剔除列表。当保守光栅化不可用时，Pettineo描述了一种使用表面梯度保守估计每个像素上三角形的z边界的方法。例如，如果在一个像素处需要距离最远的距离，则使用x和y深度梯度来选择像素的哪个角距离最远，并计算该点的深度。因为这些点可能不在三角形上，所以他也将光源的z深度范围作为一个整体，以避免一个接近边对的三角形将估计的z深度抛得很远。Wronski探索了各种各样的解决方案，他的想法是在周围放置一个边界球一个网格单元，对锥体进行交叉测试。这种测试是快速评估和良好的工作时，细胞是近立方，当拉长。</strong></p>
<p><strong>Drobot描述了网格是如何用于在《使命召唤:无限战争》中插入灯光的。想想静态聚光灯。它在空间中形成一个体积，比如一个锥体。如果不进行进一步的处理，这个锥体可以延伸相当大的距离，既可以延伸到场景的范围，也可以延伸到为光线定义的最大距离。现在想象一下这个聚光灯的阴影贴图，在场景中使用静态几何生成。这个地图定义了光照射的每个方向的最大距离。在烘焙过程中，这个阴影贴图变成了一个低分辨率的网格，然后作为光的有效体积。网格是保守的，在每个阴影贴图区域使用最大深度形成，因此它完全包围了被光照亮的空间体积。这种聚光灯的表现可能会比原始锥的体积重叠更少。</strong></p>
<p><strong>与此过程无关的是，光列表存储和访问方法(称为z- binning)比聚集着色所占用的内存要少得多。在它中，灯光是根据屏幕z深度排序的，并基于这些深度给出ID。一组z-slices，每一个都是相同的深度厚度，而不是指数，然后用来分类这些灯。每个z-slice只存储重叠的灯光的最小和最大ID。参见下图。平铺底纹列表也会生成，几何体剔除是可选的。然后，每个表面位置访问这个二维平铺结构和每个切片的一维z-bin ID范围。平铺列表给出了平铺中可能影响像素的所有灯光。像素的深度检索可能重叠z-slice的ID范围。这两者的重叠是在飞行中计算，并给出有效的光列表的集群。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108202632.png" class="" title="image-20211108202632">

<p>使用z-bin，每个灯都根据它的z深度得到一个ID。生成每个贴图的列表。每个z-bin存储一个最小和最大ID，一个可能重叠切片的保守光源范围。对于标记单元格中的任何像素，我们检索两个列表并找到重叠。</p>
<p><strong>该算法不需要为三维网格中的每个集群创建和存储列表，而只需要为每个二维贴图创建一个列表，并为z片集创建一个固定大小的小数组。需要更少的存储、带宽使用和预计算，但要确定每个像素上的相关光需要多做一些工作。使用z-bin可能会导致一些灯光被错误地分类，但Drobot发现，在人造环境中，xy屏幕坐标和z-深度的灯光之间通常很少有重叠。使用像素和计算着色器，该方案能够在深度不连续的瓷砖中给出近乎完美的剔除。</strong></p>
<p><strong>用于访问对象的三维数据结构通常可以归类为与体积相关的，其中网格或八叉树被施加在空间上;与对象相关，其中形成了包围卷层次结构;或混合，例如在网格单元格的内容周围使用包围体。Bezrati在一个计算着色器中执行平铺着色以形成一个增强的光列表，其中每个光包括它的最小和最大z深度。通过这种方式，一个碎片可以迅速拒绝任何不重叠它的光。O’donnell和Chajdas展示了在CPU一侧形成的平铺光树。他们为每个光源使用带有深度边界的平铺光源列表，并形成一个边界间隔层次。也就是说，他们没有像Olsson等人所做的那样，为所有光源形成一个单独的三维层次，而是从贴图中每个光源的z区创建一个更简单的一维层次。这种结构可以很好地映射到GPU的架构中，并且能够更好地处理大量光照落在一个贴图中的情况。他们还提供了一种混合算法，可以选择将贴图划分为单元格(通常的集群着色方法)还是使用光树。光树在细胞与其光线的平均重叠度较低的情况下工作得最好。</strong></p>
<p><strong>本地灯光列表的想法可以用在移动设备上，但有不同的限制和机会。例如，在移动设备上，以传统的延迟方式一次渲染一盏灯可能是最有效的方法，因为移动设备将G缓冲区保存在本地内存中的独特属性。平铺前向着色可以在支持OpenGL ES 2.0的设备上实现，这在移动GPU上几乎是给定的。通过OpenGL ES 3.0和一个称为像素本地存储的扩展，ARM GPU中可用的基于瓦片的渲染系统可以有效地生成和应用光列表。更多信息请参见billetter的介绍。Nummelin讨论了Frostbite引擎从桌面到移动设备的转换，包括轻分类方案的权衡，因为计算着色器在移动硬件上的支持较少。由于移动设备使用基于平铺的渲染，为延迟着色生成的G缓冲区数据可以在本地内存中维护。Smith和Einig描述了使用framebuffer获取和像素本地存储来实现这一点，发现这些机制将总带宽成本降低了一半以上。</strong></p>
<p><strong>总之，平铺、聚集或其他光列表剔除技术可以用于延迟或向前着色，每种技术也可以应用于贴花。光体剔除算法专注于最小化每个片段的光数，而解耦几何和着色的想法可以用来平衡处理和带宽成本，以最大化效率。就像截锥剔除将花费额外的时间，如果所有对象总是在视图中，那么有些技术在各种条件下提供的好处很少。如果太阳是唯一的光源，则不需要进行光剔除预处理。如果有一点表面透支和少数灯光，延迟着色可能花费更多的时间。对于有许多照明效果有限的场景，无论是使用正向着色还是延迟着色，花时间创建局部光照列表都是值得的。当几何体处理复杂或表面渲染昂贵时，延迟着色提供了一种方法，以避免透支，最小化驱动成本，如程序和状态切换，并使用更少的调用来渲染更大的合并网格。请记住，在渲染单个帧时，可以使用这些方法中的几个。什么使技术的最佳组合不仅取决于场景，而且也可以根据每个对象或每个光的基础而变化。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108203117.png" class="" title="image-20211108203117">

<p>对于典型的桌面GPU，比较传统的单通道前向、延迟和使用延迟和前向阴影的平铺/聚集光分类。</p>
<p><strong>为了总结这一节，我们在上表中总结了不同方法之间的主要差异。“透明度”行中的右箭头表示延迟着色应用于不透明的表面，透明的表面需要前向着色。“小三角形”注意到延迟着色的一个优势，即四倍着色(章节23.1)在正向渲染时效率很低，因为所有四个样本都被充分评估了。“注册压力”指的是涉及着色器的总体复杂性。在着色器中使用许多寄存器意味着形成的线程更少，导致GPU的扭曲未得到充分利用。如果使用着色器流线型方法，那么对于平铺和集群延迟技术，它可能会变得较低。阴影映射重用通常不像以前那么重要，当时GPU内存更有限。</strong></p>
<p><strong>当存在大量光源时，阴影是一个挑战。一种应对方法是忽略除最近和最亮的光和太阳以外的所有光的阴影计算，以冒着从次要光源漏出光线的风险。Harada等人讨论了他们如何在平铺前向系统中使用光线投射，为每个可见表面像素生成一条射线到每个附近的光源。Olsson等人讨论了使用被占用的网格单元作为几何体的代理来生成阴影地图，并根据需要创建样本。他们还提供了一个混合系统，将这些有限的阴影贴图与光线投射结合在一起。</strong></p>
<p><strong>使用世界空间而不是屏幕空间来生成光线列表是另一种构建聚集着色空间的方法。这种方法在某些情况下是合理的，但是对于大的场景，由于内存不足，还是值得避免的约束，并且由于远处的簇将是像素大小的，从而影响性能。Persson提供了一个基本的集群前向系统的代码，其中静态光存储在一个三维世界空间网格中。</strong></p>
<h2 id="Deferred-Texturing-延迟纹理"><a href="#Deferred-Texturing-延迟纹理" class="headerlink" title="Deferred Texturing 延迟纹理"></a>Deferred Texturing 延迟纹理</h2><p><strong>延迟着色避免了透支和计算碎片着色的成本，然后丢弃这些结果。但是，在形成G -buffer时，仍然会发生透支。一个对象被栅格化并检索其所有参数，在此过程中执行多个纹理访问。如果稍后绘制的另一个对象遮挡了这些存储的样本，那么用于绘制第一个对象的所有带宽都被浪费了。一些延迟着色系统执行部分或全z- preass，以避免稍后被另一个对象绘制的表面的纹理访问。然而，如果可能的话，许多系统都会避免额外的几何通道。带宽用于纹理获取，也用于顶点数据访问和其他数据。对于详细的几何图形，一个额外的通道可以使用更多的带宽，而不是它可能节省纹理访问成本。</strong></p>
<p><strong>形成和访问的G缓冲区的数量越多，内存和带宽成本就越高。在一些系统中，带宽可能不是一个问题，因为瓶颈可能主要是在GPU的处理器中。正如在第18章中详细讨论的那样，瓶颈总是存在的，而且它随时都可能改变。为什么会有如此多的效率方案，主要原因是每个方案都是针对特定的平台和场景类型开发的。其他因素，如实现和优化系统的难度、编写内容的便利性以及各种各样的其他人为因素，也可以决定构建什么。</strong></p>
<p><strong>虽然GPU的计算能力和带宽能力都随着时间的推移而提高，但它们的增长速度不同，计算能力的增长速度更快。这一趋势，加上GPU上的新功能，意味着一种防止系统未来的方法是将瓶颈瞄准GPU计算，而不是缓冲区访问。</strong></p>
<p><strong>一些不同的方案已经开发出来，使用单一的几何通道，避免检索纹理，直到需要。Haar和Aaltonen描述了虚拟延迟纹理是如何在《刺客信条:大革命》中使用的。他们的系统管理本地8192 × 8192的可见纹理图集，每个图集的分辨率都是128 × 128，都是从更大的纹理集中选择的。这个图集大小允许存储(u, v)纹理坐标，可以用来访问图集中的任何texel。有16位用来存储坐标;8192个位置需要13位，这就剩下3位，即8级，亚像素精度。32位的切线基也被存储，编码为四元数(章节16.6)。这样做意味着只需要一个64位G缓冲区。由于没有在几何通道中执行纹理访问，透支可以是非常便宜的。在这个G缓冲区建立之后，在着色过程中访问虚拟纹理。梯度是mipmapping所需要的，但不存储。相反，将检查每个像素的邻居，并使用那些与(u, v)值最接近的在飞行中计算梯度。材质ID也来自于确定哪个纹理贴图被访问，通过将纹理坐标值除以128来完成，即纹理分辨率。</strong></p>
<p><strong>在这个游戏中使用的另一种降低阴影成本的技术是在四分之一分辨率下渲染，并使用特殊形式的MSAA。在使用AMD GCN的控制台，或使用opengl4.5、OpenGL ES 3.2或其他扩展的系统上，MSAA采样模式可以根据需要设置。Haar和altonen将网格模式设置为4× MSAA，使每个网格样本直接对应于全屏像素的中心。通过四分之一分辨率的渲染，他们可以利用MSAA的多次采样特性。(u, v)和切线基可以在没有损失的情况下在表面上插值，并且8× MSAA(相当于每像素2× MSAA)也是可能的。当渲染场景有相当大的透支，如树叶和树木，他们的技术显著减少了着色器调用的数量和G缓冲区的带宽成本。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108203452.png" class="" title="image-20211108203452">

<p>在可见性缓冲区的第一步中，只有三角形和实例ID被渲染并存储在一个G缓冲区中，这里每个三角形都有不同的颜色。(图片来源:Graham Wihlidal-Electronic Arts )</p>
<p><strong>只存储纹理坐标和基础是非常简单的，但其他方案也是可行的。Burns和Hunt描述了他们所谓的可见性缓冲区，其中存储了两部分数据，一个三角形ID和一个实例ID。参见上图。几何通道着色器非常快，没有纹理访问，只需要存储这两个ID值。所有三角形和顶点数据——位置、法线、颜色、材质等等——都存储在全局缓冲区中。在延迟着色过程中，为每个像素存储的三角形和实例id用于检索这些数据。该像素的视图射线与三角形相交，以找到重心坐标，用于插值三角形的顶点数据。其他通常不太频繁的计算也必须按像素执行，例如顶点着色器计算。纹理梯度值也是从头计算每个像素，而不是插值。然后，所有这些数据都被用来给像素着色，并使用任何所需的分类方案进行光照。</strong></p>
<p><strong>虽然这一切听起来都很昂贵，但请记住，计算能力的增长速度要快于带宽能力。这项研究倾向于一个计算量很大的管道，以最大限度地减少由于透支造成的带宽损失。如果场景中有少于64k的网格，并且每个网格有少于64k的三角形，那么每个ID长度为16位，g缓冲区可以小到每像素32位。更大的场景将这个数字推到48或64位。</strong></p>
<p><strong>Stachowiak描述了可见性缓冲区的一种变体，它使用了GCN架构上可用的一些功能。在初始通过过程中，三角形上位置的重心坐标也会被计算并按像素存储。一个GCN片段(即着色器可以廉价地计算重心坐标，相比之下，之后执行单个射线/每个像素的三角形相交。虽然需要额外的存储空间，但这种方法有一个重要的优点。对于动画网格，原始的可见性缓冲区方案需要将任何修改过的网格数据流输出到缓冲区，以便在延迟着色期间可以检索到修改过的顶点位置。保存转换后的网格坐标会消耗额外的带宽。通过在第一次传递中存储重心坐标，我们就完成了顶点位置的处理，不需要再次获取顶点位置，这是原始可见性缓冲区的一个缺点。然而，如果需要与相机的距离，这个值也必须在第一次通过时存储，因为以后无法重建。</strong></p>
<p><strong>这个管线可以解耦几何和阴影频率，类似于以前的方案。Aaltonen指出，MSAA网格采样方法可以应用于每一种方法，从而进一步减少所需的平均内存数量。他还讨论了这三种方案中存储布局的变化以及计算成本和能力的差异。Schied和Dachsbacher走了相反的方向，建立在可见性缓冲区上，并使用MSAA功能来减少内存消耗和阴影计算，以实现高质量的抗锯齿。</strong></p>
<p><strong>Pettineo指出，无绑定纹理功能(章节6.2.5)的可用性使得延迟纹理的实现更加简单。他的延迟纹理系统创建了一个更大的G缓冲区，存储深度、单独的材质ID和深度梯度。绘制了Sponza模型，将该系统的性能与带有和不带有z- preass的集群前向方法进行了比较。当关闭MSAA时，延迟纹理总是比前向着色快，而当应用MSAA时则慢。正如在第5.4.2节中所提到的，随着屏幕分辨率的提高，大多数电子游戏都不再使用MSAA，而是依赖于时间抗锯齿，所以在实践中这种支持并不是那么重要。</strong></p>
<p><strong>Engel指出，由于在DirectX 12和Vulkan中暴露了API特性，可见性缓冲区的概念变得越来越有吸引力。裁剪三角形集(第19.8节)和其他使用计算着色器执行的移除技术减少了栅格化的三角形数量。DirectX 12的ExecuteIndirect命令可以是用于创建一个等效的优化索引缓冲区，只显示那些没有被剔除的三角形。当与高级的剔除系统一起使用时，他的分析表明，在San Miguel场景的所有分辨率和抗锯齿设置下，可见缓冲的性能都优于延迟着色。随着屏幕分辨率的提高，性能差距也在增大。GPU的API和功能的未来变化可能会进一步提高性能。Lauritzen讨论了可见性缓冲区，以及如何发展GPU以改进在延迟设置中访问和处理材质着色器的方式。</strong></p>
<p><strong>Doghramachi和Bucci详细讨论了他们的延迟纹理系统，他们称之为延迟+。他们的系统很早就集成了侵略性的淘汰技术。例如，对前一帧的深度缓冲进行下采样和重投影，为当前场景中的每个像素提供保守的剔除深度。这些深度有助于测试在绘制截锥中可见的所有网格的边界体时的遮挡，如19.7.2节中简要讨论的那样。他们注意到，如果有alpha切割纹理，必须在任何初始通道中访问(或者任何z- preass)，这样切割后的对象就不会被隐藏。剔除和栅格化过程的结果是一组G缓冲器，其中包括深度、纹理坐标、切线空间、梯度和材质ID，这些用于遮蔽像素。虽然它的G缓冲区的数量比其他延迟纹理方案更高，但它确实避免了不必要的纹理访问。对于《杀出重头戏:人类分裂》中的两个简化场景模型，他们发现延迟+比聚集向前着色运行得更快，并相信更复杂的材料和照明将进一步扩大差距。他们还指出，翘曲的使用明显更好，这意味着小三角形造成的问题更少，所以GPU镶嵌性能更好。他们的延迟纹理实现比延迟着色还有其他几个优点，比如能够更有效地处理更广泛的材质。主要的缺点是在大多数延迟方案中常见的，与透明性和抗锯齿有关。</strong></p>
<h2 id="Object-and-Texture-Space-Shading-物体和纹理空间着色"><a href="#Object-and-Texture-Space-Shading-物体和纹理空间着色" class="headerlink" title="Object- and Texture-Space Shading 物体和纹理空间着色"></a>Object- and Texture-Space Shading 物体和纹理空间着色</h2><p><strong>将几何图形采样速率与阴影值计算速率解耦的想法是本章中反复出现的主题。在这里，我们将介绍几种不同的方法，它们不容易归入到目前为止所介绍的类别中。特别地，我们讨论了利用Reyes批处理渲染器中首次看到的概念的混合方法，该方法被皮克斯和其他公司用于制作他们的电影多年。现在，工作室主要使用一些形式的光线或路径跟踪来渲染，但在当时，Reyes以一种创新和有效的方式解决了几个渲染问题。</strong></p>
<p><strong>雷耶斯的关键概念是微多边形的概念。每一个表面都被切成一个极其精细的四边形网格。在原来的系统中，切丁是完成的对于眼睛，其目标是使每个微多边形的宽度和高度约为像素的一半，以便维持奈奎斯特限制(第5.4.1节)。截锥外的四边形或面向眼睛外的四边形被剔除。在这个系统中，微多边形被着色，并分配一个单一的颜色。这种技术发展到对微多边形网格中的顶点进行着色。我们在这里的讨论集中在最初的系统上，因为它探索了一些想法。</strong></p>
<p><strong>每个微多边形被插入到一个像素-亚采样z缓冲区中一个抖动的4 × 4样本网格中。抖动是为了通过产生噪声来避免混叠。因为在栅格化之前，着色与微多边形的覆盖有关，这种技术被称为基于对象的着色。将其与前向着色(在栅格化期间，着色在屏幕空间中发生)和延迟着色(在栅格化之后发生)进行比较。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108225002.png" class="" title="image-20211108225002">

<p>雷耶斯渲染管线。每个对象被镶嵌成微多边形，然后分别着色。每个像素的一组抖动样本(红色)与微多边形进行比较，结果用于渲染图像。</p>
<p><strong>物体空间中的着色的一个优点是材质纹理通常直接与它们的微多边形相关。也就是说，几何对象可以细分，这样每个微多边形的像素数都是2的幂。在着色过程中，精确过滤的mipmap样本可以被微多边形检索，因为它直接与表面着色面积相关。原始的Reyes系统还意味着缓存相干访问纹理发生，因为微多边形是按顺序访问的。这种优势并不适用于所有的纹理，例如，用作反射贴图的环境纹理必须用传统的方法进行采样和过滤。</strong></p>
<p><strong>动态模糊和景深效果也可以很好地配合这种安排。对于运动模糊，每个微多边形在帧间隔的抖动时间沿其路径分配一个位置。因此，每个微多边形将在移动方向上有不同的位置，从而产生模糊。景深以类似的方式实现，基于混沌圆分布微多边形。</strong></p>
<p><strong>Reyes算法有一些缺点。所有的物体都必须能够被镶嵌，并且必须被切得很细。着色影在z缓冲区的遮挡测试之前发生，所以可能会由于透支而浪费。在奈奎斯特极限取样并不意味着高频现象如尖锐的镜面高光被捕获，而是取样足以重建较低的频率。</strong></p>
<p><strong>通常，每个对象必须是“图表”，换句话说，必须有(u, v)纹理值的顶点，给每个不同的区域一个独特的texel模型。示例请参见第23页的图2.9和第173页的图6.6。基于对象的着色可以被认为是第一次在着色中烘焙，使用相机来确定依赖于视图的效果，并可能限制为每个表面区域所花费的精力。在GPU上执行基于对象的着色的一个简单方法是将对象细分到一个精细的亚像素级，然后在网格上着色每个顶点。这样做可能会很昂贵，因为每个三角形的设置成本并没有在多个像素上平摊。由于四元渲染(章节23.1)，单像素三角形会生成4个像素着色器调用。gpu被优化以渲染覆盖相当数量像素的三角形，例如，16或更多(章节23.10.3)。</strong></p>
<p><strong>Burns等人通过在确定哪些物体位置是可见的后执行物体空间着色来探索物体空间着色。他们用一个“多边形网格”来确定这些对象，这个对象被切分、尽可能剔除，然后栅格化。然后使用一个独立的物体空间“着色网格”来遮蔽可见区域，每个texel对应于表面的一个区域。阴影网格可以是一个不同的分辨率比多边形网格。他们发现，精细的镶嵌几何表面几乎没有什么好处，因此将两者分离可以更有效地利用资源。他们只在模拟器上实现了他们的工作，但他们的技术已经影响了新的研究和发展。</strong></p>
<p><strong>从Reyes获得灵感的大量研究已经在GPU上针对各种现象检测了更快的着色方法。Ragan-Kelley等人提出了一种基于解耦采样的硬件扩展，将他们的思想应用于运动模糊和景深。样本有五个维度:两个是亚像素位置，两个是镜头位置，一个是时间。能见度和着色分别采样。“解耦映射”决定了给定可见性样本所需的着色样本。Liktor和Dachsbacher提出了一个类似的延迟着色系统，其中着色样本在计算和使用随机栅格化时被缓存。像运动模糊和景深这样的效果不需要高采样率，所以着色计算可以重复使用。Clarberg等人提出了在纹理空间中计算着色的硬件扩展。这样就消除了四边形的遮蔽问题，从而允许更小的三角形。由于着色是在纹理空间中计算的，当从纹理中查找着色时，像素着色器可以使用双线性过滤器或更复杂的过滤器。这可以通过降低纹理分辨率来降低着色成本。对于低频项，这种技术通常工作得很好，因为可以使用滤波。</strong></p>
<p><strong>Andersson等人采用了一种不同的方法，称为纹理空间着色。对每个三角形进行截锥和背面剔除测试，然后将其绘制的表面应用到输出目标的相应区域，基于其(u, v)参数化对这个三角形进行着色。同时，使用一个几何着色器，每个可见三角形的大小在相机的视图被计算。这个大小值用于确定将在哪个类mipmap级别插入三角形。通过这种方式，对一个对象执行的着色量与它的屏幕覆盖有关。参见下图。他们使用随机栅格化来渲染最终的图像。生成的每个片段都向上查找它的着色颜色从纹理。同样，计算出的着色值可以用于运动模糊和景深效果。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108225412.png" class="" title="image-20211108225412">

<p>对象空间纹理着色。左边是最终渲染，包括动态模糊。图表中间显示了可见的三角形。在右侧，每个三角形都根据三角形的屏幕覆盖率以适当的mipmap级别插入，以便在最终的基于相机的光栅化过程中使用。(转载由M. Andersson和英特尔公司许可，版权为英特尔公司，2014年。)</p>
<p><strong>Hillesland和Yang基于纹理空间着色概念，以及类似Liktor和Dachsbacher的缓存概念。他们将几何图形绘制到最终视图，使用计算着色器填充基于对象的纹理结果的类似于mipmap的结构，并再次渲染几何图形以访问这个纹理并显示最终的着色。一个三角形ID可见缓冲区也被保存在第一个通道中，以便他们的计算着色器可以稍后访问顶点属性进行插值。他们的系统包括随时间的一致性。由于材质是在物体空间中，所以对于每一帧，相同的区域与相同的输出纹理位置相关联。如果在给定的mipmap级别上的表面积的着色是以前计算过的，并且不是太旧，那么它将被重用，而不是重新计算。结果会随着材质、光照和其他因素的变化而变化，但他们发现每隔60帧重复使用一个着色样本会导致可以忽略的错误。他们还确定，mipmap级别不仅可以通过屏幕大小来选择，还可以通过其他因素的变化来选择，比如在一个区域上的法向变化。更高的mipmap级别意味着每个屏幕片段计算的阴影更少，他们发现这可以带来可观的节省。</strong></p>
<p><strong>Baker描述了Oxide Games为游戏《Ashes of the Singularity》设计的渲染器。它是受Reyes的启发，尽管实现细节是相当不同的，并为每个模型作为一个整体使用纹理空间着色。物体表面可以覆盖任意数量的材料，通过使用遮罩来区分。他们的流程是:</strong></p>
<pre><code>**•几个大4k × 4k，每个通道16位-“主”纹理被分配用于着色。**

**•对所有对象进行评估。如果在视图中，则计算物体在屏幕上的估计面积。**

**•这个区域用于为每个对象分配一个主纹理的比例。如果请求的总面积大于纹理空间，则按比例缩小以使请求适合。**

**•基于纹理的着色是在计算着色器中执行的，每个附加到模型的材质依次应用。每个材质的结果都累积在指定的主纹理中。**

**•根据需要计算主纹理的Mipmap级别。**

**•对象被栅格化，主纹理用于遮蔽它们。**
</code></pre>
<p><strong>使用多个材料每个对象允许这样的效果，如有一个单一的地形模型，包括泥土，道路，地面覆盖，水，雪，和冰，每一个都有自己的材料BRDF。如果需要的话，抗锯齿在像素级和着色级都可以工作，因为在着色过程中可以获得关于物体表面面积和它与主纹理关系的完整信息。例如，这种能力允许系统稳定地处理具有极高反射能力的模型。因为着色结果是作为一个整体附加到对象上的，无论能见度如何，着色也可以以不同于栅格化的帧率计算。30帧/秒的着色已经足够了，光栅化在60帧/秒，或者虚拟现实系统在90帧/秒。拥有异步着色意味着即使着色器负载变得太高，几何图形的帧率也可以保持。</strong></p>
<p><strong>在实施这样一个系统时，有几个挑战。由于每个对象的“材料四边形”在对象着色步骤中都是用计算着色器处理的，然后在栅格化过程中绘制对象，所以与典型的游戏引擎相比，发送的批大约是前者的两倍。然而，大多数批处理都很简单，像DirectX 12和Vulkan这样的API有助于减少开销。如何根据对象的大小分配主纹理对图像质量有很大的影响。在屏幕上较大的物体，或者不同的像素密度(如地形)，都可能有问题。执行额外的拼接过程用于在主纹理中保持不同分辨率的地形块之间的平滑过渡。屏幕空间技术，如环境遮挡，是一个挑战实现。像原来的可见性缓冲区一样，影响物体形状的动画必须做两次，用于着色和栅格化。物体被遮蔽，然后被遮挡，这是一种浪费。对于具有较低深度复杂性的应用程序，如实时策略游戏，这种成本可能相对较低。每个材质都很容易评估，不像复杂的延迟着色器，而且着色是在整个对象的图表上完成的。带有简单着色器的物体，如粒子和树，从这项技术中得到的好处很少。为了提高性能，这些效果可以用正向着色来代替渲染。如下图所示，能够处理许多灯光可以使渲染的场景更加丰富。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211108225646.png" class="" title="image-20211108225646">

<p>奇点的灰烬被大约一千盏灯照亮的场景。这包括每辆车和每颗子弹至少有一个光源。(图片由Oxide Games和Stardock Entertainment提供。)</p>
<p><strong>关于高效着色的讨论到此结束。我们只是触及了一整套专门技术，以提高速度和质量的结果使用不同的应用程序。我们的目标是提出常用的算法来加速着色，并解释它们是如何和为什么产生的。随着图形硬件功能和API的发展，以及屏幕分辨率、美术工作流程和其他元素的变化，高效的着色技术将继续以新的、可能是意想不到的方式被研究和开发。</strong></p>
<p><strong>如果您已经通读了本书，那么您现在已经掌握了现代交互式渲染引擎的主要算法的工作知识。我们的目标之一是让您快速了解该领域的最新文章和演示。如果您希望了解这些元素如何协同工作，我们强烈推荐您阅读Courr’eges和anagnosto关于不同商业渲染器的优秀文章。在此之后，接下来的章节将深入探讨几个领域，如虚拟现实和增强现实的渲染、交集和碰撞检测的算法，以及图形硬件的架构特性。</strong></p>
<h1 id="21-Virtual-and-Augmented-Reality-虚拟现实与增强现实"><a href="#21-Virtual-and-Augmented-Reality-虚拟现实与增强现实" class="headerlink" title="21 Virtual and Augmented Reality 虚拟现实与增强现实"></a>21 Virtual and Augmented Reality 虚拟现实与增强现实</h1><p><strong>虚拟现实(VR)和增强现实(AR)是试图以现实世界的方式刺激你的感官的技术。在计算机图形学领域，增强现实技术将合成对象与我们周围的世界整合在一起;虚拟现实完全取代了世界。参见下图。本章重点介绍特定于这两种技术的渲染技术，这两种技术有时使用“XR”组合在一起，其中X可以代表任何字母。本文的重点将主要放在虚拟现实技术上，因为在撰写本文时，虚拟现实技术的应用更为广泛。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211110125037.png" class="" title="image-20211110125037">

<p>前三位作者使用了各种VR系统。托马斯使用HTC Vive手机;Eric在Birdly - fly-like-a-bird模拟器;Naty使用Oculus Rift。</p>
<p><strong>渲染只是这些领域的一小部分。从硬件的角度来看，使用了某些类型的GPU，这是系统中很容易理解的一部分。创造准确和舒适的头部追踪传感器，有效的输入设备(可能带有触觉反馈或眼球追踪控制)，舒适的头饰和光学设备，以及令人信服的音频，是系统创造者面临的挑战。平衡性能、舒适度、移动自由度、价格和其他因素，使其成为一个苛刻的设计空间。</strong></p>
<p><strong>我们专注于交互渲染以及这些技术影响图像生成的方式，首先简要介绍了目前可用的各种虚拟和增强现实系统。然后讨论了一些系统的sdk和api的功能和目标。我们以特定的计算机图形技术结束，这些技术应该避免或修改，以提供最佳的用户体验。</strong></p>
<h2 id="Equipment-and-Systems-Overview-设备与系统概述"><a href="#Equipment-and-Systems-Overview-设备与系统概述" class="headerlink" title="Equipment and Systems Overview 设备与系统概述"></a>Equipment and Systems Overview 设备与系统概述</h2><p><strong>除了中央处理器(CPU)和图形处理器(GPU)，虚拟现实和增强现实图形设备也可以分为传感器和显示器。传感器包括跟踪器，可以检测用户的旋转和位置，以及大量的输入方法和设备。在显示方面，一些系统依赖于使用手机屏幕，而手机屏幕在逻辑上分为两部分。专用系统通常有两个独立的显示器。显示器是用户在虚拟现实系统中看到的全部内容。对于增强现实，虚拟是通过特殊设计的光学设备与真实世界的视图相结合的。</strong></p>
<p><strong>虚拟现实和增强现实是一个古老的领域，最近经历了新、低成本系统的爆炸式增长，这在很大程度上是直接或间接地由于各种移动和主机技术的可用性。手机可以用于沉浸式体验，有时效果惊人。移动电话可以放置在头戴式显示器(HMD)中，从简单的显示器(如谷歌)到免提并提供额外输入设备(如GearVR)的显示器。手机的重力、磁北和其他机制的方向传感器可以确定显示器的方向。方向，也称为姿态，有三个自由度，例如偏航、俯仰和滚转，如4.2.1.1节所讨论的，API可以以一组欧拉角、一个旋转矩阵或一个四元数返回方向。真实世界的内容，如固定视角的全景图和视频，可以很好地在这些设备上运行，因为为用户呈现正确的二维视图的成本相当低。</strong></p>
<p><strong>移动设备相对适中的计算能力，以及GPU和CPU硬件扩展使用的功率需求，限制了它们的功能。在虚拟现实设备中，用户的头戴式耳机通过一组电线与固定的计算机相连，这限制了机动性，但允许使用更强大的处理器。</strong></p>
<p><strong>我们将简要介绍两个系统的传感器，Oculus Rift和HTC Vive。两者都提供六自由度(6-DOF)跟踪:方向和位置。Rift通过多达三个独立的红外摄像机跟踪HMD和控制器的位置。当耳机的位置由固定的外部传感器确定时，这被称为由外而内跟踪。耳机外部的一组红外发光二极管可以跟踪它。Vive使用了一对“灯塔”，以快速的间隔将不可见的光线照射到房间里，耳机里的传感器和控制器通过检测来三角定位它们的位置。这是一种由内而外的跟踪，传感器是HMD的一部分。</strong></p>
<p><strong>手动控制器是一种标准设备，与鼠标和键盘不同，它具有可追踪性，能够随用户移动。基于各种技术，许多其他类型的输入设备已经为VR开发出来。这些设备包括手套或其他肢体或身体追踪设备、眼球追踪设备，以及那些模拟原地运动的设备，如压力垫、单向或全方位跑步机、固定自行车和真人大小的仓鼠球，等等。除了光学系统，基于磁、惯性、机械、深度探测和声学现象的跟踪方法已经被探索。</strong></p>
<p><strong>增强现实被定义为计算机生成的内容与用户的真实世界视图相结合。任何提供在图像上覆盖文本数据的平视显示器(HUD)的应用程序都是增强现实的基本形式。2009年推出的Yelp Monocle可以在摄像头的视角上覆盖企业用户的评级和距离。谷歌Translate的移动版本可以用翻译后的等价物替换符号。《Pok´emon GO》等游戏将虚拟生物覆盖在真实环境中。Snapchat可以检测面部特征，并添加服装元素或动画。</strong></p>
<p><strong>混合现实(MR)是增强现实的子集，其中真实世界和三维虚拟内容实时混合和交互。混合现实的一个经典用例是在手术中，病人器官的扫描数据与外部身体的摄像机视图合并。这个场景假设一个具有相当计算能力和精度的系绳系统。另一个例子是与一只虚拟袋鼠“捉迷藏”，现实世界的墙壁可以隐藏你的对手。在这种情况下，移动性更重要，而注册或其他影响质量的因素则不那么重要。</strong></p>
<p><strong>在这个领域使用的一项技术是在HMD的前面安装一个摄像机。例如，每个HTC Vive都有一个前置摄像头，开发者可以使用。这个世界的视图被发送到眼睛，合成图像可以与它合成。这有时被称为通过AR或VR，或中介现实，在这种情况下，用户不能直接观看环境。使用这种视频流的一个优点是，它允许更多地控制虚拟对象与真实对象的合并。不利的一面是，人们对现实世界的感知存在一定的滞后。Vrvana的Totem和Occipital的Bridge都是使用这种安排的头戴式显示器的AR系统的例子。</strong></p>
<p><strong>在本书写作之时，微软的HoloLens是最著名的混合现实系统。这是一个不受束缚的系统，CPU、GPU和微软所说的HPU(全息处理单元)都内置在耳机中。HPU是一种定制芯片，由24个数字信号处理核心组成，功耗小于10瓦。这些核心用于处理来自kinect摄像机的世界数据。这种视图，连同其他传感器，如加速度计，执行由内到外的跟踪，还有一个额外的优势，即不需要灯塔，QR码(又称基准)或其他外部元素。HPU用于识别一组有限的手势，这意味着不需要额外的输入设备基本交互。在扫描环境的同时，HPU还可以提取深度并导出几何数据，如表示世界表面的平面和多边形。这个几何图形可以用于碰撞检测，例如，让虚拟对象坐在真实世界的桌面。</strong></p>
<p><strong>通过创建真实世界的路径点(称为空间锚点)，使用HPU进行跟踪，可以在世界任何地方有效地实现更大范围的运动。然后相对于特定的空间锚设置虚拟对象的位置。该设备对这些锚定位置的估计也可以随着时间的推移而提高。这些数据可以共享，这意味着少数用户可以在相同的位置看到相同的内容。还可以定义锚，以便不同位置的用户可以在同一模型上协作。</strong></p>
<p><strong>一对透明屏幕可以让用户看到世界以及投影到这些屏幕上的任何东西。请注意，这不同于手机使用的增强现实技术，后者的世界景色是由相机捕捉的。使用透明屏幕的一个优点是，世界本身不会有延迟或显示问题，也不会消耗处理能力。这种类型的显示系统的一个缺点是虚拟内容只能增加用户对世界的看法的亮度。例如，一个黑暗的虚拟物体不会遮挡它后面更亮的真实物体，因为光线只能增加。这可以给虚拟对象一个半透明的感觉。全息透镜还有一个液晶调光器，可以帮助避免这种影响。通过适当的调整，该系统可以有效地显示与现实相融合的三维虚拟对象。</strong></p>
<p><strong>苹果的ARKit和谷歌的ARCore帮助开发者为手机和平板电脑开发增强现实应用。标准是显示单一(不是立体)视图，设备与眼睛保持一定距离。物体可以是完全不透明的，因为它们被覆盖在摄像机的视野中。参见下图。对于ARKit来说，由内到外的跟踪是通过使用设备的动作感应硬件以及摄像头可见的一系列显著功能来实现的。逐帧跟踪这些特征点有助于精确确定设备的当前位置和方向。与HoloLens一样，水平和垂直表面被发现，并确定范围，然后将这些信息提供给开发商。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211110130022.png" class="" title="image-20211110130022">

<p>来自ARKit的图像。接地面被检测到并显示为蓝色网格。最近的豆袋椅是一个添加在地面上的虚拟物体。它缺少阴影，尽管可以为物体添加阴影，并在场景中混合。(图片由Autodesk, Inc.提供)</p>
<p><strong>英特尔的Project Alloy是一种不系绳的头戴式显示器，像HoloLens一样，它有一个传感器阵列，可以探测房间里的大型物体和墙壁。与HoloLens不同，HMD不能让用户直接看到世界。然而，它感知周围环境的能力赋予了英特尔所谓的“合并现实”，即现实世界中的物体可以在虚拟世界中具有令人信服的存在感。例如，用户可以在虚拟世界中触摸控制台，在现实世界中触摸桌子。</strong></p>
<p><strong>虚拟和增强现实传感器和控制器正在经历快速发展，令人着迷的技术以惊人的速度出现。它们承诺提供更少干扰的耳机，更多的移动性和更好的体验。例如，谷歌的Daydream VR和高通的Snapdragon VR头盔都是不系线的，使用的是由内到外的位置跟踪，不需要外部传感器或设备。惠普、Zotac和MSI公司的系统将计算机安装在你的背部，使其成为提供更多计算能力的不受束缚的系统。英特尔的WiGig线-less网络技术使用短距离90ghz无线电将图像从个人电脑发送到耳机。另一种方法是在云上进行昂贵的光照计算，然后将压缩后的信息发送给耳机中较轻、功能较弱的GPU进行渲染。软件方法，如获取点云，体素化这些，并以交互速率渲染体素化表示，为虚拟和真实的融合开辟了新的途径。</strong></p>
<p><strong>本章的大部分内容都集中在显示器及其在VR和AR中的使用上。我们首先浏览了图像如何在屏幕上显示的一些物理机制以及涉及的一些问题。本章继续介绍sdk和硬件系统为简化编程和增强用户对场景的感知提供了什么。本节之后是关于这些不同因素如何影响图像生成的信息，并讨论了需要如何修改或可能完全避免某些图形技术。最后，我们讨论了渲染方法和硬件增强，以提高效率和参与者的体验。</strong></p>
<h2 id="Physical-Elements-物理原理"><a href="#Physical-Elements-物理原理" class="headerlink" title="Physical Elements 物理原理"></a>Physical Elements 物理原理</h2><p><strong>本节介绍现代VR和AR系统的各种组件和特性，特别是与图像显示相关的组件和特性。这些信息为理解供应商提供的工具背后的逻辑提供了一个框架。</strong></p>
<h3 id="Latency-延迟"><a href="#Latency-延迟" class="headerlink" title="Latency 延迟"></a>Latency 延迟</h3><p><strong>缓解延迟的影响在VR和AR系统中尤其重要，这通常是最关键的问题。我们在第3章讨论了GPU如何隐藏内存延迟。这种类型的延迟是由纹理获取等操作引起的，是整个系统的一小部分所特有的。这里我们指的是整个系统的“运动到光子”延迟。也就是说，假设你开始把头转向左边。从你的头朝向某一特定方向，到从该方向产生的图像被显示，需要多长时间?从检测用户输入(例如，头部方向)到响应(显示的新图像)，链中每一块硬件的处理和通信成本加起来需要几十毫秒的延迟。</strong></p>
<p><strong>带有常规显示监视器的系统中的延迟(例如。最坏的情况下，它会让人恼火，破坏互动和联系的感觉。对于增强现实和混合现实应用，较低的延迟将有助于提高“像素粘性”，即场景中的虚拟对象与现实世界的贴合程度。系统中的延迟越长，相对于真实世界中的对应对象，虚拟对象看起来越像在游动或漂浮。在沉浸式虚拟现实中，显示器是唯一的视觉输入，延迟可以创造一组更激烈的效果。虽然不是真正的疾病，但它被称为模拟病，会导致出汗、头晕、恶心和更糟的情况。如果你开始感到不适，立即摘下HMD——你无法“通过”这种不适，只会变得更糟糕。引用卡马克的话说，“不要强迫。我们不需要在演示室里清理病人。“在现实中，真正的呕吐很少见，但其影响可能很严重，使人虚弱，可以持续一天。</strong></p>
<p><strong>在虚拟现实中，当显示的图像与用户的期望或其他感官(如内耳平衡和运动的前庭系统)的感知不匹配时，就会出现“模拟病”。头部运动与显示图像匹配的时间差越小越好。一些研究指出15毫秒是难以察觉的。超过20毫秒的延迟肯定可以被感知到，并且会产生有害的影响。相比之下，从鼠标移动到显示，电子游戏通常有50毫秒或更多的延迟，如果没有垂直同步，则有30毫秒(章节23.6.2)。在VR系统中，90 FPS的显示率是很常见的，即帧时间为11.1 ms。在一个典型的桌面系统上，通过电缆扫描帧到显示器大约需要11毫秒，所以即使你能在1毫秒内渲染，你仍然会有12毫秒的延迟。</strong></p>
<p><strong>有许多以应用为基础的技术可以预防或改善不适。这些方法包括最小化视觉流(游戏邦注:如在前进过程中不让用户看向侧面或避免爬楼梯)，以及更多心理学方法，如播放环境音乐或呈现一个代表用户鼻子的虚拟物体。更柔和的颜色和更暗的灯光也可以帮助避免模拟病。使系统的响应与用户的操作和期望相匹配是提供一个愉快的虚拟体验。让所有的物体响应头部的运动，不要缩放相机或改变视野，适当缩放虚拟世界，不要让相机远离用户，这些都是一些指导方针。在用户周围有一个固定的视觉参考，如汽车或飞机驾驶舱，也可以减少模拟器晕机。应用于用户的视觉加速可能会引起不适，所以使用恒定的速度是最好的。硬件解决方案也可能被证明是有用的。例如，三星(Samsung)的Entrim 4D耳机会发出微小的电脉冲，影响前庭系统，从而使用户能够根据自己的平衡感判断所看到的东西。时间会证明这项技术的有效性，但这是一个迹象，表明有多少研究和开发正在做，以减轻模拟病的影响。</strong></p>
<p><strong>跟踪姿势，或简单的姿势，是方向和，如果可能，观众的头部在现实世界的位置。姿态用于形成渲染所需的相机矩阵。在一帧开始时，可以使用对姿态的粗略预测来进行模拟，例如角色和环境元素的碰撞检测。当渲染即将开始时，一个更新的姿态预测可以在那一刻被检索并用于更新相机的视图。这种预测将更准确，因为它稍后被检索并且持续时间更短。当图像即将显示时，另一个更准确的姿态预测仍然可以被检索，并用于扭曲图像，以更好地匹配用户的位置。每一个后来的预测都不能完全弥补先前不准确预测的计算，但尽可能地使用它们可以大大提高整体体验。各种钻机的硬件增强提供了在需要时快速查询和获取更新头部姿态的能力。</strong></p>
<p><strong>除了视觉效果之外，还有其他元素能够让玩家在虚拟环境中进行更有说服力的互动，但如果图像设计不当，玩家的体验将会非常糟糕。减少延迟和提高应用程序的真实感可以帮助实现沉浸感或在场感，在这种情况下，界面会消失，参与者会觉得自己是虚拟世界的一部分。</strong></p>
<h3 id="Optics-光学"><a href="#Optics-光学" class="headerlink" title="Optics 光学"></a>Optics 光学</h3><p><strong>设计精确的物理光学来将头戴式显示器的内容映射到视网膜上的相应位置是一项昂贵的任务。让虚拟现实显示系统价格合理的是，GPU生成的图像在单独的后处理过程中被扭曲，以便正确地到达我们的眼睛。</strong></p>
<p><strong>VR系统的镜头向用户呈现的是一个具有针垫变形的大视场图像，图像的边缘似乎向内弯曲。如下图中右侧所示，通过使用桶形失真对每个生成的图像进行扭曲，可以抵消这一效果。光学系统通常也会受到色差的影响，镜片会导致颜色分离，就像棱镜一样。这个问题也可以由厂商的软件来弥补，生成的图像具有倒色分离。另一种是色差方向。“当通过虚拟现实系统的光学系统显示时，这些不同的颜色会恰当地结合在一起。这种校正可以在扭曲的一对图像边缘的橙色边缘上看到。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211110130550.png" class="" title="image-20211110130550">

<p>原始的渲染目标(左)和它们的扭曲版本(右)显示在HTC Vive上。(图片由Valve提供)</p>
<p><strong>有两种类型的显示，滚动和全局。对于这两种类型的显示，图像以串行流的形式发送。在滚动显示中，该流被接收后立即逐行显示。在全局显示中，一旦接收到整个图像，它就会以单个短脉冲显示。在虚拟现实系统中，每种显示器都有其各自的优点。与全局显示(在显示之前必须等待整个图像出现)相比，滚动显示可以最小化延迟，因为结果会在可用时立即显示。例如，如果图像是以条带生成的，那么每个条带都可以在显示之前以渲染的方式发送，“与光束赛跑”。缺点是不同的像素在不同的时间被照亮，所以根据视网膜和显示器之间的相对运动，图像会被认为是不稳定的。这种不匹配对于增强现实系统来说尤其令人不安。好消息是，排字器通常通过在一组扫描线上插值预测的头部姿势来进行补偿。这主要解决了在快速头部旋转时可能发生的抖动或剪切，尽管不能纠正场景中移动的物体。</strong></p>
<p><strong>全局显示没有这种类型的时间问题，因为图像必须在显示之前完全形成。相反，挑战是技术上的，因为单个短时间脉冲排除了几个显示选项。有机发光二极管(OLED)显示器是目前全球显示器的最佳选择，因为它的速度足以跟上VR使用中流行的90 FPS的显示速度。</strong></p>
<h3 id="Stereopsis-立体观测"><a href="#Stereopsis-立体观测" class="headerlink" title="Stereopsis 立体观测"></a>Stereopsis 立体观测</h3><p><strong>如上图所示，两张图像被偏移，每只眼睛的视角不同。这样做会刺激立体视觉，即有两只眼睛对深度的感知。立体视觉虽然是一个重要的影响，但它会随着距离的增加而减弱，这并不是我们感知深度的唯一方式。例如，在标准显示器上看图像时，我们根本不用它。物体大小、纹理模式变化、阴影、相对运动(视差)和其他视觉深度提示只需要一只眼睛就可以完成。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211110130746.png" class="" title="image-20211110130746">

<p>两眼旋转多少才能看到一个物体就是收敛。会聚是眼睛向内聚焦于某一物体的运动，如左眼。散度是向外的运动当它们转向看远处的物体时，远离页面的右边。观察远处物体的视线实际上是平行的。</p>
<p><strong>眼睛必须调整多少形状以使某物聚焦被称为适应性需求。例如，Oculus Rift的光学功能相当于观看距离用户1.3米远的屏幕。眼睛需要向内转动多少才能聚焦在一个物体上，这被称为收敛需求。参见上图。在现实世界中，眼睛会改变晶状体的形状，同时向内转动，这种现象被称为调节——收敛反射。对于显示器，适应需求是恒定的，但随着眼睛聚焦在不同感知深度的物体上，收敛需求会发生变化。这种不匹配会导致眼睛疲劳，所以Oculus建议用户将看到的任何物体放置在0.75到3.5米之外。这种不匹配在一些增强现实系统中也会产生感知效果，例如，用户可能会聚焦在现实世界中一个遥远的物体上，但随后必须重新聚焦在一个相关的虚拟广告牌上，该广告牌位于眼睛附近的固定深度。一些团队正在研究和开发一种硬件，这种硬件可以根据用户的眼球运动来调整感知到的焦距，有时也被称为自适应聚焦或可变聚焦显示器。</strong></p>
<p><strong>为VR和AR生成立体图像对的规则与单显示系统的规则不同，在单显示系统中，某些技术(偏光镜头、快门眼镜、多视角显示光学)从同一屏幕向每只眼睛呈现不同的图像。在虚拟现实技术中，每只眼睛都有一个独立的显示器，这意味着每只眼睛的位置必须保证投射到视网膜上的图像与现实非常匹配。眼与眼之间的距离称为瞳孔间距离(IPD)。在一项对4000名美国陆军士兵的研究中发现，IPD的范围从52毫米到78毫米，平均为63.5毫米。VR和AR系统都有校准方法来确定和调整用户的IPD，从而提高图像质量和舒适度。该系统的API控制一个包含IPD的摄像机模型。最好避免为了达到效果而修改用户的感知IPD。例如，增加眼间距可以增强深度感知，但也会导致眼疲劳。</strong></p>
<p><strong>头戴式显示器的立体渲染很难从头开始。好消息是，为每只眼睛设置和使用适当的摄像机转换的大部分过程都是由API处理的，这是下一节的主题。</strong></p>
<h2 id="APIs-and-Hardware-接口和硬件"><a href="#APIs-and-Hardware-接口和硬件" class="headerlink" title="APIs and Hardware 接口和硬件"></a>APIs and Hardware 接口和硬件</h2><p><strong>让我们从一开始就说:始终使用系统供应商提供的VR软件开发工具包(SDK)和应用程序编程接口(API)，除非你有很好的理由不这样做。例如，你可能认为自己的失真着色器更快，看起来也差不多。然而，在实践中，它可能会引起严重的用户不适——如果没有广泛的测试，您不一定会知道这是否正确。由于这个和其他原因，应用程序控制的失真已经从所有主要API中删除;获得正确的VR显示是一个系统级的任务。为了优化性能和保持质量，你需要做很多细致的工程。本节讨论各种供应商的SDK和API提供的支持。</strong></p>
<p><strong>将三维场景的渲染图像发送到耳机的过程非常简单。在这里，我们将使用大多数虚拟和增强现实API的常见元素来讨论它，并在此过程中注意特定于供应商的功能。首先，确定将要渲染的帧将被显示的时间。通常支持帮助您估计这个时间延迟。这个值是必需的，这样SDK就可以估算出在看到帧的那一刻眼睛所处的位置和方向。考虑到这个估计的延迟，API会查询姿势，其中包含关于每个眼睛的相机设置的信息。如果传感器也能跟踪这一信息，这至少包括头部的方向和位置。OpenVR API还需要知道用户是站着还是坐着，这可能会影响将哪个位置作为原点，例如跟踪区域的中心或用户头部的位置。如果预测是完美的，那么渲染的图像将显示在头部到达预测的位置和方向的时刻。这样，延迟的影响可以被最小化。</strong></p>
<p><strong>给定每只眼睛的预测姿态，你通常会将场景渲染到两个独立的目标。这些目标被作为纹理发送到SDK的合成器。排字人员负责将这些图像转换成在头戴式显示器上观看效果最好的形式。排字器还可以将不同的层合成在一起。例如，如果需要单眼平视显示，其中的视图对两个眼睛是相同的，可以提供一个包含该元素的单一纹理，作为一个单独的层，在每个眼睛的视图上合成。纹理可以是不同的分辨率和格式，由合成器负责转换到最终的眼睛缓冲。这样做可以实现优化，如动态降低三维场景的层的分辨率以节省渲染时间，同时保持其他层的高分辨率和质量。一旦为每个人组成了图像眼睛、畸变、色差和任何其他需要的过程都由SDK执行，然后显示结果。</strong></p>
<p><strong>如果您依赖于API，那么您不需要完全理解这些步骤背后的算法，因为供应商为您做了很多工作。然而，了解一些这方面的知识仍然是值得的，只要你意识到最明显的解决方案并不总是最好的。首先，考虑合成。最有效的方法是首先将所有图层组合在一起，然后在这张图像上应用各种校正措施。相反，Oculus首先对每一层分别进行这些校正，然后将这些扭曲的层合成，形成最终的显示图像。一个优点是，每一层的图像都是按照自己的分辨率进行扭曲的，这样可以提高文本的质量，比如单独处理文本，意味着在扭曲过程中重新采样和过滤只关注文本的内容。</strong></p>
<p><strong>用户感知到的视场大致是圆形的。这意味着我们不需要在每个图像的边缘，靠近角落渲染一些像素。虽然这些像素会出现在显示器上，但它们几乎无法被观众察觉。为了避免浪费时间生成这些，我们可以首先渲染一个网格，将这些像素隐藏在我们生成的原始图像中。这个网格作为蒙版呈现到模板缓冲区中，或者呈现到前面的z缓冲区中。在评估之前，这些区域的后续渲染片段将被丢弃。Vlachos报告称，这将使HTC Vive的填充率降低约17%。参见下图。Valve的OpenVR API将这种预渲染蒙版称为“隐藏区域网格”。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111103704.png" class="" title="image-20211111103704">

<p>在左侧，显示图像中的红色区域显示了经过渲染和扭曲的像素，但对HMD用户不可见。注意，黑色区域在经过转换的渲染图像的边界之外。在右侧，这些红色区域在渲染开始时被红色边缘的网格预先掩盖掉，导致渲染(预扭曲)的图像需要更少的像素进行着色。将右侧图像与原始图像进行比较，如图21.3中的左侧。(图片由Valve提供)</p>
<p><strong>一旦我们有了渲染后的图像，它需要被扭曲以补偿系统光学的失真。其概念是定义原始图像到所需显示形状的重新映射，如图21.3所示。换句话说，给定传入的渲染图像上的一个像素样本，这个样本在显示的图像中移动到哪里?光线投射方法可以给出精确的答案，并根据波长进行调整，但对大多数硬件来说是不切实际的。一个方法是将渲染后的图像作为纹理处理，并绘制一个填充屏幕的四边形来运行后处理。像素着色器计算这个纹理上对应于输出显示像素的确切位置。然而，这种方法可能是昂贵的，因为这个着色器必须评估每个像素的失真方程。</strong></p>
<p><strong>将纹理应用到三角形网格中会更有效。这个网格的形状可以通过变形方程修改和渲染。扭曲网格仅仅一次不会纠正色差。三组独立的(u, v)坐标用于扭曲图像，每个颜色通道对应一组。也就是说，网格中的每个三角形都被渲染一次，但是对于每个像素，渲染后的图像在略微不同的位置被采样三次。这些红色、绿色和蓝色通道值构成输出像素的颜色。</strong></p>
<p><strong>我们可以将规则间隔的网格应用到渲染的图像上，并将扭曲应用到显示的图像上，反之亦然。将网格网格应用于显示图像并将其弯曲回渲染图像的一个优点是，由于不会显示细三角形，因此生成的2 × 2四边形可能更少。在这种情况下，网格位置不是扭曲的，而是作为一个网格渲染，只有顶点的纹理坐标被调整，以扭曲应用到网格上的图像。一个典型的网格是48 × 48个四边形每只眼睛。参见下图。纹理坐标通过使用每个通道的显示-渲染图像变换计算一次。通过在网格中存储这些值，在着色器执行期间不需要复杂的转换。GPU支持纹理的各向异性采样和滤波，可用于生成清晰的可显示图像。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111103845.png" class="" title="image-20211111103845">

<p>在左边，显示最终显示的图像的网格。在实践中，这个网格可以被修剪回右边剔除的版本，因为绘制黑色三角形不会增加最终图像。(图片由Valve提供)</p>
<p><strong>上上图中右侧渲染的立体对被显示网格扭曲。在该图像中心被移除的切片对应于扭曲转换生成可显示图像的方式—请注意，在上上图左侧显示的版本中，该切片是如何从图像的交汇处丢失的。通过将显示的翘曲网格修剪到仅可见的区域，如上图中右侧所示，我们可以减少最终失真通过的成本约15%。</strong></p>
<p><strong>综上所述的优化，我们首先绘制一个隐藏区域网格，以避免评估碎片在我们知道将无法检测或未使用的区域(如中间部分)。我们用眼睛来渲染这个场景。然后我们将这个渲染图像应用到一个网格网格中，这个网格已经被修剪，只包含相关的渲染区域。将这个网格渲染到一个新的目标上，我们就可以看到要显示的图像。虚拟和增强现实系统的API支持中内置了部分或全部这些优化。</strong></p>
<h3 id="Stereo-Rendering-立体渲染"><a href="#Stereo-Rendering-立体渲染" class="headerlink" title="Stereo Rendering 立体渲染"></a>Stereo Rendering 立体渲染</h3><p><strong>渲染两个独立的视图看起来是渲染单个视图的两倍。然而，正如Wilson所指出的那样，即使是简单的实现也不是这样。阴影地图生成、模拟和动画以及其他元素都是视图无关的。像素着色器调用的数量不会增加一倍，因为显示本身在两个视图之间被分割成两半。同样，后处理效果也依赖于分辨率，所以这些成本也不会改变。然而，依赖视图的顶点处理增加了一倍，因此许多人已经探索了降低这一成本的方法。</strong></p>
<p><strong>截锥剔除通常在任何网格被发送到GPU的管线之前执行。单个视锥可以用来包含两个眼视锥。因为剔除发生在呈现之前，所以在剔除发生之后可以检索到要使用的确切呈现视图。然而，这意味着在剔除过程中需要一个安全裕度，因为该检索到的视图对可以查看被截锥删除的模型。Vlachos建议将视野增加约5度用于预测剔除。Johansson讨论了如何将截锥剔除和其他策略(如实例化和遮挡剔除查询)结合起来用于大型建筑模型的VR显示。</strong></p>
<p><strong>渲染两个立体视图的一种方法是在一个系列中完成，先渲染一个视图，然后再渲染另一个视图。实现起来很简单，但这有一个明显的缺点，即状态更改也会加倍，这是需要避免的(第18.4.2节)。对于基于贴图的渲染器，频繁更改视图和渲染目标(或剪接矩形)将导致糟糕的性能。一个更好的选择是渲染每个对象两次，切换相机转换之间。然而，API绘制调用的数量仍然增加了一倍，导致了额外的工作。想到的一种方法是使用几何着色器复制几何，为每个视图创建三角形。例如，DirectX 11支持几何着色器将生成的三角形发送到分离的目标。不幸的是，这种技术已经被发现降低了三倍或更多的几何吞吐量，因此没有在实践中使用。一个更好的解决方案是使用实例化，在实例化中，每个对象的几何图形都通过一个draw调用绘制两次。用户定义的剪辑平面被设置为保持每个眼睛的视图分离。使用实例化比使用几何着色器快得多，并且是一个很好的解决方案，排除任何额外的GPU支持。另一种方法是在渲染一只眼睛的图像时，形成一个命令列表(章节18.5.4)，将引用的常量缓冲区移位到另一只眼睛的变换中，然后重放这个列表来渲染第二只眼睛的图像。</strong></p>
<p><strong>有几个扩展可以避免在管道中发送两次(或更多)几何图形。在一些手机上，OpenGL ES 3.0扩展多视图增加了对只发送一次几何图形并将其渲染到两个或多个视图的支持，并对屏幕顶点位置和任何与视图相关的变量进行调整。扩展提供了更多的自由实现一个立体渲染器。例如，最简单的扩展可能会在驱动程序中使用实例化，发出两次几何图形，而需要GPU支持的实现可能会将每个三角形发送到每个视图。不同的实现有不同的优点，但是由于API成本总是降低的，所以这些方法中的任何一种都可以帮助CPU绑定的应用程序。例如，更复杂的实现可以提高纹理缓存效率，只对视图无关的属性执行一次顶点着色。理想情况下，可以为每个视图设置整个矩阵，也可以为每个视图设置任意顶点属性。为了让硬件实现使用更少的晶体管，GPU可以实现这些特性的子集。</strong></p>
<p><strong>AMD和NVIDIA提供了针对VR立体渲染的多GPU解决方案。对于两个GPU，每个渲染一个单独的眼睛的视图。使用关联掩码，CPU为所有接收特定API调用的GPU设置一个位。通过这种方式，呼叫可以被发送到一个或多个GPU。如果在左眼和右眼视图之间调用不同，那么通过关联掩码，API仍然需要调用两次。</strong></p>
<p><strong>另一种由厂商提供的渲染风格是NVIDIA所称的“广播”，在这种渲染方式下，只需要一个draw调用即可实现双眼的渲染。，它被广播到所有GPU。固定缓冲区用于发送不同的数据，例如，眼睛位置，到不同的GPU。广播创建两眼的图像，几乎没有比单个视图更多的CPU开销，因为唯一的成本是设置第二个常量缓冲区。</strong></p>
<p><strong>单独的GPU意味着单独的目标，但是排字器通常需要一个单独的渲染图像。有一个特殊的子矩形传输命令可以在一毫秒或更短的时间内将渲染目标数据从一个GPU转移到另一个GPU。它是异步的，这意味着传输可以在GPU做其他工作时发生。如果两个GPU并行运行，它们也可以分别创建渲染所需的阴影缓冲区。这是重复的工作，但比尝试并行处理和GPU之间的传输更简单，通常更快。这整个两个GPU设置的结果是大约30到35%的渲染加速。对于已经针对单个GPU进行了调优的应用程序，多个GPU可以将它们的额外计算应用于额外的示例，以获得更好的抗锯齿结果。</strong></p>
<p><strong>立体声视差对附近的模型很重要，但对远处的物体则可以忽略不计。Palandri和Green在移动GearVR平台上利用了这一点，他们使用了一个垂直于视图方向的分离平面。他们发现，大约10米的平面距离是一个很好的默认距离。较近的不透明物体以立体声呈现，而较远的物体则用放置在两个立体声摄像机之间的单向度摄像机呈现。为了最小化overdraw，首先绘制立体视图，然后使用它们的深度缓冲区的交集来初始化z-buffer，用于单单渲染。然后合成这幅遥远物体的图像每个立体视图。每个视图最后呈现的是透明内容。虽然更复杂，而且跨越分离平面的物体需要额外的通道，但这种方法在质量和深度感知方面没有损失，总体节约了约25%。</strong></p>
<p><strong>从下图中可以看出，由于光学所需要的畸变，使得每只眼睛的图像周围产生了更高的像素密度。此外，外围通常不那么重要，因为用户在相当多的时间里会看向屏幕的中心。由于这些原因，人们开发了各种技术，以减少对眼睛周围像素的处理。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111104431.png" class="" title="image-20211111104431">

<p>左边是一只眼睛的渲染图像。右边是要显示的扭曲图像。注意中间的绿色椭圆是如何保持相同的面积的。在外围，渲染图像中较大的区域(红色轮廓)与较小的显示区域相关联。(图片由NVIDIA公司提供。)</p>
<p><strong>一种沿外围降低分辨率的方法是NVIDIA称为多分辨率着色和AMD称为可变速率着色。其想法是将屏幕划分为，例如，3 × 3的区域，并以较低的分辨率渲染周边区域，如下图所示。NVIDIA从其Maxwell架构开始就支持这种分区方案，但是在使用Pascal时，支持一种更通用的投影类型。这被称为同步多投影(SMP)。几何图形可以通过多达16个独立的投影乘以2个独立的眼睛位置来处理，允许一个网格复制多达32次，而不需要额外的应用成本。第二眼位置必须与第一眼位置沿x轴的偏移量相等。每个投影可以独立地倾斜或绕轴旋转。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111104601.png" class="" title="image-20211111104601">

<p>假设我们想要以较低分辨率渲染左边的视图。我们可以根据需要降低任何区域的分辨率，但通常在共享边缘保持相同的分辨率更好。在右边，我们展示了蓝色区域如何减少50%的像素，红色区域减少75%。视场保持不变，但是外围区域的分辨率降低了。</p>
<p><strong>使用SMP，可以实现镜头匹配着色，其目标是更好地匹配渲染的分辨率。参见上上图。四个墩柱渲染倾斜的平面，如下图中的左边所示。这些经过修改的投影在图像中心提供了更多的像素密度，而在外围提供了更少的像素密度。这比多分辨率着色提供了一个更平滑的过渡部分。有一些缺点，例如，花朵的效果需要重新制作，以显示正确。Unity和Unreal Engine 4已经将这种技术集成到他们的系统中。Toth等人对这些算法和其他多视图投影算法进行了正式的比较和对比，并使用每只眼睛最多3 × 3个视图来进一步减少像素阴影。注意，SMP可以同时应用于双眼，如下图中右侧所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111104722.png" class="" title="image-20211111104722">

<p>左:同时多投影(SMP)使用四个投影平面为一只眼睛。右图:SMP使用四只眼睛的投影平面。</p>
<p><strong>为了节省片段处理的时间，一种称为径向密度掩蔽的应用程序级方法以棋盘式四边形模式呈现外围像素。换句话说，其他的2×2四元组片段不会被渲染。然后使用一个后处理通道从它们的邻居重建缺失的像素。这种技术可以对于一个只有一个低端GPU的系统来说，这是非常有价值的。使用这种方法渲染将减少像素着色器调用，但如果跳过并执行重建过滤器的成本太高，可能不会给你带来任何好处。索尼伦敦工作室在这一过程中走得更远，从2 × 2的集合中减少1、2或3个四边形，在靠近图像边缘的地方增加数量。缺失的四边形以类似的方式填充，每帧抖动模式都会改变。应用时间反锯齿也可以帮助隐藏阶梯的伪影。索尼系统节省了大约25%的GPU时间。</strong></p>
<p><strong>另一种方法是为每只眼睛绘制两张独立的图像，一张是中央的圆形区域，另一张是形成外围的环形区域。然后，这两幅图像可以被合成和扭曲，形成那只眼睛的显示图像。外围的图像可以以较低的分辨率生成，以节省像素着色器调用，代价是发送几何图形以形成四个不同的图像。这种技术与GPU支持发送几何图形到多个视图，以及为具有两个或四个GPU的系统提供一个自然的工作分工相吻合。虽然这是为了减少由于HMD所涉及的光学而导致的外围过多的像素着色，但Vlachos称这种技术为固定凹点渲染。这个术语是一个更高级的概念，凹点渲染。</strong></p>
<h3 id="Foveated-Rendering-漏斗状渲染"><a href="#Foveated-Rendering-漏斗状渲染" class="headerlink" title="Foveated Rendering 漏斗状渲染"></a>Foveated Rendering 漏斗状渲染</h3><p><strong>为了理解这种渲染技术，我们必须对我们的眼睛有更多的了解。中央凹是我们每只眼睛视网膜上的一个小凹陷，它充满了高密度的视锥细胞，视锥细胞是与色觉相关的感光细胞。我们的视觉灵敏度在这一区域最高，我们转动眼睛来利用这一能力，比如追踪飞行中的鸟，或者阅读页面上的文字。视力迅速下降，在前30度，从中央凹每2.5度下降约50%，越往远处下降越陡。我们的眼睛有水平114度的双目视野(两眼可以看到同一物体)。第一代消费者头戴式耳机的视场略小，双眼水平视度约为80至100度，而且可能还会上升。从2016年开始，中央20度视角的区域覆盖HMD显示器的3.6%，预计在2020年左右下降到2%。在此期间，显示分辨率可能会上升一个数量级。</strong></p>
<p><strong>在低视敏度区域，由于显示器像素的巨大优势，这就提供了使用凹点渲染来执行更少工作的机会。这个想法是为了渲染眼睛所指向的区域具有高分辨率和高质量，而在其他方面花费的精力更少。问题是眼睛会移动，所以知道要渲染的区域会改变。例如，当研究一个物体时，眼睛会进行一系列的快速移动，称为扫视，以每秒900度的速度移动。在90帧/秒的系统中，可能每帧10度。精确的眼球追踪硬件可以通过减少中央凹区域外的渲染工作，从而潜在地提高性能，但是这样的传感器是一个技术上的挑战。此外，在外围渲染“更大”的像素往往会增加混叠问题。通过尝试保持对比度，避免随着时间的推移而发生大的变化，使得外围区域在感知上更容易被接受，从而可以以较低分辨率绘制外围区域。Stengel等人讨论了以前的凹点渲染方法，以减少着色器调用的次数并呈现自己的方法。</strong></p>
<h2 id="Rendering-Techniques-渲染技术"><a href="#Rendering-Techniques-渲染技术" class="headerlink" title="Rendering Techniques 渲染技术"></a>Rendering Techniques 渲染技术</h2><p><strong>适用于单一世界观的东西不一定适用于两种世界观。即使在立体声技术中，在单一的固定屏幕上所使用的技术与在随观众移动的屏幕上所使用的技术之间也存在相当大的差异。在这里，我们将讨论一些特定的算法，这些算法可能在单个屏幕上运行良好，但在VR和AR上却存在问题。我们借鉴了Oculus、Valve、Epic Games、微软等公司的专业知识。这些公司的研究继续被收录到用户手册中，并在博客中进行讨论，因此我们建议访问他们的网站，了解当前的最佳实践。</strong></p>
<p><strong>正如上一节所强调的，供应商希望您理解他们的SDK和API，并适当地使用它们。视图是至关重要的，所以遵循供应商提供的头部模型，得到完全正确的相机投影矩阵。应该避免频闪灯等效果，因为闪烁会导致头痛和眼睛疲劳。在视野边缘附近闪烁会导致模拟器病。闪烁效应和薄条纹等高频纹理也会引发一些人癫痫发作。</strong></p>
<p><strong>基于显示器的电子游戏通常使用带有关于生命值、弹药或剩余燃料的叠加数据的抬头显示器。然而，对于VR和AR来说，双目视觉意味着距离观看者更近的物体在两眼之间有更大的偏移-收敛(章节21.2.3)。如果将HUD放置在屏幕的同一部分，则感知提示HUD必须离屏幕较远，如图21.4所示。然而，HUD被绘制在所有东西的前面。这种感知上的不匹配使得用户很难融合两幅图像并理解他们所看到的，这可能会导致不适。将HUD内容以接近眼睛的深度渲染解决了这个问题，但仍以屏幕面积为代价。参见下图。如果附近的墙比十字线更近，那么仍然存在深度冲突的风险，因为十字线图标仍然以给定的深度呈现在顶部。投射一条光线并找到给定方向上最近的表面深度可以用各种方法来调整这个深度，要么直接使用它，要么如果需要的话平滑地将它移动到更近的地方。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111105241.png" class="" title="image-20211111105241">

<p>一个繁忙的抬头显示，主导的观点。注意HUD元素必须针对每只眼睛进行移动，以避免令人困惑的深度线索。更好的解决方案是考虑将这些信息放入虚拟世界或玩家角色的设备或显示器中，因为用户可以倾斜或转头。要想看到立体效果，靠近并放置一张小而硬的纸，垂直于页面，让一只眼睛看着每一个图像。(图片由Oculus VR, LLC提供)</p>
<p><strong>在某些情况下，凹凸贴图在任何立体视觉系统中都工作得很糟糕，因为它是被看到的，在平面上绘制着色。它可以处理精细的表面细节和远处的物体，但对于表示更大的几何形状和用户可以接近的法线地图，这种错觉很快就会消失。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111105434.png" class="" title="image-20211111105434">

<p>对于较小的表面特征，比如左边和中间的两个纹理，法线贴图在VR中可以很好地工作。凹凸纹理代表了相当大的几何特征，例如右边的图像，在立体视觉中近距离观察时将无法令人信服。(图片由Valve提供)</p>
<p><strong>参见上图。基本视差映射的游动问题在立体声中更加明显，但可以通过一个简单的校正因子来改善。在某些情况下，可能需要更昂贵的技术，如陡视差映射、视差遮挡映射(第6.8.1节)或位移映射，以产生令人信服的效果。</strong></p>
<p><strong>广告牌和视点替用在立体视觉中有时不能令人信服，因为这些缺乏表面z-深度。体积技术或网格可能更合适。天空盒的大小需要让它们呈现在“无穷大”或附近，即眼睛位置的差异不应影响他们的渲染。如果使用色调映射，则应该对渲染后的两幅图像同样使用色调映射，以避免眼睛疲劳。屏幕空间环境遮挡和反射技术会产生不正确的立体差异。类似的，后期处理效果，如花华或耀斑，需要以一种尊重每个眼睛的z深度的方式生成，以便图像适当融合。水下或热雾变形效果也需要重新制作。屏幕空间反射技术产生的反射可能存在匹配问题，因此反射探头可能更有效。即使是高光高光也需要修改，因为立体视觉会影响到材料的光泽度。这两幅眼睛图像的高光位置可能有很大的差异。研究人员发现，修改这种差异可以使图像更容易融合，更有说服力。换句话说，当计算光泽成分时，眼睛的位置可能会移动得更近一些。相反，远处物体的高光差异可能在图像之间难以察觉，这可能导致共享着色计算。如果计算完成并存储在纹理空间中，就可以在眼睛图像之间共享着色。</strong></p>
<p><strong>VR对显示技术的要求非常高。代替,比如使用监视器和50度水平的视野,导致每度也许大约50像素,110度的视野在VR显示结果在大约每度15像素Vive的1080×1200像素显示为每只眼睛。从渲染图像到显示图像的转换也使重新采样和正确滤波的过程复杂化。用户的头部不断移动，即使只是一点点，也会增加时间混叠。由于这些原因，高质量的抗走样是提高图像质量和融合的实际要求。时间反锯齿经常被推荐，因为可能会模糊，尽管至少有一个团队在索尼已经成功地使用了。他们发现两者之间存在权衡，但去除闪烁的像素比提供更清晰的图像更重要。然而，对于大多数VR应用来说，MSAA提供的更清晰的视觉效果是首选。请注意，4× MSAA很好，8×更好，抖动超采样更好，如果你买得起的话。这种对MSAA的偏好与使用各种延迟渲染方法相抵触，因为对于每个像素多个样本来说，延迟渲染方法的成本很高。</strong></p>
<p><strong>在VR显示器上，颜色在阴影表面缓慢变化的条带(章节23.6)可以特别明显。这个伪影可以通过添加一点抖动噪声来掩盖。</strong></p>
<p><strong>不应该使用运动模糊效果，因为它们会使图像变得模糊，超出任何由于眼球运动而产生的伪影。这种效果与运行在90帧/秒的VR显示器的低持久性是不一致的。因为我们的眼睛确实在大视野中移动，通常是快速的扫视，所以景深技术应该避免。这种方法使得场景外围的内容看起来模糊，没有真正的原因，并可能导致模拟病。</strong></p>
<p><strong>混合现实系统带来了额外的挑战，比如将类似的光照应用到虚拟物体上，就像现实环境中一样。在某些情况下，现实世界的照明可以控制和转换为虚拟照明提前。当这是不可能的，您可以使用各种光估计技术来捕捉和近似环境的飞行照明条件。Kronander等人对各种照明捕获和表示方法进行了深入研究。</strong></p>
<h3 id="Judder-颤抖"><a href="#Judder-颤抖" class="headerlink" title="Judder 颤抖"></a>Judder 颤抖</h3><p><strong>即使虚拟世界和现实世界之间有完美的跟踪和适当维护的通信，延迟仍然是一个问题。生成45至120帧/秒的图像需要有限的时间，这是一系列VR设备的更新速率。</strong></p>
<p><strong>当图像没有及时生成并发送到排字器并显示时，就会出现丢弃帧。对Oculus Rift早期发行游戏的调查显示，它们的帧数下降了约5%。掉落的帧可以增加颤抖的感觉，这是VR头盔中最明显的涂抹和频闪伪影，当眼睛相对于显示器移动时。参见下图。如果像素在帧的持续时间内被照亮，眼睛的视网膜上就会接收到污迹。降低持久度，即在一帧中显示器照亮像素的时间长度，可以减少模糊效果。然而，它可能会导致频闪，如果帧之间有很大的变化，多个独立的图像被感知。Abrash深入讨论了抖动和它与显示技术的关系。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111105905.png" class="" title="image-20211111105905">

<p>颤抖。连续显示四帧，CPU和GPU尝试为每一帧计算图像。第一个帧的图像(以粉红色显示)被及时计算并发送给该帧的排字器。下一个图像(蓝色)没有在第二帧中显示完成，因此必须再次显示第一个图像。绿色的第三张图片也没有及时准备好，所以(现在已经完成的)第二张图片被发送到第三帧的排字器。橙色的第四幅图像是及时完成的，因此显示。注意，第三帧的渲染计算结果永远不会显示出来。(源自Oculus的插图。)</p>
<p><strong>供应商提供的方法可以帮助最小化延迟和抖动效果。其中一组技术被Oculus称为时间翘曲和空间翘曲，对生成的图像进行翘曲或修改，以更好地匹配用户的方向和位置。首先，假设我们没有丢弃帧，我们检测到用户正在旋转他们的头部。我们使用检测到的旋转来预测每只眼睛的位置和视野方向。有了完美的预测，我们生成的图像就完全符合需要。</strong></p>
<p><strong>相反地，假设用户正在旋转他们的头部并正在减速。对于这种情况，我们的预测将会超出预期，生成的图像在显示时间应该提前一点。除了速度外，估计旋转加速度有助于改进预测。</strong></p>
<p><strong>更严重的情况是帧被丢弃。在这里，我们必须使用前一帧的图像，因为有些东西需要放到屏幕上。给定我们对用户视图的最佳预测，我们可以修改该图像以近似缺失帧的图像。我们能做的一个操作是二维图像扭曲，也就是Oculus所说的时间扭曲。它只补偿头部的旋转姿势。这种扭曲操作是一种快速的纠正措施，比什么都不做要好得多。Van Waveren讨论了各种时间扭曲实现的权衡，包括在CPU和数字信号处理器(DSP)上运行的时间扭曲实现，得出的结论是GPU是目前为止完成这项任务最快的。大多数GPU可以在不到半毫秒的时间内完成这个图像扭曲过程。旋转先前显示的图像会导致显示图像的黑色边框在用户的周边视觉中变得可见。渲染比当前帧需要的更大的图像是避免这个问题的一种方法。然而，在实践中，这一边缘区域几乎不引人注意。</strong></p>
<p><strong>除了速度，纯旋转扭曲的一个优势是场景中的其他元素都是一致的。用户实际上处于环境天空盒的中心(章节13.3)，只改变视图的方向和方向。这种技术速度很快，而且效果很好。缺失帧已经够糟糕的了，但由于间歇性的帧丢失而导致的可变且不可预测的延迟似乎更迅速地导致了模拟病。为了提供更流畅的帧率，Valve在检测到帧下降时启用了交错重投影系统，将渲染率降至45 FPS，并每隔一帧进行扭曲。类似地，PLAY STATION上的一个VR版本有120赫兹的刷新率，其中渲染以60赫兹执行，重新投影以填充交替帧。</strong></p>
<p><strong>仅仅为了旋转而修正是不够的。即使用户没有移动或移动他们的位置，当头部旋转或倾斜时，眼睛确实改变了位置。例如，当仅仅使用图像扭曲时，眼睛之间的距离会显得更小，因为新图像是使用眼睛分离，眼睛指向不同的方向。这是一个很小的影响，但如果不适当地补偿位置变化，可能会导致用户迷失方向和生病，如果有物体靠近观看者，或如果观看者向下看一个纹理地平面。要调整位置变化，可以执行完全三维重投影(第12.2节)。图像中的所有像素都有一个与它们相关的深度，所以这个过程可以被认为是将这些像素投影到它们在世界中的位置，移动眼睛的位置，然后将这些点重新投影到屏幕上。Oculus称这个过程为位置时间扭曲。除了费用高昂之外，这种方法还有几个缺点。一个问题是，当眼睛移动时，一些表面可能进入或离开视野。这可以以不同的方式发生，例如，一个立方体的表面可以变得可见，或视差可以导致一个物体在前景中相对于背景移动，以便在那里隐藏或显示细节。重投影算法试图识别不同深度的物体，并使用局部图像扭曲来填补发现的任何缺口。这样的技术可以造成解除遮挡的痕迹，当一个物体从他们面前经过时，扭曲使得远处的细节似乎发生了变化和动画。透明度不能通过基本的重投影来处理，因为只有一个表面的深度是已知的。例如，这种限制会影响粒子系统的出现。</strong></p>
<p><strong>图像扭曲和重投影技术的一个问题是碎片的颜色是根据旧位置计算的。我们可以改变这些碎片的位置和可见性，但任何高光或反射都不会改变。掉落的帧可以显示这些表面高光的抖动，即使表面本身被完美地平移。即使没有任何头部运动，这些方法的基本版本也无法补偿场景中的物体运动或动画。我们只知道表面的位置，不知道它们的速度。因此，对于一个外推图像，物体不会自己在帧到帧之间移动。对象的移动可以在速度缓冲区中捕获，如12.5节所述。这样做允许重新投影技术也根据这些更改进行调整。</strong></p>
<p><strong>旋转和位置补偿技术通常在一个独立的、异步的过程中运行，作为防止帧掉落的一种形式。Valve称之为异步重投影，Oculus称之为异步时间扭曲和异步空间扭曲。《Spacewarp》通过分析之前的帧来推断缺失的帧，并考虑到摄像机和头部的平移以及动画和控制器的运动。深度缓冲器在空间曲速中不使用。除了正常的渲染，外推图像是独立地计算在同一时间。由于是基于图像的，这个过程需要相当多的时间，这意味着如果渲染不能及时完成，重新投影的图像通常是可用的。因此，不用再决定是继续尝试完成画面，还是使用时间扭曲或空间扭曲重新投影，两者都完成了。如果框架没有及时完成，那么空间曲速结果是可用的。硬件需求是有限的，这些扭曲技术主要是作为对功能较差的系统的辅助。Reed和Beeler讨论了GPU共享的不同方式以及如何有效地使用异步翘曲，Hughes等人也做了同样的研究。</strong></p>
<p><strong>旋转和定位技术是互补的，每一种都有自己的改进。旋转扭曲可以完美地适应头部旋转时，观看遥远的静态场景或图像。位置重投影对附近的动画对象很好。相对于位置偏移，方向的变化通常会引起更严重的配准问题，因此即使只是旋转校正也能提供相当大的改进。</strong></p>
<p><strong>我们在这里讨论的是这些补偿过程背后的基本思想。当然，关于这些方法的技术挑战和限制有更多的文章，我们请感兴趣的读者参考相关参考文献。</strong></p>
<h3 id="Timing-时机"><a href="#Timing-时机" class="headerlink" title="Timing 时机"></a>Timing 时机</h3><p><strong>虽然异步时间翘曲和空间翘曲技术可以帮助避免抖动，但保持质量的最佳建议是应用本身尽可能避免掉帧。即使没有抖动，我们注意到用户在显示时的实际姿势可能与预测的姿势不同。因此，一种称为晚方向扭曲的技术可能有助于更好地匹配用户应该看到的内容。这个想法是得到姿势并像往常一样生成帧，然后在帧中检索更新后的姿势预测。如果这个新的姿态不同于渲染场景的原始姿态，那么在这个帧上执行旋转扭曲(时间扭曲)。由于翘曲通常只需要不到半毫秒的时间，这种投资通常是值得的。在实践中，这种技术通常是排字本身的责任。</strong></p>
<p><strong>通过使用延迟锁存(late latching)技术，可以使这个进程运行在单独的CPU线程上，从而最小化获取这个稍后方向数据所花费的时间。这个CPU线程定期将预测的姿态发送到GPU的私有缓冲区，GPU会在扭曲图像之前的最后可能时刻获取最新的设置。延迟锁定可以用来直接向GPU提供所有头部姿态数据。这样做有一个限制，即每个眼睛的视图矩阵在那个时候对应用程序是不可用的，因为只有GPU提供了这个信息。AMD有一个改进的版本叫做最新数据锁存器，它允许GPU在需要这些数据的时候抓取最新的姿态。</strong></p>
<p><strong>你可能已经注意到在图21.12中CPU和GPU有相当长的停机时间，因为CPU直到排字完成才开始处理。这是单个CPU系统的简化视图，其中所有的工作都发生在单个帧中。正如在第18.5节中讨论的，大多数系统都有多个CPU，它们可以以各种方式保持工作。在实际操作中，cpu通常负责碰撞检测、路径规划或其他任务，并为GPU在下一帧渲染准备数据。流水线已经完成，GPU可以在CPU在上一帧设置的任何地方工作。为了有效，CPU和GPU每帧的工作应该少于一帧。参见下图。排字师通常使用一种方法来知道GPU何时完成。它被称为fence，由应用程序作为命令发出，当所有GPU调用都在它完全执行之前发出信号。fence对于知道GPU什么时候用完各种资源很有用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111110337.png" class="" title="image-20211111110337">

<p>管线。为了最大限度地利用资源，cpu在一帧内执行任务，GPU用于渲染下一帧。通过使用运行开始/自适应队列，底部显示的间隙可以被添加到每一帧的GPU执行时间中。</p>
<p><strong>图中所示的GPU持续时间表示绘制图像所花费的时间。一旦合成器完成了创建和显示最后一帧，GPU就准备开始渲染下一帧了。CPU需要等待合成完成后才能向GPU发出下一帧的命令。然而，如果我们一直等到图像显示出来，那么应用程序在CPU上生成新命令时就会花费一些时间，这些命令会被驱动程序解释，最终命令会发布给GPU。在这段时间里，GPU是空闲的，这段时间可能高达2毫秒。Valve和Oculus通过提供调用的支持来避免这种停机时间分别在前面运行启动和自适应队列。这种技术可以在任何系统上实现。其目的是让GPU在完成前一帧后立即开始工作，通过计时前一帧预期完成的时间并在此之前发出命令。大多数VR API都提供了一些隐式或显式的机制来发布应用程序，以便在有规律的节奏下运行下一帧，并有足够的时间来最大化吞吐量。在这一节中，我们提供了管线和这个缺口的简化视图，以便让人们了解这种优化的好处。参见Vlachos和Mah的演讲，深入讨论流水线和计时策略。</strong></p>
<p><strong>我们在这里结束对虚拟现实和增强现实系统的讨论。鉴于写作和出版之间的时间差，我们预计会出现许多新技术，并取代这里介绍的技术。我们的主要目标是在这个快速发展的领域提供渲染问题和解决方案的感觉。最近研究探索的一个迷人的方向是使用光线投射进行渲染。例如，Hunt讨论了这种可能性，并提供了一个开源的CPU/GPU混合射线投射器，它可以评估每秒超过100亿射线。光线投射直接解决了光栅化系统面临的许多问题，如宽视场和镜头失真，同时也适用于凹点渲染。McGuire指出，光线可以在滚动显示器显示之前投射到像素上，从而将系统这部分的延迟降低到几乎为零。这与其他许多研究项目一起，使他得出结论，我们将在未来使用VR，但不称之为VR，因为它将只是每个人的计算界面。</strong></p>
<h1 id="22-Intersection-Test-Methods-交叉测试法"><a href="#22-Intersection-Test-Methods-交叉测试法" class="headerlink" title="22 Intersection Test Methods 交叉测试法"></a>22 Intersection Test Methods 交叉测试法</h1><p><strong>交叉测试是计算机图形学中常用的测试方法。我们可能希望确定两个物体是否发生碰撞，或者找到到地面的距离，这样我们就可以保持相机在一个恒定的高度。另一个重要的用途是确定是否应该将对象发送到管道中。所有这些操作都可以通过交集测试来执行。在本章中，我们将介绍最常见的光线/物体和物体/物体相交测试。</strong></p>
<p><strong>在碰撞检测算法中，也建立在层次结构之上，系统必须决定两个原始对象是否发生碰撞。这些对象包括三角形、球体、轴向包围盒(AABBs)、定向包围盒(OBBs)和离散的定向多边形(k-DOPs)。</strong></p>
<p><strong>正如我们在第19.4节中看到的，视图截锥剔除是一种有效地丢弃视图截锥之外几何图形的方法。使用此方法需要决定包围体(BV)是否完全位于锥体外部、内部或部分位于锥体内部的测试。</strong></p>
<p><strong>在所有这些情况下，我们都遇到了需要交叉测试的一类问题。交集测试确定两个物体A和B是否相交，这可能意味着A完全在B内部(或者相反)，A和B的边界相交，或者它们是不相交的。然而，有时可能需要更多的信息，如与某个位置最近的交点，或渗透的数量和方向。</strong></p>
<p><strong>在这一章中，我们重点讨论快速交集测试方法。文中不仅给出了基本算法，而且对如何构造新的、高效的交点测试方法提出了建议。当然，本章所介绍的方法也适用于脱机计算机图形应用。例如，在第22.6至22.9节中介绍的射线相交算法在射线追踪程序中使用。</strong></p>
<p><strong>在简要介绍硬件加速拾取方法之后，本章继续介绍一些有用的定义，然后是形成边界体的算法在原语。然后给出了构造高效交集测试方法的经验法则。最后，本章的大部分内容由交叉测试方法的手册组成。</strong></p>
<h2 id="GPU-Accelerated-Picking-GPU加速筛选"><a href="#GPU-Accelerated-Picking-GPU加速筛选" class="headerlink" title="GPU-Accelerated Picking GPU加速筛选"></a>GPU-Accelerated Picking GPU加速筛选</h2><p><strong>让用户用鼠标或其他输入设备选择(点击)某个对象通常是可取的。当然，这样的操作需要很高的性能。</strong></p>
<p><strong>如果您需要将所有对象集中在屏幕上的一个点或更大的区域，而不考虑能见度，那么CPU端选择解决方案可能是必要的。这种类型的挑选有时会在建模或CAD软件包中看到。它可以在CPU上通过使用包围卷层次结构有效地解决(章节19.1.1)。在像素的位置形成一条射线，从视图截锥的近平面到远平面。然后根据需要测试光线与包围体层次的交集，类似于在全局光照算法中加速追踪光线的做法。对于用户在屏幕上定义矩形所形成的矩形区域，我们将创建一个截锥而不是射线，并在层次结构中测试它。</strong></p>
<p><strong>CPU上的交集测试有几个缺点，这取决于需求。拥有成千上万个三角形的网格，如果一个三角形一个三角形地进行测试，代价会非常昂贵，除非网格本身有一些加速结构，比如层次结构或网格。如果精度很重要，由位移映射或GPU镶嵌生成的几何图形需要由CPU匹配。对于alpha映射的对象，比如树叶，用户不应该选择完全透明的像素。在CPU上需要大量的工作来模拟纹理访问，以及任何其他材质，因为任何原因丢弃像素。</strong></p>
<p><strong>通常情况下，我们只需要屏幕上某个像素或某个区域上可见的内容。对于这种类型的选择，使用GPU管线本身。Hanrahan和Haeberli首先提出了一种方法。为了支持拾取，场景中每个三角形、多边形或网格对象都有一个唯一的标识符值，可以将其视为一种颜色。这个想法与可见性缓冲区的意图相似，形成的图像类似于第906页的图20.12。形成的图像存储在屏幕外，然后用于极其快速的拾取。当用户点击一个像素时，图像中的颜色标识符就会被查找，对象也会立即被识别出来。当使用简单的着色器执行标准渲染时，这些标识符值可以被渲染到一个单独的渲染目标，因此成本相对较低。主要的花费可能是将像素从GPU读取回CPU。</strong></p>
<p><strong>像素着色器接收或计算的任何其他类型的信息也可以存储在屏幕外的目标中。例如，法线或纹理坐标是很明显的候选者。利用这种系统，利用插值也可以找到三角形内点的相对位置。在一个单独的渲染目标中，每个三角形都被渲染为三角形顶点的红色(255, 0,0)，绿色(0,255,0)，蓝色(0,0,255)。假设所选像素的插值颜色是(23,192,40)，这意味着红色顶点贡献因子23/255，绿色顶点贡献因子192/255，红色顶点贡献因子40/255。这些值是重心坐标，将在22.8.1节进一步讨论。</strong></p>
<p><strong>使用GPU拾取最初是作为三维绘图系统的一部分呈现的。这种拾取特别适合于这样的系统，摄像机和物体都不移动，因为整个拾取缓冲器可以生成一次并重复使用。为了选择相机何时移动，另一种方法是将场景再次渲染到一个微小的目标上，例如，3 × 3，使用离轴相机聚焦在屏幕的一小部分。CPU侧截锥剔除应该消除几乎所有的几何图形，只有少数像素被着色，使此通道相对快速。对于选择所有对象(不仅仅是可见对象)，这个小窗口方法可以执行多次，使用深度剥离或简单地不渲染先前选择的对象。</strong></p>
<h2 id="Definitions-and-Tools-定义和工具"><a href="#Definitions-and-Tools-定义和工具" class="headerlink" title="Definitions and Tools 定义和工具"></a>Definitions and Tools 定义和工具</h2><p><strong>本节介绍整个章节中有用的符号和定义。</strong></p>
<p><strong>一条射线r(t)由原点o和方向矢量d定义(为方便起见，通常归一化为||d|| = 1)。其数学公式如下式所示，射线的图解如下图所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111225335.png" class="" title="image-20211111225335">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111225351.png" class="" title="image-20211111225351">

<p>一条简单的射线及其参数:o(射线原点)，d(射线方向)，以及在射线上产生不同点的t, r(t) = o + td。</p>
<p><strong>标量t是一个变量，用于在射线上生成不同的点，其中小于零的t值位于射线原点后面(因此不属于射线)，正的t值位于射线原点前面。此外，由于射线方向是标准化的，t值在射线上生成一个点，该点距离射线原点的距离为t单位。</strong></p>
<p><strong>在实践中，我们通常也存储一个交点距离l，这是我们想沿着射线搜索的最大距离。例如，在选择时，我们通常想要沿着射线最近的交点;这个交点以外的物体可以忽略不计。</strong></p>
<p><strong>距离l从∞开始。当物体成功相交时，l用相交距离更新。一旦设置了l，射线就变成了用于测试的线段。在我们将要讨论的光线/物体相交测试中，我们通常不会在讨论中包含l。如果您希望使用l，您所要做的就是执行普通的射线/物体测试，然后检查l与计算出的交点距离，并采取适当的行动。</strong></p>
<p><strong>当讨论曲面时，我们要区分隐式曲面和显式曲面。隐式曲面由下式定义:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111225651.png" class="" title="image-20211111225651">

<p><strong>这里，p是曲面上的任意点。这意味着如果在曲面上有一个点把这个点代入f，那么结果就是0。否则，f的结果将是非零的。隐曲面的一个例子是p²x + p²y + p²z = r²，它描述了一个半径为r的位于原点的球体。很容易看出，这可以重写为f(p) = p²x + p²y + p²z −r² = 0，表示它确实是隐式的。隐式曲面在17.3节中进行了简要介绍，而Gomes等人和de Ara´ujo等人对各种隐式曲面类型的建模和绘制进行了详细介绍。</strong></p>
<p><strong>另一方面，显式曲面由向量函数f和一些参数(ρ， φ)定义，而不是由曲面上的一个点定义。这些参数在表面上的产出点p。一般思路如下下式所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111230001.png" class="" title="image-20211111230001">

<p><strong>显式曲面的一个例子是球面，这一次用球坐标表示，其中ρ是纬度，φ是经度，如下公式所示:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111230039.png" class="" title="image-20211111230039">

<p><strong>另一个例子，三角形△v0v1v2，可以这样明确地描述:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111230111.png" class="" title="image-20211111230111">

<p><strong>最后，我们将给出除球面外的一些常见边界体的定义。</strong></p>
<p><strong>定义。</strong></p>
<p><strong>轴对齐的边界框(也称为矩形框)，简称AABB，是一个面法线与标准基轴重合的框。例如，AABB A用两个对角相对的点a^min和 a^max来描述，其中 ai^min ≤ ai^max，∀i∈{x, y, z}。</strong></p>
<p><strong>下图包含了一个三维AABB的插图符号。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111230354.png" class="" title="image-20211111230354">

<p>一个三维的AABB, A，及其极点a^min 和 a^max，以及标准基的坐标轴。</p>
<p><strong>定义。</strong></p>
<p><strong>一个有方向的边界框，简称OBB，是一个面法线都是成对正交的框。，它是一个任意旋转的AABB。OBB，B可以用盒子的中心点 b^c和三个标准化的向量( b^u, b^v, b^w)来描述，这三个向量描述了盒子的侧面方向。它们各自的正半长用 hu^B, hv^B ,和hw^B表示，也就是到 b^c 的距离到各自面的中心。</strong></p>
<p><strong>三维OBB及其表示法如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111230721.png" class="" title="image-20211111230721">

<p>一个三维OBB, B，它的中心点，b^c，以及它的正方向的正向量 b^u ,b^v, b^w ．边的半长 hu^B, hv^B ,和hw^B，为从盒子中心到面中心的距离，如图所示。</p>
<p><strong>定义。</strong></p>
<p><strong>k- DOP(离散方向多面体)定义为k/2(其中k是偶数)标准化法线(方向)，ni， 1≤I≤k/2，且每个ni 两个关联的标量值di^min和 di^max,其中 di^min&lt; di^max．每个三元组(ni, di^min, di^max)描述slab, Si也就是两个平面之间的体积 πi^min:ni·x + di^min= 0 和 πi^max:ni ·x + di^max = 0, 其中所有slab的交点 , ∩1≤l≤k/2， Sl为实际k- dop体积。k-DOP被定义为该边界最紧密的slab对象。AABBs和OBBs可以用6- DOPs表示，因为每一个都有三个板定义的6个平面。下图描述了一个二维的8-DOP。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111231846.png" class="" title="image-20211111231846">

<p>一个二维8-DOP茶杯的例子，所有法线，ni，与第一块slab，S1，slab的“尺寸”为:d1^min和 d1^max．</p>
<p><strong>对于凸多面体的定义，利用平面半空间的概念是有用的。正半空间包括n·x + d≥0的所有点x，负半空间是n·x + d≤0。</strong></p>
<p><strong>定义。</strong></p>
<p><strong>凸多面体是由p个平面的负半空间的交点定义的有限体积，其中每个平面的法线都指向多面体。</strong></p>
<p><strong>AABBs, OBBs和k-DOPs，以及任何视图截锥，都是凸多面体的特殊形式。更复杂的k-DOPs和凸多面体主要用于碰撞检测算法，在这种算法中，计算底层网格的精确交点是非常昂贵的。用于形成这些边界体的额外平面可以从对象中修剪额外的体积，因此证明所涉及的额外成本是合理的。</strong></p>
<p><strong>另外两个感兴趣的边界体是线扫球和矩形扫球。它们通常也被分别称为胶囊和含片，示例如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111232258.png" class="" title="image-20211111232258">

<p>直线扫球和矩形扫球，又称胶囊和菱形。</p>
<p><strong>分离轴指定一条线，其中两个不重叠(不相交)的物体在该线上的投影也不重叠。类似地，当一个平面可以插入两个三维物体之间时，平面的法线定义了一个分离轴。接下来是交叉测试的一个重要工具，它适用于凸多面体，如AABBs, OBBs和k-DOPs。这是分离超平面定理的一个方面。</strong></p>
<p><strong>分离轴测试(SAT)。</strong></p>
<p><strong>对于任意两个凸不相交多面体A和B，至少存在一个分离轴，在该轴上形成间隔的多面体的投影也是不相交的。如果一个物体是凹的，这就不成立了。例如，井壁和桶壁可能不接触，但没有平面可以将它们分开。此外，如果A和B是不相交的，那么它们可以被一个正交的轴分开(即。，通过平行平面)与以下任一:</strong></p>
<p><strong>1.A的A面。</strong> </p>
<p><strong>2.A的B面。</strong> </p>
<p><strong>3.每个多面体的边(如叉积)。</strong> </p>
<p><strong>前两个测试表明，如果一个物体完全位于另一个物体的另一侧，它们就不能重叠。前两个测试处理的人脸，最后一个测试基于对象的边缘。为了在第三个测试中分离物体，我们想要在一个平面(其法线是分离轴)中尽可能地靠近两个物体，这样一个平面与物体的距离不能比物体的一条边更近。所以，要测试的分离轴都是由两个对象的边的叉乘形成的。这个测试在下图中演示了两个盒子。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211111232534.png" class="" title="image-20211111232534">

<p>分离轴。将蓝色框称为A，黄色框称为B。第一张图显示B完全位于A的右表面的右侧，第二张图显示A完全位于B的左下表面的下方。因此，由A的右上边缘和B的左下边缘的叉乘形成的轴定义了分隔两个物体的平面的法线。</p>
<p><strong>注意这里凸多面体的定义是自由的。线段和凸多边形(如三角形)也是凸多面体(虽然退化，因为它们没有包围体积)。线段A没有面，所以第一个测试消失了。该检验用于推导22.12节的三角形/盒重叠检验和22.13.5节的OBB/OBB重叠检验。Gregorius注意到一个重要的优化，任何交叉测试使用分离轴:时间相干。如果在这一帧中发现了一个分离轴，则将此轴存储为下一帧中测试对象对的第一个轴。</strong></p>
<p><strong>回到可以使用的方法的讨论，优化交叉测试的一种常见技术是在早期进行一些简单的计算，以确定射线或物体是否错过了另一个物体。这样的测试称为拒绝测试，如果测试成功，则称交集被拒绝。</strong></p>
<p><strong>本章中经常使用的另一种方法是将三维物体投射到“最佳”正交平面(xy、xz或yz)，并在二维空间中解决问题。</strong></p>
<p><strong>最后，由于数值计算的不精确性，在交点测试中，我们通常使用一个极小的数值。这个数字表示ε (epsilon)，它的值会随着测试的不同而变化。然而，通常会选择适用于程序员的问题情况的epsilon (Press等人称之为“方便的虚构”)，而不是进行仔细的舍入误差分析和调整。在其他设置中使用的这种代码可能会因为条件的不同而中断。Ericson的书在几何计算的背景下深入讨论了数值稳健性的领域。这一点很明确，我们有时确实试图提供对于“普通”数据来说至少是合理的初始值，小规模(比如小于100，大于0.1)，并且在原点附近。</strong></p>
<h2 id="Bounding-Volume-Creation-创建边界体积"><a href="#Bounding-Volume-Creation-创建边界体积" class="headerlink" title="Bounding Volume Creation 创建边界体积"></a>Bounding Volume Creation 创建边界体积</h2><p><strong>给定一个对象集合，寻找一个紧密的拟合包围体对于最小化相交代价非常重要。任意射线击中任意凸物体的概率与该物体的表面积成正比(第22.4节)。最小化这个区域可以提高任何交集算法的效率，因为拒绝永远不会比交集慢。相比之下，在碰撞检测算法中，尽量减小每个BV的体积往往更好。本节简要介绍给定多边形集合的最优或接近最优边界体积的方法。</strong></p>
<h3 id="AABB-and-k-DOP-Creation-AABB和k-DOP创建"><a href="#AABB-and-k-DOP-Creation-AABB和k-DOP创建" class="headerlink" title="AABB and k-DOP Creation AABB和k-DOP创建"></a>AABB and k-DOP Creation AABB和k-DOP创建</h3><p><strong>要创建的最简单的绑定卷是AABB。取多边形顶点集合沿各轴的最小和最大范围，形成AABB。k-DOP是AABB的扩展:将顶点投影到每个法线ni上，这些投影的极值(min,max)存储在di^min 和 di^max中．这两个值定义了该方向最紧的板。所有这些值一起定义了一个最小k-DOP。</strong></p>
<h3 id="Sphere-Creation-球体创造"><a href="#Sphere-Creation-球体创造" class="headerlink" title="Sphere Creation 球体创造"></a>Sphere Creation 球体创造</h3><p><strong>边界球的形成不像确定板的范围那么简单。有许多算法可以执行此任务，它们在速度和质量之间进行权衡。一种快速、常数时间的单通道算法是为多边形集形成一个AABB，然后使用这个盒子的中心和对角线来形成球体。这有时会给一个贫穷的健康,可能被另一个通过改进:从中心的AABB球体的中心BV,再次遍历所有顶点,找到一个最远的从这个中心(比较对距离的平方,避免以平方根)。这是新的半径。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113115332.png" class="" title="image-20211113115332">

<p>球体边界框。最简单的是，在左边，一个物体可以在它的边界框周围有一个边界球。如果物体没有延伸到边界框的任何角落，那么可以通过使用框的中心并遍历所有顶点来找到最远的距离来设置球体的半径，就像中间的图像一样。通过移动球体的中心可以得到更小的半径，如右图所示。</p>
<p><strong>如果要在父球体中嵌套子球体，则只需要对这两种技术进行轻微的修改。如果所有的子球体都有相同的半径，这些中心可以被视为顶点，并且这个子球体半径会在任何一个过程结束时被添加到父球体的半径中。如果半径变化，AABB边界可以通过在边界计算中包含这些半径来找到一个合理的中心。如果执行了第二次传递，将每个半径加到点到父节点中心的距离上。</strong></p>
<p><strong>Ritter提出了一个简单的算法，可以创建一个接近最优的边界球。其思想是沿着每一个x, y, z轴找到最小的顶点和最大的顶点。对于这三对顶点，找出它们之间距离最大的那对。使用这一对来形成一个球体，其中心在它们之间的中点，半径等于到它们的距离。遍历所有其他顶点，检查它们到圆心的距离d。如果顶点在球体半径r之外，将球体的中心向顶点移动(d - r)/2，设置半径为(d + r)/2，然后继续。这个步骤的效果是将顶点和现有的球体包围在一个新的球体中。在第二次遍历列表之后，边界球体保证包围所有顶点。</strong></p>
<p><strong>Welzl提出了一种更复杂的算法，该算法由Eberly和Ericson等人通过网络代码实现。其思想是找到定义球体的支撑点集。一个球体可以由其表面上的两个、三个或四个点组成。当一个顶点被发现在当前球体之外时，它的位置被添加到支持集中(可能旧的支持顶点从支持集中移除)，新的球体被计算，整个列表再次运行。这个过程重复，直到球体包含所有顶点。虽然比以前的方法更复杂，但该算法保证找到最优的边界球。</strong></p>
<p><strong>Ohlarik比较了Ritter和Welzl算法变体的速度。Ritter的简化版只比基本版贵20%，但有时效果会更差，所以两者都运行是值得的。Eberly的Welzl算法的实现对于随机的点列表是线性的，但是运行速度要慢一个数量级左右。</strong></p>
<h3 id="Convex-Polyhedron-Creation-创建凸多面体"><a href="#Convex-Polyhedron-Creation-创建凸多面体" class="headerlink" title="Convex Polyhedron Creation 创建凸多面体"></a>Convex Polyhedron Creation 创建凸多面体</h3><p><strong>包围体的一种一般形式是凸多面体。凸物可配合分离轴试验使用。AABBs,k-DOPs和OBBs都是凸多面体，但可以找到更紧密的边界。正如k-DOPs可以被认为是通过添加额外的平面对从一个物体上剪去更多的体积一样，凸多面体可以由任意的平面集定义。通过削减额外的体积，更昂贵的测试涉及到封闭的多边形对象的整个网格可以避免。我们想要“收缩”我们的多边形对象，并找到这组平面，它们形成了凸包。下图显示了一个示例。凸包可以用Quickhull算法来找到。尽管名称如此，但该过程比线性时间慢，因此通常作为复杂模型的离线预处理执行。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113115812.png" class="" title="image-20211113115812">

<p>使用Quickhull计算出茶壶的凸壳。</p>
<p><strong>可以看出，这个过程可能会产生大量的平面，每个平面都由凸包上的一个多边形定义。在实践中，我们可能不需要这种精度。首先创建原始网格的简化版本，可能向外扩展以完全包含原始网格，将产生一个不太精确但更简单的凸包。还需要注意的是，对于k-DOPs，随着k的增加，BV越来越类似于凸包。</strong></p>
<h3 id="OBB-Creation-OBB创建"><a href="#OBB-Creation-OBB创建" class="headerlink" title="OBB Creation  OBB创建"></a>OBB Creation  OBB创建</h3><p><strong>一个物体可能有一个自然的OBB，因为它从一个AABB开始，然后经历一个旋转，从而使AABB成为OBB。然而，随后使用的OBB可能不是最优的。想象一个旗杆模型以一定角度从建筑延伸出来。围绕它的AABB不像沿其长度延伸的OBB那样紧。对于没有明显最佳轴的模型，基方向任意的OBB形成比寻找合理的边界球更为复杂。</strong></p>
<p><strong>在为这个问题创建算法方面已经做了大量的工作。O’rourke从1985年开始的精确解在O(n³)时间内运行。Gottschalk提出了一种更快、更简单的方法，它给出了最佳OBB的近似。它首先计算多边形网格的凸壳，以避免模型顶点在这个体积内可能导致结果偏差。然后利用线性时间的主成分分析(PCA)找到合理的OBB轴。这种方法的缺点是盒子有时是松散的。埃伯利描述了一种使用极小化技术计算最小体积OBB的方法。他为方框取样一组可能的方向，并使用OBB最小的轴作为数值最小化器的起点。然后使用Powell方向集方法来寻找最小体积盒。Eberly在网上有这个操作的代码。还有其他的算法;Chang等人对之前的工作给出了合理的概述，并提出了他们自己的最小化技术，即使用遗传算法来帮助搜索解空间。</strong></p>
<p><strong>在这里，我们提出了Larsson和K¨allberg的一种算法，一种不需要凸包并在线性时间内执行的近似最优方法。它通常提供比Gottschalk基于PCA的方法更好的质量，执行速度相当快，适合SIMD并行化，并且有作者提供的代码。首先，为对象形成一个k-DOP，并保存一对(任意一对)接触到每个k-DOP板的相对边的顶点。所有这些顶点对一起称为对象的极值点。例如，一个26-DOP生成13对点，其中一些点可能指定同一个顶点，可能给出一个较小的整体集合。“最佳OBB”被初始化为围绕对象的AABB。然后，该算法通过寻找可能提供更好匹配的OBB方向继续进行。一个大的基础三角形被构造出来，两个四面体从它的表面延伸出来。这就形成了一组7个三角形，产生了潜在的接近最优的OBBs。</strong></p>
<p><strong>这对彼此距离最远的点构成了底边三角形的一条边。离这条边最远的剩余极值点的顶点构成三角形的第三个点。每个三角形的边和在三角形的平面上的边的法线被用来形成一个潜在的新OBB的两个轴。剩余的极值点投影到这些轴上，以找到三个OBBs在平面上的二维边界。参见下图。用最小的周围二维矩形从三个OBB中选出最佳OBB。因为这三个OBB的高度、沿三角形法线的距离都是相同的，所以每个OBB周围的二维边界框足以决定哪一个是最好的。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113120251.png" class="" title="image-20211113120251">

<p>算法形成方向包围盒;记住，所有的点都是三维的。对于每个k-DOPs的slab(由一对彩色线标记)，在其极限处有一对点，用黑色标记;底部的两个顶点都是两个平板的顶点。其他用灰色标记的顶点在以下步骤中不使用。在这四对中，相隔最远的两个顶点构成一条边。从这条边的直线最远的极值点被用来与这条边形成一个三角形。形成了三个盒子，每个盒子使用三角形边来定义它的轴，其余的极值点来定义它的边界。在这三个盒子中，最好的盒子被保存了下来。</p>
<p><strong>剩余的极值点被用来通过与三角形法线的投影来找到这个OBB在三维空间中的范围。这个完全形成的OBB与最初的AABB进行检查，看哪个更好。在这个过程中发现的两个极值点，一个在高度最大值，一个在高度最小值，然后形成两个四面体，每个四面体的基础都是原来的大三角形。每个四面体依次形成三个额外的三角形，对每个三角形的三个候选OBB进行评估，就像对原始三角形进行评估一样。对于每个三角形，最好的二维OBB也像之前一样沿着其高度展开，但只是为了得到候选OBB的最终大小，而不是形成更多的三角形。总共形成7个三角形，并生成一个完整的OBB，并从每个OBB进行比较。</strong></p>
<p><strong>一旦找到最佳OBB，原始物体中的所有点都投影到它的轴线上，根据需要增加它的大小。最后对原来的AABB进行检查，看看这个OBB是否真的更适合。这整个过程比以前的技术更快，并且受益于对大多数步骤使用一组极小的极值点。值得注意的是，作者更喜欢基于表面积而不是体积来优化包围框，原因我们将在下一节介绍。</strong></p>
<h2 id="Geometric-Probability-几何概率"><a href="#Geometric-Probability-几何概率" class="headerlink" title="Geometric Probability 几何概率"></a>Geometric Probability 几何概率</h2><p><strong>常见的几何运算包括平面或光线是否与物体相交，以及物体内部是否有点。一个相关的问题是点、射线或平面与物体相交的相对概率是多少。空间中一个随机点在物体内部的相对概率是相当明显的:它与物体的体积成正比。因此，1×2×3盒子包含随机选择点的概率是1× 1× 1盒子的6倍。</strong></p>
<p><strong>对于空间中的任意一条射线，射线与物体相交的相对概率是多少?这个问题与另一个问题有关:当使用正交投影时，任意方向的对象覆盖的像素的平均数量是多少?正射影可以被认为是视图体中的一组平行光线，光线通过每个像素。给定一个随机方向的对象，所覆盖的像素数等于与该对象相交的射线数。</strong></p>
<p><strong>答案非常简单:任何凸面实体的平均投影面积是其表面积的四分之一。对于屏幕上的球面来说，这显然是正确的，它的正投影总是一个面积为πr²的圆，它的表面积是4πr²。同样的比例适用于任何其他任意方向的凸物体，如框或k-DOP的平均投影。参见Nienhuys的文章以获得非正式的证明。</strong></p>
<p><strong>球体、方框或其他凸对象在每个像素处都有一个正面和一个背面，因此深度复杂度为2。概率测度可以推广到任意多边形，因为(双面)多边形的深度复杂度总是为1。因此，任何多边形的平均投影面积是其表面积的一半。</strong></p>
<p><strong>在光线追踪文献中，这个度量被称为曲面面积启发式(SAH)，它对于形成有效的数据集可见性结构非常重要。一个用途是比较边界体积效率。例如,一个球面被射线击中的相对概率为1.57 (π/2)。即四角与球体接触的立方体)。类似地，一个立方体被击中的相对概率是1.91 (6/π)，相对于它里面的球面。</strong></p>
<p><strong>这种类型的概率测量在细节水平计算等领域是有用的。例如，想象一个又长又细的物体所覆盖的像素比一个圆形物体少得多，但两者都有相同的边界球大小。从它的边界框的面积提前知道命中率，长而细的物体可能被认为是相对不那么重要的视觉冲击。</strong></p>
<p><strong>我们现在有一个点的包围概率与体积有关，一条射线的交点概率与表面积有关。平面与方框相交的概率与方框在三维空间中的范围和成正比。这个总和称为对象的平均宽度。例如，边长为1的立方体的平均宽度为1 + 1 + 1 = 3。盒子的平均宽度与它被飞机击中的几率成正比。一个1 × 1 × 1的方框的尺寸是3，一个1 × 2 × 3的方框的尺寸是6，这意味着第二个方框与任意平面相交的可能性是另一个的两倍。</strong></p>
<p><strong>然而，这个总和比真正的几何平均宽度要大，真正的几何平均宽度是物体在所有可能的方向上沿着固定轴的平均投影长度。对于平均宽度的计算，不同的凸对象类型之间没有简单的关系(如表面积)。一个直径为d的球体的几何平均宽度为d，因为球体在任何方向上都具有相同的长度。我们将离开这个主题，简单地说，乘一个盒子的尺寸的总和(即。它的几何平均宽度是0.5，可以直接与球体的直径进行比较。因此，测量为3的1 × 1 × 1盒子的几何平均宽度为3 × 0.5= 1.5。包围此盒体的球体的直径为√3= 1.732。因此一个球体的边界立方体是1.732/1.5=1.155，可能与任意平面相交。</strong></p>
<p><strong>这些关系有助于确定各种算法的优点。截锥剔除是一个主要的选择，因为它涉及到与边界体相交的平面。另一个用途是确定是否以及在哪里最好分割包含对象的BSP节点，以便截锥剔除性能变得更好(章节19.1.2)。</strong></p>
<h2 id="Rules-of-Thumb-经验法则"><a href="#Rules-of-Thumb-经验法则" class="headerlink" title="Rules of Thumb 经验法则"></a>Rules of Thumb 经验法则</h2><p><strong>在我们开始研究特定的交集方法之前，这里有一些经验法则，可以导致更快、更健壮、更精确的交集测试。在设计、发明和实现交叉例程时，应该牢记这些原则:</strong></p>
<pre><code>**•在早期执行计算和比较，可能琐碎地拒绝或接受各种类型的交叉，以获得一个早期逃避进一步的计算。**

**•如果可能，利用之前测试的结果。**

**•如果使用了多个拒绝或验收测试，那么试着改变它们的内部顺序(如果可能的话)，因为可能会产生更有效的测试。不要认为看似微小的变化不会产生影响。**

**•推迟昂贵的计算(尤其是三角函数、平方根和除法)，直到真正需要时(第22.8节，延迟昂贵的除法的例子)。**

**•通过降低问题的维度(例如，从三维到二维甚至一维)，交叉问题通常可以大大简化。参见22.9节中的示例。**

**•如果一条射线或一个物体在同一时间与许多其他物体进行比较，请在测试开始前寻找可以只做一次的预计算。**

**•当交叉测试很昂贵时，通常最好先在物体周围放置一个球体或其他简单的BV来快速拒绝。**

**•养成在电脑上进行计时比较的习惯，并使用真实数据和测试情况进行计时。**

**•利用前一帧的结果，例如，如果发现某个轴在前一帧分离两个对象，那么在下一帧尝试该轴可能是一个好主意。**

**•最后，试着让你的代码健壮。这意味着它应该适用于所有特殊情况，并且对尽可能多的浮点精度错误不敏感。要意识到它的局限性。更多关于数值和几何鲁棒性的信息，请参阅Ericson的书。**
</code></pre>
<p><strong>最后，我们强调这样一个事实:对于一个特定的测试，很难确定是否有一个“最佳”的算法。在评估时，通常使用一组不同的、预先确定的命中率的随机数据，但这只显示了部分事实。该算法将在真实场景中使用，例如在游戏中，最好在该情境下进行评估。使用的测试场景越多，对性能问题的理解就越好。一些体系结构，如GPUs和宽SIMD实现，可能会由于需要执行多个拒绝分支而导致性能下降。最好避免做假设，而是创建一个可靠的测试计划。</strong></p>
<h2 id="Ray-Sphere-Intersection-光线-球体交叉"><a href="#Ray-Sphere-Intersection-光线-球体交叉" class="headerlink" title="Ray/Sphere Intersection 光线/球体交叉"></a>Ray/Sphere Intersection 光线/球体交叉</h2><p><strong>让我们从一个数学上简单的交点检验开始，即射线和球体之间的交点检验。正如我们稍后将看到的，如果我们开始考虑所涉及的几何学，直接的数学解可以更快地得到。</strong></p>
<h3 id="Mathematical-Solution-数学方法"><a href="#Mathematical-Solution-数学方法" class="headerlink" title="Mathematical Solution 数学方法"></a>Mathematical Solution 数学方法</h3><p><strong>一个球体可以由一个中心点c和一个半径r来定义。更紧凑的隐式，计算球体的公式（与前面介绍的公式相比）</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113122359.png" class="" title="image-20211113122359">

<p><strong>p是球面上的任意点。为了求解射线与球体的交点，射线r(t)只需将上方程中的p替换产出</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113122450.png" class="" title="image-20211113122450">

<p><strong>利用22.1式，r(t) = o + td，将上式简化为:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113122519.png" class="" title="image-20211113122519">

<p><strong>最后一步来自于假设d是标准化的事实，即 d·d = ||d||² = 1。毫不奇怪，得到的方程是一个二阶多项式，这意味着，如果射线与球面相交，它最多在两点处相交。参见下图。如果方程的解是虚的，那么光线就会错过球面。如果不是，两个解t1 和t2 可以插入到射线方程中来计算球面上的交点。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113122639.png" class="" title="image-20211113122639">

<p>左边的图像显示了一条错过球体的射线，因此b²−c &lt; 0。中间的图像显示了一条射线与球体相交于两点(b²−c &gt; 0)，这两点由标量t1 和t2决定．右图说明了b²−c = 0的情况，这意味着两个交点重合。</p>
<p><strong>得到的上方程可以写成二次方程:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113122803.png" class="" title="image-20211113122803">

<p><strong>其中b = d·(o−c)， c = (o−c)·(o−c)−r²。二阶方程的解如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113122838.png" class="" title="image-20211113122838">

<p><strong>注意，如果b²−c &lt; 0，则射线错过了球体，可以拒绝相交并避免计算√ (例如，平方根√和一些补充)。如果这个测试通过，两个t0 =−b−√(b²−c)和t1 =−b + √(b²−c)可计算。为了找到的最小正值，需要进行额外的比较t0 和t1．请参阅realtimerendering.com上的碰撞检测章节，以获得解决这个二次方程的另一种方法，它在数值上更稳定。</strong></p>
<p><strong>如果从几何角度来看待这些计算，就可以发现更好的拒绝测试。下一小节将描述这样一个例程。</strong></p>
<h3 id="Optimized-Solution-优化解决方案"><a href="#Optimized-Solution-优化解决方案" class="headerlink" title="Optimized Solution 优化解决方案"></a>Optimized Solution 优化解决方案</h3><p><strong>对于光线/球面相交问题，我们首先观察到光线原点后面的相交是不需要的。例如，这通常是在拣选的情况下。为了尽早检查这种情况，我们首先计算一个向量l = c−o，它是从射线原点到球体中心的向量。下图中描述了所有使用的符号。同时,这个向量的长度的平方计算,l² = l·l。现在如果l² &lt; r²,这意味着光线起源是在球体,这反过来,意味着雷保证了球体,我们只能退出如果我们要检测是否射线击中球;否则,我们继续。接下来，计算l在射线方向d上的投影:s = l·d。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113123336.png" class="" title="image-20211113123336">

<p>优化的射线/球体相交的几何符号。在左图中，射线与球体相交两点，距离为t = s±q。中间的情况表明，当球在射线原点后面时，会产生排斥。最后，在右边，射线原点在球内，在这种情况下射线总是击中球。</p>
<p><strong>现在，第一个排斥检验:如果s &lt; 0且射线原点在球面外面，那么球面在射线原点后面，我们可以排斥交集。否则，从球心到投影的距离的平方用勾股定理计算:m² = l²−s²。第二个拒绝测试甚至比第一个更简单:如果m² &gt; r²射线肯定会错过球体，其余的计算可以安全地省略。如果球体和射线通过了最后的测试，那么射线肯定会击中球体，我们可以退出，如果这是我们感兴趣的。</strong></p>
<p><strong>要找到真正的交点，还需要做一些工作。首先，计算距离q² = r²−m²的平方。参见上图。自从m² ≤ r²,q²大于等于0，这意味着q = √q²是可以计算出来的。最后，到交叉口的距离为t = s±q，其解与上一数学求解部分得到的二阶方程的解非常相似。</strong></p>
<p><strong>如果我们只对第一个正交点感兴趣，那么对于光线原点在球之外的情况，我们应该用t1 = s - q，当射线原点在内部时t2= s + q。将t值(s)插入到射线方程(方程22.1)中，得到真交点(s)。</strong></p>
<p><strong>下面的框中显示了优化版本的伪代码。例程返回一个布尔值，如果射线没有击中球体，则返回REJECT，否则相交。如果射线与球面相交，那么从射线原点到交点的距离t，以及交点p，也会返回。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113124043.png" class="" title="image-20211113124043">

<p><strong>注意，在第3行之后，我们可以测试p是否在球面内，如果我们只想知道射线和球面是否相交，则程序可以终止。同样，在第6行之后，射线保证会击中球体。如果我们做一个计数运算(计数加、乘、比较和相似)，我们发现几何解，在完成之后，近似等于前面给出的代数解。重要的区别在于拒绝测试在过程的早期就完成了，这使得该算法的总体成本平均较低。</strong></p>
<p><strong>优化的几何算法存在于计算射线与其他一些二次曲面和混合对象之间的交点。如圆柱体、圆锥体、椭球体、胶囊、菱形等。</strong></p>
<h2 id="Ray-Box-Intersection-光线-盒体交叉"><a href="#Ray-Box-Intersection-光线-盒体交叉" class="headerlink" title="Ray/Box Intersection 光线/盒体交叉"></a>Ray/Box Intersection 光线/盒体交叉</h2><p><strong>下面给出了三种确定射线是否与实心方框相交的方法。第一个处理AABBs和OBBs。第二种变体通常更快，但只处理更简单的AABB。第三个是基于947页的分离轴测试，只处理线段与AABBs。这里，我们使用第22.2节中BVs的定义和符号。</strong></p>
<h3 id="Slabs-Method-板方法"><a href="#Slabs-Method-板方法" class="headerlink" title="Slabs Method 板方法"></a>Slabs Method 板方法</h3><p><strong>射线/AABB相交的一种方案是基于Kay和Kajiya的slab方法，而该方法又受到Cyrus-Beck线裁剪算法的启发。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113133500.png" class="" title="image-20211113133500">

<p>左图显示的是由两个板组成的二维OBB，而右图显示的是测试与OBB相交的两条射线。所有的t值都显示出来了，绿色的u和橙色的v用下标表示。极端的t值用盒子标记。左射线在t^min &lt; t^max时击中OBB，右射线在 t^max &lt; t^min时错过。</p>
<p><strong>我们扩展了这个方案来处理更一般的OBB量。它返回最接近的正t值(即从射线原点o到交点的距离(如果有的话)。AABB的优化将在我们介绍一般情况后进行处理。这个问题是通过计算射线和OBB表面的所有平面的t值来解决的。盒子被认为是一组三个板，如上图左侧的二维图所示。对于每个板，有一个最小和最大的t值，这些被称为ti^min和 ti^max，∀i∈{u, v, w}。下一步是计算公式中的变量:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113133603.png" class="" title="image-20211113133603">

<p><strong>现在，有一个聪明的测试:如果t^min≤ t^max，则射线定义的直线与方框相交;否则错过。换句话说，我们找到了每个平板的近和远的交点距离。如果找到的最远的距离小于或等于最近的距离，那么射线定义的线就会击中方框。您应该通过查看上图右侧的插图来确信这一点。这两个距离定义了直线的交点，所以如果最近的“远”距离不是负的，射线本身就会击中方框，即盒子不在光线后面。</strong></p>
<p><strong>在OBB (A)和射线(由方程22.1描述)之间，射线/OBB相交测试的伪代码如下。代码返回一个布尔值，指示射线是否与OBB相交(INTERSECT或REJECT)，以及到交点的距离(如果存在)。回想一下，对于OBB A，中心是a^c, a^u, a^v和 a^w 为箱体规格化的侧面方向;h^u, h^v和 h^w 为正半长(从中心到盒面)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211113133822.png" class="" title="image-20211113133822">

<p><strong>第7行检查射线方向是否不垂直于当前被测试板的法线方向。换句话说，它测试光线是否不平行于平板，从而与平板相交。注意，ε在这里是一个很小的数字，在10^( - 20)的顺序上，只是为了避免在除法发生时溢出。第8行和第9行表示除f;在实践中，计算1/f一次并乘以这个值通常更快，因为除法通常很昂贵。第10行确保t1 和t2的最小值储在t1中，因此，它们的最大值存储在t2中．在实践中，交换不一定是必须的;相反，分支可以重复第11行和第12行，而t1 和t2 可以在那里改变位置。如果第13行返回，则射线错过了方框，类似地，如果第14行返回，则方框在射线原点的后面。如果射线平行于平板(所以不能与平板相交)，则执行第15行;它测试光线是否在平板外面。如果是，则射线错过了盒子，测试终止。对于更快的代码，Haines讨论了一种展开循环的方法，从而避免了一些代码。</strong></p>
<p><strong>伪代码中没有显示一个额外的测试，值得在实际代码中添加。当我们定义射线时，我们通常想要找到最近的物体。因此，在第15行之后，我们还可以测试t^min是否≥l，其中l是当前射线的长度。这有效地将射线视为一条线段。如果新的十字路口不靠近，这个十字路口就会被拒绝。这个测试可以推迟到整个射线/OBB测试完成之后，但是在循环中尝试早期拒绝通常更有效。</strong></p>
<p><strong>对于OBB的特殊情况，也就是AABB，还有其他的优化。第5行和第6行改为e = pi,f = di，这使得测试速度更快。通常情况下,a^min 和a^max AABB的角在第8行和第9行使用，因此避免了加减运算。Kay和Kajiya和Smits注意到，第7行可以通过允许除0和正确解释处理器的结果来避免。Kensler给出了这个测试的最小版本的代码。Williams等人提供了正确处理除以0的实现细节，以及其他优化。Aila等人展示了如何在一些NVIDIA架构上的单个GPU操作中执行最大最小值测试，或者反之亦然。也可以使用SAT对射线和方框进行测试，但交点距离不是结果的一部分，这通常是有用的。</strong></p>
<p><strong>平板方法的推广可用来计算光线与k-DOP、截锥或任何凸多面体的交点;代码可在web上获得。</strong></p>
<h3 id="Ray-Slope-Method-射线斜率法"><a href="#Ray-Slope-Method-射线斜率法" class="headerlink" title="Ray Slope Method 射线斜率法"></a>Ray Slope Method 射线斜率法</h3><p><strong>2007年，Eisemann等人提出了一种比以前的方法更快的相交方框的方法。射线不是三维测试，而是通过盒子在二维空间的三个投影来测试。关键思想是，对于每个二维测试，都有两个方框角来定义光线“看到”的极端范围，类似于模型的轮廓边缘。要与方框的投影相交，射线的斜率必须在由射线原点和这两点定义的两个斜率之间。如果这个测试通过了所有三个投影，射线必须击中盒子。这个方法非常快，因为有些比较项完全依赖于射线的值。通过一次计算这些项，射线就可以有效地与大量的盒子进行比较。这种方法可以只返回是否击中了盒子，或者还可以返回交集距离，只需要一点额外的成本。</strong></p>
<h2 id="Ray-Triangle-Intersection-光线-三角形交叉"><a href="#Ray-Triangle-Intersection-光线-三角形交叉" class="headerlink" title="Ray/Triangle Intersection 光线/三角形交叉"></a>Ray/Triangle Intersection 光线/三角形交叉</h2><p><strong>在实时图形库和API中，三角形几何通常存储为一组具有相关着色法线的顶点，每个三角形由三个这样的顶点定义。三角形所在平面的法线通常不存储，在这种情况下，如果需要，必须计算它。射线/三角形相交测试有很多，其中很多都是先求射线与三角形平面的交点。然后，交点和三角形顶点投影到轴向平面(xy, yz，或xz)，在这里三角形的面积是最大的。通过这样做，我们将问题简化为二维，我们只需要确定(二维)点是否在(二维)三角形内。有几种这样的方法存在，Haines对它们进行了审查和比较，代码可以在网上找到。参见第22.9节，了解使用这种技术的一个流行算法。对于不同的CPU架构、编译器和命中率，已经评估了大量的算法，不能得出结论说在所有情况下都有一个最佳的测试。</strong></p>
<p><strong>在这里，重点将放在一个算法，不假定法线是预先计算的。对于三角形网格，这可以节省大量内存。对于动态几何，我们不需要每一帧都重新计算三角形的平面方程。不是在三角形的平面上测试一条射线，然后检查相交点是否包含在一个二维的三角形中，而是只对三角形的顶点进行检查。M¨oller和Trumbore讨论了该算法及其优化，本文将使用他们的演示。Kensler和Shirley指出，大多数直接在三维空间中运行的射线/三角形测试在计算上是等价的。他们开发了新的测试方法，使用SSE测试三角形上的四道射线，并使用遗传算法在这个等效测试中找到操作的最佳顺序。性能最好的测试代码在他们的论文中。请注意，有许多不同的方法可以实现此目的。例如，Baldwin和Weber提供了一种不同的空间速度权衡方法。这类测试的一个潜在问题是，一条恰好与三角形的边或顶点相交的射线可能被判定为错过三角形。这意味着光线可以通过接触两个三角形共享的边来穿过网格。Woop等人提出了在边和顶点上都是水密的射线/三角形相交测试。性能会稍微低一些，这取决于使用哪种类型的遍历。</strong></p>
<p><strong>方程22.1中的光线用于测试与由三个顶点p1, p2, p3所定义的三角形的交即△p1p2p3。</strong></p>
<h3 id="Intersection-Algorithm-交集算法"><a href="#Intersection-Algorithm-交集算法" class="headerlink" title="Intersection Algorithm 交集算法"></a>Intersection Algorithm 交集算法</h3><p><strong>三角形上的点f(u, v)由显式公式给出</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114123600.png" class="" title="image-20211114123600">

<p><strong>式中(u, v)为两个重心坐标，必须满足u≥0,v≥0和u + v≤1。注意，(u, v)可以用于纹理映射、法线或颜色插值等操作。也就是说，u和v是衡量每个顶点对特定位置贡献的权重，w =(1−u−v)是第三个权重。这些坐标在其他著作中常表示为α、β和γ。我们在这里使用u v和w是为了可读性和符号的一致性。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133043.png" class="" title="image-20211114133043">

<p>三角形的重心坐标，以及示例点的值。在三角形内u,v,w的值都在0到1之间变化，这三个的和在整个平面上总是1。这些值可以用作三个顶点上的数据如何影响三角形上任何点的权重。注意，在每个顶点上，一个值是1，其他值是0，沿着边，一个值总是0。</p>
<p><strong>计算射线r(t)和三角形f(u, v)的交点，就等于r(t) = f(u, v)，就得到</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133203.png" class="" title="image-20211114133203">

<p><strong>重新安排条件</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133242.png" class="" title="image-20211114133242">

<p><strong>这意味着质心坐标(u, v)和从射线原点到交点的距离t可以通过解这个线性方程组得到。</strong></p>
<p><strong>这种操作可以从几何上理解为将三角形平移到原点，并将其转换为y和z方向的单位三角形，射线方向与x对齐。如下图所示。如果M =(−d p1−p0 p2−p0)为22.13式中的矩阵，将22.13式与M^−1相乘求解。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133451.png" class="" title="image-20211114133451">

<p>射线原点的基底的平移和变化。</p>
<p><strong>表示e1 = p1 −p0,e2 = p2 −p0， s = o−p0式22.13的解采用Cramer法则:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133650.png" class="" title="image-20211114133650">

<p><strong>因此，上方程可以重写为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133739.png" class="" title="image-20211114133739">

<p><strong>q = d × e2和r = s × e1．这些因素可以用来加速计算。</strong></p>
<p><strong>如果您能够负担一些额外的存储空间，可以重新制定这个测试，以减少计算的数量。上式可以改写为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114133923.png" class="" title="image-20211114133923">

<p><strong>其中n = e1 ×e2 是三角形的非标准化法线，因此是常量(对于静态几何)，m = s × d。如果我们保存p0,e1,e2，和每个三角形n，我们可以避免许多射线三角形相交的计算。大部分的收益来自于避免叉乘。需要注意的是，这违背了算法的原始思想，即用三角形存储最小的信息。然而，如果速度是最受关注的，这可能是一个合理的选择。需要权衡的是，额外的内存访问是否超过了节省的计算。只有仔细的测试才能最终显示什么是最快的。</strong></p>
<h3 id="Implementation-实现"><a href="#Implementation-实现" class="headerlink" title="Implementation 实现"></a>Implementation 实现</h3><p><strong>算法在下面的伪代码中进行了总结。除了返回射线是否与三角形相交，算法还返回前面描述的三重(u, v, t)。代码不剔除面向后的三角形，它返回t值为负的交点，但如果需要，这些交点也可以被剔除。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114134401.png" class="" title="image-20211114134401">

<p><strong>有几行可能需要一些解释。第4行计算a，它是矩阵M的行列式，接下来是一个避免行列式接近于零的测试。通过适当调整ε的值，该算法非常健壮。对于浮点精度和“正常”条件，ε = 10^−5 工作很好。在第9行中，将u的值与三角形(u = 0)的一条边进行比较。</strong></p>
<p><strong>该算法的C-code(包括剔除和非剔除版本)可在web上找到。C代码有两个分支:一个有效地剔除所有面向后的三角形，另一个对双面三角形执行交叉测试。所有的计算都被延迟到需要的时候。例如，v的值是直到发现u的值在允许范围内时才计算(这也可以在伪代码中看到)。</strong></p>
<p><strong>单侧交例程消去了行列式值为负的所有三角形。这个程序允许航线唯一的除法操作被延迟，直到一个交点被确认。</strong></p>
<h2 id="Ray-Polygon-Intersection-光线-多边形交叉"><a href="#Ray-Polygon-Intersection-光线-多边形交叉" class="headerlink" title="Ray/Polygon Intersection 光线/多边形交叉"></a>Ray/Polygon Intersection 光线/多边形交叉</h2><p><strong>尽管三角形是最常见的绘制原语，但是计算光线和多边形之间的交点的程序是有用的。一个有n个顶点的多边形由一个有序的顶点列表定义{v0, v1，…, vn−1}，其中顶点vi 与vi+1形成一条边当0≤I &lt; n−1时，多边形被来自vn−1 的边关闭到v0．多边形的平面πp : np ·x + dp = 0。</strong></p>
<p><strong>我们首先计算射线(方程22.1)与πp的交点，这很容易做到，用射线代替x。解决方案如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114134932.png" class="" title="image-20211114134932">

<p><strong>如果分母是|np ·d| &lt; ε，其中ε为极小值，则认为射线平行于多边形平面，不发生相交。在这种计算中，可以使用10^−20或更小的，因为目的是避免在除法时溢出。我们忽略光线在多边形平面上的情况。</strong></p>
<p><strong>否则，求出光线与多边形平面的交点p: p = o+td，其中t值为上式。然后，决定p是否在多边形内的问题从三维降为二维。这是通过将所有顶点和p投影到xy、xz或yz平面上来实现的，在这些平面上投影多边形的面积最大。也就是说，可以跳过max(|np,x|， |np,y|， |np,z|)对应的坐标分量，其余的保留为二维坐标。例如，给定一个法线(0.6，−0.692,0.4)，y分量的幅值最大，因此所有y坐标都被忽略。选择最大的幅值是为了避免投影到一个可能会产生退化、零面积三角形的平面上。请注意，为了提高效率，此组件信息可以预先计算一次并存储在多边形中。在这个投影过程中，多边形和交点的拓扑是守恒的(假设多边形确实是平的;有关此主题的更多信息，请参阅第16.2节)。投影程序如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114135127.png" class="" title="image-20211114135127">

<p>多边形顶点与交点p在xy平面上的正交投影，在xy平面上投影的多边形面积最大。这是一个使用降维来获得更简单计算的例子。</p>
<p><strong>剩下的问题是二维射线/平面交点p是否包含在二维多边形中。在这里，我们将回顾一个比较有用的算法——“交叉”测试。Haines和Schneider and Eberly提供了二维点对多边形策略的广泛研究。一种更正式的处理方法可以在计算几何文献中找到。Lagae和Dutr´e提供了一种基于M¨oller和Trumbore射线/三角形测试的射线/四边形相交的快速方法。Walker提供了一种快速测试10个以上顶点的多边形的方法。Nishita等人讨论了曲线边形状的点包含测试。</strong></p>
<h3 id="The-Crossings-Test-交叉测试"><a href="#The-Crossings-Test-交叉测试" class="headerlink" title="The Crossings Test 交叉测试"></a>The Crossings Test 交叉测试</h3><p><strong>交叉检验基于约当曲线定理，这是拓扑的结果。如果一条光线从该点沿平面任意方向穿过奇数条多边形边，则该点在多边形内。约当曲线定理实际上局限于非自交的循环。对于自相交的循环，这个射线测试使一些明显在多边形内部的区域被认为是在外部。如下图所示。这种检验也称为奇偶检验或偶奇检验。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114135533.png" class="" title="image-20211114135533">

<p>一个自相交的凹多边形，但它所有的封闭区域都不考虑在内(只有棕色区域在里面)。顶点用大的黑点标记。三个被测试的点和它们的测试射线被显示出来。根据约当曲线定理，如果与多边形的边相交的次数为奇数，则点在内。因此，最上面和最下面的点都在里面(分别是1和3个交叉点)。每个中间的两个点穿过两条边，因此被认为是在多边形的外面。</p>
<p><strong>交叉算法的工作原理是，从p点在x正方向(或任何方向;x方向的编码效率很高)。然后计算多边形边与这条射线之间的交叉数。正如约当曲线定理所证明的那样，奇数个交叉点表示该点在多边形内。</strong></p>
<p><strong>测试点p也可以被认为是在原点，而(平移)边则是针对正x轴进行测试。这个选项如下图所示。如果多边形边的y坐标具有相同的符号，则该边不能穿过x轴。否则，它可以，然后检查x坐标。如果两者都是正的，那么交叉的数量就会增加，因为测试射线必须到达这条边。如果它们的符号不同，则必须计算边与x轴交点的x坐标，如果x坐标为正，则交叉点的数量增加。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114135704.png" class="" title="image-20211114135704">

<p>多边形已经被−p (p是测试多边形中是否包含的点)翻译，因此与正x轴相交的次数决定了p是否在多边形内。边e0,e2,e3和e4 不要穿过x轴。边e的交点1 必须计算x轴，但不会产生交点，因为交点的x分量是负的。边e7 和e8 将增加交叉的数量，因为每条边的两个顶点有正的x分量和一个负的和一个正的y分量。最后，边e5 和e6 共享一个y = 0和x &gt;的顶点，它们将一起增加交叉点的数量1。通过考虑x轴上的顶点在射线e5 被归类为穿过射线，e6被归类为高于射线。</p>
<p><strong>在上图中，所有封闭区域都可以被分类为内部区域。这个变体测试找出圈数，即多边形循环绕测试点的次数。治疗方法见海恩斯的文章。</strong></p>
<p><strong>当测试射线与顶点相交时，可能会出现问题，因为可能会检测到两个相交点。这些问题可以通过考虑射线上方无穷小的顶点来解决，在实践中，可以通过将y≥0的顶点解释为也位于x轴(射线)上方来解决。代码变得更加简单和快速，因为没有顶点被相交。</strong></p>
<p><strong>下面是交叉测试的有效形式的伪代码。它的灵感来自Joseph Samosky和Mark hahigh - hutchinson的工作，代码可以在网上找到。一个二维测试点t和顶点为v0的多边形P 通过vn−1 进行了比较。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114135926.png" class="" title="image-20211114135926">

<p><strong>第3行检查多边形中最后一个顶点的y值是否大于或等于测试点t的y值，并将结果存储在布尔值y0．换句话说，它测试我们要测试的第一条边的第一个端点是在x轴之上还是之下。第7行测试端点是否为e0 和e1 在测试点形成的x轴的不同侧面。如果是，那么第8行测试x-截距是否为正。实际上，它要比这个快一些:为了避免计算截距通常需要的除法，我们在这里执行一个消号操作。通过内部倒置，第9行记录发生了交叉。第10行到第12行继续到下一个顶点。</strong></p>
<p><strong>在伪代码中，我们没有在第7行之后执行测试，以查看与测试点相比，两个端点的x坐标是更大还是更小。尽管我们提出的算法使用快速接受或拒绝这些类型的边，基于伪代码提出的代码通常运行更快，没有这个测试。一个主要的因素是被测试多边形的顶点数——如果顶点数更多，首先检查x坐标的差异会更有效。</strong></p>
<p><strong>交叉测试的优点是相对快速和健壮，不需要对多边形进行额外的信息或预处理。这种方法的一个缺点是，除了表示是否，它不会产生任何结果一个点在多边形的内部或外部。其他方法，如第22.8.1节中的射线/三角形测试，也可以计算重心坐标，用于插值关于测试点的附加信息。注意，重心坐标可以扩展到处理三个以上顶点的凸多边形和凹多边形。Jim´enez等人提供了一种基于重心坐标的优化算法，旨在包括多边形边缘的所有点，并与交叉测试竞争。</strong></p>
<p><strong>更普遍的问题是，确定一个点是否在由线段和B´ezier曲线组成的封闭轮廓内!B´ezier可以以类似的方式执行，计算射线交叉。Lengyel给出了一种鲁棒的算法来处理这一过程，将其用于像素着色器中来渲染文本。</strong></p>
<h2 id="Plane-Box-Intersection-平面-盒体交叉"><a href="#Plane-Box-Intersection-平面-盒体交叉" class="headerlink" title="Plane/Box Intersection 平面/盒体交叉"></a>Plane/Box Intersection 平面/盒体交叉</h2><p><strong>我们可以通过将点插入到平面方程(π: n·x + d = 0)中来知道点到平面的距离。结果的绝对值就是到平面的距离。平面/球面测试很简单:将球面的中心插入到平面方程中，看看其绝对值是否小于或等于球面的半径。</strong></p>
<p><strong>确定方框是否与平面相交的一个方法是将方框的所有顶点插入到平面方程中。如果同时得到一个正的和一个负的结果(或0)，那么顶点位于平面的两边(或上)，因此，一个交点已经被检测到。有一些更聪明、更快的方法来做这个测试，在接下来的两节中介绍，一节用于AABB，一节用于OBB。</strong></p>
<p><strong>这两种方法背后的想法是，八个角中只有两个需要插入到平面方程中。对于任意方向的方框，无论是否与平面相交，方框上对角相对的两个角是最大的距离，当沿着平面的法线测量时。每个盒子有四条对角线，由它的角组成。取每个对角线方向与平面法线的点积，最大的值表示这两个最远点的对角线。通过测试这两个角，整个盒子将在一个平面上进行测试。</strong></p>
<h3 id="AABB"><a href="#AABB" class="headerlink" title="AABB"></a>AABB</h3><p><strong>假设我们有一个AABB, B,定义为一个中心点,c,和正的一半对角向量,h。注意,可以很容易地将c和h来源于最小和最大的角落,B中的b^min和 b^max,也就是说,c = (b^max + b^min) / 2和h = (b^max− b^min) / 2。</strong></p>
<p><strong>现在，我们要在n·x + d = 0的平面上测试B。有一种非常快的方法来执行这个测试。理论上，可以通过将盒子的所有8条不同的对角线投影到法线上，并选择最长的一条来实现。然而，在实践中，这可以迅速实现</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114140749.png" class="" title="image-20211114140749">

<p><strong>为什么这等价于找到八个不同的半对角线投影的最大值?这8条半对角线是组合 g^i = (±hx, ±hy, ±hz)，我们要计算所有8个i的 g^i·n。当 g^i·n中的每一项都是正数时，它将达到最大值。对于x项，这发生在nx 和hx^i的符号相同，但既然我们知道hx 是正的，我们可以计算出最大项为hx| nx｜．对y和z也这样做得到方程22.18。</strong></p>
<p><strong>接下来，我们计算从中心点c到平面的带符号的距离s。这是通过:s = c·n + d完成的。s和e都在下图中说明。假设平面的“外部”是正的半空间，我们可以简单地测试是否s - e &gt; 0，这表明盒子完全在平面外部。类似地，s+e &lt; 0表示盒子完全在里面。否则，方框与平面相交。这一技术是基于Ville Miettinen的想法和巧妙的实现。伪代码如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114141125.png" class="" title="image-20211114141125">

<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114141212.png" class="" title="image-20211114141212">

<p>圆心为c，对角线为正的半对角线为h的轴对齐方框与平面π进行测试。这个想法是计算从方框中心到平面的带符号距离s，并将其与方框的“范围”e进行比较。向量g^i 是这个二维方框的不同对角线吗，其中h等于g¹ 在这个例子中。还要注意，带符号的距离s是负的，它的大小大于e，表明方框在平面内(s + e &lt; 0)。</p>
<h3 id="OBB"><a href="#OBB" class="headerlink" title="OBB"></a>OBB</h3><p><strong>对平面进行OBB测试与上一节的AABB/平面测试仅略有不同。它只是计算的“范围”的盒子需要改变，这是做</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114141511.png" class="" title="image-20211114141511">

<p><strong>回想一下(b^u, b^v, b^w)是OBB的坐标系轴(见章节22.2中OBB的定义)，( hu^B,hv ^B, hw^B)是方框沿这些轴的长度。</strong></p>
<h2 id="Triangle-Triangle-Intersection-三角形-三角形交叉"><a href="#Triangle-Triangle-Intersection-三角形-三角形交叉" class="headerlink" title="Triangle/Triangle Intersection 三角形/三角形交叉"></a>Triangle/Triangle Intersection 三角形/三角形交叉</h2><p><strong>由于图形硬件使用三角形作为其最重要的(和优化的)绘图原语，因此对这类数据执行碰撞检测测试也是很自然的。所以，最深层的碰撞检测算法通常有一个程序来决定两个三角形是否相交。给定两个三角形，T1 =△p1p2p3 和T2  =△q1q2q3 位于平面上π1 和π2，我们要确定它们是否相交。</strong></p>
<p><strong>从一个较高的层次，通常从检查T1 与π2相交，是否T2 与π1相交 。如果这些测试中的任何一个失败，就不可能有交集。假设三角形不是共面的，我们知道平面的交点是π1 和π2，将是一条直线L。如下图所示。从图中可以看出，如果三角形相交，它们在L上的交点也会有重叠。否则，就不会有交集。有许多不同的方法来实现这个方法，下面我们将介绍Guigue和Devillers的方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114141830.png" class="" title="image-20211114141830">

<p>三角形和它们所在的平面。在这两幅图中，交点间隔用红色标出。左:沿L线重叠的间隔，以及三角形。右:没有交集;这两个区间不重叠。</p>
<p><strong>在这个实现中，大量使用了来自四个三维向量a、b、c和d的4 × 4行列式:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114141933.png" class="" title="image-20211114141933">

<p><strong>在几何上，22.20式有直观的解释。这个叉乘，(b−a) × (c−a)，可以看作是计算一个三角形的法线，∆abc。通过取这个法线和向量a到d之间的点积，我们得到一个正值，如果d在三角形平面的正半空间，∆abc。另一种解释是，行列式的符号告诉我们b - a方向上的螺旋是否与d - c方向相同。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114142030.png" class="" title="image-20211114142030">

<p>螺旋向量b−a在d−c方向上的图解。</p>
<p><strong>我们首先检验T1 相交与π2，反之亦然。这可以用公式22.20中的特殊行列式来完成，方法是计算[q1,q2,q3,p1]、[q1,q2,q3,p2], [q1,q2,q3,p3］．第一个检验等价于计算T2的法线，然后测试哪个半空间与点p1 是在。如果这些行列式的符号相同且非零，那么就没有交集，测试结束。如果全部为零，则三角形共面，并执行一个单独的测试来处理这种情况。否则，继续测试是否T2 与π1相交，使用相同类型的测试。</strong></p>
<p><strong>在这一点，两个间隔，I1 = [i, j] 和 I2 = [k, l]，在l上被计算，其中I1 由T1 和I2 从T2．为了做到这一点，每个三角形的顶点都被重新排序，所以第一个顶点单独位于另一个三角形平面的一边。如果I1 与I2，则这两个三角形相交，这只发生在k≤j和i≤l。要实现k≤j，我们可以使用行列式的符号检验(方程22.20)，注意j是从p1p2推导出来的， k来自q1q2．利用行列式计算的“螺旋检验”的解释，我们可以得出，当[p1, p2, q1, q2]≤0时，k≤j。最后的测试变成了</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114142528.png" class="" title="image-20211114142528">

<p><strong>整个测试从六个决定性测试开始，前三个测试共享第一个参数，因此可以共享许多计算。原则上，行列式可以使用许多较小的2 × 2子行列式计算，当这些发生在多个4 × 4行列式中，计算可以共享。网络上有这个测试的代码，也可以通过扩充代码来计算实际的交点线段。</strong></p>
<p><strong>如果三角形共面，则将它们投影到轴向平面上，在这个平面上三角形的面积最大(第22.9节)。然后，进行了一个简单的二维三角形-三角形重叠测试。首先，测试所有的闭合边(即包括端点)T1 与T2的闭边相交．如果找到任何相交点，三角形就相交。否则，我们必须检验T1 完全包含在T2 反之亦然。这可以通过对T的一个顶点执行三角形内点测试(第22.8节)来完成T1 对T2，反之亦然。</strong></p>
<p><strong>注意，分离轴试验(见第947页)可用于推导三角形/三角形重叠试验。相反，我们提出了Guigue和Devillers的测试，它比使用SAT更快。还有其他算法可以执行三角形/三角形相交。架构和编译器的差异，以及预期命中率的差异，意味着我们不能推荐总是性能最好的单一算法。注意，精度问题可能会出现在任何几何测试中。Robbins和Whitesides使用了Shewchuk的精确算法来避免这种情况。</strong></p>
<h2 id="Triangle-Box-Intersection-三角形-盒体交叉"><a href="#Triangle-Box-Intersection-三角形-盒体交叉" class="headerlink" title="Triangle/Box Intersection 三角形/盒体交叉"></a>Triangle/Box Intersection 三角形/盒体交叉</h2><p><strong>本节介绍一个算法，用于确定一个三角形是否与一个轴对齐的框相交。这样的测试对于体素化和碰撞检测是有用的。</strong></p>
<p><strong>Green和Hatch提出了一种可以确定任意多边形是否与方框重叠的算法。Akenine-M¨oller开发了一种基于分离轴测试的更快的方法(第947页)，我们在这里介绍。三角形/球体测试也可以使用该测试进行，详见Ericson的文章。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114143200.png" class="" title="image-20211114143200">

<p>用于三角形/盒子重叠测试的符号。在左边，显示盒子和三角形的初始位置，而在右边，盒子和三角形已经被平移，使盒子的中心与原点重合。</p>
<p><strong>我们重点测试一个轴对齐的包围盒(AABB)，它由一个中心c和一个半长向量h定义，对应一个三角形∆u0u1u2．为了简化测试，我们首先移动方框和三角形，使方框围绕原点居中，即 vi = ui −c, i∈{0,1,2}。这种转换和使用的符号如上图所示。为了测试一个有方向的盒子，我们将首先通过反盒子变换旋转三角形顶点，然后使用这里的测试。基于分离轴测试(SAT)，我们测试了以下13个轴:</strong></p>
<pre><code>**1.[3 tests]e0 = (1,0,0)， e1 = (0,1,0)， e2 = (0,0,1) (AABB的法线)。换句话说，测试AABB与最小的AABB围绕三角形。**

**2.[1 test]n，∆u0u1u2的法线．我们使用快速平面/AABB重叠测试(第22.10.1节)，它只测试盒子对角线上与三角形法线最接近的两个顶点。**

**3.[9 tests]aij = ei ×fj ，i，j∈&#123;0,1,2&#125;，其中f0 = v1 −v0，f1 = v2 −v1和f2 = v0 −v2,即边向量。这些测试在形式上是相似的，我们只展示i = 0和j = 0情况下的推导(见下文)。**
</code></pre>
<p><strong>一旦找到分离轴，算法就终止并返回“无重叠”。“如果所有测试都通过了，也就是说没有分离轴，则三角形与方框重叠。</strong></p>
<p><strong>这里我们推出了9个测试中的一个，其中i = 0, j = 0，在步骤3中。这意味着a00 = e0 ×f0 =(0,−f0z,f0y）。现在我们需要把三角形顶点投影到a00 (以下称为一个):</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114143758.png" class="" title="image-20211114143758">

<p><strong>通常，我们需要找到min(p0,p1,p2)和max(p0,p1,p2)，但幸运的是p0 = p1，简化了计算。现在只需要求min(p0,p2)和max(p0,p2)，这要快得多，因为条件语句在现代CPUs上开销很大。</strong></p>
<p><strong>在三角形投影到a上之后，我们还需要将盒子投影到a上。我们计算投影在a上的方框的“半径”r</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114144011.png" class="" title="image-20211114144011">

<p><strong>最后一步对于这个轴ax = 0。然后，这个轴测试就变成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114144023.png" class="" title="image-20211114144023">

<p><strong>在网站获得。</strong></p>
<h2 id="Bounding-Volume-Bounding-Volume-Intersection-包围盒-包围盒交叉"><a href="#Bounding-Volume-Bounding-Volume-Intersection-包围盒-包围盒交叉" class="headerlink" title="Bounding-Volume/Bounding-Volume Intersection 包围盒/包围盒交叉"></a>Bounding-Volume/Bounding-Volume Intersection 包围盒/包围盒交叉</h2><p><strong>边界体积的目的是提供更简单的交叉测试和更有效的拒绝。例如，要测试两辆车是否相撞，首先找到它们的BVs并测试它们是否重叠。如果它们没有这样做，那么汽车就可以保证不发生碰撞(我们假设这是最常见的情况)。这样，我们就避免了测试一辆车的每个原语与另一辆车的每个原语，从而节省了计算。</strong></p>
<p><strong>一个基本的操作是测试两个边界体是否重叠。下面将介绍AABB、k-DOP和OBB的重叠测试方法。关于围绕原语形成BVs的算法，请参见第22.3节。</strong></p>
<p><strong>使用比球面和AABB更复杂的bv的原因是，更复杂的BVs通常具有更紧密的配合。如下图所示。当然，其他的边界卷也是可能的。例如，圆柱体和椭球体有时被用作物体的边界体。此外，可以放置几个球体来包围单个物体。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114144233.png" class="" title="image-20211114144233">

<p>一个球体(左)，一个AABB(中左)，一个OBB(中右)，和一个k-DOP(右)显示了一个对象，其中OBB和k-DOP明显比其他的空空间少。</p>
<p><strong>对于胶囊和菱形BVs来说，计算最小距离是一种相对快速的操作。因此，它们经常用于公差验证应用程序，其中需要验证两个(或多个)对象之间至少有一定的距离。Eberly和Larsen等人推导了这些类型的边界体的公式和有效算法。</strong></p>
<h3 id="Sphere-Sphere-Intersection-球-球的交叉"><a href="#Sphere-Sphere-Intersection-球-球的交叉" class="headerlink" title="Sphere/Sphere Intersection 球/球的交叉"></a>Sphere/Sphere Intersection 球/球的交叉</h3><p><strong>对于球体，相交测试是简单和快速的:计算两个球体的中心之间的距离，然后拒绝如果这个距离大于两个球体的半径和。否则,他们相交。在实现这个算法时，最好使用这两个量的距离的平方，因为所需要的只是比较的结果。这样，计算平方根(一个昂贵的避免操作)。Ericson给出了同时测试四对独立球体的SSE代码。</strong></p>
<h3 id="Sphere-Box-Intersection-球体-盒的交叉"><a href="#Sphere-Box-Intersection-球体-盒的交叉" class="headerlink" title="Sphere/Box Intersection 球体/盒的交叉"></a>Sphere/Box Intersection 球体/盒的交叉</h3><p><strong>Arvo首先提出了一种测试球体与AABB是否相交的算法，该算法非常简单。这个想法是找到在AABB上最接近球的中心的点，c。使用一维测试，对AABB的三个轴各一个。在AABB的边界上测试一个轴的球面中心坐标。如果它在边界之外，则计算球体中心和方框之间沿这个轴(一个减法)的距离并平方。在我们沿着三个轴做了这个之后，这些距离的平方之和与半径的平方r²相比较球面的。如果总和小于半径的平方，则最近的点在球体内部，并且盒子重叠。如Arvo所示，该算法可以修改为处理空心框和球体，以及轴向椭球。</strong></p>
<p><strong>Larsson等人提出了该算法的一些变体，包括一个相当快的SSE向量化版本。他们的观点是在早期使用简单的拒绝测试，或者每个轴，或者在一开始就全部使用。拒绝测试是看中心到盒子沿轴的距离是否大于半径。如果是这样，测试可以提前结束，因为球体不可能与盒子重叠。当重叠概率较低时，这种早期拒绝方法明显更快。接下来是他们测试的QRI(快速拒绝交织)版本。早期的输出测试位于第4行和第7行，如果需要可以删除它们。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114144744.png" class="" title="image-20211114144744">

<p><strong>对于快速的矢量化(使用SSE)实现，Larsson等人提出消除大部分分支。思路是使用下面的表达式同时计算第3行和第6行:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114144814.png" class="" title="image-20211114144814">

<p><strong>通常，我们将d更新为d = d+e²。然而，使用SSE，我们可以并行地计算方程22.25中的x、y和z。下面给出了完整测试的伪代码。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114144936.png" class="" title="image-20211114144936">

<p><strong>注意，第1行和第2行可以使用并行的SSE max函数来实现。即使在这个测试中没有提前推出，它仍然比其他技术更快。这是因为已经消除了分支，并且使用了并行计算。SSE的另一种方法是向量化对象对。Ericson给出了SIMD代码来同时比较四个球体和四个AABBs。</strong></p>
<p><strong>对于球/OBB相交，首先将球的中心转换到OBB的空间。也就是说，使用OBB的归一化轴作为转换球体中心的基础。现在这个中心点是相对于OBB的轴线表示的，所以OBB可以被视为AABB。然后使用球面/AABB算法进行交点测试。</strong></p>
<p><strong>Larsson给出了一种椭球体/OBB交会测试的有效方法。首先，两个物体都被缩放，使椭球变成一个球体，OBB成为一个平行六面体。可进行球/板交叉试验，快速验收和拒收。最后，测试球体是否与那些面对它的平行四边形相交。</strong></p>
<h3 id="AABB-AABB-Intersection-AABB-AABB交叉"><a href="#AABB-AABB-Intersection-AABB-AABB交叉" class="headerlink" title="AABB/AABB Intersection AABB / AABB交叉"></a>AABB/AABB Intersection AABB / AABB交叉</h3><p><strong>顾名思义，AABB是一个面与主轴方向对齐的盒子。因此，用两点就足以描述这样一个体积。这里我们使用第22.2节中给出的AABB的定义。</strong></p>
<p><strong>由于其简单性，AABBs通常被用于碰撞检测算法和场景图中节点的包围体。两个AABBs，A和B相交的检验是平凡的，总结如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114145212.png" class="" title="image-20211114145212">

<p><strong>第1行和第2行在x、y和z三个标准轴方向上循环。Ericson提供了SSE代码，用于同时测试四对独立的AABBs。</strong></p>
<h3 id="k-DOP-k-DOP-Intersection-k-DOP-k-DOP交叉"><a href="#k-DOP-k-DOP-Intersection-k-DOP-k-DOP交叉" class="headerlink" title="k-DOP/k-DOP Intersection  k-DOP / k-DOP交叉"></a>k-DOP/k-DOP Intersection  k-DOP / k-DOP交叉</h3><p><strong>一个k-DOP与另一个k-DOP的交集检验只包含k/2区间重叠检验。Klosowski等人的研究表明，对于中等k值，两个k-DOPs的重叠测试比两个OBBs的测试快一个数量级。在第946页的图22.4中，描述了一个简单的二维k-DOP。注意，AABB是一个6-DOP的特殊情况，其中法线是正和负主轴方向。OBBs也是6-DOP的一种形式，但这种快速测试只能在两个OBBs共享同一轴时使用。</strong></p>
<p><strong>下面的交叉测试简单而快速，不精确但保守。如果要测试两个k-DOPs, A和B(上标索引为A和B)是否相交，则测试所有平行平板对(Si^A, Si^B)用于重叠;si =Si^A∩ Si^B是一维区间重叠检验，求解起来比较容易。这是第22.5节中的经验法则所推荐的降维示例。本文将三维平板试验简化为一维区间重叠试验。</strong></p>
<p><strong>如果在任何时候i =∅(即空集)BVs不相交，测试终止。否则，平板重叠测试将继续进行。当且仅当所有si ≠∅,1≤i≤k/2，则认为BVs重叠。根据分离轴测试(第22.2节)，还需要测试一个平行于每个k-DOP的一条边的叉积的轴。然而，这些测试经常被忽略，因为它们的成本高于它们在性能上的回报。因此，如果下面的测试返回k- DOPs重叠，那么它们实际上可能是不相交的。下面是k-DOP/k-DOP重叠测试的伪代码:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114145951.png" class="" title="image-20211114145951">

<p><strong>注意，在k- DOP的每个实例中只需要存储k个标量值(法线ni，对于所有k- DOPs只存储一次，因为它们是静态的)。如果k- DOPs被t^A 和t^B ，则测试会稍微复杂一点。项目t^A 在法线上，ni,例如,pi^A= t^A·ni (注意，这与任何k-DOP无关，因此对于每个t^A 或t^B只需要计算一次 )，在if语句中加上pi^A到 di^(A, min)和 di^(A,max)。同样的方法也适用于 t^B。换句话说，平移改变了k-DOP沿每个法线方向的距离。</strong></p>
<p><strong>Laine 和 Karras提出了k- DOPs的一种扩展，称为顶点映射。这个想法是将一组平面法线映射到k-DOP上的各个点，这样存储的每个点都代表沿着该方向最远的位置。这个点和方向形成了一个平面，在一个半空间内完全包含模型，即点在模型的k-DOP的顶点。在测试过程中，给定方向的顶点可以用于更精确的k- DOPs之间的交叉测试，用于改进截锥剔除，以及在旋转后寻找更紧密的AABBs等。</strong></p>
<h3 id="OBB-OBB-Intersection-OBB-OBB的交叉"><a href="#OBB-OBB-Intersection-OBB-OBB的交叉" class="headerlink" title="OBB/OBB Intersection OBB / OBB的交叉"></a>OBB/OBB Intersection OBB / OBB的交叉</h3><p><strong>在本节中，我们简要概述了一种快速测试两个OBBs, A和B之间交集的方法。该算法使用分离轴测试，比以前使用最接近特征或线性规划的方法快一个数量级。OBB的定义见第22.2节。</strong></p>
<p><strong>测试是在A的中心和轴线组成的坐标系中进行的。这意味着原点是a^c =(0,0,0)这个坐标系的主轴是a^u = (1,0,0)， a^v = (0,1,0)， a^w =(0,0,1)。假设B相对于A，平移t，旋转(矩阵)R。</strong></p>
<p><strong>根据分离轴测试，只要找到一个将A和B分开的轴，就可以保证它们不相交(不重叠)。需要测试15个轴:3个来自A的面，3个来自B的面，3·3 = 9来自A和B的边的组合。这在下图的二维图中显示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211114150749.png" class="" title="image-20211114150749">

<p>为了确定两个OBBs是否重叠，可以使用分离轴测试。这里，它是二维的。四个分离轴与两个OBBs的面正交，每个盒子有两个轴。OBBs被投影到坐标轴上。如果两个投影在所有轴上重叠，则OBBs重叠;否则，它们就不会。因此，只要找到一个将投影分开的轴，就可以知道OBBs没有重叠。在本例中，左下角的轴是分隔投影的唯一轴。(参见Ericson。)</p>
<p><strong>作为矩阵a = (a^u a^v a^w)的标准正交性的结果，应该与A的面正交的潜在分离轴仅仅是轴 a^u a^v a^w。B也是如此。剩下的9个势轴，分别由A和B的一条边组成，则 c^ij = a^i ×b^j，∀i∈{u, v, w}和∀j∈{u, v, w}。幸运的是，在线上有对此进行优化的代码。</strong></p>
<h2 id="View-Frustum-Intersection-视锥交叉"><a href="#View-Frustum-Intersection-视锥交叉" class="headerlink" title="View Frustum Intersection 视锥交叉"></a>View Frustum Intersection 视锥交叉</h2><p><strong>正如在第19.4节中所看到的，分层视图截锥剔除对于快速渲染复杂场景至关重要。在边界体积层次剔除遍历过程中调用的少数操作之一是视图截锥和边界体积之间的交集测试。因此，这些操作对于快速执行至关重要。理想情况下，他们应该确定BV是完全在内部(包含)，还是完全在外部(排除)，或者它与截锥相交。</strong></p>
<p><strong>回顾一下，视图截锥是一个被近平面和远平面截断的金字塔(它们是平行的)，使体积有限。事实上，它变成了一个多面体。如下图所示，六个平面的名称，近、远、左、右、上、下也被标记了出来。视图截锥体定义了场景中应该可见的部分，从而进行渲染(以金字塔截锥的视角)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115133303.png" class="" title="image-20211115133303">

<p>左边的插图是一个无限的金字塔，然后被平行的近平面和远平面裁剪来构建一个视图截锥。其他平面的名称也显示出来，摄像机的位置是在金字塔的顶端。</p>
<p><strong>用于层次结构(例如场景图)内部节点和外围几何的最常见的包围体是球体、AABBs和OBBs。因此，锥/球和锥/AABB/OBB测试将在这里讨论和推导。</strong></p>
<p><strong>为了了解为什么我们需要三个返回结果outside/inside/intersect，我们将检查遍历边界体积层次结构时发生了什么。如果一个BV被发现完全在视图截锥之外，那么该BV的子树将不会被进一步遍历，它的任何几何体都不会被渲染。另一方面，如果BV完全在内部，那么就不需要为该子树计算更多的截锥/BV测试，每个可渲染的叶子将被绘制。对于部分可见的BV，即，它与截锥相交，BV的子树被递归地针对截锥进行测试。如果BV是一个叶子，那么这个叶子必须被渲染。</strong></p>
<p><strong>完整检验称为差集/并集/交集检验。有时，第三种状态，交集，可能被认为是太昂贵的计算。在这种情况下，BV被归类为“可能在内部”。“我们称这种简化的算法为差集/并集测试。如果不能成功排除BV，则有两个选择。一种是将“可能在内部”的状态视为包含，这意味着BV内部的所有内容都被渲染。这通常是低效的，因为不执行进一步的筛选。另一种选择是依次测试子树中的每个节点是否排除。这样的测试通常是没有好处的，因为许多子树可能确实在截锥中。因为这两个选择都不是特别好，所以一些快速区分交集和包含的尝试通常是值得的，即使测试并不完美。</strong></p>
<p><strong>重要的是要认识到，快速分类测试不必是精确的场景图剔除，只是保守。为了区分排除和纳入，所需要的只是测试在纳入方面出错。也就是说，实际上应该排除的对象可能会被错误地包括进来。这样的错误只会花费额外的时间。另一方面，应该包含的对象永远不应该被测试快速分类为被排除的对象，否则将发生呈现错误。对于包含和交集，任何一种错误分类通常都是合法的。如果将一个完全包含的BV归为相交，则测试其子树是否存在交集会浪费时间。如果一个相交的BV完全被考虑在内，渲染所有对象会浪费时间，其中一些对象可能已经被剔除。</strong></p>
<p><strong>在介绍截锥与球体(AABB或OBB)之间的试验之前，我们将描述截锥与一般物体之间的交叉试验方法。这个测试如下图所示。其想法是将测试从BV/截锥测试转换为点/体积测试。首先，选择一个相对于BV的点。然后BV沿着截锥的外侧移动，尽可能接近它而不重叠。在这个移动过程中，相对于BV的点被跟踪，它的轨迹形成一个新的体积(下图中有厚边的多边形)。事实上，BV被移动到尽可能接近截锥的位置，这意味着如果相对于BV的点(在其原始位置)位于描出的体积内，那么BV与截锥相交或在截锥内。所以，不是测试BV与截锥的交点，相对于BV的点是测试另一个新的体积，由点描出。以同样的方式，BV可以沿着截锥的内部移动，并尽可能接近截锥。这将绘制出一个新的、更小的截锥，其平面与原始截锥平行。如果相对于物体的点在这个新体积内，那么BV就完全在截锥内。在后面的部分中，将使用此技术导出测试。注意，新体积的创建与实际BV的位置无关——它只依赖于相对于BV的点的位置和BV的形状。这意味着具有任意位置的BV可以用相同的体积进行测试。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115133651.png" class="" title="image-20211115133651">

<p>左上方的图像显示了一个截锥(蓝色)和一个一般的包围体(绿色)，其中一个相对于对象的点p已经被选中。通过追踪物体在截锥的外部(右上)和内部(左下)移动的点p，尽可能接近截锥，截锥/BV可以被重新定义为针对外部和内部体积测试点p。这在右下角显示。如果点p在橙色体积的外面，则BV在截锥的外面。如果p在橙色区域内，则BV与截锥相交，如果p在紫色区域内，则BV完全在截锥内。</p>
<p><strong>只保存父BV与每个子BV的交集状态是一种有用的优化。如果已知父元素完全位于截锥内部，则任何子元素都不需要进一步的截锥测试。平面掩蔽和时间相干技术是一种新的技术在第19.4节中使用的方法也可以显著改进针对边界卷层次结构的测试，尽管对于SIMD实现来说用处不大。</strong></p>
<p><strong>首先，我们推导出截锥的平面方程，因为这类试验需要这些方程。接着介绍了截锥/球面相交，接着解释了截锥/盒体相交。</strong></p>
<h3 id="Frustum-Plane-Extraction-视锥平面提取"><a href="#Frustum-Plane-Extraction-视锥平面提取" class="headerlink" title="Frustum Plane Extraction 视锥平面提取"></a>Frustum Plane Extraction 视锥平面提取</h3><p><strong>为了做视图截锥剔除，需要截锥的六个不同侧面的平面方程。我们在这里提出一种聪明而快速的方法来获得这些。假设视图矩阵为V，投影矩阵为P，则复合变换为M = PV。点s(其中sw = 1)转化为t = ms，此时，t可能有tw ≠ 1，因为，例如，透视投影。因此，t中的所有分量都除以tw 用u得到点uw = 1。对于视图截锥内的点，认为−1≤ui≤1，对于i∈x, y, z，即点u在里面一个单位立方体。这是针对OpenGL类型的投影矩阵(章节4.7)。对于DirectX，同样成立，除了0≤uz ≤1。截体的平面可以直接由复合变换矩阵的行推导出来。</strong></p>
<p><strong>先关注一下单位立方体左侧平面右侧的体积，其中−1≤ux。这一点在下面展开:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115134224.png" class="" title="image-20211115134224">

<p><strong>在推导过程中，mi, 表示M中的第i行。最后一步中(m0, + m3,)·s≥0实际上表示视图截锥左平面的(半)平面方程。这是因为单位立方体中的左平面已经被转换回世界坐标。还要注意sw = 1，使方程成为一个平面。为了使平面的法线点从截锥向外，方程必须被否定(就像描述单位立方体内部的原始方程一样)。这给了−(m3, + m0,·(x, y, z, 1) = 0对于截锥的左平面(这里我们使用(x, y, z, 1)而不是使用形式为:ax + by + cz + d = 0的平面方程)。总而言之，所有的平面都是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115134521.png" class="" title="image-20211115134521">

<p><strong>OpenGL和DirectX中的代码可以在web上找到。</strong></p>
<h3 id="Frustum-Sphere-Intersection-视锥体-球体交叉"><a href="#Frustum-Sphere-Intersection-视锥体-球体交叉" class="headerlink" title="Frustum/Sphere Intersection 视锥体/球体交叉"></a>Frustum/Sphere Intersection 视锥体/球体交叉</h3><p><strong>正射影视图的截锥体是一个盒体，因此在这种情况下的重叠测试是一个球体/OBB相交，可以使用22.13.2节给出的算法来解决。为了进一步测试球体是否完全在盒子内部，我们首先检查球体的中心是否沿着每个轴在盒子边界之间的距离大于它的半径。如果它在所有三个维度之间，它就是完全包含的。关于这个修改过的算法的有效实现，以及代码，请参阅Arvo的文章。</strong></p>
<p><strong>按照推导截锥/BV测试的方法，对于任意截锥，我们选择球的中心作为跟踪点p。如下图所示。如果半径为r的球体，沿着截锥的内部和外部移动，并且尽可能地靠近截锥，那么p的轨迹给了我们重新制定截锥/球体测试所需的体积。实际的体积显示在下图的中间部分。和之前一样，如果p在橙色外面体积，那么球面在截锥外。如果p在紫色区域内，那么球面完全在截锥内。如果点在橙色区域内，则球面与截锥侧面平面相交。这样，精确的测试就可以完成了。然而，为了效率起见，我们使用下图右侧的近似。在这里，为了避免圆角需要的更复杂的计算，橙色的体积被扩展了。注意,外卷由平面的视锥体r移动距离单位向外的方向平截头体平面正常,而内部体积可以创建通过移动平面视锥体r距离单元内的视锥体平面法线的方向。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115134955.png" class="" title="image-20211115134955">

<p>在左边显示了一个截锥和一个球体。精确的截锥/球体测试可以表述为测试p与中间图中的橙色和紫色体积。右边是中间体积的合理近似。如果球体的中心位于圆角外，但在所有外平面内，它将被错误地分类为相交，即使它是在截锥外。</p>
<p><strong>假设截锥的平面方程是这样的:正半空间位于截锥的外面。然后，一个实际的实现将在截锥的六个平面上进行循环，对于每个截锥平面，计算从球体中心到平面的带符号的距离。这是通过将球心插入平面方程来完成的。如果距离大于半径r，那么球面在截锥外。如果到所有六个平面的距离都小于- r，则球体在截锥内;否则球面与它相交。更准确地说，我们说球体与截锥相交，但球体中心可能位于上图中圆角外的一个尖角区域。这意味着球体在截锥的外面，但我们认为它是相交的，保守地说，是正确的。</strong></p>
<p><strong>为了使测试更精确，如果球体在外面，可以添加额外的平面进行测试。然而，为了快速剔除场景图节点，偶尔的错误命中只会导致不必要的测试，而不是算法失败，而且这种额外的测试总体上会花费更多的时间。在第20.3节中描述了另一种更精确(尽管仍然不精确)的方法，这种方法在这些尖角区域非常重要时很有用。</strong></p>
<p><strong>对于有效的着色技术，锥体通常是高度不对称的，一个特殊的方法描述在第895页的图20.7。Assarsson和M¨oller提供了一种方法，通过将截锥分割成八进制并找出物体的中心位于哪个八进制中，从而消除了每个测试中的三个平面。</strong></p>
<h3 id="Frustum-Box-Intersection-视锥体-盒的交叉"><a href="#Frustum-Box-Intersection-视锥体-盒的交叉" class="headerlink" title="Frustum/Box Intersection 视锥体/盒的交叉"></a>Frustum/Box Intersection 视锥体/盒的交叉</h3><p><strong>如果视图的投影是正投影(即通过OBB/OBB交叉测试(章节22.13.5)，可以进行精确的测试。对于一般的截锥/箱交叉测试，有两种常用的方法。一个简单的方法是通过使用截锥的视图和投影矩阵将所有8个方框角转换为截锥的坐标系统。执行沿每个轴延伸[−1,1]的规范视图体积的剪辑测试(章节4.7.1)。如果所有的点都在一个边界之外，盒子就会被拒绝;如果所有的都在，这个盒子就被完全包含了。由于此方法模拟裁剪，它可以用于由一组点分隔的任何对象，如线段、三角形或k-DOP。这种方法的优点是不需要提取截锥平面。它的自包含的简单性使它在计算着色器中高效使用。</strong></p>
<p><strong>一个在CPU上相当有效的方法是使用在22.10节中描述的平面/盒相交测试。像截锥/球体测试一样，OBB或AABB是针对六个视图截锥平面进行检查的。在平面/盒测试中，我们最多检查两个角，而不是计算从平面到所有八个角的标记距离，由飞机的正常状态决定。如果最近的角在平面外面，盒子完全在外面，测试可以提前结束。如果每个平面的最远角在内部，则方框包含在截锥内部。注意，远近平面的点积距离计算是可以共享的，因为这些平面是平行的。第二种方法的唯一额外费用是必须首先得到截锥的平面，如果要测试几个箱子的话，这是一笔微不足道的费用。</strong></p>
<p><strong>与截锥/球体算法一样，测试也需要将实际完全位于外部的交叉框进行分类。这些类型的错误如下图所示。Qu´ılez指出，在固定大小的地形网格或其他大型物体中，这种情况会更频繁地发生。当报告了一个交集时，他的解决方案是随后也测试每个形成边界框的平面上的截锥角。如果所有的点都在一个方框的平面外，截锥和方框就不相交。这个额外的测试相当于分离轴测试的第二部分，其中被测试的轴与第二个对象的面正交。也就是说，这种额外的检测可能比累积的收益更昂贵。对于他的GIS渲染器，Eng发现这种优化每帧消耗2毫秒的CPU时间，只节省了一些绘制调用。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115135403.png" class="" title="image-20211115135403">

<p>粗体的黑线是截锥的平面。当使用所提出的算法测试框(左)与截锥时，框可能被错误地分类为相交时，它是在外面。对于图中的情况，当方框的中心位于红色区域时，就会发生这种情况。</p>
<p><strong>Wihlidal使用截锥剔除的另一个方向，只使用四个截锥侧面，而不执行近平面和远平面剔除测试。他指出，这两架平面在电子游戏中并没有多大帮助。近的平面大多是多余的，因为侧面几乎修剪了它所做的所有空间，而远面通常设置为查看场景中的所有物体。</strong></p>
<p><strong>另一种方法是使用分离轴测试(见22.13节)来推导交集例程。一些作者使用分离轴检验来求解两个凸多面体的通解。一个单一的优化测试可以用于线段、三角形、AABBs、OBBs、 k-DOPs、视锥体和凸多面体的任何组合。</strong></p>
<h2 id="Line-Line-Intersection-线-线交叉"><a href="#Line-Line-Intersection-线-线交叉" class="headerlink" title="Line/Line Intersection 线/线交叉"></a>Line/Line Intersection 线/线交叉</h2><p><strong>在本节中，推导和检查了二维和三维的线/线相交测试。线、射线和线段彼此相交，并描述了既快速又优雅的方法。</strong></p>
<h3 id="Two-Dimensions-二维"><a href="#Two-Dimensions-二维" class="headerlink" title="Two Dimensions 二维"></a>Two Dimensions 二维</h3><h4 id="First-Method-方法一"><a href="#First-Method-方法一" class="headerlink" title="First Method 方法一"></a>First Method 方法一</h4><p><strong>从理论的角度来看，计算一对二维线的交点的第一种方法是非常漂亮的。考虑两条直线r1(s)= o1 + sd1 和r2(t) = o2 +td2。自从a·a^⊥ = 0 (perp点积来自章节1.2.1)，r1(s)和r2变得优雅而简单。请注意这部分中的所有向量都是二维的</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115140215.png" class="" title="image-20211115140215">

<p><strong>如果d1 ·d2^⊥ = 0，则两直线平行且不相交。对于无限长的线，所有的s和t值都是有效的，但是对于线段(具有标准化方向)，长度为l1 和l2 (从s = 0开始，t = 0结束于s = l1,t = l2)，当且仅当0≤s≤l1和0≤t≤l2时，我们有一个有效的交集。或者，如果设o1 = p1 和d1 = p2 −p1 (意思是线段从p1 在p2处结束)，同理求r2 起点和终点是q1 和q2，则当且仅当0≤s≤1,0≤t≤1时，存在有效交。对于有原点的射线，有效范围为s≥0,t≥0。交点可以通过把s代入r1 或者把t代入r2得到。</strong></p>
<h4 id="Second-Method-方法二"><a href="#Second-Method-方法二" class="headerlink" title="Second Method 方法二"></a>Second Method 方法二</h4><p><strong>Antonio描述了另一种判断两条线段(即。通过做更多的比较和早期的拒绝，以及避免前面公式中昂贵的计算(除法)，实现了交叉。因此，这种方法更快。再次使用前面的符号，即第一个线段从p1到p2 开始第二个来自q1到q2．这意味着r1(s)= p1 + s (p2 −p1)和r2(t) =q1 + t(q2 −q1）。用22.28式的结果求得一个解r1(s) = r2(t)：</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115140816.png" class="" title="image-20211115140816">

<p><strong>在22.29式中，a = q2 −q1， b = p2 −p1， c = p1 −q1， d = c·a^⊥，e = c·b^⊥，f = a·b^⊥。因子s的简化步骤来自以下事实： a^⊥·b =−b^⊥·a和 a·b^⊥= b^⊥·a，如果 a·b^⊥= 0，那么这两条线是共线的。Antonio注意到s和t的分母是相同的，由于s和t不是明确需要的，可以省略除法运算。定义s = d/f和t = e/f。要测试0≤s≤1，使用以下代码:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115141519.png" class="" title="image-20211115141519">

<p><strong>经过检验，保证0≤s≤1。然后对t = e/f执行同样的操作(通过将代码中的d替换为e)。如果例程在测试后没有返回，线段就会相交，因为t值也有效。</strong></p>
<p><strong>这个例程的整数版本的源代码可以在网上找到，并且很容易转换为浮点数使用。</strong></p>
<h3 id="Three-Dimensions-三维"><a href="#Three-Dimensions-三维" class="headerlink" title="Three Dimensions 三维"></a>Three Dimensions 三维</h3><p><strong>假设我们想在三维空间中计算两条直线(由射线定义，方程22.1)的交点。这些线也称为r1(s)= o1 + sd1 和r2(t) = o2 +td2,没有限制的值t。三维对应的补点产品,在这种情况下,叉乘,因为a×a= 0,因此三维版本是一样的推导二维的版本。两条直线的交点推导如下:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115141855.png" class="" title="image-20211115141855">

<p><strong>第三步是减去o1 (o2)，然后与d2 (d1)，步骤4用d1 ×d2 (d2 ×d1）点乘得到.最后，第5步，解是将等式右边写成行列式(并改变下面方程的一些符号)然后除以s (t)右边的项。</strong></p>
<p><strong>Goldman指出，如果分母是||d1 ×d2||² = 0，那么这两条线平行。他还注意到，如果线是倾斜的(即它们不共面),则s和t参数表示最接近的点。</strong></p>
<p><strong>如果这些线被当作线段，长度为l1 和l2 (假设方向向量d1 和d2 均归一化)，然后检查0≤s≤l1和0≤t≤l2 两种。如果不是，则拒绝交集。</strong></p>
<p><strong>Rhodes对两条直线或线段相交问题给出了深入的解决方案。他给出了处理特殊情况的健壮解决方案，并讨论了优化并提供了源代码。</strong></p>
<h2 id="Intersection-between-Three-Planes-三个平面交叉"><a href="#Intersection-between-Three-Planes-三个平面交叉" class="headerlink" title="Intersection between Three Planes 三个平面交叉"></a>Intersection between Three Planes 三个平面交叉</h2><p><strong>给定三个平面，每个平面由一个标准化的法向量ni描述，以及平面上任意点pi， i = 1, 2，和3，这两个平面的交点p由下方程给出。注意，如果有两个或多个平面平行，则分母，即三个平面法线的行列式为零:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115142645.png" class="" title="image-20211115142645">

<p><strong>该公式可用于计算由一组平面组成的曲面的角。一个例子是k-DOP，它由k个平面方程组成。上方程可以计算凸多面体的角，如果它是由适当的平面提供的。</strong></p>
<p><strong>通常情况下，如果平面以隐式形式给出，即πi : ni ·x +di = 0，那么我们需要找到点pi 为了能够使用这个方程。可以选择平面上的任意点。我们计算离原点最近的点，因为这些计算很便宜。给定一条来自原点的光线，沿着平面的法线，与平面相交，得到离原点最近的点:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211115142920.png" class="" title="image-20211115142920">

<p><strong>这个结果不应该让人感到惊讶，因为di 在平面方程中，原点到平面的负距离是垂直的(如果这是真的，法线必须是单位长度)。</strong></p>
<h1 id="23-Graphics-Hardware-图形硬件"><a href="#23-Graphics-Hardware-图形硬件" class="headerlink" title="23 Graphics Hardware 图形硬件"></a>23 Graphics Hardware 图形硬件</h1><p><strong>尽管图形硬件正在快速发展，但在其设计中仍有一些通用的概念和架构。我们在这一章的目标是给一个图形系统的各种硬件元素的理解，以及它们如何相互关联。书的其他部分讨论了它们与特定算法的使用。这里，我们根据硬件本身的条件来介绍硬件。我们首先描述如何栅格化线条和三角形，然后演示GPU的大规模计算能力是如何工作的，任务是如何调度的，包括处理延迟和占用。然后我们讨论内存系统，缓存，压缩，颜色缓冲，以及GPU中与深度系统相关的一切。然后介绍纹理系统的细节，然后介绍GPU的架构类型。在第23.10节中介绍了三种不同体系结构的案例研究，最后简要讨论了光线追踪体系结构。</strong></p>
<h2 id="Rasterization-光栅化-2"><a href="#Rasterization-光栅化-2" class="headerlink" title="Rasterization 光栅化"></a>Rasterization 光栅化</h2><p><strong>任何GPU的一个重要特性就是它绘制三角形和直线的速度。如2.4节所述，光栅化包括三角形设置和三角形遍历。此外，我们将描述如何在三角形上插值属性，这与三角形遍历密切相关。我们以保守光栅化结束，它是标准光栅化的扩展。</strong></p>
<p><strong>回想一下，像素的中心是(x+0.5, y+0.5)，其中x∈[0,W−1]，y∈[0,H−1]为整数，W × H为屏幕分辨率，如3840 × 2160。设非变换顶点为vi，i∈{0,1,2}，变换后的顶点(包括投影但不除w)为qi = Mvi．二维屏幕空间坐标为pi =((qix/qiw + 1)W/2， (qiy/qiw + 1)H/2) ，则执行透视图除以w分量，并将值进行缩放和转换以匹配屏幕分辨率。这个设置如下图所示。是可以如图所示，像素网格被划分为2 × 2像素组，称为四边形。为了能够计算纹理细节级别(第23.8节)所需的导数，对所有三角形中至少有一个像素的四边形计算像素着色(也在第3.8节中讨论)。这是大多数GPU(如果不是全部的话)的核心设计，并影响了许多后续阶段。三角形越小，辅助像素与三角形内像素的比例就越大。这种关系意味着在执行像素着色时，小三角形是昂贵的(与三角形面积成比例)。最糟糕的情况是一个三角形覆盖一个像素，这意味着它需要三个辅助像素。辅助像素的数量有时被称为四边形着色。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116132646.png" class="" title="image-20211116132646">

<p>一个三角形，有三个二维顶点p0,p1和p2 在屏幕空间。屏幕的尺寸是16 × 8像素。注意，像素(x, y)的中心是(x + 0.5, y + 0.5)。底边的法向量(长度按0.25缩放)显示为红色。只有绿色的像素在三角形内。黄色的辅助像素属于正方形(2 × 2像素)，其中至少有一个像素被认为是在里面，而辅助像素的样本点(中心)在三角形外面。使用有限差分计算导数时需要辅助像素。</p>
<p><strong>为了确定一个像素中心或任何其他样本位置是否在一个三角形内，硬件对每个三角形边缘使用一个边缘函数。这些是基于直线方程的，也就是，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116132813.png" class="" title="image-20211116132813">

<p><strong>其中n是一个向量，有时称为边的法向量，与边正交，p是直线上的一点。这样的方程可以写成ax+by +c = 0。接下来，我们将推导出边函数e2(x, y)到p0 和p1．边向量是p1 −p0，法线就是这条边逆时针旋转90度，也就是 n2 =(−(p1y−p0y)， p1x−p0x)，指向三角形内部，如上图所示。通过插入n2 和p0 代入上方程,e2(x, y)变成了</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116132956.png" class="" title="image-20211116132956">

<p><strong>对于边上的点(x, y) e(x, y) = 0。将法线指向三角形内侧意味着e(x, y) &gt; 0表示与法线同边的点。这条边将空间分成两部分，e(x, y) &gt; 0有时被称为正半空间，e(x, y) &lt; 0被称为负半空间。这些属性可以用来确定一个点是否在三角形内。称三角形的边为ei，i∈{0,1,2}。如果一个采样点(x, y)在三角形内或在三角形的边缘，那么它必须保持ei(x, y)对所有i≥0。</strong></p>
<p><strong>图形API规范经常要求将屏幕空间中的浮点顶点坐标转换为定点坐标。这样做是为了以一致的方式定义平局规则(稍后将介绍)。它还可以使样品的内部测试更有效。两个pix 和piy 可以存储，例如，1.14.8位，即1符号位，14位为整数坐标，8位为像素内的小数位置。在这种情况下，这意味着可以有2⁸ 个在一个像素内x和y的可能位置，并且整数坐标必须在[−(2^14−1)， 2^14−1]范围内。在实际操作中，这种接合是在计算边方程之前完成的。</strong></p>
<p><strong>边函数的另一个重要特征是它的增量性质。假设我们在某个像素中心(x, y) = (xi + 0.5,yi + 0.5),其中(xi , yi)为整数像素坐标，即我们求出e(x, y) = ax+by+c。例如，要计算右边的像素，我们需要计算e(x + 1, y)，它可以重写为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116133337.png" class="" title="image-20211116133337">

<p><strong>即这只是在当前像素e(x, y)加上a处计算的边函数。类似的推理可以应用于y方向，这些属性通常被用来快速计算一小块像素中的三个边方程，例如，8 × 8像素，用每个像素一个比特来“戳穿”覆盖掩码，表示该像素是否在内部。稍后将在本节中解释这种层次遍历。</strong></p>
<p><strong>重要的是要考虑当一条边或一个顶点恰好经过一个像素中心时会发生什么。例如，假设两个三角形共享一条边，这条边通过一个像素中心。它应该属于第一个三角形，第二个，还是两个都属于?从效率的角度来看，这两个答案都是错误的，因为像素首先会被一个三角形写入，然后被另一个三角形覆盖。为此，通常使用平局规则，这里我们展示了在DirectX中使用的左上角规则。像素在ei(x, y) &gt; 0，对于所有i∈{0,1,2}，总是被认为在内部。当一条边经过一个像素时，左上角的规则起作用。如果像素的中心位于上边缘或左边缘上，则该像素被认为是内部的。如果一条边是水平的，而其他边在它下面，那么它就是上边。如果一条边是非水平的，并且位于三角形的左侧，那么它就是一条左边，这意味着一个三角形最多可以有两条左边。它可以简单地检测边缘是顶部还是左侧。A上边缘的a = 0(水平)和b &lt; 0，而左边缘的a&gt; 0。确定采样点(x, y)是否在三角形内的整个测试有时被称为内部测试。</strong></p>
<p><strong>我们还没有解释如何穿越线路。一般来说，一条线可以被渲染成一个长方形，像素宽的矩形，它可以由两个三角形组成，也可以为矩形使用一个额外的边方程。这种设计的优点是边方程的硬件同样适用于线。点被画成四边形。</strong></p>
<p><strong>为了提高效率，通常采用分层的方式进行三角遍历。通常，硬件会计算屏幕空间顶点的边界框，然后确定哪些tile位于边界框内，并且与三角形重叠。确定瓦片是否在边缘之外，可以使用第22.10.1节AABB/平面试验的二维版本技术。一般原理如下图所示。为了适应平铺三角形遍历，我们可以首先确定在遍历开始之前，应该用边缘测试哪个平铺角。对于特定边缘的所有瓦片，使用的瓦片角是相同的，因为最近的瓦片角只取决于边缘法线。对这些预定角的边缘方程进行计算，如果这个选定的角在其边缘之外，则整个平铺在外部，硬件不需要在该平铺中执行任何逐像素的内部测试。要移动到相邻的贴图，可以对每递增属性。例如，要向右水平移动8个像素，就需要添加8a。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116133701.png" class="" title="image-20211116133701">

<p>边函数的负半空间e(x, y) &lt; 0总是被认为在三角形外。在这里，4×4像素贴图的角落被投影到边缘的法线上。只有带有黑圆的角需要用这条边来测试，因为它在n上的投影是最大的。然后可以得出结论，这个瓷砖在三角形的外面。</p>
<p><strong>有了贴图/边缘相交测试，就有可能分层遍历三角形。如下图所示。tiles也需要按照一定的顺序进行遍历，这可以采用之字形顺序或使用一些空间填充曲线，这两种方法都倾向于增加一致性。如果需要，还可以添加层次遍历中的其他级别。例如，玩家可以先访问16 × 16的贴图，然后测试每个与三角形重叠的贴图的4 × 4 subtiles。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116133826.png" class="" title="image-20211116133826">

<p>使用4 × 4像素贴图的平铺遍历时可能的遍历顺序。在本例中，遍历从左上角开始，一直到右边。顶部的每一个贴图都与三角形重叠，尽管右上方的贴图没有像素。遍历继续到直接下方的贴图，它完全位于外部，所以这里不需要逐像素的内部测试。然后继续向左遍历，发现下面两个贴图与三角形重叠，而左下方的贴图没有重叠。</p>
<p><strong>平铺遍历的主要优势，比如说，以扫描线顺序遍历三角形，是像素以更一致的方式处理，因此，像素访问也更一致。它还具有在访问颜色和深度缓冲区时更好地利用局部性的优点。例如，考虑一个大三角形以扫描线顺序遍历。texel被缓存，所以最近访问的texel保留在缓存中以供重用。假设mipmapping用于纹理，这增加了缓存中的texels的重用级别。如果我们按照扫描线顺序访问像素，那么当到达扫描线的末端时，在扫描线开始处使用的像素很可能已经从缓存中移除。由于在缓存中重用texel比从内存中重复获取texel更有效，三角形通常在tile中遍历。这为纹理、深度缓冲和颜色缓冲提供了很大的好处。事实上，纹理、深度和颜色缓冲也是出于同样的原因存储在tiles中。这将在第23.4节中进一步讨论。</strong></p>
<p><strong>在三角形遍历开始之前，GPU通常有一个三角形设置阶段。这个阶段的目的是计算三角形上的常数，以便遍历能够有效地进行。例如，边方程中式23.2)常数ai,bi,ci，i∈{0,1,2}，在此计算一次，然后用于当前三角形的整个遍历步骤。三角形设置还负责计算与属性插值相关的常量(章节23.1.1)。随着讨论的继续，我们还将发现在三角形设置中可以一次性计算的其他常数。</strong></p>
<p><strong>由于裁剪可能生成更多的三角形，因此剪辑必须在三角形设置之前完成。在剪辑空间中根据视图体积裁剪一个三角形是一个昂贵的过程，所以GPU避免这样做，如果不是绝对必要的话。对近平面的裁剪总是需要的，这可以产生一个或两个三角。对于屏幕边缘，大多数GPU使用保护带剪切，这是一种更简单的方案，避免了更复杂的完整剪切过程。算法如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116134049.png" class="" title="image-20211116134049">

<p>防护带试图避免完全剪断。假设防护带区域在x和y上都是±16K像素，那么中间的屏幕大约是6500 × 4900像素，这表明这些三角形是巨大的。底部的两个绿色三角形要么作为三角形设置的一部分，要么在前面的步骤中被剔除。常见的情况是中间的蓝色三角形，它与屏幕区域相交，并且完全在防护带内部。不需要完整的剪切操作，因为只处理可见的贴图。红色三角形在保护带之外，并与屏幕区域相交，所以这些需要修剪。注意右边的红色三角形被剪成两个三角形。</p>
<h3 id="Interpolation-插值"><a href="#Interpolation-插值" class="headerlink" title="Interpolation 插值"></a>Interpolation 插值</h3><p><strong>在22.8.1节中，质心坐标是计算射线与三角形相交的副产品。任意顶点属性ai，i∈{0,1,2}，可以用质心坐标(u, v)插值为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116134542.png" class="" title="image-20211116134542">

<p><strong>其中a(u, v)是三角形上(u, v)处的插值属性。质心坐标的定义为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116134607.png" class="" title="image-20211116134607">

<p><strong>Ai 是下图中左边所示的子三角形的面积。第三个坐标w = A0/ (A0 +A1 +A2)也是定义的一部分，它表明u + v + w = 1，即 w = 1−u−v，这里用1−u−v代替w。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116134742.png" class="" title="image-20211116134742">

<p>左:一个顶点上具有标量属性(a0, a1, a2)的三角形。在p点的重心坐标与带符号的区域(A1,A2,A0）成.中间:说明重心坐标(u, v)在三角形上的变化。右:法线的长度n2 是边p0p1 逆时针旋转90度。这个区域A2 然后bh / 2。</p>
<p><strong>式23.2中的边方程可以用边的法线表示，n2 = (a2, b2)，有</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116135028.png" class="" title="image-20211116135028">

<p><strong>其中p = (x, y)根据点积的定义，这个可以写成</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116135113.png" class="" title="image-20211116135113">

<p><strong>α是n2和p−p0之间的夹角．注意，b = ||n2||等于边p0p1的长度,因为n2 是边旋转90度。第二项||p−p0|| cos α的几何解释，是投影p−p0 到n2得到的向量的长度，这个长度正好等于区域A2的子三角形的高h．如上图中的右侧所示。值得注意的是，我们有e2(p) = | | n2|| ||p−p0|| cos α = bh = 2A2，这很好，因为我们需要子三角形的面积，以计算重心坐标。这意味着</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116135432.png" class="" title="image-20211116135432">

<p><strong>三角形设置通常计算1/(A0 +A1 +A2)，因为三角形的面积没有改变，这也避免了每个像素的分割。所以，当我们用边方程遍历一个三角形时，方程23.8中的所有项都是内部测试的副产品。这在插值深度时很有用，正如我们将看到的，或者对于正交投影，但是对于透视投影，重心坐标不会生成预期的结果，如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116135520.png" class="" title="image-20211116135520">

<p>左图:在透视中，几何体的投影图像随着距离而缩小。中间:边对三角形的投影。注意三角形的上半部分在投影平面上所覆盖的部分比下半部分要小。右图:带有棋盘纹理的四边形。上面的图像使用重心坐标进行纹理渲染，而下面的图像使用透视校正的重心坐标。</p>
<p><strong>透视校正的重心坐标需要每像素进行除法。这里省略推导，而是总结最重要的结果。由于线性插值并不昂贵，而且我们知道如何计算(u, v)，所以我们希望在屏幕空间中尽可能多地使用线性插值，甚至用于透视校正。有点令人惊讶的是，它证明了在三角形上线性插值a/w和1/w是可能的，其中w是变换后顶点的第四个分量。恢复内插属性a，就是使用这两个插值值，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116135628.png" class="" title="image-20211116135628">

<p><strong>这是前面提到的逐像素划分。</strong></p>
<p><strong>一个具体的例子说明了这种效果。假设我们沿着一个水平三角形的边进行插值，用a0 = 4在左边结束和a1 = 6在右边。这两个端点之间的中点值是多少?对于正投影(或者当端点的w值匹配时)，答案就是a = 5, 中间值在a0 和a1间．</strong></p>
<p><strong>而是说端点的w值是w0 = 1和w1 = 3。在这种情况下，我们需要插值两次，以得到a/w和1/w。对于a/w，左端点是4/1 = 4，右端点是6/3 = 2，所以中点值是3。对于1/w，我们有1/1和1/3，所以中点是2/3。3除以2/3得到a = 4.5透视中点值。</strong></p>
<p><strong>在实践中，我们经常需要在一个三角形上使用透视校正来插值几个属性。因此，通常需要计算透视图校正的重心坐标，我们将其表示为(∽u，∽v)，然后将其用于所有属性插值。为此，我们引入以下辅助函数:</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116135936.png" class="" title="image-20211116135936">

<p><strong>注意，由于e0(x y) = a0x + b0y + c0，三角形设置可以计算和存储a0/ w0 和其他类似的术语，以使每像素计算更快。另外,所有fi函数可以乘以w0w1w2；例如，我们储存w1w2f0(x, y), w0w2f1(x, y)和w0w1f2(x, y)。透视校正的重心坐标是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116140046.png" class="" title="image-20211116140046">

<p><strong>每个像素需要计算一次，然后可以用正确的透视缩短来插值任何属性。注意，这些坐标与子三角形的面积不像(u, v)那样成比例。此外，分母不是常数，就像重心坐标那样，这就是为什么必须按像素进行除法的原因。</strong></p>
<p><strong>最后，请注意，由于深度是z/w，我们可以在23.10式中看到，我们不应该使用这些方程，因为它们已经被w除了。因此，zi/ wi 应该每个顶点计算，然后使用(u, v)进行线性插值。这有几个优点，例如，对于深度缓冲区的压缩(第23.7节)。</strong></p>
<h3 id="Conservative-Rasterization-保守的光栅化"><a href="#Conservative-Rasterization-保守的光栅化" class="headerlink" title="Conservative Rasterization 保守的光栅化"></a>Conservative Rasterization 保守的光栅化</h3><p><strong>从DirectX 11开始，通过在OpenGL中使用扩展，可以使用一种名为保守光栅化(CR)的新型三角形遍历。CR分为高估CR (OCR)和低估CR (UCR)两种。有时它们也被称为外保守光栅化和内保守光栅化。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116140237.png" class="" title="image-20211116140237">

<p>三角形的保守栅格化。使用外保守栅格化时，所有彩色像素都属于三角形。黄色和绿色像素使用标准栅格化在三角形内部，只有绿色像素使用内部保守栅格化生成。</p>
<p><strong>宽泛地说，所有重叠的像素或三角形内的像素都用OCR访问，只有完全在三角形内的像素才用UCR访问。OCR和UCR都可以通过平铺遍历实现，将平铺大小缩小到一个像素。当硬件不支持时，可以使用几何着色器或三角形扩展来实现OCR。有关CR的更多信息，请参阅相应API的规范。CR可以用于图像空间的碰撞检测、遮挡剔除、阴影计算和抗锯齿等算法。</strong></p>
<p><strong>最后，我们注意到所有类型的栅格化都充当几何和像素处理之间的桥梁。为了计算三角形顶点的最终位置和计算像素的最终颜色，GPU需要大量灵活的计算能力。下面将对此进行解释。</strong></p>
<h2 id="Massive-Compute-and-Scheduling-大量计算和调度"><a href="#Massive-Compute-and-Scheduling-大量计算和调度" class="headerlink" title="Massive Compute and Scheduling 大量计算和调度"></a>Massive Compute and Scheduling 大量计算和调度</h2><p><strong>为了提供可用于任意计算的大量计算能力，大多数(如果不是全部的话)GPU架构使用统一的着色器架构，使用多线程的SIMD处理，有时称为 SIMT处理或超线程。有关线程、SIMD处理、扭曲和线程组的详细信息，请参阅第3.10节。请注意，我们使用术语翘曲，这是NVIDIA的术语，但在AMD的硬件上，这些被称为波或波前。在本节中，我们将首先查看GPU中使用的典型统一算术逻辑单元(ALU)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116140540.png" class="" title="image-20211116140540">

<p>左:一个算术逻辑单元的例子，每次只执行一项。分派端口接收有关要执行的当前指令的信息，操作数收集器读取指令所需的寄存器。右图:这里，8 × 4 ALU已经与其他几个硬件单元组装在一起，形成一个称为多处理器的块。32个ALUs，有时称为SIMD通道，将以锁步方式执行相同的程序，即它们构成SIMD引擎。还有一个寄存器文件、一个L1缓存、本地数据存储、纹理单元和用于在ALU中未处理的各种指令的特殊单元。</p>
<p><strong>ALU是为一个实体(如顶点或片段)执行程序而优化的一块硬件。有时我们用SIMD lane来代替ALU。图形处理器的典型ALU显示在上图的左侧。主要的计算单元是浮点(FP)单元和整数单元。FP单元通常遵循IEEE 754 FP标准，并支持FMA指令作为其最复杂的指令之一。ALU通常还包含移动/比较、加载/存储功能和分支单元，以及超越操作，如余弦、正弦和指数。然而，应该注意的是，其中一些可能位于某些架构上的独立硬件单元中，例如，一组小型的，比如说，超越的硬件单元可以操作到服务更多的ALU。对于不像其他操作那样经常执行的操作来说，情况可能就是这样。如上图中右侧所示，这些组合在特殊单元(SU)块中。ALU架构通常使用几个硬件管道阶段来构建，即有几个构建在硅中并并行执行的实际块。例如，当当前指令执行乘法运算时，下一条指令可以获取寄存器。如果有n个管线阶段，理想情况下，吞吐量可以增加n倍。这通常被称为流水线并行性。使用流水线的另一个重要原因是，流水线处理器中最慢的硬件块指示了执行该块的最大时钟频率。增加管道阶段的数量可以使每个管线阶段的硬件块数量更小，这通常可以增加时钟频率。然而，为了简化设计，ALU通常有几个管线阶段，例如4-10。</strong></p>
<p><strong>统一的ALU不同于CPU核心，因为它没有许多附加功能，比如分支预测、寄存器重命名和深度指令流水线。相反，芯片的大部分区域都花在复制ALU上，以提供巨大的计算能力，并增加寄存器文件的大小，以便可以输入和输出扭曲。例如，NVIDIA GTX 1080 Ti有3584个ALU。为了高效地调度分配给GPU的工作，大多数GPU将ALU分组为32个。它们以锁步方式执行，这意味着整个32个ALU集是一个SIMD引擎。不同的供应商使用不同的名称来表示这样的组以及附加的硬件单元，我们使用通用术语多处理器(MP)。例如，NVIDIA使用术语流多处理器，Intel使用执行单元，AMD使用计算单元。上图的右侧显示了MP的一个示例。MP通常有一个调度程序，将工作分派给SIMD引擎，还有一个L1缓存、本地数据存储(LDS)、纹理单元(TX)和一个用于处理未在ALU中执行的指令的特殊单元。MP将指令分派到ALU上，在ALU上指令以锁步方式执行，即SIMD-处理(章节3.10)。请注意MP的确切内容因厂商和架构的不同而不同。</strong></p>
<p><strong>SIMD处理对于图形工作负载是有意义的，因为有许多相同的，例如，顶点和片段，执行相同的程序。在这里，架构利用了线程级的并行性，例如，顶点和碎片可以独立于其他顶点和碎片执行它们的着色器。此外，对于任何类型的SIMD/ simt处理，都可以利用数据级的并行性，因为指令是针对SIMD机器中的所有通道执行的。还有指令级的并行性，这意味着如果处理器可以找到彼此独立的指令，它们就可以同时执行，前提是有资源可以并行执行。</strong></p>
<p><strong>接近MP的是一个(warp)调度器，它接收要在MP上执行的大块工作。经纱调度程序的任务是将经纱中的工作分配给MP，将寄存器文件(RF)中的寄存器分配给经纱中的线程，然后以最好的方式对工作进行优先排序。通常，下游的工作优先级高于上游工作。例如，像素着色位于可编程阶段的末尾，比在流水线中较早的顶点着色具有更高的优先级。这避免了拖延，因为接近尾声的阶段不太可能阻塞早期阶段。请参阅第34页的图3.2，以重新了解图形管线图。MP可以处理数百甚至数千个线程，以隐藏延迟，例如内存访问。调度程序可以在MP上切换当前正在执行(或等待)的曲速，等待一个可以执行的曲速。由于调度器是在专用硬件中实现的，因此通常无需任何开销。例如，如果当前的warp执行了一个纹理加载指令，预计会有很长的延迟，调度程序可以立即切换出当前的warp，用另一个来替换它，并继续执行那个warp。通过这种方式，可以更好地利用计算单元。</strong></p>
<p><strong>注意，对于像素着色工作，warp调度器会分派几个完整的四边形，因为像素是在四边形粒度上着色的，以便计算导数。这已在第23.1节中提到，并将在第23.8节中进一步讨论。所以，如果扭曲的尺寸是32，那么32/4 = 8个四轴可以被安排执行。这里有一个建筑设计选择，你可以选择将整个经线锁定在一个三角形上，或者有可能让经线上的每个四元属于一个不同的三角形。前者更容易实现，但对于较小的三角形，效率会受到影响。后者更复杂，但对于较小的三角形更有效。</strong></p>
<p><strong>通常，MPs也被复制，以获得更高的芯片上的计算密度，因此，GPU通常也有一个更高级别的调度器。它的任务是根据提交给GPU的工作将工作分配给不同的warp调度程序。在一个线程中有许多线程通常也意味着一个线程的工作需要独立于其他线程的工作。当然，在图形处理中经常会出现这种情况。例如，顶点的着色通常不依赖于其他顶点，片段的颜色通常不依赖于其他片段。</strong></p>
<p><strong>请注意，架构之间有许多不同之处。其中一些将在第23.10节重点介绍，其中将介绍一些不同的案例研究。至此，我们知道了光栅化是如何完成的，以及如何使用许多重复的统一ALU来计算着色。剩下的一大块是内存系统、所有相关的缓冲区和纹理。这些是从23.4节开始的以下部分的主题，但首先我们介绍一些延迟和占用的更多信息。</strong></p>
<h2 id="Latency-and-Occupancy-延迟和占用率"><a href="#Latency-and-Occupancy-延迟和占用率" class="headerlink" title="Latency and Occupancy 延迟和占用率"></a>Latency and Occupancy 延迟和占用率</h2><p><strong>一般来说，延迟是进行查询和接收查询结果之间的时间。例如，您可以在内存中的某个地址请求值，而从查询到获得结果所花费的时间就是延迟。另一个例子是从纹理单元请求经过过滤的颜色，从请求时间到该值可用可能需要数百甚至数千个时钟周期。这为了GPU中计算资源的有效使用，需要隐藏延迟。如果不隐藏这些延迟，那么内存访问可以很容易地支配执行时间。</strong></p>
<p><strong>其中一个隐藏机制是SIMD处理的多线程部分，如第33页的图3.1所示。一般来说，MP可以处理的扭曲有一个最大数量。主动翘曲的数量取决于寄存器的使用，也可能取决于纹理采样器、L1缓存、插值和其他因素的使用。这里，我们定义占用率o为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116142158.png" class="" title="image-20211116142158">

<p><strong>其中wmax MP和w上允许的最大曲线数是多少active是当前活动的翘曲数量。也就是说，o是计算资源使用情况的度量。例如，假设wmax = 32，一个着色器处理器有256kB寄存器，一个着色器程序一个线程使用27个32位浮点寄存器，另一个使用150。此外，我们假定寄存器的使用决定了活动翘曲的数量。假设SIMD宽度为32，则这两种情况的翘曲活动次数分别为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116142320.png" class="" title="image-20211116142320">

<p><strong>在第一种情况下，即对于使用27个寄存器的短程序，wactive &gt; 32，所以占用率是o = 1，这是理想的，因此预示着隐藏延迟的好兆头。然而，在第二种情况下，wactive ≈13.65，则o≈13.65/32≈0.43。因为有更少的主动扭曲，占用更低，这可能会阻碍延迟隐藏。因此，重要的是设计一个具有最大扭曲、最大寄存器和其他共享资源数量平衡的体系结构。</strong></p>
<p><strong>有时过高的占用率可能会适得其反，因为如果你的着色器使用了很多内存访问，它可能会使缓存崩溃。另一种隐藏机制是在内存请求之后继续执行相同的warp，如果有一些指令独立于内存访问的结果，这是可能的。虽然这样会使用更多的寄存器，但有时低占用率会更有效。一个例子是循环展开，它为指令级的并行性提供了更多的可能性，因为通常会生成更长的独立指令链，这使得在转换指令之前执行更长的时间成为可能。然而，这也会使用更多的临时寄存器。一般的规则是争取更高的入住率。低占用率意味着当一个着色器请求纹理访问时，切换到另一个扭曲的可能性更小。</strong></p>
<p><strong>另一种延迟是将数据从GPU读回CPU。一个好的思维模式是把GPU和CPU看作是独立的异步运行的计算机，两者之间的通信需要付出一些努力。改变信息流方向带来的延迟会严重影响性能。当从GPU读取数据时，可能必须在读取之前刷新管线。在此期间，CPU等待GPU完成它的工作。为架构，如英特尔的GEN架构，其中GPU和CPU在同一芯片上，并使用共享内存模型，这种类型的延迟大大降低。较低级别的缓存在CPU和GPU之间共享，而较高级别的缓存不共享。共享缓存减少的延迟允许不同类型的优化和其他类型的算法。例如，这个特性被用来加速光线追踪，光线在图形处理器和CPU核心之间来回传输，而不需要任何成本。</strong></p>
<p><strong>不产生CPU延迟的回读机制的一个例子是遮挡查询。看到19.7.1节。对于遮挡测试，其机制是执行查询，然后偶尔检查GPU，看看查询的结果是否可用。在等待结果的同时，其他工作可以同时在CPU和GPU上完成。</strong></p>
<h2 id="Memory-Architecture-and-Buses-内存架构和总线"><a href="#Memory-Architecture-and-Buses-内存架构和总线" class="headerlink" title="Memory Architecture and Buses 内存架构和总线"></a>Memory Architecture and Buses 内存架构和总线</h2><p><strong>在这里，我们将介绍一些术语，讨论几种不同类型的内存体系结构，然后介绍压缩和缓存。</strong></p>
<p><strong>端口是在两个设备之间发送数据的通道，而总线是在两个以上设备之间发送数据的共享通道。带宽是用来描述端口或总线上的数据吞吐量的术语，以字节/秒(B/s)为单位。端口和总线在计算机图形架构中很重要，简单地说，因为它们将不同的构建块粘在一起。同样重要的是，带宽是一种稀缺资源，因此在构建图形系统之前必须进行仔细的设计和分析。由于端口和总线都提供数据传输能力，端口通常被称为总线，这是我们在这里要遵循的约定。</strong></p>
<p><strong>对于许多GPU来说，在图形加速器上有专用的GPU内存是很常见的，这种内存通常被称为显存。访问这种内存通常比让GPU通过总线访问系统内存要快得多，例如，PC上使用的PCI Express (PCIe)。16通道PCIe v3双向带宽为15.75 GB/s, PCIe v4双向带宽为31.51 GB/s。然而，Pascal架构的显存(GTX 1080)提供320gb /s。</strong></p>
<p><strong>传统上，纹理和渲染目标存储在视频内存中，但它也可以存储其他数据。场景中的许多物体在帧与帧之间并没有明显的形状变化。即使是一个人类角色，通常也会使用一组不变的网格进行渲染，这些网格在关节处使用GPU端顶点混合。对于这种类型的数据，纯粹通过建模矩阵和顶点着色程序进行动画，通常使用静态顶点和索引缓冲区，它们被放置在视频内存中。这样做可以让GPU快速访问。对于每一帧由CPU更新的顶点，将使用动态顶点和索引缓冲区，这些缓冲区被放置在可以通过总线(如PCI Express)访问的系统内存中。PCIe的一个很好的特性是查询可以流水线化，这样就可以在返回结果之前请求多个查询。</strong></p>
<p><strong>大多数游戏控制台，例如所有的xbox和PLAYSTATION 4，使用统一的内存架构(UMA)，这意味着图形加速器可以使用主机内存的任何部分的纹理和不同类型的缓冲区。CPU和图形加速器使用相同的内存，因此也使用相同的总线。这显然不同于使用专用显存。Intel还使用了UMA，这样CPU内核和GEN9图形架构之间就可以共享内存，如下图所示。然而，并不是所有的缓存都是共享的。图形处理器有自己的一组L1缓存、L2缓存和L3缓存。最后一级缓存是内存层次结构中的第一个共享资源。对于任何计算机或图形架构来说，拥有一个缓存层次结构是很重要的。如果在访问中存在某种局部性，那么这样做可以减少对内存的平均访问时间。在下一节中，我们将讨论GPU的缓存和压缩。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116143053.png" class="" title="image-20211116143053">

<p>英特尔系统芯片(SoC) Gen9图形架构与CPU核和共享内存模型的内存架构的简化视图。请注意，最后一级缓存(llc)是在图形处理器和CPU内核之间共享的。</p>
<h2 id="Caching-and-Compression-缓存与压缩"><a href="#Caching-and-Compression-缓存与压缩" class="headerlink" title="Caching and Compression 缓存与压缩"></a>Caching and Compression 缓存与压缩</h2><p><strong>缓存位于每个GPU的几个不同部分，但它们的架构不同，我们将在23.10节中看到。通常，向体系结构中添加缓存层次结构的目标是通过利用内存访问模式的局域性来减少内存延迟和带宽使用。也就是说，如果GPU访问一个项目，它很可能会很快访问这个相同的或附近的项目。大多数缓冲区和纹理格式以平铺格式存储，这也有助于增加局部性。假设一条高速缓存线由512位组成，即64字节，而当前使用的颜色格式每像素使用4B。一个设计选择便是将所有像素存储在64B的4 × 4区域(也称为贴图)中。也就是说，整个颜色缓冲将被分割成4 × 4的贴图。一个平铺也可以跨越几条高速缓存线。</strong></p>
<p><strong>为了获得一个高效的GPU架构，我们需要在所有方面都工作以减少带宽的使用。大多数GPU都包含硬件单元，用于动态压缩和解压缩渲染目标，例如，图像正在被渲染。重要的是要认识到这些类型的压缩算法是无损的;也就是说，总是可以精确地再现原始数据。这些算法的核心是我们所说的贴图表，它为每个贴图存储额外的信息。这可以存储在芯片上或通过内存层次结构通过缓存访问。这两种系统的框图如下图所示。一般来说，相同的设置可以用于深度、颜色和模板压缩，有时需要进行一些修改。平铺表中的每个元素存储帧缓冲区中像素平铺的状态。每个贴图的状态可以被压缩、未压缩或清除(后面将讨论)。一般来说，也可以有不同类型的压缩块。例如，一种压缩模式可能压缩到25%，另一种压缩到50%。重要的是要认识到压缩的级别取决于GPU可以处理的内存传输的大小。在特定的架构中，最小的内存传输是32B。如果贴图大小被选择为64B，那么它只能压缩到50%。然而，使用128B的贴图大小，可以压缩到75% (96 B)， 50% (64 B)和25% (32 B)。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116143444.png" class="" title="image-20211116143444">

<p>GPU中压缩和缓存渲染目标的硬件技术的框图。左:后缓存压缩，压缩/解压硬件单元位于缓存之后(以下)。右:预缓存压缩，压缩/解压硬件单元位于缓存之前(上面)。</p>
<p><strong>平铺表也经常用于实现渲染目标的快速清除。当系统发出对呈现目标的清除时，表中每个tile的状态都被设置为cleared，并且帧缓冲区本身不受影响。当访问渲染目标的硬件单元需要读取被清除的渲染目标时，解压单元首先检查表中的状态，看看tile是否被清除。如果是这样，渲染目标贴图将被放置在缓存中，所有值都设置为clear值，而不需要读取和解压缩实际的渲染目标数据。就这样，获得了渲染目标本身在清除过程中被最小化，这节省了带宽。如果状态未被清除，则必须读取该贴图的渲染目标。瓦片存储的数据被读取，如果被压缩，则在发送之前通过解压缩器传递。</strong></p>
<p><strong>当访问渲染目标的硬件单元完成了写新值，并且贴图最终从缓存中被驱逐，它被发送到压缩器，在那里尝试压缩它。如果有两种压缩模式，两种都可以尝试，并且使用能压缩最少位元的瓦片的模式。由于API需要无损的呈现目标压缩，所以如果所有压缩技术都失败了，就需要使用未压缩的数据。这也意味着无损渲染目标压缩永远不能在实际渲染目标中减少内存使用——这种技术只能减少内存带宽的使用。如果压缩成功，则将瓦片的状态设置为已压缩，并以压缩形式发送信息。否则，它将以未压缩的方式发送，并且状态设置为未压缩。</strong></p>
<p><strong>请注意，压缩机和解压单元可以在缓存之后(称为后缓存)或在缓存之前(预缓存)，如上图所示。预缓存压缩可以大幅增加有效缓存的大小，但通常也会增加系统的复杂度。对于压缩深度和颜色有具体的算法。后者包括对有损压缩的研究，然而，在我们所知的任何硬件中都没有这种研究。大多数算法编码一个锚值，它表示平铺中的所有像素，然后根据锚值以不同的方式编码差异。对于深度，通常存储一组平面方程或使用差分技术，这两种方法都能得到很好的结果，因为深度在屏幕空间中是线性的。</strong></p>
<h2 id="Color-Buffering-颜色缓存"><a href="#Color-Buffering-颜色缓存" class="headerlink" title="Color Buffering 颜色缓存"></a>Color Buffering 颜色缓存</h2><p><strong>使用GPU进行渲染需要访问几种不同的缓冲区，例如颜色、深度和模板缓冲区。请注意，尽管它被称为“颜色”缓冲区，但任何类型的数据都可以在其中呈现和存储。</strong></p>
<p><strong>根据表示颜色的字节数，颜色缓冲区通常有几种颜色模式。这些模式包括:</strong></p>
<pre><code>**•高颜色- 2字节/像素，其中15或16位用于颜色，分别提供32,768或65,536种颜色。**

**•真颜色或RGB颜色，每像素3或4字节，其中24位用于颜色，提供16777,216≈1680万种不同的颜色。**

**•深颜色——每像素30、36或48位，能提供至少10亿种不同的颜色。**
</code></pre>
<p><strong>高颜色模式有16位的颜色分辨率。通常情况下，这个数量会被分成至少5个比特(红色、绿色和蓝色)，每个颜色通道提供32个关卡。</strong></p>
<p><strong>这就剩下一个比特，通常给绿色通道，导致5-6-5分割。选择绿色通道是因为它对眼睛的亮度影响最大，因此需要更高的精度。高色彩比真实和深颜色有速度优势。这是因为每个像素2个字节的内存访问速度通常比每个像素3个或更多字节的内存访问速度更快。也就是说，高颜色模式的使用在这一点上是相当罕见的。每个通道中只有32或64个颜色级别，就可以很容易地分辨相邻颜色级别的差异。这个问题有时被称为条带化或分割化。人类视觉系统由于一种被称为马赫带的感知现象而进一步放大了这些差异。参见下图。在抖动中，相邻的水平被混合在一起，通过交换空间分辨率来增加有效的颜色分辨率，可以减少效果。即使在24位显示器上，渐变的条带也很明显。向帧缓冲区图像添加噪声可以用来掩盖这个问题。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116161023.png" class="" title="image-20211116161023">

<p>当矩形从白色渐变到黑色时，条纹就出现了。尽管32个灰度条都有一个固定的强度级别，但由于马赫波段错觉，每个灰度条在左边看起来较暗，在右边看起来较浅。</p>
<p><strong>真彩色使用24位RGB颜色，每个颜色通道1字节。在PC系统上，顺序有时被反转为BGR。在内部，这些颜色通常使用每像素32位存储，因为大多数内存系统都优化了访问4字节元素。在一些系统中，额外的8位也可以用来存储alpha通道，给像素一个RGBA值。24位颜色(无alpha)表示也称为打包像素格式，与32位未打包像素格式相比，它可以节省帧缓冲区内存。对于实时渲染来说，使用24位颜色几乎总是可以接受的。它仍然有可能看到颜色的带状，但比只有16位的可能性要小得多。</strong></p>
<p><strong>对于RGB颜色，深颜色使用30,36或48位。例如，10位、12位或16位每个通道。如果加上alpha，这些数字增加到40/48/64。HDMI 1.3支持所有30/36/48模式，DisplayPort标准也支持每通道最多16位。</strong></p>
<p><strong>如23.5节所述，颜色缓冲区经常被压缩和缓存。此外，在23.10节的每个案例研究中，将传入的片段数据与颜色缓冲进行进一步描述。混合由光栅操作(ROP)单元处理，每个ROP通常连接到内存分区，例如使用广义棋盘模式。接下来我们将讨论视频显示控制器，它采用一个彩色缓冲并使其出现在显示器上。然后检查单缓冲、双缓冲和三缓冲。</strong></p>
<h3 id="Video-Display-Controller-视频显示控制器"><a href="#Video-Display-Controller-视频显示控制器" class="headerlink" title="Video Display Controller 视频显示控制器"></a>Video Display Controller 视频显示控制器</h3><p><strong>在每个GPU中，都有一个视频显示控制器(VDC)，也称为显示引擎或显示界面，它负责在显示器上显示一个颜色缓冲。它是GPU中的一个硬件单元，可以支持多种接口，如高清多媒体接口(HDMI)、显示端口(DisplayPort)、数字可视接口(DVI)、视频图形阵列(VGA)等。要显示的颜色缓冲可能位于与CPU用于其任务相同的内存中，在专用的帧缓冲内存中，或在显存中，后者可以包含任何GPU数据，但CPU不能直接访问。每个接口都使用其标准协议来传输颜色缓冲、计时信息，有时甚至是音频。VDC还可以执行图像缩放、降噪、组成多个图像源和其他功能。</strong></p>
<p><strong>显示器，例如LCD，更新图像的速率通常在每秒60到144次(赫兹)之间。这也称为垂直刷新率。大多数观众注意到频率低于72赫兹的闪烁。有关这个主题的更多信息，请参阅12.5节。</strong></p>
<p><strong>监视器技术已经在几个方面取得了进步，包括刷新率、每个组件的位、色域和同步。刷新率过去是60hz，但120hz正变得越来越常见，高达600hz是可能的。为了获得较高的刷新率，图像通常会被显示多次，有时还会插入黑色帧，以最小化由于在帧显示期间眼睛移动而产生的模糊伪影。显示器也可以有超过8位每通道，和HDR显示器可能是下一个重要的显示技术。每个通道可以使用10位或更多。杜比拥有HDR显示技术，使用低分辨率的LED背光阵列来增强其LCD显示器。这样做可以使它们的显示器亮度是普通显示器的10倍，对比度是普通显示器的100倍。更宽色域的显示器也变得越来越普遍。它们可以显示更广泛的颜色范围，通过使纯光谱色调变得可代表，例如，更生动的绿色。有关色域的更多信息，请参阅第8.1.3节。</strong></p>
<p><strong>为了减少撕裂效应，公司开发了自适应同步技术，如AMD的FreeSync和NVIDIA的G-sync。这里的想法是调整显示的更新速率以适应GPU可以产生的结果，而不是使用固定的预定速率。例如，如果一帧渲染需要10毫秒，而下一帧渲染需要30毫秒，那么显示的图像更新将在每个图像完成渲染后立即开始。使用这种技术，渲染看起来更加流畅。此外，如果图像没有更新，那么颜色缓冲就不需要发送到显示器，这样可以节省电力。</strong></p>
<h3 id="Single-Double-and-Triple-Buffering-单、双、三次缓冲"><a href="#Single-Double-and-Triple-Buffering-单、双、三次缓冲" class="headerlink" title="Single, Double, and Triple Buffering 单、双、三次缓冲"></a>Single, Double, and Triple Buffering 单、双、三次缓冲</h3><p><strong>在2.4节中，我们提到了双重缓冲确保图像在渲染完成之前不会显示在显示器上。在这里，我们将描述单缓冲区、双缓冲区甚至三缓冲区。</strong></p>
<p><strong>假设我们只有一个缓冲区。这个缓冲区必须是当前显示在显示器上的那个。当绘制一个帧的三角形时，随着显示器刷新，越来越多的三角形会出现——这是一种不令人信服的效果。即使我们的帧速率等于监视器的更新速率，单缓冲区也有问题。如果我们决定清除缓冲区或绘制一个大三角形，那么当视频显示控制器传输正在绘制的颜色缓冲区区域时，我们将能够简要地看到颜色缓冲区的实际部分变化。有时称为撕裂，因为显示的图像看起来就像被简单地撕成两半，这不是实时图形的理想特性。在一些古老的系统上，比如Amiga，你可以测试光束的位置，从而避免在那里绘制，从而允许单缓冲区工作。现在，单缓冲区很少被使用，除了虚拟现实系统，在虚拟现实系统中，“竞速波束”可能是一种减少延迟的方法。</strong></p>
<p><strong>为避免撕裂问题，常用双缓冲。完成后的图像显示在前缓冲区中，而屏幕外的后缓冲区包含当前正在绘制的图像。后缓冲和前缓冲然后由图形驱动程序交换，通常是在整个图像被转移到显示器之后，以避免撕裂。交换通常是通过交换两个颜色缓冲指针来完成的。对于CRT显示器，这个事件被称为垂直回描，在此期间的视频信号被称为垂直同步脉冲，或简称vsync。对于液晶显示器来说，光束没有物理回描，但我们使用相同的术语来表示整个图像刚刚被转移到显示器上。在渲染完成后立即交换前面和后面的缓冲区对于绘制系统的基准测试是有用的，并且在许多应用中也被使用，因为它最大化了帧率。在垂直同步上不进行更新也会导致撕裂，但是因为有两个完全形成的图像，所以工件并不像单个缓冲那样糟糕。在交换之后，(新的)back缓冲区是图形命令的接收方，而新的front缓冲区则显示给用户。这个过程如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116161602.png" class="" title="image-20211116161602">

<p>对于单个缓冲(顶部)，前端缓冲总是显示。对于双缓冲(中间)，第一个缓冲区0在前面，缓冲区1在后面。然后他们从前面到后面，反之亦然。三重缓冲(底部)也有一个挂起的缓冲区。在这里，首先清除一个缓冲区并开始呈现它(pending)。其次，系统继续使用缓冲区进行渲染，直到图像完成(返回)。最后，显示缓冲区(前面)。</p>
<p><strong>可以用第二个后置缓冲区(我们称之为挂起缓冲区)来扩充双缓冲。这被称为三重缓冲。挂起缓冲区类似于后置缓冲区，因为它也在屏幕外，并且可以在显示前置缓冲区时对其进行修改。挂起缓冲区成为三个缓冲区循环的一部分。在一帧期间，等待的缓冲区可以被访问。在下一次交换时，它成为后置缓冲区，呈现在这里完成。然后它就变成了前台缓冲区并显示给查看器。在下一次交换时，缓冲区再次变成挂起缓冲区。在上图的底部可以看到这一过程。</strong></p>
<p><strong>三倍缓冲比双缓冲有一个主要优点。使用它，系统可以在等待垂直回描时访问挂起的缓冲区。使用双缓冲，在等待垂直回描以便进行交换时，构造必须简单地保持等待。这是因为前缓冲区必须显示给查看器，而后缓冲区必须保持不变，因为其中有一个完成的图像，等待显示。三重缓冲的缺点是延迟增加到一个完整的帧。这种增加延迟了对用户输入的反应，如按键、鼠标或操纵杆移动。控件可能感觉迟钝，因为这些用户事件在挂起缓冲区中的呈现开始后被延迟。</strong></p>
<p><strong>理论上，可以使用三个以上的缓冲区。如果计算一帧的时间变化很大，那么更多的缓冲区会带来更多的平衡和更高的总体显示率，但代价是更多的潜在延迟。概括地说，多重缓冲可以被认为是一个循环结构。有一个呈现指针和一个显示指针，每个指针都指向不同的缓冲区。呈现指针引导显示指针，当当前呈现缓冲区的计算完成时，将移动到下一个缓冲区。唯一的规则是显示指针不应该与呈现指针相同。</strong></p>
<p><strong>实现PC图形加速器附加加速的相关方法是使用SLI模式。早在1998年，3dfx就使用SLI作为扫描线交错的缩写，即两个图形芯片组并行运行，一个处理奇数扫描线，另一个处理偶数扫描线。NVIDIA(收购了3dfx的资产)使用这个缩写来实现一种完全不同的连接两个(或更多)显卡的方式，称为可扩展连接接口。AMD将其称为“CrossFire x”。这种并行方式可以将屏幕分割成两个(或更多)水平部分(每张卡片一个)，或者让每张卡片完全呈现自己的帧，交替输出。还有一个模式，允许卡片加速反锯齿相同的帧。最常见的用法是让每个GPU渲染一个单独的帧，称为交替帧渲染(AFR)。虽然这个方案听起来似乎应该增加延迟，但它往往收效甚微或根本没有效果。假设一个GPU系统的渲染速度是10fps。如果GPU是瓶颈，两个使用AFR的GPU可以以20 FPS渲染，甚至4个以40 FPS渲染。每个GPU渲染帧需要相同的时间，所以延迟不一定会改变。</strong></p>
<p><strong>屏幕分辨率继续增加，给基于逐像素采样的渲染器带来了严峻的挑战。保持帧率的一种方法是自适应地改变屏幕和表面上的像素着色率。</strong></p>
<h2 id="Depth-Culling-Testing-and-Buffering-深度剔除、测试和缓存"><a href="#Depth-Culling-Testing-and-Buffering-深度剔除、测试和缓存" class="headerlink" title="Depth Culling, Testing, and Buffering 深度剔除、测试和缓存"></a>Depth Culling, Testing, and Buffering 深度剔除、测试和缓存</h2><p><strong>在本节中，我们将讨论与深度相关的所有内容，包括分辨率、测试、剔除、压缩、缓存、缓冲和early-z。</strong></p>
<p><strong>深度分辨率很重要，因为它有助于避免渲染错误。例如，假设你制作了一张纸的模型，并把它放在书桌上，稍稍高于书桌表面。通过计算桌子和纸的z-深度的精度极限，桌子可以在纸的各个点戳穿。这个问题有时被称为z-fighting。请注意，如果把纸放在与桌子完全相同的高度，即。如果纸和桌子是共面的，那么如果没有关于它们关系的额外信息，就不会有正确的答案。这个问题是由于建模不好，不能用更好的z精度来解决。</strong></p>
<p><strong>正如我们在2.5.2节中看到的，z缓冲区(也称为深度缓冲区)可以用来解析可见性。这种缓冲区通常每个像素(或样本)有24位或32位，可以使用浮点或定点表示。对于正交观察，距离值与z值成正比，因此得到均匀分布。然而，就透视来看，分布是不均匀的，正如我们在99-102页看到的。在应用了透视变换(式4.74或4.76)之后，需要对w分量进行除法(式4.72)。深度分量就变成了pz =qz/ qw，其中q是乘以投影矩阵后的点。对于定点表示，值pz =qz/ qw 从它的有效范围(例如，DirectX的[0,1])映射到整数范围[0,2^b−1]，并存储在z-buffer中，其中b是比特数。有关深度精度的更多信息，请参阅第99-102页。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116162102.png" class="" title="image-20211116162102">

<p>一个可能实现的深度管线，其中z-interpolate简单地计算深度值使用插值。</p>
<p><strong>硬件深度管线如上图所示。该管道的主要目标是根据深度缓冲区测试光栅化原语时生成的每个传入深度，并可能将传入深度写入深度缓冲区碎片通过深度测试。与此同时，这条管道线需要高效。图的左边部分从粗光栅化开始，即在平铺层面上的光栅化(第23.1节)。此时，只有与原语重叠的贴图才会进入下一个阶段，即HiZ单元，在这里执行z-culling技术。</strong></p>
<p><strong>HiZ单元从一个称为粗深度测试的块开始，这里通常执行两种类型的测试。我们从描述z开始max-culling是对Greene的分级z-buffering算法的简化，见第19.7.2节。这个想法是存储最大值，称为zmax，每个贴图的所有深度。贴图大小与建筑有关，但通常使用8 × 8像素。这些zmax-值可以存储在固定的片上内存或通过高速缓存访问。在上图中，我们将其称为HiZ缓存。简单地说，我们想测试三角形是否完全闭塞在贴图中。为了做到这一点，我们需要计算最小的z值，zmin^tri，在瓷砖内部的三角形上。如果 zmin^tri  &gt;zmax，它可以保证三角形被之前渲染的几何体遮挡。可以终止对贴图中的三角形的处理，这节省了逐像素深度测试。注意，它不保存任何像素着色器执行，因为每个样本深度测试将消除碎片，隐藏在管线稍后。在实践中，我们无法计算出zmin^tri的准确值，因此，取而代之的是一个保守的估计。有几种不同的计算 zmin^tri 的方法是可能的，每一种都有其优缺点:</strong></p>
<pre><code>**1.可以使用三角形三个顶点的最小z值。这并不总是准确的，但是有很少的开销。**

 **2.使用三角形的平面方程计算瓦片四个角的z值，并使用最小值。**
</code></pre>
<p><strong>将这两种策略相结合，可获得最佳的剔除性能。这是通过取两个zmin 值中较大的那个来完成。</strong></p>
<p><strong>另一种粗深度试验是zmin-culling，其思想是存储zmin 所有像素在一个平铺。它有两种用途。首先，它可以用来避免z-buffer读取。如果正在渲染的三角形绝对位于之前渲染过的所有几何图形的前面，则没有必要进行逐像素深度测试。在某些情况下，可以完全避免z-buffer读取，从而进一步提高性能。其次，它可以用于支持不同类型的深度测试。对zmax-culling方法，我们假设标准的“小于”深度测试。然而，如果剔除可以与其他深度测试一起使用，并且如果zmin 和zmax 都可用，所有深度测试都可以使用此筛选过程支持。Andersson博士论文中有关于深度管道的更详细的硬件描述。</strong></p>
<p><strong>上图中的绿色框涉及更新tile的zmax 和zmin 值的不同方法。如果一个三角形覆盖了整个贴图，则可以直接在HiZ单元中进行更新。否则，需要读取整个贴图的每个样本深度，并将其降低到最小和最大值，然后发送回HiZ单元，这将带来一些延迟。Andersson等人提出了一种执行方法这没有来自深度缓存的更昂贵的反馈，仍然能够保持大部分的淘汰效率。</strong></p>
<p><strong>对于通过粗深度测试的瓦片，将确定像素或样本覆盖率(使用第23.1节中描述的边缘方程)，并计算每个样本深度(上图中称为z-interpolate)。这些值被转发到深度单元，如图所示。根据API的描述，像素着色器的评估应该遵循。然而，在某些情况下，可以在不改变预期行为的情况下执行一个名为early-z或early depth的额外测试。Early-z实际上只是在像素着色器之前执行的每个样本深度测试，并且被遮挡的碎片被丢弃。这个过程因此避免了不必要的像素着色器的执行。早期z测试经常与z筛选混淆，但它是由完全独立的硬件执行的。任何一种技术都可以单独使用。</strong></p>
<p><strong>所有的zmax-culling,zmin-culling和early-z在很多情况下会被GPU自动使用。然而，如果像素着色器写入自定义深度，使用丢弃操作，或写入一个值到无序访问视图，这些必须被禁用。如果early-z不能使用，那么深度测试将在像素着色器之后进行(称为后期深度测试)。</strong></p>
<p><strong>在较新的硬件上，可以执行原子的读-修改-写操作，从着色器加载和存储图像。在这些情况下，如果您知道这样做是安全的，您可以显式地启用early-z并覆盖这些约束。当像素着色器输出自定义深度时，可以使用的另一个特征是保守深度。在这种情况下，如果程序员保证自定义深度大于三角形深度，就可以启用early-z。对于这个例子，zmax-也可以启用淘汰，但不是early-z和zmin-culling。</strong></p>
<p><strong>一如既往，遮挡剔除得益于从正面到背面的渲染。另一种名称和意图相似的技术是z-prepass。其理念是，程序员首先渲染场景，同时只写入深度，禁用像素着色，并写入颜色缓冲区。当渲染随后的通道时，会使用“相等”测试，这意味着只有最前面的表面会被着色，因为z缓冲区已经被初始化了。看到18.4.5节。</strong></p>
<p><strong>为了结束本节，我们将简要描述depth管道的缓存和压缩，如上图右下角所示。一般的压缩系统类似于第23.5节中描述的系统。每个贴图可以压缩到一些选择的大小，并且总是有一个回退到未压缩的数据，当压缩未能达到任何选择的大小时使用。在清除深度缓冲区时，使用“快速清除”可以节省带宽占用。由于深度在屏幕空间中是线性的，典型的压缩算法要么存储高精度的平面方程，要么使用delta编码的差分技术，要么使用锚定方法。平铺表和HiZ缓存可以完全存储在片上缓冲区中，或者它们可以通过内存层次结构的其余部分进行通信，就像深度缓存一样。在芯片上存储是昂贵的，因为这些缓冲区需要足够大来处理支持的最大分辨率。</strong></p>
<h2 id="Texturing-纹理"><a href="#Texturing-纹理" class="headerlink" title="Texturing 纹理"></a>Texturing 纹理</h2><p><strong>虽然纹理操作，包括抓取、过滤和解压缩，当然可以在GPU多处理器上运行的纯软件中实现，但已有研究表明，用于纹理的固定功能硬件的速度可以提高40倍。纹理单元执行纹理格式的寻址、过滤、箝位和解压缩(第6章)。它与纹理缓存一起使用以减少带宽的使用。我们首先讨论过滤以及它对纹理单元的影响。</strong></p>
<p><strong>为了能够使用缩小过滤器，如mipmapping和各向异性过滤，纹理坐标在屏幕空间的导数是必需的。也就是说，为了计算纹理级别λ，我们需要∂u/∂x，∂v/∂x，∂u/∂y，和∂v/∂y。它们告诉我们碎片所代表的纹理区域或功能的范围。如果从顶点着色器传递的纹理坐标被用来直接访问纹理，那么可以分析地计算导数。如果使用某些函数对纹理坐标进行转换，例如(u′, v′)= (cosv, sinu)，那么用解析法求导数就变得更复杂了。然而，使用链式法则或符号微分法仍然是可能的。尽管如此，这些方法都没有被图形硬件使用，因为情况可能是任意复杂的。想象计算一个表面上的反射，使用一个环境地图，法线被凹凸贴图。这是很难分析计算，例如，反射向量的导数反弹一个法线地图，然后用于访问环境地图。因此，导数通常是用x和y在四倍基i上的有限差分进行数值计算的。如，除以2×2像素。这也是为什么GPU架构专注于调度四边形的原因。</strong></p>
<p><strong>一般来说，导数计算是在幕后进行的，即它们对用户是隐藏的。实际的实现通常是在一个四轴上使用跨车道指令(shuffle/swizzle)，这样的指令可以被编译器插入。有些GPU使用固定功能的硬件来计算这些导数。对于如何计算衍生品并没有确切的规范。一些常用的方法如下图所示。OpenGL 4.5和DirectX 11都支持粗函数和细函数。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116162949.png" class="" title="image-20211116162949">

<p>说明如何计算导数。箭头表示计算箭头结束处的像素与开始处的像素之间的差异。例如，左上角的水平差被计算为右上角像素减去左上角像素。对于粗导数(左)，一个水平差和一个垂直差用于四元组内的所有四个像素。对于精细的导数(右)，我们使用最接近像素的差异。</p>
<p><strong>所有GPU都使用纹理缓存来减少纹理的带宽占用。有些架构使用专用缓存来纹理，甚至使用两个专用级别的纹理缓存，而其他架构则在所有类型的访问(包括纹理)之间共享缓存。通常使用一个小的片上存储器(通常是SRAM)来实现纹理缓存。这个缓存存储最近纹理读取的结果，访问非常快。替换策略和大小依赖于体系结构。如果相邻的像素需要访问相同或接近位置的texels，它们很可能在缓存中找到这些。正如在第23.4节中提到的，内存访问通常以平铺方式完成，所以像素不是以扫描线顺序存储，而是以小的平铺存储，例如，4 × 4像素，这提高了效率，因为一个平铺Texels是拼凑在一起的。以字节为单位的平铺大小通常与缓存行大小相同，例如，64字节。另一种存储纹理的方法是使用混合图案。假设纹理坐标已经被转换为定点数字:(u, v)，其中每个u和v都有n位。u中编号为i的位记为ui．然后将(u, v)重映射到一个混合的纹理地址A为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116163113.png" class="" title="image-20211116163113">

<p><strong>其中B是纹理的基址，T是一个texel所占用的字节数。这种重新映射的好处是它会产生如下图所示的texel顺序。可以看出，这是一条空间填充曲线，称为莫顿序列（Morton sequence），它可以提高相干性。在这种情况下，曲线是二维的，因为纹理通常也是。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116163209.png" class="" title="image-20211116163209">

<p>纹理混合增加texel内存访问的一致性。注意，这里的texel大小是4字节，texel地址显示在每个texel的左上角。</p>
<p><strong>纹理单元还包含自定义硅来解压几种不同的纹理格式(章节6.2.6)。与软件实现相比，在固定功能的硬件中实现这些功能通常要高效许多倍。注意，当使用纹理作为渲染目标和纹理映射时，会出现其他压缩机会。如果颜色缓冲的压缩是启用的(章节23.5)，那么当访问这样的渲染目标作为纹理时，有两个设计选项。当渲染目标完成渲染后，一个选项是将整个渲染目标从其颜色缓冲压缩格式中解压缩，并将其未压缩存储以供后续纹理访问。第二种选择是在纹理单元中添加硬件支持，以解压颜色缓冲压缩格式。后者是更有效的选择，因为渲染目标可以保持压缩，甚至在访问期间作为纹理。更多关于缓存和压缩的信息可以在23.4节找到。</strong></p>
<p><strong>Mipmapping对纹理缓存局部性很重要，因为它强制一个最大像素比。当遍历一个三角形时，每个新像素代表纹理空间中大约一个像素的一个步骤。Mipmapping是渲染中为数不多的同时提高视觉效果和性能的技术之一。</strong></p>
<h2 id="Architecture-架构"><a href="#Architecture-架构" class="headerlink" title="Architecture 架构"></a>Architecture 架构</h2><p><strong>获得更快图像的最佳方法是利用并行性，这几乎可以在GPU的所有阶段实现。这个想法是同时计算多个结果，然后在稍后的阶段合并这些结果。通常，并行图形体系结构的外观如下图所示。应用程序将任务发送给GPU，经过一些调度后，在几个几何单元中并行地开始几何处理。从几何处理的结果被转发到一组栅格化单元，执行栅格化。然后由一组像素处理单元并行地执行像素着色和混合。最后，生成的图像被发送到显示器以供查看。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116163449.png" class="" title="image-20211116163449">

<p>一种高性能并行计算机图形体系结构的通用体系结构，由几个几何单元(G)、光栅化单元(R)和像素处理单元(P)组成。</p>
<p><strong>对于软件和硬件，重要的是要认识到，如果您的代码或硬件有一个串行部分，它将限制可能的总体性能改进。这由阿姆达尔定律表示，即，</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116163531.png" class="" title="image-20211116163531">

<p><strong>其中s是程序/硬件的串行百分比，因此1 - s是可用于并行化的百分比。此外，p是通过并行化程序或硬件可以实现的最大性能改进因子。例如，如果我们最初有一个多处理器，然后增加了三个，那么p = 4。这里，a(s, p)是你从改进中得到的加速因子。如果我们有一个体系结构，比如说，10%是序列化的，也就是说。s = 0.1，我们改进了我们的架构，使其余(非串行)部分可以改进20倍，则a = 1/(0.1 + 0.9/20)≈6.9。可以看到，我们没有得到20的加速，原因是代码/硬件的串行部分严重限制了性能。实际上，当p→∞时，a = 10。是把精力花在改进并行部分还是串行部分上并不总是很清楚，但在并行部分得到实质性改进之后，串行部分将更加限制性能。</strong></p>
<p><strong>对于图形架构，多个结果是并行计算的，但是绘制调用中的原语应该按照CPU提交的顺序进行处理。因此，必须进行某种排序，以便并行单元一起呈现用户想要的图像。具体来说，需要从模型空间到屏幕空间进行排序(章节2.3.1和2.4)。应该注意的是，几何单位和像素处理单位可以映射到相同的单位，即统一的运算器。我们案例研究部分的所有架构都使用统一着色器架构(章节23.10)。即使是这样，理解排序发生的位置也是很重要的。我们提出了并行架构的分类。排序可以发生在管线中的任何地方，这将在并行架构中产生四种不同的工作分配类别，如下图所示。它们被称为优先排序、中间排序、最后排序片段和最后排序图像。请注意，这些架构导致了在GPU的并行单元之间分配工作的不同方法。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116163714.png" class="" title="image-20211116163714">

<p>并行图形架构的分类。A是应用，G是几何单位，R是光栅化单位，P是像素处理单位。从左到右，体系结构分别是排序优先、排序中间、排序最后的片段和排序最后的映像。</p>
<p><strong>基于排序优先的体系结构在几何阶段之前对原语进行排序。策略是将屏幕划分为一组区域，区域内的原语被发送到“拥有”该区域的完整管道。参见下图。原语的初始处理足以知道它需要发送哪个区域——这就是排序步骤。排序优先是对一台机器探索最少的架构。这种方案确实适用于驱动由多个屏幕或投影仪组成的大屏幕系统，因为每个屏幕都有一台计算机。一个名为Chromium的系统已经开发出来，它可以使用工作站集群实现任何类型的并行绘制算法。例如，排序优先和排序最后可以实现较高的渲染性能。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116163827.png" class="" title="image-20211116163827">

<p>排序优先将屏幕分割成多个单独的块，并为每个块分配一个处理器，如下所示。然后将原语发送给它们重叠的处理器。这与排序中间架构形成了对比，后者需要在几何处理完成后对所有三角形进行排序。只有在所有三角形都被排序后，才能开始逐像素光栅化。</p>
<p><strong>马里建筑(章节23.10.1)属于中等类型。几何处理单元被赋予大约相同数量的几何处理。</strong></p>
<p><strong>然后，转换后的几何图形被分类为不重叠的矩形，称为瓷砖，它们一起覆盖整个屏幕。注意，转换后的三角形可能会与几个贴图重叠，因此可能会被几个光栅化器和像素处理单元处理。这里效率的关键是，每对光栅化和像素处理单元在芯片上都有一个瓦片大小的帧缓冲区，这意味着所有对帧缓冲区的访问都非常快。当所有的几何图形被分类到贴图时，每个贴图的栅格化和像素处理可以开始彼此独立。一些中间排序架构为不透明几何图形的每个tile执行z- preass，这意味着每个像素只着色一次。然而，并不是所有的排序中间架构都这样做。</strong></p>
<p><strong>最后排序片段体系结构在栅格化(有时称为片段生成)之后和像素处理之前对片段进行排序。一个例子是GCN架构，在第23.10.3节中描述。就像中间排序一样，原语尽可能均匀地分布在几何单元中。最后排序片段的一个优点是不会有任何重叠，这意味着生成的片段只被发送到一个像素处理单元，这是最优的。如果一个光栅化单元处理大三角形，而另一个处理小三角形，就会出现不平衡。</strong></p>
<p><strong>最后，最后排序图像结构经过像素处理后进行排序。如下图所示。这个体系结构可以看作是一组独立的管线。原语分布在管线中，每个管线呈现一个具有深度的图像。在最后的合成阶段，所有的图像都是根据它们的z-buffer进行合并。需要注意的是，最后排序的图像系统不能完全实现像OpenGL和DirectX这样的API，因为它们需要原语按发送的顺序排列。PixelFlow是最后排序图像架构的一个例子。PixelFlow架构也值得注意，因为它使用了延迟着色，这意味着它只着色可见的片段。但是，应该注意的是，由于管道末端占用了大量的带宽，目前的体系结构没有使用最后排序图像。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116164107.png" class="" title="image-20211116164107">

<p>在最后排序图像中，场景中的不同对象被发送到不同的处理器。当合成单独的渲染图像时，透明度很难处理，所以透明对象通常被发送到所有节点。</p>
<p><strong>对于大型平铺显示系统来说，纯最后排序图像方案的一个问题是，需要在渲染节点之间传输大量的图像和深度数据。Roth和Reiners通过使用每个处理器结果的屏幕和深度边界来优化数据传输和组成成本。</strong></p>
<p><strong>Eldridge等人提出了Pomegranate，一种到处排序的架构。简单地说，它在几何阶段和光栅单元(R’s)之间、R’s和像素处理单元(P’s)之间以及P’s和显示器之间插入排序阶段。因此，随着系统的扩展(即因为更多的管线被添加)。分拣阶段被实现为具有点对点链接的高速网络。仿真表明，随着管线的增加，性能几乎呈线性增长。</strong></p>
<p><strong>一个图形系统中的所有组件(主机、几何处理、光栅化和像素处理)连接在一起就构成了一个多处理系统。对于这样的系统，有两个众所周知的问题，并且几乎总是与多处理相关:负载平衡和通信。先进先出队列通常被插入到管道中的许多不同位置，以便作业可以排队，以避免管道的某些部分陷入停顿。例如，可以在几何图形和光栅化单元之间放置一个FIFO，这样，如果光栅化单元不能跟上几何图形单元的速度，例如，由于巨大的三角形大小，可以缓冲几何处理的三角形。</strong></p>
<p><strong>所描述的不同排序体系结构具有不同的负载平衡优点和缺点。查阅Eldridge的博士论文或Molnar等人的论文以获取更多信息。程序员也可以影响负载平衡;实现这一目标的技术将在第18章中讨论。如果总线的带宽过低，或者使用不明智，通信可能是一个问题。因此，设计一个应用程序的渲染系统，使瓶颈不发生在任何总线上，例如从主机到图形硬件的总线，是极其重要的。第18.2节介绍了检测瓶颈的不同方法。</strong></p>
<h2 id="Case-Studies-案例研究"><a href="#Case-Studies-案例研究" class="headerlink" title="Case Studies 案例研究"></a>Case Studies 案例研究</h2><p><strong>本节将介绍三种不同的图形硬件架构。首先展示的是ARM Mali G71彩虹桥架构，目标是移动设备和电视。接下来是英伟达的Pascal架构。最后，我们描述了AMD的GCN架构，称为Vega。</strong></p>
<p><strong>请注意，图形硬件公司的设计决策通常基于尚未构建的gpu的广泛软件模拟。也就是说，几个应用程序，例如游戏，通过它们的参数化模拟器运行几个不同的配置。例如，可能的参数是MPs的数量、时钟频率、缓存的数量、光栅引擎/tessellator引擎的数量和ROPs的数量。模拟用于收集有关性能、功率使用和内存带宽使用等因素的信息。在一天结束时，选择在大多数用例中工作得最好的可能配置，并根据该配置构建芯片。此外，模拟可能有助于发现体系结构中的典型瓶颈，然后可以解决这些瓶颈，例如增加缓存的大小。对于特定的GPU，不同的速度和单位数量的原因很简单，“它以这种方式工作得最好。”</strong></p>
<h3 id="Case-Study-ARM-Mali-G71-Bifrost-案例研究-ARM-Mali-G71彩虹桥"><a href="#Case-Study-ARM-Mali-G71-Bifrost-案例研究-ARM-Mali-G71彩虹桥" class="headerlink" title="Case Study: ARM Mali G71 Bifrost 案例研究:ARM Mali G71彩虹桥"></a>Case Study: ARM Mali G71 Bifrost 案例研究:ARM Mali G71彩虹桥</h3><p><strong>Mali产品线包括ARM的所有GPU架构，Bifrost是他们2016年推出的架构。这种架构的目标是移动和嵌入式系统，例如移动电话、平板电脑和电视。2015年，基于马里的GPU出货量为7.5亿台。由于其中许多都是由电池供电的，因此设计一个节能的建筑而不是只关注性能是很重要的。因此，使用排序中间体系结构是有意义的，在这种体系结构中，所有帧缓冲区访问都保存在芯片上，这降低了功耗。马里所有的建筑都是中间建筑，有时被称为瓦片建筑。GPU的高级概述如下图所示。可以看到，G71可以支持多达32个统一着色器引擎。ARM使用术语着色器核心而不是着色器引擎，但我们使用术语着色器引擎以避免与本章的其余部分混淆。一个着色器引擎能够一次执行12个线程的指令。，它有12个ALU。32个着色器引擎的选择是专门为G71，但架构规模超过32个引擎。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116164600.png" class="" title="image-20211116164600">

<p>Bifrost G71 GPU架构，可扩展到32个着色器引擎，每个着色器引擎如下图所示。</p>
<p><strong>驱动软件为GPU提供工作。作业管理器，即然后将工作分配给着色引擎。这些引擎通过GPU fabric连接，GPU fabric是一个总线，引擎可以在此总线上与GPU中的其他单元通信。所有内存访问都通过内存管理单元(MMU)发送，MMU将虚拟内存地址转换为物理地址。</strong></p>
<p><strong>着色器引擎的概述如下图所示。可以看到，它包含三个执行引擎，围绕着四边形执行着色。因此，它们被设计成SIMD宽度为4的小型通用处理器。每一个执行引擎包含4个融合乘加(FMA)单元，用于32位浮点数和4个32位加法器。这意味着有3 × 4个ALU，即每个着色器引擎有12条SIMD通道。用我们这里的术语来说，四轴曲相当于经线。例如，为了隐藏纹理访问的延迟，架构可以在每个着色器引擎中保持至少256个线程。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116164720.png" class="" title="image-20211116164720">

<p>彩虹桥着色器引擎架构，其中的瓦片内存是在芯片上，这使得快速的本地帧缓冲区访问。</p>
<p><strong>注意，着色器引擎是统一的，可以执行计算、顶点和像素着色等操作。执行引擎还包含对许多超越函数的支持，如正弦和余弦函数。此外，在使用16位浮点精度时，性能可达2倍。这些单元还支持绕过寄存器内容的情况下，当一个寄存器的结果只作为输入到后面的指令。这样可以节省电力，因为不需要访问注册文件。此外，当执行纹理或其他内存访问时，例如，单个四元组可以由四元组管理器切换进来，类似于其他架构如何隐藏此类操作的延迟。注意，这是在小粒度级别上发生的，交换4个线程而不是全部12个线程。加载/存储单元负责一般的内存访问、内存地址转换和一致缓存。属性单元处理属性索引和寻址。它将访问发送到加载/存储单元。变化单元执行变化属性的插值。</strong></p>
<p><strong>平铺架构(排序-中间)的核心思想是首先执行所有的几何处理，以便找到要渲染的每个原语的屏幕空间位置。同时，为帧缓冲区中的每个瓦片构建一个多边形列表，其中包含指向重叠瓦片的所有原语的指针。在这一步之后，重叠贴图的原语集就被知道了。因此，可以对平铺中的原语进行栅格化和着色，并将结果存储在片上平铺存储器中。当tile完成了它所有的原语渲染后，tile内存中的数据通过L2缓存写回外部内存。这减少了内存带宽的使用。然后下一个贴图被栅格化，以此类推，直到整个帧被渲染。第一个平铺架构是Pixel-Planes 5，该系统与马里架构有一些高层相似之处。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116164856.png" class="" title="image-20211116164856">

<p>说明几何图形如何流经彩虹桥建筑。顶点着色器由位置着色(被平铺使用)和变化着色(在平铺之后只在需要时执行)组成。</p>
<p><strong>上图可视化了几何处理和像素处理。可以看到，顶点着色器被分割成一个只执行位置着色的部分和另一个称为变化着色的部分，这是在平铺后完成的。与ARM以前的架构相比，这节省了内存带宽。执行装箱所需要的唯一信息是顶点的位置，用来确定一个原语覆盖了哪些块。下图所示的分层方式显示了执行分类的层单元。这有助于使装箱的内存占用更小，更可预测，因为它不再与原始大小成比例。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116165004.png" class="" title="image-20211116165004">

<p>彩虹桥结构的分层层。在这个例子中，装箱是在三个不同的层次上完成的，每个三角形都被分配到与单个正方形重叠的层次上。</p>
<p><strong>当贴图完成场景中所有原语的分类后，就可以确切地知道哪些原语与某个tile重叠。因此，只要有可用的着色器引擎可以并行工作，其余的光栅化、像素处理和混合可以对任意数量的贴图并行执行。通常，一个平铺被提交给一个处理平铺中所有原语的着色器引擎。当这个工作完成了所有的瓷砖，它也可以开始与几何处理和下一帧的平铺。这个处理模型意味着在平铺体系结构中可能存在更多的延迟。</strong></p>
<p><strong>在这一点上，光栅化，像素着色器执行，混合和其他逐像素操作。平铺架构最重要的一个特性是，单个平铺的帧缓冲区(例如，包括颜色、深度和模板)可以存储在片上快速内存中，这里称为平铺内存。这是可以承受的，因为贴图很小(16 × 16像素)。当tile中的所有呈现完成后，tile的期望输出(通常是颜色，可能还有深度)被复制到与屏幕大小相同的芯片外帧缓冲区(在外部内存中)。这意味着在逐像素处理期间对帧缓冲区的所有访问实际上都是免费的。避免使用外部总线是非常可取的，因为这种使用带来了很高的能源成本。当将片内块内存的内容逐出片外帧缓冲区时，仍然可以使用帧缓冲区压缩。</strong></p>
<p><strong>彩虹桥支持像素本地存储(PLS)，这是一组通常支持排序-中间架构的扩展。使用PLS，可以让像素着色器访问帧缓冲区的颜色，从而实现自定义混合技术。相反，混合通常是使用API配置的，并且不能在其中编程像素着色器的方法。用户还可以使用贴图内存存储每个像素的任意固定大小的数据结构。这允许程序员有效地实现，例如，延迟着色技术。G缓冲(例如，法线，位置，和漫反射纹理)存储在PLS在第一个通过。第二次通过执行光照计算并在PLS中积累结果。第三次通过使用PLS中的信息来计算最终像素的颜色。请注意，对于单个tile，所有这些计算都是在整个tile内存保存在芯片上时进行的，这使得它非常快。</strong></p>
<p><strong>所有马里架构都是基于多重采样反锯齿(MSAA)设计的，他们实现了第143页描述的旋转网格超采样(RGSS)方案，每像素使用4个样本。排序-中间架构非常适合抗锯齿。这是因为过滤是在贴图离开GPU并被发送到外部内存之前完成的。因此，外部内存中的帧缓冲区只需要为每个像素存储一种颜色。一个标准体系结构需要一个四倍于此大小的帧缓冲区。对于平铺架构，您只需要将芯片上平铺缓冲区增加4倍，或者有效地使用更小的平铺(宽度和高度的一半)。</strong></p>
<p><strong>马里彩虹桥体系结构还可以选择性地选择在一批渲染原语上使用多重采样或超采样。这意味着更昂贵的超采样方法，即对每个样本执行像素着色器，可以在需要时使用。一个例子是用alpha映射渲染一个有纹理的树，在这里你需要高质量的采样以避免视觉工件。对于这些原语，可以启用超采样。当这种复杂的情况结束，需要渲染更简单的对象时，可以切换回使用更便宜的多次采样方法。该建筑还支持8×和16× MSAA。</strong></p>
<p><strong>Bifrost(以及之前称为Midgard的体系结构)还支持一种称为事务消除的技术。这个想法是为了避免场景中不随帧变化的部分从tile内存转移到芯片外内存。对于当前帧，当瓦片被逐出到芯片外帧缓冲区时，将为每个瓦片计算唯一的签名。这个签名是校验和的一种类型。对于下一帧，将为将要被驱逐的块计算签名。如果来自前一帧的签名与当前帧的特定贴图的签名相同，那么架构将避免将颜色缓冲区写入芯片外内存，因为正确的内容已经在那里了。这对于休闲手机游戏(游戏邦注:如《愤怒的小鸟》)尤其有用，因为在这类游戏中，每帧更新的场景比例较小。还要注意，这种类型的技术很难在最后排序架构上实现，因为它们不是按每个贴图操作的。G71还支持智能组合(smart composition)，即应用于用户界面组合的事务消除。它可以避免读取、合成和写入像素块，如果所有的源都与前一帧相同，并且操作相同。</strong></p>
<p><strong>低功耗的技术，如时钟门控和功率门控，也在这个体系结构中大量使用。这意味着管线中未使用或不活动的部分将被关闭或以较低的能耗保持闲置，以减少电力消耗。</strong></p>
<p><strong>为了减少纹理带宽，有一个纹理缓存，为ASTC和ETC提供了专用的解压单元。此外，压缩纹理以压缩的形式存储在缓存中，而不是解压纹理然后将texel放入缓存中。这意味着当请求一个texel时，硬件从缓存中读取块，然后动态地解压缩块的texel。这种配置增加了缓存的有效大小，从而提高了效率。</strong></p>
<p><strong>一般来说，瓦片架构的一个优点是，它天生就设计了瓦片的并行处理。例如，可以添加更多的着色器引擎，其中每个着色器引擎负责一次独立渲染到单个贴图。平铺架构的一个缺点是，整个场景数据需要发送到GPU进行平铺，处理的几何数据流输出到内存。一般来说，排序中间架构不是理想的处理几何放大，如应用几何着色器和镶嵌，因为更多的几何增加了内存传输的数量来回变换几何。对于马里架构，几何着色(章节18.4.2)和镶嵌都是在GPU上的软件中处理的，马里最佳实践指南建议永远不要使用几何着色器。对于大多数内容，中间排序体系结构在移动和嵌入式系统中工作得很好。</strong></p>
<h3 id="Case-Study-NVIDIA-Pascal-案例研究-NVIDIA-Pascal"><a href="#Case-Study-NVIDIA-Pascal-案例研究-NVIDIA-Pascal" class="headerlink" title="Case Study: NVIDIA Pascal 案例研究:NVIDIA Pascal"></a>Case Study: NVIDIA Pascal 案例研究:NVIDIA Pascal</h3><p><strong>Pascal是NVIDIA构建的GPU架构。它既作为图形部分存在，也作为计算部分存在，后者的目标是高性能计算和深度学习应用。在本演示中，我们将主要关注图形部分，特别是称为GeForce GTX 1080的特定配置。我们将以自下而上的方式呈现架构，从最小的统一ALU开始，然后逐步构建到整个GPU。我们将在本节的最后简要介绍一些其他芯片配置。</strong></p>
<p><strong>Pascal图形架构中使用的统一ALU (NVIDIA术语中的cuda核心)与1002页图23.8左侧的ALU具有相同的高级图。ALU的重点是浮点和整数运算，但它们也支持其他运算。为了提高计算能力，将几个这样的ALU组合成一个流多处理器(SM)。在Pascal的图形部分中，SM由4个处理块组成，每个处理块有32个ALU。这意味着SM可以同时执行32个线程的4次翘曲。如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116170418.png" class="" title="image-20211116170418">

<p>Pascal流多处理器(SM)具有32 × 2 × 2的统一ALU和SM被封装在一个多态引擎中，共同形成一个纹理处理集群(TPC)。请注意，顶部深灰色的盒子被复制到它下面，但部分复制被省略了。</p>
<p><strong>每个处理块，即是一款宽度为32的SIMT引擎，也有8个负载/存储(LD/ST)单元和8个特殊功能单元(SFUs)。加载/存储单元处理寄存器文件中寄存器的读写值，该文件为16,384 × 4字节，即每个处理块64 kB，每SM加起来等于256 kB。 SFUs处理超越函数指令，如正弦、余弦、指数(以2为底)、对数(以2为底)、倒数和倒数平方根。它们还支持属性插值。</strong></p>
<p><strong>SM中的所有ALU共享一个指令缓存，而每个SIMT引擎都有自己的指令缓冲区，其中包含一组最近加载的指令，以进一步提高指令缓存命中率。翘曲调度程序能够在每个时钟周期内调度两个翘曲指令，例如，工作可以被调度到两个时钟周期，同一时钟周期内的ALU和LD/ST单位。注意，每个SM也有两个L1缓存，每个有24 kB的存储，即48kb / SM。使用两个L1缓存的原因可能是，L1缓存越大，需要的读写端口越多，增加了缓存的复杂性，使得芯片上的实现更大。此外，每个SM有8个纹理单位。</strong></p>
<p><strong>因为着色必须在2 × 2像素四边形中完成，warp调度器找到8个不同像素四边形的工作，并将它们分组在32个SIMT车道中执行。因为这是一个统一的ALU设计，翘曲调度程序可以组一个顶点，像素，原语，或计算着色工作到翘曲。注意，SM可以同时处理不同类型的扭曲(如顶点、像素和原语)。该体系结构在将当前正在执行的翘曲切换到准备执行的翘曲时也没有任何开销。关于接下来要在Pascal上执行什么warp的细节还没有公开，但是之前的NVIDIA架构给了我们一些提示。在2008年的NVIDIA特斯拉架构中，一个记分牌被用来限定每个时钟周期的每个偏差。计分板是一种通用的机制，它允许无序执行而不产生冲突。翘曲调度程序会选择那些已经准备好执行的翘曲，例如，不等待纹理加载返回的翘曲，并选择优先级最高的翘曲。翘曲类型、指令类型和“公平性”是用来选择最高优先级翘曲的参数。</strong></p>
<p><strong>SM与变形引擎(PM)协同工作。这个单元是在费米芯片中首次引入的。PM执行几个几何相关的任务，包括取顶点、镶嵌、同时进行多投影、属性设置和流输出。第一阶段从全局顶点缓存中获取顶点，并将顶点和船体着色的变形发送到SMs。然后是一个可选的镶嵌阶段(第17.6节)，其中新生成的(u, v)补丁坐标被分派到SMs，用于域着色和可选的几何着色。第三阶段处理视口转换和透视校正。此外，这里还执行了一个可选的同步多投影步骤，可以用于高效的VR渲染，例如(章节21.3.1)。接下来是可选的第四个阶段，在这个阶段，顶点被流输出到内存。最后，将结果转发给相关的光栅引擎。</strong></p>
<p><strong>光栅引擎有三个任务，即三角形设置、三角形遍历和z-culling。三角形设置获取顶点，计算边方程，并执行背面剔除。三角形遍历使用分层平铺遍历技术来访问重叠三角形的平铺。它使用边方程来执行平铺测试和内部测试。在费米上，每个光栅化器每个时钟周期最多可以处理8个像素。帕斯卡身上没有公开号码。z-culling单元使用第23.7节中描述的技术来处理每个贴图上的culling。如果一个瓦片被选中，那么对该瓦片的处理将立即终止。对于幸存的三角形，每个顶点的属性被转换成平面方程，以便在像素着色器中进行有效的评估。</strong></p>
<p><strong>与变体引擎耦合的流处理器称为纹理处理集群(TPC)。在更高的层次上，5个TPC被分组到一个图形处理集群(GPC)中，该集群有一个单一的光栅引擎为这5个TPC提供服务。GPC可以被认为是一个小型的GPU，它的目标是为图形提供一套平衡的硬件单元，例如顶点、几何、光栅、纹理、像素和ROP单元。正如我们将在本节最后看到的，创建独立的功能单元可以让设计师更容易地创建具有一系列功能的GPU芯片家族。</strong></p>
<p><strong>至此，我们已经拥有了GeForce GTX 1080的大部分构建块。它由4个GPC组成，这个常规设置如下图所示。请注意，这里还有另一种级别的调度，由GigaThread引擎提供支持，以及到PCIe v3的接口。GigaThread引擎是一个全局工作分配引擎，它将线程块调度到所有的GPC。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116171019.png" class="" title="image-20211116171019">

<p>Pascal GPU在其GTX 1080配置20个SMs，20个 polymorph engines，4个raster engines，8×20 = 160个纹理单元(峰值速率为277.3 Gtexels/s)， 256×20 = 5120 kB的注册文件，以及总共20 × 128 = 2560个统一ALU。</p>
<p><strong>光栅操作单元也显示在上图中，尽管有些隐藏。它们位于图中L2缓存的正下方。每个蓝块为1个ROP单位，共8组，每组8个ROP，共64个ROP。ROP单元的主要任务是将输出写入像素和其他缓冲区，并执行各种操作，如混合。如图左右所示，共有8个32位内存控制器，合计为256位。八个ROP单元绑定到一个内存控制器和256kb的L2缓存。这为整个芯片提供了2MB的L2缓存。每个ROP都绑定到某个内存分区，这意味着一个ROP处理缓冲区中某个像素子集。ROP装置还可以处理无损压缩。有三种不同的压缩模式除了支持未压缩和快速清除。对于2:1压缩(例如，从256 B到128 B)，每个贴图存储一个参考颜色值，并在像素之间编码差异，其中每个差异使用比未压缩形式更少的比特进行编码。然后4:1压缩是2:1模式的扩展，但这种模式只能在差异可以使用更少的位编码的情况下启用，而且它只适用于那些内容平滑变化的块。还有一种8:1模式，它是2 × 2像素块的4:1恒定颜色压缩与上述的2:1模式的组合。8:1模式的优先级高于4:1,4:1模式的优先级高于2:1，即:压缩率最高的模式，也成功地压缩瓷砖总是使用。如果所有这些压缩尝试都失败了，则必须以未压缩的形式传输并存储在内存中。帕斯卡压缩系统的效率如下图所示。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116171230.png" class="" title="image-20211116171230">

<p>渲染后的图像显示在左边，而压缩结果显示在Maxwell(中间)、Pascal之前的架构和Pascal(右边)。图像越呈紫色，缓冲压缩成功率越高。</p>
<p><strong>显存为GDDRX5，时钟速率为10GHz。上面我们看到8个内存控制器总共提供256位= 32B。这总共提供了320GB /s的内存峰值带宽，但是许多级别的缓存结合压缩技术提供了更高的有效速率。</strong></p>
<p><strong>该芯片的基时钟频率为1607 MHz，当有足够的功率预算时，它可以工作在升压模式(1733 MHz)。峰值计算能力为</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116171343.png" class="" title="image-20211116171343">

<p><strong>其中2来自于这样一个事实:一个融合了乘法和加法的运算通常被计算为两个浮点运算，我们已经除以10^6从MFLOPS转换为TFLOPS。GTX 1080 Ti具有3584个ALUs，导致12.3 TFLOPS。</strong></p>
<p><strong>NVIDIA开发最后排序片段架构已经很长时间了。然而，由于Maxwell，它们还支持一种称为平铺缓存的新呈现类型，这种呈现在排序中间和排序最后的片段之间。该架构如下图所示。其思想是利用局部性和L2缓存。几何图形是在足够小的块中处理的，因此输出可以留在这个缓存中。此外，帧缓冲区也保持在L2中，只要几何重叠的平铺还没有完成像素着色。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116171457.png" class="" title="image-20211116171457">

<p>平铺缓存引入了一个binner来将几何图形分类为平铺，并让转换后的几何图形留在L2缓存中。当前处理的贴图也会留在L2中，直到当前块的几何图形完成为止。</p>
<p><strong>在上上上图中有四个光栅引擎，但是我们知道图形API必须(在大多数情况下)遵守原始提交顺序。帧缓冲区是通常使用一般化的棋盘模式分割成多个贴图，每个栅格引擎“拥有”一组贴图。当前三角形被发送到至少有一个与三角形重叠的贴图的每个栅格引擎，这就独立地解决了每个贴图的排序问题。这有利于更好的负载平衡。在GPU架构中通常也有几个FIFO队列，它们是为了减少硬件单元的消耗。这些队列没有显示在我们的图中。</strong></p>
<p><strong>显示器控制器为每色12位，支持BT.2020宽色域。它还支持HDMI 2.0b和HDCP 2.2。对于视频处理，它支持SMPTE 2084，这是一个高动态范围视频的传递函数。Venkataraman描述了英伟达架构如何从费米和之后有一个或多个复制引擎。这些内存控制器可以执行直接内存访问(DMA)传输。DMA传输发生在CPU和GPU之间，这样的传输通常在这两者中任意一个上启动。开始处理单元可以在传输期间继续进行其他计算。复制引擎可以启动CPU和GPU内存之间的DMA数据传输，它们可以独立于GPU的其余部分执行。因此，当信息从CPU传输到GPU时，GPU可以渲染三角形并执行其他功能，反之亦然。</strong></p>
<p><strong>Pascal体系结构也可以配置为非图形化应用程序，例如用于训练神经网络或大规模数据分析。特斯拉P100就是一个这样的配置。与GTX 1080的一些不同之处在于，它使用4096位的高带宽内存2 (HBM2)作为内存总线，提供720 GB/s的总内存带宽。此外，它们具有本地16位浮点数支持，性能是32位浮点数的2倍，双精度处理速度更快。SM配置也不同，寄存器文件设置也不同。</strong></p>
<p><strong>GTX 1080 Ti是一个高端配置。它有3584个ALU, 352位内存总线，484 GB/s的总内存带宽，88个rop, 224个纹理单元，相比之下GTX 1080有2560、256位、320 GB/s、64和160个纹理单元。</strong></p>
<p><strong>它使用6个GPC进行配置，即它有6个光栅引擎，而GTX 1080只有4个。其中4个GPC与GTX 1080完全相同，而剩下的2个稍微小一些，只有4个TPC而不是5个。1080 Ti由120亿个晶体管组成，而1080使用了72亿个晶体管。Pascal架构非常灵活，因为它还可以缩小规模。例如，GTX 1070是GTX 1080减去一个GPC，而GTX 1050由两个GPC组成，每个GPC有三个短信。</strong></p>
<h3 id="Case-Study-AMD-GCN-Vega-案例研究-AMD-GCN-Vega"><a href="#Case-Study-AMD-GCN-Vega-案例研究-AMD-GCN-Vega" class="headerlink" title="Case Study: AMD GCN Vega 案例研究:AMD GCN Vega"></a>Case Study: AMD GCN Vega 案例研究:AMD GCN Vega</h3><p><strong>AMD显卡产品以及Xbox One和PLAYSTATION 4都采用了AMD的GCN架构。在这里，我们描述GCN Vega架构的一般元素，它是这些控制台中使用的架构的演变。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116172001.png" class="" title="image-20211116172001">

<p>维加架构的GCN计算单元。每个向量寄存器文件有64 kB的容量，而标量RF有12.5 kB，本地数据共享有64 kB。注意，对于每个CU中的计算，有四个16 SIMD通道单元(浅绿色)，带有32位浮点数。</p>
<p><strong>GCN架构的核心构建块是计算单元(CU)，如上图所示。CU有四个SIMD单元，每个单元有16个SIMD通道。16个统一的ALU(使用第23.2节的术语)。每个SIMD单元执行64个线程的指令，这被称为波前。每个SIMD单元可以在每个时钟周期内发出一条单精度浮点指令。因为该体系结构每个SIMD单元处理64个线程的波前，在波前完全发出之前需要4个时钟周期。还要注意，CU可以同时运行来自不同内核的代码。由于每个SIMD单元有16个通道，每个时钟周期可以发出一条指令，因此整个CU的最大吞吐量为每个CU 4个SIMD单元×每个单元16个SIMD通道=每个时钟周期64个单精度FP操作。CU还可以执行比单精度FP多一倍的半精度(16位浮点)指令，这对于需要较低精度的情况非常有用。例如，这可以包括机器学习和着色器计算。注意，两个16位FP值被打包成一个32位FP寄存器。每个SIMD单元有一个64 kB的寄存器文件，这相当于每线程65 536/(4·64)= 256个寄存器，因为一个单精度FP使用4字节，每个波前有64个线程。ALU有四个硬件管线阶段。</strong></p>
<p><strong>每个CU都有一个指令缓存(图中没有显示)，最多可以在四个SIMD单元之间共享。相关指令被转发到SIMD单元的指令缓冲区(IB)。每个IB有处理10个波前的存储空间，可以根据需要切换到SIMD单元，以隐藏延迟。这意味着CU可以处理40个波阵面。这相当于40·64 = 2560个线程。因此，上图中的CU调度器一次可以处理2560个线程，它的任务是将工作分配到CU的不同单元。每个时钟周期，当前CU上的所有波前都被考虑为指令问题，每个执行端口最多可以发出一条指令。CU的执行端口包括分支、标量/矢量ALU、标量/矢量内存、本地数据共享、全局数据共享或导出以及特殊指令，即每个执行端口大致对应CU的一个单元。</strong></p>
<p><strong>标量单元是一个64位的ALU，它也在SIMD单元之间共享。它有自己的标量寄存器文件和标量数据缓存(未显示)。标量射频每个SIMD单元有800个32位寄存器，即 800·4·4 = 12.5 kB。执行与波阵面紧密耦合。由于向SIMD单元完全发出一条指令需要四个时钟周期，因此标量单元只能每四个时钟周期为特定SIMD单元提供服务。标量单元处理控制流、指针运算和其他可以在warp中共享的计算。从标量单元发送条件和无条件的分支指令，以便在分支和消息单元中执行。每个SIMD单元都有一个单独的48位程序计数器(PC)，在通道之间共享。这就足够了，因为它们都执行相同的指令。对于获得的分支，程序计数器将被更新。该单元可以发送的消息包括调试消息、特殊图形同步消息和CPU中断。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116172226.png" class="" title="image-20211116172226">

<p>64 CUs的Vega 10 GPU。注意，每个CU包含如上图所示的硬件。</p>
<p><strong>Vega 10架构如上图所示。顶部部分包括一个图形命令处理器，两个硬件调度程序(HWSs)和八个异步计算引擎(ACEs)。GPC的任务是将图形任务调度到GPU的图形管道和计算引擎上。HWSs的缓冲区在队列中工作，它们尽可能快地分配给ACE。ACE的任务是将计算任务调度到计算引擎上。还有两个DMA引擎可以处理复制任务(图中没有显示)。GPC、ACEs和DMA引擎可以并行工作，并将工作提交给GPU，这可以提高利用率，因为任务可以从不同的队列中交错执行。可以从任何队列分派工作，而不需要等待其他工作完成，这意味着独立的任务可以同时在计算引擎上执行。ACE可以通过缓存或内存进行同步。它们可以一起支持任务图，这样一个ACE的任务可以依赖于另一个ACE的任务，或者依赖于图形管道的任务。建议较小的计算和复制任务与较重的图形任务交织。</strong></p>
<p><strong>如上图所示，有4个图形管道和4个计算引擎。每个计算引擎有16个CUs，合计64个CUs。图形管线有两个模块，即几何引擎和绘制流分类光栅(DSBR)。几何引擎包括几何汇编器、镶嵌单元和顶点汇编器。另外，支持一个新的原始着色器。基本着色器的想法是使更灵活的几何处理和更快的剔除基本的。DSBR结合了排序中间和排序最后架构的优点，这也是平铺缓存的目标(章节23.10.2)。图像在屏幕空间中被划分为多个贴图，经过几何处理后，每个原语被分配到它们重叠的贴图上。在平铺的栅格化过程中，所有需要的数据(例如平铺缓冲区)都保存在L2缓存中，这提高了性能。像素着色可以自动延迟，直到一个平铺中的所有几何图形都被处理完。因此，z- preass是在罩下完成的，像素只着色一次。延迟着色可以打开或关闭;例如，对于透明的几何体，它需要关闭。</strong></p>
<p><strong>为了处理深度、模板和颜色缓冲，GCN体系结构有一个称为颜色和深度块(CDB)的构建块。它们处理颜色、深度和模板阅读和写作，除了颜色混合。CDB可以使用23.5节中描述的一般方法压缩颜色缓冲区。使用增量压缩技术，每个贴图存储一个像素的颜色，不压缩，其余的颜色值相对于该像素颜色进行编码。为了提高效率，可以根据访问模式动态选择贴图大小。对于最初使用256字节存储的贴图，最大速率为8:1，即压缩到32字节。压缩后的颜色缓冲区可以作为后续通道中的纹理，在这种情况下，纹理单元将解压缩被压缩的贴图，从而进一步节省带宽。</strong></p>
<p><strong>光栅化器在每个时钟周期内最多可以光栅化四个原语。连接到图形管道和计算引擎的CDB每个时钟周期可以写16个像素。也就是说，小于16像素的三角形会降低效率。栅格化器还处理粗深度测试(HiZ)和分层模板测试。HiZ的缓冲区被称为HTILE，可以由开发人员编程，例如，用于向GPU提供遮挡信息。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116172523.png" class="" title="image-20211116172523">

<p>Vega架构的缓存层次结构。</p>
<p><strong>Vega的缓存层次结构如上图所示。在层次结构的顶端(图中最右边)，我们有寄存器，其次是L1和L2缓存。然后是高带宽内存2 (HBM2)，它也位于显卡上，最后是位于CPU端上的系统内存。Vega的一个新特性是高带宽缓存控制器(HBCC)，如上上图的底部所示。它允许视频内存像最后一级缓存一样运行。这意味着如果进行内存访问，而相应的内容不在显存中，则HBCC将自动通过PCIe总线获取相关的系统内存页，并将其放入显存。因此，视频内存中最近使用较少的页面可能会被换出。HBM2和系统内存之间共享的内存池称为HBCC内存段(HMS)。所有的图形块也通过L2缓存访问内存，这与以前的架构不同。该体系结构还支持虚拟内存(章节19.10.1)。</strong></p>
<p><strong>请注意，所有片上模块，例如HBCC、XDMA (CrossFire DMA)、PCI express、显示引擎和多媒体引擎，都通过一个称为Infinity Fabric (IF)的互连连接进行通信。AMD的CPU也可以连接到IF上。Infinity Fabric可以连接不同芯片芯片上的模块。IF也是一致的，这意味着所有块都可以在内存中看到相同的内容视图。</strong></p>
<p><strong>该芯片的基时钟频率为1677 MHz，即，峰值计算能力密度是</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116172656.png" class="" title="image-20211116172656">

<p><strong>其中FMA和TFLOPS的计算与公式23.16相符。该体系结构灵活且可扩展，因此需要更多配置。</strong></p>
<h2 id="Ray-Tracing-Architectures-光线追踪的架构"><a href="#Ray-Tracing-Architectures-光线追踪的架构" class="headerlink" title="Ray Tracing Architectures 光线追踪的架构"></a>Ray Tracing Architectures 光线追踪的架构</h2><p><strong>本节将简要介绍射线追踪硬件。我们不会列出关于这个主题的所有最近的引用，而是提供一组鼓励读者遵循的指针。2002年Schmittler等人开始了这一领域的研究，重点是遍历和交叉，使用固定功能单元计算遮光。这项工作后来被Woop等人跟进，他们提出了一个带有可编程着色器的架构。</strong></p>
<p><strong>在过去的几年中，对这个话题的商业兴趣有了相当大的增长。这一点可以从Imagination Technologies、LG电子和三星等公司提出的实时射线追踪硬件架构中看出。然而，在撰写本文时，只有Imagination Technologies发布了一款商业产品。</strong></p>
<p><strong>在这些体系结构中有几个共同的特点。首先，它们通常使用基于轴对齐的包围盒的包围体层次结构。其次，它们倾向于通过降低射线/盒交叉测试的精度来降低硬件复杂度(第22.7节)。最后，他们使用可编程核心来支持可编程底纹，这或多或少是当今的需求。例如，Imagination Technologies扩展了他们的传统芯片设计，添加了一个光线追踪单元，它可以利用着色器核心进行着色。光线追踪单元由光线相交处理器和相干引擎组成，相干引擎将具有相似性质的光线聚集在一起进行处理，利用局部性实现更快的光线追踪。Imagination Technologies的建筑还包括一个专门用于建造BVHs的单元。</strong></p>
<p><strong>该领域的研究还在继续探索几个领域，包括降低遍历的有效实现精度、BVHs的压缩表示和能效。毫无疑问，还有更多的研究要做。</strong></p>
<h1 id="24-The-Future-未来"><a href="#24-The-Future-未来" class="headerlink" title="24 The Future 未来"></a>24 The Future 未来</h1><p><strong>未来由两部分组成:你和其他一切。这一章是关于两者的。首先，我们将做一些预测，其中一些甚至可能成为现实。更重要的是第二部分，关于你接下来要去哪里。这是一个扩展的进一步阅读和参考资料部分，但是它也讨论了从这里开始的方法—一般的信息源、会议、代码等等。但首先，我们来看一幅图:参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116172911.png" class="" title="image-20211116172911">

<p>通过游戏《Destiny 2》，我们可以瞥见未来。</p>
<h2 id="Everything-Else-其他的一切"><a href="#Everything-Else-其他的一切" class="headerlink" title="Everything Else 其他的一切"></a>Everything Else 其他的一切</h2><p><strong>图形有助于游戏的销售，而游戏则有助于芯片的销售。从芯片制造商的营销角度来看，实时渲染的最佳特性之一是图形处理消耗了大量的处理能力和其他资源。与硬件相关的特性，如帧速率、分辨率和颜色深度也会在一定程度上增加，从而进一步增加负载。虚拟现实应用程序的标准是最低90帧/秒的固定帧率，4k像素的显示器已经在测试图形系统的能力以跟上。</strong></p>
<p><strong>在场景中模拟光线效果的复杂任务本身就足以吸收计算能力。在场景中添加更多的物体或灯光是一种渲染会变得更昂贵的方法。物体的类型(包括固体和体积，如雾)，这些物体表面的描绘方式，以及使用的灯光类型都是一些可能增加复杂性的因素。如果我们能够获取更多的样本，评估更精确的方程，或者仅仅是使用更多的内存，许多算法的质量就会提高。不断增加的复杂性使得图形处理能力几乎成为一个无底洞。</strong></p>
<p><strong>为了解决对长期业绩的担忧，乐观主义者喜欢求助于摩尔定律。这个观察结果给出了每1.5年加速2倍的速度，或者更有用的是每5年加速10倍的速度。然而，处理器速度通常不是瓶颈，而且可能会随着时间的推移而减少。带宽是，因为它每10年增加10倍，而不是5倍。</strong></p>
<p><strong>电影行业的算法经常会在实时渲染中找到自己的方法，因为这两个领域的目标都是生成逼真的图像。看看他们的做法，我们可以看到一些统计数据，比如2016年电影《奇幻森林》的一帧画面中，某些场景中有数百万根头发，渲染时间为30至40小时。虽然GPU是专门为实时渲染而设计的，所以相对于cpu有明显的优势，但从1/(40 × 60 × 60) = 0.00000694 FPS到60 FPS需要7个数量级。</strong></p>
<p><strong>我们承诺了一些预测。“更快更灵活”是一个简单的说法。随着GPU架构的发展，一种可能性是z缓冲区三角形光栅化管道将继续占据主导地位。除了最简单的游戏外，所有游戏都使用GPU进行渲染。即使明天某些不可思议的技术取代了现有的管线，一种速度快一百倍，并且包含下载系统补丁的技术，行业仍需要数年时间才能转向这种新技术。一个问题是，新方法是否可以使用与现有方法完全相同的API。如果没有，领养需要一段时间。一款复杂的游戏需要数千万美元或更多的开发成本，并且需要数年时间才能制作完成。目标平台是在过程的早期选择的，这将决定从算法和使用的着色器，到制作的艺术品的大小和复杂性。除了这些因素之外，还需要制作与这些元素一起工作或生产这些元素所需的工具，用户需要精通这些工具的使用。即使出现了奇迹，目前栅格化流水线背后的动力也给了它几年的寿命。</strong></p>
<p><strong>仍然会发生改变。在现实中，简单的“一个光栅化器统治所有”的想法已经开始消失。在本书中，我们讨论了计算着色器如何能够承担各种任务，证明光栅化几乎不是GPU能提供的唯一服务。如果新技术很有吸引力，那么就会重新调整工作流程，从游戏公司转向商业引擎和内容创造工具。</strong></p>
<p><strong>那么，长期来看呢?用于绘制三角形、访问纹理和混合结果样本的专用固定功能GPU硬件仍然可以极大地提高性能。移动设备的需求改变了这一等式，因为功耗变得和原始性能一样重要。然而，“发射然后忘记”的基本管道概念，即我们将一个三角形发送到管道中，并在该框架中完全完成它，并不是现代渲染引擎中使用的模型。变换、扫描、阴影和混合的基本管道模型已经发展到几乎无法识别的地步。GPU已经成为一个大型的基于流的处理器集群，你可以随心所欲地使用它。</strong></p>
<p><strong>APIi和GPU已经共同进化以适应这一现实。咒语是“灵活性”。方法由研究人员探索，然后由开发人员在现有硬件上实现，确定他们希望的功能。独立的硬件供应商可以利用这些发现和他们自己的研究来开发通用功能，形成一个良性循环。对任何单一算法进行优化都是徒劳的。但在GPU上创建新的、灵活的访问和处理数据的方式却并非如此。</strong></p>
<p><strong>考虑到这一点，我们认为光线/物体相交是一种具有多种用途的通用工具。我们知道，使用路径跟踪的完美无偏采样最终会在场景描述的限制下生成正确的、地面真实的图像。“最终”这个词才是关键所在。正如在第11.7节中所讨论的，作为一种可行的算法，路径跟踪目前面临着严峻的挑战。主要的问题是需要大量的样本来得到一个没有噪声的结果，并且在动画时不会闪烁。也就是说，路径跟踪的纯粹性和简单性使得它非常吸引人。交互呈现的当前状态是多种专门技术为特定情况量身定制，而现在只有一种算法可以完成所有工作。电影制片厂当然已经意识到这一点，因为在过去的十年中，他们已经完全转向光线和路径追踪方法。这样做可以让他们优化一组轻型运输的几何操作。</strong></p>
<p><strong>实时渲染——所有的渲染——最终是关于采样和过滤。除了提高射线发射的效率外，路径跟踪还可以受益于智能采样和滤波。事实上，几乎每一个离线路径追踪者都是有偏见的，不管营销文献。对发送样本射线的位置做出了合理的假设，极大地提高了性能。路径跟踪可以受益的另一个领域是智能过滤。深度学习目前是研究和开发的一个白热化领域，由于2012年的显著进步，它大大超过了图像识别的手工调整算法，人们对它的兴趣开始重新升温。使用神经网络去噪和抗锯齿是令人着迷的发展。参见下图。我们已经看到使用神经网络进行渲染相关任务的研究论文数量大幅上升，更不用说建模和动画了。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116173446.png" class="" title="image-20211116173446">

<p>用神经网络重建图像。左边是用路径跟踪生成的噪声图像。在右侧，图像以交互速率使用GPU加速去噪处理。</p>
<p><strong>可以追溯到1987年AT&amp;T的Pixel Machine，交互式光线追踪长期以来一直适用于小场景、低分辨率、很少的光线，以及只有清晰反射、折射和阴影的组合。微软在DirectX API中添加了射线追踪功能，称为DXR，简化了射线发射的过程，并可能促使硬件供应商增加对射线相交的支持。光线拍摄，通过去噪或其他滤波增强，将首先只是另一种技术，以改善各种元素的渲染质量，如阴影或反射。它将与许多其他算法竞争，每个渲染引擎根据诸如速度、质量和易用性等因素做出选择。参见下图。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116173531.png" class="" title="image-20211116173531">

<p>这些图像以交互速率呈现，每像素有两道反射射线反射，屏幕位置有一道阴影射线反射，两道环境遮挡射线反射，每像素有七道射线反射。阴影和反射使用去噪滤波器。</p>
<p><strong>在撰写本文时，分层射线拍摄作为一种基本操作并不是主流商业GPU的明确组成部分。我们认为PowerVR的Wizard GPU是一个好兆头，因为一家移动设备公司正在考虑通过分层场景描述测试射线的硬件支持。直接支持光线投射的新型GPU将改变效率方程，并可能创建一个良性循环，使各种渲染效果不再那么定制化和专一化。用于眼射线和光线追踪或计算着色器的栅格化几乎是一种方法，已经在各种DXR演示中使用。随着改进的去噪算法，用于追踪光线的更快的GPU，以及以前的研究和新的研究的重新应用，我们期望很快看到相当于10倍的性能改进。</strong></p>
<p><strong>我们希望DXR在其他方面为开发者和研究人员带来福音。对于游戏来说，投射光线的烘焙系统现在可以在GPU上运行并使用类似的功能或者与在交互式渲染器中找到的相同的着色器，以提高性能为结果。地面真实图像可以更容易地生成，使其更容易测试，甚至自动调整算法。架构改变的想法，允许更灵活的生成GPU任务，例如，着色器创建着色工作，似乎是一个强大的，可能有其他应用程序。</strong></p>
<p><strong>当然，GPU的发展还有其他有趣的可能性。另一种理想的世界观是所有的物质都被体素化了。如第13.10节所述，这种表示对于轻传输和模拟有许多优点。需要大量的数据存储，以及场景中动态对象的困难，使得完全切换的可能性极小。尽管如此，我们相信体素可能会得到更多的关注，因为它们在广泛的领域的使用，包括高质量的体积效果，3D打印，和无约束的对象修改(例如，Minecraft)。当然，考虑到自动驾驶汽车系统、激光雷达和其他传感器产生的大量此类数据，点云将成为未来几年更多研究的一部分。带符号距离域(SDFs)是另一种有趣的场景描述方法。与体素类似，SDFs可以对场景进行无约束的修改，也可以加速光线追踪。</strong></p>
<p><strong>有时，给定应用程序的独特约束允许其开发人员“打破常规”，使用以前认为奇异或不可行的技术。《Media Molecule’s Dreams》和《Second Order’s Claybook》(如下图所示)等游戏可以让我们对可能出现的非正统算法主导的渲染前景有一些有趣的了解。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116173700.png" class="" title="image-20211116173700">

<p>《Claybook》是一款基于物理原理的益智游戏，玩家可以自由塑造粘土世界。粘土世界使用签名距离场建模，并使用光线追踪渲染，包括主光线、光线追踪阴影和AO。在GPU上模拟固体和液体物理。</p>
<p><strong>虚拟和混合现实值得一提。当虚拟现实运行良好时，它是令人惊叹的。混合现实具有与现实世界相融合的合成内容的迷人演示。每个人都想要兼具这两种功能的轻量级眼镜，这在短期内可能会被归入“个人喷气背包、水下城市”一类。但谁知道呢?考虑到这些努力背后的大量研究和开发，可能会有一些突破，可能会改变世界。</strong></p>
<h2 id="You-你"><a href="#You-你" class="headerlink" title="You 你"></a>You 你</h2><p><strong>那么，当你和你孩子们的孩子们在等待奇点的时候，你会做什么呢?当然是程序:发现新的算法，创建应用程序，或者做任何你喜欢的事情。几十年前，一台机器的图形硬件比一辆豪华汽车还贵;现在，它被内置在几乎所有有CPU的设备中，这些设备通常可以放在你的手掌中。图形黑客是廉价和主流的。在本节中，我们将介绍各种资源，这些资源对学习实时渲染领域的更多知识非常有用。</strong></p>
<p><strong>这本书不是凭空出现的;它利用了大量的信息来源。如果您对某个特定的算法感兴趣，请跟踪原始的出版物。我们的网站有一个页面，上面有我们参考的所有文章，所以如果有资源的话，你可以在那里找到链接。大多数研究文章都可以使用谷歌Scholar，作者的网站，或者，如果其他方法都失败了，向作者要一份拷贝——几乎每个人都喜欢别人阅读和欣赏他们的作品。如果没有找到免费的服务，例如ACM数字图书馆有大量的文章可用。如果您是SIGGRAPH的成员，您可以自动免费访问他们的许多图形文章和演讲。有几家杂志发表了技术文章，如ACM图形学报(现在包括了SIGGRAPH的议题)，计算机图形技术杂志(开放获取)，IEEE可视化和计算机图形学报，计算机图形论坛，IEEE计算机图形和应用，等等。最后，一些专业的博客有很好的信息，而且Twitter上的图形开发人员和研究人员经常指出很好的新资源。</strong></p>
<p><strong>学习和认识别人的最快方法之一就是参加会议。另一个人正在做你正在做或可能感兴趣的事情的几率很高。如果资金紧张，联系组织者，询问志愿者机会或奖学金。SIGGRAPH和SIGGRAPH亚洲年度会议是新想法的主要场所，但不是唯一的。其他技术集会，如欧洲图形大会和欧洲图形渲染专题讨论会(EGSR)，交互式3D图形和游戏专题讨论会(I3D)，以及高性能图形(HPG)论坛，都展示并发布了大量与实时渲染相关的材料。还有一些针对开发者的会议，如知名的游戏开发者大会(GDC)。在排队或参加活动时，向陌生人问好。在SIGGRAPH上，尤其要留意在你感兴趣的领域里的“物以类聚”(BOF)。与人面对面地交流想法是有益的，也是充满活力的。</strong></p>
<p><strong>有一些与交互呈现相关的电子资源。特别值得注意的是，《Graphics Codex》是一份高质量的纯电子参考文献，具有不断更新的优势。沉浸式线性代数网站，部分由本书的合著者创建，包括交互式演示，以帮助学习这个主题。雪莉在Kindle上有一系列关于光线追踪的短篇书籍。我们期待有更多这类廉价和快速获取的资源。</strong></p>
<p><strong>印刷书籍仍有一席之地。除了一般文本和特定领域的卷，编辑的文章集包括大量的研究和发展信息，其中许多我们在本书中引用。最近的例子是GPU Pro和GPU Zen书籍。早前的书籍如《Game Programming Gems》、《GPU Gems》(免费在线)和《ShaderX》系列仍然有相关文章——算法不会腐烂。所有这些书籍都允许游戏开发者在不写正式会议论文的情况下呈现自己的方法。这样的收集还允许学者们讨论他们工作的技术细节，这些细节不适合在研究论文中。对于专业开发人员来说，阅读一篇文章中找到的实现细节所节省的一个小时，比阅读整本书所花的钱还多。如果你等不及一本书的投递，可以使用亚马逊上的“查看内部”功能，或者在谷歌Books上搜索文本，可以获得一段摘录，让你开始阅读。</strong></p>
<p><strong>当一切都说了并做了之后，就需要编写代码了。随着GitHub、Bitbucket和类似存储库的兴起，可以利用的存储库越来越多。难点在于知道什么不符合斯特金定律。虚幻引擎等产品的源代码是开放的，因此这是一种不可思议的资源。ACM现在鼓励发布任何技术文章的代码。你所尊敬的作者有时会有他们的代码可用。搜索周围。</strong></p>
<p><strong>一个特别值得注意的地方是Shadertoy，它经常在像素着色器中使用光线行进来展示各种技术。虽然许多程序首先是视觉上的糖果，但该网站有许多教育演示，所有代码都是可见的，并且都可以在浏览器中运行。另一个基于浏览器的演示的来源是three.js库和相关站点。“三”是对WebGL的包装，鼓励实验，因为只需要几行代码就可以生成渲染。在网络上发布演示供任何人运行和分析，只需点击超链接，这对于教育用途和分享想法是非常棒的。本书的一位作者基于three.js为Udacity创建了一个介绍性的图形课程。</strong></p>
<p><strong>我们再次向您推荐我们的网站realtimerendering.com。在那里你会找到许多其他资源，比如推荐书目和新书列表(包括一些免费的高质量书籍)，以及有价值的博客、研究网站、课程介绍和许多其他信息来源的链接。寻找快乐!</strong></p>
<p><strong>我们最后的建议是去学习，去做。实时计算机图形学领域在不断发展，新的思想和特征不断被发明和整合。你可以参与其中。使用的广泛的技术似乎令人生畏，但你不需要执行一长串流行词汇来获得良好的结果。基于应用程序的约束和视觉风格，巧妙地结合少量技术，可以产生独特的视觉效果。在GitHub上分享你的结果，它也可以用来管理博客。参与!</strong></p>
<p><strong>这一领域最好的部分之一就是每隔几年就会进行自我改造。计算机体系结构不断变化和改进。几年前不奏效的做法，现在可能值得一试。每一款新的GPU都有不同的功能、速度和内存。什么是有效的，什么是瓶颈会不断变化和发展。即使是那些看起来古老而完善的地方也值得重游。据说创造是一种扭曲、打破和混合其他想法的过程，而不是从无到有。</strong></p>
<p><strong>这一版本是在1974年(1724年)由Sutherland、Sproull和Schumacker发表的计算机图形学领域的里程碑论文之一《十种隐面算法的特征》44年后出版的。他们55页的论文进行了令人难以置信的全面比较。被描述为“贵得离谱”的算法，甚至连研究者的名字都没有提及的蛮力技术，也只是在附录中提到，现在被称为z缓冲区。公平地说，萨瑟兰是z-buffer发明者埃德·卡特穆尔(Ed Catmull)的顾问，他讨论这一概念的论文将在几个月后发表]。</strong></p>
<p><strong>第十一种隐藏表面技术胜出了，因为它易于在硬件上实现，而且内存密度上升，成本下降。萨瑟兰等人所做的“Ter算法”调查在当时是完全有效的。随着条件的变化，所使用的算法也会发生变化。未来几年将会发生什么令人兴奋。当我们回顾当前的渲染技术时代，会有什么感觉?没有人知道，每个人都可能对未来产生重大影响。没有一定要发生的未来，没有一定要发生的过程。你创建它。</strong></p>
<img src="/2023/05/05/Real-Time%20Rendering%204th%20edition/image-20211116174031.png" class="" title="image-20211116174031">

<p><strong>What do you want to do next?</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OSkirito"
      src="/images/head_image.png">
  <p class="site-author-name" itemprop="name">OSkirito</p>
  <div class="site-description" itemprop="description">CG技术的记录与分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oskirito" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oskirito" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OSkirito</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
